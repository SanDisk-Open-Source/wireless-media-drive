From 5a32ba6ff343ddad8837cf859f4e45397ca9249b Mon Sep 17 00:00:00 2001
From: Frank Li <Frank.Li@freescale.com>
Date: Mon, 6 Sep 2010 12:47:23 +0800
Subject: [PATCH] ENGR00127171-1 MX23\MX28: Copy 2.6.31 MSL

31kernel upgrade.
Copy 9fefd36353aeccd32d2531238753d87b705e431e
mach-mx23 mach-mx28 plat-mxs

Signed-off-by: Frank Li <Frank.Li@freescale.com>
---
 arch/arm/configs/imx23evk_defconfig             | 1865 ++++++++++++++++
 arch/arm/configs/imx23evk_updater_defconfig     | 1176 ++++++++++
 arch/arm/configs/imx28evk_defconfig             | 1890 ++++++++++++++++
 arch/arm/configs/imx28evk_updater_defconfig     | 1044 +++++++++
 arch/arm/mach-mx23/Kconfig                      |   25 +
 arch/arm/mach-mx23/Makefile                     |   15 +
 arch/arm/mach-mx23/Makefile.boot                |    3 +
 arch/arm/mach-mx23/bus_freq.c                   |  170 ++
 arch/arm/mach-mx23/clock.c                      | 1596 ++++++++++++++
 arch/arm/mach-mx23/device.c                     | 1015 +++++++++
 arch/arm/mach-mx23/device.h                     |   34 +
 arch/arm/mach-mx23/emi.S                        |  254 +++
 arch/arm/mach-mx23/emi.inc                      |  667 ++++++
 arch/arm/mach-mx23/gpio.c                       |  190 ++
 arch/arm/mach-mx23/include/mach/dma.h           |   59 +
 arch/arm/mach-mx23/include/mach/irqs.h          |  102 +
 arch/arm/mach-mx23/include/mach/lcdif.h         |  441 ++++
 arch/arm/mach-mx23/include/mach/mx23.h          |  111 +
 arch/arm/mach-mx23/include/mach/regs-apbh.h     |  358 +++
 arch/arm/mach-mx23/include/mach/regs-audioin.h  |  287 +++
 arch/arm/mach-mx23/include/mach/regs-audioout.h |  518 +++++
 arch/arm/mach-mx23/include/mach/regs-emi.h      |  234 ++
 arch/arm/mach-mx23/include/mach/regs-i2c.h      |  383 ++++
 arch/arm/mach-mx23/include/mach/regs-lcdif.h    |  650 ++++++
 arch/arm/mach-mx23/include/mach/regs-lradc.h    |  669 ++++++
 arch/arm/mach-mx23/include/mach/regs-ocotp.h    |  311 +++
 arch/arm/mach-mx23/include/mach/regs-power.h    |  564 +++++
 arch/arm/mach-mx23/include/mach/regs-pwm.h      |  135 ++
 arch/arm/mach-mx23/include/mach/regs-pxp.h      |  517 +++++
 arch/arm/mach-mx23/include/mach/regs-rtc.h      |  219 ++
 arch/arm/mach-mx23/include/mach/regs-ssp.h      |  392 ++++
 arch/arm/mach-mx23/include/mach/regs-timrot.h   |  257 +++
 arch/arm/mach-mx23/include/mach/regulator.h     |   30 +
 arch/arm/mach-mx23/mx23_pins.h                  |  156 ++
 arch/arm/mach-mx23/mx23evk.c                    |  156 ++
 arch/arm/mach-mx23/mx23evk.h                    |   32 +
 arch/arm/mach-mx23/mx23evk_pins.c               |  939 ++++++++
 arch/arm/mach-mx23/otp.c                        |  437 ++++
 arch/arm/mach-mx23/pinctrl.c                    |  161 ++
 arch/arm/mach-mx23/pm.c                         |  651 ++++++
 arch/arm/mach-mx23/power.c                      |  523 +++++
 arch/arm/mach-mx23/regs-clkctrl.h               |  442 ++++
 arch/arm/mach-mx23/regs-digctl.h                |  724 ++++++
 arch/arm/mach-mx23/regs-dram.h                  |  890 ++++++++
 arch/arm/mach-mx23/regs-pinctrl.h               | 1879 ++++++++++++++++
 arch/arm/mach-mx23/serial.c                     |  161 ++
 arch/arm/mach-mx23/sleep.S                      |  553 +++++
 arch/arm/mach-mx23/sleep.h                      |  125 ++
 arch/arm/mach-mx23/usb.h                        |  109 +
 arch/arm/mach-mx23/usb_dr.c                     |  171 ++
 arch/arm/mach-mx28/Kconfig                      |   20 +
 arch/arm/mach-mx28/Makefile                     |   15 +
 arch/arm/mach-mx28/Makefile.boot                |    3 +
 arch/arm/mach-mx28/bus_freq.c                   |  178 ++
 arch/arm/mach-mx28/clock.c                      | 1774 +++++++++++++++
 arch/arm/mach-mx28/device.c                     | 1508 +++++++++++++
 arch/arm/mach-mx28/device.h                     |   34 +
 arch/arm/mach-mx28/emi.S                        |  220 ++
 arch/arm/mach-mx28/emi_settings.c               |  680 ++++++
 arch/arm/mach-mx28/emi_settings.h               |   37 +
 arch/arm/mach-mx28/gpio.c                       |  196 ++
 arch/arm/mach-mx28/include/mach/dma.h           |   59 +
 arch/arm/mach-mx28/include/mach/lcdif.h         |  276 +++
 arch/arm/mach-mx28/include/mach/mx28.h          |  245 +++
 arch/arm/mach-mx28/include/mach/regs-apbh.h     |  535 +++++
 arch/arm/mach-mx28/include/mach/regs-i2c.h      |  498 +++++
 arch/arm/mach-mx28/include/mach/regs-icoll.h    |  293 +++
 arch/arm/mach-mx28/include/mach/regs-lcdif.h    |  680 ++++++
 arch/arm/mach-mx28/include/mach/regs-lradc.h    |  772 +++++++
 arch/arm/mach-mx28/include/mach/regs-power.h    |  683 ++++++
 arch/arm/mach-mx28/include/mach/regs-pwm.h      |  147 ++
 arch/arm/mach-mx28/include/mach/regs-pxp.h      |  518 +++++
 arch/arm/mach-mx28/include/mach/regs-rtc.h      |  226 ++
 arch/arm/mach-mx28/include/mach/regs-ssp.h      |  474 ++++
 arch/arm/mach-mx28/include/mach/regs-timrot.h   |  293 +++
 arch/arm/mach-mx28/include/mach/regulator.h     |   30 +
 arch/arm/mach-mx28/mx28_pins.h                  |  164 ++
 arch/arm/mach-mx28/mx28evk.c                    |  129 ++
 arch/arm/mach-mx28/mx28evk.h                    |   25 +
 arch/arm/mach-mx28/mx28evk_pins.c               | 1139 ++++++++++
 arch/arm/mach-mx28/pinctrl.c                    |  175 ++
 arch/arm/mach-mx28/pm.c                         |  344 +++
 arch/arm/mach-mx28/power.c                      |  536 +++++
 arch/arm/mach-mx28/regs-clkctrl.h               |  635 ++++++
 arch/arm/mach-mx28/regs-digctl.h                | 1022 +++++++++
 arch/arm/mach-mx28/regs-dram.h                  | 2505 +++++++++++++++++++++
 arch/arm/mach-mx28/regs-pinctrl.h               | 2673 +++++++++++++++++++++++
 arch/arm/mach-mx28/serial.c                     |  309 +++
 arch/arm/mach-mx28/sleep.S                      |  420 ++++
 arch/arm/mach-mx28/sleep.h                      |  125 ++
 arch/arm/mach-mx28/usb.h                        |  109 +
 arch/arm/mach-mx28/usb_dr.c                     |  160 ++
 arch/arm/mach-mx28/usb_h1.c                     |   81 +
 arch/arm/plat-mxs/Kconfig                       |  177 ++
 arch/arm/plat-mxs/Makefile                      |   24 +
 arch/arm/plat-mxs/clock.c                       |  325 +++
 arch/arm/plat-mxs/core.c                        |  137 ++
 arch/arm/plat-mxs/cpufreq.c                     |  527 +++++
 arch/arm/plat-mxs/device.c                      |  795 +++++++
 arch/arm/plat-mxs/dma-apbh.c                    |  243 ++
 arch/arm/plat-mxs/dma-apbx.c                    |  202 ++
 arch/arm/plat-mxs/dmaengine.c                   |  645 ++++++
 arch/arm/plat-mxs/gpio.c                        |  225 ++
 arch/arm/plat-mxs/icoll.c                       |  141 ++
 arch/arm/plat-mxs/include/mach/arc_otg.h        |  174 ++
 arch/arm/plat-mxs/include/mach/bus_freq.h       |   46 +
 arch/arm/plat-mxs/include/mach/clkdev.h         |   25 +
 arch/arm/plat-mxs/include/mach/clock.h          |  127 ++
 arch/arm/plat-mxs/include/mach/ddi_bc.h         |  715 ++++++
 arch/arm/plat-mxs/include/mach/debug-macro.S    |   42 +
 arch/arm/plat-mxs/include/mach/device.h         |  221 ++
 arch/arm/plat-mxs/include/mach/dmaengine.h      |  495 +++++
 arch/arm/plat-mxs/include/mach/entry-macro.S    |   36 +
 arch/arm/plat-mxs/include/mach/fsl_usb.h        |   74 +
 arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h |   46 +
 arch/arm/plat-mxs/include/mach/gpio.h           |   63 +
 arch/arm/plat-mxs/include/mach/hardware.h       |   53 +
 arch/arm/plat-mxs/include/mach/io.h             |   38 +
 arch/arm/plat-mxs/include/mach/irqs.h           |   44 +
 arch/arm/plat-mxs/include/mach/lradc.h          |   61 +
 arch/arm/plat-mxs/include/mach/memory.h         |   68 +
 arch/arm/plat-mxs/include/mach/pinctrl.h        |  152 ++
 arch/arm/plat-mxs/include/mach/power.h          |   64 +
 arch/arm/plat-mxs/include/mach/system.h         |   30 +
 arch/arm/plat-mxs/include/mach/timex.h          |   23 +
 arch/arm/plat-mxs/include/mach/uncompress.h     |   56 +
 arch/arm/plat-mxs/include/mach/unique-id.h      |   30 +
 arch/arm/plat-mxs/include/mach/vmalloc.h        |   19 +
 arch/arm/plat-mxs/iram.c                        |   67 +
 arch/arm/plat-mxs/lradc.c                       |  385 ++++
 arch/arm/plat-mxs/pinctrl.c                     |  215 ++
 arch/arm/plat-mxs/regs-apbx.h                   |  433 ++++
 arch/arm/plat-mxs/regs-icoll.h                  |  293 +++
 arch/arm/plat-mxs/regs-usbphy.h                 |  323 +++
 arch/arm/plat-mxs/timer-match.c                 |  164 ++
 arch/arm/plat-mxs/timer-nomatch.c               |  194 ++
 arch/arm/plat-mxs/unique-id.c                   |  198 ++
 arch/arm/plat-mxs/usb_common.c                  |  381 ++++
 arch/arm/plat-mxs/utmixc.c                      |   89 +
 139 files changed, 54120 insertions(+), 0 deletions(-)

diff --git a/arch/arm/configs/imx23evk_defconfig b/arch/arm/configs/imx23evk_defconfig
new file mode 100644
index 0000000..d65c1fb
--- /dev/null
+++ b/arch/arm/configs/imx23evk_defconfig
@@ -0,0 +1,1865 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Mon May 24 17:09:02 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_FIQ=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=12
+CONFIG_VECTORS_PHY_ADDR=0
+
+#
+# Freescale i.MXS implementations
+#
+# CONFIG_ARCH_MX28 is not set
+CONFIG_ARCH_MX23=y
+CONFIG_MACH_MX23EVK=y
+CONFIG_MXS_UNIQUE_ID=y
+CONFIG_MXS_UNIQUE_ID_OTP=y
+CONFIG_MXS_ICOLL=y
+CONFIG_MXS_EARLY_CONSOLE=y
+CONFIG_MXS_DMA_ENGINE=y
+CONFIG_MXS_LRADC=y
+CONFIG_MXS_PWM_CHANNELS=8
+
+#
+# Freescale Application UART:
+#
+CONFIG_MXS_AUART_DMA_SUPPORT=y
+CONFIG_MXS_AUART_PORTS=5
+# CONFIG_MXS_AUART0_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART0_DMA_ENABLE is not set
+CONFIG_MXS_AUART1_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART1_DMA_ENABLE is not set
+# CONFIG_MXS_AUART2_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART2_DMA_ENABLE is not set
+# CONFIG_MXS_AUART3_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART3_DMA_ENABLE is not set
+# CONFIG_MXS_AUART4_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART4_DMA_ENABLE is not set
+CONFIG_MXS_RAM_FREQ_SCALING=y
+# CONFIG_MXS_RAM_MDDR is not set
+CONFIG_MXS_RAM_DDR=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyAM0,115200 root=/dev/mmcblk0p2 rootwait lcd_panel=lms350"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_ARPD=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MXC_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NFC=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLOCK=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+CONFIG_MXS_PERSISTENT=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_MII is not set
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+CONFIG_ENC28J60=y
+# CONFIG_ENC28J60_WRITEVERIFY is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=320
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=240
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXS=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXS=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_MXS_VIIM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXS_DUART=y
+CONFIG_SERIAL_MXS_AUART=y
+CONFIG_SERIAL_MXS_DUART_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MXS=y
+CONFIG_I2C_MXS_SELECT0=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXS=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_BATTERY_MXS=y
+# CONFIG_MXS_VBUS_CURRENT_DRAW is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_MXC_MMA7450=m
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXS_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXS_PXP=y
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXS=y
+# CONFIG_FB_MXS_LCD_43WVF1G is not set
+CONFIG_FB_MXS_LCD_LMS430=y
+# CONFIG_FB_MXS_TVENC is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_MXS=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SPI=y
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_MXS_SOC=y
+CONFIG_SND_MXS_SOC_EVK_ADC=y
+CONFIG_SND_MXS_SOC_ADC=y
+# CONFIG_SND_MXS_SOC_EVK_DEVB_SPDIF is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_MXS_ADC_CODEC=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_STATIC_IRAM is not set
+# CONFIG_USB_EHCI_FSL_MC13783 is not set
+# CONFIG_USB_EHCI_FSL_1301 is not set
+# CONFIG_USB_EHCI_FSL_1504 is not set
+CONFIG_USB_EHCI_FSL_UTMI=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=m
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_FSL_UTP is not set
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_CDC_COMPOSITE=m
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MXC_OTG is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+CONFIG_MMC_MXS=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_MXS=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MXS=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_ICEDCC is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+# CONFIG_SECURITY_TOMOYO is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CRYPTODEV=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_DCP=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/configs/imx23evk_updater_defconfig b/arch/arm/configs/imx23evk_updater_defconfig
new file mode 100644
index 0000000..739e7bd
--- /dev/null
+++ b/arch/arm/configs/imx23evk_updater_defconfig
@@ -0,0 +1,1176 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Thu May  6 16:41:59 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_FIQ=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-updater"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+CONFIG_RELAY=y
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=12
+CONFIG_VECTORS_PHY_ADDR=0
+
+#
+# Freescale i.MXS implementations
+#
+# CONFIG_ARCH_MX28 is not set
+CONFIG_ARCH_MX23=y
+CONFIG_MACH_MX23EVK=y
+CONFIG_MXS_ICOLL=y
+CONFIG_MXS_EARLY_CONSOLE=y
+CONFIG_MXS_DMA_ENGINE=y
+CONFIG_MXS_LRADC=y
+CONFIG_MXS_PWM_CHANNELS=8
+
+#
+# Freescale Application UART:
+#
+CONFIG_MXS_AUART_DMA_SUPPORT=y
+CONFIG_MXS_AUART_PORTS=5
+# CONFIG_MXS_AUART0_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART0_DMA_ENABLE is not set
+CONFIG_MXS_AUART1_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART1_DMA_ENABLE is not set
+# CONFIG_MXS_AUART2_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART2_DMA_ENABLE is not set
+# CONFIG_MXS_AUART3_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART3_DMA_ENABLE is not set
+# CONFIG_MXS_AUART4_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART4_DMA_ENABLE is not set
+CONFIG_MXS_RAM_FREQ_SCALING=y
+# CONFIG_MXS_RAM_MDDR is not set
+CONFIG_MXS_RAM_DDR=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyAM0,115200 rdinit=/linuxrc"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_SUSPEND is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+# CONFIG_MTD_CFI_AMDSTD is not set
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NFC=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=128
+CONFIG_MTD_UBI_BEB_RESERVE=2
+CONFIG_MTD_UBI_GLUEBI=y
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+CONFIG_MXS_PERSISTENT=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MXS_VIIM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXS_DUART=y
+CONFIG_SERIAL_MXS_AUART=y
+CONFIG_SERIAL_MXS_DUART_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXS=y
+# CONFIG_FB_MXS_LCD_43WVF1G is not set
+CONFIG_FB_MXS_LCD_LMS430=y
+# CONFIG_FB_MXS_TVENC is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_ILI9320 is not set
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_MXS=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=y
+CONFIG_FSL_UTP=y
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+CONFIG_MMC_MXS=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_MXS=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_MXS=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+# CONFIG_UBIFS_FS_ZLIB is not set
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_DCP is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/configs/imx28evk_defconfig b/arch/arm/configs/imx28evk_defconfig
new file mode 100644
index 0000000..40c35b6
--- /dev/null
+++ b/arch/arm/configs/imx28evk_defconfig
@@ -0,0 +1,1890 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Tue Jun  8 11:22:27 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_FIQ=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+CONFIG_AUDIT=y
+
+#
+# RCU Subsystem
+#
+# CONFIG_CLASSIC_RCU is not set
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=16
+CONFIG_VECTORS_PHY_ADDR=0
+
+#
+# Freescale i.MXS implementations
+#
+CONFIG_ARCH_MX28=y
+# CONFIG_ARCH_MX23 is not set
+CONFIG_MACH_MX28EVK=y
+CONFIG_MXS_TIMER_WITH_MACH=y
+CONFIG_MXS_ICOLL=y
+CONFIG_MXS_EARLY_CONSOLE=y
+CONFIG_MXS_DMA_ENGINE=y
+CONFIG_MXS_LRADC=y
+CONFIG_MXS_PWM_CHANNELS=8
+
+#
+# Freescale Application UART:
+#
+CONFIG_MXS_AUART_DMA_SUPPORT=y
+CONFIG_MXS_AUART_PORTS=5
+CONFIG_MXS_AUART0_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART0_DMA_ENABLE is not set
+CONFIG_MXS_AUART1_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART1_DMA_ENABLE is not set
+CONFIG_MXS_AUART2_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART2_DMA_ENABLE is not set
+CONFIG_MXS_AUART3_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART3_DMA_ENABLE is not set
+CONFIG_MXS_AUART4_DEVICE_ENABLE=y
+# CONFIG_MXS_AUART4_DMA_ENABLE is not set
+CONFIG_MXS_RAM_FREQ_SCALING=y
+# CONFIG_MXS_RAM_MDDR is not set
+# CONFIG_MXS_RAM_DDR is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETLABEL is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+# CONFIG_CAN_BCM is not set
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_DEV is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+CONFIG_CAN_FLEXCAN=m
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NFC=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+CONFIG_MTD_UBI_BLOCK=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+CONFIG_MXS_PERSISTENT=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=m
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+CONFIG_FEC=y
+# CONFIG_FEC_1588 is not set
+# CONFIG_FEC2 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXS=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+CONFIG_MOUSE_VSXXXAA=m
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+CONFIG_TOUCHSCREEN_GUNZE=m
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXS=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=m
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_RIO is not set
+CONFIG_STALDRV=y
+CONFIG_MXS_VIIM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXS_DUART=y
+CONFIG_SERIAL_MXS_AUART=y
+CONFIG_SERIAL_MXS_DUART_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_IPMI_HANDLER=m
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_IPMI_SI=m
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=8192
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MXS=y
+CONFIG_I2C_MXS_SELECT0=y
+# CONFIG_I2C_MXS_SELECT0_PIOQUEUE_MODE is not set
+# CONFIG_I2C_MXS_SELECT1 is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_BATTERY_MXS=y
+# CONFIG_MXS_VBUS_CURRENT_DRAW is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXS_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+# CONFIG_SSB_DEBUG is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_VIDEO_ALLOW_V4L1 is not set
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXS_PXP=y
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXS=y
+CONFIG_FB_MXS_LCD_43WVF1G=y
+# CONFIG_FB_MXS_LCD_LMS430 is not set
+# CONFIG_FB_MXS_TVENC is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_MXS=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_MXS_SOC=y
+CONFIG_SND_MXS_SOC_SPDIF_DAI=y
+CONFIG_SND_MXS_SOC_EVK_DEVB=y
+CONFIG_SND_MXS_SOC_DAI=y
+CONFIG_SND_MXS_SOC_EVK_DEVB_SPDIF=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_SGTL5000=y
+CONFIG_SND_SOC_MXS_SPDIF=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H1=y
+# CONFIG_USB_EHCI_ARC_OTG is not set
+# CONFIG_USB_STATIC_IRAM is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=m
+CONFIG_WORKAROUND_ARCUSB_REG_RW=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_FSL_UTP is not set
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MXC_OTG is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+CONFIG_MMC_MXS=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_MXS=y
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_MXS=y
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MXS=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+# CONFIG_INOTIFY is not set
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+CONFIG_QUOTA_TREE=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+CONFIG_CRAMFS=m
+# CONFIG_SQUASHFS is not set
+CONFIG_VXFS_FS=m
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_STACKTRACE=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+CONFIG_LSM_MMAP_MIN_ADDR=65536
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+# CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX is not set
+# CONFIG_SECURITY_TOMOYO is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CRYPTODEV=y
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_DCP=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/configs/imx28evk_updater_defconfig b/arch/arm/configs/imx28evk_updater_defconfig
new file mode 100644
index 0000000..21223ed
--- /dev/null
+++ b/arch/arm/configs/imx28evk_updater_defconfig
@@ -0,0 +1,1044 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_FIQ=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-updater"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+
+#
+# RCU Subsystem
+#
+# CONFIG_CLASSIC_RCU is not set
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=16
+CONFIG_VECTORS_PHY_ADDR=0
+
+#
+# Freescale i.MXS implementations
+#
+CONFIG_ARCH_MX28=y
+# CONFIG_ARCH_MX23 is not set
+CONFIG_MACH_MX28EVK=y
+CONFIG_MXS_TIMER_WITH_MACH=y
+CONFIG_MXS_ICOLL=y
+CONFIG_MXS_EARLY_CONSOLE=y
+CONFIG_MXS_DMA_ENGINE=y
+CONFIG_MXS_LRADC=y
+CONFIG_MXS_PWM_CHANNELS=8
+
+#
+# Freescale Application UART:
+#
+CONFIG_MXS_AUART_DMA_SUPPORT=y
+CONFIG_MXS_AUART_PORTS=5
+# CONFIG_MXS_AUART0_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART0_DMA_ENABLE is not set
+# CONFIG_MXS_AUART1_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART1_DMA_ENABLE is not set
+# CONFIG_MXS_AUART2_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART2_DMA_ENABLE is not set
+# CONFIG_MXS_AUART3_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART3_DMA_ENABLE is not set
+# CONFIG_MXS_AUART4_DEVICE_ENABLE is not set
+# CONFIG_MXS_AUART4_DMA_ENABLE is not set
+CONFIG_MXS_RAM_FREQ_SCALING=y
+# CONFIG_MXS_RAM_MDDR is not set
+# CONFIG_MXS_RAM_DDR is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyAM0,115200 rdinit=/linuxrc"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_FPE_NWFPE is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NFC=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_DEVKMEM is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MXS_VIIM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXS_DUART=y
+# CONFIG_SERIAL_MXS_AUART is not set
+CONFIG_SERIAL_MXS_DUART_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_UNIX98_PTYS is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_I2C is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_FB_MXS_TVENC is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=y
+CONFIG_WORKAROUND_ARCUSB_REG_RW=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=y
+CONFIG_FSL_UTP=y
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+CONFIG_MMC_MXS=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+CONFIG_REGULATOR_MXS=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4DEV_COMPAT=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FSNOTIFY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_DCP is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx23/Kconfig b/arch/arm/mach-mx23/Kconfig
new file mode 100644
index 0000000..28009b0
--- /dev/null
+++ b/arch/arm/mach-mx23/Kconfig
@@ -0,0 +1,25 @@
+choice
+	prompt "Select i.MXS board type"
+
+config MACH_MX23EVK
+	bool "Freescale MX23 EVK board"
+	depends on ARCH_MX23
+	select USB_ARCH_HAS_EHCI
+
+endchoice
+
+
+config MXS_UNIQUE_ID
+	bool "Support for UniqueID on boot media"
+	default y
+
+config MXS_UNIQUE_ID_OTP
+	bool "UniqueID on OTP"
+	depends on MXS_UNIQUE_ID
+	default y
+
+config VECTORS_PHY_ADDR
+	int "vectors address"
+	default 0
+	help
+	  This config set vectors table is located which physical address
diff --git a/arch/arm/mach-mx23/Makefile b/arch/arm/mach-mx23/Makefile
new file mode 100644
index 0000000..a5e2781
--- /dev/null
+++ b/arch/arm/mach-mx23/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux kernel.
+#
+obj-y += pinctrl.o clock.o device.o serial.o power.o pm.o sleep.o bus_freq.o
+
+# Board select
+obj-$(CONFIG_MACH_MX23EVK) += mx23evk.o mx23evk_pins.o
+obj-$(CONFIG_GENERIC_GPIO) += gpio.o
+obj-$(CONFIG_MXS_RAM_FREQ_SCALING) +=emi.o
+obj-$(CONFIG_MXS_UNIQUE_ID_OTP)    += otp.o
+
+# USB support
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y   += usb_dr.o
+endif
diff --git a/arch/arm/mach-mx23/Makefile.boot b/arch/arm/mach-mx23/Makefile.boot
new file mode 100644
index 0000000..1568ad4
--- /dev/null
+++ b/arch/arm/mach-mx23/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x40008000
+params_phys-y	:= 0x40000100
+initrd_phys-y	:= 0x40800000
diff --git a/arch/arm/mach-mx23/bus_freq.c b/arch/arm/mach-mx23/bus_freq.c
new file mode 100644
index 0000000..9133e6b
--- /dev/null
+++ b/arch/arm/mach-mx23/bus_freq.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module.
+ *
+ * @ingroup PM
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include <mach/bus_freq.h>
+
+#include "regs-clkctrl.h"
+#include "regs-digctl.h"
+
+#define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define DIGCTRL_BASE_ADDR IO_ADDRESS(DIGCTL_PHYS_ADDR)
+#define BF(value, field) (((value) << BP_##field) & BM_##field)
+
+struct profile profiles[] = {
+	{ 454736, 151580, 130910, 0, 1550000,
+	1450000, 355000, 3300000, 1750000, 24000, 0 },
+	{ 392727, 130910, 130910, 0, 1450000,
+	1375000, 225000, 3300000, 1750000, 24000, 0x1CF3 },
+	{ 360000, 120000, 130910, 0, 1375000,
+	1275000, 200000, 3300000, 1750000, 24000, 0x1CF3 },
+	{ 261818, 130910, 130910, 0, 1275000,
+	1175000, 173000, 3300000, 1750000, 24000, 0x1CF3 },
+#ifdef CONFIG_MXS_RAM_MDDR
+	{  64000,  64000,  48000, 3, 1050000,
+	975000, 150000, 3300000, 1750000, 24000, 0x1CF3 },
+	{  24000,  24000,  24000, 3, 1050000,
+	975000, 150000, 3075000, 1725000, 6000, 0x1C93 },
+#else
+	{  64000,  64000,  96000, 3, 1050000,
+	975000, 150000, 3300000, 1750000, 24000, 0x1CF3 },
+	{  24000,  24000,  96000, 3, 1050000,
+	975000, 150000, 3300000, 1725000, 6000, 0x1C93 },
+#endif
+};
+
+static struct clk *usb_clk;
+static struct clk *lcdif_clk;
+
+int low_freq_used(void)
+{
+	if ((clk_get_usecount(usb_clk) == 0)
+	    && (clk_get_usecount(lcdif_clk) == 0))
+		return 1;
+	else
+		return 0;
+}
+
+int is_hclk_autoslow_ok(void)
+{
+	if (clk_get_usecount(usb_clk) == 0)
+		return 1;
+	else
+		return 0;
+}
+
+int timing_ctrl_rams(int ss)
+{
+	__raw_writel(BF(ss, DIGCTL_ARMCACHE_VALID_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_DRTY_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_CACHE_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_DTAG_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_ITAG_SS),
+				      DIGCTRL_BASE_ADDR + HW_DIGCTL_ARMCACHE);
+	return 0;
+}
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	usb_clk = clk_get(NULL, "usb_clk0");
+	if (IS_ERR(usb_clk)) {
+		ret = PTR_ERR(usb_clk);
+		goto out_usb;
+	}
+
+	lcdif_clk = clk_get(NULL, "lcdif");
+	if (IS_ERR(lcdif_clk)) {
+		ret = PTR_ERR(lcdif_clk);
+		goto out_lcd;
+	}
+	return 0;
+
+out_lcd:
+	clk_put(usb_clk);
+out_usb:
+	return ret;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		},
+	.probe = busfreq_probe,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx23/clock.c b/arch/arm/mach-mx23/clock.c
new file mode 100644
index 0000000..9e18dbc
--- /dev/null
+++ b/arch/arm/mach-mx23/clock.c
@@ -0,0 +1,1596 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/iram_alloc.h>
+#include <linux/platform_device.h>
+
+#include <mach/clock.h>
+
+#include "regs-clkctrl.h"
+#include "regs-digctl.h"
+
+#include <mach/regs-rtc.h>
+#include <mach/mx23.h>
+
+#define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define DIGCTRL_BASE_ADDR IO_ADDRESS(DIGCTL_PHYS_ADDR)
+#define RTC_BASE_ADDR IO_ADDRESS(RTC_PHYS_ADDR)
+
+/* these are the maximum clock speeds that have been
+ * validated to run at the minumum VddD target voltage level for cpu operation
+ * (presently 1.05V target, .975V Brownout).  Higher clock speeds for GPMI and
+ * SSP have not been validated.
+ */
+#define PLL_ENABLED_MAX_CLK_SSP 96000000
+#define PLL_ENABLED_MAX_CLK_GPMI 96000000
+
+
+/* external clock input */
+static struct clk pll_clk;
+static struct clk ref_xtal_clk;
+
+#ifdef DEBUG
+static void print_ref_counts(void);
+#endif
+
+static unsigned long enet_mii_phy_rate;
+
+static inline int clk_is_busy(struct clk *clk)
+{
+	if ((clk->parent == &ref_xtal_clk) && (clk->xtal_busy_bits))
+		return __raw_readl(clk->busy_reg) & (1 << clk->xtal_busy_bits);
+	else if (clk->busy_bits && clk->busy_reg)
+		return __raw_readl(clk->busy_reg) & (1 << clk->busy_bits);
+	else {
+		printk(KERN_ERR "WARNING: clock has no assigned busy \
+			register or bits\n");
+		udelay(10);
+		return 0;
+	}
+}
+
+static inline int clk_busy_wait(struct clk *clk)
+{
+	int i;
+
+	for (i = 10000000; i; i--)
+		if (!clk_is_busy(clk))
+			break;
+	if (!i)
+		return -ETIMEDOUT;
+	else
+		return 0;
+}
+
+static bool mx23_enable_h_autoslow(bool enable)
+{
+	bool currently_enabled;
+
+	if (__raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_HBUS) &
+		BM_CLKCTRL_HBUS_AUTO_SLOW_MODE)
+		currently_enabled = true;
+	else
+		currently_enabled = false;
+
+	if (enable)
+		__raw_writel(BM_CLKCTRL_HBUS_AUTO_SLOW_MODE,
+			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_SET);
+	else
+		__raw_writel(BM_CLKCTRL_HBUS_AUTO_SLOW_MODE,
+			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);
+	return currently_enabled;
+}
+
+
+static void mx23_set_hbus_autoslow_flags(u16 mask)
+{
+	u32 reg;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	reg &= 0xFFFF;
+	reg |= mask << 16;
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+}
+
+static void local_clk_disable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->ref)
+		return;
+
+	if ((--clk->ref) & CLK_EN_MASK)
+		return;
+
+	if (clk->disable)
+		clk->disable(clk);
+	local_clk_disable(clk->secondary);
+	local_clk_disable(clk->parent);
+}
+
+static int local_clk_enable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	if ((clk->ref++) & CLK_EN_MASK)
+		return 0;
+	if (clk->parent)
+		local_clk_enable(clk->parent);
+	if (clk->secondary)
+		local_clk_enable(clk->secondary);
+	if (clk->enable)
+		clk->enable(clk);
+	return 0;
+}
+
+
+static bool mx23_is_clk_enabled(struct clk *clk)
+{
+	if (clk->enable_reg)
+		return (__raw_readl(clk->enable_reg) &
+				clk->enable_bits) ? 0 : 1;
+	else
+		return (clk->ref & CLK_EN_MASK) ? 1 : 0;
+}
+
+
+static int mx23_raw_enable(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk->enable_reg) {
+		reg = __raw_readl(clk->enable_reg);
+		reg &= ~clk->enable_bits;
+		__raw_writel(reg, clk->enable_reg);
+	}
+	if (clk->busy_reg)
+		clk_busy_wait(clk);
+
+	return 0;
+}
+
+static void mx23_raw_disable(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk->enable_reg) {
+		reg = __raw_readl(clk->enable_reg);
+		reg |= clk->enable_bits;
+		__raw_writel(reg, clk->enable_reg);
+	}
+}
+
+static unsigned long ref_xtal_get_rate(struct clk *clk)
+{
+	return 24000000;
+}
+
+static struct clk ref_xtal_clk = {
+	.flags = RATE_FIXED,
+	.get_rate = ref_xtal_get_rate,
+};
+
+static unsigned long pll_get_rate(struct clk *clk);
+static int pll_enable(struct clk *clk);
+static void pll_disable(struct clk *clk);
+
+static struct clk pll_clk = {
+
+	 .parent = &ref_xtal_clk,
+	 .flags = RATE_FIXED,
+	 .get_rate = pll_get_rate,
+	 .enable = pll_enable,
+	 .disable = pll_disable,
+
+};
+
+static unsigned long pll_get_rate(struct clk *clk)
+{
+	return 480000000;
+}
+
+static int pll_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0);
+
+	if ((reg & BM_CLKCTRL_PLLCTRL0_POWER) &&
+		(reg & BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS))
+		return 0;
+
+	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |
+			     BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_SET);
+	/* only a 10us delay is need.  PLLCTRL1 LOCK bitfied is only a timer
+	 * and is incorrect (excessive).  Per definition of the PLLCTRL0
+	 * POWER field, waiting at least 10us.
+	 */
+	udelay(10);
+
+	return 0;
+}
+
+static void pll_disable(struct clk *clk)
+{
+	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER |
+			     BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLLCTRL0_CLR);
+	return;
+}
+
+static inline unsigned long
+ref_clk_get_rate(unsigned long base, unsigned int div)
+{
+	unsigned long rate = base / 1000;
+	return 1000 * ((rate * 18) / div);
+}
+
+static unsigned long ref_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long base = clk->parent->get_rate(clk->parent);
+	unsigned long div = (base  * 18) / rate;
+	return (base / div) * 18;
+}
+
+static int ref_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long base = clk->parent->get_rate(clk->parent);
+	unsigned long div = ((base/1000)  * 18) / (rate/1000);
+	if (rate != ((base / div) * 18))
+		return -EINVAL;
+	if (clk->scale_reg == 0)
+		return -EINVAL;
+	base = __raw_readl(clk->scale_reg);
+	base &= ~(0x3F << clk->scale_bits);
+	base |= (div << clk->scale_bits);
+	__raw_writel(base, clk->scale_reg);
+	return 0;
+}
+
+static unsigned long ref_cpu_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC) &
+	    BM_CLKCTRL_FRAC_CPUFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_cpu_clk = {
+	.parent = &pll_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.get_rate = ref_cpu_get_rate,
+	.round_rate = ref_clk_round_rate,
+	.set_rate = ref_clk_set_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.enable_bits = BM_CLKCTRL_FRAC_CLKGATECPU,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.scale_bits = BP_CLKCTRL_FRAC_CPUFRAC,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU,
+	.busy_bits	= 28,
+};
+
+static unsigned long ref_emi_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC) &
+	    BM_CLKCTRL_FRAC_EMIFRAC;
+	reg >>= BP_CLKCTRL_FRAC_EMIFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_emi_clk = {
+	.parent = &pll_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.get_rate = ref_emi_get_rate,
+	.set_rate = ref_clk_set_rate,
+	.round_rate = ref_clk_round_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.enable_bits = BM_CLKCTRL_FRAC_CLKGATEEMI,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.scale_bits = BP_CLKCTRL_FRAC_EMIFRAC,
+};
+
+static unsigned long ref_io_get_rate(struct clk *clk);
+static struct clk ref_io_clk = {
+	.parent = &pll_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.get_rate = ref_io_get_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.enable_bits = BM_CLKCTRL_FRAC_CLKGATEIO,
+};
+
+static unsigned long ref_io_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC) &
+			BM_CLKCTRL_FRAC_IOFRAC;
+	reg >>= BP_CLKCTRL_FRAC_IOFRAC;
+
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static unsigned long ref_pix_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC) &
+	    BM_CLKCTRL_FRAC_PIXFRAC;
+	reg >>= BP_CLKCTRL_FRAC_PIXFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_pix_clk = {
+	.parent = &pll_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.get_rate = ref_pix_get_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.enable_bits = BM_CLKCTRL_FRAC_CLKGATEPIX,
+};
+
+static struct clk cpu_clk, h_clk;
+static int clkseq_set_parent(struct clk *clk, struct clk *parent)
+{
+	int shift;
+
+	if (clk->parent == parent)
+		return 0;  /* clock parent already at target.  nothing to do */
+	/* bypass? */
+	if (parent == &ref_xtal_clk)
+		shift = 4;
+	else
+		shift = 8;
+
+	if (clk->bypass_reg)
+		__raw_writel(1 << clk->bypass_bits, clk->bypass_reg + shift);
+
+	return 0;
+}
+
+static unsigned long lcdif_get_rate(struct clk *clk)
+{
+	long rate = clk->parent->get_rate(clk->parent);
+	long div;
+	const int mask = 0xff;
+
+	div = (__raw_readl(clk->scale_reg) >> clk->scale_bits) & mask;
+	if (div) {
+		rate /= div;
+		div = (__raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC) &
+			BM_CLKCTRL_FRAC_PIXFRAC) >> BP_CLKCTRL_FRAC_PIXFRAC;
+		rate /= div;
+	}
+
+	return rate;
+}
+
+static int lcdif_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = 0;
+	/*
+	 * ref_pix can be between 480e6*18/35=246.9MHz and 480e6*18/18=480MHz,
+	 * which is between 18/(18*480e6)=2.084ns and 35/(18*480e6)=4.050ns.
+	 *
+	 * ns_cycle >= 2*18e3/(18*480) = 25/6
+	 * ns_cycle <= 2*35e3/(18*480) = 875/108
+	 *
+	 * Multiply the ns_cycle by 'div' to lengthen it until it fits the
+	 * bounds. This is the divider we'll use after ref_pix.
+	 *
+	 * 6 * ns_cycle >= 25 * div
+	 * 108 * ns_cycle <= 875 * div
+	 */
+	u32 ns_cycle = 1000000000 / rate;
+	u32 div, reg_val;
+	u32 lowest_result = (u32) -1;
+	u32 lowest_div = 0, lowest_fracdiv = 0;
+
+	ns_cycle *= 2; /* Fix calculate double frequency */
+
+
+
+	for (div = 1; div < 256; ++div) {
+		u32 fracdiv;
+		u32 ps_result;
+		int lower_bound = 6 * ns_cycle >= 25 * div;
+		int upper_bound = 108 * ns_cycle <= 875 * div;
+		if (!lower_bound)
+			break;
+		if (!upper_bound)
+			continue;
+		/*
+		 * Found a matching div. Calculate fractional divider needed,
+		 * rounded up.
+		 */
+		fracdiv = ((clk->parent->get_rate(clk->parent) / 1000000 * 18 / 2) *
+				ns_cycle + 1000 * div - 1) /
+				(1000 * div);
+		if (fracdiv < 18 || fracdiv > 35) {
+			ret = -EINVAL;
+			goto out;
+		}
+		/* Calculate the actual cycle time this results in */
+		ps_result = 6250 * div * fracdiv / 27;
+
+		/* Use the fastest result that doesn't break ns_cycle */
+		if (ps_result <= lowest_result) {
+			lowest_result = ps_result;
+			lowest_div = div;
+			lowest_fracdiv = fracdiv;
+		}
+	}
+
+	if (div >= 256 || lowest_result == (u32) -1) {
+		ret = -EINVAL;
+		goto out;
+	}
+	pr_debug("Programming PFD=%u,DIV=%u ref_pix=%uMHz "
+			"PIXCLK=%uMHz cycle=%u.%03uns\n",
+			lowest_fracdiv, lowest_div,
+			480*18/lowest_fracdiv, 480*18/lowest_fracdiv/lowest_div,
+			lowest_result / 1000, lowest_result % 1000);
+
+	/* Program ref_pix phase fractional divider */
+	reg_val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
+	reg_val &= ~BM_CLKCTRL_FRAC_PIXFRAC;
+	reg_val |= BF_CLKCTRL_FRAC_PIXFRAC(lowest_fracdiv);
+	__raw_writel(reg_val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
+
+	/* Ungate PFD */
+	__raw_writel(BM_CLKCTRL_FRAC_CLKGATEPIX,
+			CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC_CLR);
+
+	/* Program pix divider */
+	reg_val = __raw_readl(clk->scale_reg);
+	reg_val &= ~(BM_CLKCTRL_PIX_DIV | BM_CLKCTRL_PIX_CLKGATE);
+	reg_val |= BF_CLKCTRL_PIX_DIV(lowest_div);
+	__raw_writel(reg_val, clk->scale_reg);
+
+	/* Wait for divider update */
+	ret = clk_busy_wait(clk);
+	if (ret)
+		goto out;
+
+	/* Switch to ref_pix source */
+	reg_val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+	reg_val &= ~BM_CLKCTRL_CLKSEQ_BYPASS_PIX;
+	__raw_writel(reg_val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+
+out:
+	return ret;
+}
+
+/*
+ * We set lcdif_clk's parent as &pll_clk deliberately, although
+ * in IC spec lcdif_clk(CLK_PIX) is derived from ref_pix which in turn
+ * is derived from PLL. By doing so, users just need to set/get clock rate
+ * for lcdif_clk, without need to take care of ref_pix, because the clock
+ * driver will automatically calculate the fracdivider for HW_CLKCTRL_FRAC
+ * and the divider for HW_CLKCTRL_PIX conjointly.
+ */
+static struct clk lcdif_clk = {
+	.parent		= &pll_clk,
+	.enable 	= mx23_raw_enable,
+	.disable 	= mx23_raw_disable,
+	.scale_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX,
+	.busy_bits	= 29,
+	.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_PIX,
+	.enable_bits	= 31,
+	.bypass_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits	= 1,
+	.get_rate	= lcdif_get_rate,
+	.set_rate	= lcdif_set_rate,
+	.set_parent = clkseq_set_parent,
+	.flags		= CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long cpu_get_rate(struct clk *clk)
+{
+	unsigned long rate, div;
+	rate = (clk->parent->get_rate(clk->parent));
+	div = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU) &
+			  BM_CLKCTRL_CPU_DIV_CPU;
+	rate = rate/div;
+	return rate;
+}
+
+static unsigned long cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long frac_rate, root_rate = clk->parent->get_rate(clk->parent);
+	unsigned int div = root_rate / rate;
+	if (div == 0)
+		return root_rate;
+	if (clk->parent == &ref_cpu_clk) {
+		if (div > 0x3F)
+			div = 0x3F;
+		return root_rate / div;
+	}
+
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	return rate;
+}
+
+static int cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate = pll_clk.get_rate(&pll_clk);
+	int ret = -EINVAL;
+	u32 clkctrl_cpu = 1;
+	u32 c = clkctrl_cpu;
+	u32 clkctrl_frac = 1;
+	u32 val;
+	u32 reg_val, hclk_reg;
+	bool h_autoslow;
+
+	/* make sure the cpu div_xtal is 1 */
+	reg_val = __raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_CPU);
+	reg_val &= ~(BM_CLKCTRL_CPU_DIV_XTAL);
+	reg_val |= (1 << BP_CLKCTRL_CPU_DIV_XTAL);
+	__raw_writel(reg_val, CLKCTRL_BASE_ADDR+HW_CLKCTRL_CPU);
+
+	if (rate < ref_xtal_get_rate(&ref_xtal_clk))
+		return -EINVAL;
+
+	if (rate == clk_get_rate(clk))
+		return 0;
+	/* temporaily disable h autoslow to avoid
+	 * hclk getting too slow while temporarily
+	 * changing clocks
+	 */
+	h_autoslow = mx23_enable_h_autoslow(false);
+
+	if (rate == ref_xtal_get_rate(&ref_xtal_clk)) {
+
+		/* switch to the 24M source */
+		clk_set_parent(clk, &ref_xtal_clk);
+
+		/* to avoid bus starvation issues, we'll go ahead
+		 * and change hbus clock divider to 1 now.  Cpufreq
+		 * or other clock management can lower it later if
+		 * desired for power savings or other reasons, but
+		 * there should be no need to with hbus autoslow
+		 * functionality enabled.
+		 */
+
+		ret = clk_busy_wait(&cpu_clk);
+		if (ret) {
+			printk(KERN_ERR "* couldn't set\
+				up CPU divisor\n");
+			return ret;
+		}
+
+		ret = clk_busy_wait(&h_clk);
+		if (ret) {
+			printk(KERN_ERR "* H_CLK busy timeout\n");
+			return ret;
+		}
+
+		hclk_reg = __raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_HBUS);
+		hclk_reg &= ~(BM_CLKCTRL_HBUS_DIV);
+		hclk_reg |= (1 << BP_CLKCTRL_HBUS_DIV);
+
+		__raw_writel(hclk_reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_SET);
+
+		ret = clk_busy_wait(&cpu_clk);
+		if (ret) {
+			printk(KERN_ERR "** couldn't set\
+				up CPU divisor\n");
+			return ret;
+		}
+
+		ret = clk_busy_wait(&h_clk);
+		if (ret) {
+			printk(KERN_ERR "** CLK busy timeout\n");
+			return ret;
+		}
+
+	} else {
+		for ( ; c < 0x40; c++) {
+			u32 f = ((root_rate/1000)*18/c + (rate/1000)/2) /
+				(rate/1000);
+			int s1, s2;
+
+			if (f < 18 || f > 35)
+				continue;
+			s1 = (root_rate/1000)*18/clkctrl_frac/clkctrl_cpu -
+			     (rate/1000);
+			s2 = (root_rate/1000)*18/c/f - (rate/1000);
+			if (abs(s1) > abs(s2)) {
+				clkctrl_cpu = c;
+				clkctrl_frac = f;
+			}
+			if (s2 == 0)
+				break;
+		};
+		if (c == 0x40) {
+			int  d = (root_rate/1000)*18/clkctrl_frac/clkctrl_cpu -
+				(rate/1000);
+			if ((abs(d) > 100) || (clkctrl_frac < 18) ||
+				(clkctrl_frac > 35))
+				return -EINVAL;
+		}
+
+		/* prepare Frac div */
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
+		val &= ~(BM_CLKCTRL_FRAC_CPUFRAC);
+		val |= (clkctrl_frac << BP_CLKCTRL_FRAC_CPUFRAC);
+
+		/* prepare clkctrl_cpu div*/
+		reg_val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
+		reg_val &= ~0x3F;
+		reg_val |= clkctrl_cpu;
+
+		/* set safe hbus clock divider. A divider of 3 ensure that
+		 * the Vddd voltage required for the cpuclk is sufficiently
+		 * high for the hbus clock and under 24MHz cpuclk conditions,
+		 * a divider of at least 3 ensures hbusclk doesn't remain
+		 * uneccesarily low which hurts performance
+		 */
+		hclk_reg = __raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_HBUS);
+		hclk_reg &= ~(BM_CLKCTRL_HBUS_DIV);
+		hclk_reg |= (3 << BP_CLKCTRL_HBUS_DIV);
+
+		/* if the pll was OFF, we need to turn it ON.
+		 * Even if it was ON, we want to temporarily
+		 * increment it by 1 to avoid turning off
+		 * in the upcoming parent clock change to xtal.  This
+		 * avoids waiting an extra 10us for every cpu clock
+		 * change between ref_cpu sourced frequencies.
+		 */
+		pll_enable(&pll_clk);
+		pll_clk.ref++;
+
+		/* switch to XTAL CLK source temparily while
+		 * we manipulate ref_cpu frequency */
+		clk_set_parent(clk, &ref_xtal_clk);
+
+		ret = clk_busy_wait(&h_clk);
+
+		if (ret) {
+			printk(KERN_ERR "-* HCLK busy wait timeout\n");
+			return ret;
+		}
+
+		ret = clk_busy_wait(clk);
+
+		if (ret) {
+			printk(KERN_ERR "-* couldn't set\
+				up CPU divisor\n");
+			return ret;
+		}
+
+		__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC);
+
+		/* clear the gate */
+		__raw_writel(BM_CLKCTRL_FRAC_CLKGATECPU, CLKCTRL_BASE_ADDR +
+			     HW_CLKCTRL_FRAC_CLR);
+
+		/* set the ref_cpu integer divider */
+		__raw_writel(reg_val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
+
+		/* wait for the ref_cpu path to become stable before
+		 * switching over to it
+		 */
+
+		ret = clk_busy_wait(&ref_cpu_clk);
+
+		if (ret) {
+			printk(KERN_ERR "-** couldn't set\
+				up CPU divisor\n");
+			return ret;
+		}
+
+		/* change hclk divider to safe value for any ref_cpu
+		 * value.
+		 */
+		__raw_writel(hclk_reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+
+		ret = clk_busy_wait(&h_clk);
+
+		if (ret) {
+			printk(KERN_ERR "-** HCLK busy wait timeout\n");
+			return ret;
+		}
+
+		clk_set_parent(clk, &ref_cpu_clk);
+
+		/* decrement the pll_clk ref count because
+		 * we temporarily enabled/incremented the count
+		 * above.
+		 */
+		pll_clk.ref--;
+
+		ret = clk_busy_wait(&cpu_clk);
+
+		if (ret) {
+			printk(KERN_ERR "-*** Couldn't set\
+				up CPU divisor\n");
+			return ret;
+		}
+
+		ret = clk_busy_wait(&h_clk);
+
+		if (ret) {
+			printk(KERN_ERR "-*** HCLK busy wait timeout\n");
+			return ret;
+		}
+
+	}
+	mx23_enable_h_autoslow(h_autoslow);
+	return ret;
+}
+
+static struct clk cpu_clk = {
+	.parent = &ref_cpu_clk,
+	.get_rate = cpu_get_rate,
+	.round_rate = cpu_round_rate,
+	.set_rate = cpu_set_rate,
+	.set_parent = clkseq_set_parent,
+	.scale_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.scale_bits	= 0,
+	.bypass_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits	= 7,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU,
+	.busy_bits	= 28,
+	.xtal_busy_bits = 29,
+};
+
+static unsigned long uart_get_rate(struct clk *clk)
+{
+	unsigned int div;
+	div = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL) &
+	    BM_CLKCTRL_XTAL_DIV_UART;
+	return clk->parent->get_rate(clk->parent) / div;
+}
+
+static struct clk uart_clk = {
+	.parent = &ref_xtal_clk,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_UART_CLK_GATE,
+	.get_rate = uart_get_rate,
+};
+
+static struct clk pwm_clk = {
+	.parent = &ref_xtal_clk,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_PWM_CLK24M_GATE,
+};
+
+static unsigned long clk_32k_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 750;
+}
+
+static struct clk clk_32k = {
+	.parent = &ref_xtal_clk,
+	.flags = RATE_FIXED,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE,
+	.get_rate = clk_32k_get_rate,
+};
+
+static unsigned long lradc_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 16;
+}
+
+static struct clk lradc_clk = {
+	.parent = &clk_32k,
+	.flags = RATE_FIXED,
+	.get_rate = lradc_get_rate,
+};
+
+static unsigned long x_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS) &
+	    BM_CLKCTRL_XBUS_DIV;
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static unsigned long x_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int root_rate, frac_rate;
+	unsigned int div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	/* while the reference manual specifies that divider
+	 * values up to 1023 are aloud, other critial SoC compents
+	 * require higher x clock values at all times.  Through
+	 * limited testing, the lradc functionality to measure
+	 * the battery voltage and copy this value to the
+	 * power supply requires at least a 64kHz xclk.
+	 * so the divider will be limited to 375.
+	 */
+	if ((div == 0) || (div > 375))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	else
+		return root_rate / (div + 1);
+}
+
+static int x_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate;
+	unsigned long round_rate;
+	unsigned int reg, div;
+	root_rate = clk->parent->get_rate(clk->parent);
+
+	if ((!clk->round_rate) || !(clk->scale_reg))
+		return -EINVAL;
+
+	round_rate =  clk->round_rate(clk, rate);
+	div = root_rate / round_rate;
+
+	if (root_rate % round_rate)
+			return -EINVAL;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
+	reg &= ~(BM_CLKCTRL_XBUS_DIV_FRAC_EN | BM_CLKCTRL_XBUS_DIV);
+	reg |= BF_CLKCTRL_XBUS_DIV(div);
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
+
+	return clk_busy_wait(clk);
+
+}
+
+static struct clk x_clk = {
+	.parent = &ref_xtal_clk,
+	.get_rate = x_get_rate,
+	.set_rate = x_set_rate,
+	.round_rate = x_round_rate,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS,
+	.busy_bits	= 31,
+};
+
+
+
+static struct clk ana_clk = {
+	.parent = &ref_xtal_clk,
+};
+
+
+
+static unsigned long xtal_clock32k_get_rate(struct clk *clk)
+{
+	if (__raw_readl(RTC_BASE_ADDR + HW_RTC_PERSISTENT0) &
+		BM_RTC_PERSISTENT0_XTAL32_FREQ)
+		return 32000;
+	else
+		return 32768;
+}
+
+static struct clk xtal_clock32k_clk = {
+	.get_rate = xtal_clock32k_get_rate,
+};
+
+static unsigned long rtc32k_get_rate(struct clk *clk)
+{
+	if (clk->parent == &ref_xtal_clk)
+		/* mx23 reference manual had error.
+		 * fixed divider is 750 not 768
+		 */
+		return clk->parent->get_rate(clk->parent) / 750;
+	else
+		return xtal_clock32k_get_rate(clk);
+}
+
+static struct clk rtc32k_clk = {
+	.parent = &xtal_clock32k_clk,
+	.get_rate = rtc32k_get_rate,
+};
+
+static unsigned long h_get_rate(struct clk *clk)
+{
+	unsigned long reg, div;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	div = reg & BM_CLKCTRL_HBUS_DIV;
+		return clk->parent->get_rate(clk->parent) / div;
+}
+
+static unsigned long h_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int root_rate, frac_rate;
+	unsigned int div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x20))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	else
+		return root_rate / (div + 1);
+}
+
+static int h_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate;
+	unsigned long round_rate;
+	unsigned int reg, div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	round_rate =  h_round_rate(clk, rate);
+	div = root_rate / round_rate;
+	if ((div == 0) || (div >= 0x20))
+		return -EINVAL;
+
+	if (root_rate % round_rate)
+			return -EINVAL;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	reg &= ~(BM_CLKCTRL_HBUS_DIV_FRAC_EN | BM_CLKCTRL_HBUS_DIV);
+	reg |= BF_CLKCTRL_HBUS_DIV(div);
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+
+	if (clk_busy_wait(clk)) {
+		printk(KERN_ERR "couldn't set up AHB divisor\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct clk h_clk = {
+	.parent = &cpu_clk,
+	.get_rate = h_get_rate,
+	.set_rate = h_set_rate,
+	.round_rate = h_round_rate,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS,
+	.busy_bits	= 31,
+};
+
+static struct clk ocrom_clk = {
+	.parent = &h_clk,
+};
+
+static unsigned long emi_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI);
+	if (clk->parent == &ref_emi_clk)
+		reg = (reg & BM_CLKCTRL_EMI_DIV_EMI);
+	else
+		reg = (reg & BM_CLKCTRL_EMI_DIV_XTAL) >>
+		    BP_CLKCTRL_EMI_DIV_XTAL;
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static unsigned long emi_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate = clk->parent->get_rate(clk->parent);
+	unsigned int div = root_rate / rate;
+	if (div == 0)
+		return root_rate;
+	if (clk->parent == &ref_emi_clk) {
+		if (div > 0x3F)
+			div = 0x3F;
+		return root_rate / div;
+	}
+	if (div > 0xF)
+		div = 0xF;
+	return root_rate / div;
+}
+
+/* when changing the emi clock, dram access must be
+ * disabled.  Special handling is needed to perform
+ * the emi clock change without touching sdram.
+ */
+static int emi_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = 0;
+
+	struct mxs_emi_scaling_data sc_data;
+
+	unsigned long clkctrl_emi;
+	unsigned long clkctrl_frac;
+	int div = 1;
+	unsigned long root_rate, cur_emi_div, cur_emi_frac;
+	struct clk *target_parent_p = &ref_xtal_clk;
+
+	if (rate < ref_xtal_get_rate(&ref_xtal_clk))
+		return -EINVAL;
+
+	if (!mxs_ram_funcs_sz)
+		goto out;
+
+	sc_data.cur_freq = (clk->get_rate(clk)) / 1000 / 1000;
+	sc_data.new_freq = rate / 1000 / 1000;
+
+	if (sc_data.cur_freq == sc_data.new_freq)
+		goto out;
+
+	if (rate != ref_xtal_get_rate(&ref_xtal_clk)) {
+		target_parent_p = &ref_emi_clk;
+		pll_enable(&pll_clk);
+
+		root_rate = pll_clk.get_rate(&pll_clk);
+
+		for (clkctrl_emi = div; clkctrl_emi < 0x3f;
+					clkctrl_emi += div) {
+			clkctrl_frac = ((root_rate / 1000) * 18 +
+					(rate / 1000) * clkctrl_emi / 2) /
+					((rate / 1000) * clkctrl_emi);
+			if (clkctrl_frac >= 18 && clkctrl_frac <= 35) {
+				pr_debug("%s: clkctrl_frac found %ld for %ld\n",
+					__func__, clkctrl_frac, clkctrl_emi);
+				if (((root_rate / 1000) * 18 /
+					clkctrl_frac / clkctrl_emi) / 1000 ==
+					rate / 1000 / 1000)
+					break;
+			}
+		}
+
+		if (clkctrl_emi >= 0x3f)
+			return -EINVAL;
+		pr_debug("%s: clkctrl_emi %ld, clkctrl_frac %ld\n",
+			__func__, clkctrl_emi, clkctrl_frac);
+
+		sc_data.emi_div = clkctrl_emi;
+		sc_data.frac_div = clkctrl_frac;
+	}
+
+
+	cur_emi_div = ((__raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_EMI) &
+		BM_CLKCTRL_EMI_DIV_EMI) >> BP_CLKCTRL_EMI_DIV_EMI);
+	cur_emi_frac = ((__raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_FRAC) &
+		BM_CLKCTRL_EMI_DIV_EMI) >> BP_CLKCTRL_FRAC_EMIFRAC);
+
+	if ((cur_emi_div == sc_data.emi_div) &&
+		(cur_emi_frac == sc_data.frac_div))
+		goto out;
+	{
+		unsigned long iram_phy;
+		bool h_autoslow;
+		int (*scale)(struct mxs_emi_scaling_data *) =
+			iram_alloc(mxs_ram_funcs_sz, &iram_phy);
+
+		if (NULL == scale) {
+			pr_err("%s Not enough iram\n", __func__);
+			return -ENOMEM;
+		}
+
+		/* temporaily disable h autoslow to maximize
+		 * performance/minimize time spent with no
+		 * sdram access
+		 */
+		h_autoslow = mx23_enable_h_autoslow(false);
+
+		memcpy(scale, mxs_ram_freq_scale, mxs_ram_funcs_sz);
+
+		local_irq_disable();
+		local_fiq_disable();
+
+		scale(&sc_data);
+
+		iram_free(iram_phy, mxs_ram_funcs_sz);
+
+		local_fiq_enable();
+		local_irq_enable();
+
+		/* temporaily disable h autoslow to avoid
+		 * hclk getting too slow while temporarily
+		 * changing clocks
+		 */
+		mx23_enable_h_autoslow(h_autoslow);
+	}
+
+	/* this code is for keeping track of ref counts.
+	 * and disabling previous parent if necessary
+	 * actual clkseq changes have already
+	 * been made.
+	 */
+	clk_set_parent(clk, target_parent_p);
+
+out:
+	return ret;
+}
+
+static struct clk emi_clk = {
+	.parent = &ref_emi_clk,
+	.get_rate = emi_get_rate,
+	.set_rate = emi_set_rate,
+	.round_rate = emi_round_rate,
+	.set_parent = clkseq_set_parent,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI,
+	.enable_bits = BM_CLKCTRL_EMI_CLKGATE,
+	.scale_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI,
+	.busy_bits	= 28,
+	.xtal_busy_bits = 29,
+	.bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits = 6,
+};
+
+static unsigned long ssp_get_rate(struct clk *clk);
+
+static int ssp_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+	u32 reg, div;
+	bool is_clk_enable;
+
+	is_clk_enable = mx23_is_clk_enabled(clk);
+	if (!is_clk_enable)
+		local_clk_enable(clk);
+
+	/* if the desired clock can be sourced from ref_xtal,
+	 * use ref_xtal to save power
+	 */
+	if ((rate <= ref_xtal_get_rate(&ref_xtal_clk)) &&
+		((ref_xtal_get_rate(&ref_xtal_clk) % rate) == 0))
+		clk_set_parent(clk, &ref_xtal_clk);
+	else
+		clk_set_parent(clk, &ref_io_clk);
+
+	if (rate > PLL_ENABLED_MAX_CLK_SSP)
+		rate = PLL_ENABLED_MAX_CLK_SSP;
+
+	div = (clk_get_rate(clk->parent) + rate - 1) / rate;
+
+	if (div == 0 || div > BM_CLKCTRL_SSP_DIV)
+		goto out;
+
+	reg = __raw_readl(clk->scale_reg);
+	reg &= ~(BM_CLKCTRL_SSP_DIV | BM_CLKCTRL_SSP_DIV_FRAC_EN);
+	reg |= div << clk->scale_bits;
+	__raw_writel(reg, clk->scale_reg);
+
+	ret = clk_busy_wait(clk);
+out:
+	if (!is_clk_enable)
+		local_clk_disable(clk);
+
+	if (ret != 0)
+		printk(KERN_ERR "%s: error %d\n", __func__, ret);
+	return ret;
+}
+
+static int ssp_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+
+	if (clk->bypass_reg) {
+		if (clk->parent == parent)
+			return 0;
+		if (parent == &ref_io_clk)
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + CLR_REGISTER);
+		else
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + SET_REGISTER);
+		clk->parent = parent;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* handle peripheral clocks whose optimal parent dependent on
+ * system parameters such as cpu_clk rate.  For now, this optimization
+ * only occurs to the peripheral clock when it's not in use to avoid
+ * handling more complex system clock coordination issues.
+ */
+static int ssp_set_sys_dependent_parent(struct clk *clk)
+{
+	if ((clk->ref & CLK_EN_MASK) == 0) {
+		if (clk_get_rate(&cpu_clk) > ref_xtal_get_rate(&ref_xtal_clk)) {
+			clk_set_parent(clk, &ref_io_clk);
+			clk_set_rate(clk, PLL_ENABLED_MAX_CLK_SSP);
+		} else {
+			clk_set_parent(clk, &ref_xtal_clk);
+			clk_set_rate(clk, ref_xtal_get_rate(&ref_xtal_clk));
+		}
+	}
+
+	return 0;
+}
+
+static struct clk ssp_clk = {
+	 .parent = &ref_io_clk,
+	 .get_rate = ssp_get_rate,
+	 .enable = mx23_raw_enable,
+	 .disable = mx23_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP,
+	 .enable_bits = BM_CLKCTRL_SSP_CLKGATE,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP,
+	 .busy_bits = 29,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP,
+	 .scale_bits = 0,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 5,
+	 .set_rate = ssp_set_rate,
+	 .set_parent = ssp_set_parent,
+	 .set_sys_dependent_parent = ssp_set_sys_dependent_parent,
+};
+
+static unsigned long ssp_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP) &
+		    BM_CLKCTRL_SSP_DIV;
+
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static unsigned long gpmi_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI) &
+		    BM_CLKCTRL_GPMI_DIV;
+
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static int gpmi_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+	u32 reg, div;
+
+	/* Make absolutely certain the clock is enabled. */
+	local_clk_enable(clk);
+
+	/* if the desired clock can be sourced from ref_xtal,
+	 * use ref_xtal to save power
+	 */
+	if ((rate <= ref_xtal_get_rate(&ref_xtal_clk)) &&
+		((ref_xtal_get_rate(&ref_xtal_clk) % rate) == 0))
+		clk_set_parent(clk, &ref_xtal_clk);
+	else
+		clk_set_parent(clk, &ref_io_clk);
+
+	if (rate > PLL_ENABLED_MAX_CLK_SSP)
+		rate = PLL_ENABLED_MAX_CLK_GPMI;
+
+	div = (clk_get_rate(clk->parent) + rate - 1) / rate;
+
+	if (div == 0 || div > BM_CLKCTRL_GPMI_DIV)
+		goto out;
+
+	reg = __raw_readl(clk->scale_reg);
+	reg &= ~(BM_CLKCTRL_GPMI_DIV | BM_CLKCTRL_GPMI_DIV_FRAC_EN);
+	reg |= div << clk->scale_bits;
+	__raw_writel(reg, clk->scale_reg);
+
+	ret = clk_busy_wait(clk);
+
+out:
+
+	/* Undo the enable above. */
+	local_clk_disable(clk);
+
+	if (ret != 0)
+		printk(KERN_ERR "%s: error %d\n", __func__, ret);
+	return ret;
+}
+
+static int gpmi_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+
+	if (clk->bypass_reg) {
+		if (clk->parent == parent)
+			return 0;
+		if (parent == &ref_io_clk)
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + CLR_REGISTER);
+		else
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + SET_REGISTER);
+		clk->parent = parent;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+/* handle peripheral clocks whose optimal parent dependent on
+ * system parameters such as cpu_clk rate.  For now, this optimization
+ * only occurs to the peripheral clock when it's not in use to avoid
+ * handling more complex system clock coordination issues.
+ */
+static int gpmi_set_sys_dependent_parent(struct clk *clk)
+{
+
+	if ((clk->ref & CLK_EN_MASK) == 0) {
+		if (clk_get_rate(&cpu_clk) > ref_xtal_get_rate(&ref_xtal_clk)) {
+			clk_set_parent(clk, &ref_io_clk);
+			clk_set_rate(clk, PLL_ENABLED_MAX_CLK_GPMI);
+		} else {
+			clk_set_parent(clk, &ref_xtal_clk);
+			clk_set_rate(clk, ref_xtal_get_rate(&ref_xtal_clk));
+		}
+	}
+
+	return 0;
+}
+
+static struct clk gpmi_clk = {
+	.parent		= &ref_io_clk,
+	.secondary      = 0,
+	.flags          = 0,
+	.set_parent     = gpmi_set_parent,
+	.set_sys_dependent_parent = gpmi_set_sys_dependent_parent,
+
+	.enable_reg     = CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI,
+	.enable_bits    = BM_CLKCTRL_GPMI_CLKGATE,
+	.enable         = mx23_raw_enable,
+	.disable        = mx23_raw_disable,
+
+	.scale_reg      = CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI,
+	.scale_bits     = 0,
+	.round_rate     = 0,
+	.set_rate       = gpmi_set_rate,
+	.get_rate       = gpmi_get_rate,
+
+	.bypass_reg     = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits    = 4,
+
+	.busy_reg       = CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI,
+	.busy_bits      = 29,
+};
+
+static unsigned long pcmspdif_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 4;
+}
+
+static struct clk pcmspdif_clk = {
+	.parent = &pll_clk,
+	.get_rate = pcmspdif_get_rate,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SPDIF,
+	.enable_bits = BM_CLKCTRL_SPDIF_CLKGATE,
+};
+
+/* usb_clk for usb0 */
+static struct clk usb_clk = {
+	.parent = &pll_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.enable_reg = DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL,
+	.enable_bits = BM_DIGCTL_CTRL_USB_CLKGATE,
+	.flags		= CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk audio_clk = {
+	.parent = &ref_xtal_clk,
+	.enable = mx23_raw_enable,
+	.disable = mx23_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_FILT_CLK24M_GATE,
+};
+
+static struct clk vid_clk = {
+	.parent		= &ref_xtal_clk,
+	.enable         = mx23_raw_enable,
+	.disable        = mx23_raw_disable,
+	.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.enable_bits	= BM_CLKCTRL_FRAC1_CLKGATEVID,
+};
+
+static struct clk tv108M_ng_clk = {
+	.parent		= &vid_clk,
+	.enable         = mx23_raw_enable,
+	.disable        = mx23_raw_disable,
+	.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_TV,
+	.enable_bits	= BM_CLKCTRL_TV_CLK_TV108M_GATE,
+	.flags		= RATE_FIXED,
+};
+
+static struct clk tv27M_clk = {
+	.parent		= &vid_clk,
+	.enable         = mx23_raw_enable,
+	.disable        = mx23_raw_disable,
+	.enable_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_TV,
+	.enable_bits	= BM_CLKCTRL_TV_CLK_TV_GATE,
+	.flags		= RATE_FIXED,
+};
+
+static struct clk_lookup onchip_clocks[] = {
+	{
+	 .con_id = "pll.0",
+	 .clk = &pll_clk,
+	 },
+	{
+	 .con_id = "ref_xtal",
+	 .clk = &ref_xtal_clk,
+	 },
+	{
+	 .con_id = "ref_cpu",
+	 .clk = &ref_cpu_clk,
+	 },
+	{
+	 .con_id = "ref_emi",
+	 .clk = &ref_emi_clk,
+	 },
+	{
+	 .con_id = "ref_io.0",
+	 .clk = &ref_io_clk,
+	 },
+	{
+	 .con_id = "ref_pix",
+	 .clk = &ref_pix_clk,
+	 },
+	{
+	 .con_id = "lcdif",
+	 .clk = &lcdif_clk,
+	 },
+	{
+	 .con_id = "xtal_clock32k",
+	 .clk = &xtal_clock32k_clk,
+	 },
+	{
+	 .con_id = "rtc",
+	 .clk = &rtc32k_clk,
+	 },
+	{
+	 .con_id = "cpu",
+	 .clk = &cpu_clk,
+	 },
+	{
+	 .con_id = "h",
+	 .clk = &h_clk,
+	 },
+	{
+	 .con_id = "x",
+	 .clk = &x_clk,
+	 },
+	{
+	 .con_id = "ocrom",
+	 .clk = &ocrom_clk,
+	 },
+	{
+	 .con_id = "clk_32k",
+	 .clk = &clk_32k,
+	 },
+	{
+	 .con_id = "uart",
+	 .clk = &uart_clk,
+	 },
+	{
+	 .con_id = "pwm",
+	 .clk = &pwm_clk,
+	 },
+	{
+	 .con_id = "lradc",
+	 .clk = &lradc_clk,
+	 },
+	{
+	 .con_id = "ssp.0",
+	 .clk = &ssp_clk,
+	 },
+	{
+	 .con_id = "emi",
+	 .clk = &emi_clk,
+	 },
+	{
+	.con_id = "usb_clk0",
+	.clk = &usb_clk,
+	},
+	{
+	.con_id = "audio",
+	.clk = &audio_clk,
+	},
+	{
+	 .con_id = "spdif",
+	 .clk = &pcmspdif_clk,
+	},
+	{
+	 .con_id = "ref_vid",
+	 .clk = &vid_clk,
+	},
+	{
+	 .con_id = "tv108M_ng",
+	 .clk = &tv108M_ng_clk,
+	},
+	{
+	 .con_id = "tv27M",
+	 .clk = &tv27M_clk,
+	},
+	{
+	 .con_id = "gpmi",
+	 .clk = &gpmi_clk,
+	},
+};
+
+/* for debugging */
+#ifdef DEBUG
+static void print_ref_counts(void)
+{
+
+	printk(KERN_INFO "pll_clk ref count: %i\n",
+		pll_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "ref_cpu_clk ref count: %i\n",
+		ref_cpu_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "ref_emi_clk ref count: %i\n",
+		ref_emi_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "lcdif_clk ref count: %i\n",
+		lcdif_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "ref_io_clk ref count: %i\n",
+		ref_io_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "ssp_clk ref count: %i\n",
+		ssp_clk.ref & CLK_EN_MASK);
+
+	printk(KERN_INFO "gpmi_clk ref count: %i\n",
+		gpmi_clk.ref & CLK_EN_MASK);
+
+}
+#endif
+
+static void mx23_clock_scan(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU)
+		cpu_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI)
+		emi_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP)
+		ssp_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI)
+		gpmi_clk.parent = &ref_xtal_clk;
+
+	reg = __raw_readl(RTC_BASE_ADDR + HW_RTC_PERSISTENT0);
+	if (!(reg & BM_RTC_PERSISTENT0_CLOCKSOURCE))
+		rtc32k_clk.parent = &ref_xtal_clk;
+};
+
+void __init mx23_set_input_clk(unsigned long xtal0,
+			       unsigned long xtal1,
+			       unsigned long xtal2, unsigned long enet)
+{
+
+}
+
+void __init mx23_clock_init(void)
+{
+	int i;
+	mx23_clock_scan();
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++)
+		clk_register(&onchip_clocks[i]);
+
+	clk_enable(&cpu_clk);
+	clk_enable(&emi_clk);
+
+	clk_en_public_h_asm_ctrl(mx23_enable_h_autoslow,
+		mx23_set_hbus_autoslow_flags);
+}
diff --git a/arch/arm/mach-mx23/device.c b/arch/arm/mach-mx23/device.c
new file mode 100644
index 0000000..814c4ef
--- /dev/null
+++ b/arch/arm/mach-mx23/device.c
@@ -0,0 +1,1015 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/phy.h>
+#include <linux/fec.h>
+#include <linux/gpmi-nfc.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-timrot.h>
+#include <mach/regs-lradc.h>
+#include <mach/device.h>
+#include <mach/dma.h>
+#include <mach/irqs.h>
+#include <mach/lradc.h>
+#include <mach/lcdif.h>
+#include <mach/ddi_bc.h>
+
+#include "device.h"
+#include "mx23_pins.h"
+#include "mx23evk.h"
+#include "mach/mx23.h"
+
+#if defined(CONFIG_SERIAL_MXS_DUART) || \
+	defined(CONFIG_SERIAL_MXS_DUART_MODULE)
+static struct resource duart_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = DUART_PHYS_ADDR,
+	 .end = DUART_PHYS_ADDR + 0x1000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_DEBUG_UART ,
+	 .end = IRQ_DEBUG_UART ,
+	 },
+};
+
+static void __init mx23_init_duart(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-duart", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = duart_resource;
+	pdev->num_resources = ARRAY_SIZE(duart_resource);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void mx23_init_duart(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_DMA_ENGINE)
+static struct resource mxs_ahb_apbh_res = {
+	.flags = IORESOURCE_MEM,
+	.start = APBH_DMA_PHYS_ADDR,
+	.end = APBH_DMA_PHYS_ADDR + 0x2000 - 1,
+};
+
+static struct mxs_dma_plat_data mxs_ahb_apbh_data = {
+	.chan_base = MXS_DMA_CHANNEL_AHB_APBH,
+	.chan_num = 8,
+};
+
+static struct resource mxs_ahb_apbx_res = {
+	.flags = IORESOURCE_MEM,
+	.start = APBX_DMA_PHYS_ADDR,
+	.end = APBX_DMA_PHYS_ADDR + 0x2000 - 1,
+};
+
+static struct mxs_dma_plat_data mxs_ahb_apbx_data = {
+	.chan_base = MXS_DMA_CHANNEL_AHB_APBX,
+	.chan_num = 16,
+};
+
+static void __init mx23_init_dma(void)
+{
+	int i;
+	struct mxs_dev_lookup *lookup;
+	struct platform_device *pdev;
+	lookup = mxs_get_devices("mxs-dma");
+	if (lookup == NULL || IS_ERR(lookup))
+		return;
+	for (i = 0; i < lookup->size; i++) {
+		pdev = lookup->pdev + i;
+		if (!strcmp(pdev->name, "mxs-dma-apbh")) {
+			pdev->resource = &mxs_ahb_apbh_res;
+			pdev->dev.platform_data = &mxs_ahb_apbh_data;
+		} else if (!strcmp(pdev->name, "mxs-dma-apbx")) {
+			pdev->resource = &mxs_ahb_apbx_res;
+			pdev->dev.platform_data = &mxs_ahb_apbx_data;
+		} else
+			continue;
+		pdev->num_resources = 1;
+		mxs_add_device(pdev, 0);
+	}
+}
+#else
+static void mx23_init_dma(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+static struct resource framebuffer_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LCDIF_PHYS_ADDR,
+	 .end   = LCDIF_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LCDIF_ERROR,
+	 .end   = IRQ_LCDIF_ERROR,
+	 },
+};
+
+static struct mxs_platform_fb_data mxs_framebuffer_pdata = {
+	.list = LIST_HEAD_INIT(mxs_framebuffer_pdata.list),
+};
+
+static void __init mx23_init_lcdif(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-fb", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = framebuffer_resource;
+	pdev->num_resources = ARRAY_SIZE(framebuffer_resource);
+	pdev->dev.platform_data = &mxs_framebuffer_pdata;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_lcdif(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_MXS_PXP) || \
+	defined(CONFIG_VIDEO_MXS_PXP_MODULE)
+static struct resource pxp_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= (unsigned int)IO_ADDRESS(PXP_PHYS_ADDR),
+		.end	= (unsigned int)IO_ADDRESS(PXP_PHYS_ADDR) + 0x2000 - 1,
+	}, {
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_PXP,
+		.end	= IRQ_PXP,
+	},
+};
+static void __init mx23_init_pxp(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-pxp", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = pxp_resource;
+	pdev->num_resources = ARRAY_SIZE(pxp_resource);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_pxp(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_MXS_VIIM) || defined(CONFIG_MXS_VIIM_MODULE)
+struct resource viim_resources[] = {
+	[0] = {
+		.start  = DIGCTL_PHYS_ADDR,
+		.end    = DIGCTL_PHYS_ADDR + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = OCOTP_PHYS_ADDR,
+		.end    = OCOTP_PHYS_ADDR + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+static void __init mx23_init_viim(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs_viim", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->resource = viim_resources;
+	pdev->num_resources = ARRAY_SIZE(viim_resources);
+
+	mxs_add_device(pdev, 2);
+}
+#else
+static void __init mx23_init_viim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+static struct resource i2c_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = I2C0_PHYS_ADDR,
+	 .end   = I2C0_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_I2C,
+	 .end   = MXS_DMA_CHANNEL_AHB_APBX_I2C,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C_ERROR,
+	 .end   = IRQ_I2C_ERROR,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C_DMA,
+	 .end   = IRQ_I2C_DMA,
+	 },
+};
+
+static struct mxs_i2c_plat_data i2c_platdata = {
+#ifdef	CONFIG_I2C_MXS_SELECT0_PIOQUEUE_MODE
+	.pioqueue_mode = 0,
+#endif
+};
+
+static void __init mx23_init_i2c(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-i2c", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->resource = i2c_resource;
+	pdev->num_resources = ARRAY_SIZE(i2c_resource);
+	pdev->dev.platform_data = &i2c_platdata;
+
+	mxs_add_device(pdev, 2);
+}
+#else
+static void __init mx23_init_i2c(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_WATCHDOG) || defined(CONFIG_MXS_WATCHDOG_MODULE)
+static struct resource mx23_wdt_res = {
+	.flags = IORESOURCE_MEM,
+	.start = RTC_PHYS_ADDR,
+	.end   = RTC_PHYS_ADDR + 0x2000 - 1,
+};
+
+static void __init mx23_init_wdt(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-wdt", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = &mx23_wdt_res;
+	pdev->num_resources = 1;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_wdt(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXS) || defined(CONFIG_RTC_DRV_MXS_MODULE)
+static struct resource mx23_rtc_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = RTC_PHYS_ADDR,
+	 .end   = RTC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_RTC_ALARM,
+	 .end   = IRQ_RTC_ALARM,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_RTC_1MSEC,
+	 .end   = IRQ_RTC_1MSEC,
+	},
+};
+
+static void __init mx23_init_rtc(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-rtc", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx23_rtc_res;
+	pdev->num_resources = ARRAY_SIZE(mx23_rtc_res);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_rtc(void)
+{
+	;
+}
+#endif
+
+#ifdef CONFIG_MXS_LRADC
+struct mxs_lradc_plat_data mx23_lradc_data = {
+	.vddio_voltage = BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL6,
+	.battery_voltage = BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL7,
+};
+
+static struct resource mx23_lradc_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+};
+
+static void __init mx23_init_lradc(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-lradc", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx23_lradc_res;
+	pdev->num_resources = ARRAY_SIZE(mx23_lradc_res);
+	pdev->dev.platform_data = &mx23_lradc_data;
+	mxs_add_device(pdev, 0);
+}
+#else
+static void __init mx23_init_lradc(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_KEYBOARD_MXS) || defined(CONFIG_KEYBOARD_MXS_MODULE)
+static struct mxskbd_keypair keyboard_data[] = {
+	{ 100, KEY_F1 },
+	{ 306, KEY_RIGHT},
+	{ 626, KEY_F2},
+	{ 932, KEY_LEFT },
+	{ 1584, KEY_UP },
+	{ 2207, KEY_DOWN },
+	{ 1907, KEY_F3 },
+	{ 2831, KEY_SELECT },
+	{ -1, 0 },
+};
+
+static struct mxs_kbd_plat_data mxs_kbd_data = {
+	.keypair = keyboard_data,
+	.channel = LRADC_CH0,
+};
+
+static struct resource mx23_kbd_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LRADC_CH0,
+	 .end   = IRQ_LRADC_CH0,
+	 },
+};
+
+static void __init mx23_init_kbd(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-kbd", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx23_kbd_res;
+	pdev->num_resources = ARRAY_SIZE(mx23_kbd_res);
+	pdev->dev.platform_data = &mxs_kbd_data;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_kbd(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
+static struct mxs_touchscreen_plat_data mx23_ts_data = {
+	.x_plus_chan = LRADC_TOUCH_X_PLUS,
+	.x_minus_chan = LRADC_TOUCH_X_MINUS,
+	.y_plus_chan = LRADC_TOUCH_Y_PLUS,
+	.y_minus_chan = LRADC_TOUCH_Y_MINUS,
+	.x_plus_val = BM_LRADC_CTRL0_XPLUS_ENABLE,
+	.x_minus_val = BM_LRADC_CTRL0_XMINUS_ENABLE,
+	.y_plus_val = BM_LRADC_CTRL0_YPLUS_ENABLE,
+	.y_minus_val = BM_LRADC_CTRL0_YMINUS_ENABLE,
+	.x_plus_mask = BM_LRADC_CTRL0_XPLUS_ENABLE,
+	.x_minus_mask = BM_LRADC_CTRL0_XMINUS_ENABLE,
+	.y_plus_mask = BM_LRADC_CTRL0_YPLUS_ENABLE,
+	.y_minus_mask = BM_LRADC_CTRL0_YMINUS_ENABLE,
+};
+
+static struct resource mx23_ts_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_TOUCH_DETECT,
+	 .end   = IRQ_TOUCH_DETECT,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LRADC_CH5,
+	 .end   = IRQ_LRADC_CH5,
+	 },
+};
+
+static void __init mx23_init_ts(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-ts", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx23_ts_res;
+	pdev->num_resources = ARRAY_SIZE(mx23_ts_res);
+	pdev->dev.platform_data = &mx23_ts_data;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_ts(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_DCP)
+
+static struct resource dcp_resources[] = {
+
+	{
+		.flags = IORESOURCE_MEM,
+		.start = DCP_PHYS_ADDR,
+		.end   = DCP_PHYS_ADDR + 0x2000 - 1,
+	}, {
+		.flags = IORESOURCE_IRQ,
+		.start = IRQ_DCP_VMI,
+		.end = IRQ_DCP_VMI,
+	}, {
+		.flags = IORESOURCE_IRQ,
+		.start = IRQ_DCP,
+		.end = IRQ_DCP,
+	},
+};
+
+static void __init mx23_init_dcp(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("dcp", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = dcp_resources;
+	pdev->num_resources = ARRAY_SIZE(dcp_resources);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23_init_dcp(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_MTD_NAND_GPMI_NFC)
+
+static int gpmi_nfc_platform_init(unsigned int max_chip_count)
+{
+	return 0;
+}
+
+static void gpmi_nfc_platform_exit(unsigned int max_chip_count)
+{
+}
+
+static const char *gpmi_nfc_partition_source_types[] = { "cmdlinepart", 0 };
+
+static struct gpmi_nfc_platform_data  gpmi_nfc_platform_data = {
+	.nfc_version             = 0,
+	.boot_rom_version        = 0,
+	.clock_name              = "gpmi",
+	.platform_init           = gpmi_nfc_platform_init,
+	.platform_exit           = gpmi_nfc_platform_exit,
+	.min_prop_delay_in_ns    = 5,
+	.max_prop_delay_in_ns    = 9,
+	.max_chip_count          = 2,
+	.boot_area_size_in_bytes = 20 * SZ_1M,
+	.partition_source_types  = gpmi_nfc_partition_source_types,
+	.partitions              = 0,
+	.partition_count         = 0,
+};
+
+static struct resource gpmi_nfc_resources[] = {
+	{
+	 .name  = GPMI_NFC_GPMI_REGS_ADDR_RES_NAME,
+	 .flags = IORESOURCE_MEM,
+	 .start = GPMI_PHYS_ADDR,
+	 .end   = GPMI_PHYS_ADDR + SZ_8K - 1,
+	 },
+	{
+	 .name  = GPMI_NFC_GPMI_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_GPMI_ATTENTION,
+	 .end   = IRQ_GPMI_ATTENTION,
+	},
+	{
+	 .name  = GPMI_NFC_BCH_REGS_ADDR_RES_NAME,
+	 .flags = IORESOURCE_MEM,
+	 .start = BCH_PHYS_ADDR,
+	 .end   = BCH_PHYS_ADDR + SZ_8K - 1,
+	 },
+	{
+	 .name  = GPMI_NFC_BCH_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_BCH,
+	 .end   = IRQ_BCH,
+	 },
+	{
+	 .name  = GPMI_NFC_DMA_CHANNELS_RES_NAME,
+	 .flags = IORESOURCE_DMA,
+	 .start	= MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	 .end	= MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	 },
+	{
+	 .name  = GPMI_NFC_DMA_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_GPMI_DMA,
+	 .end   = IRQ_GPMI_DMA,
+	},
+};
+
+static void __init mx23_init_gpmi_nfc(void)
+{
+	struct platform_device  *pdev;
+
+	pdev = mxs_get_device(GPMI_NFC_DRIVER_NAME, 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->dev.platform_data = &gpmi_nfc_platform_data;
+	pdev->resource          =  gpmi_nfc_resources;
+	pdev->num_resources     = ARRAY_SIZE(gpmi_nfc_resources);
+	mxs_add_device(pdev, 1);
+}
+#else
+static void mx23_init_gpmi_nfc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
+static unsigned long mxs_mmc_setclock_mmc0(unsigned long hz)
+{
+	struct clk *ssp = clk_get(NULL, "ssp.0");
+
+	clk_set_rate(ssp, 2 * hz);
+	clk_put(ssp);
+
+	return hz;
+}
+
+static struct mxs_mmc_platform_data mx23_mmc0_data = {
+	.hw_init	= mxs_mmc_hw_init_mmc0,
+	.hw_release	= mxs_mmc_hw_release_mmc0,
+	.get_wp		= mxs_mmc_get_wp_mmc0,
+	.cmd_pullup	= mxs_mmc_cmd_pullup_mmc0,
+	 /*
+	 Don't change ssp clock because ssp1 and ssp2 share one ssp clock source
+	 ssp module have own divider.
+	 .setclock	= mxs_mmc_setclock_mmc0,
+	 */
+	.caps 		= MMC_CAP_4_BIT_DATA,
+	.min_clk	= 400000,
+	.max_clk	= 48000000,
+	.read_uA        = 50000,
+	.write_uA       = 70000,
+	.clock_mmc = "ssp.0",
+	.power_mmc = NULL,
+};
+
+static struct resource mx23_mmc0_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= SSP1_PHYS_ADDR,
+		.end	= SSP1_PHYS_ADDR + 0x2000 - 1,
+	},
+	{
+		.flags	= IORESOURCE_DMA,
+		.start	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+		.end	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP1_DMA,
+		.end	= IRQ_SSP1_DMA,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP_ERROR,
+		.end	= IRQ_SSP_ERROR,
+	},
+};
+
+static void __init mx23_init_mmc(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-mmc", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx23_mmc0_resource;
+	pdev->num_resources = ARRAY_SIZE(mx23_mmc0_resource);
+	pdev->dev.platform_data = &mx23_mmc0_data;
+
+	mxs_add_device(pdev, 2);
+}
+#else
+static void mx23_init_mmc(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_SPI_MXS) || defined(CONFIG_SPI_MXS_MODULE)
+static struct resource ssp1_resources[] = {
+	{
+		.start	= SSP1_PHYS_ADDR,
+		.end	= SSP1_PHYS_ADDR + 0x1FFF,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_SSP1_DMA,
+		.end	= IRQ_SSP1_DMA,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.start	= IRQ_SSP_ERROR,
+		.end	= IRQ_SSP_ERROR,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.start	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+		.end	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static void __init mx23_init_spi1(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-spi", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = ssp1_resources;
+	pdev->num_resources = ARRAY_SIZE(ssp1_resources);
+
+	mxs_add_device(pdev, 3);
+}
+#else
+static void mx23_init_spi1(void)
+{
+	;
+}
+#endif
+
+#define CMDLINE_DEVICE_CHOOSE(name, dev1, dev2)			\
+	static char *cmdline_device_##name;			\
+	static int cmdline_device_##name##_setup(char *dev)	\
+	{							\
+		cmdline_device_##name = dev + 1;		\
+		return 0;					\
+	}							\
+	__setup(#name, cmdline_device_##name##_setup);		\
+	void mx23_init_##name(void)				\
+	{							\
+		if (!cmdline_device_##name ||			\
+			!strcmp(cmdline_device_##name, #dev1))	\
+				mx23_init_##dev1();		\
+		else if (!strcmp(cmdline_device_##name, #dev2))	\
+				mx23_init_##dev2();		\
+		else						\
+			pr_err("Unknown %s assignment '%s'.\n",	\
+				#name, cmdline_device_##name);	\
+	}
+
+CMDLINE_DEVICE_CHOOSE(ssp1, mmc, spi1)
+
+#if defined(CONFIG_BATTERY_MXS)
+/* battery info data */
+static ddi_bc_Cfg_t battery_data = {
+	.u32StateMachinePeriod		 = 100,		/* ms */
+	.u16CurrentRampSlope		 = 75,		/* mA/s */
+	.u16ConditioningThresholdVoltage = 2900, 	/* mV */
+	.u16ConditioningMaxVoltage	 = 3000,	/* mV */
+	.u16ConditioningCurrent		 = 60,		/* mA */
+	.u32ConditioningTimeout		 = 4*60*60*1000, /* ms (4 hours) */
+	.u16ChargingVoltage		 = 4200,	/* mV */
+	/* FIXME: the current comparator could have h/w bugs in current
+	 * detection through POWER_STS.CHRGSTS bit */
+	.u16ChargingCurrent		 = 600,		/* mA 600 */
+	.u16ChargingThresholdCurrent	 = 60,		/* mA 60 */
+	.u32ChargingTimeout		 = 4*60*60*1000,/* ms (4 hours) */
+	.u32TopOffPeriod		 = 30*60*1000,	/* ms (30 minutes) */
+	.monitorDieTemp			 = 1,		/* Monitor the die */
+	.u8DieTempHigh			 = 75,		/* deg centigrade */
+	.u8DieTempLow			 = 65,		/* deg centigrade */
+	.u16DieTempSafeCurrent		 = 0,		/* mA */
+	.monitorBatteryTemp		 = 0,		/* Monitor the battery*/
+	.u8BatteryTempChannel		 = 1,		/* LRADC 1 */
+	.u16BatteryTempHigh		 = 642,		/* Unknown units */
+	.u16BatteryTempLow		 = 497,		/* Unknown units */
+	.u16BatteryTempSafeCurrent	 = 0,		/* mA */
+};
+
+static struct resource battery_resource[] = {
+	{/* 0 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDD5V,
+		.end    = IRQ_VDD5V,
+	},
+	{/* 1 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_DCDC4P2_BO,
+		.end    = IRQ_DCDC4P2_BO,
+	},
+	{/* 2 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_BATT_BRNOUT,
+		.end    = IRQ_BATT_BRNOUT,
+	},
+	{/* 3 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDDD_BRNOUT,
+		.end    = IRQ_VDDD_BRNOUT,
+	},
+	{/* 4 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDD18_BRNOUT,
+		.end    = IRQ_VDD18_BRNOUT,
+	},
+	{/* 5 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDDIO_BRNOUT,
+		.end    = IRQ_VDDIO_BRNOUT,
+	},
+	{/* 6 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDD5V_DROOP,
+		.end    = IRQ_VDD5V_DROOP,
+	},
+};
+
+static void mx23_init_battery(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-battery", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = battery_resource,
+	pdev->num_resources = ARRAY_SIZE(battery_resource),
+	pdev->dev.platform_data = &battery_data;
+	mxs_add_device(pdev, 3);
+
+}
+#else
+static void mx23_init_battery(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+       defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+void __init mx23_init_spdif(void)
+{	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-spdif", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	mxs_add_device(pdev, 3);
+}
+#else
+static inline void mx23_init_spdif(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_PERSISTENT)
+static const struct mxs_persistent_bit_config
+mx23_persistent_bit_config[] = {
+	{ .reg = 0, .start =  0, .width =  1,
+		.name = "CLOCKSOURCE" },
+	{ .reg = 0, .start =  1, .width =  1,
+		.name = "ALARM_WAKE_EN" },
+	{ .reg = 0, .start =  2, .width =  1,
+		.name = "ALARM_EN" },
+	{ .reg = 0, .start =  3, .width =  1,
+		.name = "CLK_SECS" },
+	{ .reg = 0, .start =  4, .width =  1,
+		.name = "XTAL24MHZ_PWRUP" },
+	{ .reg = 0, .start =  5, .width =  1,
+		.name = "XTAL32MHZ_PWRUP" },
+	{ .reg = 0, .start =  6, .width =  1,
+		.name = "XTAL32_FREQ" },
+	{ .reg = 0, .start =  7, .width =  1,
+		.name = "ALARM_WAKE" },
+	{ .reg = 0, .start =  8, .width =  5,
+		.name = "MSEC_RES" },
+	{ .reg = 0, .start = 13, .width =  1,
+		.name = "DISABLE_XTALOK" },
+	{ .reg = 0, .start = 14, .width =  2,
+		.name = "LOWERBIAS" },
+	{ .reg = 0, .start = 16, .width =  1,
+		.name = "DISABLE_PSWITCH" },
+	{ .reg = 0, .start = 17, .width =  1,
+		.name = "AUTO_RESTART" },
+	{ .reg = 0, .start = 18, .width = 14,
+		.name = "SPARE_ANALOG" },
+
+	{ .reg = 1, .start =  0, .width =  1,
+		.name = "FORCE_RECOVERY" },
+	{ .reg = 1, .start =  1, .width =  1,
+		.name = "NAND_SECONDARY_BOOT" },
+	{ .reg = 1, .start =  2, .width =  1,
+		.name = "NAND_SDK_BLOCK_REWRITE" },
+	{ .reg = 1, .start =  3, .width =  1,
+		.name = "SD_SPEED_ENABLE" },
+	{ .reg = 1, .start =  4, .width =  1,
+		.name = "SD_INIT_SEQ_1_DISABLE" },
+	{ .reg = 1, .start =  5, .width =  1,
+		.name = "SD_CMD0_DISABLE" },
+	{ .reg = 1, .start =  6, .width =  1,
+		.name = "SD_INIT_SEQ_2_ENABLE" },
+	{ .reg = 1, .start =  7, .width =  1,
+		.name = "OTG_ATL_ROLE_BIT" },
+	{ .reg = 1, .start =  8, .width =  1,
+		.name = "OTG_HNP_BIT" },
+	{ .reg = 1, .start =  9, .width =  1,
+		.name = "USB_LOW_POWER_MODE" },
+	{ .reg = 1, .start = 10, .width =  1,
+		.name = "SKIP_CHECKDISK" },
+	{ .reg = 1, .start = 11, .width =  1,
+		.name = "USB_BOOT_PLAYER_MODE" },
+	{ .reg = 1, .start = 12, .width =  1,
+		.name = "ENUMERATE_500MA_TWICE" },
+	{ .reg = 1, .start = 13, .width = 19,
+		.name = "SPARE_GENERAL" },
+
+	{ .reg = 2, .start =  0, .width = 32,
+		.name = "SPARE_2" },
+	{ .reg = 3, .start =  0, .width = 32,
+		.name = "SPARE_3" },
+	{ .reg = 4, .start =  0, .width = 32,
+		.name = "SPARE_4" },
+	{ .reg = 5, .start =  0, .width = 32,
+		.name = "SPARE_5" },
+};
+
+static struct mxs_platform_persistent_data mx23_persistent_data = {
+	.bit_config_tab = mx23_persistent_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx23_persistent_bit_config),
+};
+
+static struct resource mx23_persistent_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = RTC_PHYS_ADDR,
+	 .end   = RTC_PHYS_ADDR + 0x2000 - 1,
+	 },
+};
+
+static void mx23_init_persistent(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-persistent", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->dev.platform_data = &mx23_persistent_data;
+	pdev->resource = mx23_persistent_res,
+	pdev->num_resources = ARRAY_SIZE(mx23_persistent_res),
+	mxs_add_device(pdev, 3);
+}
+#else
+static void mx23_init_persistent()
+{
+}
+#endif
+
+int __init mx23_device_init(void)
+{
+	mx23_init_dma();
+	mx23_init_viim();
+	mx23_init_duart();
+	mx23_init_auart();
+	mx23_init_lradc();
+	mx23_init_i2c();
+	mx23_init_kbd();
+	mx23_init_wdt();
+	mx23_init_ts();
+	mx23_init_rtc();
+	mx23_init_dcp();
+	mx23_init_ssp1();
+	mx23_init_gpmi_nfc();
+	mx23_init_spdif();
+	mx23_init_lcdif();
+	mx23_init_pxp();
+	mx23_init_battery();
+	mx23_init_persistent();
+
+	return 0;
+}
+
+static struct __initdata map_desc mx23_io_desc[] = {
+	{
+	 .virtual = MX23_SOC_IO_VIRT_BASE,
+	 .pfn = __phys_to_pfn(MX23_SOC_IO_PHYS_BASE),
+	 .length = MX23_SOC_IO_AREA_SIZE,
+	 .type = MT_DEVICE,
+	 },
+	{
+	 .virtual = MX23_OCRAM_BASE,
+	 .pfn = __phys_to_pfn(MX23_OCRAM_PHBASE),
+	 .length = MX23_OCRAM_SIZE,
+	 .type  = MT_DEVICE,
+	},
+};
+
+void __init mx23_map_io(void)
+{
+	iotable_init(mx23_io_desc, ARRAY_SIZE(mx23_io_desc));
+}
+
+void __init mx23_irq_init(void)
+{
+	avic_init_irq(IO_ADDRESS(ICOLL_PHYS_ADDR), ARCH_NR_IRQS);
+}
+
+static void mx23_timer_init(void)
+{
+	int i, reg;
+	mx23_clock_init();
+
+	mx23_timer.clk = clk_get(NULL, "clk_32k");
+	if (mx23_timer.clk == NULL || IS_ERR(mx23_timer.clk))
+		return;
+	__raw_writel(BM_TIMROT_ROTCTRL_SFTRST,
+		     mx23_timer.base + HW_TIMROT_ROTCTRL_CLR);
+	for (i = 0; i < 10000; i++) {
+		reg = __raw_readl(mx23_timer.base + HW_TIMROT_ROTCTRL);
+		if (!(reg & BM_TIMROT_ROTCTRL_SFTRST))
+			break;
+		udelay(2);
+	}
+	if (i >= 10000)
+		return;
+	__raw_writel(BM_TIMROT_ROTCTRL_CLKGATE,
+		     mx23_timer.base + HW_TIMROT_ROTCTRL_CLR);
+
+	reg = __raw_readl(mx23_timer.base + HW_TIMROT_ROTCTRL);
+
+	mxs_nomatch_timer_init(&mx23_timer);
+}
+
+struct mxs_sys_timer mx23_timer = {
+	.timer = {
+		  .init = mx23_timer_init,
+		  },
+	.clk_sel = BV_TIMROT_TIMCTRLn_SELECT__32KHZ_XTAL,
+	.base = IO_ADDRESS(TIMROT_PHYS_ADDR),
+};
diff --git a/arch/arm/mach-mx23/device.h b/arch/arm/mach-mx23/device.h
new file mode 100644
index 0000000..ec41155
--- /dev/null
+++ b/arch/arm/mach-mx23/device.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_DEVICE_H__
+#define __ASM_ARCH_MACH_DEVICE_H__
+
+extern struct mxs_sys_timer mx23_timer;
+
+extern void __init mx23_map_io(void);
+extern void __init mx23_clock_init(void);
+extern void __init mx23_irq_init(void);
+extern int __init mx23_pinctrl_init(void);
+extern int __init mx23_gpio_init(void);
+extern int __init mx23_device_init(void);
+extern void __init mx23_init_auart(void);
+extern void __init
+mx23_set_input_clk(unsigned long, unsigned long, unsigned long, unsigned long);
+
+#endif
diff --git a/arch/arm/mach-mx23/emi.S b/arch/arm/mach-mx23/emi.S
new file mode 100644
index 0000000..41e1ea6
--- /dev/null
+++ b/arch/arm/mach-mx23/emi.S
@@ -0,0 +1,254 @@
+/*
+ * Freescale MX23 low level RAM frequency manipulation
+ *
+ * Author: Vitaly Wool <vital@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/system.h>
+#include <asm/pgtable-hwdef.h>
+#include <mach/hardware.h>
+#include <mach/regs-power.h>
+#include <mach/regs-emi.h>
+#include "regs-clkctrl.h"
+#include "regs-dram.h"
+#include "regs-digctl.h"
+
+/* TODO should be move to clock.h */
+#define SCALING_DATA_EMI_DIV_OFFSET     0
+#define SCALING_DATA_FRAC_DIV_OFFSET    4
+#define SCALING_DATA_CUR_FREQ_OFFSET    8
+#define SCALING_DATA_NEW_FREQ_OFFSET    12
+#define REGS_CLKCTRL_BASE MX23_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define HW_CLKCTRL_EMI_ADDR (REGS_CLKCTRL_BASE + HW_CLKCTRL_EMI)
+#define HW_CLKCTRL_FRAC_SET_ADDR (REGS_CLKCTRL_BASE + HW_CLKCTRL_FRAC_SET)
+#define HW_CLKCTRL_FRAC_CLR_ADDR (REGS_CLKCTRL_BASE + HW_CLKCTRL_FRAC_CLR)
+#define HW_CLKCTRL_FRAC_ADDR (REGS_CLKCTRL_BASE + HW_CLKCTRL_FRAC)
+#define HW_EMI_CTRL_ADDR MX23_SOC_IO_ADDRESS(REGS_EMI_PHYS + HW_EMI_CTRL)
+#define HW_DRAM_CTL04_ADDR MX23_SOC_IO_ADDRESS(REGS_DRAM_PHYS + HW_DRAM_CTL04)
+#define HW_CLKCTRL_CLKSEQ_ADDR (REGS_CLKCTRL_BASE + HW_CLKCTRL_CLKSEQ)
+.global cpu_arm926_switch_mm
+
+.align 8
+ENTRY(mxs_ram_freq_scale)
+	stmfd	sp!, {r1 - r9, lr}
+
+	ldr	r5, [r0, #SCALING_DATA_NEW_FREQ_OFFSET]
+	ldr	r6, [r0, #SCALING_DATA_CUR_FREQ_OFFSET]
+	ldr	r7, [r0, #SCALING_DATA_EMI_DIV_OFFSET]
+	ldr	r8, [r0, #SCALING_DATA_FRAC_DIV_OFFSET]
+
+	adr	r9, __mxs_temp_stack
+
+	@ clean cache
+	ldr	r1, __mxs_flush_cache_addr
+	mov	lr, pc
+	mov	pc, r1
+
+	@ put DRAM into self refresh
+	ldr	r0, __mx23_dram_ctl00
+	ldr	r1, [r0, #0x20]
+	orr	r1, r1, #(1 << 8)
+	str	r1, [r0, #0x20]
+	@ wait for it to actually happen
+	ldr	r0, __mx23_dram_emi00
+1:	ldr	r1, [r0, #0x10]
+	tst	r1, #(1 << 1)
+	beq	1b
+	nop
+
+
+	@ RAM to clk from xtal
+	mov	r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0xFF000000)
+	mov	r1, #(1<<6)
+	str	r1, [r0, #4]
+	mov	r0, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+101:	ldr     r1, [r0]
+	tst     r1, #BM_CLKCTRL_EMI_BUSY_REF_XTAL
+	bne     101b
+
+	@ Gate ref_emi
+	mov	r0, #(HW_CLKCTRL_FRAC_SET_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_SET_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_SET_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_SET_ADDR & 0xFF000000)
+
+	mov r1, #(BM_CLKCTRL_FRAC_CLKGATEEMI)
+	str r1, [r0]
+
+
+	@ prepare for change
+	cmp	r5, #24
+	bgt	2f
+	bl	mx23_ram_24M_set_timings
+	b	44f
+2:	cmp	r5, #48
+	bgt	3f
+	bl	mx23_ram_48M_set_timings
+	b	55f
+3:	cmp	r5, #60
+	bgt	4f
+	bl	mx23_ram_60M_set_timings
+	b	55f
+4:	cmp	r5, #80
+	bgt	5f
+	bl	mx23_ram_80M_set_timings
+	b	55f
+5:	cmp	r5, #96
+	bgt	6f
+	bl	mx23_ram_96M_set_timings
+	b	55f
+6:	cmp	r5, #120
+	bgt	7f
+	bl	mx23_ram_120M_set_timings
+	b	55f
+7:	cmp     r5, #133
+	bgt	8f
+	bl	mx23_ram_133M_set_timings
+	b	55f
+8:	bl	mx23_ram_150M_set_timings
+
+
+44:
+
+	bl	__mx23_emi_set_values_xtal
+
+	@ resttore normal DRAM mode
+        ldr     r0, __mx23_dram_ctl00
+        ldr     r1, [r0, #0x20]
+        bic     r1, r1, #(1 << 8)
+        str     r1, [r0, #0x20]
+
+        @ wait for it to actually happen
+        ldr     r0, __mx23_dram_emi00
+99:    	ldr     r1, [r0, #0x10]
+        tst     r1, #(1 << 1)
+        bne     99b
+        b		110f
+
+55:
+	@When are using the DLL, reset the DRAM controller and DLL
+	@start point logic (via DLL_SHIFT_RESET and DLL_RESET).
+	@After changing clock dividers and loading
+	@the new HW_DRAM_CTL* parameters, we will wait for a new DLL_LOCK
+
+	@todo - for DRAM's that will use DLL bypass (non DDR1)
+	@	we should not use DLL_RESET and DLL_SHIFT_RESET.
+
+	mov     r0,     #(HW_EMI_CTRL_ADDR & 0x000000FF)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0x0000FF00)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0x00FF0000)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0xFF000000)
+	ldr     r1, [r0]            @read values of HW_EMI_CTRL into R1
+	orr r1, r1, #BM_EMI_CTRL_DLL_SHIFT_RESET    @Set these 2 fields.
+	orr r1, r1, #BM_EMI_CTRL_DLL_RESET
+	str     r1, [r0]            @write back values to HW_EMI_CTRL register.
+
+	bl __mx23_emi_set_values2
+
+	@ EMI back to PLL
+	mov	r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0xFF000000)
+	mov	r1, #(BM_CLKCTRL_CLKSEQ_BYPASS_EMI)
+	@clear bypass bit
+	str	r1, [r0, #8]
+
+	@ Wait for BUSY_REF_EMI, to assure new clock dividers
+	@ are done transferring
+	mov	r0, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+1:	ldr	r1, [r0]
+	tst	r1, #BM_CLKCTRL_EMI_BUSY_REF_EMI
+	bne	1b
+	str	r1, [r0]
+
+@todo - for DRAM's that will use DLL bypass (non DDR1)
+@we should not use DLL_RESET and DLL_SHIFT_RESET.
+@	if(HW_DRAM_CTL04.B.DLL_BYPASS_MODE==0)
+@	{
+@
+@	    Clear the DLL_RESET and DLL_SHIFT_RESET bitfields
+@	    (\todo - is that necessary?
+@	     they were already set previously to reset
+@            the controller/DLL start point,
+@	     so clearing should have no effect..)
+@
+@	     BF_CS2(EMI_CTRL, DLL_RESET, 0, DLL_SHIFT_RESET, 0);
+
+	mov     r0,     #(HW_EMI_CTRL_ADDR & 0x000000FF)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0x0000FF00)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0x00FF0000)
+	orr     r0, r0, #(HW_EMI_CTRL_ADDR & 0xFF000000)
+	ldr     r1, [r0]
+	bic r1, #BM_EMI_CTRL_DLL_SHIFT_RESET
+	bic r1, #BM_EMI_CTRL_DLL_RESET
+	str     r1, [r0]
+
+@ Wait for DLL locking.
+@        while(HW_DRAM_CTL04.B.DLLLOCKREG==0);
+
+	mov     r0,     #(HW_DRAM_CTL04_ADDR & 0x000000FF)
+	orr     r0, r0, #(HW_DRAM_CTL04_ADDR & 0x0000FF00)
+	orr     r0, r0, #(HW_DRAM_CTL04_ADDR & 0x00FF0000)
+	orr     r0, r0, #(HW_DRAM_CTL04_ADDR & 0xFF000000)
+77:	ldr     r1, [r0]
+	tst     r1, #BM_DRAM_CTL04_DLLLOCKREG
+	beq     77b
+
+88:
+	@ resttore normal DRAM mode
+        ldr     r0, __mx23_dram_ctl00
+        ldr     r1, [r0, #0x20]
+        bic     r1, r1, #(1 << 8)
+        str     r1, [r0, #0x20]
+
+        @ wait for it to actually happen
+        ldr     r0, __mx23_dram_emi00
+102:    ldr     r1, [r0, #0x10]
+        tst     r1, #(1 << 1)
+        bne     102b
+
+110:
+@ restore regs and return
+	ldmfd   sp!, {r1 - r9, lr}
+	mov	pc, lr
+
+	.space	0x100
+__mxs_temp_stack:
+	.word	0
+
+#include "emi.inc"
+
+__mxs_flush_cache_addr:
+	.word	arm926_flush_kern_cache_all
+
+ENTRY(mxs_ram_funcs_sz)
+	.word	. - mxs_ram_freq_scale
+
diff --git a/arch/arm/mach-mx23/emi.inc b/arch/arm/mach-mx23/emi.inc
new file mode 100644
index 0000000..290d35e
--- /dev/null
+++ b/arch/arm/mach-mx23/emi.inc
@@ -0,0 +1,667 @@
+/*
+ * Freescale MX23 low level RAM timings tables for Micron mDDR
+ *
+ * Author: Vitaly Wool <vital@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+__mx23_emi_set_values_xtal:
+	stmfd	r9!, {r0 - r4, lr}
+
+	mov	r1, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+
+32:	ldr	r4, [r1]
+	tst	r4, #BM_CLKCTRL_EMI_BUSY_REF_XTAL
+	bne	32b
+	b	4f
+
+__mx23_emi_set_values2:
+
+	stmfd	r9!, {r0 - r4, lr}
+
+	mov	r1, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r1, r1, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+
+	mov	r0, #(HW_CLKCTRL_FRAC_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0xFF000000)
+	ldr	r2, [r0]
+
+	@clear EMIFRAC bits and store result in r4
+	bic	r4, r2, #BM_CLKCTRL_FRAC_EMIFRAC
+
+	orr 	r4, r4, r8, lsl #BP_CLKCTRL_FRAC_EMIFRAC
+	str 	r4, [r0]
+
+	@ ungate ref_emi
+	mov	r0, #(HW_CLKCTRL_FRAC_CLR_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_CLR_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_CLR_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_CLR_ADDR & 0xFF000000)
+
+	mov r2, #(BM_CLKCTRL_FRAC_CLKGATEEMI)
+	str r2, [r0]
+
+
+	@ set the integer divider
+	ldr r2, [r1]
+	bic r2, r2, #BM_CLKCTRL_EMI_DIV_EMI
+	orr r2, r2, r7, lsl #BP_CLKCTRL_EMI_DIV_EMI
+
+	str r2, [r1]
+
+	@ wait for clock to stabilize
+50:	ldr	r2, [r1]
+	tst	r2, #BM_CLKCTRL_EMI_BUSY_REF_EMI
+	bne	50b
+	b 4f
+
+@ Change integer/fractional dividers.
+
+@ The fractional divider and integer divider must be written in such
+@  an order to guarantee that when going from a lower frequency to a
+@  higher frequency that any intermediate frequencies do not exceed
+@  the final frequency. For this reason, we must make sure to check
+@  the current divider values with the new divider values and write
+@  them in the correct order.
+
+1:	ldr	r4, [r1]
+	and	r4, r4, #BM_CLKCTRL_EMI_DIV_EMI
+	/* new emi div > cur emi div? */
+	cmp	r4, r7
+	bgt	2f
+	mov	r4, r7
+	orr	r4, r4, #0x100
+
+@ This was for DCC_RESYNC_ENABLE, which is deprecated in mx23
+@	orr	r4, r4, r3
+
+	str	r4, [r1]
+11:	ldr	r4, [r1]
+	tst	r4, #BM_CLKCTRL_EMI_BUSY_REF_EMI
+	bne	11b
+	tst	r4, #BM_CLKCTRL_EMI_BUSY_REF_XTAL
+	bne	11b
+
+2:	ldr	r2, [r0]
+
+	and	r4, r2, #BM_CLKCTRL_FRAC_EMIFRAC
+	lsr	r4, r4, #8
+	/* new pll div != cur pll div? */
+	cmp	r4, r8
+	beq	3f
+	bic	r4, r2, #BM_CLKCTRL_FRAC_EMIFRAC
+	orr	r4, r4, r8, lsl #8
+	str	r4, [r0]
+	nop
+	nop
+	nop
+
+3:	ldr	r4, [r1]
+	and	r4, r4, #BM_CLKCTRL_EMI_DIV_EMI
+	/* new emi div != cur emi div? */
+	cmp	r4, r7
+	beq	4f
+	mov	r4, r7
+	orr	r4, r4, #0x100
+
+@ This was for DCC_RESYNC_ENABLE, which is deprecated in mx23
+@	orr	r4, r4, r3
+	str	r4, [r1]
+31:	ldr	r4, [r1]
+	tst	r4, #BM_CLKCTRL_EMI_BUSY_REF_EMI
+	bne	31b
+
+4:	ldmfd	r9!, {r0 - r4, lr}
+	mov	pc, lr
+
+mx23_ram_24M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+#ifdef CONFIG_MXS_RAM_MDDR
+	adr	r1, __mx23_dram_24M_values
+#else
+//  96MHz is the lowest frequency supported for DDR1.
+	adr	r1, __mx23_dram_96M_values
+#endif
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_48M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+#ifdef CONFIG_MXS_RAM_MDDR
+	adr	r1, __mx23_dram_48M_values
+#else
+//  96MHz is the lowest frequency supported for DDR1.
+	adr	r1, __mx23_dram_96M_values
+#endif
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_60M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+#ifdef CONFIG_MXS_RAM_MDDR
+	adr	r1, __mx23_dram_60M_values
+#else
+//  96MHz is the lowest frequency supported for DDR1.
+	adr	r1, __mx23_dram_96M_values
+#endif
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_80M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+#ifdef CONFIG_MXS_RAM_MDDR
+	adr	r1, __mx23_dram_80M_values
+#else
+//  96MHz is the lowest frequency supported for DDR1.
+	adr	r1, __mx23_dram_96M_values
+#endif
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_96M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_96M_values
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_120M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_120M_values
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_133M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_133M_values
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	str	r3, [r0, r2, lsl #2]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+mx23_ram_150M_set_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_150M_values
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	str	r3, [r0, r2, lsl #2]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+__mx23_dram_ctl00:
+	.word 	MX23_SOC_IO_ADDRESS(REGS_DRAM_PHYS)
+__mx23_dram_emi00:
+	.word	MX23_SOC_IO_ADDRESS(REGS_EMI_PHYS)
+__mx23_power_vdddctrl:
+	.word	MX23_SOC_IO_ADDRESS(REGS_POWER_PHYS + HW_POWER_VDDDCTRL)
+
+mx23_ram_save_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_saved_values
+1:	ldr	r2, [r1]
+	mov	r4, r2, lsl #2
+	ldr	r3, [r0, r4]
+	str	r3, [r1, #4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+#ifdef CONFIG_MXS_RAM_MDDR
+__mx23_dram_24M_values:
+	.word    4
+	.word    0x01000101
+	.word    7
+	.word    0x01000101
+	.word    12
+	.word    0x02010002
+	.word    13
+	.word    0x06060a02
+	.word    15
+	.word    0x01030000
+	.word    17
+	.word    0x2d000102
+	.word    18
+	.word    0x20200000
+	.word    19
+	.word    0x027f1414
+	.word    20
+	.word    0x01021608
+	.word    21
+	.word    0x00000002
+	.word    26
+	.word    0x000000b3
+	.word    32
+	.word    0x00030687
+	.word    33
+	.word    0x00000003
+	.word    34
+	.word    0x000012c1
+	.word    40
+	.word    0x00010000
+
+__mx23_dram_48M_values:
+	.word    4
+	.word    0x01000101
+	.word    7
+	.word    0x01000101
+	.word    13
+	.word    0x06060a02
+	.word    12
+	.word    0x02010002
+	.word    15
+	.word    0x02040000
+	.word    17
+	.word    0x2d000104
+	.word    18
+	.word    0x1f1f0000
+	.word    19
+	.word    0x027f0a0a
+	.word    20
+	.word    0x02030a10
+	.word    21
+	.word    0x00000004
+	.word    26
+	.word    0x0000016f
+	.word    32
+	.word    0x00060d17
+	.word    33
+	.word    0x00000006
+	.word    34
+	.word    0x00002582
+	.word    40
+	.word    0x00020000
+
+__mx23_dram_60M_values:
+__mx23_dram_80M_values:
+	.word    4
+	.word    0x01000101
+	.word    7
+	.word    0x01000101
+	.word    12
+	.word    0x02020002
+	.word    13
+	.word    0x06060a02
+	.word    15
+	.word    0x02040000
+	.word    17
+	.word    0x2d000005
+	.word    18
+	.word    0x1f1f0000
+	.word    19
+	.word    0x027f0a0a
+	.word    20
+	.word    0x02040a10
+	.word    21
+	.word    0x00000006
+	.word    26
+	.word    0x000001cc
+	.word    32
+	.word    0x00081060
+	.word    33
+	.word    0x00000008
+	.word    34
+	.word    0x00002ee5
+	.word    40
+	.word    0x00020000
+
+__mx23_dram_96M_values:
+	.word    4
+	.word    0x00000101
+	.word    7
+	.word    0x01000001
+	.word    12
+	.word    0x02020002
+	.word    13
+	.word    0x06070a02
+	.word    15
+	.word    0x03050000
+	.word    17
+	.word    0x2d000808
+	.word    18
+	.word    0x1f1f0000
+	.word    19
+	.word    0x020c1010
+	.word    20
+	.word    0x0305101c
+	.word    21
+	.word    0x00000007
+	.word    26
+	.word    0x000002e6
+	.word    32
+	.word    0x000c1a3b
+	.word    33
+	.word    0x0000000c
+	.word    34
+	.word    0x00004b0d
+	.word    40
+	.word    0x00030000
+
+__mx23_dram_120M_values:
+	.word    4
+	.word    0x00000101
+	.word    7
+	.word    0x01000001
+	.word    12
+	.word    0x02020002
+	.word    13
+	.word    0x06070a02
+	.word    15
+	.word    0x03050000
+	.word    17
+	.word    0x2300080a
+	.word    18
+	.word    0x1f1f0000
+	.word    19
+	.word    0x020c1010
+	.word    20
+	.word    0x0306101c
+	.word    21
+	.word    0x00000009
+	.word    26
+	.word    0x000003a1
+	.word    32
+	.word    0x000f20ca
+	.word    33
+	.word    0x0000000f
+	.word    34
+	.word    0x00005dca
+	.word    40
+	.word    0x00040000
+
+__mx23_dram_133M_values:
+__mx23_dram_150M_values:
+	.word    4
+	.word    0x00000101
+	.word    7
+	.word    0x01000001
+	.word    12
+	.word    0x02020002
+	.word    13
+	.word    0x06070a02
+	.word    15
+	.word    0x03050000
+	.word    17
+	.word    0x2000080a
+	.word    18
+	.word    0x1f1f0000
+	.word    19
+	.word    0x020c1010
+	.word    20
+	.word    0x0306101c
+	.word    21
+	.word    0x0000000a
+	.word    26
+	.word    0x00000408
+	.word    32
+	.word    0x0010245f
+	.word    33
+	.word    0x00000010
+	.word    34
+	.word    0x00006808
+	.word    40
+	.word    0x00040000
+
+#elif CONFIG_MXS_RAM_DDR
+
+__mx23_dram_96M_values:
+	.word	4
+	.word	0x00000101
+	.word	7
+	.word	0x01000001
+	.word	11
+	.word	0x00070202
+	.word	12
+	.word	0x02020000 @ t_wr 2, t_rrd 2, t_cke 0
+	.word	13
+	.word	0x04040a01 @ t_wtr 1
+	.word	15
+	.word	0x02040000 @ t_rp 2, t_dal 4
+	.word	17
+	.word	0x2f001706 @ dll_start_point 0x2f, dll_increment 0x17, t_rc 6
+	.word	19
+	.word	0x027f1a1a
+	.word	20
+	.word	0x02051c21 @ t_rcd 2, t_rasmin 5, wr_dqs_shift 0x22
+	.word	21
+	.word	0x00000007 @ t_rfc 7
+	.word	26
+	.word	0x000002e6 /* 0x347b */ @ t_ref
+	.word	32
+	.word	0x00081a3e @ t_xsnr 8, t_rasmax 0x1a3e
+	.word	33
+	.word	0x000000c8 @ t_xsr 0xc8
+	.word	34
+	.word	0x00004b0d @ t_init
+	.word	40
+	.word	0x00010000
+
+__mx23_dram_120M_values:
+	.word	4
+	.word	0x00000101
+	.word	7
+	.word	0x01000001
+	.word	11
+	.word	0x00070202
+	.word	12
+	.word	0x02020000 @ t_wr 2, t_rrd 2, t_cke 0
+	.word	13
+	.word	0x04040a01 @ t_wtr 1
+	.word	15
+	.word	0x02040000 @ t_rp 2, t_dal 4
+	.word	17
+	.word	0x26001308 @ dll_start_point 0x26, dll_increment 0x13, t_rc 8
+	.word	19
+	.word	0x027f1a1a
+	.word	20
+	.word	0x02061c23 @ t_rcd 2, t_rasmin 6
+	.word	21
+	.word	0x00000009 @ t_rfc 9
+	.word	26
+	.word	0x000003a1 /* 0x41a6 */ @ t_ref
+	.word	32
+	.word	0x000a20ca @ t_xsnr 9, t_rasmax 0x20ca
+	.word	33
+	.word	0x000000c8 @ t_xsr 0xc8
+	.word	34
+	.word	0x00005dca @ t_init
+	.word	40
+	.word	0x00010000
+
+__mx23_dram_133M_values:
+	.word	4
+	.word	0x00000101
+	.word	7
+	.word	0x01000001
+	.word	11
+	.word	0x00070202
+	.word	12
+	.word	0x02020000
+	.word	13
+	.word	0x04040a01
+	.word	15
+	.word	0x02040000
+	.word	17
+	.word	0x19000f08 @ t_rc 0xa
+	.word	19
+	.word	0x02021313
+	.word	20
+	.word	0x02061521
+	.word	21
+	.word	0x0000000a
+	.word	26
+	.word	0x000003f7 /* 0x48b9 */
+	.word	32
+	.word	0x000a23cd
+	.word	33
+	.word	0x000000c8 @ t_xsr 0xc8
+	.word	34
+	.word	0x00006665
+	.word	40
+	.word	0x00010000
+
+__mx23_dram_150M_values:
+	.word	4
+	.word	0x00000101
+	.word	7
+	.word	0x01000001
+/*
+Note that CASLAT of 0x06 means 2.5 cycles.  This is needed to operate at this
+frequency. HOWEVER, we would need to implement the setting of WRITEMODEREG
+after setting CAS latency to assure that the new CAS latency is actually
+being used in the EMI controller.  Otherwise, the controller will still be
+using whatever was set the first time the EMI controller was initialized.
+Also, a CASLAT of 2.5 needs caslat_lin and caslat_lin_gate of 0x05
+(also 2.5 cycles).
+*/
+	.word	11
+	.word	0x00070206
+	.word	12
+	.word	0x02020000 @ t_wr 2, t_rrd 2, t_cke 0
+/*
+	caslat_lin and caslat_lin_gate of 0x05 since CASLAT is 0x06 (2.5 cycles).  See above note.
+*/
+	.word	13
+	.word	0x05050a02 @ t_wtr 2
+	.word	15
+	.word	0x03060000 @ t_rp 3, t_dal 6
+	.word	17
+	.word	0x18000d0c @ dll_start_point 0x18, dll_increment 0xd, t_rc 0xc
+	.word	19
+	.word	0x027f0f0f
+	.word	20
+	.word	0x03071121 @ t_rcd 3, t_rasmin 7
+	.word	21
+	.word	0x0000000c @ t_rfc 0xc
+	.word	26
+	.word	0x000001cc /* 0x20cd */ @ t_ref
+	.word	32
+	.word	0x000c2860 @ t_xsnr 0xc, t_rasmax 0x2860
+	.word	33
+	.word	0x000000c8 @ t_xsr 0xc8
+	.word	34
+	.word	0x00007554 @ t_init
+	.word	40
+	.word	0x00010000
+
+#else
+#error RAM chip not defined
+#endif
+
+mx23_ram_restore_timings:
+	ldr	r0, __mx23_dram_ctl00
+	adr	r1, __mx23_dram_saved_values
+1:	ldr	r2, [r1]
+	ldr	r3, [r1, #4]
+	mov	r4, r2, lsl #2
+	str	r3, [r0, r4]
+	add	r1, r1, #8
+	cmp	r2, #40
+	bne	1b
+	mov	pc, lr
+
+__mx23_dram_saved_values:
+	.word	4
+	.word	0
+	.word	7
+	.word	0
+	.word	12
+	.word	0
+	.word	13
+	.word	0
+	.word	15
+	.word	0
+	.word	17
+	.word	0
+	.word	18
+	.word	0
+	.word	19
+	.word	0
+	.word	20
+	.word	0
+	.word	21
+	.word	0
+	.word	26
+	.word	0
+	.word	32
+	.word	0
+	.word	33
+	.word	0
+	.word	34
+	.word	0
+	.word	40
+	.word	0
+
diff --git a/arch/arm/mach-mx23/gpio.c b/arch/arm/mach-mx23/gpio.c
new file mode 100644
index 0000000..fca4534
--- /dev/null
+++ b/arch/arm/mach-mx23/gpio.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include <mach/pinctrl.h>
+
+#include "regs-pinctrl.h"
+
+#define PINCTRL_BASE_ADDR IO_ADDRESS(PINCTRL_PHYS_ADDR)
+
+static int
+mx23_gpio_direction(struct mxs_gpio_port *port, int pin, unsigned int input)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	if (input)
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOE0_CLR);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOE0_SET);
+
+	return 0;
+}
+
+static int mx23_gpio_get(struct mxs_gpio_port *port, int pin)
+{
+	unsigned int data;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	data = __raw_readl(base + HW_PINCTRL_DIN0);
+	return data & (1 << pin);
+}
+
+static void mx23_gpio_set(struct mxs_gpio_port *port, int pin, int data)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	if (data)
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOUT0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOUT0_CLR);
+}
+
+static unsigned int mx23_gpio_irq_stat(struct mxs_gpio_port *port)
+{
+	unsigned int mask;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	mask = __raw_readl(base + HW_PINCTRL_IRQSTAT0);
+	mask &= __raw_readl(base + HW_PINCTRL_IRQEN0);
+	return mask;
+}
+
+static int
+mx23_gpio_set_irq_type(struct mxs_gpio_port *port, int pin, unsigned int type)
+{
+	unsigned int level, pol;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		level = 0;
+		pol = 1;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		level = 0;
+		pol = 0;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		level = 1;
+		pol = 1;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		level = 1;
+		pol = 0;
+		break;
+	default:
+		pr_debug("%s: Incorrect GPIO interrupt type 0x%x\n",
+			 __func__, type);
+		return -ENXIO;
+	}
+
+	if (level)
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQLEVEL0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQLEVEL0_CLR);
+
+	if (pol)
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQPOL0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQPOL0_CLR);
+
+	return 0;
+}
+
+static void mx23_gpio_unmask_irq(struct mxs_gpio_port *port, int pin)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	__raw_writel(1 << pin, base + HW_PINCTRL_IRQEN0_SET);
+}
+
+static void mx23_gpio_mask_irq(struct mxs_gpio_port *port, int pin)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	__raw_writel(1 << pin, base + HW_PINCTRL_IRQEN0_CLR);
+}
+
+static void mx23_gpio_ack_irq(struct mxs_gpio_port *port, int pin)
+{
+	unsigned int mask;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	mask = 1 << pin;
+	if (mask)
+		__raw_writel(mask, base + HW_PINCTRL_IRQSTAT0_CLR);
+}
+
+static struct mxs_gpio_port mx23_gpios[] = {
+	{
+	 .irq = IRQ_GPIO0,
+	 },
+	{
+	 .irq = IRQ_GPIO1,
+	 },
+	{
+	 .irq = IRQ_GPIO2,
+	 },
+};
+
+static struct mxs_gpio_chip mx23_gpio_chip = {
+	.set_dir = mx23_gpio_direction,
+	.get = mx23_gpio_get,
+	.set = mx23_gpio_set,
+	.get_irq_stat = mx23_gpio_irq_stat,
+	.set_irq_type = mx23_gpio_set_irq_type,
+	.unmask_irq = mx23_gpio_unmask_irq,
+	.mask_irq = mx23_gpio_mask_irq,
+	.ack_irq = mx23_gpio_ack_irq,
+};
+
+int __init mx23_gpio_init(void)
+{
+	int i;
+	unsigned int reg;
+	if (__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR) &
+	    BM_PINCTRL_CTRL_SFTRST) {
+		__raw_writel(BM_PINCTRL_CTRL_SFTRST,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+		for (i = 0; i < 10000; i++) {
+			if (!(__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL) &
+			      BM_PINCTRL_CTRL_SFTRST))
+				break;
+			udelay(2);
+		}
+		if (i >= 10000)
+			return -EFAULT;
+
+		__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	}
+
+	reg = __raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL);
+	for (i = 0; i < ARRAY_SIZE(mx23_gpios); i++) {
+		void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * i;
+		if (!(reg & (BM_PINCTRL_CTRL_PRESENT0 << i)))
+			continue;
+		mxs_set_gpio_chip(&mx23_gpios[i], &mx23_gpio_chip);
+		mx23_gpios[i].id = i;
+		__raw_writel(0, base + HW_PINCTRL_IRQEN0);
+		__raw_writel(0xFFFFFFFF, base + HW_PINCTRL_PIN2IRQ0);
+		mx23_gpios[i].child_irq = MXS_GPIO_IRQ_START +
+		    (i * PINS_PER_BANK);
+		mxs_add_gpio_port(&mx23_gpios[i]);
+	}
+	return 0;
+}
diff --git a/arch/arm/mach-mx23/include/mach/dma.h b/arch/arm/mach-mx23/include/mach/dma.h
new file mode 100644
index 0000000..ae4b778
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/dma.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_DMA_H__
+#define __ASM_ARCH_MACH_DMA_H__
+
+enum {
+	MXS_DMA_CHANNEL_AHB_APBH = 0,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP0 = MXS_DMA_CHANNEL_AHB_APBH,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP2,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	MXS_DMA_CHANNEL_AHB_APBH_HSADC,
+	MXS_DMA_CHANNEL_AHB_APBH_LCDIF,
+	MXS_DMA_CHANNEL_AHB_APBH_14,
+	MXS_DMA_CHANNEL_AHB_APBH_15,
+	MXS_DMA_CHANNEL_AHB_APBX = 16,
+	MXS_DMA_CHANNEL_AHB_APBX_AUDIOADC = MXS_DMA_CHANNEL_AHB_APBX,
+	MXS_DMA_CHANNEL_AHB_APBX_AUDIODAC,
+	MXS_DMA_CHANNEL_AHB_APBX_SPDIF,
+	MXS_DMA_CHANNEL_AHB_APBX_I2C,
+	MXS_DMA_CHANNEL_AHB_APBX_SAIF1,
+	MXS_DMA_CHANNEL_AHB_APBX_DRI,
+	MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_SAIF2,
+	MXS_DMA_CHANNEL_AHB_APBX_RESERVED1,
+	MXS_DMA_CHANNEL_AHB_APBX_RESERVED2,
+	MXS_DMA_CHANNEL_AHB_APBX_RESERVED3,
+	MXS_DMA_CHANNEL_AHB_APBX_RESERVED4,
+	MXS_DMA_CHANNEL_AHB_APBX_RESERVED5,
+	MAX_DMA_CHANNELS,
+};
+#endif /* __ASM_ARCH_MACH_MX23_H__ */
diff --git a/arch/arm/mach-mx23/include/mach/irqs.h b/arch/arm/mach-mx23/include/mach/irqs.h
new file mode 100644
index 0000000..5d5211b
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/irqs.h
@@ -0,0 +1,102 @@
+/*
+ * Freescale STMP378X interrupts
+ *
+ * Copyright (C) 2005 Sigmatel Inc
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#define IRQ_DEBUG_UART			0
+#define IRQ_COMMS_RX			1
+#define IRQ_COMMS_TX			1
+#define IRQ_SSP2_ERROR			2
+#define IRQ_VDD5V			3
+#define IRQ_HEADPHONE_SHORT		4
+#define IRQ_DAC_DMA			5
+#define IRQ_DAC_ERROR			6
+#define IRQ_ADC_DMA			7
+#define IRQ_ADC_ERROR			8
+#define IRQ_SPDIF_DMA			9
+#define IRQ_SAIF2_DMA			9
+#define IRQ_SPDIF_ERROR			10
+#define IRQ_SAIF1_IRQ			10
+#define IRQ_SAIF2_IRQ			10
+#define IRQ_USB_CTRL			11
+#define IRQ_USB_WAKEUP			12
+#define IRQ_GPMI_DMA			13
+#define IRQ_SSP1_DMA			14
+#define IRQ_SSP_ERROR			15
+#define IRQ_GPIO0			16
+#define IRQ_GPIO1			17
+#define IRQ_GPIO2			18
+#define IRQ_SAIF1_DMA			19
+#define IRQ_SSP2_DMA			20
+#define IRQ_ECC8_IRQ			21
+#define IRQ_RTC_ALARM			22
+#define IRQ_UARTAPP_TX_DMA		23
+#define IRQ_UARTAPP_INTERNAL		24
+#define IRQ_UARTAPP_RX_DMA		25
+#define IRQ_I2C_DMA			26
+#define IRQ_I2C_ERROR			27
+#define IRQ_TIMER0			28
+#define IRQ_TIMER1			29
+#define IRQ_TIMER2			30
+#define IRQ_TIMER3			31
+#define IRQ_BATT_BRNOUT			32
+#define IRQ_VDDD_BRNOUT			33
+#define IRQ_VDDIO_BRNOUT		34
+#define IRQ_VDD18_BRNOUT		35
+#define IRQ_TOUCH_DETECT		36
+#define IRQ_LRADC_CH0			37
+#define IRQ_LRADC_CH1			38
+#define IRQ_LRADC_CH2			39
+#define IRQ_LRADC_CH3			40
+#define IRQ_LRADC_CH4			41
+#define IRQ_LRADC_CH5			42
+#define IRQ_LRADC_CH6			43
+#define IRQ_LRADC_CH7			44
+#define IRQ_LCDIF_DMA			45
+#define IRQ_LCDIF_ERROR			46
+#define IRQ_DIGCTL_DEBUG_TRAP		47
+#define IRQ_RTC_1MSEC			48
+#define IRQ_DRI_DMA			49
+#define IRQ_DRI_ATTENTION		50
+#define IRQ_GPMI_ATTENTION		51
+#define IRQ_IR				52
+#define IRQ_DCP_VMI			53
+#define IRQ_DCP				54
+#define IRQ_BCH				56
+#define IRQ_PXP				57
+#define IRQ_UARTAPP2_TX_DMA		58
+#define IRQ_UARTAPP2_INTERNAL		59
+#define IRQ_UARTAPP2_RX_DMA		60
+#define IRQ_VDAC_DETECT			61
+#define IRQ_VDD5V_DROOP			64
+#define IRQ_DCDC4P2_BO			65
+
+
+#define NR_REAL_IRQS	128
+#define NR_IRQS		(NR_REAL_IRQS + 32 * 3)
+#define ARCH_NR_IRQS 	NR_REAL_IRQS
+
+/* All interrupts are FIQ capable */
+#define FIQ_START		IRQ_DEBUG_UART
+
+/* Hard disk IRQ is a GPMI attention IRQ */
+#define IRQ_HARDDISK		IRQ_GPMI_ATTENTION
+
+#ifndef __ASSEMBLY__
+void mxs_set_irq_fiq(unsigned int irq, unsigned int type);
+void mxs_enable_fiq_functionality(int enable);
+#endif
+
diff --git a/arch/arm/mach-mx23/include/mach/lcdif.h b/arch/arm/mach-mx23/include/mach/lcdif.h
new file mode 100644
index 0000000..f128020
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/lcdif.h
@@ -0,0 +1,441 @@
+/*
+ * Freescale MXS LCDIF interfaces
+ *
+ * Author: Vitaly Wool <vital@embeddedalley.com>
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _ARCH_ARM_LCDIF_H
+#define _ARCH_ARM_LCDIF_H
+
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <linux/backlight.h>
+#include <linux/dma-mapping.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+
+#include <mach/device.h>
+#include <mach/hardware.h>
+
+#include "regs-lcdif.h"
+
+#define REGS_LCDIF_BASE IO_ADDRESS(LCDIF_PHYS_ADDR)
+
+enum {
+	SPI_MOSI = 0,
+	SPI_SCLK,
+	SPI_CS,
+};
+
+struct mxs_lcd_dma_chain_info {
+	dma_addr_t *dma_addr_p;
+	unsigned offset;
+};
+
+enum {
+	MXS_LCD_PANEL_SYSTEM = 0,
+	MXS_LCD_PANEL_VSYNC,
+	MXS_LCD_PANEL_DOTCLK,
+	MXS_LCD_PANEL_DVI,
+};
+
+struct mxs_platform_bl_data;
+struct mxs_platform_fb_entry {
+	char name[16];
+	u16 x_res;
+	u16 y_res;
+	u16 bpp;
+	u32 cycle_time_ns;
+	int lcd_type;
+	int (*init_panel) (struct device *, dma_addr_t, int,
+			   struct mxs_platform_fb_entry *);
+	void (*release_panel) (struct device *, struct mxs_platform_fb_entry *);
+	int (*blank_panel) (int);
+	void (*run_panel) (void);
+	void (*stop_panel) (void);
+	int (*pan_display) (dma_addr_t);
+	int (*update_panel) (void *, struct mxs_platform_fb_entry *);
+	struct list_head link;
+	struct mxs_platform_bl_data *bl_data;
+};
+
+struct mxs_platform_fb_data {
+	struct list_head list;
+	struct mxs_platform_fb_entry *cur;
+	struct mxs_platform_fb_entry *next;
+};
+
+#define MXS_LCDIF_PANEL_INIT	1
+#define MXS_LCDIF_PANEL_RELEASE	2
+
+struct mxs_platform_bl_data {
+	struct list_head list;
+	struct regulator *regulator;
+	int bl_gpio;
+	int bl_max_intensity;
+	int bl_cons_intensity;
+	int bl_default_intensity;
+	int (*init_bl) (struct mxs_platform_bl_data *);
+	int (*set_bl_intensity) (struct mxs_platform_bl_data *,
+				 struct backlight_device *, int);
+	void (*free_bl) (struct mxs_platform_bl_data *);
+};
+
+static inline void mxs_lcd_register_entry(struct mxs_platform_fb_entry
+					  *pentry, struct mxs_platform_fb_data
+					  *pdata)
+{
+	list_add_tail(&pentry->link, &pdata->list);
+	if (!pdata->cur)
+		pdata->cur = pentry;
+}
+
+static inline void mxs_lcd_move_pentry_up(struct mxs_platform_fb_entry
+					  *pentry, struct mxs_platform_fb_data
+					  *pdata)
+{
+	list_move(&pentry->link, &pdata->list);
+}
+
+static inline int mxs_lcd_iterate_pdata(struct mxs_platform_fb_data
+					*pdata,
+					int (*func) (struct
+						     mxs_platform_fb_entry
+						     * pentry, void *data,
+						     int ret_prev), void *data)
+{
+	struct mxs_platform_fb_entry *pentry;
+	int ret = 0;
+	list_for_each_entry(pentry, &pdata->list, link) {
+		ret = func(pentry, data, ret);
+	}
+	return ret;
+}
+
+static inline void mxs_lcd_set_bl_pdata(struct mxs_platform_bl_data
+					*pdata)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-bl", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->dev.platform_data = pdata;
+}
+
+void mxs_init_lcdif(void);
+int mxs_lcdif_dma_init(struct device *dev, dma_addr_t phys, int memsize);
+void mxs_lcdif_dma_release(void);
+void mxs_lcdif_run(void);
+void mxs_lcdif_stop(void);
+int mxs_lcdif_pan_display(dma_addr_t addr);
+
+int mxs_lcdif_register_client(struct notifier_block *nb);
+void mxs_lcdif_unregister_client(struct notifier_block *nb);
+void mxs_lcdif_notify_clients(unsigned long event,
+			      struct mxs_platform_fb_entry *pentry);
+
+#ifndef FBIO_WAITFORVSYNC
+#define FBIO_WAITFORVSYNC		_IOW('F', 0x20, u_int32_t)
+#endif
+
+static inline void setup_dotclk_panel(u16 v_pulse_width,
+				      u16 v_period,
+				      u16 v_wait_cnt,
+				      u16 v_active,
+				      u16 h_pulse_width,
+				      u16 h_period,
+				      u16 h_wait_cnt,
+				      u16 h_active, int enable_present)
+{
+	u32 val;
+
+	__raw_writel(BM_LCDIF_CTRL_DATA_SHIFT_DIR,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+	__raw_writel(BM_LCDIF_CTRL_SHIFT_NUM_BITS,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+	__raw_writel(BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL1_CLR);
+	__raw_writel(BF_LCDIF_CTRL1_BYTE_PACKING_FORMAT(7) |
+		     BM_LCDIF_CTRL1_RECOVER_ON_UNDERFLOW,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL1_SET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+	val &= ~(BM_LCDIF_TRANSFER_COUNT_V_COUNT |
+		 BM_LCDIF_TRANSFER_COUNT_H_COUNT);
+	val |= BF_LCDIF_TRANSFER_COUNT_H_COUNT(h_active) |
+	    BF_LCDIF_TRANSFER_COUNT_V_COUNT(v_active);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+
+	__raw_writel(BM_LCDIF_CTRL_VSYNC_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_WAIT_FOR_VSYNC_EDGE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_DVI_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_DOTCLK_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	__raw_writel(BM_LCDIF_CTRL_BYPASS_COUNT,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+	__raw_writel(BM_LCDIF_CTRL_WORD_LENGTH |
+		     BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE |
+		     BM_LCDIF_CTRL_LCD_DATABUS_WIDTH,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BF_LCDIF_CTRL_WORD_LENGTH(3) |/* 24 bit */
+		     BM_LCDIF_CTRL_DATA_SELECT |/* data mode */
+		     BF_LCDIF_CTRL_INPUT_DATA_SWIZZLE(0) |/* no swap */
+		     BF_LCDIF_CTRL_LCD_DATABUS_WIDTH(3),/* 24 bit */
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_POL |
+		 BM_LCDIF_VDCTRL0_HSYNC_POL |
+		 BM_LCDIF_VDCTRL0_ENABLE_POL | BM_LCDIF_VDCTRL0_DOTCLK_POL);
+	val |= BM_LCDIF_VDCTRL0_ENABLE_POL | BM_LCDIF_VDCTRL0_DOTCLK_POL;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_OEB);
+	/* vsync is output */
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	/*
+	 * need enable sig for true RGB i/f.  Or, if not true RGB, leave it
+	 * zero.
+	 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val |= BM_LCDIF_VDCTRL0_ENABLE_PRESENT;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	/*
+	 * For DOTCLK mode, count VSYNC_PERIOD in terms of complete hz lines
+	 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT |
+		 BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT);
+	val |= BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT |
+	    BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	__raw_writel(BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH,
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0_CLR);
+	__raw_writel(v_pulse_width, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0_SET);
+
+	__raw_writel(BF_LCDIF_VDCTRL1_VSYNC_PERIOD(v_period),
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL1);
+
+	__raw_writel(BF_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH(h_pulse_width) |
+		     BF_LCDIF_VDCTRL2_HSYNC_PERIOD(h_period),
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL2);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+	val &= ~BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT;
+	val |= BF_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT(h_active);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+	val &= ~(BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT |
+		 BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT);
+	val |= BF_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT(h_wait_cnt) |
+	    BF_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT(v_wait_cnt);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+	val |= BM_LCDIF_VDCTRL4_SYNC_SIGNALS_ON;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+}
+
+static inline void release_dotclk_panel(void)
+{
+	__raw_writel(BM_LCDIF_CTRL_DOTCLK_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL1);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL2);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+}
+
+static inline void setup_dvi_panel(u16 h_active, u16 v_active,
+				   u16 h_blanking, u16 v_lines,
+				   u16 v1_blank_start, u16 v1_blank_end,
+				   u16 v2_blank_start, u16 v2_blank_end,
+				   u16 f1_start, u16 f1_end,
+				   u16 f2_start, u16 f2_end)
+{
+	u32 val;
+	/* 32bit packed format (RGB) */
+	__raw_writel(BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT,
+			REGS_LCDIF_BASE + HW_LCDIF_CTRL1_CLR);
+	__raw_writel(BF_LCDIF_CTRL1_BYTE_PACKING_FORMAT(0x7) |
+		      BM_LCDIF_CTRL1_RECOVER_ON_UNDERFLOW,
+		      REGS_LCDIF_BASE + HW_LCDIF_CTRL1_SET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+	val &= ~(BM_LCDIF_TRANSFER_COUNT_V_COUNT |
+			BM_LCDIF_TRANSFER_COUNT_H_COUNT);
+	val |= BF_LCDIF_TRANSFER_COUNT_H_COUNT(h_active) |
+			BF_LCDIF_TRANSFER_COUNT_V_COUNT(v_active);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+
+	/* set lcdif to DVI mode */
+	__raw_writel(BM_LCDIF_CTRL_DVI_MODE,
+		REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	__raw_writel(BM_LCDIF_CTRL_VSYNC_MODE,
+			REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_DOTCLK_MODE,
+			REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+	__raw_writel(BM_LCDIF_CTRL_BYPASS_COUNT,
+		      REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	/* convert input RGB -> YCbCr */
+	__raw_writel(BM_LCDIF_CTRL_RGB_TO_YCBCR422_CSC,
+		      REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	/* interlace odd and even fields */
+	__raw_writel(BM_LCDIF_CTRL1_INTERLACE_FIELDS,
+		      REGS_LCDIF_BASE + HW_LCDIF_CTRL1_SET);
+
+	__raw_writel(BM_LCDIF_CTRL_WORD_LENGTH |
+			BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE |
+			BM_LCDIF_CTRL_LCD_DATABUS_WIDTH,
+			REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BF_LCDIF_CTRL_WORD_LENGTH(3) |	/* 24 bit */
+		      BM_LCDIF_CTRL_DATA_SELECT |	/* data mode */
+		      BF_LCDIF_CTRL_INPUT_DATA_SWIZZLE(0) |	/* no swap */
+		      BF_LCDIF_CTRL_LCD_DATABUS_WIDTH(1),	/* 8 bit */
+		      REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+	/* LCDIF_DVI */
+	/* set frame size */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_DVICTRL0);
+	val &= ~(BM_LCDIF_DVICTRL0_H_ACTIVE_CNT |
+		      BM_LCDIF_DVICTRL0_H_BLANKING_CNT |
+		      BM_LCDIF_DVICTRL0_V_LINES_CNT);
+	val |= BF_LCDIF_DVICTRL0_H_ACTIVE_CNT(1440) |
+		      BF_LCDIF_DVICTRL0_H_BLANKING_CNT(h_blanking) |
+		      BF_LCDIF_DVICTRL0_V_LINES_CNT(v_lines);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_DVICTRL0);
+
+	/* set start/end of field-1 and start of field-2 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_DVICTRL1);
+	val &= ~(BM_LCDIF_DVICTRL1_F1_START_LINE |
+		      BM_LCDIF_DVICTRL1_F1_END_LINE |
+		      BM_LCDIF_DVICTRL1_F2_START_LINE);
+	val |= BF_LCDIF_DVICTRL1_F1_START_LINE(f1_start) |
+		BF_LCDIF_DVICTRL1_F1_END_LINE(f1_end) |
+		BF_LCDIF_DVICTRL1_F2_START_LINE(f2_start);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_DVICTRL1);
+
+	/* set first vertical blanking interval and end of filed-2 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_DVICTRL2);
+	val &= ~(BM_LCDIF_DVICTRL2_F2_END_LINE |
+		      BM_LCDIF_DVICTRL2_V1_BLANK_START_LINE |
+		      BM_LCDIF_DVICTRL2_V1_BLANK_END_LINE);
+	val |= BF_LCDIF_DVICTRL2_F2_END_LINE(f2_end) |
+		      BF_LCDIF_DVICTRL2_V1_BLANK_START_LINE(v1_blank_start) |
+		      BF_LCDIF_DVICTRL2_V1_BLANK_END_LINE(v1_blank_end);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_DVICTRL2);
+
+	/* set second vertical blanking interval */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_DVICTRL3);
+	val &= ~(BM_LCDIF_DVICTRL3_V2_BLANK_START_LINE |
+		      BM_LCDIF_DVICTRL3_V2_BLANK_END_LINE);
+	val |= BF_LCDIF_DVICTRL3_V2_BLANK_START_LINE(v2_blank_start) |
+		      BF_LCDIF_DVICTRL3_V2_BLANK_END_LINE(v2_blank_end);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_DVICTRL3);
+
+	/* fill the rest area black color if the input frame
+	 * is not 720 pixels/line
+	 */
+	if (h_active != 720) {
+		/* the input frame can't be less then (720-256) pixels/line */
+		if (720 - h_active > 0xff)
+			h_active = 720 - 0xff;
+
+		val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_DVICTRL4);
+		val &= ~(BM_LCDIF_DVICTRL4_H_FILL_CNT |
+			      BM_LCDIF_DVICTRL4_Y_FILL_VALUE |
+			      BM_LCDIF_DVICTRL4_CB_FILL_VALUE |
+			      BM_LCDIF_DVICTRL4_CR_FILL_VALUE);
+		val |= BF_LCDIF_DVICTRL4_H_FILL_CNT(720 - h_active) |
+			      BF_LCDIF_DVICTRL4_Y_FILL_VALUE(16) |
+			      BF_LCDIF_DVICTRL4_CB_FILL_VALUE(128) |
+			      BF_LCDIF_DVICTRL4_CR_FILL_VALUE(128);
+		__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_DVICTRL4);
+	}
+
+	/* Color Space Conversion RGB->YCbCr */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF0);
+	val &= ~(BM_LCDIF_CSC_COEFF0_C0 |
+		      BM_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER);
+	val |= BF_LCDIF_CSC_COEFF0_C0(0x41) |
+		      BF_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER(3);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF0);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF1);
+	val &= ~(BM_LCDIF_CSC_COEFF1_C1 | BM_LCDIF_CSC_COEFF1_C2);
+	val |= BF_LCDIF_CSC_COEFF1_C1(0x81) |
+		      BF_LCDIF_CSC_COEFF1_C2(0x19);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF1);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF2);
+	val &= ~(BM_LCDIF_CSC_COEFF2_C3 | BM_LCDIF_CSC_COEFF2_C4);
+	val |= BF_LCDIF_CSC_COEFF2_C3(0x3DB) |
+		      BF_LCDIF_CSC_COEFF2_C4(0x3B6);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF2);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF3);
+	val &= ~(BM_LCDIF_CSC_COEFF3_C5 | BM_LCDIF_CSC_COEFF3_C6);
+	val |= BF_LCDIF_CSC_COEFF3_C5(0x70) |
+		      BF_LCDIF_CSC_COEFF3_C6(0x70);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF3);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF4);
+	val &= ~(BM_LCDIF_CSC_COEFF4_C7 | BM_LCDIF_CSC_COEFF4_C8);
+	val |= BF_LCDIF_CSC_COEFF4_C7(0x3A2) | BF_LCDIF_CSC_COEFF4_C8(0x3EE);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_COEFF4);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_OFFSET);
+	val &= ~(BM_LCDIF_CSC_OFFSET_CBCR_OFFSET
+		| BM_LCDIF_CSC_OFFSET_Y_OFFSET);
+	val |= BF_LCDIF_CSC_OFFSET_CBCR_OFFSET(0x80) |
+		      BF_LCDIF_CSC_OFFSET_Y_OFFSET(0x10);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_OFFSET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_CSC_LIMIT);
+	val &= ~(BM_LCDIF_CSC_LIMIT_CBCR_MIN |
+		      BM_LCDIF_CSC_LIMIT_CBCR_MAX |
+		      BM_LCDIF_CSC_LIMIT_Y_MIN |
+		      BM_LCDIF_CSC_LIMIT_Y_MAX);
+	val |= BF_LCDIF_CSC_LIMIT_CBCR_MIN(16) |
+		      BF_LCDIF_CSC_LIMIT_CBCR_MAX(240) |
+		      BF_LCDIF_CSC_LIMIT_Y_MIN(16) |
+		      BF_LCDIF_CSC_LIMIT_Y_MAX(235);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_CSC_LIMIT);
+}
+
+static inline void release_dvi_panel(void)
+{
+	__raw_writel(BM_LCDIF_CTRL_DVI_MODE,
+			REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+}
+#endif /* _ARCH_ARM_LCDIF_H */
diff --git a/arch/arm/mach-mx23/include/mach/mx23.h b/arch/arm/mach-mx23/include/mach/mx23.h
new file mode 100644
index 0000000..6e1d2aa
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/mx23.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_MX23_H___
+#define __ASM_ARCH_MACH_MX23_H___
+
+#include <asm/sizes.h>
+#include <mach/irqs.h>
+
+#define MX23_SOC_IO_PHYS_BASE	0x80000000
+#define MX23_SOC_IO_VIRT_BASE	0xF0000000
+#define MX23_SOC_IO_AREA_SIZE	SZ_1M
+
+/* Virtual address where OCRAM is mapped */
+#define MX23_OCRAM_PHBASE   0x00000000
+#ifdef __ASSEMBLER__
+#define MX23_OCRAM_BASE     0xf1000000
+#else
+#define MX23_OCRAM_BASE     (void __iomem *)0xf1000000
+#endif
+#define MX23_OCRAM_SIZE     (32 * SZ_1K)
+
+#define ICOLL_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x000000)
+#define APBH_DMA_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x004000)
+#define BCH_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x00A000)
+#define GPMI_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x00C000)
+#define SSP1_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x010000)
+#define SSP2_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x034000)
+#define PINCTRL_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x018000)
+#define DIGCTL_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x01C000)
+#define ETM_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x020000)
+#define APBX_DMA_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x024000)
+#define DCP_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x028000)
+#define PXP_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x02A000)
+#define OCOTP_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x02C000)
+#define AXI_AHB0_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x02E000)
+#define LCDIF_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x030000)
+#define TVENC_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x038000)
+#define CLKCTRL_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x040000)
+#define SAIF0_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x042000)
+#define POWER_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x044000)
+#define SAIF1_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x046000)
+#define AUDIOOUT_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x048000)
+#define AUDIOIN_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x04c000)
+#define LRADC_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x050000)
+#define SPDIF_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x054000)
+#define RTC_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x05c000)
+#define I2C0_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x058000)
+#define PWM_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x064000)
+#define TIMROT_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x068000)
+#define AUART1_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x06C000)
+#define AUART2_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x06E000)
+#define DUART_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x070000)
+#define USBPHY_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x07C000)
+#define USBCTRL_PHYS_ADDR	(MX23_SOC_IO_PHYS_BASE + 0x080000)
+#define DRAM_PHYS_ADDR		(MX23_SOC_IO_PHYS_BASE + 0x0E0000)
+
+#define MX23_SOC_IO_ADDRESS(x) \
+	((x) - MX23_SOC_IO_PHYS_BASE + MX23_SOC_IO_VIRT_BASE)
+
+#ifdef __ASSEMBLER__
+#define IO_ADDRESS(x)		\
+		MX23_SOC_IO_ADDRESS(x)
+#else
+#define IO_ADDRESS(x)		\
+	(void __force __iomem *) 	\
+	(((x) >= (unsigned long)MX23_SOC_IO_PHYS_BASE) && \
+	 ((x) < (unsigned long)MX23_SOC_IO_PHYS_BASE + \
+				MX23_SOC_IO_AREA_SIZE) ? \
+		MX23_SOC_IO_ADDRESS(x) : 0xDEADBEEF)
+#endif
+
+#ifdef CONFIG_MXS_EARLY_CONSOLE
+#define MXS_DEBUG_CONSOLE_PHYS DUART_PHYS_ADDR
+#define MXS_DEBUG_CONSOLE_VIRT IO_ADDRESS(DUART_PHYS_ADDR)
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+#define MXS_LL_UART_PADDR DUART_PHYS_ADDR
+#define MXS_LL_UART_VADDR MX23_SOC_IO_ADDRESS(DUART_PHYS_ADDR)
+#endif
+
+#ifndef __ASSEMBLY__
+/* for using the mma7450.c file ,we
+need to define this struct */
+struct mxc_mma7450_platform_data {
+	char *reg_dvdd_io;
+	char *reg_avdd;
+	void (*gpio_pin_get) (void);
+	void (*gpio_pin_put) (void);
+	int int1;
+	int int2;
+};
+#endif
+
+#endif /* __ASM_ARCH_MACH_MX23_H__ */
diff --git a/arch/arm/mach-mx23/include/mach/regs-apbh.h b/arch/arm/mach-mx23/include/mach/regs-apbh.h
new file mode 100644
index 0000000..e3ee9be
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-apbh.h
@@ -0,0 +1,358 @@
+/*
+ * Freescale APBH Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.57
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___APBH_H
+#define __ARCH_ARM___APBH_H
+
+
+#define HW_APBH_CTRL0	(0x00000000)
+#define HW_APBH_CTRL0_SET	(0x00000004)
+#define HW_APBH_CTRL0_CLR	(0x00000008)
+#define HW_APBH_CTRL0_TOG	(0x0000000c)
+
+#define BM_APBH_CTRL0_SFTRST	0x80000000
+#define BM_APBH_CTRL0_CLKGATE	0x40000000
+#define BM_APBH_CTRL0_AHB_BURST8_EN	0x20000000
+#define BM_APBH_CTRL0_APB_BURST4_EN	0x10000000
+#define BP_APBH_CTRL0_RSVD0	24
+#define BM_APBH_CTRL0_RSVD0	0x0F000000
+#define BF_APBH_CTRL0_RSVD0(v)  \
+		(((v) << 24) & BM_APBH_CTRL0_RSVD0)
+#define BP_APBH_CTRL0_RESET_CHANNEL	16
+#define BM_APBH_CTRL0_RESET_CHANNEL	0x00FF0000
+#define BF_APBH_CTRL0_RESET_CHANNEL(v)  \
+		(((v) << 16) & BM_APBH_CTRL0_RESET_CHANNEL)
+#define BV_APBH_CTRL0_RESET_CHANNEL__SSP1  0x02
+#define BV_APBH_CTRL0_RESET_CHANNEL__SSP2  0x04
+#define BV_APBH_CTRL0_RESET_CHANNEL__ATA   0x10
+#define BV_APBH_CTRL0_RESET_CHANNEL__NAND0 0x10
+#define BV_APBH_CTRL0_RESET_CHANNEL__NAND1 0x20
+#define BV_APBH_CTRL0_RESET_CHANNEL__NAND2 0x40
+#define BV_APBH_CTRL0_RESET_CHANNEL__NAND3 0x80
+#define BP_APBH_CTRL0_CLKGATE_CHANNEL	8
+#define BM_APBH_CTRL0_CLKGATE_CHANNEL	0x0000FF00
+#define BF_APBH_CTRL0_CLKGATE_CHANNEL(v)  \
+		(((v) << 8) & BM_APBH_CTRL0_CLKGATE_CHANNEL)
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP1  0x02
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP2  0x04
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__ATA   0x10
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND0 0x10
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND1 0x20
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND2 0x40
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND3 0x80
+#define BP_APBH_CTRL0_FREEZE_CHANNEL	0
+#define BM_APBH_CTRL0_FREEZE_CHANNEL	0x000000FF
+#define BF_APBH_CTRL0_FREEZE_CHANNEL(v)  \
+		(((v) << 0) & BM_APBH_CTRL0_FREEZE_CHANNEL)
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__SSP1  0x02
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__SSP2  0x04
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__ATA   0x10
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__NAND0 0x10
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__NAND1 0x20
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__NAND2 0x40
+#define BV_APBH_CTRL0_FREEZE_CHANNEL__NAND3 0x80
+
+#define HW_APBH_CTRL1	(0x00000010)
+#define HW_APBH_CTRL1_SET	(0x00000014)
+#define HW_APBH_CTRL1_CLR	(0x00000018)
+#define HW_APBH_CTRL1_TOG	(0x0000001c)
+
+#define BP_APBH_CTRL1_RSVD1	24
+#define BM_APBH_CTRL1_RSVD1	0xFF000000
+#define BF_APBH_CTRL1_RSVD1(v) \
+		(((v) << 24) & BM_APBH_CTRL1_RSVD1)
+#define BM_APBH_CTRL1_CH7_CMDCMPLT_IRQ_EN	0x00800000
+#define BM_APBH_CTRL1_CH6_CMDCMPLT_IRQ_EN	0x00400000
+#define BM_APBH_CTRL1_CH5_CMDCMPLT_IRQ_EN	0x00200000
+#define BM_APBH_CTRL1_CH4_CMDCMPLT_IRQ_EN	0x00100000
+#define BM_APBH_CTRL1_CH3_CMDCMPLT_IRQ_EN	0x00080000
+#define BM_APBH_CTRL1_CH2_CMDCMPLT_IRQ_EN	0x00040000
+#define BM_APBH_CTRL1_CH1_CMDCMPLT_IRQ_EN	0x00020000
+#define BM_APBH_CTRL1_CH0_CMDCMPLT_IRQ_EN	0x00010000
+#define BP_APBH_CTRL1_RSVD0	8
+#define BM_APBH_CTRL1_RSVD0	0x0000FF00
+#define BF_APBH_CTRL1_RSVD0(v)  \
+		(((v) << 8) & BM_APBH_CTRL1_RSVD0)
+#define BM_APBH_CTRL1_CH7_CMDCMPLT_IRQ	0x00000080
+#define BM_APBH_CTRL1_CH6_CMDCMPLT_IRQ	0x00000040
+#define BM_APBH_CTRL1_CH5_CMDCMPLT_IRQ	0x00000020
+#define BM_APBH_CTRL1_CH4_CMDCMPLT_IRQ	0x00000010
+#define BM_APBH_CTRL1_CH3_CMDCMPLT_IRQ	0x00000008
+#define BM_APBH_CTRL1_CH2_CMDCMPLT_IRQ	0x00000004
+#define BM_APBH_CTRL1_CH1_CMDCMPLT_IRQ	0x00000002
+#define BM_APBH_CTRL1_CH0_CMDCMPLT_IRQ	0x00000001
+
+#define HW_APBH_CTRL2	(0x00000020)
+#define HW_APBH_CTRL2_SET	(0x00000024)
+#define HW_APBH_CTRL2_CLR	(0x00000028)
+#define HW_APBH_CTRL2_TOG	(0x0000002c)
+
+#define BP_APBH_CTRL2_RSVD1	24
+#define BM_APBH_CTRL2_RSVD1	0xFF000000
+#define BF_APBH_CTRL2_RSVD1(v) \
+		(((v) << 24) & BM_APBH_CTRL2_RSVD1)
+#define BM_APBH_CTRL2_CH7_ERROR_STATUS	0x00800000
+#define BV_APBH_CTRL2_CH7_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH7_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH6_ERROR_STATUS	0x00400000
+#define BV_APBH_CTRL2_CH6_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH6_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH5_ERROR_STATUS	0x00200000
+#define BV_APBH_CTRL2_CH5_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH5_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH4_ERROR_STATUS	0x00100000
+#define BV_APBH_CTRL2_CH4_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH4_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH3_ERROR_STATUS	0x00080000
+#define BV_APBH_CTRL2_CH3_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH3_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH2_ERROR_STATUS	0x00040000
+#define BV_APBH_CTRL2_CH2_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH2_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH1_ERROR_STATUS	0x00020000
+#define BV_APBH_CTRL2_CH1_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH1_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH0_ERROR_STATUS	0x00010000
+#define BV_APBH_CTRL2_CH0_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH0_ERROR_STATUS__BUS_ERROR   0x1
+#define BP_APBH_CTRL2_RSVD0	8
+#define BM_APBH_CTRL2_RSVD0	0x0000FF00
+#define BF_APBH_CTRL2_RSVD0(v)  \
+		(((v) << 8) & BM_APBH_CTRL2_RSVD0)
+#define BM_APBH_CTRL2_CH7_ERROR_IRQ	0x00000080
+#define BM_APBH_CTRL2_CH6_ERROR_IRQ	0x00000040
+#define BM_APBH_CTRL2_CH5_ERROR_IRQ	0x00000020
+#define BM_APBH_CTRL2_CH4_ERROR_IRQ	0x00000010
+#define BM_APBH_CTRL2_CH3_ERROR_IRQ	0x00000008
+#define BM_APBH_CTRL2_CH2_ERROR_IRQ	0x00000004
+#define BM_APBH_CTRL2_CH1_ERROR_IRQ	0x00000002
+#define BM_APBH_CTRL2_CH0_ERROR_IRQ	0x00000001
+
+#define HW_APBH_DEVSEL	(0x00000030)
+
+#define BP_APBH_DEVSEL_CH7	28
+#define BM_APBH_DEVSEL_CH7	0xF0000000
+#define BF_APBH_DEVSEL_CH7(v) \
+		(((v) << 28) & BM_APBH_DEVSEL_CH7)
+#define BP_APBH_DEVSEL_CH6	24
+#define BM_APBH_DEVSEL_CH6	0x0F000000
+#define BF_APBH_DEVSEL_CH6(v)  \
+		(((v) << 24) & BM_APBH_DEVSEL_CH6)
+#define BP_APBH_DEVSEL_CH5	20
+#define BM_APBH_DEVSEL_CH5	0x00F00000
+#define BF_APBH_DEVSEL_CH5(v)  \
+		(((v) << 20) & BM_APBH_DEVSEL_CH5)
+#define BP_APBH_DEVSEL_CH4	16
+#define BM_APBH_DEVSEL_CH4	0x000F0000
+#define BF_APBH_DEVSEL_CH4(v)  \
+		(((v) << 16) & BM_APBH_DEVSEL_CH4)
+#define BP_APBH_DEVSEL_CH3	12
+#define BM_APBH_DEVSEL_CH3	0x0000F000
+#define BF_APBH_DEVSEL_CH3(v)  \
+		(((v) << 12) & BM_APBH_DEVSEL_CH3)
+#define BP_APBH_DEVSEL_CH2	8
+#define BM_APBH_DEVSEL_CH2	0x00000F00
+#define BF_APBH_DEVSEL_CH2(v)  \
+		(((v) << 8) & BM_APBH_DEVSEL_CH2)
+#define BP_APBH_DEVSEL_CH1	4
+#define BM_APBH_DEVSEL_CH1	0x000000F0
+#define BF_APBH_DEVSEL_CH1(v)  \
+		(((v) << 4) & BM_APBH_DEVSEL_CH1)
+#define BP_APBH_DEVSEL_CH0	0
+#define BM_APBH_DEVSEL_CH0	0x0000000F
+#define BF_APBH_DEVSEL_CH0(v)  \
+		(((v) << 0) & BM_APBH_DEVSEL_CH0)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_CURCMDAR
+ *              base 0x00000040
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_CURCMDAR(n)	(0x00000040 + (n) * 0x70)
+#define BP_APBH_CHn_CURCMDAR_CMD_ADDR	0
+#define BM_APBH_CHn_CURCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBH_CHn_CURCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_NXTCMDAR
+ *              base 0x00000050
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_NXTCMDAR(n)	(0x00000050 + (n) * 0x70)
+#define BP_APBH_CHn_NXTCMDAR_CMD_ADDR	0
+#define BM_APBH_CHn_NXTCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBH_CHn_NXTCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_CMD
+ *              base 0x00000060
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_CMD(n)	(0x00000060 + (n) * 0x70)
+#define BP_APBH_CHn_CMD_XFER_COUNT	16
+#define BM_APBH_CHn_CMD_XFER_COUNT	0xFFFF0000
+#define BF_APBH_CHn_CMD_XFER_COUNT(v) \
+		(((v) << 16) & BM_APBH_CHn_CMD_XFER_COUNT)
+#define BP_APBH_CHn_CMD_CMDWORDS	12
+#define BM_APBH_CHn_CMD_CMDWORDS	0x0000F000
+#define BF_APBH_CHn_CMD_CMDWORDS(v)  \
+		(((v) << 12) & BM_APBH_CHn_CMD_CMDWORDS)
+#define BP_APBH_CHn_CMD_RSVD1	9
+#define BM_APBH_CHn_CMD_RSVD1	0x00000E00
+#define BF_APBH_CHn_CMD_RSVD1(v)  \
+		(((v) << 9) & BM_APBH_CHn_CMD_RSVD1)
+#define BM_APBH_CHn_CMD_HALTONTERMINATE	0x00000100
+#define BM_APBH_CHn_CMD_WAIT4ENDCMD	0x00000080
+#define BM_APBH_CHn_CMD_SEMAPHORE	0x00000040
+#define BM_APBH_CHn_CMD_NANDWAIT4READY	0x00000020
+#define BM_APBH_CHn_CMD_NANDLOCK	0x00000010
+#define BM_APBH_CHn_CMD_IRQONCMPLT	0x00000008
+#define BM_APBH_CHn_CMD_CHAIN	0x00000004
+#define BP_APBH_CHn_CMD_COMMAND	0
+#define BM_APBH_CHn_CMD_COMMAND	0x00000003
+#define BF_APBH_CHn_CMD_COMMAND(v)  \
+		(((v) << 0) & BM_APBH_CHn_CMD_COMMAND)
+#define BV_APBH_CHn_CMD_COMMAND__NO_DMA_XFER 0x0
+#define BV_APBH_CHn_CMD_COMMAND__DMA_WRITE   0x1
+#define BV_APBH_CHn_CMD_COMMAND__DMA_READ    0x2
+#define BV_APBH_CHn_CMD_COMMAND__DMA_SENSE   0x3
+
+/*
+ *  multi-register-define name HW_APBH_CHn_BAR
+ *              base 0x00000070
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_BAR(n)	(0x00000070 + (n) * 0x70)
+#define BP_APBH_CHn_BAR_ADDRESS	0
+#define BM_APBH_CHn_BAR_ADDRESS	0xFFFFFFFF
+#define BF_APBH_CHn_BAR_ADDRESS(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_SEMA
+ *              base 0x00000080
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_SEMA(n)	(0x00000080 + (n) * 0x70)
+#define BP_APBH_CHn_SEMA_RSVD2	24
+#define BM_APBH_CHn_SEMA_RSVD2	0xFF000000
+#define BF_APBH_CHn_SEMA_RSVD2(v) \
+		(((v) << 24) & BM_APBH_CHn_SEMA_RSVD2)
+#define BP_APBH_CHn_SEMA_PHORE	16
+#define BM_APBH_CHn_SEMA_PHORE	0x00FF0000
+#define BF_APBH_CHn_SEMA_PHORE(v)  \
+		(((v) << 16) & BM_APBH_CHn_SEMA_PHORE)
+#define BP_APBH_CHn_SEMA_RSVD1	8
+#define BM_APBH_CHn_SEMA_RSVD1	0x0000FF00
+#define BF_APBH_CHn_SEMA_RSVD1(v)  \
+		(((v) << 8) & BM_APBH_CHn_SEMA_RSVD1)
+#define BP_APBH_CHn_SEMA_INCREMENT_SEMA	0
+#define BM_APBH_CHn_SEMA_INCREMENT_SEMA	0x000000FF
+#define BF_APBH_CHn_SEMA_INCREMENT_SEMA(v)  \
+		(((v) << 0) & BM_APBH_CHn_SEMA_INCREMENT_SEMA)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_DEBUG1
+ *              base 0x00000090
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_DEBUG1(n)	(0x00000090 + (n) * 0x70)
+#define BM_APBH_CHn_DEBUG1_REQ	0x80000000
+#define BM_APBH_CHn_DEBUG1_BURST	0x40000000
+#define BM_APBH_CHn_DEBUG1_KICK	0x20000000
+#define BM_APBH_CHn_DEBUG1_END	0x10000000
+#define BM_APBH_CHn_DEBUG1_SENSE	0x08000000
+#define BM_APBH_CHn_DEBUG1_READY	0x04000000
+#define BM_APBH_CHn_DEBUG1_LOCK	0x02000000
+#define BM_APBH_CHn_DEBUG1_NEXTCMDADDRVALID	0x01000000
+#define BM_APBH_CHn_DEBUG1_RD_FIFO_EMPTY	0x00800000
+#define BM_APBH_CHn_DEBUG1_RD_FIFO_FULL	0x00400000
+#define BM_APBH_CHn_DEBUG1_WR_FIFO_EMPTY	0x00200000
+#define BM_APBH_CHn_DEBUG1_WR_FIFO_FULL	0x00100000
+#define BP_APBH_CHn_DEBUG1_RSVD1	5
+#define BM_APBH_CHn_DEBUG1_RSVD1	0x000FFFE0
+#define BF_APBH_CHn_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_APBH_CHn_DEBUG1_RSVD1)
+#define BP_APBH_CHn_DEBUG1_STATEMACHINE	0
+#define BM_APBH_CHn_DEBUG1_STATEMACHINE	0x0000001F
+#define BF_APBH_CHn_DEBUG1_STATEMACHINE(v)  \
+		(((v) << 0) & BM_APBH_CHn_DEBUG1_STATEMACHINE)
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__IDLE            0x00
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD1        0x01
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD3        0x02
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD2        0x03
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__XFER_DECODE     0x04
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_WAIT        0x05
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD4        0x06
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__PIO_REQ         0x07
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_FLUSH      0x08
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_WAIT       0x09
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WRITE           0x0C
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_REQ        0x0D
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__CHECK_CHAIN     0x0E
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__XFER_COMPLETE   0x0F
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__TERMINATE       0x14
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WAIT_END        0x15
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WRITE_WAIT      0x1C
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__HALT_AFTER_TERM 0x1D
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__CHECK_WAIT      0x1E
+
+/*
+ *  multi-register-define name HW_APBH_CHn_DEBUG2
+ *              base 0x000000A0
+ *              count 8
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_DEBUG2(n)	(0x000000a0 + (n) * 0x70)
+#define BP_APBH_CHn_DEBUG2_APB_BYTES	16
+#define BM_APBH_CHn_DEBUG2_APB_BYTES	0xFFFF0000
+#define BF_APBH_CHn_DEBUG2_APB_BYTES(v) \
+		(((v) << 16) & BM_APBH_CHn_DEBUG2_APB_BYTES)
+#define BP_APBH_CHn_DEBUG2_AHB_BYTES	0
+#define BM_APBH_CHn_DEBUG2_AHB_BYTES	0x0000FFFF
+#define BF_APBH_CHn_DEBUG2_AHB_BYTES(v)  \
+		(((v) << 0) & BM_APBH_CHn_DEBUG2_AHB_BYTES)
+
+#define HW_APBH_VERSION	(0x000003f0)
+
+#define BP_APBH_VERSION_MAJOR	24
+#define BM_APBH_VERSION_MAJOR	0xFF000000
+#define BF_APBH_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_APBH_VERSION_MAJOR)
+#define BP_APBH_VERSION_MINOR	16
+#define BM_APBH_VERSION_MINOR	0x00FF0000
+#define BF_APBH_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_APBH_VERSION_MINOR)
+#define BP_APBH_VERSION_STEP	0
+#define BM_APBH_VERSION_STEP	0x0000FFFF
+#define BF_APBH_VERSION_STEP(v)  \
+		(((v) << 0) & BM_APBH_VERSION_STEP)
+#endif /* __ARCH_ARM___APBH_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-audioin.h b/arch/arm/mach-mx23/include/mach/regs-audioin.h
new file mode 100644
index 0000000..1a881ce
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-audioin.h
@@ -0,0 +1,287 @@
+/*
+ * Freescale AUDIOIN Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.52
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___AUDIOIN_H
+#define __ARCH_ARM___AUDIOIN_H
+
+#define REGS_AUDIOIN_BASE  (IO_ADDRESS(AUDIOIN_PHYS_ADDR))
+
+#define HW_AUDIOIN_CTRL	(0x00000000)
+#define HW_AUDIOIN_CTRL_SET	(0x00000004)
+#define HW_AUDIOIN_CTRL_CLR	(0x00000008)
+#define HW_AUDIOIN_CTRL_TOG	(0x0000000c)
+
+#define BM_AUDIOIN_CTRL_SFTRST	0x80000000
+#define BM_AUDIOIN_CTRL_CLKGATE	0x40000000
+#define BP_AUDIOIN_CTRL_RSRVD3	21
+#define BM_AUDIOIN_CTRL_RSRVD3	0x3FE00000
+#define BF_AUDIOIN_CTRL_RSRVD3(v)  \
+		(((v) << 21) & BM_AUDIOIN_CTRL_RSRVD3)
+#define BP_AUDIOIN_CTRL_DMAWAIT_COUNT	16
+#define BM_AUDIOIN_CTRL_DMAWAIT_COUNT	0x001F0000
+#define BF_AUDIOIN_CTRL_DMAWAIT_COUNT(v)  \
+		(((v) << 16) & BM_AUDIOIN_CTRL_DMAWAIT_COUNT)
+#define BP_AUDIOIN_CTRL_RSRVD1	11
+#define BM_AUDIOIN_CTRL_RSRVD1	0x0000F800
+#define BF_AUDIOIN_CTRL_RSRVD1(v)  \
+		(((v) << 11) & BM_AUDIOIN_CTRL_RSRVD1)
+#define BM_AUDIOIN_CTRL_LR_SWAP	0x00000400
+#define BM_AUDIOIN_CTRL_EDGE_SYNC	0x00000200
+#define BM_AUDIOIN_CTRL_INVERT_1BIT	0x00000100
+#define BM_AUDIOIN_CTRL_OFFSET_ENABLE	0x00000080
+#define BM_AUDIOIN_CTRL_HPF_ENABLE	0x00000040
+#define BM_AUDIOIN_CTRL_WORD_LENGTH	0x00000020
+#define BM_AUDIOIN_CTRL_LOOPBACK	0x00000010
+#define BM_AUDIOIN_CTRL_FIFO_UNDERFLOW_IRQ	0x00000008
+#define BM_AUDIOIN_CTRL_FIFO_OVERFLOW_IRQ	0x00000004
+#define BM_AUDIOIN_CTRL_FIFO_ERROR_IRQ_EN	0x00000002
+#define BM_AUDIOIN_CTRL_RUN	0x00000001
+
+#define HW_AUDIOIN_STAT	(0x00000010)
+#define HW_AUDIOIN_STAT_SET	(0x00000014)
+#define HW_AUDIOIN_STAT_CLR	(0x00000018)
+#define HW_AUDIOIN_STAT_TOG	(0x0000001c)
+
+#define BM_AUDIOIN_STAT_ADC_PRESENT	0x80000000
+#define BP_AUDIOIN_STAT_RSRVD3	0
+#define BM_AUDIOIN_STAT_RSRVD3	0x7FFFFFFF
+#define BF_AUDIOIN_STAT_RSRVD3(v)  \
+		(((v) << 0) & BM_AUDIOIN_STAT_RSRVD3)
+
+#define HW_AUDIOIN_ADCSRR	(0x00000020)
+#define HW_AUDIOIN_ADCSRR_SET	(0x00000024)
+#define HW_AUDIOIN_ADCSRR_CLR	(0x00000028)
+#define HW_AUDIOIN_ADCSRR_TOG	(0x0000002c)
+
+#define BM_AUDIOIN_ADCSRR_OSR	0x80000000
+#define BV_AUDIOIN_ADCSRR_OSR__OSR6  0x0
+#define BV_AUDIOIN_ADCSRR_OSR__OSR12 0x1
+#define BP_AUDIOIN_ADCSRR_BASEMULT	28
+#define BM_AUDIOIN_ADCSRR_BASEMULT	0x70000000
+#define BF_AUDIOIN_ADCSRR_BASEMULT(v)  \
+		(((v) << 28) & BM_AUDIOIN_ADCSRR_BASEMULT)
+#define BV_AUDIOIN_ADCSRR_BASEMULT__SINGLE_RATE 0x1
+#define BV_AUDIOIN_ADCSRR_BASEMULT__DOUBLE_RATE 0x2
+#define BV_AUDIOIN_ADCSRR_BASEMULT__QUAD_RATE   0x4
+#define BM_AUDIOIN_ADCSRR_RSRVD2	0x08000000
+#define BP_AUDIOIN_ADCSRR_SRC_HOLD	24
+#define BM_AUDIOIN_ADCSRR_SRC_HOLD	0x07000000
+#define BF_AUDIOIN_ADCSRR_SRC_HOLD(v)  \
+		(((v) << 24) & BM_AUDIOIN_ADCSRR_SRC_HOLD)
+#define BP_AUDIOIN_ADCSRR_RSRVD1	21
+#define BM_AUDIOIN_ADCSRR_RSRVD1	0x00E00000
+#define BF_AUDIOIN_ADCSRR_RSRVD1(v)  \
+		(((v) << 21) & BM_AUDIOIN_ADCSRR_RSRVD1)
+#define BP_AUDIOIN_ADCSRR_SRC_INT	16
+#define BM_AUDIOIN_ADCSRR_SRC_INT	0x001F0000
+#define BF_AUDIOIN_ADCSRR_SRC_INT(v)  \
+		(((v) << 16) & BM_AUDIOIN_ADCSRR_SRC_INT)
+#define BP_AUDIOIN_ADCSRR_RSRVD0	13
+#define BM_AUDIOIN_ADCSRR_RSRVD0	0x0000E000
+#define BF_AUDIOIN_ADCSRR_RSRVD0(v)  \
+		(((v) << 13) & BM_AUDIOIN_ADCSRR_RSRVD0)
+#define BP_AUDIOIN_ADCSRR_SRC_FRAC	0
+#define BM_AUDIOIN_ADCSRR_SRC_FRAC	0x00001FFF
+#define BF_AUDIOIN_ADCSRR_SRC_FRAC(v)  \
+		(((v) << 0) & BM_AUDIOIN_ADCSRR_SRC_FRAC)
+
+#define HW_AUDIOIN_ADCVOLUME	(0x00000030)
+#define HW_AUDIOIN_ADCVOLUME_SET	(0x00000034)
+#define HW_AUDIOIN_ADCVOLUME_CLR	(0x00000038)
+#define HW_AUDIOIN_ADCVOLUME_TOG	(0x0000003c)
+
+#define BP_AUDIOIN_ADCVOLUME_RSRVD5	29
+#define BM_AUDIOIN_ADCVOLUME_RSRVD5	0xE0000000
+#define BF_AUDIOIN_ADCVOLUME_RSRVD5(v) \
+		(((v) << 29) & BM_AUDIOIN_ADCVOLUME_RSRVD5)
+#define BM_AUDIOIN_ADCVOLUME_VOLUME_UPDATE_LEFT	0x10000000
+#define BP_AUDIOIN_ADCVOLUME_RSRVD4	26
+#define BM_AUDIOIN_ADCVOLUME_RSRVD4	0x0C000000
+#define BF_AUDIOIN_ADCVOLUME_RSRVD4(v)  \
+		(((v) << 26) & BM_AUDIOIN_ADCVOLUME_RSRVD4)
+#define BM_AUDIOIN_ADCVOLUME_EN_ZCD	0x02000000
+#define BM_AUDIOIN_ADCVOLUME_RSRVD3	0x01000000
+#define BP_AUDIOIN_ADCVOLUME_VOLUME_LEFT	16
+#define BM_AUDIOIN_ADCVOLUME_VOLUME_LEFT	0x00FF0000
+#define BF_AUDIOIN_ADCVOLUME_VOLUME_LEFT(v)  \
+		(((v) << 16) & BM_AUDIOIN_ADCVOLUME_VOLUME_LEFT)
+#define BP_AUDIOIN_ADCVOLUME_RSRVD2	13
+#define BM_AUDIOIN_ADCVOLUME_RSRVD2	0x0000E000
+#define BF_AUDIOIN_ADCVOLUME_RSRVD2(v)  \
+		(((v) << 13) & BM_AUDIOIN_ADCVOLUME_RSRVD2)
+#define BM_AUDIOIN_ADCVOLUME_VOLUME_UPDATE_RIGHT	0x00001000
+#define BP_AUDIOIN_ADCVOLUME_RSRVD1	8
+#define BM_AUDIOIN_ADCVOLUME_RSRVD1	0x00000F00
+#define BF_AUDIOIN_ADCVOLUME_RSRVD1(v)  \
+		(((v) << 8) & BM_AUDIOIN_ADCVOLUME_RSRVD1)
+#define BP_AUDIOIN_ADCVOLUME_VOLUME_RIGHT	0
+#define BM_AUDIOIN_ADCVOLUME_VOLUME_RIGHT	0x000000FF
+#define BF_AUDIOIN_ADCVOLUME_VOLUME_RIGHT(v)  \
+		(((v) << 0) & BM_AUDIOIN_ADCVOLUME_VOLUME_RIGHT)
+
+#define HW_AUDIOIN_ADCDEBUG	(0x00000040)
+#define HW_AUDIOIN_ADCDEBUG_SET	(0x00000044)
+#define HW_AUDIOIN_ADCDEBUG_CLR	(0x00000048)
+#define HW_AUDIOIN_ADCDEBUG_TOG	(0x0000004c)
+
+#define BM_AUDIOIN_ADCDEBUG_ENABLE_ADCDMA	0x80000000
+#define BP_AUDIOIN_ADCDEBUG_RSRVD1	4
+#define BM_AUDIOIN_ADCDEBUG_RSRVD1	0x7FFFFFF0
+#define BF_AUDIOIN_ADCDEBUG_RSRVD1(v)  \
+		(((v) << 4) & BM_AUDIOIN_ADCDEBUG_RSRVD1)
+#define BM_AUDIOIN_ADCDEBUG_ADC_DMA_REQ_HAND_SHAKE_CLK_CROSS	0x00000008
+#define BM_AUDIOIN_ADCDEBUG_SET_INTERRUPT3_HAND_SHAKE	0x00000004
+#define BM_AUDIOIN_ADCDEBUG_DMA_PREQ	0x00000002
+#define BM_AUDIOIN_ADCDEBUG_FIFO_STATUS	0x00000001
+
+#define HW_AUDIOIN_ADCVOL	(0x00000050)
+#define HW_AUDIOIN_ADCVOL_SET	(0x00000054)
+#define HW_AUDIOIN_ADCVOL_CLR	(0x00000058)
+#define HW_AUDIOIN_ADCVOL_TOG	(0x0000005c)
+
+#define BP_AUDIOIN_ADCVOL_RSRVD4	29
+#define BM_AUDIOIN_ADCVOL_RSRVD4	0xE0000000
+#define BF_AUDIOIN_ADCVOL_RSRVD4(v) \
+		(((v) << 29) & BM_AUDIOIN_ADCVOL_RSRVD4)
+#define BM_AUDIOIN_ADCVOL_VOLUME_UPDATE_PENDING	0x10000000
+#define BP_AUDIOIN_ADCVOL_RSRVD3	26
+#define BM_AUDIOIN_ADCVOL_RSRVD3	0x0C000000
+#define BF_AUDIOIN_ADCVOL_RSRVD3(v)  \
+		(((v) << 26) & BM_AUDIOIN_ADCVOL_RSRVD3)
+#define BM_AUDIOIN_ADCVOL_EN_ADC_ZCD	0x02000000
+#define BM_AUDIOIN_ADCVOL_MUTE	0x01000000
+#define BP_AUDIOIN_ADCVOL_RSRVD2	14
+#define BM_AUDIOIN_ADCVOL_RSRVD2	0x00FFC000
+#define BF_AUDIOIN_ADCVOL_RSRVD2(v)  \
+		(((v) << 14) & BM_AUDIOIN_ADCVOL_RSRVD2)
+#define BP_AUDIOIN_ADCVOL_SELECT_LEFT	12
+#define BM_AUDIOIN_ADCVOL_SELECT_LEFT	0x00003000
+#define BF_AUDIOIN_ADCVOL_SELECT_LEFT(v)  \
+		(((v) << 12) & BM_AUDIOIN_ADCVOL_SELECT_LEFT)
+#define BP_AUDIOIN_ADCVOL_GAIN_LEFT	8
+#define BM_AUDIOIN_ADCVOL_GAIN_LEFT	0x00000F00
+#define BF_AUDIOIN_ADCVOL_GAIN_LEFT(v)  \
+		(((v) << 8) & BM_AUDIOIN_ADCVOL_GAIN_LEFT)
+#define BP_AUDIOIN_ADCVOL_RSRVD1	6
+#define BM_AUDIOIN_ADCVOL_RSRVD1	0x000000C0
+#define BF_AUDIOIN_ADCVOL_RSRVD1(v)  \
+		(((v) << 6) & BM_AUDIOIN_ADCVOL_RSRVD1)
+#define BP_AUDIOIN_ADCVOL_SELECT_RIGHT	4
+#define BM_AUDIOIN_ADCVOL_SELECT_RIGHT	0x00000030
+#define BF_AUDIOIN_ADCVOL_SELECT_RIGHT(v)  \
+		(((v) << 4) & BM_AUDIOIN_ADCVOL_SELECT_RIGHT)
+#define BP_AUDIOIN_ADCVOL_GAIN_RIGHT	0
+#define BM_AUDIOIN_ADCVOL_GAIN_RIGHT	0x0000000F
+#define BF_AUDIOIN_ADCVOL_GAIN_RIGHT(v)  \
+		(((v) << 0) & BM_AUDIOIN_ADCVOL_GAIN_RIGHT)
+
+#define HW_AUDIOIN_MICLINE	(0x00000060)
+#define HW_AUDIOIN_MICLINE_SET	(0x00000064)
+#define HW_AUDIOIN_MICLINE_CLR	(0x00000068)
+#define HW_AUDIOIN_MICLINE_TOG	(0x0000006c)
+
+#define BP_AUDIOIN_MICLINE_RSRVD6	30
+#define BM_AUDIOIN_MICLINE_RSRVD6	0xC0000000
+#define BF_AUDIOIN_MICLINE_RSRVD6(v) \
+		(((v) << 30) & BM_AUDIOIN_MICLINE_RSRVD6)
+#define BM_AUDIOIN_MICLINE_DIVIDE_LINE1	0x20000000
+#define BM_AUDIOIN_MICLINE_DIVIDE_LINE2	0x10000000
+#define BP_AUDIOIN_MICLINE_RSRVD5	25
+#define BM_AUDIOIN_MICLINE_RSRVD5	0x0E000000
+#define BF_AUDIOIN_MICLINE_RSRVD5(v)  \
+		(((v) << 25) & BM_AUDIOIN_MICLINE_RSRVD5)
+#define BM_AUDIOIN_MICLINE_MIC_SELECT	0x01000000
+#define BP_AUDIOIN_MICLINE_RSRVD4	22
+#define BM_AUDIOIN_MICLINE_RSRVD4	0x00C00000
+#define BF_AUDIOIN_MICLINE_RSRVD4(v)  \
+		(((v) << 22) & BM_AUDIOIN_MICLINE_RSRVD4)
+#define BP_AUDIOIN_MICLINE_MIC_RESISTOR	20
+#define BM_AUDIOIN_MICLINE_MIC_RESISTOR	0x00300000
+#define BF_AUDIOIN_MICLINE_MIC_RESISTOR(v)  \
+		(((v) << 20) & BM_AUDIOIN_MICLINE_MIC_RESISTOR)
+#define BM_AUDIOIN_MICLINE_RSRVD3	0x00080000
+#define BP_AUDIOIN_MICLINE_MIC_BIAS	16
+#define BM_AUDIOIN_MICLINE_MIC_BIAS	0x00070000
+#define BF_AUDIOIN_MICLINE_MIC_BIAS(v)  \
+		(((v) << 16) & BM_AUDIOIN_MICLINE_MIC_BIAS)
+#define BP_AUDIOIN_MICLINE_RSRVD2	6
+#define BM_AUDIOIN_MICLINE_RSRVD2	0x0000FFC0
+#define BF_AUDIOIN_MICLINE_RSRVD2(v)  \
+		(((v) << 6) & BM_AUDIOIN_MICLINE_RSRVD2)
+#define BP_AUDIOIN_MICLINE_MIC_CHOPCLK	4
+#define BM_AUDIOIN_MICLINE_MIC_CHOPCLK	0x00000030
+#define BF_AUDIOIN_MICLINE_MIC_CHOPCLK(v)  \
+		(((v) << 4) & BM_AUDIOIN_MICLINE_MIC_CHOPCLK)
+#define BP_AUDIOIN_MICLINE_RSRVD1	2
+#define BM_AUDIOIN_MICLINE_RSRVD1	0x0000000C
+#define BF_AUDIOIN_MICLINE_RSRVD1(v)  \
+		(((v) << 2) & BM_AUDIOIN_MICLINE_RSRVD1)
+#define BP_AUDIOIN_MICLINE_MIC_GAIN	0
+#define BM_AUDIOIN_MICLINE_MIC_GAIN	0x00000003
+#define BF_AUDIOIN_MICLINE_MIC_GAIN(v)  \
+		(((v) << 0) & BM_AUDIOIN_MICLINE_MIC_GAIN)
+
+#define HW_AUDIOIN_ANACLKCTRL	(0x00000070)
+#define HW_AUDIOIN_ANACLKCTRL_SET	(0x00000074)
+#define HW_AUDIOIN_ANACLKCTRL_CLR	(0x00000078)
+#define HW_AUDIOIN_ANACLKCTRL_TOG	(0x0000007c)
+
+#define BM_AUDIOIN_ANACLKCTRL_CLKGATE	0x80000000
+#define BP_AUDIOIN_ANACLKCTRL_RSRVD4	11
+#define BM_AUDIOIN_ANACLKCTRL_RSRVD4	0x7FFFF800
+#define BF_AUDIOIN_ANACLKCTRL_RSRVD4(v)  \
+		(((v) << 11) & BM_AUDIOIN_ANACLKCTRL_RSRVD4)
+#define BM_AUDIOIN_ANACLKCTRL_DITHER_OFF	0x00000400
+#define BM_AUDIOIN_ANACLKCTRL_SLOW_DITHER	0x00000200
+#define BM_AUDIOIN_ANACLKCTRL_INVERT_ADCCLK	0x00000100
+#define BP_AUDIOIN_ANACLKCTRL_RSRVD3	6
+#define BM_AUDIOIN_ANACLKCTRL_RSRVD3	0x000000C0
+#define BF_AUDIOIN_ANACLKCTRL_RSRVD3(v)  \
+		(((v) << 6) & BM_AUDIOIN_ANACLKCTRL_RSRVD3)
+#define BP_AUDIOIN_ANACLKCTRL_ADCCLK_SHIFT	4
+#define BM_AUDIOIN_ANACLKCTRL_ADCCLK_SHIFT	0x00000030
+#define BF_AUDIOIN_ANACLKCTRL_ADCCLK_SHIFT(v)  \
+		(((v) << 4) & BM_AUDIOIN_ANACLKCTRL_ADCCLK_SHIFT)
+#define BM_AUDIOIN_ANACLKCTRL_RSRVD2	0x00000008
+#define BP_AUDIOIN_ANACLKCTRL_ADCDIV	0
+#define BM_AUDIOIN_ANACLKCTRL_ADCDIV	0x00000007
+#define BF_AUDIOIN_ANACLKCTRL_ADCDIV(v)  \
+		(((v) << 0) & BM_AUDIOIN_ANACLKCTRL_ADCDIV)
+
+#define HW_AUDIOIN_DATA	(0x00000080)
+#define HW_AUDIOIN_DATA_SET	(0x00000084)
+#define HW_AUDIOIN_DATA_CLR	(0x00000088)
+#define HW_AUDIOIN_DATA_TOG	(0x0000008c)
+
+#define BP_AUDIOIN_DATA_HIGH	16
+#define BM_AUDIOIN_DATA_HIGH	0xFFFF0000
+#define BF_AUDIOIN_DATA_HIGH(v) \
+		(((v) << 16) & BM_AUDIOIN_DATA_HIGH)
+#define BP_AUDIOIN_DATA_LOW	0
+#define BM_AUDIOIN_DATA_LOW	0x0000FFFF
+#define BF_AUDIOIN_DATA_LOW(v)  \
+		(((v) << 0) & BM_AUDIOIN_DATA_LOW)
+#endif /* __ARCH_ARM___AUDIOIN_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-audioout.h b/arch/arm/mach-mx23/include/mach/regs-audioout.h
new file mode 100644
index 0000000..d751858
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-audioout.h
@@ -0,0 +1,518 @@
+/*
+ * Freescale AUDIOOUT Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.65
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___AUDIOOUT_H
+#define __ARCH_ARM___AUDIOOUT_H
+
+#define REGS_AUDIOOUT_BASE  (IO_ADDRESS(AUDIOOUT_PHYS_ADDR))
+
+#define HW_AUDIOOUT_CTRL	(0x00000000)
+#define HW_AUDIOOUT_CTRL_SET	(0x00000004)
+#define HW_AUDIOOUT_CTRL_CLR	(0x00000008)
+#define HW_AUDIOOUT_CTRL_TOG	(0x0000000c)
+
+#define BM_AUDIOOUT_CTRL_SFTRST	0x80000000
+#define BM_AUDIOOUT_CTRL_CLKGATE	0x40000000
+#define BP_AUDIOOUT_CTRL_RSRVD4	21
+#define BM_AUDIOOUT_CTRL_RSRVD4	0x3FE00000
+#define BF_AUDIOOUT_CTRL_RSRVD4(v)  \
+		(((v) << 21) & BM_AUDIOOUT_CTRL_RSRVD4)
+#define BP_AUDIOOUT_CTRL_DMAWAIT_COUNT	16
+#define BM_AUDIOOUT_CTRL_DMAWAIT_COUNT	0x001F0000
+#define BF_AUDIOOUT_CTRL_DMAWAIT_COUNT(v)  \
+		(((v) << 16) & BM_AUDIOOUT_CTRL_DMAWAIT_COUNT)
+#define BM_AUDIOOUT_CTRL_RSRVD3	0x00008000
+#define BM_AUDIOOUT_CTRL_LR_SWAP	0x00004000
+#define BM_AUDIOOUT_CTRL_EDGE_SYNC	0x00002000
+#define BM_AUDIOOUT_CTRL_INVERT_1BIT	0x00001000
+#define BP_AUDIOOUT_CTRL_RSRVD2	10
+#define BM_AUDIOOUT_CTRL_RSRVD2	0x00000C00
+#define BF_AUDIOOUT_CTRL_RSRVD2(v)  \
+		(((v) << 10) & BM_AUDIOOUT_CTRL_RSRVD2)
+#define BP_AUDIOOUT_CTRL_SS3D_EFFECT	8
+#define BM_AUDIOOUT_CTRL_SS3D_EFFECT	0x00000300
+#define BF_AUDIOOUT_CTRL_SS3D_EFFECT(v)  \
+		(((v) << 8) & BM_AUDIOOUT_CTRL_SS3D_EFFECT)
+#define BM_AUDIOOUT_CTRL_RSRVD1	0x00000080
+#define BM_AUDIOOUT_CTRL_WORD_LENGTH	0x00000040
+#define BM_AUDIOOUT_CTRL_DAC_ZERO_ENABLE	0x00000020
+#define BM_AUDIOOUT_CTRL_LOOPBACK	0x00000010
+#define BM_AUDIOOUT_CTRL_FIFO_UNDERFLOW_IRQ	0x00000008
+#define BM_AUDIOOUT_CTRL_FIFO_OVERFLOW_IRQ	0x00000004
+#define BM_AUDIOOUT_CTRL_FIFO_ERROR_IRQ_EN	0x00000002
+#define BM_AUDIOOUT_CTRL_RUN	0x00000001
+
+#define HW_AUDIOOUT_STAT	(0x00000010)
+#define HW_AUDIOOUT_STAT_SET	(0x00000014)
+#define HW_AUDIOOUT_STAT_CLR	(0x00000018)
+#define HW_AUDIOOUT_STAT_TOG	(0x0000001c)
+
+#define BM_AUDIOOUT_STAT_DAC_PRESENT	0x80000000
+#define BP_AUDIOOUT_STAT_RSRVD1	0
+#define BM_AUDIOOUT_STAT_RSRVD1	0x7FFFFFFF
+#define BF_AUDIOOUT_STAT_RSRVD1(v)  \
+		(((v) << 0) & BM_AUDIOOUT_STAT_RSRVD1)
+
+#define HW_AUDIOOUT_DACSRR	(0x00000020)
+#define HW_AUDIOOUT_DACSRR_SET	(0x00000024)
+#define HW_AUDIOOUT_DACSRR_CLR	(0x00000028)
+#define HW_AUDIOOUT_DACSRR_TOG	(0x0000002c)
+
+#define BM_AUDIOOUT_DACSRR_OSR	0x80000000
+#define BV_AUDIOOUT_DACSRR_OSR__OSR6  0x0
+#define BV_AUDIOOUT_DACSRR_OSR__OSR12 0x1
+#define BP_AUDIOOUT_DACSRR_BASEMULT	28
+#define BM_AUDIOOUT_DACSRR_BASEMULT	0x70000000
+#define BF_AUDIOOUT_DACSRR_BASEMULT(v)  \
+		(((v) << 28) & BM_AUDIOOUT_DACSRR_BASEMULT)
+#define BV_AUDIOOUT_DACSRR_BASEMULT__SINGLE_RATE 0x1
+#define BV_AUDIOOUT_DACSRR_BASEMULT__DOUBLE_RATE 0x2
+#define BV_AUDIOOUT_DACSRR_BASEMULT__QUAD_RATE   0x4
+#define BM_AUDIOOUT_DACSRR_RSRVD2	0x08000000
+#define BP_AUDIOOUT_DACSRR_SRC_HOLD	24
+#define BM_AUDIOOUT_DACSRR_SRC_HOLD	0x07000000
+#define BF_AUDIOOUT_DACSRR_SRC_HOLD(v)  \
+		(((v) << 24) & BM_AUDIOOUT_DACSRR_SRC_HOLD)
+#define BP_AUDIOOUT_DACSRR_RSRVD1	21
+#define BM_AUDIOOUT_DACSRR_RSRVD1	0x00E00000
+#define BF_AUDIOOUT_DACSRR_RSRVD1(v)  \
+		(((v) << 21) & BM_AUDIOOUT_DACSRR_RSRVD1)
+#define BP_AUDIOOUT_DACSRR_SRC_INT	16
+#define BM_AUDIOOUT_DACSRR_SRC_INT	0x001F0000
+#define BF_AUDIOOUT_DACSRR_SRC_INT(v)  \
+		(((v) << 16) & BM_AUDIOOUT_DACSRR_SRC_INT)
+#define BP_AUDIOOUT_DACSRR_RSRVD0	13
+#define BM_AUDIOOUT_DACSRR_RSRVD0	0x0000E000
+#define BF_AUDIOOUT_DACSRR_RSRVD0(v)  \
+		(((v) << 13) & BM_AUDIOOUT_DACSRR_RSRVD0)
+#define BP_AUDIOOUT_DACSRR_SRC_FRAC	0
+#define BM_AUDIOOUT_DACSRR_SRC_FRAC	0x00001FFF
+#define BF_AUDIOOUT_DACSRR_SRC_FRAC(v)  \
+		(((v) << 0) & BM_AUDIOOUT_DACSRR_SRC_FRAC)
+
+#define HW_AUDIOOUT_DACVOLUME	(0x00000030)
+#define HW_AUDIOOUT_DACVOLUME_SET	(0x00000034)
+#define HW_AUDIOOUT_DACVOLUME_CLR	(0x00000038)
+#define HW_AUDIOOUT_DACVOLUME_TOG	(0x0000003c)
+
+#define BP_AUDIOOUT_DACVOLUME_RSRVD4	29
+#define BM_AUDIOOUT_DACVOLUME_RSRVD4	0xE0000000
+#define BF_AUDIOOUT_DACVOLUME_RSRVD4(v) \
+		(((v) << 29) & BM_AUDIOOUT_DACVOLUME_RSRVD4)
+#define BM_AUDIOOUT_DACVOLUME_VOLUME_UPDATE_LEFT	0x10000000
+#define BP_AUDIOOUT_DACVOLUME_RSRVD3	26
+#define BM_AUDIOOUT_DACVOLUME_RSRVD3	0x0C000000
+#define BF_AUDIOOUT_DACVOLUME_RSRVD3(v)  \
+		(((v) << 26) & BM_AUDIOOUT_DACVOLUME_RSRVD3)
+#define BM_AUDIOOUT_DACVOLUME_EN_ZCD	0x02000000
+#define BM_AUDIOOUT_DACVOLUME_MUTE_LEFT	0x01000000
+#define BP_AUDIOOUT_DACVOLUME_VOLUME_LEFT	16
+#define BM_AUDIOOUT_DACVOLUME_VOLUME_LEFT	0x00FF0000
+#define BF_AUDIOOUT_DACVOLUME_VOLUME_LEFT(v)  \
+		(((v) << 16) & BM_AUDIOOUT_DACVOLUME_VOLUME_LEFT)
+#define BP_AUDIOOUT_DACVOLUME_RSRVD2	13
+#define BM_AUDIOOUT_DACVOLUME_RSRVD2	0x0000E000
+#define BF_AUDIOOUT_DACVOLUME_RSRVD2(v)  \
+		(((v) << 13) & BM_AUDIOOUT_DACVOLUME_RSRVD2)
+#define BM_AUDIOOUT_DACVOLUME_VOLUME_UPDATE_RIGHT	0x00001000
+#define BP_AUDIOOUT_DACVOLUME_RSRVD1	9
+#define BM_AUDIOOUT_DACVOLUME_RSRVD1	0x00000E00
+#define BF_AUDIOOUT_DACVOLUME_RSRVD1(v)  \
+		(((v) << 9) & BM_AUDIOOUT_DACVOLUME_RSRVD1)
+#define BM_AUDIOOUT_DACVOLUME_MUTE_RIGHT	0x00000100
+#define BP_AUDIOOUT_DACVOLUME_VOLUME_RIGHT	0
+#define BM_AUDIOOUT_DACVOLUME_VOLUME_RIGHT	0x000000FF
+#define BF_AUDIOOUT_DACVOLUME_VOLUME_RIGHT(v)  \
+		(((v) << 0) & BM_AUDIOOUT_DACVOLUME_VOLUME_RIGHT)
+
+#define HW_AUDIOOUT_DACDEBUG	(0x00000040)
+#define HW_AUDIOOUT_DACDEBUG_SET	(0x00000044)
+#define HW_AUDIOOUT_DACDEBUG_CLR	(0x00000048)
+#define HW_AUDIOOUT_DACDEBUG_TOG	(0x0000004c)
+
+#define BM_AUDIOOUT_DACDEBUG_ENABLE_DACDMA	0x80000000
+#define BP_AUDIOOUT_DACDEBUG_RSRVD2	12
+#define BM_AUDIOOUT_DACDEBUG_RSRVD2	0x7FFFF000
+#define BF_AUDIOOUT_DACDEBUG_RSRVD2(v)  \
+		(((v) << 12) & BM_AUDIOOUT_DACDEBUG_RSRVD2)
+#define BP_AUDIOOUT_DACDEBUG_RAM_SS	8
+#define BM_AUDIOOUT_DACDEBUG_RAM_SS	0x00000F00
+#define BF_AUDIOOUT_DACDEBUG_RAM_SS(v)  \
+		(((v) << 8) & BM_AUDIOOUT_DACDEBUG_RAM_SS)
+#define BP_AUDIOOUT_DACDEBUG_RSRVD1	6
+#define BM_AUDIOOUT_DACDEBUG_RSRVD1	0x000000C0
+#define BF_AUDIOOUT_DACDEBUG_RSRVD1(v)  \
+		(((v) << 6) & BM_AUDIOOUT_DACDEBUG_RSRVD1)
+#define BM_AUDIOOUT_DACDEBUG_SET_INTERRUPT1_CLK_CROSS	0x00000020
+#define BM_AUDIOOUT_DACDEBUG_SET_INTERRUPT0_CLK_CROSS	0x00000010
+#define BM_AUDIOOUT_DACDEBUG_SET_INTERRUPT1_HAND_SHAKE	0x00000008
+#define BM_AUDIOOUT_DACDEBUG_SET_INTERRUPT0_HAND_SHAKE	0x00000004
+#define BM_AUDIOOUT_DACDEBUG_DMA_PREQ	0x00000002
+#define BM_AUDIOOUT_DACDEBUG_FIFO_STATUS	0x00000001
+
+#define HW_AUDIOOUT_HPVOL	(0x00000050)
+#define HW_AUDIOOUT_HPVOL_SET	(0x00000054)
+#define HW_AUDIOOUT_HPVOL_CLR	(0x00000058)
+#define HW_AUDIOOUT_HPVOL_TOG	(0x0000005c)
+
+#define BP_AUDIOOUT_HPVOL_RSRVD5	29
+#define BM_AUDIOOUT_HPVOL_RSRVD5	0xE0000000
+#define BF_AUDIOOUT_HPVOL_RSRVD5(v) \
+		(((v) << 29) & BM_AUDIOOUT_HPVOL_RSRVD5)
+#define BM_AUDIOOUT_HPVOL_VOLUME_UPDATE_PENDING	0x10000000
+#define BP_AUDIOOUT_HPVOL_RSRVD4	26
+#define BM_AUDIOOUT_HPVOL_RSRVD4	0x0C000000
+#define BF_AUDIOOUT_HPVOL_RSRVD4(v)  \
+		(((v) << 26) & BM_AUDIOOUT_HPVOL_RSRVD4)
+#define BM_AUDIOOUT_HPVOL_EN_MSTR_ZCD	0x02000000
+#define BM_AUDIOOUT_HPVOL_MUTE	0x01000000
+#define BP_AUDIOOUT_HPVOL_RSRVD3	17
+#define BM_AUDIOOUT_HPVOL_RSRVD3	0x00FE0000
+#define BF_AUDIOOUT_HPVOL_RSRVD3(v)  \
+		(((v) << 17) & BM_AUDIOOUT_HPVOL_RSRVD3)
+#define BM_AUDIOOUT_HPVOL_SELECT	0x00010000
+#define BM_AUDIOOUT_HPVOL_RSRVD2	0x00008000
+#define BP_AUDIOOUT_HPVOL_VOL_LEFT	8
+#define BM_AUDIOOUT_HPVOL_VOL_LEFT	0x00007F00
+#define BF_AUDIOOUT_HPVOL_VOL_LEFT(v)  \
+		(((v) << 8) & BM_AUDIOOUT_HPVOL_VOL_LEFT)
+#define BM_AUDIOOUT_HPVOL_RSRVD1	0x00000080
+#define BP_AUDIOOUT_HPVOL_VOL_RIGHT	0
+#define BM_AUDIOOUT_HPVOL_VOL_RIGHT	0x0000007F
+#define BF_AUDIOOUT_HPVOL_VOL_RIGHT(v)  \
+		(((v) << 0) & BM_AUDIOOUT_HPVOL_VOL_RIGHT)
+
+#define HW_AUDIOOUT_RESERVED	(0x00000060)
+#define HW_AUDIOOUT_RESERVED_SET	(0x00000064)
+#define HW_AUDIOOUT_RESERVED_CLR	(0x00000068)
+#define HW_AUDIOOUT_RESERVED_TOG	(0x0000006c)
+
+#define BP_AUDIOOUT_RESERVED_RSRVD1	0
+#define BM_AUDIOOUT_RESERVED_RSRVD1	0xFFFFFFFF
+#define BF_AUDIOOUT_RESERVED_RSRVD1(v)	(v)
+
+#define HW_AUDIOOUT_PWRDN	(0x00000070)
+#define HW_AUDIOOUT_PWRDN_SET	(0x00000074)
+#define HW_AUDIOOUT_PWRDN_CLR	(0x00000078)
+#define HW_AUDIOOUT_PWRDN_TOG	(0x0000007c)
+
+#define BP_AUDIOOUT_PWRDN_RSRVD7	25
+#define BM_AUDIOOUT_PWRDN_RSRVD7	0xFE000000
+#define BF_AUDIOOUT_PWRDN_RSRVD7(v) \
+		(((v) << 25) & BM_AUDIOOUT_PWRDN_RSRVD7)
+#define BM_AUDIOOUT_PWRDN_SPEAKER	0x01000000
+#define BP_AUDIOOUT_PWRDN_RSRVD6	21
+#define BM_AUDIOOUT_PWRDN_RSRVD6	0x00E00000
+#define BF_AUDIOOUT_PWRDN_RSRVD6(v)  \
+		(((v) << 21) & BM_AUDIOOUT_PWRDN_RSRVD6)
+#define BM_AUDIOOUT_PWRDN_SELFBIAS	0x00100000
+#define BP_AUDIOOUT_PWRDN_RSRVD5	17
+#define BM_AUDIOOUT_PWRDN_RSRVD5	0x000E0000
+#define BF_AUDIOOUT_PWRDN_RSRVD5(v)  \
+		(((v) << 17) & BM_AUDIOOUT_PWRDN_RSRVD5)
+#define BM_AUDIOOUT_PWRDN_RIGHT_ADC	0x00010000
+#define BP_AUDIOOUT_PWRDN_RSRVD4	13
+#define BM_AUDIOOUT_PWRDN_RSRVD4	0x0000E000
+#define BF_AUDIOOUT_PWRDN_RSRVD4(v)  \
+		(((v) << 13) & BM_AUDIOOUT_PWRDN_RSRVD4)
+#define BM_AUDIOOUT_PWRDN_DAC	0x00001000
+#define BP_AUDIOOUT_PWRDN_RSRVD3	9
+#define BM_AUDIOOUT_PWRDN_RSRVD3	0x00000E00
+#define BF_AUDIOOUT_PWRDN_RSRVD3(v)  \
+		(((v) << 9) & BM_AUDIOOUT_PWRDN_RSRVD3)
+#define BM_AUDIOOUT_PWRDN_ADC	0x00000100
+#define BP_AUDIOOUT_PWRDN_RSRVD2	5
+#define BM_AUDIOOUT_PWRDN_RSRVD2	0x000000E0
+#define BF_AUDIOOUT_PWRDN_RSRVD2(v)  \
+		(((v) << 5) & BM_AUDIOOUT_PWRDN_RSRVD2)
+#define BM_AUDIOOUT_PWRDN_CAPLESS	0x00000010
+#define BP_AUDIOOUT_PWRDN_RSRVD1	1
+#define BM_AUDIOOUT_PWRDN_RSRVD1	0x0000000E
+#define BF_AUDIOOUT_PWRDN_RSRVD1(v)  \
+		(((v) << 1) & BM_AUDIOOUT_PWRDN_RSRVD1)
+#define BM_AUDIOOUT_PWRDN_HEADPHONE	0x00000001
+
+#define HW_AUDIOOUT_REFCTRL	(0x00000080)
+#define HW_AUDIOOUT_REFCTRL_SET	(0x00000084)
+#define HW_AUDIOOUT_REFCTRL_CLR	(0x00000088)
+#define HW_AUDIOOUT_REFCTRL_TOG	(0x0000008c)
+
+#define BP_AUDIOOUT_REFCTRL_RSRVD4	27
+#define BM_AUDIOOUT_REFCTRL_RSRVD4	0xF8000000
+#define BF_AUDIOOUT_REFCTRL_RSRVD4(v) \
+		(((v) << 27) & BM_AUDIOOUT_REFCTRL_RSRVD4)
+#define BM_AUDIOOUT_REFCTRL_FASTSETTLING	0x04000000
+#define BM_AUDIOOUT_REFCTRL_RAISE_REF	0x02000000
+#define BM_AUDIOOUT_REFCTRL_XTAL_BGR_BIAS	0x01000000
+#define BM_AUDIOOUT_REFCTRL_RSRVD3	0x00800000
+#define BP_AUDIOOUT_REFCTRL_VBG_ADJ	20
+#define BM_AUDIOOUT_REFCTRL_VBG_ADJ	0x00700000
+#define BF_AUDIOOUT_REFCTRL_VBG_ADJ(v)  \
+		(((v) << 20) & BM_AUDIOOUT_REFCTRL_VBG_ADJ)
+#define BM_AUDIOOUT_REFCTRL_LOW_PWR	0x00080000
+#define BM_AUDIOOUT_REFCTRL_LW_REF	0x00040000
+#define BP_AUDIOOUT_REFCTRL_BIAS_CTRL	16
+#define BM_AUDIOOUT_REFCTRL_BIAS_CTRL	0x00030000
+#define BF_AUDIOOUT_REFCTRL_BIAS_CTRL(v)  \
+		(((v) << 16) & BM_AUDIOOUT_REFCTRL_BIAS_CTRL)
+#define BM_AUDIOOUT_REFCTRL_RSRVD2	0x00008000
+#define BM_AUDIOOUT_REFCTRL_VDDXTAL_TO_VDDD	0x00004000
+#define BM_AUDIOOUT_REFCTRL_ADJ_ADC	0x00002000
+#define BM_AUDIOOUT_REFCTRL_ADJ_VAG	0x00001000
+#define BP_AUDIOOUT_REFCTRL_ADC_REFVAL	8
+#define BM_AUDIOOUT_REFCTRL_ADC_REFVAL	0x00000F00
+#define BF_AUDIOOUT_REFCTRL_ADC_REFVAL(v)  \
+		(((v) << 8) & BM_AUDIOOUT_REFCTRL_ADC_REFVAL)
+#define BP_AUDIOOUT_REFCTRL_VAG_VAL	4
+#define BM_AUDIOOUT_REFCTRL_VAG_VAL	0x000000F0
+#define BF_AUDIOOUT_REFCTRL_VAG_VAL(v)  \
+		(((v) << 4) & BM_AUDIOOUT_REFCTRL_VAG_VAL)
+#define BM_AUDIOOUT_REFCTRL_RSRVD1	0x00000008
+#define BP_AUDIOOUT_REFCTRL_DAC_ADJ	0
+#define BM_AUDIOOUT_REFCTRL_DAC_ADJ	0x00000007
+#define BF_AUDIOOUT_REFCTRL_DAC_ADJ(v)  \
+		(((v) << 0) & BM_AUDIOOUT_REFCTRL_DAC_ADJ)
+
+#define HW_AUDIOOUT_ANACTRL	(0x00000090)
+#define HW_AUDIOOUT_ANACTRL_SET	(0x00000094)
+#define HW_AUDIOOUT_ANACTRL_CLR	(0x00000098)
+#define HW_AUDIOOUT_ANACTRL_TOG	(0x0000009c)
+
+#define BP_AUDIOOUT_ANACTRL_RSRVD8	29
+#define BM_AUDIOOUT_ANACTRL_RSRVD8	0xE0000000
+#define BF_AUDIOOUT_ANACTRL_RSRVD8(v) \
+		(((v) << 29) & BM_AUDIOOUT_ANACTRL_RSRVD8)
+#define BM_AUDIOOUT_ANACTRL_SHORT_CM_STS	0x10000000
+#define BP_AUDIOOUT_ANACTRL_RSRVD7	25
+#define BM_AUDIOOUT_ANACTRL_RSRVD7	0x0E000000
+#define BF_AUDIOOUT_ANACTRL_RSRVD7(v)  \
+		(((v) << 25) & BM_AUDIOOUT_ANACTRL_RSRVD7)
+#define BM_AUDIOOUT_ANACTRL_SHORT_LR_STS	0x01000000
+#define BP_AUDIOOUT_ANACTRL_RSRVD6	22
+#define BM_AUDIOOUT_ANACTRL_RSRVD6	0x00C00000
+#define BF_AUDIOOUT_ANACTRL_RSRVD6(v)  \
+		(((v) << 22) & BM_AUDIOOUT_ANACTRL_RSRVD6)
+#define BP_AUDIOOUT_ANACTRL_SHORTMODE_CM	20
+#define BM_AUDIOOUT_ANACTRL_SHORTMODE_CM	0x00300000
+#define BF_AUDIOOUT_ANACTRL_SHORTMODE_CM(v)  \
+		(((v) << 20) & BM_AUDIOOUT_ANACTRL_SHORTMODE_CM)
+#define BM_AUDIOOUT_ANACTRL_RSRVD5	0x00080000
+#define BP_AUDIOOUT_ANACTRL_SHORTMODE_LR	17
+#define BM_AUDIOOUT_ANACTRL_SHORTMODE_LR	0x00060000
+#define BF_AUDIOOUT_ANACTRL_SHORTMODE_LR(v)  \
+		(((v) << 17) & BM_AUDIOOUT_ANACTRL_SHORTMODE_LR)
+#define BP_AUDIOOUT_ANACTRL_RSRVD4	15
+#define BM_AUDIOOUT_ANACTRL_RSRVD4	0x00018000
+#define BF_AUDIOOUT_ANACTRL_RSRVD4(v)  \
+		(((v) << 15) & BM_AUDIOOUT_ANACTRL_RSRVD4)
+#define BP_AUDIOOUT_ANACTRL_SHORT_LVLADJL	12
+#define BM_AUDIOOUT_ANACTRL_SHORT_LVLADJL	0x00007000
+#define BF_AUDIOOUT_ANACTRL_SHORT_LVLADJL(v)  \
+		(((v) << 12) & BM_AUDIOOUT_ANACTRL_SHORT_LVLADJL)
+#define BM_AUDIOOUT_ANACTRL_RSRVD3	0x00000800
+#define BP_AUDIOOUT_ANACTRL_SHORT_LVLADJR	8
+#define BM_AUDIOOUT_ANACTRL_SHORT_LVLADJR	0x00000700
+#define BF_AUDIOOUT_ANACTRL_SHORT_LVLADJR(v)  \
+		(((v) << 8) & BM_AUDIOOUT_ANACTRL_SHORT_LVLADJR)
+#define BP_AUDIOOUT_ANACTRL_RSRVD2	6
+#define BM_AUDIOOUT_ANACTRL_RSRVD2	0x000000C0
+#define BF_AUDIOOUT_ANACTRL_RSRVD2(v)  \
+		(((v) << 6) & BM_AUDIOOUT_ANACTRL_RSRVD2)
+#define BM_AUDIOOUT_ANACTRL_HP_HOLD_GND	0x00000020
+#define BM_AUDIOOUT_ANACTRL_HP_CLASSAB	0x00000010
+#define BP_AUDIOOUT_ANACTRL_RSRVD1	0
+#define BM_AUDIOOUT_ANACTRL_RSRVD1	0x0000000F
+#define BF_AUDIOOUT_ANACTRL_RSRVD1(v)  \
+		(((v) << 0) & BM_AUDIOOUT_ANACTRL_RSRVD1)
+
+#define HW_AUDIOOUT_TEST	(0x000000a0)
+#define HW_AUDIOOUT_TEST_SET	(0x000000a4)
+#define HW_AUDIOOUT_TEST_CLR	(0x000000a8)
+#define HW_AUDIOOUT_TEST_TOG	(0x000000ac)
+
+#define BM_AUDIOOUT_TEST_RSRVD4	0x80000000
+#define BP_AUDIOOUT_TEST_HP_ANTIPOP	28
+#define BM_AUDIOOUT_TEST_HP_ANTIPOP	0x70000000
+#define BF_AUDIOOUT_TEST_HP_ANTIPOP(v)  \
+		(((v) << 28) & BM_AUDIOOUT_TEST_HP_ANTIPOP)
+#define BM_AUDIOOUT_TEST_RSRVD3	0x08000000
+#define BM_AUDIOOUT_TEST_TM_ADCIN_TOHP	0x04000000
+#define BM_AUDIOOUT_TEST_TM_LOOP	0x02000000
+#define BM_AUDIOOUT_TEST_TM_HPCOMMON	0x01000000
+#define BP_AUDIOOUT_TEST_HP_I1_ADJ	22
+#define BM_AUDIOOUT_TEST_HP_I1_ADJ	0x00C00000
+#define BF_AUDIOOUT_TEST_HP_I1_ADJ(v)  \
+		(((v) << 22) & BM_AUDIOOUT_TEST_HP_I1_ADJ)
+#define BP_AUDIOOUT_TEST_HP_IALL_ADJ	20
+#define BM_AUDIOOUT_TEST_HP_IALL_ADJ	0x00300000
+#define BF_AUDIOOUT_TEST_HP_IALL_ADJ(v)  \
+		(((v) << 20) & BM_AUDIOOUT_TEST_HP_IALL_ADJ)
+#define BP_AUDIOOUT_TEST_RSRVD2	14
+#define BM_AUDIOOUT_TEST_RSRVD2	0x000FC000
+#define BF_AUDIOOUT_TEST_RSRVD2(v)  \
+		(((v) << 14) & BM_AUDIOOUT_TEST_RSRVD2)
+#define BM_AUDIOOUT_TEST_VAG_CLASSA	0x00002000
+#define BM_AUDIOOUT_TEST_VAG_DOUBLE_I	0x00001000
+#define BP_AUDIOOUT_TEST_RSRVD1	4
+#define BM_AUDIOOUT_TEST_RSRVD1	0x00000FF0
+#define BF_AUDIOOUT_TEST_RSRVD1(v)  \
+		(((v) << 4) & BM_AUDIOOUT_TEST_RSRVD1)
+#define BM_AUDIOOUT_TEST_ADCTODAC_LOOP	0x00000008
+#define BM_AUDIOOUT_TEST_DAC_CLASSA	0x00000004
+#define BM_AUDIOOUT_TEST_DAC_DOUBLE_I	0x00000002
+#define BM_AUDIOOUT_TEST_DAC_DIS_RTZ	0x00000001
+
+#define HW_AUDIOOUT_BISTCTRL	(0x000000b0)
+#define HW_AUDIOOUT_BISTCTRL_SET	(0x000000b4)
+#define HW_AUDIOOUT_BISTCTRL_CLR	(0x000000b8)
+#define HW_AUDIOOUT_BISTCTRL_TOG	(0x000000bc)
+
+#define BP_AUDIOOUT_BISTCTRL_RSVD0	4
+#define BM_AUDIOOUT_BISTCTRL_RSVD0	0xFFFFFFF0
+#define BF_AUDIOOUT_BISTCTRL_RSVD0(v) \
+		(((v) << 4) & BM_AUDIOOUT_BISTCTRL_RSVD0)
+#define BM_AUDIOOUT_BISTCTRL_FAIL	0x00000008
+#define BM_AUDIOOUT_BISTCTRL_PASS	0x00000004
+#define BM_AUDIOOUT_BISTCTRL_DONE	0x00000002
+#define BM_AUDIOOUT_BISTCTRL_START	0x00000001
+
+#define HW_AUDIOOUT_BISTSTAT0	(0x000000c0)
+#define HW_AUDIOOUT_BISTSTAT0_SET	(0x000000c4)
+#define HW_AUDIOOUT_BISTSTAT0_CLR	(0x000000c8)
+#define HW_AUDIOOUT_BISTSTAT0_TOG	(0x000000cc)
+
+#define BP_AUDIOOUT_BISTSTAT0_RSVD0	24
+#define BM_AUDIOOUT_BISTSTAT0_RSVD0	0xFF000000
+#define BF_AUDIOOUT_BISTSTAT0_RSVD0(v) \
+		(((v) << 24) & BM_AUDIOOUT_BISTSTAT0_RSVD0)
+#define BP_AUDIOOUT_BISTSTAT0_DATA	0
+#define BM_AUDIOOUT_BISTSTAT0_DATA	0x00FFFFFF
+#define BF_AUDIOOUT_BISTSTAT0_DATA(v)  \
+		(((v) << 0) & BM_AUDIOOUT_BISTSTAT0_DATA)
+
+#define HW_AUDIOOUT_BISTSTAT1	(0x000000d0)
+#define HW_AUDIOOUT_BISTSTAT1_SET	(0x000000d4)
+#define HW_AUDIOOUT_BISTSTAT1_CLR	(0x000000d8)
+#define HW_AUDIOOUT_BISTSTAT1_TOG	(0x000000dc)
+
+#define BP_AUDIOOUT_BISTSTAT1_RSVD1	29
+#define BM_AUDIOOUT_BISTSTAT1_RSVD1	0xE0000000
+#define BF_AUDIOOUT_BISTSTAT1_RSVD1(v) \
+		(((v) << 29) & BM_AUDIOOUT_BISTSTAT1_RSVD1)
+#define BP_AUDIOOUT_BISTSTAT1_STATE	24
+#define BM_AUDIOOUT_BISTSTAT1_STATE	0x1F000000
+#define BF_AUDIOOUT_BISTSTAT1_STATE(v)  \
+		(((v) << 24) & BM_AUDIOOUT_BISTSTAT1_STATE)
+#define BP_AUDIOOUT_BISTSTAT1_RSVD0	8
+#define BM_AUDIOOUT_BISTSTAT1_RSVD0	0x00FFFF00
+#define BF_AUDIOOUT_BISTSTAT1_RSVD0(v)  \
+		(((v) << 8) & BM_AUDIOOUT_BISTSTAT1_RSVD0)
+#define BP_AUDIOOUT_BISTSTAT1_ADDR	0
+#define BM_AUDIOOUT_BISTSTAT1_ADDR	0x000000FF
+#define BF_AUDIOOUT_BISTSTAT1_ADDR(v)  \
+		(((v) << 0) & BM_AUDIOOUT_BISTSTAT1_ADDR)
+
+#define HW_AUDIOOUT_ANACLKCTRL	(0x000000e0)
+#define HW_AUDIOOUT_ANACLKCTRL_SET	(0x000000e4)
+#define HW_AUDIOOUT_ANACLKCTRL_CLR	(0x000000e8)
+#define HW_AUDIOOUT_ANACLKCTRL_TOG	(0x000000ec)
+
+#define BM_AUDIOOUT_ANACLKCTRL_CLKGATE	0x80000000
+#define BP_AUDIOOUT_ANACLKCTRL_RSRVD3	5
+#define BM_AUDIOOUT_ANACLKCTRL_RSRVD3	0x7FFFFFE0
+#define BF_AUDIOOUT_ANACLKCTRL_RSRVD3(v)  \
+		(((v) << 5) & BM_AUDIOOUT_ANACLKCTRL_RSRVD3)
+#define BM_AUDIOOUT_ANACLKCTRL_INVERT_DACCLK	0x00000010
+#define BM_AUDIOOUT_ANACLKCTRL_RSRVD2	0x00000008
+#define BP_AUDIOOUT_ANACLKCTRL_DACDIV	0
+#define BM_AUDIOOUT_ANACLKCTRL_DACDIV	0x00000007
+#define BF_AUDIOOUT_ANACLKCTRL_DACDIV(v)  \
+		(((v) << 0) & BM_AUDIOOUT_ANACLKCTRL_DACDIV)
+
+#define HW_AUDIOOUT_DATA	(0x000000f0)
+#define HW_AUDIOOUT_DATA_SET	(0x000000f4)
+#define HW_AUDIOOUT_DATA_CLR	(0x000000f8)
+#define HW_AUDIOOUT_DATA_TOG	(0x000000fc)
+
+#define BP_AUDIOOUT_DATA_HIGH	16
+#define BM_AUDIOOUT_DATA_HIGH	0xFFFF0000
+#define BF_AUDIOOUT_DATA_HIGH(v) \
+		(((v) << 16) & BM_AUDIOOUT_DATA_HIGH)
+#define BP_AUDIOOUT_DATA_LOW	0
+#define BM_AUDIOOUT_DATA_LOW	0x0000FFFF
+#define BF_AUDIOOUT_DATA_LOW(v)  \
+		(((v) << 0) & BM_AUDIOOUT_DATA_LOW)
+
+#define HW_AUDIOOUT_SPEAKERCTRL	(0x00000100)
+#define HW_AUDIOOUT_SPEAKERCTRL_SET	(0x00000104)
+#define HW_AUDIOOUT_SPEAKERCTRL_CLR	(0x00000108)
+#define HW_AUDIOOUT_SPEAKERCTRL_TOG	(0x0000010c)
+
+#define BP_AUDIOOUT_SPEAKERCTRL_RSRVD2	25
+#define BM_AUDIOOUT_SPEAKERCTRL_RSRVD2	0xFE000000
+#define BF_AUDIOOUT_SPEAKERCTRL_RSRVD2(v) \
+		(((v) << 25) & BM_AUDIOOUT_SPEAKERCTRL_RSRVD2)
+#define BM_AUDIOOUT_SPEAKERCTRL_MUTE	0x01000000
+#define BP_AUDIOOUT_SPEAKERCTRL_I1_ADJ	22
+#define BM_AUDIOOUT_SPEAKERCTRL_I1_ADJ	0x00C00000
+#define BF_AUDIOOUT_SPEAKERCTRL_I1_ADJ(v)  \
+		(((v) << 22) & BM_AUDIOOUT_SPEAKERCTRL_I1_ADJ)
+#define BP_AUDIOOUT_SPEAKERCTRL_IALL_ADJ	20
+#define BM_AUDIOOUT_SPEAKERCTRL_IALL_ADJ	0x00300000
+#define BF_AUDIOOUT_SPEAKERCTRL_IALL_ADJ(v)  \
+		(((v) << 20) & BM_AUDIOOUT_SPEAKERCTRL_IALL_ADJ)
+#define BP_AUDIOOUT_SPEAKERCTRL_RSRVD1	16
+#define BM_AUDIOOUT_SPEAKERCTRL_RSRVD1	0x000F0000
+#define BF_AUDIOOUT_SPEAKERCTRL_RSRVD1(v)  \
+		(((v) << 16) & BM_AUDIOOUT_SPEAKERCTRL_RSRVD1)
+#define BP_AUDIOOUT_SPEAKERCTRL_POSDRIVER	14
+#define BM_AUDIOOUT_SPEAKERCTRL_POSDRIVER	0x0000C000
+#define BF_AUDIOOUT_SPEAKERCTRL_POSDRIVER(v)  \
+		(((v) << 14) & BM_AUDIOOUT_SPEAKERCTRL_POSDRIVER)
+#define BP_AUDIOOUT_SPEAKERCTRL_NEGDRIVER	12
+#define BM_AUDIOOUT_SPEAKERCTRL_NEGDRIVER	0x00003000
+#define BF_AUDIOOUT_SPEAKERCTRL_NEGDRIVER(v)  \
+		(((v) << 12) & BM_AUDIOOUT_SPEAKERCTRL_NEGDRIVER)
+#define BP_AUDIOOUT_SPEAKERCTRL_RSRVD0	0
+#define BM_AUDIOOUT_SPEAKERCTRL_RSRVD0	0x00000FFF
+#define BF_AUDIOOUT_SPEAKERCTRL_RSRVD0(v)  \
+		(((v) << 0) & BM_AUDIOOUT_SPEAKERCTRL_RSRVD0)
+
+#define HW_AUDIOOUT_VERSION	(0x00000200)
+
+#define BP_AUDIOOUT_VERSION_MAJOR	24
+#define BM_AUDIOOUT_VERSION_MAJOR	0xFF000000
+#define BF_AUDIOOUT_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_AUDIOOUT_VERSION_MAJOR)
+#define BP_AUDIOOUT_VERSION_MINOR	16
+#define BM_AUDIOOUT_VERSION_MINOR	0x00FF0000
+#define BF_AUDIOOUT_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_AUDIOOUT_VERSION_MINOR)
+#define BP_AUDIOOUT_VERSION_STEP	0
+#define BM_AUDIOOUT_VERSION_STEP	0x0000FFFF
+#define BF_AUDIOOUT_VERSION_STEP(v)  \
+		(((v) << 0) & BM_AUDIOOUT_VERSION_STEP)
+#endif /* __ARCH_ARM___AUDIOOUT_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-emi.h b/arch/arm/mach-mx23/include/mach/regs-emi.h
new file mode 100644
index 0000000..bf3adff
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-emi.h
@@ -0,0 +1,234 @@
+/*
+ * Freescale EMI Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ */
+
+#ifndef __ARCH_ARM___EMI_H
+#define __ARCH_ARM___EMI_H  1
+
+#define REGS_EMI_PHYS (0x80020000)
+#define REGS_EMI_SIZE 0x00002000
+
+#define HW_EMI_CTRL	(0x00000000)
+#define HW_EMI_CTRL_SET	(0x00000004)
+#define HW_EMI_CTRL_CLR	(0x00000008)
+#define HW_EMI_CTRL_TOG	(0x0000000c)
+
+#define BM_EMI_CTRL_SFTRST	0x80000000
+#define BM_EMI_CTRL_CLKGATE	0x40000000
+#define BM_EMI_CTRL_TRAP_SR	0x20000000
+#define BM_EMI_CTRL_TRAP_INIT	0x10000000
+#define BP_EMI_CTRL_AXI_DEPTH	26
+#define BM_EMI_CTRL_AXI_DEPTH	0x0C000000
+#define BF_EMI_CTRL_AXI_DEPTH(v)  \
+		(((v) << 26) & BM_EMI_CTRL_AXI_DEPTH)
+#define BV_EMI_CTRL_AXI_DEPTH__ONE   0x0
+#define BV_EMI_CTRL_AXI_DEPTH__TWO   0x1
+#define BV_EMI_CTRL_AXI_DEPTH__THREE 0x2
+#define BV_EMI_CTRL_AXI_DEPTH__FOUR  0x3
+#define BM_EMI_CTRL_DLL_SHIFT_RESET	0x02000000
+#define BM_EMI_CTRL_DLL_RESET	0x01000000
+#define BP_EMI_CTRL_ARB_MODE	22
+#define BM_EMI_CTRL_ARB_MODE	0x00C00000
+#define BF_EMI_CTRL_ARB_MODE(v)  \
+		(((v) << 22) & BM_EMI_CTRL_ARB_MODE)
+#define BV_EMI_CTRL_ARB_MODE__TIMESTAMP     0x0
+#define BV_EMI_CTRL_ARB_MODE__WRITE_HYBRID  0x1
+#define BV_EMI_CTRL_ARB_MODE__PORT_PRIORITY 0x2
+#define BM_EMI_CTRL_RSVD3	0x00200000
+#define BP_EMI_CTRL_PORT_PRIORITY_ORDER	16
+#define BM_EMI_CTRL_PORT_PRIORITY_ORDER	0x001F0000
+#define BF_EMI_CTRL_PORT_PRIORITY_ORDER(v)  \
+		(((v) << 16) & BM_EMI_CTRL_PORT_PRIORITY_ORDER)
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0123 0x00
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0312 0x01
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0231 0x02
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0321 0x03
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0213 0x04
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT0132 0x05
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1023 0x06
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1302 0x07
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1230 0x08
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1320 0x09
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1203 0x0A
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT1032 0x0B
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2013 0x0C
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2301 0x0D
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2130 0x0E
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2310 0x0F
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2103 0x10
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT2031 0x11
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3012 0x12
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3201 0x13
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3120 0x14
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3210 0x15
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3102 0x16
+#define BV_EMI_CTRL_PORT_PRIORITY_ORDER__PORT3021 0x17
+#define BM_EMI_CTRL_RSVD2	0x00008000
+#define BP_EMI_CTRL_PRIORITY_WRITE_ITER	12
+#define BM_EMI_CTRL_PRIORITY_WRITE_ITER	0x00007000
+#define BF_EMI_CTRL_PRIORITY_WRITE_ITER(v)  \
+		(((v) << 12) & BM_EMI_CTRL_PRIORITY_WRITE_ITER)
+#define BM_EMI_CTRL_RSVD1	0x00000800
+#define BP_EMI_CTRL_HIGH_PRIORITY_WRITE	8
+#define BM_EMI_CTRL_HIGH_PRIORITY_WRITE	0x00000700
+#define BF_EMI_CTRL_HIGH_PRIORITY_WRITE(v)  \
+		(((v) << 8) & BM_EMI_CTRL_HIGH_PRIORITY_WRITE)
+#define BM_EMI_CTRL_RSVD0	0x00000080
+#define BM_EMI_CTRL_MEM_WIDTH	0x00000040
+#define BM_EMI_CTRL_WRITE_PROTECT	0x00000020
+#define BM_EMI_CTRL_RESET_OUT	0x00000010
+#define BP_EMI_CTRL_CE_SELECT	0
+#define BM_EMI_CTRL_CE_SELECT	0x0000000F
+#define BF_EMI_CTRL_CE_SELECT(v)  \
+		(((v) << 0) & BM_EMI_CTRL_CE_SELECT)
+#define BV_EMI_CTRL_CE_SELECT__NONE 0x0
+#define BV_EMI_CTRL_CE_SELECT__CE0  0x1
+#define BV_EMI_CTRL_CE_SELECT__CE1  0x2
+#define BV_EMI_CTRL_CE_SELECT__CE2  0x4
+#define BV_EMI_CTRL_CE_SELECT__CE3  0x8
+
+#define HW_EMI_STAT	(0x00000010)
+
+#define BM_EMI_STAT_DRAM_PRESENT	0x80000000
+#define BM_EMI_STAT_NOR_PRESENT	0x40000000
+#define BM_EMI_STAT_LARGE_DRAM_ENABLED	0x20000000
+#define BP_EMI_STAT_RSVD0	2
+#define BM_EMI_STAT_RSVD0	0x1FFFFFFC
+#define BF_EMI_STAT_RSVD0(v)  \
+		(((v) << 2) & BM_EMI_STAT_RSVD0)
+#define BM_EMI_STAT_DRAM_HALTED	0x00000002
+#define BV_EMI_STAT_DRAM_HALTED__NOT_HALTED 0x0
+#define BV_EMI_STAT_DRAM_HALTED__HALTED     0x1
+#define BM_EMI_STAT_NOR_BUSY	0x00000001
+#define BV_EMI_STAT_NOR_BUSY__NOT_BUSY 0x0
+#define BV_EMI_STAT_NOR_BUSY__BUSY     0x1
+
+#define HW_EMI_TIME	(0x00000020)
+#define HW_EMI_TIME_SET	(0x00000024)
+#define HW_EMI_TIME_CLR	(0x00000028)
+#define HW_EMI_TIME_TOG	(0x0000002c)
+
+#define BP_EMI_TIME_RSVD4	28
+#define BM_EMI_TIME_RSVD4	0xF0000000
+#define BF_EMI_TIME_RSVD4(v) \
+		(((v) << 28) & BM_EMI_TIME_RSVD4)
+#define BP_EMI_TIME_THZ	24
+#define BM_EMI_TIME_THZ	0x0F000000
+#define BF_EMI_TIME_THZ(v)  \
+		(((v) << 24) & BM_EMI_TIME_THZ)
+#define BP_EMI_TIME_RSVD2	20
+#define BM_EMI_TIME_RSVD2	0x00F00000
+#define BF_EMI_TIME_RSVD2(v)  \
+		(((v) << 20) & BM_EMI_TIME_RSVD2)
+#define BP_EMI_TIME_TDH	16
+#define BM_EMI_TIME_TDH	0x000F0000
+#define BF_EMI_TIME_TDH(v)  \
+		(((v) << 16) & BM_EMI_TIME_TDH)
+#define BP_EMI_TIME_RSVD1	13
+#define BM_EMI_TIME_RSVD1	0x0000E000
+#define BF_EMI_TIME_RSVD1(v)  \
+		(((v) << 13) & BM_EMI_TIME_RSVD1)
+#define BP_EMI_TIME_TDS	8
+#define BM_EMI_TIME_TDS	0x00001F00
+#define BF_EMI_TIME_TDS(v)  \
+		(((v) << 8) & BM_EMI_TIME_TDS)
+#define BP_EMI_TIME_RSVD0	4
+#define BM_EMI_TIME_RSVD0	0x000000F0
+#define BF_EMI_TIME_RSVD0(v)  \
+		(((v) << 4) & BM_EMI_TIME_RSVD0)
+#define BP_EMI_TIME_TAS	0
+#define BM_EMI_TIME_TAS	0x0000000F
+#define BF_EMI_TIME_TAS(v)  \
+		(((v) << 0) & BM_EMI_TIME_TAS)
+
+#define HW_EMI_DDR_TEST_MODE_CSR	(0x00000030)
+#define HW_EMI_DDR_TEST_MODE_CSR_SET	(0x00000034)
+#define HW_EMI_DDR_TEST_MODE_CSR_CLR	(0x00000038)
+#define HW_EMI_DDR_TEST_MODE_CSR_TOG	(0x0000003c)
+
+#define BP_EMI_DDR_TEST_MODE_CSR_RSVD1	2
+#define BM_EMI_DDR_TEST_MODE_CSR_RSVD1	0xFFFFFFFC
+#define BF_EMI_DDR_TEST_MODE_CSR_RSVD1(v) \
+		(((v) << 2) & BM_EMI_DDR_TEST_MODE_CSR_RSVD1)
+#define BM_EMI_DDR_TEST_MODE_CSR_DONE	0x00000002
+#define BM_EMI_DDR_TEST_MODE_CSR_START	0x00000001
+
+#define HW_EMI_DEBUG	(0x00000080)
+
+#define BP_EMI_DEBUG_RSVD1	4
+#define BM_EMI_DEBUG_RSVD1	0xFFFFFFF0
+#define BF_EMI_DEBUG_RSVD1(v) \
+		(((v) << 4) & BM_EMI_DEBUG_RSVD1)
+#define BP_EMI_DEBUG_NOR_STATE	0
+#define BM_EMI_DEBUG_NOR_STATE	0x0000000F
+#define BF_EMI_DEBUG_NOR_STATE(v)  \
+		(((v) << 0) & BM_EMI_DEBUG_NOR_STATE)
+
+#define HW_EMI_DDR_TEST_MODE_STATUS0	(0x00000090)
+
+#define BP_EMI_DDR_TEST_MODE_STATUS0_RSVD1	13
+#define BM_EMI_DDR_TEST_MODE_STATUS0_RSVD1	0xFFFFE000
+#define BF_EMI_DDR_TEST_MODE_STATUS0_RSVD1(v) \
+		(((v) << 13) & BM_EMI_DDR_TEST_MODE_STATUS0_RSVD1)
+#define BP_EMI_DDR_TEST_MODE_STATUS0_ADDR0	0
+#define BM_EMI_DDR_TEST_MODE_STATUS0_ADDR0	0x00001FFF
+#define BF_EMI_DDR_TEST_MODE_STATUS0_ADDR0(v)  \
+		(((v) << 0) & BM_EMI_DDR_TEST_MODE_STATUS0_ADDR0)
+
+#define HW_EMI_DDR_TEST_MODE_STATUS1	(0x000000a0)
+
+#define BP_EMI_DDR_TEST_MODE_STATUS1_RSVD1	13
+#define BM_EMI_DDR_TEST_MODE_STATUS1_RSVD1	0xFFFFE000
+#define BF_EMI_DDR_TEST_MODE_STATUS1_RSVD1(v) \
+		(((v) << 13) & BM_EMI_DDR_TEST_MODE_STATUS1_RSVD1)
+#define BP_EMI_DDR_TEST_MODE_STATUS1_ADDR1	0
+#define BM_EMI_DDR_TEST_MODE_STATUS1_ADDR1	0x00001FFF
+#define BF_EMI_DDR_TEST_MODE_STATUS1_ADDR1(v)  \
+		(((v) << 0) & BM_EMI_DDR_TEST_MODE_STATUS1_ADDR1)
+
+#define HW_EMI_DDR_TEST_MODE_STATUS2	(0x000000b0)
+
+#define BP_EMI_DDR_TEST_MODE_STATUS2_DATA0	0
+#define BM_EMI_DDR_TEST_MODE_STATUS2_DATA0	0xFFFFFFFF
+#define BF_EMI_DDR_TEST_MODE_STATUS2_DATA0(v)	(v)
+
+#define HW_EMI_DDR_TEST_MODE_STATUS3	(0x000000c0)
+
+#define BP_EMI_DDR_TEST_MODE_STATUS3_DATA1	0
+#define BM_EMI_DDR_TEST_MODE_STATUS3_DATA1	0xFFFFFFFF
+#define BF_EMI_DDR_TEST_MODE_STATUS3_DATA1(v)	(v)
+
+#define HW_EMI_VERSION	(0x000000f0)
+
+#define BP_EMI_VERSION_MAJOR	24
+#define BM_EMI_VERSION_MAJOR	0xFF000000
+#define BF_EMI_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_EMI_VERSION_MAJOR)
+#define BP_EMI_VERSION_MINOR	16
+#define BM_EMI_VERSION_MINOR	0x00FF0000
+#define BF_EMI_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_EMI_VERSION_MINOR)
+#define BP_EMI_VERSION_STEP	0
+#define BM_EMI_VERSION_STEP	0x0000FFFF
+#define BF_EMI_VERSION_STEP(v)  \
+		(((v) << 0) & BM_EMI_VERSION_STEP)
+#endif /* __ARCH_ARM___EMI_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-i2c.h b/arch/arm/mach-mx23/include/mach/regs-i2c.h
new file mode 100644
index 0000000..a255d3f
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-i2c.h
@@ -0,0 +1,383 @@
+/*
+ * Freescale I2C Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.54
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___I2C_H
+#define __ARCH_ARM___I2C_H
+
+
+#define HW_I2C_CTRL0	(0x00000000)
+#define HW_I2C_CTRL0_SET	(0x00000004)
+#define HW_I2C_CTRL0_CLR	(0x00000008)
+#define HW_I2C_CTRL0_TOG	(0x0000000c)
+
+#define BM_I2C_CTRL0_SFTRST	0x80000000
+#define BV_I2C_CTRL0_SFTRST__RUN   0x0
+#define BV_I2C_CTRL0_SFTRST__RESET 0x1
+#define BM_I2C_CTRL0_CLKGATE	0x40000000
+#define BV_I2C_CTRL0_CLKGATE__RUN     0x0
+#define BV_I2C_CTRL0_CLKGATE__NO_CLKS 0x1
+#define BM_I2C_CTRL0_RUN	0x20000000
+#define BV_I2C_CTRL0_RUN__HALT 0x0
+#define BV_I2C_CTRL0_RUN__RUN  0x1
+#define BM_I2C_CTRL0_RSVD1	0x10000000
+#define BM_I2C_CTRL0_PRE_ACK	0x08000000
+#define BM_I2C_CTRL0_ACKNOWLEDGE	0x04000000
+#define BV_I2C_CTRL0_ACKNOWLEDGE__SNAK 0x0
+#define BV_I2C_CTRL0_ACKNOWLEDGE__ACK  0x1
+#define BM_I2C_CTRL0_SEND_NAK_ON_LAST	0x02000000
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__ACK_IT 0x0
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__NAK_IT 0x1
+#define BM_I2C_CTRL0_PIO_MODE	0x01000000
+#define BM_I2C_CTRL0_MULTI_MASTER	0x00800000
+#define BV_I2C_CTRL0_MULTI_MASTER__SINGLE   0x0
+#define BV_I2C_CTRL0_MULTI_MASTER__MULTIPLE 0x1
+#define BM_I2C_CTRL0_CLOCK_HELD	0x00400000
+#define BV_I2C_CTRL0_CLOCK_HELD__RELEASE  0x0
+#define BV_I2C_CTRL0_CLOCK_HELD__HELD_LOW 0x1
+#define BM_I2C_CTRL0_RETAIN_CLOCK	0x00200000
+#define BV_I2C_CTRL0_RETAIN_CLOCK__RELEASE  0x0
+#define BV_I2C_CTRL0_RETAIN_CLOCK__HOLD_LOW 0x1
+#define BM_I2C_CTRL0_POST_SEND_STOP	0x00100000
+#define BV_I2C_CTRL0_POST_SEND_STOP__NO_STOP   0x0
+#define BV_I2C_CTRL0_POST_SEND_STOP__SEND_STOP 0x1
+#define BM_I2C_CTRL0_PRE_SEND_START	0x00080000
+#define BV_I2C_CTRL0_PRE_SEND_START__NO_START   0x0
+#define BV_I2C_CTRL0_PRE_SEND_START__SEND_START 0x1
+#define BM_I2C_CTRL0_SLAVE_ADDRESS_ENABLE	0x00040000
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__DISABLED 0x0
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__ENABLED  0x1
+#define BM_I2C_CTRL0_MASTER_MODE	0x00020000
+#define BV_I2C_CTRL0_MASTER_MODE__SLAVE  0x0
+#define BV_I2C_CTRL0_MASTER_MODE__MASTER 0x1
+#define BM_I2C_CTRL0_DIRECTION	0x00010000
+#define BV_I2C_CTRL0_DIRECTION__RECEIVE  0x0
+#define BV_I2C_CTRL0_DIRECTION__TRANSMIT 0x1
+#define BP_I2C_CTRL0_XFER_COUNT	0
+#define BM_I2C_CTRL0_XFER_COUNT	0x0000FFFF
+#define BF_I2C_CTRL0_XFER_COUNT(v)  \
+		(((v) << 0) & BM_I2C_CTRL0_XFER_COUNT)
+
+#define HW_I2C_TIMING0	(0x00000010)
+#define HW_I2C_TIMING0_SET	(0x00000014)
+#define HW_I2C_TIMING0_CLR	(0x00000018)
+#define HW_I2C_TIMING0_TOG	(0x0000001c)
+
+#define BP_I2C_TIMING0_RSVD2	26
+#define BM_I2C_TIMING0_RSVD2	0xFC000000
+#define BF_I2C_TIMING0_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING0_RSVD2)
+#define BP_I2C_TIMING0_HIGH_COUNT	16
+#define BM_I2C_TIMING0_HIGH_COUNT	0x03FF0000
+#define BF_I2C_TIMING0_HIGH_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING0_HIGH_COUNT)
+#define BP_I2C_TIMING0_RSVD1	10
+#define BM_I2C_TIMING0_RSVD1	0x0000FC00
+#define BF_I2C_TIMING0_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING0_RSVD1)
+#define BP_I2C_TIMING0_RCV_COUNT	0
+#define BM_I2C_TIMING0_RCV_COUNT	0x000003FF
+#define BF_I2C_TIMING0_RCV_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING0_RCV_COUNT)
+
+#define HW_I2C_TIMING1	(0x00000020)
+#define HW_I2C_TIMING1_SET	(0x00000024)
+#define HW_I2C_TIMING1_CLR	(0x00000028)
+#define HW_I2C_TIMING1_TOG	(0x0000002c)
+
+#define BP_I2C_TIMING1_RSVD2	26
+#define BM_I2C_TIMING1_RSVD2	0xFC000000
+#define BF_I2C_TIMING1_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING1_RSVD2)
+#define BP_I2C_TIMING1_LOW_COUNT	16
+#define BM_I2C_TIMING1_LOW_COUNT	0x03FF0000
+#define BF_I2C_TIMING1_LOW_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING1_LOW_COUNT)
+#define BP_I2C_TIMING1_RSVD1	10
+#define BM_I2C_TIMING1_RSVD1	0x0000FC00
+#define BF_I2C_TIMING1_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING1_RSVD1)
+#define BP_I2C_TIMING1_XMIT_COUNT	0
+#define BM_I2C_TIMING1_XMIT_COUNT	0x000003FF
+#define BF_I2C_TIMING1_XMIT_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING1_XMIT_COUNT)
+
+#define HW_I2C_TIMING2	(0x00000030)
+#define HW_I2C_TIMING2_SET	(0x00000034)
+#define HW_I2C_TIMING2_CLR	(0x00000038)
+#define HW_I2C_TIMING2_TOG	(0x0000003c)
+
+#define BP_I2C_TIMING2_RSVD2	26
+#define BM_I2C_TIMING2_RSVD2	0xFC000000
+#define BF_I2C_TIMING2_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING2_RSVD2)
+#define BP_I2C_TIMING2_BUS_FREE	16
+#define BM_I2C_TIMING2_BUS_FREE	0x03FF0000
+#define BF_I2C_TIMING2_BUS_FREE(v)  \
+		(((v) << 16) & BM_I2C_TIMING2_BUS_FREE)
+#define BP_I2C_TIMING2_RSVD1	10
+#define BM_I2C_TIMING2_RSVD1	0x0000FC00
+#define BF_I2C_TIMING2_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING2_RSVD1)
+#define BP_I2C_TIMING2_LEADIN_COUNT	0
+#define BM_I2C_TIMING2_LEADIN_COUNT	0x000003FF
+#define BF_I2C_TIMING2_LEADIN_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING2_LEADIN_COUNT)
+
+#define HW_I2C_CTRL1	(0x00000040)
+#define HW_I2C_CTRL1_SET	(0x00000044)
+#define HW_I2C_CTRL1_CLR	(0x00000048)
+#define HW_I2C_CTRL1_TOG	(0x0000004c)
+
+#define BP_I2C_CTRL1_RSVD1	29
+#define BM_I2C_CTRL1_RSVD1	0xE0000000
+#define BF_I2C_CTRL1_RSVD1(v) \
+		(((v) << 29) & BM_I2C_CTRL1_RSVD1)
+#define BM_I2C_CTRL1_CLR_GOT_A_NAK	0x10000000
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__DO_NOTHING 0x0
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__CLEAR      0x1
+#define BM_I2C_CTRL1_ACK_MODE	0x08000000
+#define BV_I2C_CTRL1_ACK_MODE__ACK_AFTER_HOLD_LOW  0x0
+#define BV_I2C_CTRL1_ACK_MODE__ACK_BEFORE_HOLD_LOW 0x1
+#define BM_I2C_CTRL1_FORCE_DATA_IDLE	0x04000000
+#define BM_I2C_CTRL1_FORCE_CLK_IDLE	0x02000000
+#define BM_I2C_CTRL1_BCAST_SLAVE_EN	0x01000000
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__NO_BCAST    0x0
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__WATCH_BCAST 0x1
+#define BP_I2C_CTRL1_SLAVE_ADDRESS_BYTE	16
+#define BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE	0x00FF0000
+#define BF_I2C_CTRL1_SLAVE_ADDRESS_BYTE(v)  \
+		(((v) << 16) & BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE)
+#define BM_I2C_CTRL1_BUS_FREE_IRQ_EN	0x00008000
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN	0x00004000
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN	0x00002000
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN	0x00001000
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ_EN	0x00000800
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ_EN	0x00000400
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ_EN	0x00000200
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ_EN	0x00000100
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_BUS_FREE_IRQ	0x00000080
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ	0x00000040
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ	0x00000020
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ	0x00000010
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ	0x00000008
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ	0x00000004
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ	0x00000002
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ	0x00000001
+#define BV_I2C_CTRL1_SLAVE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ__REQUEST    0x1
+
+#define HW_I2C_STAT	(0x00000050)
+
+#define BM_I2C_STAT_MASTER_PRESENT	0x80000000
+#define BV_I2C_STAT_MASTER_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_MASTER_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_SLAVE_PRESENT	0x40000000
+#define BV_I2C_STAT_SLAVE_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_SLAVE_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_ANY_ENABLED_IRQ	0x20000000
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__NO_REQUESTS          0x0
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__AT_LEAST_ONE_REQUEST 0x1
+#define BM_I2C_STAT_GOT_A_NAK	0x10000000
+#define BV_I2C_STAT_GOT_A_NAK__NO_NAK       0x0
+#define BV_I2C_STAT_GOT_A_NAK__DETECTED_NAK 0x1
+#define BP_I2C_STAT_RSVD1	24
+#define BM_I2C_STAT_RSVD1	0x0F000000
+#define BF_I2C_STAT_RSVD1(v)  \
+		(((v) << 24) & BM_I2C_STAT_RSVD1)
+#define BP_I2C_STAT_RCVD_SLAVE_ADDR	16
+#define BM_I2C_STAT_RCVD_SLAVE_ADDR	0x00FF0000
+#define BF_I2C_STAT_RCVD_SLAVE_ADDR(v)  \
+		(((v) << 16) & BM_I2C_STAT_RCVD_SLAVE_ADDR)
+#define BM_I2C_STAT_SLAVE_ADDR_EQ_ZERO	0x00008000
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__ZERO_NOT_MATCHED 0x0
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__WAS_ZERO         0x1
+#define BM_I2C_STAT_SLAVE_FOUND	0x00004000
+#define BV_I2C_STAT_SLAVE_FOUND__IDLE    0x0
+#define BV_I2C_STAT_SLAVE_FOUND__WAITING 0x1
+#define BM_I2C_STAT_SLAVE_SEARCHING	0x00002000
+#define BV_I2C_STAT_SLAVE_SEARCHING__IDLE   0x0
+#define BV_I2C_STAT_SLAVE_SEARCHING__ACTIVE 0x1
+#define BM_I2C_STAT_DATA_ENGINE_DMA_WAIT	0x00001000
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__CONTINUE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__WAITING  0x1
+#define BM_I2C_STAT_BUS_BUSY	0x00000800
+#define BV_I2C_STAT_BUS_BUSY__IDLE 0x0
+#define BV_I2C_STAT_BUS_BUSY__BUSY 0x1
+#define BM_I2C_STAT_CLK_GEN_BUSY	0x00000400
+#define BV_I2C_STAT_CLK_GEN_BUSY__IDLE 0x0
+#define BV_I2C_STAT_CLK_GEN_BUSY__BUSY 0x1
+#define BM_I2C_STAT_DATA_ENGINE_BUSY	0x00000200
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_SLAVE_BUSY	0x00000100
+#define BV_I2C_STAT_SLAVE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_SLAVE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_BUS_FREE_IRQ_SUMMARY	0x00000080
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY	0x00000040
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY	0x00000020
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY	0x00000010
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_EARLY_TERM_IRQ_SUMMARY	0x00000008
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY	0x00000004
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY	0x00000002
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_IRQ_SUMMARY	0x00000001
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__REQUEST    0x1
+
+#define HW_I2C_DATA	(0x00000060)
+
+#define BP_I2C_DATA_DATA	0
+#define BM_I2C_DATA_DATA	0xFFFFFFFF
+#define BF_I2C_DATA_DATA(v)	(v)
+
+#define HW_I2C_DEBUG0	(0x00000070)
+#define HW_I2C_DEBUG0_SET	(0x00000074)
+#define HW_I2C_DEBUG0_CLR	(0x00000078)
+#define HW_I2C_DEBUG0_TOG	(0x0000007c)
+
+#define BM_I2C_DEBUG0_DMAREQ	0x80000000
+#define BM_I2C_DEBUG0_DMAENDCMD	0x40000000
+#define BM_I2C_DEBUG0_DMAKICK	0x20000000
+#define BM_I2C_DEBUG0_DMATERMINATE	0x10000000
+#define BP_I2C_DEBUG0_TBD	26
+#define BM_I2C_DEBUG0_TBD	0x0C000000
+#define BF_I2C_DEBUG0_TBD(v)  \
+		(((v) << 26) & BM_I2C_DEBUG0_TBD)
+#define BP_I2C_DEBUG0_DMA_STATE	16
+#define BM_I2C_DEBUG0_DMA_STATE	0x03FF0000
+#define BF_I2C_DEBUG0_DMA_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG0_DMA_STATE)
+#define BM_I2C_DEBUG0_START_TOGGLE	0x00008000
+#define BM_I2C_DEBUG0_STOP_TOGGLE	0x00004000
+#define BM_I2C_DEBUG0_GRAB_TOGGLE	0x00002000
+#define BM_I2C_DEBUG0_CHANGE_TOGGLE	0x00001000
+#define BM_I2C_DEBUG0_TESTMODE	0x00000800
+#define BM_I2C_DEBUG0_SLAVE_HOLD_CLK	0x00000400
+#define BP_I2C_DEBUG0_SLAVE_STATE	0
+#define BM_I2C_DEBUG0_SLAVE_STATE	0x000003FF
+#define BF_I2C_DEBUG0_SLAVE_STATE(v)  \
+		(((v) << 0) & BM_I2C_DEBUG0_SLAVE_STATE)
+
+#define HW_I2C_DEBUG1	(0x00000080)
+#define HW_I2C_DEBUG1_SET	(0x00000084)
+#define HW_I2C_DEBUG1_CLR	(0x00000088)
+#define HW_I2C_DEBUG1_TOG	(0x0000008c)
+
+#define BM_I2C_DEBUG1_I2C_CLK_IN	0x80000000
+#define BM_I2C_DEBUG1_I2C_DATA_IN	0x40000000
+#define BP_I2C_DEBUG1_RSVD4	28
+#define BM_I2C_DEBUG1_RSVD4	0x30000000
+#define BF_I2C_DEBUG1_RSVD4(v)  \
+		(((v) << 28) & BM_I2C_DEBUG1_RSVD4)
+#define BP_I2C_DEBUG1_DMA_BYTE_ENABLES	24
+#define BM_I2C_DEBUG1_DMA_BYTE_ENABLES	0x0F000000
+#define BF_I2C_DEBUG1_DMA_BYTE_ENABLES(v)  \
+		(((v) << 24) & BM_I2C_DEBUG1_DMA_BYTE_ENABLES)
+#define BP_I2C_DEBUG1_CLK_GEN_STATE	16
+#define BM_I2C_DEBUG1_CLK_GEN_STATE	0x00FF0000
+#define BF_I2C_DEBUG1_CLK_GEN_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG1_CLK_GEN_STATE)
+#define BP_I2C_DEBUG1_RSVD2	11
+#define BM_I2C_DEBUG1_RSVD2	0x0000F800
+#define BF_I2C_DEBUG1_RSVD2(v)  \
+		(((v) << 11) & BM_I2C_DEBUG1_RSVD2)
+#define BP_I2C_DEBUG1_LST_MODE	9
+#define BM_I2C_DEBUG1_LST_MODE	0x00000600
+#define BF_I2C_DEBUG1_LST_MODE(v)  \
+		(((v) << 9) & BM_I2C_DEBUG1_LST_MODE)
+#define BV_I2C_DEBUG1_LST_MODE__BCAST    0x0
+#define BV_I2C_DEBUG1_LST_MODE__MY_WRITE 0x1
+#define BV_I2C_DEBUG1_LST_MODE__MY_READ  0x2
+#define BV_I2C_DEBUG1_LST_MODE__NOT_ME   0x3
+#define BM_I2C_DEBUG1_LOCAL_SLAVE_TEST	0x00000100
+#define BP_I2C_DEBUG1_RSVD1	5
+#define BM_I2C_DEBUG1_RSVD1	0x000000E0
+#define BF_I2C_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_I2C_DEBUG1_RSVD1)
+#define BM_I2C_DEBUG1_FORCE_CLK_ON	0x00000010
+#define BM_I2C_DEBUG1_FORCE_ARB_LOSS	0x00000008
+#define BM_I2C_DEBUG1_FORCE_RCV_ACK	0x00000004
+#define BM_I2C_DEBUG1_FORCE_I2C_DATA_OE	0x00000002
+#define BM_I2C_DEBUG1_FORCE_I2C_CLK_OE	0x00000001
+
+#define HW_I2C_VERSION	(0x00000090)
+
+#define BP_I2C_VERSION_MAJOR	24
+#define BM_I2C_VERSION_MAJOR	0xFF000000
+#define BF_I2C_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_I2C_VERSION_MAJOR)
+#define BP_I2C_VERSION_MINOR	16
+#define BM_I2C_VERSION_MINOR	0x00FF0000
+#define BF_I2C_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_I2C_VERSION_MINOR)
+#define BP_I2C_VERSION_STEP	0
+#define BM_I2C_VERSION_STEP	0x0000FFFF
+#define BF_I2C_VERSION_STEP(v)  \
+		(((v) << 0) & BM_I2C_VERSION_STEP)
+#endif /* __ARCH_ARM___I2C_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-lcdif.h b/arch/arm/mach-mx23/include/mach/regs-lcdif.h
new file mode 100644
index 0000000..b8eae0f
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-lcdif.h
@@ -0,0 +1,650 @@
+/*
+ * Freescale LCDIF Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.32
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___LCDIF_H
+#define __ARCH_ARM___LCDIF_H
+
+
+#define HW_LCDIF_CTRL	(0x00000000)
+#define HW_LCDIF_CTRL_SET	(0x00000004)
+#define HW_LCDIF_CTRL_CLR	(0x00000008)
+#define HW_LCDIF_CTRL_TOG	(0x0000000c)
+
+#define BM_LCDIF_CTRL_SFTRST	0x80000000
+#define BM_LCDIF_CTRL_CLKGATE	0x40000000
+#define BM_LCDIF_CTRL_YCBCR422_INPUT	0x20000000
+#define BM_LCDIF_CTRL_RSRVD0	0x10000000
+#define BM_LCDIF_CTRL_WAIT_FOR_VSYNC_EDGE	0x08000000
+#define BM_LCDIF_CTRL_DATA_SHIFT_DIR	0x04000000
+#define BV_LCDIF_CTRL_DATA_SHIFT_DIR__TXDATA_SHIFT_LEFT  0x0
+#define BV_LCDIF_CTRL_DATA_SHIFT_DIR__TXDATA_SHIFT_RIGHT 0x1
+#define BP_LCDIF_CTRL_SHIFT_NUM_BITS	21
+#define BM_LCDIF_CTRL_SHIFT_NUM_BITS	0x03E00000
+#define BF_LCDIF_CTRL_SHIFT_NUM_BITS(v)  \
+		(((v) << 21) & BM_LCDIF_CTRL_SHIFT_NUM_BITS)
+#define BM_LCDIF_CTRL_DVI_MODE	0x00100000
+#define BM_LCDIF_CTRL_BYPASS_COUNT	0x00080000
+#define BM_LCDIF_CTRL_VSYNC_MODE	0x00040000
+#define BM_LCDIF_CTRL_DOTCLK_MODE	0x00020000
+#define BM_LCDIF_CTRL_DATA_SELECT	0x00010000
+#define BV_LCDIF_CTRL_DATA_SELECT__CMD_MODE  0x0
+#define BV_LCDIF_CTRL_DATA_SELECT__DATA_MODE 0x1
+#define BP_LCDIF_CTRL_INPUT_DATA_SWIZZLE	14
+#define BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE	0x0000C000
+#define BF_LCDIF_CTRL_INPUT_DATA_SWIZZLE(v)  \
+		(((v) << 14) & BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE)
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__NO_SWAP         0x0
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__LITTLE_ENDIAN   0x0
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__BIG_ENDIAN_SWAP 0x1
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__SWAP_ALL_BYTES  0x1
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__HWD_SWAP        0x2
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__HWD_BYTE_SWAP   0x3
+#define BP_LCDIF_CTRL_CSC_DATA_SWIZZLE	12
+#define BM_LCDIF_CTRL_CSC_DATA_SWIZZLE	0x00003000
+#define BF_LCDIF_CTRL_CSC_DATA_SWIZZLE(v)  \
+		(((v) << 12) & BM_LCDIF_CTRL_CSC_DATA_SWIZZLE)
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__NO_SWAP         0x0
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__LITTLE_ENDIAN   0x0
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__BIG_ENDIAN_SWAP 0x1
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__SWAP_ALL_BYTES  0x1
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__HWD_SWAP        0x2
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__HWD_BYTE_SWAP   0x3
+#define BP_LCDIF_CTRL_LCD_DATABUS_WIDTH	10
+#define BM_LCDIF_CTRL_LCD_DATABUS_WIDTH	0x00000C00
+#define BF_LCDIF_CTRL_LCD_DATABUS_WIDTH(v)  \
+		(((v) << 10) & BM_LCDIF_CTRL_LCD_DATABUS_WIDTH)
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__16_BIT 0x0
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__8_BIT  0x1
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__18_BIT 0x2
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__24_BIT 0x3
+#define BP_LCDIF_CTRL_WORD_LENGTH	8
+#define BM_LCDIF_CTRL_WORD_LENGTH	0x00000300
+#define BF_LCDIF_CTRL_WORD_LENGTH(v)  \
+		(((v) << 8) & BM_LCDIF_CTRL_WORD_LENGTH)
+#define BV_LCDIF_CTRL_WORD_LENGTH__16_BIT 0x0
+#define BV_LCDIF_CTRL_WORD_LENGTH__8_BIT  0x1
+#define BV_LCDIF_CTRL_WORD_LENGTH__18_BIT 0x2
+#define BV_LCDIF_CTRL_WORD_LENGTH__24_BIT 0x3
+#define BM_LCDIF_CTRL_RGB_TO_YCBCR422_CSC	0x00000080
+#define BM_LCDIF_CTRL_ENABLE_PXP_HANDSHAKE	0x00000040
+#define BM_LCDIF_CTRL_LCDIF_MASTER	0x00000020
+#define BM_LCDIF_CTRL_DMA_BURST_LENGTH	0x00000010
+#define BM_LCDIF_CTRL_DATA_FORMAT_16_BIT	0x00000008
+#define BM_LCDIF_CTRL_DATA_FORMAT_18_BIT	0x00000004
+#define BV_LCDIF_CTRL_DATA_FORMAT_18_BIT__LOWER_18_BITS_VALID 0x0
+#define BV_LCDIF_CTRL_DATA_FORMAT_18_BIT__UPPER_18_BITS_VALID 0x1
+#define BM_LCDIF_CTRL_DATA_FORMAT_24_BIT	0x00000002
+#define BV_LCDIF_CTRL_DATA_FORMAT_24_BIT__ALL_24_BITS_VALID          0x0
+#define BV_LCDIF_CTRL_DATA_FORMAT_24_BIT__DROP_UPPER_2_BITS_PER_BYTE 0x1
+#define BM_LCDIF_CTRL_RUN	0x00000001
+
+#define HW_LCDIF_CTRL1	(0x00000010)
+#define HW_LCDIF_CTRL1_SET	(0x00000014)
+#define HW_LCDIF_CTRL1_CLR	(0x00000018)
+#define HW_LCDIF_CTRL1_TOG	(0x0000001c)
+
+#define BP_LCDIF_CTRL1_RSRVD1	27
+#define BM_LCDIF_CTRL1_RSRVD1	0xF8000000
+#define BF_LCDIF_CTRL1_RSRVD1(v) \
+		(((v) << 27) & BM_LCDIF_CTRL1_RSRVD1)
+#define BM_LCDIF_CTRL1_BM_ERROR_IRQ_EN	0x04000000
+#define BM_LCDIF_CTRL1_BM_ERROR_IRQ	0x02000000
+#define BV_LCDIF_CTRL1_BM_ERROR_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_BM_ERROR_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_RECOVER_ON_UNDERFLOW	0x01000000
+#define BM_LCDIF_CTRL1_INTERLACE_FIELDS	0x00800000
+#define BM_LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD	0x00400000
+#define BM_LCDIF_CTRL1_FIFO_CLEAR	0x00200000
+#define BM_LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS	0x00100000
+#define BP_LCDIF_CTRL1_BYTE_PACKING_FORMAT	16
+#define BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT	0x000F0000
+#define BF_LCDIF_CTRL1_BYTE_PACKING_FORMAT(v)  \
+		(((v) << 16) & BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT)
+#define BM_LCDIF_CTRL1_OVERFLOW_IRQ_EN	0x00008000
+#define BM_LCDIF_CTRL1_UNDERFLOW_IRQ_EN	0x00004000
+#define BM_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN	0x00002000
+#define BM_LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN	0x00001000
+#define BM_LCDIF_CTRL1_OVERFLOW_IRQ	0x00000800
+#define BV_LCDIF_CTRL1_OVERFLOW_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_OVERFLOW_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_UNDERFLOW_IRQ	0x00000400
+#define BV_LCDIF_CTRL1_UNDERFLOW_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_UNDERFLOW_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ	0x00000200
+#define BV_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_VSYNC_EDGE_IRQ	0x00000100
+#define BV_LCDIF_CTRL1_VSYNC_EDGE_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_VSYNC_EDGE_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_RSRVD0	0x00000080
+#define BM_LCDIF_CTRL1_PAUSE_TRANSFER	0x00000040
+#define BM_LCDIF_CTRL1_PAUSE_TRANSFER_IRQ_EN	0x00000020
+#define BM_LCDIF_CTRL1_PAUSE_TRANSFER_IRQ	0x00000010
+#define BV_LCDIF_CTRL1_PAUSE_TRANSFER_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_PAUSE_TRANSFER_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_LCD_CS_CTRL	0x00000008
+#define BM_LCDIF_CTRL1_BUSY_ENABLE	0x00000004
+#define BV_LCDIF_CTRL1_BUSY_ENABLE__BUSY_DISABLED 0x0
+#define BV_LCDIF_CTRL1_BUSY_ENABLE__BUSY_ENABLED  0x1
+#define BM_LCDIF_CTRL1_MODE86	0x00000002
+#define BV_LCDIF_CTRL1_MODE86__8080_MODE 0x0
+#define BV_LCDIF_CTRL1_MODE86__6800_MODE 0x1
+#define BM_LCDIF_CTRL1_RESET	0x00000001
+#define BV_LCDIF_CTRL1_RESET__LCDRESET_LOW  0x0
+#define BV_LCDIF_CTRL1_RESET__LCDRESET_HIGH 0x1
+
+#define HW_LCDIF_TRANSFER_COUNT	(0x00000020)
+
+#define BP_LCDIF_TRANSFER_COUNT_V_COUNT	16
+#define BM_LCDIF_TRANSFER_COUNT_V_COUNT	0xFFFF0000
+#define BF_LCDIF_TRANSFER_COUNT_V_COUNT(v) \
+		(((v) << 16) & BM_LCDIF_TRANSFER_COUNT_V_COUNT)
+#define BP_LCDIF_TRANSFER_COUNT_H_COUNT	0
+#define BM_LCDIF_TRANSFER_COUNT_H_COUNT	0x0000FFFF
+#define BF_LCDIF_TRANSFER_COUNT_H_COUNT(v)  \
+		(((v) << 0) & BM_LCDIF_TRANSFER_COUNT_H_COUNT)
+
+#define HW_LCDIF_CUR_BUF	(0x00000030)
+
+#define BP_LCDIF_CUR_BUF_ADDR	0
+#define BM_LCDIF_CUR_BUF_ADDR	0xFFFFFFFF
+#define BF_LCDIF_CUR_BUF_ADDR(v)	(v)
+
+#define HW_LCDIF_NEXT_BUF	(0x00000040)
+
+#define BP_LCDIF_NEXT_BUF_ADDR	0
+#define BM_LCDIF_NEXT_BUF_ADDR	0xFFFFFFFF
+#define BF_LCDIF_NEXT_BUF_ADDR(v)	(v)
+
+#define HW_LCDIF_PAGETABLE	(0x00000050)
+
+#define BP_LCDIF_PAGETABLE_BASE	14
+#define BM_LCDIF_PAGETABLE_BASE	0xFFFFC000
+#define BF_LCDIF_PAGETABLE_BASE(v) \
+		(((v) << 14) & BM_LCDIF_PAGETABLE_BASE)
+#define BP_LCDIF_PAGETABLE_RSVD1	2
+#define BM_LCDIF_PAGETABLE_RSVD1	0x00003FFC
+#define BF_LCDIF_PAGETABLE_RSVD1(v)  \
+		(((v) << 2) & BM_LCDIF_PAGETABLE_RSVD1)
+#define BM_LCDIF_PAGETABLE_FLUSH	0x00000002
+#define BM_LCDIF_PAGETABLE_ENABLE	0x00000001
+
+#define HW_LCDIF_TIMING	(0x00000060)
+
+#define BP_LCDIF_TIMING_CMD_HOLD	24
+#define BM_LCDIF_TIMING_CMD_HOLD	0xFF000000
+#define BF_LCDIF_TIMING_CMD_HOLD(v) \
+		(((v) << 24) & BM_LCDIF_TIMING_CMD_HOLD)
+#define BP_LCDIF_TIMING_CMD_SETUP	16
+#define BM_LCDIF_TIMING_CMD_SETUP	0x00FF0000
+#define BF_LCDIF_TIMING_CMD_SETUP(v)  \
+		(((v) << 16) & BM_LCDIF_TIMING_CMD_SETUP)
+#define BP_LCDIF_TIMING_DATA_HOLD	8
+#define BM_LCDIF_TIMING_DATA_HOLD	0x0000FF00
+#define BF_LCDIF_TIMING_DATA_HOLD(v)  \
+		(((v) << 8) & BM_LCDIF_TIMING_DATA_HOLD)
+#define BP_LCDIF_TIMING_DATA_SETUP	0
+#define BM_LCDIF_TIMING_DATA_SETUP	0x000000FF
+#define BF_LCDIF_TIMING_DATA_SETUP(v)  \
+		(((v) << 0) & BM_LCDIF_TIMING_DATA_SETUP)
+
+#define HW_LCDIF_VDCTRL0	(0x00000070)
+#define HW_LCDIF_VDCTRL0_SET	(0x00000074)
+#define HW_LCDIF_VDCTRL0_CLR	(0x00000078)
+#define HW_LCDIF_VDCTRL0_TOG	(0x0000007c)
+
+#define BP_LCDIF_VDCTRL0_RSRVD2	30
+#define BM_LCDIF_VDCTRL0_RSRVD2	0xC0000000
+#define BF_LCDIF_VDCTRL0_RSRVD2(v) \
+		(((v) << 30) & BM_LCDIF_VDCTRL0_RSRVD2)
+#define BM_LCDIF_VDCTRL0_VSYNC_OEB	0x20000000
+#define BV_LCDIF_VDCTRL0_VSYNC_OEB__VSYNC_OUTPUT 0x0
+#define BV_LCDIF_VDCTRL0_VSYNC_OEB__VSYNC_INPUT  0x1
+#define BM_LCDIF_VDCTRL0_ENABLE_PRESENT	0x10000000
+#define BM_LCDIF_VDCTRL0_VSYNC_POL	0x08000000
+#define BM_LCDIF_VDCTRL0_HSYNC_POL	0x04000000
+#define BM_LCDIF_VDCTRL0_DOTCLK_POL	0x02000000
+#define BM_LCDIF_VDCTRL0_ENABLE_POL	0x01000000
+#define BP_LCDIF_VDCTRL0_RSRVD1	22
+#define BM_LCDIF_VDCTRL0_RSRVD1	0x00C00000
+#define BF_LCDIF_VDCTRL0_RSRVD1(v)  \
+		(((v) << 22) & BM_LCDIF_VDCTRL0_RSRVD1)
+#define BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT	0x00200000
+#define BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT	0x00100000
+#define BM_LCDIF_VDCTRL0_HALF_LINE	0x00080000
+#define BM_LCDIF_VDCTRL0_HALF_LINE_MODE	0x00040000
+#define BP_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH	0
+#define BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH	0x0003FFFF
+#define BF_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH)
+
+#define HW_LCDIF_VDCTRL1	(0x00000080)
+
+#define BP_LCDIF_VDCTRL1_VSYNC_PERIOD	0
+#define BM_LCDIF_VDCTRL1_VSYNC_PERIOD	0xFFFFFFFF
+#define BF_LCDIF_VDCTRL1_VSYNC_PERIOD(v)	(v)
+
+#define HW_LCDIF_VDCTRL2	(0x00000090)
+
+#define BP_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH	24
+#define BM_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH	0xFF000000
+#define BF_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH(v) \
+		(((v) << 24) & BM_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH)
+#define BP_LCDIF_VDCTRL2_RSRVD0	18
+#define BM_LCDIF_VDCTRL2_RSRVD0	0x00FC0000
+#define BF_LCDIF_VDCTRL2_RSRVD0(v)  \
+		(((v) << 18) & BM_LCDIF_VDCTRL2_RSRVD0)
+#define BP_LCDIF_VDCTRL2_HSYNC_PERIOD	0
+#define BM_LCDIF_VDCTRL2_HSYNC_PERIOD	0x0003FFFF
+#define BF_LCDIF_VDCTRL2_HSYNC_PERIOD(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL2_HSYNC_PERIOD)
+
+#define HW_LCDIF_VDCTRL3	(0x000000a0)
+
+#define BP_LCDIF_VDCTRL3_RSRVD0	30
+#define BM_LCDIF_VDCTRL3_RSRVD0	0xC0000000
+#define BF_LCDIF_VDCTRL3_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_VDCTRL3_RSRVD0)
+#define BM_LCDIF_VDCTRL3_MUX_SYNC_SIGNALS	0x20000000
+#define BM_LCDIF_VDCTRL3_VSYNC_ONLY	0x10000000
+#define BP_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT	16
+#define BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT	0x0FFF0000
+#define BF_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT(v)  \
+		(((v) << 16) & BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT)
+#define BP_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT	0
+#define BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT	0x0000FFFF
+#define BF_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT)
+
+#define HW_LCDIF_VDCTRL4	(0x000000b0)
+
+#define BP_LCDIF_VDCTRL4_RSRVD0	19
+#define BM_LCDIF_VDCTRL4_RSRVD0	0xFFF80000
+#define BF_LCDIF_VDCTRL4_RSRVD0(v) \
+		(((v) << 19) & BM_LCDIF_VDCTRL4_RSRVD0)
+#define BM_LCDIF_VDCTRL4_SYNC_SIGNALS_ON	0x00040000
+#define BP_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT	0
+#define BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT	0x0003FFFF
+#define BF_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT)
+
+#define HW_LCDIF_DVICTRL0	(0x000000c0)
+
+#define BM_LCDIF_DVICTRL0_START_TRS	0x80000000
+#define BP_LCDIF_DVICTRL0_H_ACTIVE_CNT	20
+#define BM_LCDIF_DVICTRL0_H_ACTIVE_CNT	0x7FF00000
+#define BF_LCDIF_DVICTRL0_H_ACTIVE_CNT(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL0_H_ACTIVE_CNT)
+#define BP_LCDIF_DVICTRL0_H_BLANKING_CNT	10
+#define BM_LCDIF_DVICTRL0_H_BLANKING_CNT	0x000FFC00
+#define BF_LCDIF_DVICTRL0_H_BLANKING_CNT(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL0_H_BLANKING_CNT)
+#define BP_LCDIF_DVICTRL0_V_LINES_CNT	0
+#define BM_LCDIF_DVICTRL0_V_LINES_CNT	0x000003FF
+#define BF_LCDIF_DVICTRL0_V_LINES_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL0_V_LINES_CNT)
+
+#define HW_LCDIF_DVICTRL1	(0x000000d0)
+
+#define BP_LCDIF_DVICTRL1_RSRVD0	30
+#define BM_LCDIF_DVICTRL1_RSRVD0	0xC0000000
+#define BF_LCDIF_DVICTRL1_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_DVICTRL1_RSRVD0)
+#define BP_LCDIF_DVICTRL1_F1_START_LINE	20
+#define BM_LCDIF_DVICTRL1_F1_START_LINE	0x3FF00000
+#define BF_LCDIF_DVICTRL1_F1_START_LINE(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL1_F1_START_LINE)
+#define BP_LCDIF_DVICTRL1_F1_END_LINE	10
+#define BM_LCDIF_DVICTRL1_F1_END_LINE	0x000FFC00
+#define BF_LCDIF_DVICTRL1_F1_END_LINE(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL1_F1_END_LINE)
+#define BP_LCDIF_DVICTRL1_F2_START_LINE	0
+#define BM_LCDIF_DVICTRL1_F2_START_LINE	0x000003FF
+#define BF_LCDIF_DVICTRL1_F2_START_LINE(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL1_F2_START_LINE)
+
+#define HW_LCDIF_DVICTRL2	(0x000000e0)
+
+#define BP_LCDIF_DVICTRL2_RSRVD0	30
+#define BM_LCDIF_DVICTRL2_RSRVD0	0xC0000000
+#define BF_LCDIF_DVICTRL2_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_DVICTRL2_RSRVD0)
+#define BP_LCDIF_DVICTRL2_F2_END_LINE	20
+#define BM_LCDIF_DVICTRL2_F2_END_LINE	0x3FF00000
+#define BF_LCDIF_DVICTRL2_F2_END_LINE(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL2_F2_END_LINE)
+#define BP_LCDIF_DVICTRL2_V1_BLANK_START_LINE	10
+#define BM_LCDIF_DVICTRL2_V1_BLANK_START_LINE	0x000FFC00
+#define BF_LCDIF_DVICTRL2_V1_BLANK_START_LINE(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL2_V1_BLANK_START_LINE)
+#define BP_LCDIF_DVICTRL2_V1_BLANK_END_LINE	0
+#define BM_LCDIF_DVICTRL2_V1_BLANK_END_LINE	0x000003FF
+#define BF_LCDIF_DVICTRL2_V1_BLANK_END_LINE(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL2_V1_BLANK_END_LINE)
+
+#define HW_LCDIF_DVICTRL3	(0x000000f0)
+
+#define BP_LCDIF_DVICTRL3_RSRVD1	26
+#define BM_LCDIF_DVICTRL3_RSRVD1	0xFC000000
+#define BF_LCDIF_DVICTRL3_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_DVICTRL3_RSRVD1)
+#define BP_LCDIF_DVICTRL3_V2_BLANK_START_LINE	16
+#define BM_LCDIF_DVICTRL3_V2_BLANK_START_LINE	0x03FF0000
+#define BF_LCDIF_DVICTRL3_V2_BLANK_START_LINE(v)  \
+		(((v) << 16) & BM_LCDIF_DVICTRL3_V2_BLANK_START_LINE)
+#define BP_LCDIF_DVICTRL3_RSRVD0	10
+#define BM_LCDIF_DVICTRL3_RSRVD0	0x0000FC00
+#define BF_LCDIF_DVICTRL3_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL3_RSRVD0)
+#define BP_LCDIF_DVICTRL3_V2_BLANK_END_LINE	0
+#define BM_LCDIF_DVICTRL3_V2_BLANK_END_LINE	0x000003FF
+#define BF_LCDIF_DVICTRL3_V2_BLANK_END_LINE(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL3_V2_BLANK_END_LINE)
+
+#define HW_LCDIF_DVICTRL4	(0x00000100)
+
+#define BP_LCDIF_DVICTRL4_Y_FILL_VALUE	24
+#define BM_LCDIF_DVICTRL4_Y_FILL_VALUE	0xFF000000
+#define BF_LCDIF_DVICTRL4_Y_FILL_VALUE(v) \
+		(((v) << 24) & BM_LCDIF_DVICTRL4_Y_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_CB_FILL_VALUE	16
+#define BM_LCDIF_DVICTRL4_CB_FILL_VALUE	0x00FF0000
+#define BF_LCDIF_DVICTRL4_CB_FILL_VALUE(v)  \
+		(((v) << 16) & BM_LCDIF_DVICTRL4_CB_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_CR_FILL_VALUE	8
+#define BM_LCDIF_DVICTRL4_CR_FILL_VALUE	0x0000FF00
+#define BF_LCDIF_DVICTRL4_CR_FILL_VALUE(v)  \
+		(((v) << 8) & BM_LCDIF_DVICTRL4_CR_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_H_FILL_CNT	0
+#define BM_LCDIF_DVICTRL4_H_FILL_CNT	0x000000FF
+#define BF_LCDIF_DVICTRL4_H_FILL_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL4_H_FILL_CNT)
+
+#define HW_LCDIF_CSC_COEFF0	(0x00000110)
+
+#define BP_LCDIF_CSC_COEFF0_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF0_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF0_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF0_RSRVD1)
+#define BP_LCDIF_CSC_COEFF0_C0	16
+#define BM_LCDIF_CSC_COEFF0_C0	0x03FF0000
+#define BF_LCDIF_CSC_COEFF0_C0(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF0_C0)
+#define BP_LCDIF_CSC_COEFF0_RSRVD0	2
+#define BM_LCDIF_CSC_COEFF0_RSRVD0	0x0000FFFC
+#define BF_LCDIF_CSC_COEFF0_RSRVD0(v)  \
+		(((v) << 2) & BM_LCDIF_CSC_COEFF0_RSRVD0)
+#define BP_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER	0
+#define BM_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER	0x00000003
+#define BF_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER)
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__SAMPLE_AND_HOLD 0x0
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__RSRVD           0x1
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__INTERSTITIAL    0x2
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__COSITED         0x3
+
+#define HW_LCDIF_CSC_COEFF1	(0x00000120)
+
+#define BP_LCDIF_CSC_COEFF1_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF1_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF1_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF1_RSRVD1)
+#define BP_LCDIF_CSC_COEFF1_C2	16
+#define BM_LCDIF_CSC_COEFF1_C2	0x03FF0000
+#define BF_LCDIF_CSC_COEFF1_C2(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF1_C2)
+#define BP_LCDIF_CSC_COEFF1_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF1_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF1_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF1_RSRVD0)
+#define BP_LCDIF_CSC_COEFF1_C1	0
+#define BM_LCDIF_CSC_COEFF1_C1	0x000003FF
+#define BF_LCDIF_CSC_COEFF1_C1(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF1_C1)
+
+#define HW_LCDIF_CSC_COEFF2	(0x00000130)
+
+#define BP_LCDIF_CSC_COEFF2_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF2_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF2_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF2_RSRVD1)
+#define BP_LCDIF_CSC_COEFF2_C4	16
+#define BM_LCDIF_CSC_COEFF2_C4	0x03FF0000
+#define BF_LCDIF_CSC_COEFF2_C4(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF2_C4)
+#define BP_LCDIF_CSC_COEFF2_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF2_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF2_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF2_RSRVD0)
+#define BP_LCDIF_CSC_COEFF2_C3	0
+#define BM_LCDIF_CSC_COEFF2_C3	0x000003FF
+#define BF_LCDIF_CSC_COEFF2_C3(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF2_C3)
+
+#define HW_LCDIF_CSC_COEFF3	(0x00000140)
+
+#define BP_LCDIF_CSC_COEFF3_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF3_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF3_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF3_RSRVD1)
+#define BP_LCDIF_CSC_COEFF3_C6	16
+#define BM_LCDIF_CSC_COEFF3_C6	0x03FF0000
+#define BF_LCDIF_CSC_COEFF3_C6(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF3_C6)
+#define BP_LCDIF_CSC_COEFF3_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF3_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF3_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF3_RSRVD0)
+#define BP_LCDIF_CSC_COEFF3_C5	0
+#define BM_LCDIF_CSC_COEFF3_C5	0x000003FF
+#define BF_LCDIF_CSC_COEFF3_C5(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF3_C5)
+
+#define HW_LCDIF_CSC_COEFF4	(0x00000150)
+
+#define BP_LCDIF_CSC_COEFF4_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF4_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF4_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF4_RSRVD1)
+#define BP_LCDIF_CSC_COEFF4_C8	16
+#define BM_LCDIF_CSC_COEFF4_C8	0x03FF0000
+#define BF_LCDIF_CSC_COEFF4_C8(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF4_C8)
+#define BP_LCDIF_CSC_COEFF4_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF4_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF4_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF4_RSRVD0)
+#define BP_LCDIF_CSC_COEFF4_C7	0
+#define BM_LCDIF_CSC_COEFF4_C7	0x000003FF
+#define BF_LCDIF_CSC_COEFF4_C7(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF4_C7)
+
+#define HW_LCDIF_CSC_OFFSET	(0x00000160)
+
+#define BP_LCDIF_CSC_OFFSET_RSRVD1	25
+#define BM_LCDIF_CSC_OFFSET_RSRVD1	0xFE000000
+#define BF_LCDIF_CSC_OFFSET_RSRVD1(v) \
+		(((v) << 25) & BM_LCDIF_CSC_OFFSET_RSRVD1)
+#define BP_LCDIF_CSC_OFFSET_CBCR_OFFSET	16
+#define BM_LCDIF_CSC_OFFSET_CBCR_OFFSET	0x01FF0000
+#define BF_LCDIF_CSC_OFFSET_CBCR_OFFSET(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_OFFSET_CBCR_OFFSET)
+#define BP_LCDIF_CSC_OFFSET_RSRVD0	9
+#define BM_LCDIF_CSC_OFFSET_RSRVD0	0x0000FE00
+#define BF_LCDIF_CSC_OFFSET_RSRVD0(v)  \
+		(((v) << 9) & BM_LCDIF_CSC_OFFSET_RSRVD0)
+#define BP_LCDIF_CSC_OFFSET_Y_OFFSET	0
+#define BM_LCDIF_CSC_OFFSET_Y_OFFSET	0x000001FF
+#define BF_LCDIF_CSC_OFFSET_Y_OFFSET(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_OFFSET_Y_OFFSET)
+
+#define HW_LCDIF_CSC_LIMIT	(0x00000170)
+
+#define BP_LCDIF_CSC_LIMIT_CBCR_MIN	24
+#define BM_LCDIF_CSC_LIMIT_CBCR_MIN	0xFF000000
+#define BF_LCDIF_CSC_LIMIT_CBCR_MIN(v) \
+		(((v) << 24) & BM_LCDIF_CSC_LIMIT_CBCR_MIN)
+#define BP_LCDIF_CSC_LIMIT_CBCR_MAX	16
+#define BM_LCDIF_CSC_LIMIT_CBCR_MAX	0x00FF0000
+#define BF_LCDIF_CSC_LIMIT_CBCR_MAX(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_LIMIT_CBCR_MAX)
+#define BP_LCDIF_CSC_LIMIT_Y_MIN	8
+#define BM_LCDIF_CSC_LIMIT_Y_MIN	0x0000FF00
+#define BF_LCDIF_CSC_LIMIT_Y_MIN(v)  \
+		(((v) << 8) & BM_LCDIF_CSC_LIMIT_Y_MIN)
+#define BP_LCDIF_CSC_LIMIT_Y_MAX	0
+#define BM_LCDIF_CSC_LIMIT_Y_MAX	0x000000FF
+#define BF_LCDIF_CSC_LIMIT_Y_MAX(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_LIMIT_Y_MAX)
+
+#define HW_LCDIF_PIN_SHARING_CTRL0	(0x00000180)
+#define HW_LCDIF_PIN_SHARING_CTRL0_SET	(0x00000184)
+#define HW_LCDIF_PIN_SHARING_CTRL0_CLR	(0x00000188)
+#define HW_LCDIF_PIN_SHARING_CTRL0_TOG	(0x0000018c)
+
+#define BP_LCDIF_PIN_SHARING_CTRL0_RSRVD1	6
+#define BM_LCDIF_PIN_SHARING_CTRL0_RSRVD1	0xFFFFFFC0
+#define BF_LCDIF_PIN_SHARING_CTRL0_RSRVD1(v) \
+		(((v) << 6) & BM_LCDIF_PIN_SHARING_CTRL0_RSRVD1)
+#define BP_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE	4
+#define BM_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE	0x00000030
+#define BF_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE(v)  \
+		(((v) << 4) & BM_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE)
+#define BV_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE__NO_OVERRIDE 0x0
+#define BV_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE__RSRVD       0x1
+#define BV_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE__LCDIF_SEL   0x2
+#define BV_LCDIF_PIN_SHARING_CTRL0_MUX_OVERRIDE__GPMI_SEL    0x3
+#define BM_LCDIF_PIN_SHARING_CTRL0_RSRVD0	0x00000008
+#define BM_LCDIF_PIN_SHARING_CTRL0_PIN_SHARING_IRQ_EN	0x00000004
+#define BM_LCDIF_PIN_SHARING_CTRL0_PIN_SHARING_IRQ	0x00000002
+#define BV_LCDIF_PIN_SHARING_CTRL0_PIN_SHARING_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_PIN_SHARING_CTRL0_PIN_SHARING_IRQ__REQUEST    0x1
+#define BM_LCDIF_PIN_SHARING_CTRL0_PIN_SHARING_ENABLE	0x00000001
+
+#define HW_LCDIF_PIN_SHARING_CTRL1	(0x00000190)
+
+#define BP_LCDIF_PIN_SHARING_CTRL1_THRESHOLD1	0
+#define BM_LCDIF_PIN_SHARING_CTRL1_THRESHOLD1	0xFFFFFFFF
+#define BF_LCDIF_PIN_SHARING_CTRL1_THRESHOLD1(v)	(v)
+
+#define HW_LCDIF_PIN_SHARING_CTRL2	(0x000001a0)
+
+#define BP_LCDIF_PIN_SHARING_CTRL2_THRESHOLD2	0
+#define BM_LCDIF_PIN_SHARING_CTRL2_THRESHOLD2	0xFFFFFFFF
+#define BF_LCDIF_PIN_SHARING_CTRL2_THRESHOLD2(v)	(v)
+
+#define HW_LCDIF_DATA	(0x000001b0)
+
+#define BP_LCDIF_DATA_DATA_THREE	24
+#define BM_LCDIF_DATA_DATA_THREE	0xFF000000
+#define BF_LCDIF_DATA_DATA_THREE(v) \
+		(((v) << 24) & BM_LCDIF_DATA_DATA_THREE)
+#define BP_LCDIF_DATA_DATA_TWO	16
+#define BM_LCDIF_DATA_DATA_TWO	0x00FF0000
+#define BF_LCDIF_DATA_DATA_TWO(v)  \
+		(((v) << 16) & BM_LCDIF_DATA_DATA_TWO)
+#define BP_LCDIF_DATA_DATA_ONE	8
+#define BM_LCDIF_DATA_DATA_ONE	0x0000FF00
+#define BF_LCDIF_DATA_DATA_ONE(v)  \
+		(((v) << 8) & BM_LCDIF_DATA_DATA_ONE)
+#define BP_LCDIF_DATA_DATA_ZERO	0
+#define BM_LCDIF_DATA_DATA_ZERO	0x000000FF
+#define BF_LCDIF_DATA_DATA_ZERO(v)  \
+		(((v) << 0) & BM_LCDIF_DATA_DATA_ZERO)
+
+#define HW_LCDIF_BM_ERROR_STAT	(0x000001c0)
+
+#define BP_LCDIF_BM_ERROR_STAT_ADDR	0
+#define BM_LCDIF_BM_ERROR_STAT_ADDR	0xFFFFFFFF
+#define BF_LCDIF_BM_ERROR_STAT_ADDR(v)	(v)
+
+#define HW_LCDIF_STAT	(0x000001d0)
+
+#define BM_LCDIF_STAT_PRESENT	0x80000000
+#define BM_LCDIF_STAT_DMA_REQ	0x40000000
+#define BM_LCDIF_STAT_LFIFO_FULL	0x20000000
+#define BM_LCDIF_STAT_LFIFO_EMPTY	0x10000000
+#define BM_LCDIF_STAT_TXFIFO_FULL	0x08000000
+#define BM_LCDIF_STAT_TXFIFO_EMPTY	0x04000000
+#define BM_LCDIF_STAT_BUSY	0x02000000
+#define BM_LCDIF_STAT_DVI_CURRENT_FIELD	0x01000000
+#define BP_LCDIF_STAT_RSRVD0	0
+#define BM_LCDIF_STAT_RSRVD0	0x00FFFFFF
+#define BF_LCDIF_STAT_RSRVD0(v)  \
+		(((v) << 0) & BM_LCDIF_STAT_RSRVD0)
+
+#define HW_LCDIF_VERSION	(0x000001e0)
+
+#define BP_LCDIF_VERSION_MAJOR	24
+#define BM_LCDIF_VERSION_MAJOR	0xFF000000
+#define BF_LCDIF_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_LCDIF_VERSION_MAJOR)
+#define BP_LCDIF_VERSION_MINOR	16
+#define BM_LCDIF_VERSION_MINOR	0x00FF0000
+#define BF_LCDIF_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_LCDIF_VERSION_MINOR)
+#define BP_LCDIF_VERSION_STEP	0
+#define BM_LCDIF_VERSION_STEP	0x0000FFFF
+#define BF_LCDIF_VERSION_STEP(v)  \
+		(((v) << 0) & BM_LCDIF_VERSION_STEP)
+
+#define HW_LCDIF_DEBUG0	(0x000001f0)
+
+#define BM_LCDIF_DEBUG0_STREAMING_END_DETECTED	0x80000000
+#define BM_LCDIF_DEBUG0_WAIT_FOR_VSYNC_EDGE_OUT	0x40000000
+#define BM_LCDIF_DEBUG0_SYNC_SIGNALS_ON_REG	0x20000000
+#define BM_LCDIF_DEBUG0_DMACMDKICK	0x10000000
+#define BM_LCDIF_DEBUG0_ENABLE	0x08000000
+#define BM_LCDIF_DEBUG0_HSYNC	0x04000000
+#define BM_LCDIF_DEBUG0_VSYNC	0x02000000
+#define BM_LCDIF_DEBUG0_CUR_FRAME_TX	0x01000000
+#define BM_LCDIF_DEBUG0_EMPTY_WORD	0x00800000
+#define BP_LCDIF_DEBUG0_CUR_STATE	16
+#define BM_LCDIF_DEBUG0_CUR_STATE	0x007F0000
+#define BF_LCDIF_DEBUG0_CUR_STATE(v)  \
+		(((v) << 16) & BM_LCDIF_DEBUG0_CUR_STATE)
+#define BM_LCDIF_DEBUG0_PXP_LCDIF_B0_READY	0x00008000
+#define BM_LCDIF_DEBUG0_LCDIF_PXP_B0_DONE	0x00004000
+#define BM_LCDIF_DEBUG0_PXP_LCDIF_B1_READY	0x00002000
+#define BM_LCDIF_DEBUG0_LCDIF_PXP_B1_DONE	0x00001000
+#define BM_LCDIF_DEBUG0_GPMI_LCDIF_REQ	0x00000800
+#define BM_LCDIF_DEBUG0_LCDIF_GPMI_GRANT	0x00000400
+#define BP_LCDIF_DEBUG0_RSRVD0	0
+#define BM_LCDIF_DEBUG0_RSRVD0	0x000003FF
+#define BF_LCDIF_DEBUG0_RSRVD0(v)  \
+		(((v) << 0) & BM_LCDIF_DEBUG0_RSRVD0)
+
+#define HW_LCDIF_DEBUG1	(0x00000200)
+
+#define BP_LCDIF_DEBUG1_H_DATA_COUNT	16
+#define BM_LCDIF_DEBUG1_H_DATA_COUNT	0xFFFF0000
+#define BF_LCDIF_DEBUG1_H_DATA_COUNT(v) \
+		(((v) << 16) & BM_LCDIF_DEBUG1_H_DATA_COUNT)
+#define BP_LCDIF_DEBUG1_V_DATA_COUNT	0
+#define BM_LCDIF_DEBUG1_V_DATA_COUNT	0x0000FFFF
+#define BF_LCDIF_DEBUG1_V_DATA_COUNT(v)  \
+		(((v) << 0) & BM_LCDIF_DEBUG1_V_DATA_COUNT)
+#endif /* __ARCH_ARM___LCDIF_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-lradc.h b/arch/arm/mach-mx23/include/mach/regs-lradc.h
new file mode 100644
index 0000000..77af4be
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-lradc.h
@@ -0,0 +1,669 @@
+/*
+ * Freescale LRADC Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.48
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___LRADC_H
+#define __ARCH_ARM___LRADC_H
+
+
+#define HW_LRADC_CTRL0	(0x00000000)
+#define HW_LRADC_CTRL0_SET	(0x00000004)
+#define HW_LRADC_CTRL0_CLR	(0x00000008)
+#define HW_LRADC_CTRL0_TOG	(0x0000000c)
+
+#define BM_LRADC_CTRL0_SFTRST	0x80000000
+#define BM_LRADC_CTRL0_CLKGATE	0x40000000
+#define BP_LRADC_CTRL0_RSRVD2	22
+#define BM_LRADC_CTRL0_RSRVD2	0x3FC00000
+#define BF_LRADC_CTRL0_RSRVD2(v)  \
+		(((v) << 22) & BM_LRADC_CTRL0_RSRVD2)
+#define BM_LRADC_CTRL0_ONCHIP_GROUNDREF	0x00200000
+#define BV_LRADC_CTRL0_ONCHIP_GROUNDREF__OFF 0x0
+#define BV_LRADC_CTRL0_ONCHIP_GROUNDREF__ON  0x1
+#define BM_LRADC_CTRL0_TOUCH_DETECT_ENABLE	0x00100000
+#define BV_LRADC_CTRL0_TOUCH_DETECT_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_TOUCH_DETECT_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_YMINUS_ENABLE	0x00080000
+#define BV_LRADC_CTRL0_YMINUS_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_YMINUS_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_XMINUS_ENABLE	0x00040000
+#define BV_LRADC_CTRL0_XMINUS_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_XMINUS_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_YPLUS_ENABLE	0x00020000
+#define BV_LRADC_CTRL0_YPLUS_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_YPLUS_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_XPLUS_ENABLE	0x00010000
+#define BV_LRADC_CTRL0_XPLUS_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_XPLUS_ENABLE__ON  0x1
+#define BP_LRADC_CTRL0_RSRVD1	8
+#define BM_LRADC_CTRL0_RSRVD1	0x0000FF00
+#define BF_LRADC_CTRL0_RSRVD1(v)  \
+		(((v) << 8) & BM_LRADC_CTRL0_RSRVD1)
+#define BP_LRADC_CTRL0_SCHEDULE	0
+#define BM_LRADC_CTRL0_SCHEDULE	0x000000FF
+#define BF_LRADC_CTRL0_SCHEDULE(v)  \
+		(((v) << 0) & BM_LRADC_CTRL0_SCHEDULE)
+
+#define HW_LRADC_CTRL1	(0x00000010)
+#define HW_LRADC_CTRL1_SET	(0x00000014)
+#define HW_LRADC_CTRL1_CLR	(0x00000018)
+#define HW_LRADC_CTRL1_TOG	(0x0000001c)
+
+#define BP_LRADC_CTRL1_RSRVD2	25
+#define BM_LRADC_CTRL1_RSRVD2	0xFE000000
+#define BF_LRADC_CTRL1_RSRVD2(v) \
+		(((v) << 25) & BM_LRADC_CTRL1_RSRVD2)
+#define BM_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN	0x01000000
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC7_IRQ_EN	0x00800000
+#define BV_LRADC_CTRL1_LRADC7_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC7_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC6_IRQ_EN	0x00400000
+#define BV_LRADC_CTRL1_LRADC6_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC6_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC5_IRQ_EN	0x00200000
+#define BV_LRADC_CTRL1_LRADC5_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC5_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC4_IRQ_EN	0x00100000
+#define BV_LRADC_CTRL1_LRADC4_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC4_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC3_IRQ_EN	0x00080000
+#define BV_LRADC_CTRL1_LRADC3_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC3_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC2_IRQ_EN	0x00040000
+#define BV_LRADC_CTRL1_LRADC2_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC2_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC1_IRQ_EN	0x00020000
+#define BV_LRADC_CTRL1_LRADC1_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC1_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC0_IRQ_EN	0x00010000
+#define BV_LRADC_CTRL1_LRADC0_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC0_IRQ_EN__ENABLE  0x1
+#define BP_LRADC_CTRL1_RSRVD1	9
+#define BM_LRADC_CTRL1_RSRVD1	0x0000FE00
+#define BF_LRADC_CTRL1_RSRVD1(v)  \
+		(((v) << 9) & BM_LRADC_CTRL1_RSRVD1)
+#define BM_LRADC_CTRL1_TOUCH_DETECT_IRQ	0x00000100
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC7_IRQ	0x00000080
+#define BV_LRADC_CTRL1_LRADC7_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC7_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC6_IRQ	0x00000040
+#define BV_LRADC_CTRL1_LRADC6_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC6_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC5_IRQ	0x00000020
+#define BV_LRADC_CTRL1_LRADC5_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC5_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC4_IRQ	0x00000010
+#define BV_LRADC_CTRL1_LRADC4_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC4_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC3_IRQ	0x00000008
+#define BV_LRADC_CTRL1_LRADC3_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC3_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC2_IRQ	0x00000004
+#define BV_LRADC_CTRL1_LRADC2_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC2_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC1_IRQ	0x00000002
+#define BV_LRADC_CTRL1_LRADC1_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC1_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC0_IRQ	0x00000001
+#define BV_LRADC_CTRL1_LRADC0_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC0_IRQ__PENDING 0x1
+
+#define HW_LRADC_CTRL2	(0x00000020)
+#define HW_LRADC_CTRL2_SET	(0x00000024)
+#define HW_LRADC_CTRL2_CLR	(0x00000028)
+#define HW_LRADC_CTRL2_TOG	(0x0000002c)
+
+#define BP_LRADC_CTRL2_DIVIDE_BY_TWO	24
+#define BM_LRADC_CTRL2_DIVIDE_BY_TWO	0xFF000000
+#define BF_LRADC_CTRL2_DIVIDE_BY_TWO(v) \
+		(((v) << 24) & BM_LRADC_CTRL2_DIVIDE_BY_TWO)
+#define BM_LRADC_CTRL2_BL_AMP_BYPASS	0x00800000
+#define BV_LRADC_CTRL2_BL_AMP_BYPASS__DISABLE 0x0
+#define BV_LRADC_CTRL2_BL_AMP_BYPASS__ENABLE  0x1
+#define BM_LRADC_CTRL2_BL_ENABLE	0x00400000
+#define BM_LRADC_CTRL2_BL_MUX_SELECT	0x00200000
+#define BP_LRADC_CTRL2_BL_BRIGHTNESS	16
+#define BM_LRADC_CTRL2_BL_BRIGHTNESS	0x001F0000
+#define BF_LRADC_CTRL2_BL_BRIGHTNESS(v)  \
+		(((v) << 16) & BM_LRADC_CTRL2_BL_BRIGHTNESS)
+#define BM_LRADC_CTRL2_TEMPSENSE_PWD	0x00008000
+#define BV_LRADC_CTRL2_TEMPSENSE_PWD__ENABLE  0x0
+#define BV_LRADC_CTRL2_TEMPSENSE_PWD__DISABLE 0x1
+#define BM_LRADC_CTRL2_RSRVD1	0x00004000
+#define BM_LRADC_CTRL2_EXT_EN1	0x00002000
+#define BV_LRADC_CTRL2_EXT_EN1__DISABLE 0x0
+#define BV_LRADC_CTRL2_EXT_EN1__ENABLE  0x1
+#define BM_LRADC_CTRL2_EXT_EN0	0x00001000
+#define BP_LRADC_CTRL2_RSRVD2	10
+#define BM_LRADC_CTRL2_RSRVD2	0x00000C00
+#define BF_LRADC_CTRL2_RSRVD2(v)  \
+		(((v) << 10) & BM_LRADC_CTRL2_RSRVD2)
+#define BM_LRADC_CTRL2_TEMP_SENSOR_IENABLE1	0x00000200
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE1__DISABLE 0x0
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE1__ENABLE  0x1
+#define BM_LRADC_CTRL2_TEMP_SENSOR_IENABLE0	0x00000100
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE0__DISABLE 0x0
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE0__ENABLE  0x1
+#define BP_LRADC_CTRL2_TEMP_ISRC1	4
+#define BM_LRADC_CTRL2_TEMP_ISRC1	0x000000F0
+#define BF_LRADC_CTRL2_TEMP_ISRC1(v)  \
+		(((v) << 4) & BM_LRADC_CTRL2_TEMP_ISRC1)
+#define BV_LRADC_CTRL2_TEMP_ISRC1__300  0xF
+#define BV_LRADC_CTRL2_TEMP_ISRC1__280  0xE
+#define BV_LRADC_CTRL2_TEMP_ISRC1__260  0xD
+#define BV_LRADC_CTRL2_TEMP_ISRC1__240  0xC
+#define BV_LRADC_CTRL2_TEMP_ISRC1__220  0xB
+#define BV_LRADC_CTRL2_TEMP_ISRC1__200  0xA
+#define BV_LRADC_CTRL2_TEMP_ISRC1__180  0x9
+#define BV_LRADC_CTRL2_TEMP_ISRC1__160  0x8
+#define BV_LRADC_CTRL2_TEMP_ISRC1__140  0x7
+#define BV_LRADC_CTRL2_TEMP_ISRC1__120  0x6
+#define BV_LRADC_CTRL2_TEMP_ISRC1__100  0x5
+#define BV_LRADC_CTRL2_TEMP_ISRC1__80   0x4
+#define BV_LRADC_CTRL2_TEMP_ISRC1__60   0x3
+#define BV_LRADC_CTRL2_TEMP_ISRC1__40   0x2
+#define BV_LRADC_CTRL2_TEMP_ISRC1__20   0x1
+#define BV_LRADC_CTRL2_TEMP_ISRC1__ZERO 0x0
+#define BP_LRADC_CTRL2_TEMP_ISRC0	0
+#define BM_LRADC_CTRL2_TEMP_ISRC0	0x0000000F
+#define BF_LRADC_CTRL2_TEMP_ISRC0(v)  \
+		(((v) << 0) & BM_LRADC_CTRL2_TEMP_ISRC0)
+#define BV_LRADC_CTRL2_TEMP_ISRC0__300  0xF
+#define BV_LRADC_CTRL2_TEMP_ISRC0__280  0xE
+#define BV_LRADC_CTRL2_TEMP_ISRC0__260  0xD
+#define BV_LRADC_CTRL2_TEMP_ISRC0__240  0xC
+#define BV_LRADC_CTRL2_TEMP_ISRC0__220  0xB
+#define BV_LRADC_CTRL2_TEMP_ISRC0__200  0xA
+#define BV_LRADC_CTRL2_TEMP_ISRC0__180  0x9
+#define BV_LRADC_CTRL2_TEMP_ISRC0__160  0x8
+#define BV_LRADC_CTRL2_TEMP_ISRC0__140  0x7
+#define BV_LRADC_CTRL2_TEMP_ISRC0__120  0x6
+#define BV_LRADC_CTRL2_TEMP_ISRC0__100  0x5
+#define BV_LRADC_CTRL2_TEMP_ISRC0__80   0x4
+#define BV_LRADC_CTRL2_TEMP_ISRC0__60   0x3
+#define BV_LRADC_CTRL2_TEMP_ISRC0__40   0x2
+#define BV_LRADC_CTRL2_TEMP_ISRC0__20   0x1
+#define BV_LRADC_CTRL2_TEMP_ISRC0__ZERO 0x0
+
+#define HW_LRADC_CTRL3	(0x00000030)
+#define HW_LRADC_CTRL3_SET	(0x00000034)
+#define HW_LRADC_CTRL3_CLR	(0x00000038)
+#define HW_LRADC_CTRL3_TOG	(0x0000003c)
+
+#define BP_LRADC_CTRL3_RSRVD5	26
+#define BM_LRADC_CTRL3_RSRVD5	0xFC000000
+#define BF_LRADC_CTRL3_RSRVD5(v) \
+		(((v) << 26) & BM_LRADC_CTRL3_RSRVD5)
+#define BP_LRADC_CTRL3_DISCARD	24
+#define BM_LRADC_CTRL3_DISCARD	0x03000000
+#define BF_LRADC_CTRL3_DISCARD(v)  \
+		(((v) << 24) & BM_LRADC_CTRL3_DISCARD)
+#define BV_LRADC_CTRL3_DISCARD__1_SAMPLE  0x1
+#define BV_LRADC_CTRL3_DISCARD__2_SAMPLES 0x2
+#define BV_LRADC_CTRL3_DISCARD__3_SAMPLES 0x3
+#define BM_LRADC_CTRL3_FORCE_ANALOG_PWUP	0x00800000
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWUP__OFF 0x0
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWUP__ON  0x1
+#define BM_LRADC_CTRL3_FORCE_ANALOG_PWDN	0x00400000
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWDN__ON  0x0
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWDN__OFF 0x1
+#define BP_LRADC_CTRL3_RSRVD4	14
+#define BM_LRADC_CTRL3_RSRVD4	0x003FC000
+#define BF_LRADC_CTRL3_RSRVD4(v)  \
+		(((v) << 14) & BM_LRADC_CTRL3_RSRVD4)
+#define BP_LRADC_CTRL3_RSRVD3	10
+#define BM_LRADC_CTRL3_RSRVD3	0x00003C00
+#define BF_LRADC_CTRL3_RSRVD3(v)  \
+		(((v) << 10) & BM_LRADC_CTRL3_RSRVD3)
+#define BP_LRADC_CTRL3_CYCLE_TIME	8
+#define BM_LRADC_CTRL3_CYCLE_TIME	0x00000300
+#define BF_LRADC_CTRL3_CYCLE_TIME(v)  \
+		(((v) << 8) & BM_LRADC_CTRL3_CYCLE_TIME)
+#define BV_LRADC_CTRL3_CYCLE_TIME__6MHZ 0x0
+#define BV_LRADC_CTRL3_CYCLE_TIME__4MHZ 0x1
+#define BV_LRADC_CTRL3_CYCLE_TIME__3MHZ 0x2
+#define BV_LRADC_CTRL3_CYCLE_TIME__2MHZ 0x3
+#define BP_LRADC_CTRL3_RSRVD2	6
+#define BM_LRADC_CTRL3_RSRVD2	0x000000C0
+#define BF_LRADC_CTRL3_RSRVD2(v)  \
+		(((v) << 6) & BM_LRADC_CTRL3_RSRVD2)
+#define BP_LRADC_CTRL3_HIGH_TIME	4
+#define BM_LRADC_CTRL3_HIGH_TIME	0x00000030
+#define BF_LRADC_CTRL3_HIGH_TIME(v)  \
+		(((v) << 4) & BM_LRADC_CTRL3_HIGH_TIME)
+#define BV_LRADC_CTRL3_HIGH_TIME__42NS  0x0
+#define BV_LRADC_CTRL3_HIGH_TIME__83NS  0x1
+#define BV_LRADC_CTRL3_HIGH_TIME__125NS 0x2
+#define BV_LRADC_CTRL3_HIGH_TIME__250NS 0x3
+#define BP_LRADC_CTRL3_RSRVD1	2
+#define BM_LRADC_CTRL3_RSRVD1	0x0000000C
+#define BF_LRADC_CTRL3_RSRVD1(v)  \
+		(((v) << 2) & BM_LRADC_CTRL3_RSRVD1)
+#define BM_LRADC_CTRL3_DELAY_CLOCK	0x00000002
+#define BV_LRADC_CTRL3_DELAY_CLOCK__NORMAL  0x0
+#define BV_LRADC_CTRL3_DELAY_CLOCK__DELAYED 0x1
+#define BM_LRADC_CTRL3_INVERT_CLOCK	0x00000001
+#define BV_LRADC_CTRL3_INVERT_CLOCK__NORMAL 0x0
+#define BV_LRADC_CTRL3_INVERT_CLOCK__INVERT 0x1
+
+#define HW_LRADC_STATUS	(0x00000040)
+#define HW_LRADC_STATUS_SET	(0x00000044)
+#define HW_LRADC_STATUS_CLR	(0x00000048)
+#define HW_LRADC_STATUS_TOG	(0x0000004c)
+
+#define BP_LRADC_STATUS_RSRVD3	27
+#define BM_LRADC_STATUS_RSRVD3	0xF8000000
+#define BF_LRADC_STATUS_RSRVD3(v) \
+		(((v) << 27) & BM_LRADC_STATUS_RSRVD3)
+#define BM_LRADC_STATUS_TEMP1_PRESENT	0x04000000
+#define BM_LRADC_STATUS_TEMP0_PRESENT	0x02000000
+#define BM_LRADC_STATUS_TOUCH_PANEL_PRESENT	0x01000000
+#define BM_LRADC_STATUS_CHANNEL7_PRESENT	0x00800000
+#define BM_LRADC_STATUS_CHANNEL6_PRESENT	0x00400000
+#define BM_LRADC_STATUS_CHANNEL5_PRESENT	0x00200000
+#define BM_LRADC_STATUS_CHANNEL4_PRESENT	0x00100000
+#define BM_LRADC_STATUS_CHANNEL3_PRESENT	0x00080000
+#define BM_LRADC_STATUS_CHANNEL2_PRESENT	0x00040000
+#define BM_LRADC_STATUS_CHANNEL1_PRESENT	0x00020000
+#define BM_LRADC_STATUS_CHANNEL0_PRESENT	0x00010000
+#define BP_LRADC_STATUS_RSRVD2	1
+#define BM_LRADC_STATUS_RSRVD2	0x0000FFFE
+#define BF_LRADC_STATUS_RSRVD2(v)  \
+		(((v) << 1) & BM_LRADC_STATUS_RSRVD2)
+#define BM_LRADC_STATUS_TOUCH_DETECT_RAW	0x00000001
+#define BV_LRADC_STATUS_TOUCH_DETECT_RAW__OPEN 0x0
+#define BV_LRADC_STATUS_TOUCH_DETECT_RAW__HIT  0x1
+
+/*
+ *  multi-register-define name HW_LRADC_CHn
+ *              base 0x00000050
+ *              count 6
+ *              offset 0x10
+ */
+#define HW_LRADC_CHn(n)	(0x00000050 + (n) * 0x10)
+#define HW_LRADC_CHn_SET(n)	(0x00000054 + (n) * 0x10)
+#define HW_LRADC_CHn_CLR(n)	(0x00000058 + (n) * 0x10)
+#define HW_LRADC_CHn_TOG(n)	(0x0000005c + (n) * 0x10)
+#define BM_LRADC_CHn_TOGGLE	0x80000000
+#define BM_LRADC_CHn_RSRVD2	0x40000000
+#define BM_LRADC_CHn_ACCUMULATE	0x20000000
+#define BP_LRADC_CHn_NUM_SAMPLES	24
+#define BM_LRADC_CHn_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CHn_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CHn_NUM_SAMPLES)
+#define BP_LRADC_CHn_RSRVD1	18
+#define BM_LRADC_CHn_RSRVD1	0x00FC0000
+#define BF_LRADC_CHn_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CHn_RSRVD1)
+#define BP_LRADC_CHn_VALUE	0
+#define BM_LRADC_CHn_VALUE	0x0003FFFF
+#define BF_LRADC_CHn_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CHn_VALUE)
+
+#define HW_LRADC_CH6	(0x000000b0)
+#define HW_LRADC_CH6_SET	(0x000000b4)
+#define HW_LRADC_CH6_CLR	(0x000000b8)
+#define HW_LRADC_CH6_TOG	(0x000000bc)
+
+#define BM_LRADC_CH6_TOGGLE	0x80000000
+#define BM_LRADC_CH6_RSRVD2	0x40000000
+#define BM_LRADC_CH6_ACCUMULATE	0x20000000
+#define BP_LRADC_CH6_NUM_SAMPLES	24
+#define BM_LRADC_CH6_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CH6_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CH6_NUM_SAMPLES)
+#define BP_LRADC_CH6_RSRVD1	18
+#define BM_LRADC_CH6_RSRVD1	0x00FC0000
+#define BF_LRADC_CH6_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CH6_RSRVD1)
+#define BP_LRADC_CH6_VALUE	0
+#define BM_LRADC_CH6_VALUE	0x0003FFFF
+#define BF_LRADC_CH6_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CH6_VALUE)
+
+#define HW_LRADC_CH7	(0x000000c0)
+#define HW_LRADC_CH7_SET	(0x000000c4)
+#define HW_LRADC_CH7_CLR	(0x000000c8)
+#define HW_LRADC_CH7_TOG	(0x000000cc)
+
+#define BM_LRADC_CH7_TOGGLE	0x80000000
+#define BM_LRADC_CH7_TESTMODE_TOGGLE	0x40000000
+#define BM_LRADC_CH7_ACCUMULATE	0x20000000
+#define BP_LRADC_CH7_NUM_SAMPLES	24
+#define BM_LRADC_CH7_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CH7_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CH7_NUM_SAMPLES)
+#define BP_LRADC_CH7_RSRVD1	18
+#define BM_LRADC_CH7_RSRVD1	0x00FC0000
+#define BF_LRADC_CH7_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CH7_RSRVD1)
+#define BP_LRADC_CH7_VALUE	0
+#define BM_LRADC_CH7_VALUE	0x0003FFFF
+#define BF_LRADC_CH7_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CH7_VALUE)
+
+/*
+ *  multi-register-define name HW_LRADC_DELAYn
+ *              base 0x000000D0
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_LRADC_DELAYn(n)	(0x000000d0 + (n) * 0x10)
+#define HW_LRADC_DELAYn_SET(n)	(0x000000d4 + (n) * 0x10)
+#define HW_LRADC_DELAYn_CLR(n)	(0x000000d8 + (n) * 0x10)
+#define HW_LRADC_DELAYn_TOG(n)	(0x000000dc + (n) * 0x10)
+#define BP_LRADC_DELAYn_TRIGGER_LRADCS	24
+#define BM_LRADC_DELAYn_TRIGGER_LRADCS	0xFF000000
+#define BF_LRADC_DELAYn_TRIGGER_LRADCS(v) \
+		(((v) << 24) & BM_LRADC_DELAYn_TRIGGER_LRADCS)
+#define BP_LRADC_DELAYn_RSRVD2	21
+#define BM_LRADC_DELAYn_RSRVD2	0x00E00000
+#define BF_LRADC_DELAYn_RSRVD2(v)  \
+		(((v) << 21) & BM_LRADC_DELAYn_RSRVD2)
+#define BM_LRADC_DELAYn_KICK	0x00100000
+#define BP_LRADC_DELAYn_TRIGGER_DELAYS	16
+#define BM_LRADC_DELAYn_TRIGGER_DELAYS	0x000F0000
+#define BF_LRADC_DELAYn_TRIGGER_DELAYS(v)  \
+		(((v) << 16) & BM_LRADC_DELAYn_TRIGGER_DELAYS)
+#define BP_LRADC_DELAYn_LOOP_COUNT	11
+#define BM_LRADC_DELAYn_LOOP_COUNT	0x0000F800
+#define BF_LRADC_DELAYn_LOOP_COUNT(v)  \
+		(((v) << 11) & BM_LRADC_DELAYn_LOOP_COUNT)
+#define BP_LRADC_DELAYn_DELAY	0
+#define BM_LRADC_DELAYn_DELAY	0x000007FF
+#define BF_LRADC_DELAYn_DELAY(v)  \
+		(((v) << 0) & BM_LRADC_DELAYn_DELAY)
+
+#define HW_LRADC_DEBUG0	(0x00000110)
+#define HW_LRADC_DEBUG0_SET	(0x00000114)
+#define HW_LRADC_DEBUG0_CLR	(0x00000118)
+#define HW_LRADC_DEBUG0_TOG	(0x0000011c)
+
+#define BP_LRADC_DEBUG0_READONLY	16
+#define BM_LRADC_DEBUG0_READONLY	0xFFFF0000
+#define BF_LRADC_DEBUG0_READONLY(v) \
+		(((v) << 16) & BM_LRADC_DEBUG0_READONLY)
+#define BP_LRADC_DEBUG0_RSRVD1	12
+#define BM_LRADC_DEBUG0_RSRVD1	0x0000F000
+#define BF_LRADC_DEBUG0_RSRVD1(v)  \
+		(((v) << 12) & BM_LRADC_DEBUG0_RSRVD1)
+#define BP_LRADC_DEBUG0_STATE	0
+#define BM_LRADC_DEBUG0_STATE	0x00000FFF
+#define BF_LRADC_DEBUG0_STATE(v)  \
+		(((v) << 0) & BM_LRADC_DEBUG0_STATE)
+
+#define HW_LRADC_DEBUG1	(0x00000120)
+#define HW_LRADC_DEBUG1_SET	(0x00000124)
+#define HW_LRADC_DEBUG1_CLR	(0x00000128)
+#define HW_LRADC_DEBUG1_TOG	(0x0000012c)
+
+#define BP_LRADC_DEBUG1_RSRVD3	24
+#define BM_LRADC_DEBUG1_RSRVD3	0xFF000000
+#define BF_LRADC_DEBUG1_RSRVD3(v) \
+		(((v) << 24) & BM_LRADC_DEBUG1_RSRVD3)
+#define BP_LRADC_DEBUG1_REQUEST	16
+#define BM_LRADC_DEBUG1_REQUEST	0x00FF0000
+#define BF_LRADC_DEBUG1_REQUEST(v)  \
+		(((v) << 16) & BM_LRADC_DEBUG1_REQUEST)
+#define BP_LRADC_DEBUG1_RSRVD2	13
+#define BM_LRADC_DEBUG1_RSRVD2	0x0000E000
+#define BF_LRADC_DEBUG1_RSRVD2(v)  \
+		(((v) << 13) & BM_LRADC_DEBUG1_RSRVD2)
+#define BP_LRADC_DEBUG1_TESTMODE_COUNT	8
+#define BM_LRADC_DEBUG1_TESTMODE_COUNT	0x00001F00
+#define BF_LRADC_DEBUG1_TESTMODE_COUNT(v)  \
+		(((v) << 8) & BM_LRADC_DEBUG1_TESTMODE_COUNT)
+#define BP_LRADC_DEBUG1_RSRVD1	3
+#define BM_LRADC_DEBUG1_RSRVD1	0x000000F8
+#define BF_LRADC_DEBUG1_RSRVD1(v)  \
+		(((v) << 3) & BM_LRADC_DEBUG1_RSRVD1)
+#define BM_LRADC_DEBUG1_TESTMODE6	0x00000004
+#define BV_LRADC_DEBUG1_TESTMODE6__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE6__TEST   0x1
+#define BM_LRADC_DEBUG1_TESTMODE5	0x00000002
+#define BV_LRADC_DEBUG1_TESTMODE5__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE5__TEST   0x1
+#define BM_LRADC_DEBUG1_TESTMODE	0x00000001
+#define BV_LRADC_DEBUG1_TESTMODE__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE__TEST   0x1
+
+#define HW_LRADC_CONVERSION	(0x00000130)
+#define HW_LRADC_CONVERSION_SET	(0x00000134)
+#define HW_LRADC_CONVERSION_CLR	(0x00000138)
+#define HW_LRADC_CONVERSION_TOG	(0x0000013c)
+
+#define BP_LRADC_CONVERSION_RSRVD3	21
+#define BM_LRADC_CONVERSION_RSRVD3	0xFFE00000
+#define BF_LRADC_CONVERSION_RSRVD3(v) \
+		(((v) << 21) & BM_LRADC_CONVERSION_RSRVD3)
+#define BM_LRADC_CONVERSION_AUTOMATIC	0x00100000
+#define BV_LRADC_CONVERSION_AUTOMATIC__DISABLE 0x0
+#define BV_LRADC_CONVERSION_AUTOMATIC__ENABLE  0x1
+#define BP_LRADC_CONVERSION_RSRVD2	18
+#define BM_LRADC_CONVERSION_RSRVD2	0x000C0000
+#define BF_LRADC_CONVERSION_RSRVD2(v)  \
+		(((v) << 18) & BM_LRADC_CONVERSION_RSRVD2)
+#define BP_LRADC_CONVERSION_SCALE_FACTOR	16
+#define BM_LRADC_CONVERSION_SCALE_FACTOR	0x00030000
+#define BF_LRADC_CONVERSION_SCALE_FACTOR(v)  \
+		(((v) << 16) & BM_LRADC_CONVERSION_SCALE_FACTOR)
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__NIMH       0x0
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__DUAL_NIMH  0x1
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__LI_ION     0x2
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__ALT_LI_ION 0x3
+#define BP_LRADC_CONVERSION_RSRVD1	10
+#define BM_LRADC_CONVERSION_RSRVD1	0x0000FC00
+#define BF_LRADC_CONVERSION_RSRVD1(v)  \
+		(((v) << 10) & BM_LRADC_CONVERSION_RSRVD1)
+#define BP_LRADC_CONVERSION_SCALED_BATT_VOLTAGE	0
+#define BM_LRADC_CONVERSION_SCALED_BATT_VOLTAGE	0x000003FF
+#define BF_LRADC_CONVERSION_SCALED_BATT_VOLTAGE(v)  \
+		(((v) << 0) & BM_LRADC_CONVERSION_SCALED_BATT_VOLTAGE)
+
+#define HW_LRADC_CTRL4	(0x00000140)
+#define HW_LRADC_CTRL4_SET	(0x00000144)
+#define HW_LRADC_CTRL4_CLR	(0x00000148)
+#define HW_LRADC_CTRL4_TOG	(0x0000014c)
+
+#define BP_LRADC_CTRL4_LRADC7SELECT	28
+#define BM_LRADC_CTRL4_LRADC7SELECT	0xF0000000
+#define BF_LRADC_CTRL4_LRADC7SELECT(v) \
+		(((v) << 28) & BM_LRADC_CTRL4_LRADC7SELECT)
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC6SELECT	24
+#define BM_LRADC_CTRL4_LRADC6SELECT	0x0F000000
+#define BF_LRADC_CTRL4_LRADC6SELECT(v)  \
+		(((v) << 24) & BM_LRADC_CTRL4_LRADC6SELECT)
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC5SELECT	20
+#define BM_LRADC_CTRL4_LRADC5SELECT	0x00F00000
+#define BF_LRADC_CTRL4_LRADC5SELECT(v)  \
+		(((v) << 20) & BM_LRADC_CTRL4_LRADC5SELECT)
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC4SELECT	16
+#define BM_LRADC_CTRL4_LRADC4SELECT	0x000F0000
+#define BF_LRADC_CTRL4_LRADC4SELECT(v)  \
+		(((v) << 16) & BM_LRADC_CTRL4_LRADC4SELECT)
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC3SELECT	12
+#define BM_LRADC_CTRL4_LRADC3SELECT	0x0000F000
+#define BF_LRADC_CTRL4_LRADC3SELECT(v)  \
+		(((v) << 12) & BM_LRADC_CTRL4_LRADC3SELECT)
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC2SELECT	8
+#define BM_LRADC_CTRL4_LRADC2SELECT	0x00000F00
+#define BF_LRADC_CTRL4_LRADC2SELECT(v)  \
+		(((v) << 8) & BM_LRADC_CTRL4_LRADC2SELECT)
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC1SELECT	4
+#define BM_LRADC_CTRL4_LRADC1SELECT	0x000000F0
+#define BF_LRADC_CTRL4_LRADC1SELECT(v)  \
+		(((v) << 4) & BM_LRADC_CTRL4_LRADC1SELECT)
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC0SELECT	0
+#define BM_LRADC_CTRL4_LRADC0SELECT	0x0000000F
+#define BF_LRADC_CTRL4_LRADC0SELECT(v)  \
+		(((v) << 0) & BM_LRADC_CTRL4_LRADC0SELECT)
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL15 0xF
+
+#define HW_LRADC_VERSION	(0x00000150)
+
+#define BP_LRADC_VERSION_MAJOR	24
+#define BM_LRADC_VERSION_MAJOR	0xFF000000
+#define BF_LRADC_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_LRADC_VERSION_MAJOR)
+#define BP_LRADC_VERSION_MINOR	16
+#define BM_LRADC_VERSION_MINOR	0x00FF0000
+#define BF_LRADC_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_LRADC_VERSION_MINOR)
+#define BP_LRADC_VERSION_STEP	0
+#define BM_LRADC_VERSION_STEP	0x0000FFFF
+#define BF_LRADC_VERSION_STEP(v)  \
+		(((v) << 0) & BM_LRADC_VERSION_STEP)
+#endif /* __ARCH_ARM___LRADC_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-ocotp.h b/arch/arm/mach-mx23/include/mach/regs-ocotp.h
new file mode 100644
index 0000000..b0313dd
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-ocotp.h
@@ -0,0 +1,311 @@
+/*
+ * Freescale OCOTP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.21
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___OCOTP_H
+#define __ARCH_ARM___OCOTP_H
+
+
+#define HW_OCOTP_CTRL	(0x00000000)
+#define HW_OCOTP_CTRL_SET	(0x00000004)
+#define HW_OCOTP_CTRL_CLR	(0x00000008)
+#define HW_OCOTP_CTRL_TOG	(0x0000000c)
+
+#define BP_OCOTP_CTRL_WR_UNLOCK	16
+#define BM_OCOTP_CTRL_WR_UNLOCK	0xFFFF0000
+#define BF_OCOTP_CTRL_WR_UNLOCK(v) \
+		(((v) << 16) & BM_OCOTP_CTRL_WR_UNLOCK)
+#define BV_OCOTP_CTRL_WR_UNLOCK__KEY 0x3E77
+#define BP_OCOTP_CTRL_RSRVD2	14
+#define BM_OCOTP_CTRL_RSRVD2	0x0000C000
+#define BF_OCOTP_CTRL_RSRVD2(v)  \
+		(((v) << 14) & BM_OCOTP_CTRL_RSRVD2)
+#define BM_OCOTP_CTRL_RELOAD_SHADOWS	0x00002000
+#define BM_OCOTP_CTRL_RD_BANK_OPEN	0x00001000
+#define BP_OCOTP_CTRL_RSRVD1	10
+#define BM_OCOTP_CTRL_RSRVD1	0x00000C00
+#define BF_OCOTP_CTRL_RSRVD1(v)  \
+		(((v) << 10) & BM_OCOTP_CTRL_RSRVD1)
+#define BM_OCOTP_CTRL_ERROR	0x00000200
+#define BM_OCOTP_CTRL_BUSY	0x00000100
+#define BP_OCOTP_CTRL_RSRVD0	5
+#define BM_OCOTP_CTRL_RSRVD0	0x000000E0
+#define BF_OCOTP_CTRL_RSRVD0(v)  \
+		(((v) << 5) & BM_OCOTP_CTRL_RSRVD0)
+#define BP_OCOTP_CTRL_ADDR	0
+#define BM_OCOTP_CTRL_ADDR	0x0000001F
+#define BF_OCOTP_CTRL_ADDR(v)  \
+		(((v) << 0) & BM_OCOTP_CTRL_ADDR)
+
+#define HW_OCOTP_DATA	(0x00000010)
+
+#define BP_OCOTP_DATA_DATA	0
+#define BM_OCOTP_DATA_DATA	0xFFFFFFFF
+#define BF_OCOTP_DATA_DATA(v)	(v)
+
+/*
+ *  multi-register-define name HW_OCOTP_CUSTn
+ *              base 0x00000020
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_OCOTP_CUSTn(n)	(0x00000020 + (n) * 0x10)
+#define BP_OCOTP_CUSTn_BITS	0
+#define BM_OCOTP_CUSTn_BITS	0xFFFFFFFF
+#define BF_OCOTP_CUSTn_BITS(v)	(v)
+
+/*
+ *  multi-register-define name HW_OCOTP_CRYPTOn
+ *              base 0x00000060
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_OCOTP_CRYPTOn(n)	(0x00000060 + (n) * 0x10)
+#define BP_OCOTP_CRYPTOn_BITS	0
+#define BM_OCOTP_CRYPTOn_BITS	0xFFFFFFFF
+#define BF_OCOTP_CRYPTOn_BITS(v)	(v)
+
+/*
+ *  multi-register-define name HW_OCOTP_HWCAPn
+ *              base 0x000000A0
+ *              count 6
+ *              offset 0x10
+ */
+#define HW_OCOTP_HWCAPn(n)	(0x000000a0 + (n) * 0x10)
+#define BP_OCOTP_HWCAPn_BITS	0
+#define BM_OCOTP_HWCAPn_BITS	0xFFFFFFFF
+#define BF_OCOTP_HWCAPn_BITS(v)	(v)
+
+#define HW_OCOTP_SWCAP	(0x00000100)
+
+#define BP_OCOTP_SWCAP_BITS	0
+#define BM_OCOTP_SWCAP_BITS	0xFFFFFFFF
+#define BF_OCOTP_SWCAP_BITS(v)	(v)
+
+#define HW_OCOTP_CUSTCAP	(0x00000110)
+
+#define BM_OCOTP_CUSTCAP_CUST_DISABLE_WMADRM9	0x80000000
+#define BM_OCOTP_CUSTCAP_CUST_DISABLE_JANUSDRM10	0x40000000
+#define BP_OCOTP_CUSTCAP_RSRVD1	5
+#define BM_OCOTP_CUSTCAP_RSRVD1	0x3FFFFFE0
+#define BF_OCOTP_CUSTCAP_RSRVD1(v)  \
+		(((v) << 5) & BM_OCOTP_CUSTCAP_RSRVD1)
+#define BM_OCOTP_CUSTCAP_ENABLE_SJTAG_12MA_DRIVE	0x00000010
+#define BM_OCOTP_CUSTCAP_USE_PARALLEL_JTAG	0x00000008
+#define BM_OCOTP_CUSTCAP_RTC_XTAL_32768_PRESENT	0x00000004
+#define BM_OCOTP_CUSTCAP_RTC_XTAL_32000_PRESENT	0x00000002
+#define BM_OCOTP_CUSTCAP_RSRVD0	0x00000001
+
+#define HW_OCOTP_LOCK	(0x00000120)
+
+#define BM_OCOTP_LOCK_ROM7	0x80000000
+#define BM_OCOTP_LOCK_ROM6	0x40000000
+#define BM_OCOTP_LOCK_ROM5	0x20000000
+#define BM_OCOTP_LOCK_ROM4	0x10000000
+#define BM_OCOTP_LOCK_ROM3	0x08000000
+#define BM_OCOTP_LOCK_ROM2	0x04000000
+#define BM_OCOTP_LOCK_ROM1	0x02000000
+#define BM_OCOTP_LOCK_ROM0	0x01000000
+#define BM_OCOTP_LOCK_HWSW_SHADOW_ALT	0x00800000
+#define BM_OCOTP_LOCK_CRYPTODCP_ALT	0x00400000
+#define BM_OCOTP_LOCK_CRYPTOKEY_ALT	0x00200000
+#define BM_OCOTP_LOCK_PIN	0x00100000
+#define BM_OCOTP_LOCK_OPS	0x00080000
+#define BM_OCOTP_LOCK_UN2	0x00040000
+#define BM_OCOTP_LOCK_UN1	0x00020000
+#define BM_OCOTP_LOCK_UN0	0x00010000
+#define BP_OCOTP_LOCK_UNALLOCATED	11
+#define BM_OCOTP_LOCK_UNALLOCATED	0x0000F800
+#define BF_OCOTP_LOCK_UNALLOCATED(v)  \
+		(((v) << 11) & BM_OCOTP_LOCK_UNALLOCATED)
+#define BM_OCOTP_LOCK_ROM_SHADOW	0x00000400
+#define BM_OCOTP_LOCK_CUSTCAP	0x00000200
+#define BM_OCOTP_LOCK_HWSW	0x00000100
+#define BM_OCOTP_LOCK_CUSTCAP_SHADOW	0x00000080
+#define BM_OCOTP_LOCK_HWSW_SHADOW	0x00000040
+#define BM_OCOTP_LOCK_CRYPTODCP	0x00000020
+#define BM_OCOTP_LOCK_CRYPTOKEY	0x00000010
+#define BM_OCOTP_LOCK_CUST3	0x00000008
+#define BM_OCOTP_LOCK_CUST2	0x00000004
+#define BM_OCOTP_LOCK_CUST1	0x00000002
+#define BM_OCOTP_LOCK_CUST0	0x00000001
+
+/*
+ *  multi-register-define name HW_OCOTP_OPSn
+ *              base 0x00000130
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_OCOTP_OPSn(n)	(0x00000130 + (n) * 0x10)
+#define BP_OCOTP_OPSn_BITS	0
+#define BM_OCOTP_OPSn_BITS	0xFFFFFFFF
+#define BF_OCOTP_OPSn_BITS(v)	(v)
+
+/*
+ *  multi-register-define name HW_OCOTP_UNn
+ *              base 0x00000170
+ *              count 3
+ *              offset 0x10
+ */
+#define HW_OCOTP_UNn(n)	(0x00000170 + (n) * 0x10)
+#define BP_OCOTP_UNn_BITS	0
+#define BM_OCOTP_UNn_BITS	0xFFFFFFFF
+#define BF_OCOTP_UNn_BITS(v)	(v)
+
+#define HW_OCOTP_ROM0	(0x000001a0)
+
+#define BP_OCOTP_ROM0_BOOT_MODE	24
+#define BM_OCOTP_ROM0_BOOT_MODE	0xFF000000
+#define BF_OCOTP_ROM0_BOOT_MODE(v) \
+		(((v) << 24) & BM_OCOTP_ROM0_BOOT_MODE)
+#define BM_OCOTP_ROM0_ENABLE_PJTAG_12MA_DRIVE	0x00800000
+#define BM_OCOTP_ROM0_USE_PARALLEL_JTAG	0x00400000
+#define BP_OCOTP_ROM0_SD_POWER_GATE_GPIO	20
+#define BM_OCOTP_ROM0_SD_POWER_GATE_GPIO	0x00300000
+#define BF_OCOTP_ROM0_SD_POWER_GATE_GPIO(v)  \
+		(((v) << 20) & BM_OCOTP_ROM0_SD_POWER_GATE_GPIO)
+#define BP_OCOTP_ROM0_SD_POWER_UP_DELAY	14
+#define BM_OCOTP_ROM0_SD_POWER_UP_DELAY	0x000FC000
+#define BF_OCOTP_ROM0_SD_POWER_UP_DELAY(v)  \
+		(((v) << 14) & BM_OCOTP_ROM0_SD_POWER_UP_DELAY)
+#define BP_OCOTP_ROM0_SD_BUS_WIDTH	12
+#define BM_OCOTP_ROM0_SD_BUS_WIDTH	0x00003000
+#define BF_OCOTP_ROM0_SD_BUS_WIDTH(v)  \
+		(((v) << 12) & BM_OCOTP_ROM0_SD_BUS_WIDTH)
+#define BP_OCOTP_ROM0_SSP_SCK_INDEX	8
+#define BM_OCOTP_ROM0_SSP_SCK_INDEX	0x00000F00
+#define BF_OCOTP_ROM0_SSP_SCK_INDEX(v)  \
+		(((v) << 8) & BM_OCOTP_ROM0_SSP_SCK_INDEX)
+#define BM_OCOTP_ROM0_RSRVD3	0x00000080
+#define BM_OCOTP_ROM0_DISABLE_SPI_NOR_FAST_ READ	0x00000040
+#define BM_OCOTP_ROM0_ENABLE_USB_BOOT_SERIAL_NUM	0x00000020
+#define BM_OCOTP_ROM0_ENABLE_UNENCRYPTED_ BOOT	0x00000010
+#define BM_OCOTP_ROM0_SD_MBR_BOOT	0x00000008
+#define BM_OCOTP_ROM0_RSRVD2	0x00000004
+#define BM_OCOTP_ROM0_RSRVD1	0x00000002
+#define BM_OCOTP_ROM0_RSRVD0	0x00000001
+
+#define HW_OCOTP_ROM1	(0x000001b0)
+
+#define BP_OCOTP_ROM1_RSRVD1	30
+#define BM_OCOTP_ROM1_RSRVD1	0xC0000000
+#define BF_OCOTP_ROM1_RSRVD1(v) \
+		(((v) << 30) & BM_OCOTP_ROM1_RSRVD1)
+#define BP_OCOTP_ROM1_USE_ALT_GPMI_RDY3	28
+#define BM_OCOTP_ROM1_USE_ALT_GPMI_RDY3	0x30000000
+#define BF_OCOTP_ROM1_USE_ALT_GPMI_RDY3(v)  \
+		(((v) << 28) & BM_OCOTP_ROM1_USE_ALT_GPMI_RDY3)
+#define BP_OCOTP_ROM1_USE_ALT_GPMI_CE3	26
+#define BM_OCOTP_ROM1_USE_ALT_GPMI_CE3	0x0C000000
+#define BF_OCOTP_ROM1_USE_ALT_GPMI_CE3(v)  \
+		(((v) << 26) & BM_OCOTP_ROM1_USE_ALT_GPMI_CE3)
+#define BM_OCOTP_ROM1_USE_ALT_GPMI_RDY2	0x02000000
+#define BM_OCOTP_ROM1_USE_ALT_GPMI_CE2	0x01000000
+#define BM_OCOTP_ROM1_ENABLE_NAND3_CE_RDY_PULLUP	0x00800000
+#define BM_OCOTP_ROM1_ENABLE_NAND2_CE_RDY_PULLUP	0x00400000
+#define BM_OCOTP_ROM1_ENABLE_NAND1_CE_RDY_PULLUP	0x00200000
+#define BM_OCOTP_ROM1_ENABLE_NAND0_CE_RDY_PULLUP	0x00100000
+#define BM_OCOTP_ROM1_UNTOUCH_INTERNAL_SSP_PULLUP	0x00080000
+#define BM_OCOTP_ROM1_SSP2_EXT_PULLUP	0x00040000
+#define BM_OCOTP_ROM1_SSP1_EXT_PULLUP	0x00020000
+#define BM_OCOTP_ROM1_SD_INCREASE_INIT_SEQ_TIME	0x00010000
+#define BM_OCOTP_ROM1_SD_INIT_SEQ_2_ENABLE	0x00008000
+#define BM_OCOTP_ROM1_SD_CMD0_DISABLE	0x00004000
+#define BM_OCOTP_ROM1_SD_INIT_SEQ_1_DISABLE	0x00002000
+#define BM_OCOTP_ROM1_USE_ALT_SSP1_DATA4_7	0x00001000
+#define BP_OCOTP_ROM1_BOOT_SEARCH_COUNT	8
+#define BM_OCOTP_ROM1_BOOT_SEARCH_COUNT	0x00000F00
+#define BF_OCOTP_ROM1_BOOT_SEARCH_COUNT(v)  \
+		(((v) << 8) & BM_OCOTP_ROM1_BOOT_SEARCH_COUNT)
+#define BP_OCOTP_ROM1_RSRVD0	3
+#define BM_OCOTP_ROM1_RSRVD0	0x000000F8
+#define BF_OCOTP_ROM1_RSRVD0(v)  \
+		(((v) << 3) & BM_OCOTP_ROM1_RSRVD0)
+#define BP_OCOTP_ROM1_NUMBER_OF_NANDS	0
+#define BM_OCOTP_ROM1_NUMBER_OF_NANDS	0x00000007
+#define BF_OCOTP_ROM1_NUMBER_OF_NANDS(v)  \
+		(((v) << 0) & BM_OCOTP_ROM1_NUMBER_OF_NANDS)
+
+#define HW_OCOTP_ROM2	(0x000001c0)
+
+#define BP_OCOTP_ROM2_USB_VID	16
+#define BM_OCOTP_ROM2_USB_VID	0xFFFF0000
+#define BF_OCOTP_ROM2_USB_VID(v) \
+		(((v) << 16) & BM_OCOTP_ROM2_USB_VID)
+#define BP_OCOTP_ROM2_USB_PID	0
+#define BM_OCOTP_ROM2_USB_PID	0x0000FFFF
+#define BF_OCOTP_ROM2_USB_PID(v)  \
+		(((v) << 0) & BM_OCOTP_ROM2_USB_PID)
+
+#define HW_OCOTP_ROM3	(0x000001d0)
+
+#define BP_OCOTP_ROM3_RSRVD1	10
+#define BM_OCOTP_ROM3_RSRVD1	0xFFFFFC00
+#define BF_OCOTP_ROM3_RSRVD1(v) \
+		(((v) << 10) & BM_OCOTP_ROM3_RSRVD1)
+#define BP_OCOTP_ROM3_RSRVD0	0
+#define BM_OCOTP_ROM3_RSRVD0	0x000003FF
+#define BF_OCOTP_ROM3_RSRVD0(v)  \
+		(((v) << 0) & BM_OCOTP_ROM3_RSRVD0)
+
+#define HW_OCOTP_ROM4	(0x000001e0)
+
+#define BP_OCOTP_ROM4_BITS	0
+#define BM_OCOTP_ROM4_BITS	0xFFFFFFFF
+#define BF_OCOTP_ROM4_BITS(v)	(v)
+
+#define HW_OCOTP_ROM5	(0x000001f0)
+
+#define BP_OCOTP_ROM5_BITS	0
+#define BM_OCOTP_ROM5_BITS	0xFFFFFFFF
+#define BF_OCOTP_ROM5_BITS(v)	(v)
+
+#define HW_OCOTP_ROM6	(0x00000200)
+
+#define BP_OCOTP_ROM6_BITS	0
+#define BM_OCOTP_ROM6_BITS	0xFFFFFFFF
+#define BF_OCOTP_ROM6_BITS(v)	(v)
+
+#define HW_OCOTP_ROM7	(0x00000210)
+
+#define BP_OCOTP_ROM7_BITS	0
+#define BM_OCOTP_ROM7_BITS	0xFFFFFFFF
+#define BF_OCOTP_ROM7_BITS(v)	(v)
+
+#define HW_OCOTP_VERSION	(0x00000220)
+
+#define BP_OCOTP_VERSION_MAJOR	24
+#define BM_OCOTP_VERSION_MAJOR	0xFF000000
+#define BF_OCOTP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_OCOTP_VERSION_MAJOR)
+#define BP_OCOTP_VERSION_MINOR	16
+#define BM_OCOTP_VERSION_MINOR	0x00FF0000
+#define BF_OCOTP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_OCOTP_VERSION_MINOR)
+#define BP_OCOTP_VERSION_STEP	0
+#define BM_OCOTP_VERSION_STEP	0x0000FFFF
+#define BF_OCOTP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_OCOTP_VERSION_STEP)
+#endif /* __ARCH_ARM___OCOTP_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-power.h b/arch/arm/mach-mx23/include/mach/regs-power.h
new file mode 100644
index 0000000..30d5b02
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-power.h
@@ -0,0 +1,564 @@
+/*
+ * Freescale POWER Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.0
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___POWER_H
+#define __ARCH_ARM___POWER_H
+
+#include <mach/mx23.h>
+
+#define REGS_POWER_BASE IO_ADDRESS(POWER_PHYS_ADDR)
+#define REGS_POWER_PHYS (0x80044000)
+#define REGS_POWER_SIZE 0x00002000
+
+#define HW_POWER_CTRL	(0x00000000)
+#define HW_POWER_CTRL_SET	(0x00000004)
+#define HW_POWER_CTRL_CLR	(0x00000008)
+#define HW_POWER_CTRL_TOG	(0x0000000c)
+
+#define BM_POWER_CTRL_RSRVD3	0x80000000
+#define BM_POWER_CTRL_CLKGATE	0x40000000
+#define BP_POWER_CTRL_RSRVD2	28
+#define BM_POWER_CTRL_RSRVD2	0x30000000
+#define BF_POWER_CTRL_RSRVD2(v)  \
+		(((v) << 28) & BM_POWER_CTRL_RSRVD2)
+#define BM_POWER_CTRL_PSWITCH_MID_TRAN	0x08000000
+#define BP_POWER_CTRL_RSRVD1	25
+#define BM_POWER_CTRL_RSRVD1	0x06000000
+#define BF_POWER_CTRL_RSRVD1(v)  \
+		(((v) << 25) & BM_POWER_CTRL_RSRVD1)
+#define BM_POWER_CTRL_DCDC4P2_BO_IRQ	0x01000000
+#define BM_POWER_CTRL_ENIRQ_DCDC4P2_BO	0x00800000
+#define BM_POWER_CTRL_VDD5V_DROOP_IRQ	0x00400000
+#define BM_POWER_CTRL_ENIRQ_VDD5V_DROOP	0x00200000
+#define BM_POWER_CTRL_PSWITCH_IRQ	0x00100000
+#define BM_POWER_CTRL_PSWITCH_IRQ_SRC	0x00080000
+#define BM_POWER_CTRL_POLARITY_PSWITCH	0x00040000
+#define BM_POWER_CTRL_ENIRQ_PSWITCH	0x00020000
+#define BM_POWER_CTRL_POLARITY_DC_OK	0x00010000
+#define BM_POWER_CTRL_DC_OK_IRQ	0x00008000
+#define BM_POWER_CTRL_ENIRQ_DC_OK	0x00004000
+#define BM_POWER_CTRL_BATT_BO_IRQ	0x00002000
+#define BM_POWER_CTRL_ENIRQBATT_BO	0x00001000
+#define BM_POWER_CTRL_VDDIO_BO_IRQ	0x00000800
+#define BM_POWER_CTRL_ENIRQ_VDDIO_BO	0x00000400
+#define BM_POWER_CTRL_VDDA_BO_IRQ	0x00000200
+#define BM_POWER_CTRL_ENIRQ_VDDA_BO	0x00000100
+#define BM_POWER_CTRL_VDDD_BO_IRQ	0x00000080
+#define BM_POWER_CTRL_ENIRQ_VDDD_BO	0x00000040
+#define BM_POWER_CTRL_POLARITY_VBUSVALID	0x00000020
+#define BM_POWER_CTRL_VBUSVALID_IRQ	0x00000010
+#define BM_POWER_CTRL_ENIRQ_VBUS_VALID	0x00000008
+#define BM_POWER_CTRL_POLARITY_VDD5V_GT_VDDIO	0x00000004
+#define BM_POWER_CTRL_VDD5V_GT_VDDIO_IRQ	0x00000002
+#define BM_POWER_CTRL_ENIRQ_VDD5V_GT_VDDIO	0x00000001
+
+#define HW_POWER_5VCTRL	(0x00000010)
+#define HW_POWER_5VCTRL_SET	(0x00000014)
+#define HW_POWER_5VCTRL_CLR	(0x00000018)
+#define HW_POWER_5VCTRL_TOG	(0x0000001c)
+
+#define BP_POWER_5VCTRL_RSRVD6	30
+#define BM_POWER_5VCTRL_RSRVD6	0xC0000000
+#define BF_POWER_5VCTRL_RSRVD6(v) \
+		(((v) << 30) & BM_POWER_5VCTRL_RSRVD6)
+#define BP_POWER_5VCTRL_VBUSDROOP_TRSH	28
+#define BM_POWER_5VCTRL_VBUSDROOP_TRSH	0x30000000
+#define BF_POWER_5VCTRL_VBUSDROOP_TRSH(v)  \
+		(((v) << 28) & BM_POWER_5VCTRL_VBUSDROOP_TRSH)
+#define BM_POWER_5VCTRL_RSRVD5	0x08000000
+#define BP_POWER_5VCTRL_HEADROOM_ADJ	24
+#define BM_POWER_5VCTRL_HEADROOM_ADJ	0x07000000
+#define BF_POWER_5VCTRL_HEADROOM_ADJ(v)  \
+		(((v) << 24) & BM_POWER_5VCTRL_HEADROOM_ADJ)
+#define BP_POWER_5VCTRL_RSRVD4	21
+#define BM_POWER_5VCTRL_RSRVD4	0x00E00000
+#define BF_POWER_5VCTRL_RSRVD4(v)  \
+		(((v) << 21) & BM_POWER_5VCTRL_RSRVD4)
+#define BM_POWER_5VCTRL_PWD_CHARGE_4P2	0x00100000
+#define BP_POWER_5VCTRL_RSRVD3	18
+#define BM_POWER_5VCTRL_RSRVD3	0x000C0000
+#define BF_POWER_5VCTRL_RSRVD3(v)  \
+		(((v) << 18) & BM_POWER_5VCTRL_RSRVD3)
+#define BP_POWER_5VCTRL_CHARGE_4P2_ILIMIT	12
+#define BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT	0x0003F000
+#define BF_POWER_5VCTRL_CHARGE_4P2_ILIMIT(v)  \
+		(((v) << 12) & BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT)
+#define BM_POWER_5VCTRL_RSRVD2	0x00000800
+#define BP_POWER_5VCTRL_VBUSVALID_TRSH	8
+#define BM_POWER_5VCTRL_VBUSVALID_TRSH	0x00000700
+#define BF_POWER_5VCTRL_VBUSVALID_TRSH(v)  \
+		(((v) << 8) & BM_POWER_5VCTRL_VBUSVALID_TRSH)
+#define BM_POWER_5VCTRL_PWDN_5VBRNOUT	0x00000080
+#define BM_POWER_5VCTRL_ENABLE_LINREG_ILIMIT	0x00000040
+#define BM_POWER_5VCTRL_DCDC_XFER	0x00000020
+#define BM_POWER_5VCTRL_VBUSVALID_5VDETECT	0x00000010
+#define BM_POWER_5VCTRL_VBUSVALID_TO_B	0x00000008
+#define BM_POWER_5VCTRL_ILIMIT_EQ_ZERO	0x00000004
+#define BM_POWER_5VCTRL_PWRUP_VBUS_CMPS	0x00000002
+#define BM_POWER_5VCTRL_ENABLE_DCDC	0x00000001
+
+#define HW_POWER_MINPWR	(0x00000020)
+#define HW_POWER_MINPWR_SET	(0x00000024)
+#define HW_POWER_MINPWR_CLR	(0x00000028)
+#define HW_POWER_MINPWR_TOG	(0x0000002c)
+
+#define BP_POWER_MINPWR_RSRVD1	15
+#define BM_POWER_MINPWR_RSRVD1	0xFFFF8000
+#define BF_POWER_MINPWR_RSRVD1(v) \
+		(((v) << 15) & BM_POWER_MINPWR_RSRVD1)
+#define BM_POWER_MINPWR_LOWPWR_4P2	0x00004000
+#define BM_POWER_MINPWR_VDAC_DUMP_CTRL	0x00002000
+#define BM_POWER_MINPWR_PWD_BO	0x00001000
+#define BM_POWER_MINPWR_USE_VDDXTAL_VBG	0x00000800
+#define BM_POWER_MINPWR_PWD_ANA_CMPS	0x00000400
+#define BM_POWER_MINPWR_ENABLE_OSC	0x00000200
+#define BM_POWER_MINPWR_SELECT_OSC	0x00000100
+#define BM_POWER_MINPWR_VBG_OFF	0x00000080
+#define BM_POWER_MINPWR_DOUBLE_FETS	0x00000040
+#define BM_POWER_MINPWR_HALF_FETS	0x00000020
+#define BM_POWER_MINPWR_LESSANA_I	0x00000010
+#define BM_POWER_MINPWR_PWD_XTAL24	0x00000008
+#define BM_POWER_MINPWR_DC_STOPCLK	0x00000004
+#define BM_POWER_MINPWR_EN_DC_PFM	0x00000002
+#define BM_POWER_MINPWR_DC_HALFCLK	0x00000001
+
+#define HW_POWER_CHARGE	(0x00000030)
+#define HW_POWER_CHARGE_SET	(0x00000034)
+#define HW_POWER_CHARGE_CLR	(0x00000038)
+#define HW_POWER_CHARGE_TOG	(0x0000003c)
+
+#define BP_POWER_CHARGE_RSRVD4	27
+#define BM_POWER_CHARGE_RSRVD4	0xF8000000
+#define BF_POWER_CHARGE_RSRVD4(v) \
+		(((v) << 27) & BM_POWER_CHARGE_RSRVD4)
+#define BP_POWER_CHARGE_ADJ_VOLT	24
+#define BM_POWER_CHARGE_ADJ_VOLT	0x07000000
+#define BF_POWER_CHARGE_ADJ_VOLT(v)  \
+		(((v) << 24) & BM_POWER_CHARGE_ADJ_VOLT)
+#define BM_POWER_CHARGE_RSRVD3	0x00800000
+#define BM_POWER_CHARGE_ENABLE_LOAD	0x00400000
+#define BM_POWER_CHARGE_ENABLE_CHARGER_RESISTORS	0x00200000
+#define BM_POWER_CHARGE_ENABLE_FAULT_DETECT	0x00100000
+#define BM_POWER_CHARGE_CHRG_STS_OFF	0x00080000
+#define BM_POWER_CHARGE_LIION_4P1	0x00040000
+#define BM_POWER_CHARGE_USE_EXTERN_R	0x00020000
+#define BM_POWER_CHARGE_PWD_BATTCHRG	0x00010000
+#define BP_POWER_CHARGE_RSRVD2	12
+#define BM_POWER_CHARGE_RSRVD2	0x0000F000
+#define BF_POWER_CHARGE_RSRVD2(v)  \
+		(((v) << 12) & BM_POWER_CHARGE_RSRVD2)
+#define BP_POWER_CHARGE_STOP_ILIMIT	8
+#define BM_POWER_CHARGE_STOP_ILIMIT	0x00000F00
+#define BF_POWER_CHARGE_STOP_ILIMIT(v)  \
+		(((v) << 8) & BM_POWER_CHARGE_STOP_ILIMIT)
+#define BP_POWER_CHARGE_RSRVD1	6
+#define BM_POWER_CHARGE_RSRVD1	0x000000C0
+#define BF_POWER_CHARGE_RSRVD1(v)  \
+		(((v) << 6) & BM_POWER_CHARGE_RSRVD1)
+#define BP_POWER_CHARGE_BATTCHRG_I	0
+#define BM_POWER_CHARGE_BATTCHRG_I	0x0000003F
+#define BF_POWER_CHARGE_BATTCHRG_I(v)  \
+		(((v) << 0) & BM_POWER_CHARGE_BATTCHRG_I)
+
+#define HW_POWER_VDDDCTRL	(0x00000040)
+
+#define BP_POWER_VDDDCTRL_ADJTN	28
+#define BM_POWER_VDDDCTRL_ADJTN	0xF0000000
+#define BF_POWER_VDDDCTRL_ADJTN(v) \
+		(((v) << 28) & BM_POWER_VDDDCTRL_ADJTN)
+#define BP_POWER_VDDDCTRL_RSRVD4	24
+#define BM_POWER_VDDDCTRL_RSRVD4	0x0F000000
+#define BF_POWER_VDDDCTRL_RSRVD4(v)  \
+		(((v) << 24) & BM_POWER_VDDDCTRL_RSRVD4)
+#define BM_POWER_VDDDCTRL_PWDN_BRNOUT	0x00800000
+#define BM_POWER_VDDDCTRL_DISABLE_STEPPING	0x00400000
+#define BM_POWER_VDDDCTRL_ENABLE_LINREG	0x00200000
+#define BM_POWER_VDDDCTRL_DISABLE_FET	0x00100000
+#define BP_POWER_VDDDCTRL_RSRVD3	18
+#define BM_POWER_VDDDCTRL_RSRVD3	0x000C0000
+#define BF_POWER_VDDDCTRL_RSRVD3(v)  \
+		(((v) << 18) & BM_POWER_VDDDCTRL_RSRVD3)
+#define BP_POWER_VDDDCTRL_LINREG_OFFSET	16
+#define BM_POWER_VDDDCTRL_LINREG_OFFSET	0x00030000
+#define BF_POWER_VDDDCTRL_LINREG_OFFSET(v)  \
+		(((v) << 16) & BM_POWER_VDDDCTRL_LINREG_OFFSET)
+#define BP_POWER_VDDDCTRL_RSRVD2	11
+#define BM_POWER_VDDDCTRL_RSRVD2	0x0000F800
+#define BF_POWER_VDDDCTRL_RSRVD2(v)  \
+		(((v) << 11) & BM_POWER_VDDDCTRL_RSRVD2)
+#define BP_POWER_VDDDCTRL_BO_OFFSET	8
+#define BM_POWER_VDDDCTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDDCTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDDCTRL_BO_OFFSET)
+#define BP_POWER_VDDDCTRL_RSRVD1	5
+#define BM_POWER_VDDDCTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDDCTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDDCTRL_RSRVD1)
+#define BP_POWER_VDDDCTRL_TRG	0
+#define BM_POWER_VDDDCTRL_TRG	0x0000001F
+#define BF_POWER_VDDDCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDDCTRL_TRG)
+
+#define HW_POWER_VDDACTRL	(0x00000050)
+
+#define BP_POWER_VDDACTRL_RSRVD4	20
+#define BM_POWER_VDDACTRL_RSRVD4	0xFFF00000
+#define BF_POWER_VDDACTRL_RSRVD4(v) \
+		(((v) << 20) & BM_POWER_VDDACTRL_RSRVD4)
+#define BM_POWER_VDDACTRL_PWDN_BRNOUT	0x00080000
+#define BM_POWER_VDDACTRL_DISABLE_STEPPING	0x00040000
+#define BM_POWER_VDDACTRL_ENABLE_LINREG	0x00020000
+#define BM_POWER_VDDACTRL_DISABLE_FET	0x00010000
+#define BP_POWER_VDDACTRL_RSRVD3	14
+#define BM_POWER_VDDACTRL_RSRVD3	0x0000C000
+#define BF_POWER_VDDACTRL_RSRVD3(v)  \
+		(((v) << 14) & BM_POWER_VDDACTRL_RSRVD3)
+#define BP_POWER_VDDACTRL_LINREG_OFFSET	12
+#define BM_POWER_VDDACTRL_LINREG_OFFSET	0x00003000
+#define BF_POWER_VDDACTRL_LINREG_OFFSET(v)  \
+		(((v) << 12) & BM_POWER_VDDACTRL_LINREG_OFFSET)
+#define BM_POWER_VDDACTRL_RSRVD2	0x00000800
+#define BP_POWER_VDDACTRL_BO_OFFSET	8
+#define BM_POWER_VDDACTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDACTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDACTRL_BO_OFFSET)
+#define BP_POWER_VDDACTRL_RSRVD1	5
+#define BM_POWER_VDDACTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDACTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDACTRL_RSRVD1)
+#define BP_POWER_VDDACTRL_TRG	0
+#define BM_POWER_VDDACTRL_TRG	0x0000001F
+#define BF_POWER_VDDACTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDACTRL_TRG)
+
+#define HW_POWER_VDDIOCTRL	(0x00000060)
+
+#define BP_POWER_VDDIOCTRL_RSRVD5	24
+#define BM_POWER_VDDIOCTRL_RSRVD5	0xFF000000
+#define BF_POWER_VDDIOCTRL_RSRVD5(v) \
+		(((v) << 24) & BM_POWER_VDDIOCTRL_RSRVD5)
+#define BP_POWER_VDDIOCTRL_ADJTN	20
+#define BM_POWER_VDDIOCTRL_ADJTN	0x00F00000
+#define BF_POWER_VDDIOCTRL_ADJTN(v)  \
+		(((v) << 20) & BM_POWER_VDDIOCTRL_ADJTN)
+#define BM_POWER_VDDIOCTRL_RSRVD4	0x00080000
+#define BM_POWER_VDDIOCTRL_PWDN_BRNOUT	0x00040000
+#define BM_POWER_VDDIOCTRL_DISABLE_STEPPING	0x00020000
+#define BM_POWER_VDDIOCTRL_DISABLE_FET	0x00010000
+#define BP_POWER_VDDIOCTRL_RSRVD3	14
+#define BM_POWER_VDDIOCTRL_RSRVD3	0x0000C000
+#define BF_POWER_VDDIOCTRL_RSRVD3(v)  \
+		(((v) << 14) & BM_POWER_VDDIOCTRL_RSRVD3)
+#define BP_POWER_VDDIOCTRL_LINREG_OFFSET	12
+#define BM_POWER_VDDIOCTRL_LINREG_OFFSET	0x00003000
+#define BF_POWER_VDDIOCTRL_LINREG_OFFSET(v)  \
+		(((v) << 12) & BM_POWER_VDDIOCTRL_LINREG_OFFSET)
+#define BM_POWER_VDDIOCTRL_RSRVD2	0x00000800
+#define BP_POWER_VDDIOCTRL_BO_OFFSET	8
+#define BM_POWER_VDDIOCTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDIOCTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDIOCTRL_BO_OFFSET)
+#define BP_POWER_VDDIOCTRL_RSRVD1	5
+#define BM_POWER_VDDIOCTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDIOCTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDIOCTRL_RSRVD1)
+#define BP_POWER_VDDIOCTRL_TRG	0
+#define BM_POWER_VDDIOCTRL_TRG	0x0000001F
+#define BF_POWER_VDDIOCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDIOCTRL_TRG)
+
+#define HW_POWER_VDDMEMCTRL	(0x00000070)
+
+#define BP_POWER_VDDMEMCTRL_RSRVD2	11
+#define BM_POWER_VDDMEMCTRL_RSRVD2	0xFFFFF800
+#define BF_POWER_VDDMEMCTRL_RSRVD2(v) \
+		(((v) << 11) & BM_POWER_VDDMEMCTRL_RSRVD2)
+#define BM_POWER_VDDMEMCTRL_PULLDOWN_ACTIVE	0x00000400
+#define BM_POWER_VDDMEMCTRL_ENABLE_ILIMIT	0x00000200
+#define BM_POWER_VDDMEMCTRL_ENABLE_LINREG	0x00000100
+#define BP_POWER_VDDMEMCTRL_RSRVD1	5
+#define BM_POWER_VDDMEMCTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDMEMCTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDMEMCTRL_RSRVD1)
+#define BP_POWER_VDDMEMCTRL_TRG	0
+#define BM_POWER_VDDMEMCTRL_TRG	0x0000001F
+#define BF_POWER_VDDMEMCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDMEMCTRL_TRG)
+
+#define HW_POWER_DCDC4P2	(0x00000080)
+
+#define BP_POWER_DCDC4P2_DROPOUT_CTRL	28
+#define BM_POWER_DCDC4P2_DROPOUT_CTRL	0xF0000000
+#define BF_POWER_DCDC4P2_DROPOUT_CTRL(v) \
+		(((v) << 28) & BM_POWER_DCDC4P2_DROPOUT_CTRL)
+#define BP_POWER_DCDC4P2_RSRVD5	26
+#define BM_POWER_DCDC4P2_RSRVD5	0x0C000000
+#define BF_POWER_DCDC4P2_RSRVD5(v)  \
+		(((v) << 26) & BM_POWER_DCDC4P2_RSRVD5)
+#define BP_POWER_DCDC4P2_ISTEAL_THRESH	24
+#define BM_POWER_DCDC4P2_ISTEAL_THRESH	0x03000000
+#define BF_POWER_DCDC4P2_ISTEAL_THRESH(v)  \
+		(((v) << 24) & BM_POWER_DCDC4P2_ISTEAL_THRESH)
+#define BM_POWER_DCDC4P2_ENABLE_4P2	0x00800000
+#define BM_POWER_DCDC4P2_ENABLE_DCDC	0x00400000
+#define BM_POWER_DCDC4P2_HYST_DIR	0x00200000
+#define BM_POWER_DCDC4P2_HYST_THRESH	0x00100000
+#define BM_POWER_DCDC4P2_RSRVD3	0x00080000
+#define BP_POWER_DCDC4P2_TRG	16
+#define BM_POWER_DCDC4P2_TRG	0x00070000
+#define BF_POWER_DCDC4P2_TRG(v)  \
+		(((v) << 16) & BM_POWER_DCDC4P2_TRG)
+#define BP_POWER_DCDC4P2_RSRVD2	13
+#define BM_POWER_DCDC4P2_RSRVD2	0x0000E000
+#define BF_POWER_DCDC4P2_RSRVD2(v)  \
+		(((v) << 13) & BM_POWER_DCDC4P2_RSRVD2)
+#define BP_POWER_DCDC4P2_BO	8
+#define BM_POWER_DCDC4P2_BO	0x00001F00
+#define BF_POWER_DCDC4P2_BO(v)  \
+		(((v) << 8) & BM_POWER_DCDC4P2_BO)
+#define BP_POWER_DCDC4P2_RSRVD1	5
+#define BM_POWER_DCDC4P2_RSRVD1	0x000000E0
+#define BF_POWER_DCDC4P2_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_DCDC4P2_RSRVD1)
+#define BP_POWER_DCDC4P2_CMPTRIP	0
+#define BM_POWER_DCDC4P2_CMPTRIP	0x0000001F
+#define BF_POWER_DCDC4P2_CMPTRIP(v)  \
+		(((v) << 0) & BM_POWER_DCDC4P2_CMPTRIP)
+
+#define HW_POWER_MISC	(0x00000090)
+
+#define BP_POWER_MISC_RSRVD2	7
+#define BM_POWER_MISC_RSRVD2	0xFFFFFF80
+#define BF_POWER_MISC_RSRVD2(v) \
+		(((v) << 7) & BM_POWER_MISC_RSRVD2)
+#define BP_POWER_MISC_FREQSEL	4
+#define BM_POWER_MISC_FREQSEL	0x00000070
+#define BF_POWER_MISC_FREQSEL(v)  \
+		(((v) << 4) & BM_POWER_MISC_FREQSEL)
+#define BM_POWER_MISC_RSRVD1	0x00000008
+#define BM_POWER_MISC_DELAY_TIMING	0x00000004
+#define BM_POWER_MISC_TEST	0x00000002
+#define BM_POWER_MISC_SEL_PLLCLK	0x00000001
+
+#define HW_POWER_DCLIMITS	(0x000000a0)
+
+#define BP_POWER_DCLIMITS_RSRVD3	16
+#define BM_POWER_DCLIMITS_RSRVD3	0xFFFF0000
+#define BF_POWER_DCLIMITS_RSRVD3(v) \
+		(((v) << 16) & BM_POWER_DCLIMITS_RSRVD3)
+#define BM_POWER_DCLIMITS_RSRVD2	0x00008000
+#define BP_POWER_DCLIMITS_POSLIMIT_BUCK	8
+#define BM_POWER_DCLIMITS_POSLIMIT_BUCK	0x00007F00
+#define BF_POWER_DCLIMITS_POSLIMIT_BUCK(v)  \
+		(((v) << 8) & BM_POWER_DCLIMITS_POSLIMIT_BUCK)
+#define BM_POWER_DCLIMITS_RSRVD1	0x00000080
+#define BP_POWER_DCLIMITS_NEGLIMIT	0
+#define BM_POWER_DCLIMITS_NEGLIMIT	0x0000007F
+#define BF_POWER_DCLIMITS_NEGLIMIT(v)  \
+		(((v) << 0) & BM_POWER_DCLIMITS_NEGLIMIT)
+
+#define HW_POWER_LOOPCTRL	(0x000000b0)
+#define HW_POWER_LOOPCTRL_SET	(0x000000b4)
+#define HW_POWER_LOOPCTRL_CLR	(0x000000b8)
+#define HW_POWER_LOOPCTRL_TOG	(0x000000bc)
+
+#define BP_POWER_LOOPCTRL_RSRVD3	21
+#define BM_POWER_LOOPCTRL_RSRVD3	0xFFE00000
+#define BF_POWER_LOOPCTRL_RSRVD3(v) \
+		(((v) << 21) & BM_POWER_LOOPCTRL_RSRVD3)
+#define BM_POWER_LOOPCTRL_TOGGLE_DIF	0x00100000
+#define BM_POWER_LOOPCTRL_HYST_SIGN	0x00080000
+#define BM_POWER_LOOPCTRL_EN_CM_HYST	0x00040000
+#define BM_POWER_LOOPCTRL_EN_DF_HYST	0x00020000
+#define BM_POWER_LOOPCTRL_CM_HYST_THRESH	0x00010000
+#define BM_POWER_LOOPCTRL_DF_HYST_THRESH	0x00008000
+#define BM_POWER_LOOPCTRL_RCSCALE_THRESH	0x00004000
+#define BP_POWER_LOOPCTRL_EN_RCSCALE	12
+#define BM_POWER_LOOPCTRL_EN_RCSCALE	0x00003000
+#define BF_POWER_LOOPCTRL_EN_RCSCALE(v)  \
+		(((v) << 12) & BM_POWER_LOOPCTRL_EN_RCSCALE)
+#define BM_POWER_LOOPCTRL_RSRVD2	0x00000800
+#define BP_POWER_LOOPCTRL_DC_FF	8
+#define BM_POWER_LOOPCTRL_DC_FF	0x00000700
+#define BF_POWER_LOOPCTRL_DC_FF(v)  \
+		(((v) << 8) & BM_POWER_LOOPCTRL_DC_FF)
+#define BP_POWER_LOOPCTRL_DC_R	4
+#define BM_POWER_LOOPCTRL_DC_R	0x000000F0
+#define BF_POWER_LOOPCTRL_DC_R(v)  \
+		(((v) << 4) & BM_POWER_LOOPCTRL_DC_R)
+#define BP_POWER_LOOPCTRL_RSRVD1	2
+#define BM_POWER_LOOPCTRL_RSRVD1	0x0000000C
+#define BF_POWER_LOOPCTRL_RSRVD1(v)  \
+		(((v) << 2) & BM_POWER_LOOPCTRL_RSRVD1)
+#define BP_POWER_LOOPCTRL_DC_C	0
+#define BM_POWER_LOOPCTRL_DC_C	0x00000003
+#define BF_POWER_LOOPCTRL_DC_C(v)  \
+		(((v) << 0) & BM_POWER_LOOPCTRL_DC_C)
+
+#define HW_POWER_STS	(0x000000c0)
+
+#define BP_POWER_STS_RSRVD3	30
+#define BM_POWER_STS_RSRVD3	0xC0000000
+#define BF_POWER_STS_RSRVD3(v) \
+		(((v) << 30) & BM_POWER_STS_RSRVD3)
+#define BP_POWER_STS_PWRUP_SOURCE	24
+#define BM_POWER_STS_PWRUP_SOURCE	0x3F000000
+#define BF_POWER_STS_PWRUP_SOURCE(v)  \
+		(((v) << 24) & BM_POWER_STS_PWRUP_SOURCE)
+#define BP_POWER_STS_RSRVD2	22
+#define BM_POWER_STS_RSRVD2	0x00C00000
+#define BF_POWER_STS_RSRVD2(v)  \
+		(((v) << 22) & BM_POWER_STS_RSRVD2)
+#define BP_POWER_STS_PSWITCH	20
+#define BM_POWER_STS_PSWITCH	0x00300000
+#define BF_POWER_STS_PSWITCH(v)  \
+		(((v) << 20) & BM_POWER_STS_PSWITCH)
+#define BP_POWER_STS_RSRVD1	18
+#define BM_POWER_STS_RSRVD1	0x000C0000
+#define BF_POWER_STS_RSRVD1(v)  \
+		(((v) << 18) & BM_POWER_STS_RSRVD1)
+#define BM_POWER_STS_AVALID_STATUS	0x00020000
+#define BM_POWER_STS_BVALID_STATUS	0x00010000
+#define BM_POWER_STS_VBUSVALID_STATUS	0x00008000
+#define BM_POWER_STS_SESSEND_STATUS	0x00004000
+#define BM_POWER_STS_BATT_BO	0x00002000
+#define BM_POWER_STS_VDD5V_FAULT	0x00001000
+#define BM_POWER_STS_CHRGSTS	0x00000800
+#define BM_POWER_STS_DCDC_4P2_BO	0x00000400
+#define BM_POWER_STS_DC_OK	0x00000200
+#define BM_POWER_STS_VDDIO_BO	0x00000100
+#define BM_POWER_STS_VDDA_BO	0x00000080
+#define BM_POWER_STS_VDDD_BO	0x00000040
+#define BM_POWER_STS_VDD5V_GT_VDDIO	0x00000020
+#define BM_POWER_STS_VDD5V_DROOP	0x00000010
+#define BM_POWER_STS_AVALID	0x00000008
+#define BM_POWER_STS_BVALID	0x00000004
+#define BM_POWER_STS_VBUSVALID	0x00000002
+#define BM_POWER_STS_SESSEND	0x00000001
+
+#define HW_POWER_SPEED	(0x000000d0)
+#define HW_POWER_SPEED_SET	(0x000000d4)
+#define HW_POWER_SPEED_CLR	(0x000000d8)
+#define HW_POWER_SPEED_TOG	(0x000000dc)
+
+#define BP_POWER_SPEED_RSRVD1	24
+#define BM_POWER_SPEED_RSRVD1	0xFF000000
+#define BF_POWER_SPEED_RSRVD1(v) \
+		(((v) << 24) & BM_POWER_SPEED_RSRVD1)
+#define BP_POWER_SPEED_STATUS	16
+#define BM_POWER_SPEED_STATUS	0x00FF0000
+#define BF_POWER_SPEED_STATUS(v)  \
+		(((v) << 16) & BM_POWER_SPEED_STATUS)
+#define BP_POWER_SPEED_RSRVD0	2
+#define BM_POWER_SPEED_RSRVD0	0x0000FFFC
+#define BF_POWER_SPEED_RSRVD0(v)  \
+		(((v) << 2) & BM_POWER_SPEED_RSRVD0)
+#define BP_POWER_SPEED_CTRL	0
+#define BM_POWER_SPEED_CTRL	0x00000003
+#define BF_POWER_SPEED_CTRL(v)  \
+		(((v) << 0) & BM_POWER_SPEED_CTRL)
+
+#define HW_POWER_BATTMONITOR	(0x000000e0)
+
+#define BP_POWER_BATTMONITOR_RSRVD3	26
+#define BM_POWER_BATTMONITOR_RSRVD3	0xFC000000
+#define BF_POWER_BATTMONITOR_RSRVD3(v) \
+		(((v) << 26) & BM_POWER_BATTMONITOR_RSRVD3)
+#define BP_POWER_BATTMONITOR_BATT_VAL	16
+#define BM_POWER_BATTMONITOR_BATT_VAL	0x03FF0000
+#define BF_POWER_BATTMONITOR_BATT_VAL(v)  \
+		(((v) << 16) & BM_POWER_BATTMONITOR_BATT_VAL)
+#define BP_POWER_BATTMONITOR_RSRVD2	11
+#define BM_POWER_BATTMONITOR_RSRVD2	0x0000F800
+#define BF_POWER_BATTMONITOR_RSRVD2(v)  \
+		(((v) << 11) & BM_POWER_BATTMONITOR_RSRVD2)
+#define BM_POWER_BATTMONITOR_EN_BATADJ	0x00000400
+#define BM_POWER_BATTMONITOR_PWDN_BATTBRNOUT	0x00000200
+#define BM_POWER_BATTMONITOR_BRWNOUT_PWD	0x00000100
+#define BP_POWER_BATTMONITOR_RSRVD1	5
+#define BM_POWER_BATTMONITOR_RSRVD1	0x000000E0
+#define BF_POWER_BATTMONITOR_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_BATTMONITOR_RSRVD1)
+#define BP_POWER_BATTMONITOR_BRWNOUT_LVL	0
+#define BM_POWER_BATTMONITOR_BRWNOUT_LVL	0x0000001F
+#define BF_POWER_BATTMONITOR_BRWNOUT_LVL(v)  \
+		(((v) << 0) & BM_POWER_BATTMONITOR_BRWNOUT_LVL)
+
+#define HW_POWER_RESET	(0x00000100)
+#define HW_POWER_RESET_SET	(0x00000104)
+#define HW_POWER_RESET_CLR	(0x00000108)
+#define HW_POWER_RESET_TOG	(0x0000010c)
+
+#define BP_POWER_RESET_UNLOCK	16
+#define BM_POWER_RESET_UNLOCK	0xFFFF0000
+#define BF_POWER_RESET_UNLOCK(v) \
+		(((v) << 16) & BM_POWER_RESET_UNLOCK)
+#define BV_POWER_RESET_UNLOCK__KEY 0x3E77
+#define BP_POWER_RESET_RSRVD1	2
+#define BM_POWER_RESET_RSRVD1	0x0000FFFC
+#define BF_POWER_RESET_RSRVD1(v)  \
+		(((v) << 2) & BM_POWER_RESET_RSRVD1)
+#define BM_POWER_RESET_PWD_OFF	0x00000002
+#define BM_POWER_RESET_PWD	0x00000001
+
+#define HW_POWER_DEBUG	(0x00000110)
+#define HW_POWER_DEBUG_SET	(0x00000114)
+#define HW_POWER_DEBUG_CLR	(0x00000118)
+#define HW_POWER_DEBUG_TOG	(0x0000011c)
+
+#define BP_POWER_DEBUG_RSRVD0	4
+#define BM_POWER_DEBUG_RSRVD0	0xFFFFFFF0
+#define BF_POWER_DEBUG_RSRVD0(v) \
+		(((v) << 4) & BM_POWER_DEBUG_RSRVD0)
+#define BM_POWER_DEBUG_VBUSVALIDPIOLOCK	0x00000008
+#define BM_POWER_DEBUG_AVALIDPIOLOCK	0x00000004
+#define BM_POWER_DEBUG_BVALIDPIOLOCK	0x00000002
+#define BM_POWER_DEBUG_SESSENDPIOLOCK	0x00000001
+
+#define HW_POWER_SPECIAL	(0x00000120)
+#define HW_POWER_SPECIAL_SET	(0x00000124)
+#define HW_POWER_SPECIAL_CLR	(0x00000128)
+#define HW_POWER_SPECIAL_TOG	(0x0000012c)
+
+#define BP_POWER_SPECIAL_TEST	0
+#define BM_POWER_SPECIAL_TEST	0xFFFFFFFF
+#define BF_POWER_SPECIAL_TEST(v)	(v)
+
+#define HW_POWER_VERSION	(0x00000130)
+
+#define BP_POWER_VERSION_MAJOR	24
+#define BM_POWER_VERSION_MAJOR	0xFF000000
+#define BF_POWER_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_POWER_VERSION_MAJOR)
+#define BP_POWER_VERSION_MINOR	16
+#define BM_POWER_VERSION_MINOR	0x00FF0000
+#define BF_POWER_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_POWER_VERSION_MINOR)
+#define BP_POWER_VERSION_STEP	0
+#define BM_POWER_VERSION_STEP	0x0000FFFF
+#define BF_POWER_VERSION_STEP(v)  \
+		(((v) << 0) & BM_POWER_VERSION_STEP)
+#endif /* __ARCH_ARM___POWER_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-pwm.h b/arch/arm/mach-mx23/include/mach/regs-pwm.h
new file mode 100644
index 0000000..30380d7
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-pwm.h
@@ -0,0 +1,135 @@
+/*
+ * Freescale PWM Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.23
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PWM_H
+#define __ARCH_ARM___PWM_H
+
+
+#define HW_PWM_CTRL	(0x00000000)
+#define HW_PWM_CTRL_SET	(0x00000004)
+#define HW_PWM_CTRL_CLR	(0x00000008)
+#define HW_PWM_CTRL_TOG	(0x0000000c)
+
+#define BM_PWM_CTRL_SFTRST	0x80000000
+#define BM_PWM_CTRL_CLKGATE	0x40000000
+#define BM_PWM_CTRL_PWM4_PRESENT	0x20000000
+#define BM_PWM_CTRL_PWM3_PRESENT	0x10000000
+#define BM_PWM_CTRL_PWM2_PRESENT	0x08000000
+#define BM_PWM_CTRL_PWM1_PRESENT	0x04000000
+#define BM_PWM_CTRL_PWM0_PRESENT	0x02000000
+#define BP_PWM_CTRL_RSRVD1	7
+#define BM_PWM_CTRL_RSRVD1	0x01FFFF80
+#define BF_PWM_CTRL_RSRVD1(v)  \
+		(((v) << 7) & BM_PWM_CTRL_RSRVD1)
+#define BM_PWM_CTRL_OUTPUT_CUTOFF_EN	0x00000040
+#define BM_PWM_CTRL_PWM2_ANA_CTRL_ENABLE	0x00000020
+#define BM_PWM_CTRL_PWM4_ENABLE	0x00000010
+#define BM_PWM_CTRL_PWM3_ENABLE	0x00000008
+#define BM_PWM_CTRL_PWM2_ENABLE	0x00000004
+#define BM_PWM_CTRL_PWM1_ENABLE	0x00000002
+#define BM_PWM_CTRL_PWM0_ENABLE	0x00000001
+
+/*
+ *  multi-register-define name HW_PWM_ACTIVEn
+ *              base 0x00000010
+ *              count 5
+ *              offset 0x20
+ */
+#define HW_PWM_ACTIVEn(n)	(0x00000010 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_SET(n)	(0x00000014 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_CLR(n)	(0x00000018 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_TOG(n)	(0x0000001c + (n) * 0x20)
+#define BP_PWM_ACTIVEn_INACTIVE	16
+#define BM_PWM_ACTIVEn_INACTIVE	0xFFFF0000
+#define BF_PWM_ACTIVEn_INACTIVE(v) \
+		(((v) << 16) & BM_PWM_ACTIVEn_INACTIVE)
+#define BP_PWM_ACTIVEn_ACTIVE	0
+#define BM_PWM_ACTIVEn_ACTIVE	0x0000FFFF
+#define BF_PWM_ACTIVEn_ACTIVE(v)  \
+		(((v) << 0) & BM_PWM_ACTIVEn_ACTIVE)
+
+/*
+ *  multi-register-define name HW_PWM_PERIODn
+ *              base 0x00000020
+ *              count 5
+ *              offset 0x20
+ */
+#define HW_PWM_PERIODn(n)	(0x00000020 + (n) * 0x20)
+#define HW_PWM_PERIODn_SET(n)	(0x00000024 + (n) * 0x20)
+#define HW_PWM_PERIODn_CLR(n)	(0x00000028 + (n) * 0x20)
+#define HW_PWM_PERIODn_TOG(n)	(0x0000002c + (n) * 0x20)
+#define BP_PWM_PERIODn_RSRVD2	25
+#define BM_PWM_PERIODn_RSRVD2	0xFE000000
+#define BF_PWM_PERIODn_RSRVD2(v) \
+		(((v) << 25) & BM_PWM_PERIODn_RSRVD2)
+#define BM_PWM_PERIODn_MATT_SEL	0x01000000
+#define BM_PWM_PERIODn_MATT	0x00800000
+#define BP_PWM_PERIODn_CDIV	20
+#define BM_PWM_PERIODn_CDIV	0x00700000
+#define BF_PWM_PERIODn_CDIV(v)  \
+		(((v) << 20) & BM_PWM_PERIODn_CDIV)
+#define BV_PWM_PERIODn_CDIV__DIV_1    0x0
+#define BV_PWM_PERIODn_CDIV__DIV_2    0x1
+#define BV_PWM_PERIODn_CDIV__DIV_4    0x2
+#define BV_PWM_PERIODn_CDIV__DIV_8    0x3
+#define BV_PWM_PERIODn_CDIV__DIV_16   0x4
+#define BV_PWM_PERIODn_CDIV__DIV_64   0x5
+#define BV_PWM_PERIODn_CDIV__DIV_256  0x6
+#define BV_PWM_PERIODn_CDIV__DIV_1024 0x7
+#define BP_PWM_PERIODn_INACTIVE_STATE	18
+#define BM_PWM_PERIODn_INACTIVE_STATE	0x000C0000
+#define BF_PWM_PERIODn_INACTIVE_STATE(v)  \
+		(((v) << 18) & BM_PWM_PERIODn_INACTIVE_STATE)
+#define BV_PWM_PERIODn_INACTIVE_STATE__HI_Z 0x0
+#define BV_PWM_PERIODn_INACTIVE_STATE__0    0x2
+#define BV_PWM_PERIODn_INACTIVE_STATE__1    0x3
+#define BP_PWM_PERIODn_ACTIVE_STATE	16
+#define BM_PWM_PERIODn_ACTIVE_STATE	0x00030000
+#define BF_PWM_PERIODn_ACTIVE_STATE(v)  \
+		(((v) << 16) & BM_PWM_PERIODn_ACTIVE_STATE)
+#define BV_PWM_PERIODn_ACTIVE_STATE__HI_Z 0x0
+#define BV_PWM_PERIODn_ACTIVE_STATE__0    0x2
+#define BV_PWM_PERIODn_ACTIVE_STATE__1    0x3
+#define BP_PWM_PERIODn_PERIOD	0
+#define BM_PWM_PERIODn_PERIOD	0x0000FFFF
+#define BF_PWM_PERIODn_PERIOD(v)  \
+		(((v) << 0) & BM_PWM_PERIODn_PERIOD)
+
+#define HW_PWM_VERSION	(0x000000b0)
+
+#define BP_PWM_VERSION_MAJOR	24
+#define BM_PWM_VERSION_MAJOR	0xFF000000
+#define BF_PWM_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_PWM_VERSION_MAJOR)
+#define BP_PWM_VERSION_MINOR	16
+#define BM_PWM_VERSION_MINOR	0x00FF0000
+#define BF_PWM_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_PWM_VERSION_MINOR)
+#define BP_PWM_VERSION_STEP	0
+#define BM_PWM_VERSION_STEP	0x0000FFFF
+#define BF_PWM_VERSION_STEP(v)  \
+		(((v) << 0) & BM_PWM_VERSION_STEP)
+#endif /* __ARCH_ARM___PWM_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-pxp.h b/arch/arm/mach-mx23/include/mach/regs-pxp.h
new file mode 100644
index 0000000..0a96061
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-pxp.h
@@ -0,0 +1,517 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.57
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST	0x80000000
+#define BM_PXP_CTRL_CLKGATE	0x40000000
+#define BP_PXP_CTRL_RSVD2	28
+#define BM_PXP_CTRL_RSVD2	0x30000000
+#define BF_PXP_CTRL_RSVD2(v)  \
+		(((v) << 28) & BM_PXP_CTRL_RSVD2)
+#define BP_PXP_CTRL_INTERLACED_OUTPUT	26
+#define BM_PXP_CTRL_INTERLACED_OUTPUT	0x0C000000
+#define BF_PXP_CTRL_INTERLACED_OUTPUT(v)  \
+		(((v) << 26) & BM_PXP_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_CTRL_INTERLACED_INPUT	24
+#define BM_PXP_CTRL_INTERLACED_INPUT	0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+		(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0      0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1      0x3
+#define BM_PXP_CTRL_RSVD1	0x00800000
+#define BM_PXP_CTRL_ALPHA_OUTPUT	0x00400000
+#define BM_PXP_CTRL_IN_PLACE	0x00200000
+#define BM_PXP_CTRL_DELTA	0x00100000
+#define BM_PXP_CTRL_CROP	0x00080000
+#define BM_PXP_CTRL_SCALE	0x00040000
+#define BM_PXP_CTRL_UPSAMPLE	0x00020000
+#define BM_PXP_CTRL_SUBSAMPLE	0x00010000
+#define BP_PXP_CTRL_S0_FORMAT	12
+#define BM_PXP_CTRL_S0_FORMAT	0x0000F000
+#define BF_PXP_CTRL_S0_FORMAT(v)  \
+		(((v) << 12) & BM_PXP_CTRL_S0_FORMAT)
+#define BV_PXP_CTRL_S0_FORMAT__RGB888 0x1
+#define BV_PXP_CTRL_S0_FORMAT__RGB565 0x4
+#define BV_PXP_CTRL_S0_FORMAT__RGB555 0x5
+#define BV_PXP_CTRL_S0_FORMAT__YUV422 0x8
+#define BV_PXP_CTRL_S0_FORMAT__YUV420 0x9
+#define BM_PXP_CTRL_VFLIP	0x00000800
+#define BM_PXP_CTRL_HFLIP	0x00000400
+#define BP_PXP_CTRL_ROTATE	8
+#define BM_PXP_CTRL_ROTATE	0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+		(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_OUTPUT_RGB_FORMAT	4
+#define BM_PXP_CTRL_OUTPUT_RGB_FORMAT	0x000000F0
+#define BF_PXP_CTRL_OUTPUT_RGB_FORMAT(v)  \
+		(((v) << 4) & BM_PXP_CTRL_OUTPUT_RGB_FORMAT)
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__ARGB8888 0x0
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__RGB888   0x1
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__RGB888P  0x2
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__ARGB1555 0x3
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__RGB565   0x4
+#define BV_PXP_CTRL_OUTPUT_RGB_FORMAT__RGB555   0x5
+#define BM_PXP_CTRL_RSVD0	0x00000008
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE	0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE	0x00000002
+#define BM_PXP_CTRL_ENABLE	0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX	24
+#define BM_PXP_STAT_BLOCKX	0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+		(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY	16
+#define BM_PXP_STAT_BLOCKY	0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+		(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2	8
+#define BM_PXP_STAT_RSVD2	0x0000FF00
+#define BF_PXP_STAT_RSVD2(v)  \
+		(((v) << 8) & BM_PXP_STAT_RSVD2)
+#define BP_PXP_STAT_AXI_ERROR_ID	4
+#define BM_PXP_STAT_AXI_ERROR_ID	0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+		(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_RSVD1	0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR	0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR	0x00000002
+#define BM_PXP_STAT_IRQ	0x00000001
+
+#define HW_PXP_RGBBUF	(0x00000020)
+
+#define BP_PXP_RGBBUF_ADDR	0
+#define BM_PXP_RGBBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_RGBBUF_ADDR(v)	(v)
+
+#define HW_PXP_RGBBUF2	(0x00000030)
+
+#define BP_PXP_RGBBUF2_ADDR	0
+#define BM_PXP_RGBBUF2_ADDR	0xFFFFFFFF
+#define BF_PXP_RGBBUF2_ADDR(v)	(v)
+
+#define HW_PXP_RGBSIZE	(0x00000040)
+
+#define BP_PXP_RGBSIZE_ALPHA	24
+#define BM_PXP_RGBSIZE_ALPHA	0xFF000000
+#define BF_PXP_RGBSIZE_ALPHA(v) \
+		(((v) << 24) & BM_PXP_RGBSIZE_ALPHA)
+#define BP_PXP_RGBSIZE_WIDTH	12
+#define BM_PXP_RGBSIZE_WIDTH	0x00FFF000
+#define BF_PXP_RGBSIZE_WIDTH(v)  \
+		(((v) << 12) & BM_PXP_RGBSIZE_WIDTH)
+#define BP_PXP_RGBSIZE_HEIGHT	0
+#define BM_PXP_RGBSIZE_HEIGHT	0x00000FFF
+#define BF_PXP_RGBSIZE_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_RGBSIZE_HEIGHT)
+
+#define HW_PXP_S0BUF	(0x00000050)
+
+#define BP_PXP_S0BUF_ADDR	0
+#define BM_PXP_S0BUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0BUF_ADDR(v)	(v)
+
+#define HW_PXP_S0UBUF	(0x00000060)
+
+#define BP_PXP_S0UBUF_ADDR	0
+#define BM_PXP_S0UBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0UBUF_ADDR(v)	(v)
+
+#define HW_PXP_S0VBUF	(0x00000070)
+
+#define BP_PXP_S0VBUF_ADDR	0
+#define BM_PXP_S0VBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0VBUF_ADDR(v)	(v)
+
+#define HW_PXP_S0PARAM	(0x00000080)
+
+#define BP_PXP_S0PARAM_XBASE	24
+#define BM_PXP_S0PARAM_XBASE	0xFF000000
+#define BF_PXP_S0PARAM_XBASE(v) \
+		(((v) << 24) & BM_PXP_S0PARAM_XBASE)
+#define BP_PXP_S0PARAM_YBASE	16
+#define BM_PXP_S0PARAM_YBASE	0x00FF0000
+#define BF_PXP_S0PARAM_YBASE(v)  \
+		(((v) << 16) & BM_PXP_S0PARAM_YBASE)
+#define BP_PXP_S0PARAM_WIDTH	8
+#define BM_PXP_S0PARAM_WIDTH	0x0000FF00
+#define BF_PXP_S0PARAM_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_S0PARAM_WIDTH)
+#define BP_PXP_S0PARAM_HEIGHT	0
+#define BM_PXP_S0PARAM_HEIGHT	0x000000FF
+#define BF_PXP_S0PARAM_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_S0PARAM_HEIGHT)
+
+#define HW_PXP_S0BACKGROUND	(0x00000090)
+
+#define BP_PXP_S0BACKGROUND_COLOR	0
+#define BM_PXP_S0BACKGROUND_COLOR	0xFFFFFFFF
+#define BF_PXP_S0BACKGROUND_COLOR(v)	(v)
+
+#define HW_PXP_S0CROP	(0x000000a0)
+
+#define BP_PXP_S0CROP_XBASE	24
+#define BM_PXP_S0CROP_XBASE	0xFF000000
+#define BF_PXP_S0CROP_XBASE(v) \
+		(((v) << 24) & BM_PXP_S0CROP_XBASE)
+#define BP_PXP_S0CROP_YBASE	16
+#define BM_PXP_S0CROP_YBASE	0x00FF0000
+#define BF_PXP_S0CROP_YBASE(v)  \
+		(((v) << 16) & BM_PXP_S0CROP_YBASE)
+#define BP_PXP_S0CROP_WIDTH	8
+#define BM_PXP_S0CROP_WIDTH	0x0000FF00
+#define BF_PXP_S0CROP_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_S0CROP_WIDTH)
+#define BP_PXP_S0CROP_HEIGHT	0
+#define BM_PXP_S0CROP_HEIGHT	0x000000FF
+#define BF_PXP_S0CROP_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_S0CROP_HEIGHT)
+
+#define HW_PXP_S0SCALE	(0x000000b0)
+
+#define BP_PXP_S0SCALE_RSVD2	30
+#define BM_PXP_S0SCALE_RSVD2	0xC0000000
+#define BF_PXP_S0SCALE_RSVD2(v) \
+		(((v) << 30) & BM_PXP_S0SCALE_RSVD2)
+#define BP_PXP_S0SCALE_YSCALE	16
+#define BM_PXP_S0SCALE_YSCALE	0x3FFF0000
+#define BF_PXP_S0SCALE_YSCALE(v)  \
+		(((v) << 16) & BM_PXP_S0SCALE_YSCALE)
+#define BP_PXP_S0SCALE_RSVD1	14
+#define BM_PXP_S0SCALE_RSVD1	0x0000C000
+#define BF_PXP_S0SCALE_RSVD1(v)  \
+		(((v) << 14) & BM_PXP_S0SCALE_RSVD1)
+#define BP_PXP_S0SCALE_XSCALE	0
+#define BM_PXP_S0SCALE_XSCALE	0x00003FFF
+#define BF_PXP_S0SCALE_XSCALE(v)  \
+		(((v) << 0) & BM_PXP_S0SCALE_XSCALE)
+
+#define HW_PXP_S0OFFSET	(0x000000c0)
+
+#define BP_PXP_S0OFFSET_RSVD2	28
+#define BM_PXP_S0OFFSET_RSVD2	0xF0000000
+#define BF_PXP_S0OFFSET_RSVD2(v) \
+		(((v) << 28) & BM_PXP_S0OFFSET_RSVD2)
+#define BP_PXP_S0OFFSET_YOFFSET	16
+#define BM_PXP_S0OFFSET_YOFFSET	0x0FFF0000
+#define BF_PXP_S0OFFSET_YOFFSET(v)  \
+		(((v) << 16) & BM_PXP_S0OFFSET_YOFFSET)
+#define BP_PXP_S0OFFSET_RSVD1	12
+#define BM_PXP_S0OFFSET_RSVD1	0x0000F000
+#define BF_PXP_S0OFFSET_RSVD1(v)  \
+		(((v) << 12) & BM_PXP_S0OFFSET_RSVD1)
+#define BP_PXP_S0OFFSET_XOFFSET	0
+#define BM_PXP_S0OFFSET_XOFFSET	0x00000FFF
+#define BF_PXP_S0OFFSET_XOFFSET(v)  \
+		(((v) << 0) & BM_PXP_S0OFFSET_XOFFSET)
+
+#define HW_PXP_CSCCOEFF0	(0x000000d0)
+
+#define BM_PXP_CSCCOEFF0_YCBCR_MODE	0x80000000
+#define BP_PXP_CSCCOEFF0_RSVD1	29
+#define BM_PXP_CSCCOEFF0_RSVD1	0x60000000
+#define BF_PXP_CSCCOEFF0_RSVD1(v)  \
+		(((v) << 29) & BM_PXP_CSCCOEFF0_RSVD1)
+#define BP_PXP_CSCCOEFF0_C0	18
+#define BM_PXP_CSCCOEFF0_C0	0x1FFC0000
+#define BF_PXP_CSCCOEFF0_C0(v)  \
+		(((v) << 18) & BM_PXP_CSCCOEFF0_C0)
+#define BP_PXP_CSCCOEFF0_UV_OFFSET	9
+#define BM_PXP_CSCCOEFF0_UV_OFFSET	0x0003FE00
+#define BF_PXP_CSCCOEFF0_UV_OFFSET(v)  \
+		(((v) << 9) & BM_PXP_CSCCOEFF0_UV_OFFSET)
+#define BP_PXP_CSCCOEFF0_Y_OFFSET	0
+#define BM_PXP_CSCCOEFF0_Y_OFFSET	0x000001FF
+#define BF_PXP_CSCCOEFF0_Y_OFFSET(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF0_Y_OFFSET)
+
+#define HW_PXP_CSCCOEFF1	(0x000000e0)
+
+#define BP_PXP_CSCCOEFF1_RSVD1	27
+#define BM_PXP_CSCCOEFF1_RSVD1	0xF8000000
+#define BF_PXP_CSCCOEFF1_RSVD1(v) \
+		(((v) << 27) & BM_PXP_CSCCOEFF1_RSVD1)
+#define BP_PXP_CSCCOEFF1_C1	16
+#define BM_PXP_CSCCOEFF1_C1	0x07FF0000
+#define BF_PXP_CSCCOEFF1_C1(v)  \
+		(((v) << 16) & BM_PXP_CSCCOEFF1_C1)
+#define BP_PXP_CSCCOEFF1_RSVD0	11
+#define BM_PXP_CSCCOEFF1_RSVD0	0x0000F800
+#define BF_PXP_CSCCOEFF1_RSVD0(v)  \
+		(((v) << 11) & BM_PXP_CSCCOEFF1_RSVD0)
+#define BP_PXP_CSCCOEFF1_C4	0
+#define BM_PXP_CSCCOEFF1_C4	0x000007FF
+#define BF_PXP_CSCCOEFF1_C4(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF1_C4)
+
+#define HW_PXP_CSCCOEFF2	(0x000000f0)
+
+#define BP_PXP_CSCCOEFF2_RSVD1	27
+#define BM_PXP_CSCCOEFF2_RSVD1	0xF8000000
+#define BF_PXP_CSCCOEFF2_RSVD1(v) \
+		(((v) << 27) & BM_PXP_CSCCOEFF2_RSVD1)
+#define BP_PXP_CSCCOEFF2_C2	16
+#define BM_PXP_CSCCOEFF2_C2	0x07FF0000
+#define BF_PXP_CSCCOEFF2_C2(v)  \
+		(((v) << 16) & BM_PXP_CSCCOEFF2_C2)
+#define BP_PXP_CSCCOEFF2_RSVD0	11
+#define BM_PXP_CSCCOEFF2_RSVD0	0x0000F800
+#define BF_PXP_CSCCOEFF2_RSVD0(v)  \
+		(((v) << 11) & BM_PXP_CSCCOEFF2_RSVD0)
+#define BP_PXP_CSCCOEFF2_C3	0
+#define BM_PXP_CSCCOEFF2_C3	0x000007FF
+#define BF_PXP_CSCCOEFF2_C3(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF2_C3)
+
+#define HW_PXP_NEXT	(0x00000100)
+#define HW_PXP_NEXT_SET	(0x00000104)
+#define HW_PXP_NEXT_CLR	(0x00000108)
+#define HW_PXP_NEXT_TOG	(0x0000010c)
+
+#define BP_PXP_NEXT_POINTER	2
+#define BM_PXP_NEXT_POINTER	0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+		(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD	0x00000002
+#define BM_PXP_NEXT_ENABLED	0x00000001
+
+#define HW_PXP_PAGETABLE	(0x00000170)
+
+#define BP_PXP_PAGETABLE_BASE	14
+#define BM_PXP_PAGETABLE_BASE	0xFFFFC000
+#define BF_PXP_PAGETABLE_BASE(v) \
+		(((v) << 14) & BM_PXP_PAGETABLE_BASE)
+#define BP_PXP_PAGETABLE_RSVD1	2
+#define BM_PXP_PAGETABLE_RSVD1	0x00003FFC
+#define BF_PXP_PAGETABLE_RSVD1(v)  \
+		(((v) << 2) & BM_PXP_PAGETABLE_RSVD1)
+#define BM_PXP_PAGETABLE_FLUSH	0x00000002
+#define BM_PXP_PAGETABLE_ENABLE	0x00000001
+
+#define HW_PXP_S0COLORKEYLOW	(0x00000180)
+
+#define BP_PXP_S0COLORKEYLOW_RSVD1	24
+#define BM_PXP_S0COLORKEYLOW_RSVD1	0xFF000000
+#define BF_PXP_S0COLORKEYLOW_RSVD1(v) \
+		(((v) << 24) & BM_PXP_S0COLORKEYLOW_RSVD1)
+#define BP_PXP_S0COLORKEYLOW_PIXEL	0
+#define BM_PXP_S0COLORKEYLOW_PIXEL	0x00FFFFFF
+#define BF_PXP_S0COLORKEYLOW_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_S0COLORKEYLOW_PIXEL)
+
+#define HW_PXP_S0COLORKEYHIGH	(0x00000190)
+
+#define BP_PXP_S0COLORKEYHIGH_RSVD1	24
+#define BM_PXP_S0COLORKEYHIGH_RSVD1	0xFF000000
+#define BF_PXP_S0COLORKEYHIGH_RSVD1(v) \
+		(((v) << 24) & BM_PXP_S0COLORKEYHIGH_RSVD1)
+#define BP_PXP_S0COLORKEYHIGH_PIXEL	0
+#define BM_PXP_S0COLORKEYHIGH_PIXEL	0x00FFFFFF
+#define BF_PXP_S0COLORKEYHIGH_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_S0COLORKEYHIGH_PIXEL)
+
+#define HW_PXP_OLCOLORKEYLOW	(0x000001a0)
+
+#define BP_PXP_OLCOLORKEYLOW_RSVD1	24
+#define BM_PXP_OLCOLORKEYLOW_RSVD1	0xFF000000
+#define BF_PXP_OLCOLORKEYLOW_RSVD1(v) \
+		(((v) << 24) & BM_PXP_OLCOLORKEYLOW_RSVD1)
+#define BP_PXP_OLCOLORKEYLOW_PIXEL	0
+#define BM_PXP_OLCOLORKEYLOW_PIXEL	0x00FFFFFF
+#define BF_PXP_OLCOLORKEYLOW_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_OLCOLORKEYLOW_PIXEL)
+
+#define HW_PXP_OLCOLORKEYHIGH	(0x000001b0)
+
+#define BP_PXP_OLCOLORKEYHIGH_RSVD1	24
+#define BM_PXP_OLCOLORKEYHIGH_RSVD1	0xFF000000
+#define BF_PXP_OLCOLORKEYHIGH_RSVD1(v) \
+		(((v) << 24) & BM_PXP_OLCOLORKEYHIGH_RSVD1)
+#define BP_PXP_OLCOLORKEYHIGH_PIXEL	0
+#define BM_PXP_OLCOLORKEYHIGH_PIXEL	0x00FFFFFF
+#define BF_PXP_OLCOLORKEYHIGH_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_OLCOLORKEYHIGH_PIXEL)
+
+#define HW_PXP_DEBUGCTRL	(0x000001d0)
+
+#define BP_PXP_DEBUGCTRL_RSVD	9
+#define BM_PXP_DEBUGCTRL_RSVD	0xFFFFFE00
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+		(((v) << 9) & BM_PXP_DEBUGCTRL_RSVD)
+#define BM_PXP_DEBUGCTRL_RESET_TLB_STATS	0x00000100
+#define BP_PXP_DEBUGCTRL_SELECT	0
+#define BM_PXP_DEBUGCTRL_SELECT	0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+		(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__S0REGS   0x2
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAX    0x3
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAY    0x4
+#define BV_PXP_DEBUGCTRL_SELECT__PXBUF    0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION 0x6
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF0  0x7
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF1  0x8
+
+#define HW_PXP_DEBUG	(0x000001e0)
+
+#define BP_PXP_DEBUG_DATA	0
+#define BM_PXP_DEBUG_DATA	0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)	(v)
+
+#define HW_PXP_VERSION	(0x000001f0)
+
+#define BP_PXP_VERSION_MAJOR	24
+#define BM_PXP_VERSION_MAJOR	0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR	16
+#define BM_PXP_VERSION_MINOR	0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP	0
+#define BM_PXP_VERSION_STEP	0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_PXP_VERSION_STEP)
+
+/*
+ *  multi-register-define name HW_PXP_OLn
+ *              base 0x00000200
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLn(n)	(0x00000200 + (n) * 0x40)
+#define BP_PXP_OLn_ADDR	0
+#define BM_PXP_OLn_ADDR	0xFFFFFFFF
+#define BF_PXP_OLn_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_PXP_OLnSIZE
+ *              base 0x00000210
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnSIZE(n)	(0x00000210 + (n) * 0x40)
+#define BP_PXP_OLnSIZE_XBASE	24
+#define BM_PXP_OLnSIZE_XBASE	0xFF000000
+#define BF_PXP_OLnSIZE_XBASE(v) \
+		(((v) << 24) & BM_PXP_OLnSIZE_XBASE)
+#define BP_PXP_OLnSIZE_YBASE	16
+#define BM_PXP_OLnSIZE_YBASE	0x00FF0000
+#define BF_PXP_OLnSIZE_YBASE(v)  \
+		(((v) << 16) & BM_PXP_OLnSIZE_YBASE)
+#define BP_PXP_OLnSIZE_WIDTH	8
+#define BM_PXP_OLnSIZE_WIDTH	0x0000FF00
+#define BF_PXP_OLnSIZE_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_OLnSIZE_WIDTH)
+#define BP_PXP_OLnSIZE_HEIGHT	0
+#define BM_PXP_OLnSIZE_HEIGHT	0x000000FF
+#define BF_PXP_OLnSIZE_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_OLnSIZE_HEIGHT)
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM
+ *              base 0x00000220
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM(n)	(0x00000220 + (n) * 0x40)
+#define BP_PXP_OLnPARAM_RSVD1	20
+#define BM_PXP_OLnPARAM_RSVD1	0xFFF00000
+#define BF_PXP_OLnPARAM_RSVD1(v) \
+		(((v) << 20) & BM_PXP_OLnPARAM_RSVD1)
+#define BP_PXP_OLnPARAM_ROP	16
+#define BM_PXP_OLnPARAM_ROP	0x000F0000
+#define BF_PXP_OLnPARAM_ROP(v)  \
+		(((v) << 16) & BM_PXP_OLnPARAM_ROP)
+#define BV_PXP_OLnPARAM_ROP__MASKOL     0x0
+#define BV_PXP_OLnPARAM_ROP__MASKNOTOL  0x1
+#define BV_PXP_OLnPARAM_ROP__MASKOLNOT  0x2
+#define BV_PXP_OLnPARAM_ROP__MERGEOL    0x3
+#define BV_PXP_OLnPARAM_ROP__MERGENOTOL 0x4
+#define BV_PXP_OLnPARAM_ROP__MERGEOLNOT 0x5
+#define BV_PXP_OLnPARAM_ROP__NOTCOPYOL  0x6
+#define BV_PXP_OLnPARAM_ROP__NOT        0x7
+#define BV_PXP_OLnPARAM_ROP__NOTMASKOL  0x8
+#define BV_PXP_OLnPARAM_ROP__NOTMERGEOL 0x9
+#define BV_PXP_OLnPARAM_ROP__XOROL      0xA
+#define BV_PXP_OLnPARAM_ROP__NOTXOROL   0xB
+#define BP_PXP_OLnPARAM_ALPHA	8
+#define BM_PXP_OLnPARAM_ALPHA	0x0000FF00
+#define BF_PXP_OLnPARAM_ALPHA(v)  \
+		(((v) << 8) & BM_PXP_OLnPARAM_ALPHA)
+#define BP_PXP_OLnPARAM_FORMAT	4
+#define BM_PXP_OLnPARAM_FORMAT	0x000000F0
+#define BF_PXP_OLnPARAM_FORMAT(v)  \
+		(((v) << 4) & BM_PXP_OLnPARAM_FORMAT)
+#define BV_PXP_OLnPARAM_FORMAT__ARGB8888 0x0
+#define BV_PXP_OLnPARAM_FORMAT__RGB888   0x1
+#define BV_PXP_OLnPARAM_FORMAT__ARGB1555 0x3
+#define BV_PXP_OLnPARAM_FORMAT__RGB565   0x4
+#define BV_PXP_OLnPARAM_FORMAT__RGB555   0x5
+#define BM_PXP_OLnPARAM_ENABLE_COLORKEY	0x00000008
+#define BP_PXP_OLnPARAM_ALPHA_CNTL	1
+#define BM_PXP_OLnPARAM_ALPHA_CNTL	0x00000006
+#define BF_PXP_OLnPARAM_ALPHA_CNTL(v)  \
+		(((v) << 1) & BM_PXP_OLnPARAM_ALPHA_CNTL)
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Embedded 0x0
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Override 0x1
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Multiply 0x2
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__ROPs     0x3
+#define BM_PXP_OLnPARAM_ENABLE	0x00000001
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM2
+ *              base 0x00000230
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM2(n)	(0x00000230 + (n) * 0x40)
+#define BP_PXP_OLnPARAM2_RSVD	0
+#define BM_PXP_OLnPARAM2_RSVD	0xFFFFFFFF
+#define BF_PXP_OLnPARAM2_RSVD(v)	(v)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-rtc.h b/arch/arm/mach-mx23/include/mach/regs-rtc.h
new file mode 100644
index 0000000..a953a1d
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-rtc.h
@@ -0,0 +1,219 @@
+/*
+ * Freescale RTC Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.75
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___RTC_H
+#define __ARCH_ARM___RTC_H
+
+
+#define HW_RTC_CTRL	(0x00000000)
+#define HW_RTC_CTRL_SET	(0x00000004)
+#define HW_RTC_CTRL_CLR	(0x00000008)
+#define HW_RTC_CTRL_TOG	(0x0000000c)
+
+#define BM_RTC_CTRL_SFTRST	0x80000000
+#define BM_RTC_CTRL_CLKGATE	0x40000000
+#define BP_RTC_CTRL_RSVD0	7
+#define BM_RTC_CTRL_RSVD0	0x3FFFFF80
+#define BF_RTC_CTRL_RSVD0(v)  \
+		(((v) << 7) & BM_RTC_CTRL_RSVD0)
+#define BM_RTC_CTRL_SUPPRESS_COPY2ANALOG	0x00000040
+#define BM_RTC_CTRL_FORCE_UPDATE	0x00000020
+#define BM_RTC_CTRL_WATCHDOGEN	0x00000010
+#define BM_RTC_CTRL_ONEMSEC_IRQ	0x00000008
+#define BM_RTC_CTRL_ALARM_IRQ	0x00000004
+#define BM_RTC_CTRL_ONEMSEC_IRQ_EN	0x00000002
+#define BM_RTC_CTRL_ALARM_IRQ_EN	0x00000001
+
+#define HW_RTC_STAT	(0x00000010)
+#define HW_RTC_STAT_SET	(0x00000014)
+#define HW_RTC_STAT_CLR	(0x00000018)
+#define HW_RTC_STAT_TOG	(0x0000001c)
+
+#define BM_RTC_STAT_RTC_PRESENT	0x80000000
+#define BM_RTC_STAT_ALARM_PRESENT	0x40000000
+#define BM_RTC_STAT_WATCHDOG_PRESENT	0x20000000
+#define BM_RTC_STAT_XTAL32000_PRESENT	0x10000000
+#define BM_RTC_STAT_XTAL32768_PRESENT	0x08000000
+#define BP_RTC_STAT_RSVD1	24
+#define BM_RTC_STAT_RSVD1	0x07000000
+#define BF_RTC_STAT_RSVD1(v)  \
+		(((v) << 24) & BM_RTC_STAT_RSVD1)
+#define BP_RTC_STAT_STALE_REGS	16
+#define BM_RTC_STAT_STALE_REGS	0x00FF0000
+#define BF_RTC_STAT_STALE_REGS(v)  \
+		(((v) << 16) & BM_RTC_STAT_STALE_REGS)
+#define BP_RTC_STAT_NEW_REGS	8
+#define BM_RTC_STAT_NEW_REGS	0x0000FF00
+#define BF_RTC_STAT_NEW_REGS(v)  \
+		(((v) << 8) & BM_RTC_STAT_NEW_REGS)
+#define BP_RTC_STAT_RSVD0	0
+#define BM_RTC_STAT_RSVD0	0x000000FF
+#define BF_RTC_STAT_RSVD0(v)  \
+		(((v) << 0) & BM_RTC_STAT_RSVD0)
+
+#define HW_RTC_MILLISECONDS	(0x00000020)
+#define HW_RTC_MILLISECONDS_SET	(0x00000024)
+#define HW_RTC_MILLISECONDS_CLR	(0x00000028)
+#define HW_RTC_MILLISECONDS_TOG	(0x0000002c)
+
+#define BP_RTC_MILLISECONDS_COUNT	0
+#define BM_RTC_MILLISECONDS_COUNT	0xFFFFFFFF
+#define BF_RTC_MILLISECONDS_COUNT(v)	(v)
+
+#define HW_RTC_SECONDS	(0x00000030)
+#define HW_RTC_SECONDS_SET	(0x00000034)
+#define HW_RTC_SECONDS_CLR	(0x00000038)
+#define HW_RTC_SECONDS_TOG	(0x0000003c)
+
+#define BP_RTC_SECONDS_COUNT	0
+#define BM_RTC_SECONDS_COUNT	0xFFFFFFFF
+#define BF_RTC_SECONDS_COUNT(v)	(v)
+
+#define HW_RTC_ALARM	(0x00000040)
+#define HW_RTC_ALARM_SET	(0x00000044)
+#define HW_RTC_ALARM_CLR	(0x00000048)
+#define HW_RTC_ALARM_TOG	(0x0000004c)
+
+#define BP_RTC_ALARM_VALUE	0
+#define BM_RTC_ALARM_VALUE	0xFFFFFFFF
+#define BF_RTC_ALARM_VALUE(v)	(v)
+
+#define HW_RTC_WATCHDOG	(0x00000050)
+#define HW_RTC_WATCHDOG_SET	(0x00000054)
+#define HW_RTC_WATCHDOG_CLR	(0x00000058)
+#define HW_RTC_WATCHDOG_TOG	(0x0000005c)
+
+#define BP_RTC_WATCHDOG_COUNT	0
+#define BM_RTC_WATCHDOG_COUNT	0xFFFFFFFF
+#define BF_RTC_WATCHDOG_COUNT(v)	(v)
+
+#define HW_RTC_PERSISTENT0	(0x00000060)
+#define HW_RTC_PERSISTENT0_SET	(0x00000064)
+#define HW_RTC_PERSISTENT0_CLR	(0x00000068)
+#define HW_RTC_PERSISTENT0_TOG	(0x0000006c)
+
+#define BP_RTC_PERSISTENT0_SPARE_ANALOG	18
+#define BM_RTC_PERSISTENT0_SPARE_ANALOG	0xFFFC0000
+#define BF_RTC_PERSISTENT0_SPARE_ANALOG(v) \
+		(((v) << 18) & BM_RTC_PERSISTENT0_SPARE_ANALOG)
+#define BM_RTC_PERSISTENT0_AUTO_RESTART	0x00020000
+#define BM_RTC_PERSISTENT0_DISABLE_PSWITCH	0x00010000
+#define BP_RTC_PERSISTENT0_LOWERBIAS	14
+#define BM_RTC_PERSISTENT0_LOWERBIAS	0x0000C000
+#define BF_RTC_PERSISTENT0_LOWERBIAS(v)  \
+		(((v) << 14) & BM_RTC_PERSISTENT0_LOWERBIAS)
+#define BM_RTC_PERSISTENT0_DISABLE_XTALOK	0x00002000
+#define BP_RTC_PERSISTENT0_MSEC_RES	8
+#define BM_RTC_PERSISTENT0_MSEC_RES	0x00001F00
+#define BF_RTC_PERSISTENT0_MSEC_RES(v)  \
+		(((v) << 8) & BM_RTC_PERSISTENT0_MSEC_RES)
+#define BM_RTC_PERSISTENT0_ALARM_WAKE	0x00000080
+#define BM_RTC_PERSISTENT0_XTAL32_FREQ	0x00000040
+#define BM_RTC_PERSISTENT0_XTAL32KHZ_PWRUP	0x00000020
+#define BM_RTC_PERSISTENT0_XTAL24MHZ_PWRUP	0x00000010
+#define BM_RTC_PERSISTENT0_LCK_SECS	0x00000008
+#define BM_RTC_PERSISTENT0_ALARM_EN	0x00000004
+#define BM_RTC_PERSISTENT0_ALARM_WAKE_EN	0x00000002
+#define BM_RTC_PERSISTENT0_CLOCKSOURCE	0x00000001
+
+#define HW_RTC_PERSISTENT1	(0x00000070)
+#define HW_RTC_PERSISTENT1_SET	(0x00000074)
+#define HW_RTC_PERSISTENT1_CLR	(0x00000078)
+#define HW_RTC_PERSISTENT1_TOG	(0x0000007c)
+
+#define BP_RTC_PERSISTENT1_GENERAL	0
+#define BM_RTC_PERSISTENT1_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT1_GENERAL(v)	(v)
+#define BV_RTC_PERSISTENT1_GENERAL__ENUMERATE_500MA_TWICE 0x1000
+#define BV_RTC_PERSISTENT1_GENERAL__USB_BOOT_PLAYER_MODE  0x0800
+#define BV_RTC_PERSISTENT1_GENERAL__SKIP_CHECKDISK        0x0400
+#define BV_RTC_PERSISTENT1_GENERAL__USB_LOW_POWER_MODE    0x0200
+#define BV_RTC_PERSISTENT1_GENERAL__OTG_HNP_BIT           0x0100
+#define BV_RTC_PERSISTENT1_GENERAL__OTG_ATL_ROLE_BIT      0x0080
+
+#define HW_RTC_PERSISTENT2	(0x00000080)
+#define HW_RTC_PERSISTENT2_SET	(0x00000084)
+#define HW_RTC_PERSISTENT2_CLR	(0x00000088)
+#define HW_RTC_PERSISTENT2_TOG	(0x0000008c)
+
+#define BP_RTC_PERSISTENT2_GENERAL	0
+#define BM_RTC_PERSISTENT2_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT2_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT3	(0x00000090)
+#define HW_RTC_PERSISTENT3_SET	(0x00000094)
+#define HW_RTC_PERSISTENT3_CLR	(0x00000098)
+#define HW_RTC_PERSISTENT3_TOG	(0x0000009c)
+
+#define BP_RTC_PERSISTENT3_GENERAL	0
+#define BM_RTC_PERSISTENT3_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT3_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT4	(0x000000a0)
+#define HW_RTC_PERSISTENT4_SET	(0x000000a4)
+#define HW_RTC_PERSISTENT4_CLR	(0x000000a8)
+#define HW_RTC_PERSISTENT4_TOG	(0x000000ac)
+
+#define BP_RTC_PERSISTENT4_GENERAL	0
+#define BM_RTC_PERSISTENT4_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT4_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT5	(0x000000b0)
+#define HW_RTC_PERSISTENT5_SET	(0x000000b4)
+#define HW_RTC_PERSISTENT5_CLR	(0x000000b8)
+#define HW_RTC_PERSISTENT5_TOG	(0x000000bc)
+
+#define BP_RTC_PERSISTENT5_GENERAL	0
+#define BM_RTC_PERSISTENT5_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT5_GENERAL(v)	(v)
+
+#define HW_RTC_DEBUG	(0x000000c0)
+#define HW_RTC_DEBUG_SET	(0x000000c4)
+#define HW_RTC_DEBUG_CLR	(0x000000c8)
+#define HW_RTC_DEBUG_TOG	(0x000000cc)
+
+#define BP_RTC_DEBUG_RSVD0	2
+#define BM_RTC_DEBUG_RSVD0	0xFFFFFFFC
+#define BF_RTC_DEBUG_RSVD0(v) \
+		(((v) << 2) & BM_RTC_DEBUG_RSVD0)
+#define BM_RTC_DEBUG_WATCHDOG_RESET_MASK	0x00000002
+#define BM_RTC_DEBUG_WATCHDOG_RESET	0x00000001
+
+#define HW_RTC_VERSION	(0x000000d0)
+
+#define BP_RTC_VERSION_MAJOR	24
+#define BM_RTC_VERSION_MAJOR	0xFF000000
+#define BF_RTC_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_RTC_VERSION_MAJOR)
+#define BP_RTC_VERSION_MINOR	16
+#define BM_RTC_VERSION_MINOR	0x00FF0000
+#define BF_RTC_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_RTC_VERSION_MINOR)
+#define BP_RTC_VERSION_STEP	0
+#define BM_RTC_VERSION_STEP	0x0000FFFF
+#define BF_RTC_VERSION_STEP(v)  \
+		(((v) << 0) & BM_RTC_VERSION_STEP)
+#endif /* __ARCH_ARM___RTC_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-ssp.h b/arch/arm/mach-mx23/include/mach/regs-ssp.h
new file mode 100644
index 0000000..cdc07f8
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-ssp.h
@@ -0,0 +1,392 @@
+/*
+ * Freescale SSP Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 2.0
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___SSP_H
+#define __ARCH_ARM___SSP_H
+
+
+#define HW_SSP_CTRL0	(0x00000000)
+#define HW_SSP_CTRL0_SET	(0x00000004)
+#define HW_SSP_CTRL0_CLR	(0x00000008)
+#define HW_SSP_CTRL0_TOG	(0x0000000c)
+
+#define BM_SSP_CTRL0_SFTRST	0x80000000
+#define BM_SSP_CTRL0_CLKGATE	0x40000000
+#define BM_SSP_CTRL0_RUN	0x20000000
+#define BM_SSP_CTRL0_SDIO_IRQ_CHECK	0x10000000
+#define BM_SSP_CTRL0_LOCK_CS	0x08000000
+#define BM_SSP_CTRL0_IGNORE_CRC	0x04000000
+#define BM_SSP_CTRL0_READ	0x02000000
+#define BM_SSP_CTRL0_DATA_XFER	0x01000000
+#define BP_SSP_CTRL0_BUS_WIDTH	22
+#define BM_SSP_CTRL0_BUS_WIDTH	0x00C00000
+#define BF_SSP_CTRL0_BUS_WIDTH(v)  \
+		(((v) << 22) & BM_SSP_CTRL0_BUS_WIDTH)
+#define BV_SSP_CTRL0_BUS_WIDTH__ONE_BIT   0x0
+#define BV_SSP_CTRL0_BUS_WIDTH__FOUR_BIT  0x1
+#define BV_SSP_CTRL0_BUS_WIDTH__EIGHT_BIT 0x2
+#define BM_SSP_CTRL0_WAIT_FOR_IRQ	0x00200000
+#define BM_SSP_CTRL0_WAIT_FOR_CMD	0x00100000
+#define BM_SSP_CTRL0_LONG_RESP	0x00080000
+#define BM_SSP_CTRL0_CHECK_RESP	0x00040000
+#define BM_SSP_CTRL0_GET_RESP	0x00020000
+#define BM_SSP_CTRL0_ENABLE	0x00010000
+#define BP_SSP_CTRL0_XFER_COUNT	0
+#define BM_SSP_CTRL0_XFER_COUNT	0x0000FFFF
+#define BF_SSP_CTRL0_XFER_COUNT(v)  \
+		(((v) << 0) & BM_SSP_CTRL0_XFER_COUNT)
+
+#define HW_SSP_CMD0	(0x00000010)
+#define HW_SSP_CMD0_SET	(0x00000014)
+#define HW_SSP_CMD0_CLR	(0x00000018)
+#define HW_SSP_CMD0_TOG	(0x0000001c)
+
+#define BP_SSP_CMD0_RSVD0	23
+#define BM_SSP_CMD0_RSVD0	0xFF800000
+#define BF_SSP_CMD0_RSVD0(v) \
+		(((v) << 23) & BM_SSP_CMD0_RSVD0)
+#define BM_SSP_CMD0_SLOW_CLKING_EN	0x00400000
+#define BM_SSP_CMD0_CONT_CLKING_EN	0x00200000
+#define BM_SSP_CMD0_APPEND_8CYC	0x00100000
+#define BP_SSP_CMD0_BLOCK_SIZE	16
+#define BM_SSP_CMD0_BLOCK_SIZE	0x000F0000
+#define BF_SSP_CMD0_BLOCK_SIZE(v)  \
+		(((v) << 16) & BM_SSP_CMD0_BLOCK_SIZE)
+#define BP_SSP_CMD0_BLOCK_COUNT	8
+#define BM_SSP_CMD0_BLOCK_COUNT	0x0000FF00
+#define BF_SSP_CMD0_BLOCK_COUNT(v)  \
+		(((v) << 8) & BM_SSP_CMD0_BLOCK_COUNT)
+#define BP_SSP_CMD0_CMD	0
+#define BM_SSP_CMD0_CMD	0x000000FF
+#define BF_SSP_CMD0_CMD(v)  \
+		(((v) << 0) & BM_SSP_CMD0_CMD)
+#define BV_SSP_CMD0_CMD__MMC_GO_IDLE_STATE        0x00
+#define BV_SSP_CMD0_CMD__MMC_SEND_OP_COND         0x01
+#define BV_SSP_CMD0_CMD__MMC_ALL_SEND_CID         0x02
+#define BV_SSP_CMD0_CMD__MMC_SET_RELATIVE_ADDR    0x03
+#define BV_SSP_CMD0_CMD__MMC_SET_DSR              0x04
+#define BV_SSP_CMD0_CMD__MMC_RESERVED_5           0x05
+#define BV_SSP_CMD0_CMD__MMC_SWITCH               0x06
+#define BV_SSP_CMD0_CMD__MMC_SELECT_DESELECT_CARD 0x07
+#define BV_SSP_CMD0_CMD__MMC_SEND_EXT_CSD         0x08
+#define BV_SSP_CMD0_CMD__MMC_SEND_CSD             0x09
+#define BV_SSP_CMD0_CMD__MMC_SEND_CID             0x0A
+#define BV_SSP_CMD0_CMD__MMC_READ_DAT_UNTIL_STOP  0x0B
+#define BV_SSP_CMD0_CMD__MMC_STOP_TRANSMISSION    0x0C
+#define BV_SSP_CMD0_CMD__MMC_SEND_STATUS          0x0D
+#define BV_SSP_CMD0_CMD__MMC_BUSTEST_R            0x0E
+#define BV_SSP_CMD0_CMD__MMC_GO_INACTIVE_STATE    0x0F
+#define BV_SSP_CMD0_CMD__MMC_SET_BLOCKLEN         0x10
+#define BV_SSP_CMD0_CMD__MMC_READ_SINGLE_BLOCK    0x11
+#define BV_SSP_CMD0_CMD__MMC_READ_MULTIPLE_BLOCK  0x12
+#define BV_SSP_CMD0_CMD__MMC_BUSTEST_W            0x13
+#define BV_SSP_CMD0_CMD__MMC_WRITE_DAT_UNTIL_STOP 0x14
+#define BV_SSP_CMD0_CMD__MMC_SET_BLOCK_COUNT      0x17
+#define BV_SSP_CMD0_CMD__MMC_WRITE_BLOCK          0x18
+#define BV_SSP_CMD0_CMD__MMC_WRITE_MULTIPLE_BLOCK 0x19
+#define BV_SSP_CMD0_CMD__MMC_PROGRAM_CID          0x1A
+#define BV_SSP_CMD0_CMD__MMC_PROGRAM_CSD          0x1B
+#define BV_SSP_CMD0_CMD__MMC_SET_WRITE_PROT       0x1C
+#define BV_SSP_CMD0_CMD__MMC_CLR_WRITE_PROT       0x1D
+#define BV_SSP_CMD0_CMD__MMC_SEND_WRITE_PROT      0x1E
+#define BV_SSP_CMD0_CMD__MMC_ERASE_GROUP_START    0x23
+#define BV_SSP_CMD0_CMD__MMC_ERASE_GROUP_END      0x24
+#define BV_SSP_CMD0_CMD__MMC_ERASE                0x26
+#define BV_SSP_CMD0_CMD__MMC_FAST_IO              0x27
+#define BV_SSP_CMD0_CMD__MMC_GO_IRQ_STATE         0x28
+#define BV_SSP_CMD0_CMD__MMC_LOCK_UNLOCK          0x2A
+#define BV_SSP_CMD0_CMD__MMC_APP_CMD              0x37
+#define BV_SSP_CMD0_CMD__MMC_GEN_CMD              0x38
+#define BV_SSP_CMD0_CMD__SD_GO_IDLE_STATE         0x00
+#define BV_SSP_CMD0_CMD__SD_ALL_SEND_CID          0x02
+#define BV_SSP_CMD0_CMD__SD_SEND_RELATIVE_ADDR    0x03
+#define BV_SSP_CMD0_CMD__SD_SET_DSR               0x04
+#define BV_SSP_CMD0_CMD__SD_IO_SEND_OP_COND       0x05
+#define BV_SSP_CMD0_CMD__SD_SELECT_DESELECT_CARD  0x07
+#define BV_SSP_CMD0_CMD__SD_SEND_CSD              0x09
+#define BV_SSP_CMD0_CMD__SD_SEND_CID              0x0A
+#define BV_SSP_CMD0_CMD__SD_STOP_TRANSMISSION     0x0C
+#define BV_SSP_CMD0_CMD__SD_SEND_STATUS           0x0D
+#define BV_SSP_CMD0_CMD__SD_GO_INACTIVE_STATE     0x0F
+#define BV_SSP_CMD0_CMD__SD_SET_BLOCKLEN          0x10
+#define BV_SSP_CMD0_CMD__SD_READ_SINGLE_BLOCK     0x11
+#define BV_SSP_CMD0_CMD__SD_READ_MULTIPLE_BLOCK   0x12
+#define BV_SSP_CMD0_CMD__SD_WRITE_BLOCK           0x18
+#define BV_SSP_CMD0_CMD__SD_WRITE_MULTIPLE_BLOCK  0x19
+#define BV_SSP_CMD0_CMD__SD_PROGRAM_CSD           0x1B
+#define BV_SSP_CMD0_CMD__SD_SET_WRITE_PROT        0x1C
+#define BV_SSP_CMD0_CMD__SD_CLR_WRITE_PROT        0x1D
+#define BV_SSP_CMD0_CMD__SD_SEND_WRITE_PROT       0x1E
+#define BV_SSP_CMD0_CMD__SD_ERASE_WR_BLK_START    0x20
+#define BV_SSP_CMD0_CMD__SD_ERASE_WR_BLK_END      0x21
+#define BV_SSP_CMD0_CMD__SD_ERASE_GROUP_START     0x23
+#define BV_SSP_CMD0_CMD__SD_ERASE_GROUP_END       0x24
+#define BV_SSP_CMD0_CMD__SD_ERASE                 0x26
+#define BV_SSP_CMD0_CMD__SD_LOCK_UNLOCK           0x2A
+#define BV_SSP_CMD0_CMD__SD_IO_RW_DIRECT          0x34
+#define BV_SSP_CMD0_CMD__SD_IO_RW_EXTENDED        0x35
+#define BV_SSP_CMD0_CMD__SD_APP_CMD               0x37
+#define BV_SSP_CMD0_CMD__SD_GEN_CMD               0x38
+
+#define HW_SSP_CMD1	(0x00000020)
+
+#define BP_SSP_CMD1_CMD_ARG	0
+#define BM_SSP_CMD1_CMD_ARG	0xFFFFFFFF
+#define BF_SSP_CMD1_CMD_ARG(v)	(v)
+
+#define HW_SSP_COMPREF	(0x00000030)
+
+#define BP_SSP_COMPREF_REFERENCE	0
+#define BM_SSP_COMPREF_REFERENCE	0xFFFFFFFF
+#define BF_SSP_COMPREF_REFERENCE(v)	(v)
+
+#define HW_SSP_COMPMASK	(0x00000040)
+
+#define BP_SSP_COMPMASK_MASK	0
+#define BM_SSP_COMPMASK_MASK	0xFFFFFFFF
+#define BF_SSP_COMPMASK_MASK(v)	(v)
+
+#define HW_SSP_TIMING	(0x00000050)
+
+#define BP_SSP_TIMING_TIMEOUT	16
+#define BM_SSP_TIMING_TIMEOUT	0xFFFF0000
+#define BF_SSP_TIMING_TIMEOUT(v) \
+		(((v) << 16) & BM_SSP_TIMING_TIMEOUT)
+#define BP_SSP_TIMING_CLOCK_DIVIDE	8
+#define BM_SSP_TIMING_CLOCK_DIVIDE	0x0000FF00
+#define BF_SSP_TIMING_CLOCK_DIVIDE(v)  \
+		(((v) << 8) & BM_SSP_TIMING_CLOCK_DIVIDE)
+#define BP_SSP_TIMING_CLOCK_RATE	0
+#define BM_SSP_TIMING_CLOCK_RATE	0x000000FF
+#define BF_SSP_TIMING_CLOCK_RATE(v)  \
+		(((v) << 0) & BM_SSP_TIMING_CLOCK_RATE)
+
+#define HW_SSP_CTRL1	(0x00000060)
+#define HW_SSP_CTRL1_SET	(0x00000064)
+#define HW_SSP_CTRL1_CLR	(0x00000068)
+#define HW_SSP_CTRL1_TOG	(0x0000006c)
+
+#define BM_SSP_CTRL1_SDIO_IRQ	0x80000000
+#define BM_SSP_CTRL1_SDIO_IRQ_EN	0x40000000
+#define BM_SSP_CTRL1_RESP_ERR_IRQ	0x20000000
+#define BM_SSP_CTRL1_RESP_ERR_IRQ_EN	0x10000000
+#define BM_SSP_CTRL1_RESP_TIMEOUT_IRQ	0x08000000
+#define BM_SSP_CTRL1_RESP_TIMEOUT_IRQ_EN	0x04000000
+#define BM_SSP_CTRL1_DATA_TIMEOUT_IRQ	0x02000000
+#define BM_SSP_CTRL1_DATA_TIMEOUT_IRQ_EN	0x01000000
+#define BM_SSP_CTRL1_DATA_CRC_IRQ	0x00800000
+#define BM_SSP_CTRL1_DATA_CRC_IRQ_EN	0x00400000
+#define BM_SSP_CTRL1_FIFO_UNDERRUN_IRQ	0x00200000
+#define BM_SSP_CTRL1_FIFO_UNDERRUN_EN	0x00100000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_IRQ	0x00080000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_IRQ_EN	0x00040000
+#define BM_SSP_CTRL1_RECV_TIMEOUT_IRQ	0x00020000
+#define BM_SSP_CTRL1_RECV_TIMEOUT_IRQ_EN	0x00010000
+#define BM_SSP_CTRL1_FIFO_OVERRUN_IRQ	0x00008000
+#define BM_SSP_CTRL1_FIFO_OVERRUN_IRQ_EN	0x00004000
+#define BM_SSP_CTRL1_DMA_ENABLE	0x00002000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_EN	0x00001000
+#define BM_SSP_CTRL1_SLAVE_OUT_DISABLE	0x00000800
+#define BM_SSP_CTRL1_PHASE	0x00000400
+#define BM_SSP_CTRL1_POLARITY	0x00000200
+#define BM_SSP_CTRL1_SLAVE_MODE	0x00000100
+#define BP_SSP_CTRL1_WORD_LENGTH	4
+#define BM_SSP_CTRL1_WORD_LENGTH	0x000000F0
+#define BF_SSP_CTRL1_WORD_LENGTH(v)  \
+		(((v) << 4) & BM_SSP_CTRL1_WORD_LENGTH)
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED0    0x0
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED1    0x1
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED2    0x2
+#define BV_SSP_CTRL1_WORD_LENGTH__FOUR_BITS    0x3
+#define BV_SSP_CTRL1_WORD_LENGTH__EIGHT_BITS   0x7
+#define BV_SSP_CTRL1_WORD_LENGTH__SIXTEEN_BITS 0xF
+#define BP_SSP_CTRL1_SSP_MODE	0
+#define BM_SSP_CTRL1_SSP_MODE	0x0000000F
+#define BF_SSP_CTRL1_SSP_MODE(v)  \
+		(((v) << 0) & BM_SSP_CTRL1_SSP_MODE)
+#define BV_SSP_CTRL1_SSP_MODE__SPI    0x0
+#define BV_SSP_CTRL1_SSP_MODE__SSI    0x1
+#define BV_SSP_CTRL1_SSP_MODE__SD_MMC 0x3
+#define BV_SSP_CTRL1_SSP_MODE__MS     0x4
+#define BV_SSP_CTRL1_SSP_MODE__CE_ATA 0x7
+
+#define HW_SSP_DATA	(0x00000070)
+
+#define BP_SSP_DATA_DATA	0
+#define BM_SSP_DATA_DATA	0xFFFFFFFF
+#define BF_SSP_DATA_DATA(v)	(v)
+
+#define HW_SSP_SDRESP0	(0x00000080)
+
+#define BP_SSP_SDRESP0_RESP0	0
+#define BM_SSP_SDRESP0_RESP0	0xFFFFFFFF
+#define BF_SSP_SDRESP0_RESP0(v)	(v)
+
+#define HW_SSP_SDRESP1	(0x00000090)
+
+#define BP_SSP_SDRESP1_RESP1	0
+#define BM_SSP_SDRESP1_RESP1	0xFFFFFFFF
+#define BF_SSP_SDRESP1_RESP1(v)	(v)
+
+#define HW_SSP_SDRESP2	(0x000000a0)
+
+#define BP_SSP_SDRESP2_RESP2	0
+#define BM_SSP_SDRESP2_RESP2	0xFFFFFFFF
+#define BF_SSP_SDRESP2_RESP2(v)	(v)
+
+#define HW_SSP_SDRESP3	(0x000000b0)
+
+#define BP_SSP_SDRESP3_RESP3	0
+#define BM_SSP_SDRESP3_RESP3	0xFFFFFFFF
+#define BF_SSP_SDRESP3_RESP3(v)	(v)
+
+#define HW_SSP_STATUS	(0x000000c0)
+
+#define BM_SSP_STATUS_PRESENT	0x80000000
+#define BM_SSP_STATUS_MS_PRESENT	0x40000000
+#define BM_SSP_STATUS_SD_PRESENT	0x20000000
+#define BM_SSP_STATUS_CARD_DETECT	0x10000000
+#define BP_SSP_STATUS_RSVD3	22
+#define BM_SSP_STATUS_RSVD3	0x0FC00000
+#define BF_SSP_STATUS_RSVD3(v)  \
+		(((v) << 22) & BM_SSP_STATUS_RSVD3)
+#define BM_SSP_STATUS_DMASENSE	0x00200000
+#define BM_SSP_STATUS_DMATERM	0x00100000
+#define BM_SSP_STATUS_DMAREQ	0x00080000
+#define BM_SSP_STATUS_DMAEND	0x00040000
+#define BM_SSP_STATUS_SDIO_IRQ	0x00020000
+#define BM_SSP_STATUS_RESP_CRC_ERR	0x00010000
+#define BM_SSP_STATUS_RESP_ERR	0x00008000
+#define BM_SSP_STATUS_RESP_TIMEOUT	0x00004000
+#define BM_SSP_STATUS_DATA_CRC_ERR	0x00002000
+#define BM_SSP_STATUS_TIMEOUT	0x00001000
+#define BM_SSP_STATUS_RECV_TIMEOUT_STAT	0x00000800
+#define BM_SSP_STATUS_CEATA_CCS_ERR	0x00000400
+#define BM_SSP_STATUS_FIFO_OVRFLW	0x00000200
+#define BM_SSP_STATUS_FIFO_FULL	0x00000100
+#define BP_SSP_STATUS_RSVD1	6
+#define BM_SSP_STATUS_RSVD1	0x000000C0
+#define BF_SSP_STATUS_RSVD1(v)  \
+		(((v) << 6) & BM_SSP_STATUS_RSVD1)
+#define BM_SSP_STATUS_FIFO_EMPTY	0x00000020
+#define BM_SSP_STATUS_FIFO_UNDRFLW	0x00000010
+#define BM_SSP_STATUS_CMD_BUSY	0x00000008
+#define BM_SSP_STATUS_DATA_BUSY	0x00000004
+#define BM_SSP_STATUS_RSVD0	0x00000002
+#define BM_SSP_STATUS_BUSY	0x00000001
+
+#define HW_SSP_DEBUG	(0x00000100)
+
+#define BP_SSP_DEBUG_DATACRC_ERR	28
+#define BM_SSP_DEBUG_DATACRC_ERR	0xF0000000
+#define BF_SSP_DEBUG_DATACRC_ERR(v) \
+		(((v) << 28) & BM_SSP_DEBUG_DATACRC_ERR)
+#define BM_SSP_DEBUG_DATA_STALL	0x08000000
+#define BP_SSP_DEBUG_DAT_SM	24
+#define BM_SSP_DEBUG_DAT_SM	0x07000000
+#define BF_SSP_DEBUG_DAT_SM(v)  \
+		(((v) << 24) & BM_SSP_DEBUG_DAT_SM)
+#define BV_SSP_DEBUG_DAT_SM__DSM_IDLE 0x0
+#define BV_SSP_DEBUG_DAT_SM__DSM_WORD 0x2
+#define BV_SSP_DEBUG_DAT_SM__DSM_CRC1 0x3
+#define BV_SSP_DEBUG_DAT_SM__DSM_CRC2 0x4
+#define BV_SSP_DEBUG_DAT_SM__DSM_END  0x5
+#define BP_SSP_DEBUG_MSTK_SM	20
+#define BM_SSP_DEBUG_MSTK_SM	0x00F00000
+#define BF_SSP_DEBUG_MSTK_SM(v)  \
+		(((v) << 20) & BM_SSP_DEBUG_MSTK_SM)
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_IDLE  0x0
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CKON  0x1
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS1   0x2
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_TPC   0x3
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS2   0x4
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_HDSHK 0x5
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS3   0x6
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_RW    0x7
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CRC1  0x8
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CRC2  0x9
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS0   0xA
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END1  0xB
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END2W 0xC
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END2R 0xD
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_DONE  0xE
+#define BM_SSP_DEBUG_CMD_OE	0x00080000
+#define BP_SSP_DEBUG_DMA_SM	16
+#define BM_SSP_DEBUG_DMA_SM	0x00070000
+#define BF_SSP_DEBUG_DMA_SM(v)  \
+		(((v) << 16) & BM_SSP_DEBUG_DMA_SM)
+#define BV_SSP_DEBUG_DMA_SM__DMA_IDLE   0x0
+#define BV_SSP_DEBUG_DMA_SM__DMA_DMAREQ 0x1
+#define BV_SSP_DEBUG_DMA_SM__DMA_DMAACK 0x2
+#define BV_SSP_DEBUG_DMA_SM__DMA_STALL  0x3
+#define BV_SSP_DEBUG_DMA_SM__DMA_BUSY   0x4
+#define BV_SSP_DEBUG_DMA_SM__DMA_DONE   0x5
+#define BV_SSP_DEBUG_DMA_SM__DMA_COUNT  0x6
+#define BP_SSP_DEBUG_MMC_SM	12
+#define BM_SSP_DEBUG_MMC_SM	0x0000F000
+#define BF_SSP_DEBUG_MMC_SM(v)  \
+		(((v) << 12) & BM_SSP_DEBUG_MMC_SM)
+#define BV_SSP_DEBUG_MMC_SM__MMC_IDLE 0x0
+#define BV_SSP_DEBUG_MMC_SM__MMC_CMD  0x1
+#define BV_SSP_DEBUG_MMC_SM__MMC_TRC  0x2
+#define BV_SSP_DEBUG_MMC_SM__MMC_RESP 0x3
+#define BV_SSP_DEBUG_MMC_SM__MMC_RPRX 0x4
+#define BV_SSP_DEBUG_MMC_SM__MMC_TX   0x5
+#define BV_SSP_DEBUG_MMC_SM__MMC_CTOK 0x6
+#define BV_SSP_DEBUG_MMC_SM__MMC_RX   0x7
+#define BV_SSP_DEBUG_MMC_SM__MMC_CCS  0x8
+#define BV_SSP_DEBUG_MMC_SM__MMC_PUP  0x9
+#define BV_SSP_DEBUG_MMC_SM__MMC_WAIT 0xA
+#define BP_SSP_DEBUG_CMD_SM	10
+#define BM_SSP_DEBUG_CMD_SM	0x00000C00
+#define BF_SSP_DEBUG_CMD_SM(v)  \
+		(((v) << 10) & BM_SSP_DEBUG_CMD_SM)
+#define BV_SSP_DEBUG_CMD_SM__CSM_IDLE  0x0
+#define BV_SSP_DEBUG_CMD_SM__CSM_INDEX 0x1
+#define BV_SSP_DEBUG_CMD_SM__CSM_ARG   0x2
+#define BV_SSP_DEBUG_CMD_SM__CSM_CRC   0x3
+#define BM_SSP_DEBUG_SSP_CMD	0x00000200
+#define BM_SSP_DEBUG_SSP_RESP	0x00000100
+#define BP_SSP_DEBUG_SSP_RXD	0
+#define BM_SSP_DEBUG_SSP_RXD	0x000000FF
+#define BF_SSP_DEBUG_SSP_RXD(v)  \
+		(((v) << 0) & BM_SSP_DEBUG_SSP_RXD)
+
+#define HW_SSP_VERSION	(0x00000110)
+
+#define BP_SSP_VERSION_MAJOR	24
+#define BM_SSP_VERSION_MAJOR	0xFF000000
+#define BF_SSP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_SSP_VERSION_MAJOR)
+#define BP_SSP_VERSION_MINOR	16
+#define BM_SSP_VERSION_MINOR	0x00FF0000
+#define BF_SSP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_SSP_VERSION_MINOR)
+#define BP_SSP_VERSION_STEP	0
+#define BM_SSP_VERSION_STEP	0x0000FFFF
+#define BF_SSP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_SSP_VERSION_STEP)
+#endif /* __ARCH_ARM___SSP_H */
diff --git a/arch/arm/mach-mx23/include/mach/regs-timrot.h b/arch/arm/mach-mx23/include/mach/regs-timrot.h
new file mode 100644
index 0000000..860709e
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regs-timrot.h
@@ -0,0 +1,257 @@
+/*
+ * Freescale TIMROT Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.38
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___TIMROT_H
+#define __ARCH_ARM___TIMROT_H
+
+
+#define HW_TIMROT_ROTCTRL	(0x00000000)
+#define HW_TIMROT_ROTCTRL_SET	(0x00000004)
+#define HW_TIMROT_ROTCTRL_CLR	(0x00000008)
+#define HW_TIMROT_ROTCTRL_TOG	(0x0000000c)
+
+#define BM_TIMROT_ROTCTRL_SFTRST	0x80000000
+#define BM_TIMROT_ROTCTRL_CLKGATE	0x40000000
+#define BM_TIMROT_ROTCTRL_ROTARY_PRESENT	0x20000000
+#define BM_TIMROT_ROTCTRL_TIM3_PRESENT	0x10000000
+#define BM_TIMROT_ROTCTRL_TIM2_PRESENT	0x08000000
+#define BM_TIMROT_ROTCTRL_TIM1_PRESENT	0x04000000
+#define BM_TIMROT_ROTCTRL_TIM0_PRESENT	0x02000000
+#define BP_TIMROT_ROTCTRL_STATE	22
+#define BM_TIMROT_ROTCTRL_STATE	0x01C00000
+#define BF_TIMROT_ROTCTRL_STATE(v)  \
+		(((v) << 22) & BM_TIMROT_ROTCTRL_STATE)
+#define BP_TIMROT_ROTCTRL_DIVIDER	16
+#define BM_TIMROT_ROTCTRL_DIVIDER	0x003F0000
+#define BF_TIMROT_ROTCTRL_DIVIDER(v)  \
+		(((v) << 16) & BM_TIMROT_ROTCTRL_DIVIDER)
+#define BP_TIMROT_ROTCTRL_RSRVD3	13
+#define BM_TIMROT_ROTCTRL_RSRVD3	0x0000E000
+#define BF_TIMROT_ROTCTRL_RSRVD3(v)  \
+		(((v) << 13) & BM_TIMROT_ROTCTRL_RSRVD3)
+#define BM_TIMROT_ROTCTRL_RELATIVE	0x00001000
+#define BP_TIMROT_ROTCTRL_OVERSAMPLE	10
+#define BM_TIMROT_ROTCTRL_OVERSAMPLE	0x00000C00
+#define BF_TIMROT_ROTCTRL_OVERSAMPLE(v)  \
+		(((v) << 10) & BM_TIMROT_ROTCTRL_OVERSAMPLE)
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__8X 0x0
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__4X 0x1
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__2X 0x2
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__1X 0x3
+#define BM_TIMROT_ROTCTRL_POLARITY_B	0x00000200
+#define BM_TIMROT_ROTCTRL_POLARITY_A	0x00000100
+#define BM_TIMROT_ROTCTRL_RSRVD2	0x00000080
+#define BP_TIMROT_ROTCTRL_SELECT_B	4
+#define BM_TIMROT_ROTCTRL_SELECT_B	0x00000070
+#define BF_TIMROT_ROTCTRL_SELECT_B(v)  \
+		(((v) << 4) & BM_TIMROT_ROTCTRL_SELECT_B)
+#define BV_TIMROT_ROTCTRL_SELECT_B__NEVER_TICK 0x0
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM0       0x1
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM1       0x2
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM2       0x3
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM3       0x4
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM4       0x5
+#define BV_TIMROT_ROTCTRL_SELECT_B__ROTARYA    0x6
+#define BV_TIMROT_ROTCTRL_SELECT_B__ROTARYB    0x7
+#define BM_TIMROT_ROTCTRL_RSRVD1	0x00000008
+#define BP_TIMROT_ROTCTRL_SELECT_A	0
+#define BM_TIMROT_ROTCTRL_SELECT_A	0x00000007
+#define BF_TIMROT_ROTCTRL_SELECT_A(v)  \
+		(((v) << 0) & BM_TIMROT_ROTCTRL_SELECT_A)
+#define BV_TIMROT_ROTCTRL_SELECT_A__NEVER_TICK 0x0
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM0       0x1
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM1       0x2
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM2       0x3
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM3       0x4
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM4       0x5
+#define BV_TIMROT_ROTCTRL_SELECT_A__ROTARYA    0x6
+#define BV_TIMROT_ROTCTRL_SELECT_A__ROTARYB    0x7
+
+#define HW_TIMROT_ROTCOUNT	(0x00000010)
+
+#define BP_TIMROT_ROTCOUNT_RSRVD1	16
+#define BM_TIMROT_ROTCOUNT_RSRVD1	0xFFFF0000
+#define BF_TIMROT_ROTCOUNT_RSRVD1(v) \
+		(((v) << 16) & BM_TIMROT_ROTCOUNT_RSRVD1)
+#define BP_TIMROT_ROTCOUNT_UPDOWN	0
+#define BM_TIMROT_ROTCOUNT_UPDOWN	0x0000FFFF
+#define BF_TIMROT_ROTCOUNT_UPDOWN(v)  \
+		(((v) << 0) & BM_TIMROT_ROTCOUNT_UPDOWN)
+
+/*
+ *  multi-register-define name HW_TIMROT_TIMCTRLn
+ *              base 0x00000020
+ *              count 3
+ *              offset 0x20
+ */
+#define HW_TIMROT_TIMCTRLn(n)	(0x00000020 + (n) * 0x20)
+#define HW_TIMROT_TIMCTRLn_SET(n)	(0x00000024 + (n) * 0x20)
+#define HW_TIMROT_TIMCTRLn_CLR(n)	(0x00000028 + (n) * 0x20)
+#define HW_TIMROT_TIMCTRLn_TOG(n)	(0x0000002c + (n) * 0x20)
+#define BP_TIMROT_TIMCTRLn_RSRVD2	16
+#define BM_TIMROT_TIMCTRLn_RSRVD2	0xFFFF0000
+#define BF_TIMROT_TIMCTRLn_RSRVD2(v) \
+		(((v) << 16) & BM_TIMROT_TIMCTRLn_RSRVD2)
+#define BM_TIMROT_TIMCTRLn_IRQ	0x00008000
+#define BM_TIMROT_TIMCTRLn_IRQ_EN	0x00004000
+#define BP_TIMROT_TIMCTRLn_RSRVD1	9
+#define BM_TIMROT_TIMCTRLn_RSRVD1	0x00003E00
+#define BF_TIMROT_TIMCTRLn_RSRVD1(v)  \
+		(((v) << 9) & BM_TIMROT_TIMCTRLn_RSRVD1)
+#define BM_TIMROT_TIMCTRLn_POLARITY	0x00000100
+#define BM_TIMROT_TIMCTRLn_UPDATE	0x00000080
+#define BM_TIMROT_TIMCTRLn_RELOAD	0x00000040
+#define BP_TIMROT_TIMCTRLn_PRESCALE	4
+#define BM_TIMROT_TIMCTRLn_PRESCALE	0x00000030
+#define BF_TIMROT_TIMCTRLn_PRESCALE(v)  \
+		(((v) << 4) & BM_TIMROT_TIMCTRLn_PRESCALE)
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_1 0x0
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_2 0x1
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_4 0x2
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_8 0x3
+#define BP_TIMROT_TIMCTRLn_SELECT	0
+#define BM_TIMROT_TIMCTRLn_SELECT	0x0000000F
+#define BF_TIMROT_TIMCTRLn_SELECT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCTRLn_SELECT)
+#define BV_TIMROT_TIMCTRLn_SELECT__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM0        0x1
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM1        0x2
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM2        0x3
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM3        0x4
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM4        0x5
+#define BV_TIMROT_TIMCTRLn_SELECT__ROTARYA     0x6
+#define BV_TIMROT_TIMCTRLn_SELECT__ROTARYB     0x7
+#define BV_TIMROT_TIMCTRLn_SELECT__32KHZ_XTAL  0x8
+#define BV_TIMROT_TIMCTRLn_SELECT__8KHZ_XTAL   0x9
+#define BV_TIMROT_TIMCTRLn_SELECT__4KHZ_XTAL   0xA
+#define BV_TIMROT_TIMCTRLn_SELECT__1KHZ_XTAL   0xB
+#define BV_TIMROT_TIMCTRLn_SELECT__TICK_ALWAYS 0xC
+
+/*
+ *  multi-register-define name HW_TIMROT_TIMCOUNTn
+ *              base 0x00000030
+ *              count 3
+ *              offset 0x20
+ */
+#define HW_TIMROT_TIMCOUNTn(n)	(0x00000030 + (n) * 0x20)
+#define BP_TIMROT_TIMCOUNTn_RUNNING_COUNT	16
+#define BM_TIMROT_TIMCOUNTn_RUNNING_COUNT	0xFFFF0000
+#define BF_TIMROT_TIMCOUNTn_RUNNING_COUNT(v) \
+		(((v) << 16) & BM_TIMROT_TIMCOUNTn_RUNNING_COUNT)
+#define BP_TIMROT_TIMCOUNTn_FIXED_COUNT	0
+#define BM_TIMROT_TIMCOUNTn_FIXED_COUNT	0x0000FFFF
+#define BF_TIMROT_TIMCOUNTn_FIXED_COUNT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCOUNTn_FIXED_COUNT)
+
+#define HW_TIMROT_TIMCTRL3	(0x00000080)
+#define HW_TIMROT_TIMCTRL3_SET	(0x00000084)
+#define HW_TIMROT_TIMCTRL3_CLR	(0x00000088)
+#define HW_TIMROT_TIMCTRL3_TOG	(0x0000008c)
+
+#define BP_TIMROT_TIMCTRL3_RSRVD2	20
+#define BM_TIMROT_TIMCTRL3_RSRVD2	0xFFF00000
+#define BF_TIMROT_TIMCTRL3_RSRVD2(v) \
+		(((v) << 20) & BM_TIMROT_TIMCTRL3_RSRVD2)
+#define BP_TIMROT_TIMCTRL3_TEST_SIGNAL	16
+#define BM_TIMROT_TIMCTRL3_TEST_SIGNAL	0x000F0000
+#define BF_TIMROT_TIMCTRL3_TEST_SIGNAL(v)  \
+		(((v) << 16) & BM_TIMROT_TIMCTRL3_TEST_SIGNAL)
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM0        0x1
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM1        0x2
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM2        0x3
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM3        0x4
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM4        0x5
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__ROTARYA     0x6
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__ROTARYB     0x7
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__32KHZ_XTAL  0x8
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__8KHZ_XTAL   0x9
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__4KHZ_XTAL   0xA
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__1KHZ_XTAL   0xB
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__TICK_ALWAYS 0xC
+#define BM_TIMROT_TIMCTRL3_IRQ	0x00008000
+#define BM_TIMROT_TIMCTRL3_IRQ_EN	0x00004000
+#define BP_TIMROT_TIMCTRL3_RSRVD1	11
+#define BM_TIMROT_TIMCTRL3_RSRVD1	0x00003800
+#define BF_TIMROT_TIMCTRL3_RSRVD1(v)  \
+		(((v) << 11) & BM_TIMROT_TIMCTRL3_RSRVD1)
+#define BM_TIMROT_TIMCTRL3_DUTY_VALID	0x00000400
+#define BM_TIMROT_TIMCTRL3_DUTY_CYCLE	0x00000200
+#define BM_TIMROT_TIMCTRL3_POLARITY	0x00000100
+#define BM_TIMROT_TIMCTRL3_UPDATE	0x00000080
+#define BM_TIMROT_TIMCTRL3_RELOAD	0x00000040
+#define BP_TIMROT_TIMCTRL3_PRESCALE	4
+#define BM_TIMROT_TIMCTRL3_PRESCALE	0x00000030
+#define BF_TIMROT_TIMCTRL3_PRESCALE(v)  \
+		(((v) << 4) & BM_TIMROT_TIMCTRL3_PRESCALE)
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_1 0x0
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_2 0x1
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_4 0x2
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_8 0x3
+#define BP_TIMROT_TIMCTRL3_SELECT	0
+#define BM_TIMROT_TIMCTRL3_SELECT	0x0000000F
+#define BF_TIMROT_TIMCTRL3_SELECT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCTRL3_SELECT)
+#define BV_TIMROT_TIMCTRL3_SELECT__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM0        0x1
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM1        0x2
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM2        0x3
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM3        0x4
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM4        0x5
+#define BV_TIMROT_TIMCTRL3_SELECT__ROTARYA     0x6
+#define BV_TIMROT_TIMCTRL3_SELECT__ROTARYB     0x7
+#define BV_TIMROT_TIMCTRL3_SELECT__32KHZ_XTAL  0x8
+#define BV_TIMROT_TIMCTRL3_SELECT__8KHZ_XTAL   0x9
+#define BV_TIMROT_TIMCTRL3_SELECT__4KHZ_XTAL   0xA
+#define BV_TIMROT_TIMCTRL3_SELECT__1KHZ_XTAL   0xB
+#define BV_TIMROT_TIMCTRL3_SELECT__TICK_ALWAYS 0xC
+
+#define HW_TIMROT_TIMCOUNT3	(0x00000090)
+
+#define BP_TIMROT_TIMCOUNT3_LOW_RUNNING_COUNT	16
+#define BM_TIMROT_TIMCOUNT3_LOW_RUNNING_COUNT	0xFFFF0000
+#define BF_TIMROT_TIMCOUNT3_LOW_RUNNING_COUNT(v) \
+		(((v) << 16) & BM_TIMROT_TIMCOUNT3_LOW_RUNNING_COUNT)
+#define BP_TIMROT_TIMCOUNT3_HIGH_FIXED_COUNT	0
+#define BM_TIMROT_TIMCOUNT3_HIGH_FIXED_COUNT	0x0000FFFF
+#define BF_TIMROT_TIMCOUNT3_HIGH_FIXED_COUNT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCOUNT3_HIGH_FIXED_COUNT)
+
+#define HW_TIMROT_VERSION	(0x000000a0)
+
+#define BP_TIMROT_VERSION_MAJOR	24
+#define BM_TIMROT_VERSION_MAJOR	0xFF000000
+#define BF_TIMROT_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_TIMROT_VERSION_MAJOR)
+#define BP_TIMROT_VERSION_MINOR	16
+#define BM_TIMROT_VERSION_MINOR	0x00FF0000
+#define BF_TIMROT_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_TIMROT_VERSION_MINOR)
+#define BP_TIMROT_VERSION_STEP	0
+#define BM_TIMROT_VERSION_STEP	0x0000FFFF
+#define BF_TIMROT_VERSION_STEP(v)  \
+		(((v) << 0) & BM_TIMROT_VERSION_STEP)
+#endif /* __ARCH_ARM___TIMROT_H */
diff --git a/arch/arm/mach-mx23/include/mach/regulator.h b/arch/arm/mach-mx23/include/mach/regulator.h
new file mode 100644
index 0000000..1b07358
--- /dev/null
+++ b/arch/arm/mach-mx23/include/mach/regulator.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __PLAT_REGULATOR_H_
+#define __PLAT_REGULATOR_H_
+
+#define MXS_REG5V_NOT_USB 0
+#define MXS_REG5V_IS_USB 1
+#define MXS_VDDD 0
+#define MXS_VDDA 1
+#define MXS_VDDIO 2
+#define MXS_VDDDBO 3
+#define MXS_OVERALL_CUR 4
+
+#endif
diff --git a/arch/arm/mach-mx23/mx23_pins.h b/arch/arm/mach-mx23/mx23_pins.h
new file mode 100644
index 0000000..9811bfd
--- /dev/null
+++ b/arch/arm/mach-mx23/mx23_pins.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * Author: Vladislav Buzov <vbuzov@embeddedalley.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_PINS_H
+#define __ASM_ARCH_PINS_H
+
+#include <mach/pinctrl.h>
+
+/*
+ * Define MX28 pins, the pin name corresponds to MX28 hardware
+ * interface this pin belongs to.
+ */
+
+/* Bank 0 */
+#define PINID_GPMI_D00		MXS_PIN_ENCODE(0, 0)
+#define PINID_GPMI_D01		MXS_PIN_ENCODE(0, 1)
+#define PINID_GPMI_D02		MXS_PIN_ENCODE(0, 2)
+#define PINID_GPMI_D03		MXS_PIN_ENCODE(0, 3)
+#define PINID_GPMI_D04		MXS_PIN_ENCODE(0, 4)
+#define PINID_GPMI_D05		MXS_PIN_ENCODE(0, 5)
+#define PINID_GPMI_D06		MXS_PIN_ENCODE(0, 6)
+#define PINID_GPMI_D07		MXS_PIN_ENCODE(0, 7)
+#define PINID_GPMI_D08		MXS_PIN_ENCODE(0, 8)
+#define PINID_GPMI_D09		MXS_PIN_ENCODE(0, 9)
+#define PINID_GPMI_D10		MXS_PIN_ENCODE(0, 10)
+#define PINID_GPMI_D11		MXS_PIN_ENCODE(0, 11)
+#define PINID_GPMI_D12		MXS_PIN_ENCODE(0, 12)
+#define PINID_GPMI_D13		MXS_PIN_ENCODE(0, 13)
+#define PINID_GPMI_D14		MXS_PIN_ENCODE(0, 14)
+#define PINID_GPMI_D15		MXS_PIN_ENCODE(0, 15)
+#define PINID_GPMI_CLE		MXS_PIN_ENCODE(0, 16)
+#define PINID_GPMI_ALE		MXS_PIN_ENCODE(0, 17)
+#define PINID_GPMI_CE2N		MXS_PIN_ENCODE(0, 18)
+#define PINID_GPMI_RDY0		MXS_PIN_ENCODE(0, 19)
+#define PINID_GPMI_RDY1		MXS_PIN_ENCODE(0, 20)
+#define PINID_GPMI_RDY2		MXS_PIN_ENCODE(0, 21)
+#define PINID_GPMI_RDY3		MXS_PIN_ENCODE(0, 22)
+#define PINID_GPMI_WPN		MXS_PIN_ENCODE(0, 23)
+#define PINID_GPMI_WRN		MXS_PIN_ENCODE(0, 24)
+#define PINID_GPMI_RDN		MXS_PIN_ENCODE(0, 25)
+#define PINID_AUART1_CTS	MXS_PIN_ENCODE(0, 26)
+#define PINID_AUART1_RTS	MXS_PIN_ENCODE(0, 27)
+#define PINID_AUART1_RX		MXS_PIN_ENCODE(0, 28)
+#define PINID_AUART1_TX		MXS_PIN_ENCODE(0, 29)
+#define PINID_I2C_SCL		MXS_PIN_ENCODE(0, 30)
+#define PINID_I2C_SDA		MXS_PIN_ENCODE(0, 31)
+
+/* Bank 1 */
+#define PINID_LCD_D00		MXS_PIN_ENCODE(1, 0)
+#define PINID_LCD_D01		MXS_PIN_ENCODE(1, 1)
+#define PINID_LCD_D02		MXS_PIN_ENCODE(1, 2)
+#define PINID_LCD_D03		MXS_PIN_ENCODE(1, 3)
+#define PINID_LCD_D04		MXS_PIN_ENCODE(1, 4)
+#define PINID_LCD_D05		MXS_PIN_ENCODE(1, 5)
+#define PINID_LCD_D06		MXS_PIN_ENCODE(1, 6)
+#define PINID_LCD_D07		MXS_PIN_ENCODE(1, 7)
+#define PINID_LCD_D08		MXS_PIN_ENCODE(1, 8)
+#define PINID_LCD_D09		MXS_PIN_ENCODE(1, 9)
+#define PINID_LCD_D10		MXS_PIN_ENCODE(1, 10)
+#define PINID_LCD_D11		MXS_PIN_ENCODE(1, 11)
+#define PINID_LCD_D12		MXS_PIN_ENCODE(1, 12)
+#define PINID_LCD_D13		MXS_PIN_ENCODE(1, 13)
+#define PINID_LCD_D14		MXS_PIN_ENCODE(1, 14)
+#define PINID_LCD_D15		MXS_PIN_ENCODE(1, 15)
+#define PINID_LCD_D16		MXS_PIN_ENCODE(1, 16)
+#define PINID_LCD_D17		MXS_PIN_ENCODE(1, 17)
+#define PINID_LCD_RESET		MXS_PIN_ENCODE(1, 18)
+#define PINID_LCD_RS		MXS_PIN_ENCODE(1, 19)
+#define PINID_LCD_WR		MXS_PIN_ENCODE(1, 20)
+#define PINID_LCD_CS		MXS_PIN_ENCODE(1, 21)
+#define PINID_LCD_DOTCK		MXS_PIN_ENCODE(1, 22)
+#define PINID_LCD_ENABLE	MXS_PIN_ENCODE(1, 23)
+#define PINID_LCD_HSYNC		MXS_PIN_ENCODE(1, 24)
+#define PINID_LCD_VSYNC		MXS_PIN_ENCODE(1, 25)
+#define PINID_PWM0		MXS_PIN_ENCODE(1, 26)
+#define PINID_PWM1		MXS_PIN_ENCODE(1, 27)
+#define PINID_PWM2		MXS_PIN_ENCODE(1, 28)
+#define PINID_PWM3		MXS_PIN_ENCODE(1, 29)
+#define PINID_PWM4		MXS_PIN_ENCODE(1, 30)
+
+/* Bank 2 */
+#define PINID_SSP1_CMD		MXS_PIN_ENCODE(2, 0)
+#define PINID_SSP1_DETECT	MXS_PIN_ENCODE(2, 1)
+#define PINID_SSP1_DATA0	MXS_PIN_ENCODE(2, 2)
+#define PINID_SSP1_DATA1	MXS_PIN_ENCODE(2, 3)
+#define PINID_SSP1_DATA2	MXS_PIN_ENCODE(2, 4)
+#define PINID_SSP1_DATA3	MXS_PIN_ENCODE(2, 5)
+#define PINID_SSP1_SCK		MXS_PIN_ENCODE(2, 6)
+#define PINID_ROTARYA		MXS_PIN_ENCODE(2, 7)
+#define PINID_ROTARYB		MXS_PIN_ENCODE(2, 8)
+#define PINID_EMI_A00		MXS_PIN_ENCODE(2, 9)
+#define PINID_EMI_A01		MXS_PIN_ENCODE(2, 10)
+#define PINID_EMI_A02		MXS_PIN_ENCODE(2, 11)
+#define PINID_EMI_A03		MXS_PIN_ENCODE(2, 12)
+#define PINID_EMI_A04		MXS_PIN_ENCODE(2, 13)
+#define PINID_EMI_A05		MXS_PIN_ENCODE(2, 14)
+#define PINID_EMI_A06		MXS_PIN_ENCODE(2, 15)
+#define PINID_EMI_A07		MXS_PIN_ENCODE(2, 16)
+#define PINID_EMI_A08		MXS_PIN_ENCODE(2, 17)
+#define PINID_EMI_A09		MXS_PIN_ENCODE(2, 18)
+#define PINID_EMI_A10		MXS_PIN_ENCODE(2, 19)
+#define PINID_EMI_A11		MXS_PIN_ENCODE(2, 20)
+#define PINID_EMI_A12		MXS_PIN_ENCODE(2, 21)
+#define PINID_EMI_BA0		MXS_PIN_ENCODE(2, 22)
+#define PINID_EMI_BA1		MXS_PIN_ENCODE(2, 23)
+#define PINID_EMI_CASN		MXS_PIN_ENCODE(2, 24)
+#define PINID_EMI_CE0N		MXS_PIN_ENCODE(2, 25)
+#define PINID_EMI_CE1N		MXS_PIN_ENCODE(2, 26)
+#define PINID_GPMI_CE1N		MXS_PIN_ENCODE(2, 27)
+#define PINID_GPMI_CE0N		MXS_PIN_ENCODE(2, 28)
+#define PINID_EMI_CKE		MXS_PIN_ENCODE(2, 29)
+#define PINID_EMI_RASN		MXS_PIN_ENCODE(2, 30)
+#define PINID_EMI_WEN		MXS_PIN_ENCODE(2, 31)
+
+/* Bank 3 */
+#define PINID_EMI_D00		MXS_PIN_ENCODE(3, 0)
+#define PINID_EMI_D01		MXS_PIN_ENCODE(3, 1)
+#define PINID_EMI_D02		MXS_PIN_ENCODE(3, 2)
+#define PINID_EMI_D03		MXS_PIN_ENCODE(3, 3)
+#define PINID_EMI_D04		MXS_PIN_ENCODE(3, 4)
+#define PINID_EMI_D05		MXS_PIN_ENCODE(3, 5)
+#define PINID_EMI_D06		MXS_PIN_ENCODE(3, 6)
+#define PINID_EMI_D07		MXS_PIN_ENCODE(3, 7)
+#define PINID_EMI_D08		MXS_PIN_ENCODE(3, 8)
+#define PINID_EMI_D09		MXS_PIN_ENCODE(3, 9)
+#define PINID_EMI_D10		MXS_PIN_ENCODE(3, 10)
+#define PINID_EMI_D11		MXS_PIN_ENCODE(3, 11)
+#define PINID_EMI_D12		MXS_PIN_ENCODE(3, 12)
+#define PINID_EMI_D13		MXS_PIN_ENCODE(3, 13)
+#define PINID_EMI_D14		MXS_PIN_ENCODE(3, 14)
+#define PINID_EMI_D15		MXS_PIN_ENCODE(3, 15)
+#define PINID_EMI_DQM0		MXS_PIN_ENCODE(3, 16)
+#define PINID_EMI_DQM1		MXS_PIN_ENCODE(3, 17)
+#define PINID_EMI_DQS0		MXS_PIN_ENCODE(3, 18)
+#define PINID_EMI_DQS1		MXS_PIN_ENCODE(3, 19)
+#define PINID_EMI_CLK		MXS_PIN_ENCODE(3, 20)
+#define PINID_EMI_CLKN		MXS_PIN_ENCODE(3, 21)
+
+#endif /* __ASM_ARCH_PINS_H */
diff --git a/arch/arm/mach-mx23/mx23evk.c b/arch/arm/mach-mx23/mx23evk.c
new file mode 100644
index 0000000..6ce1583
--- /dev/null
+++ b/arch/arm/mach-mx23/mx23evk.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/pinctrl.h>
+#include <mach/regs-ocotp.h>
+
+#include "device.h"
+#include "mx23evk.h"
+#include "mx23_pins.h"
+
+static struct mxs_mma7450_platform_data mma7450_platdata = {
+	.reg_dvdd_io = "vddio",
+	.reg_avdd = "vdda",
+	.gpio_pin_get = mx23evk_mma7450_pin_init,
+	.gpio_pin_put = mx23evk_mma7450_pin_release,
+	/* int1 and int2 will be initialized in
+	i2c_device_init */
+	.int1 = 0,
+	.int2 = 0,
+};
+
+static struct i2c_board_info __initdata mma7450_i2c_device = {
+	I2C_BOARD_INFO("mma7450", 0x3A),
+	.platform_data = (void *)&mma7450_platdata,
+};
+
+static void i2c_device_init(void)
+{
+	mma7450_platdata.int1 = gpio_to_irq(MXS_PIN_TO_GPIO(PINID_GPMI_D14));
+	mma7450_platdata.int2 = gpio_to_irq(MXS_PIN_TO_GPIO(PINID_GPMI_D15));
+	i2c_register_board_info(0, &mma7450_i2c_device, 1);
+}
+
+static struct mxs_spi_platform_data enc_data = {
+	.hw_pin_init = mxs_spi_enc_pin_init,
+	.hw_pin_release = mxs_spi_enc_pin_release,
+};
+static struct spi_board_info spi_board_info[] __initdata = {
+#if defined(CONFIG_ENC28J60) || defined(CONFIG_ENC28J60_MODULE)
+	{
+		.modalias       = "enc28j60",
+		.max_speed_hz   = 6 * 1000 * 1000,
+		.bus_num	= 1,
+		.chip_select    = 0,
+		.platform_data  = &enc_data,
+	},
+#endif
+};
+
+static void spi_device_init(void)
+{
+	spi_board_info[0].irq = gpio_to_irq(MXS_PIN_TO_GPIO(PINID_SSP1_DATA1));
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+}
+
+static void __init fixup_board(struct machine_desc *desc, struct tag *tags,
+			       char **cmdline, struct meminfo *mi)
+{
+	mx23_set_input_clk(24000000, 24000000, 32000, 50000000);
+}
+
+#if defined(CONFIG_SND_MXS_SOC_ADC) || defined(CONFIG_SND_MXS_SOC_ADC_MODULE)
+static void __init mx23evk_init_adc(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-adc", 0);
+	if (pdev == NULL)
+		return;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx23evk_init_adc(void)
+{
+
+}
+#endif
+
+#define REGS_OCOTP_BASE	IO_ADDRESS(OCOTP_PHYS_ADDR)
+int get_evk_board_version()
+{
+	int boardid;
+	boardid = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CUSTCAP);
+	boardid &= 0x30000000;
+	boardid = boardid >> 28;
+
+	return boardid;
+}
+EXPORT_SYMBOL_GPL(get_evk_board_version);
+
+static void __init mx23evk_device_init(void)
+{
+	/* Add mx23evk special code */
+	i2c_device_init();
+	spi_device_init();
+	mx23evk_init_adc();
+}
+
+
+static void __init mx23evk_init_machine(void)
+{
+	mx23_pinctrl_init();
+
+	/* Init iram allocate */
+#ifdef CONFIG_VECTORS_PHY_ADDR
+	/* reserve the first page for irq vectors table*/
+	iram_init(MX23_OCRAM_PHBASE + PAGE_SIZE, MX23_OCRAM_SIZE - PAGE_SIZE);
+#else
+	iram_init(MX23_OCRAM_PHBASE, MX23_OCRAM_SIZE);
+#endif
+
+	mx23_gpio_init();
+	mx23evk_pins_init();
+	mx23evk_mma7450_pin_init();
+	mx23_device_init();
+	mx23evk_device_init();
+}
+
+MACHINE_START(MX23EVK, "Freescale MX23EVK board")
+	.phys_io	= 0x80000000,
+	.io_pg_offst	= ((0xf0000000) >> 18) & 0xfffc,
+	.boot_params	= 0x40000100,
+	.fixup		= fixup_board,
+	.map_io		= mx23_map_io,
+	.init_irq	= mx23_irq_init,
+	.init_machine	= mx23evk_init_machine,
+	.timer		= &mx23_timer.timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx23/mx23evk.h b/arch/arm/mach-mx23/mx23evk.h
new file mode 100644
index 0000000..ea2ab4d
--- /dev/null
+++ b/arch/arm/mach-mx23/mx23evk.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_MACH_MX23EVK_H
+#define __ASM_ARM_MACH_MX23EVK_H
+
+extern void __init mx23evk_pins_init(void);
+extern void  mx23evk_mma7450_pin_init(void);
+extern int mx23evk_mma7450_pin_release(void);
+extern int mxs_spi_enc_pin_init(void);
+extern int mxs_spi_enc_pin_release(void);
+extern int mxs_mmc_get_wp_mmc0(void);
+extern int mxs_mmc_hw_init_mmc0(void);
+extern void mxs_mmc_hw_release_mmc0(void);
+extern void mxs_mmc_cmd_pullup_mmc0(int enable);
+
+#endif /* __ASM_ARM_MACH_MX23EVK_H */
diff --git a/arch/arm/mach-mx23/mx23evk_pins.c b/arch/arm/mach-mx23/mx23evk_pins.c
new file mode 100644
index 0000000..cdf86cf
--- /dev/null
+++ b/arch/arm/mach-mx23/mx23evk_pins.c
@@ -0,0 +1,939 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include <mach/pinctrl.h>
+
+#include "mx23_pins.h"
+
+static struct pin_desc mx23evk_fixed_pins[] = {
+	{
+	 .name = "DUART.RX",
+	 .id = PINID_PWM0,
+	 .fun = PIN_FUN3,
+	 },
+	{
+	 .name = "DUART.TX",
+	 .id = PINID_PWM1,
+	 .fun = PIN_FUN3,
+	 },
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+	{
+	 .name  = "AUART1.RX",
+	 .id    = PINID_AUART1_RX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART1.TX",
+	 .id    = PINID_AUART1_TX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART1.CTS",
+	 .id    = PINID_AUART1_CTS,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART1.RTS",
+	 .id    = PINID_AUART1_RTS,
+	 .fun   = PIN_FUN1,
+	 },
+#endif
+
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+	{
+	 .name  = "AUART2.RX",
+	 .id    = PINID_GPMI_D14,
+	 .fun   = PIN_FUN2,
+	},
+	{
+	 .name  = "AUART2.TX",
+	 .id    = PINID_GPMI_D15,
+	 .fun   = PIN_FUN2,
+	},
+	{
+	 .name  = "AUART2.CTS",
+	 .id    = PINID_ROTARYB,
+	 .fun   = PIN_FUN2,
+	},
+	{
+	 .name  = "AUART2.RTS",
+	 .id    = PINID_ROTARYA,
+	 .fun   = PIN_FUN2,
+	},
+#endif
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+	{
+	 .name = "I2C_SCL",
+	 .id = PINID_I2C_SCL,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "I2C_SDA",
+	 .id = PINID_I2C_SDA,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+	{
+	 .name  = "LCD_D00",
+	 .id	= PINID_LCD_D00,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D01",
+	 .id	= PINID_LCD_D01,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D02",
+	 .id	= PINID_LCD_D02,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D03",
+	 .id	= PINID_LCD_D03,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D04",
+	 .id	= PINID_LCD_D04,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D05",
+	 .id	= PINID_LCD_D05,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D06",
+	 .id	= PINID_LCD_D06,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D07",
+	 .id	= PINID_LCD_D07,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D08",
+	 .id	= PINID_LCD_D08,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D09",
+	 .id	= PINID_LCD_D09,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D10",
+	 .id	= PINID_LCD_D10,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D11",
+	 .id	= PINID_LCD_D11,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D12",
+	 .id	= PINID_LCD_D12,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D13",
+	 .id	= PINID_LCD_D13,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D14",
+	 .id	= PINID_LCD_D14,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D15",
+	 .id	= PINID_LCD_D15,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D16",
+	 .id	= PINID_LCD_D16,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D17",
+	 .id	= PINID_LCD_D17,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D18",
+	 .id	= PINID_GPMI_D08,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D19",
+	 .id	= PINID_GPMI_D09,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D20",
+	 .id	= PINID_GPMI_D10,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D21",
+	 .id	= PINID_GPMI_D11,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D22",
+	 .id	= PINID_GPMI_D12,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D23",
+	 .id	= PINID_GPMI_D13,
+	 .fun	= PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_RESET",
+	 .id = PINID_LCD_RESET,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_VSYNC",
+	 .id   = PINID_LCD_VSYNC,
+	 .fun  = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_HSYNC",
+	 .id = PINID_LCD_HSYNC,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_ENABLE",
+	 .id = PINID_LCD_ENABLE,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_DOTCLK",
+	 .id = PINID_LCD_DOTCK,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_BACKLIGHT",
+	 .id = PINID_PWM2,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+	{
+	 .name = "ENET0_MDC",
+	 .id = PINID_ENET0_MDC,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_MDIO",
+	 .id = PINID_ENET0_MDIO,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RX_EN",
+	 .id = PINID_ENET0_RX_EN,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RXD0",
+	 .id = PINID_ENET0_RXD0,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RXD1",
+	 .id = PINID_ENET0_RXD1,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TX_EN",
+	 .id = PINID_ENET0_TX_EN,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TXD0",
+	 .id = PINID_ENET0_TXD0,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TXD1",
+	 .id = PINID_ENET0_TXD1,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET_CLK",
+	 .id = PINID_ENET_CLK,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+#if defined(CONFIG_USB_OTG)
+	{
+	 .name = "USB_OTG_ID",
+	 .id   = PINID_ROTARYA,
+	 .fun  = PIN_GPIO,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	},
+#endif
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+       defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+	{
+	 .name		= "SPDIF",
+	 .id		= PINID_ROTARYA,
+	 .fun		= PIN_FUN3,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	},
+#endif
+
+#if defined(CONFIG_MTD_NAND_GPMI_NFC) || \
+       defined(CONFIG_MTD_NAND_GPMI_NFC_MODULE)
+	{
+	 .name     = "GPMI D0",
+	 .id       = PINID_GPMI_D00,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	.name     = "GPMI D1",
+	.id       = PINID_GPMI_D01,
+	.fun      = PIN_FUN1,
+	.strength = PAD_4MA,
+	.voltage  = PAD_3_3V,
+	.pullup   = 0,
+	.drive    = !0
+	 },
+	{
+	 .name     = "GPMI D2",
+	 .id       = PINID_GPMI_D02,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D3",
+	 .id       = PINID_GPMI_D03,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D4",
+	 .id       = PINID_GPMI_D04,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D5",
+	 .id       = PINID_GPMI_D05,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D6",
+	 .id       = PINID_GPMI_D06,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D7",
+	 .id       = PINID_GPMI_D07,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CLE",
+	 .id       = PINID_GPMI_CLE,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI ALE",
+	 .id       = PINID_GPMI_ALE,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI WPN-",
+	 .id       = PINID_GPMI_WPN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI WR-",
+	 .id       = PINID_GPMI_WRN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RD-",
+	 .id       = PINID_GPMI_RDN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RDY0",
+	 .id       = PINID_GPMI_RDY0,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RDY1",
+	 .id       = PINID_GPMI_RDY1,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CE0-",
+	 .id       = PINID_GPMI_CE0N,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CE1-",
+	 .id       = PINID_GPMI_CE1N,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+#endif
+
+};
+
+#if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
+static struct pin_desc mx23evk_mmc_pins[] = {
+	/* Configurations of SSP0 SD/MMC port pins */
+	{
+	 .name = "SSP1_DATA0",
+	 .id = PINID_SSP1_DATA0,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 1,
+	 .drive = 1,
+	 .pull = 1,
+	 },
+	{
+	 .name = "SSP1_DATA1",
+	 .id = PINID_SSP1_DATA1,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 1,
+	 .drive = 1,
+	 .pull = 1,
+	 },
+	{
+	 .name = "SSP1_DATA2",
+	 .id = PINID_SSP1_DATA2,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 1,
+	 .drive = 1,
+	 .pull = 1,
+	 },
+	{
+	 .name = "SSP1_DATA3",
+	 .id = PINID_SSP1_DATA3,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 1,
+	 .drive = 1,
+	 .pull = 1,
+	 },
+	{
+	 .name = "SSP1_CMD",
+	 .id = PINID_SSP1_CMD,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 1,
+	 .drive = 1,
+	 .pull = 1,
+	 },
+	{
+	 .name = "SSP1_DETECT",
+	 .id = PINID_SSP1_DETECT,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 0,
+	 .drive = 1,
+	 .pull = 0,
+	 },
+	{
+	 .name = "SSP1_SCK",
+	 .id = PINID_SSP1_SCK,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .pullup = 0,
+	 .drive = 1,
+	 .pull = 0,
+	 },
+};
+#endif
+
+#if defined(CONFIG_SPI_MXS) || defined(CONFIG_SPI_MXS_MODULE)
+static struct pin_desc mx23evk_spi_pins[] = {
+	{
+	 .name	= "SSP1_DATA0",
+	 .id	= PINID_SSP1_DATA0,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .drive 	= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA3",
+	 .id	= PINID_SSP1_DATA3,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .drive 	= 1,
+	 },
+	{
+	 .name	= "SSP1_CMD",
+	 .id	= PINID_SSP1_CMD,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .drive 	= 1,
+	 },
+	{
+	 .name	= "SSP1_SCK",
+	 .id	= PINID_SSP1_SCK,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive 	= 1,
+	 },
+};
+#endif
+
+
+static void mxs_request_pins(struct pin_desc *pins, int nr)
+{
+	int i;
+	struct pin_desc *pin;
+
+	/* configure the pins */
+	for (i = 0; i < nr; i++) {
+		pin = &pins[i];
+		if (pin->fun == PIN_GPIO)
+			gpio_request(MXS_PIN_TO_GPIO(pin->id), pin->name);
+		else
+			mxs_request_pin(pin->id, pin->fun, pin->name);
+		if (pin->drive) {
+			mxs_set_strength(pin->id, pin->strength, pin->name);
+			mxs_set_voltage(pin->id, pin->voltage, pin->name);
+		}
+		if (pin->pull)
+			mxs_set_pullup(pin->id, pin->pullup, pin->name);
+		if (pin->fun == PIN_GPIO) {
+			if (pin->output)
+				gpio_direction_output(MXS_PIN_TO_GPIO(pin->id),
+						      pin->data);
+			else
+				gpio_direction_input(MXS_PIN_TO_GPIO(pin->id));
+		}
+	}
+}
+
+static void mxs_release_pins(struct pin_desc *pins, int nr)
+{
+	int i;
+	struct pin_desc *pin;
+
+	/* release the pins */
+	for (i = 0; i < nr; i++) {
+		pin = &pins[i];
+		if (pin->fun == PIN_GPIO)
+			gpio_free(MXS_PIN_TO_GPIO(pin->id));
+		else
+			mxs_release_pin(pin->id, pin->name);
+	}
+}
+
+#if defined(CONFIG_MXC_MMA7450) || defined(CONFIG_MXC_MMA7450_MODULE)
+int mx23evk_mma7450_pin_init(void)
+{
+	/* intr */
+	gpio_request(MXS_PIN_TO_GPIO(PINID_GPMI_D14), "MMA7450_INTR1");
+	gpio_direction_input(MXS_PIN_TO_GPIO(PINID_GPMI_D14));
+	gpio_request(MXS_PIN_TO_GPIO(PINID_GPMI_D15), "MMA7450_INTR2");
+	gpio_direction_input(MXS_PIN_TO_GPIO(PINID_GPMI_D15));
+	return 0;
+}
+int mx23evk_mma7450_pin_release(void)
+{
+	return 0;
+}
+#else
+int mx23evk_mma7450_pin_init(void)
+{
+	return 0;
+}
+int mx23evk_mma7450_pin_release(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
+#define MMC0_POWER	MXS_PIN_TO_GPIO(PINID_PWM3)
+#define MMC0_WP		MXS_PIN_TO_GPIO(PINID_PWM4)
+
+int mxs_mmc_get_wp_mmc0(void)
+{
+	return gpio_get_value(MMC0_WP);
+}
+
+int mxs_mmc_hw_init_mmc0(void)
+{
+	int ret = 0;
+
+	mxs_request_pins(mx23evk_mmc_pins, ARRAY_SIZE(mx23evk_mmc_pins));
+
+	/* Configure write protect GPIO pin */
+	ret = gpio_request(MMC0_WP, "mmc0_wp");
+	if (ret) {
+		pr_err("wp\n");
+		goto out_wp;
+	}
+	gpio_set_value(MMC0_WP, 0);
+	gpio_direction_input(MMC0_WP);
+
+	/* Configure POWER pin as gpio to drive power to MMC slot */
+	ret = gpio_request(MMC0_POWER, "mmc0_power");
+	if (ret) {
+		pr_err("power\n");
+		goto out_power;
+	}
+	gpio_direction_output(MMC0_POWER, 0);
+	mdelay(100);
+
+	return 0;
+
+out_power:
+	gpio_free(MMC0_WP);
+out_wp:
+	mxs_release_pins(mx23evk_mmc_pins, ARRAY_SIZE(mx23evk_mmc_pins));
+	return ret;
+}
+
+void mxs_mmc_hw_release_mmc0(void)
+{
+	gpio_free(MMC0_POWER);
+	gpio_free(MMC0_WP);
+
+	mxs_release_pins(mx23evk_mmc_pins, ARRAY_SIZE(mx23evk_mmc_pins));
+}
+
+void mxs_mmc_cmd_pullup_mmc0(int enable)
+{
+	mxs_set_pullup(PINID_SSP1_CMD, enable, "mmc0_cmd");
+}
+#else
+int mxs_mmc_get_wp_mmc0(void)
+{
+	return 0;
+}
+int mxs_mmc_hw_init_mmc0(void)
+{
+	return 0;
+}
+
+void mxs_mmc_hw_release_mmc0(void)
+{
+}
+
+void mxs_mmc_cmd_pullup_mmc0(int enable)
+{
+}
+#endif
+
+#if defined(CONFIG_ENC28J60) || defined(CONFIG_ENC28J60_MODULE)
+int mxs_spi_enc_pin_init(void)
+{
+	unsigned gpio = MXS_PIN_TO_GPIO(PINID_SSP1_DATA1);
+
+	mxs_request_pins(mx23evk_spi_pins, ARRAY_SIZE(mx23evk_spi_pins));
+
+	gpio_request(gpio, "ENC28J60_INTR");
+	gpio_direction_input(gpio);
+	set_irq_type(gpio_to_irq(gpio), IRQ_TYPE_EDGE_FALLING);
+
+	return 0;
+}
+int mxs_spi_enc_pin_release(void)
+{
+	unsigned gpio = MXS_PIN_TO_GPIO(PINID_SSP1_DATA1);
+
+
+	gpio_free(gpio);
+	set_irq_type(gpio_to_irq(gpio), IRQ_TYPE_NONE);
+
+	/* release the pins */
+	mxs_release_pins(mx23evk_spi_pins, ARRAY_SIZE(mx23evk_spi_pins));
+
+	return 0;
+}
+#else
+int mxs_spi_enc_pin_init(void)
+{
+	return 0;
+}
+int mxs_spi_enc_pin_release(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+int mx23evk_enet_gpio_init(void)
+{
+	/* pwr */
+	gpio_request(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), "ENET_PWR");
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 0);
+
+	/* reset phy */
+	gpio_request(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), "PHY_RESET");
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), 0);
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), 1);
+
+	return 0;
+}
+#else
+int mx23evk_enet_gpio_init(void)
+{
+	return 0;
+}
+#endif
+
+void __init mx23evk_pins_init(void)
+{
+	mxs_request_pins(mx23evk_fixed_pins, ARRAY_SIZE(mx23evk_fixed_pins));
+}
diff --git a/arch/arm/mach-mx23/otp.c b/arch/arm/mach-mx23/otp.c
new file mode 100644
index 0000000..7bec45f
--- /dev/null
+++ b/arch/arm/mach-mx23/otp.c
@@ -0,0 +1,437 @@
+/*
+ * Unique ID manipulation: Freescale STMP378X OTP bits read/write procedures
+ *
+ * Author: dmitry pervushin <dimka@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/fcntl.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <mach/unique-id.h>
+#include <mach/regs-ocotp.h>
+#include <mach/regs-power.h>
+#include <mach/mx23.h>
+
+static DEFINE_MUTEX(otp_mutex);
+static unsigned otp_mode;
+static unsigned long otp_hclk_saved;
+static u32 otp_voltage_saved;
+
+static int otp_full; /* = 0. By default, show/set only customer bits */
+#define OTP_USER_OFFSET 0
+#define OTP_USER_SIZE	4
+
+#define REGS_OCOTP_BASE (IO_ADDRESS(OCOTP_PHYS_ADDR))
+#define BF(value, field) (((value) << BP_##field) & BM_##field)
+/**
+ * otp_wait_busy - wait for completion of operation
+ *
+ * @flags: flags that should be clear in addition to _BUSY and _ERROR
+ *
+ * Returns 0 on success or -ETIMEDOUT on error
+ **/
+static int otp_wait_busy(u32 flags)
+{
+	int count;
+	u32 c;
+
+	for (count = 10000; count >= 0; count--) {
+		c = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+		if (!(c & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR | flags)))
+			break;
+		cpu_relax();
+	}
+	if (count < 0)
+		return -ETIMEDOUT;
+	return 0;
+}
+
+/**
+ * otp_open - open OTP bits for read or write access
+ *
+ * @mode: either O_RDONLY or O_WRONLY
+ *
+ * Returns 0 on success, error code otherwise
+ **/
+static int otp_open(int mode)
+{
+	int r;
+	struct clk *hclk;
+	int err;
+
+	if (!mutex_trylock(&otp_mutex)) {
+		printk(KERN_ERR"%s: already opened\n", __func__);
+		return -EAGAIN;
+	}
+
+	if (mode == O_RDONLY) {
+		pr_debug("%s: read-only mode\n", __func__);
+
+		r = otp_wait_busy(0);
+		if (r) {
+			err = -ETIMEDOUT;
+			goto out;
+		}
+
+		/* 2. Set RD_BANK_OPEN */
+		__raw_writel(BM_OCOTP_CTRL_RD_BANK_OPEN, REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+		udelay(10);
+
+		otp_wait_busy(0);
+	}
+
+	else if (mode == O_WRONLY) {
+		pr_debug("%s: write-only mode\n", __func__);
+		hclk = clk_get(NULL, "hclk");
+		if (IS_ERR(hclk)) {
+			err = PTR_ERR(hclk);
+			goto out;
+		}
+
+		/*
+		   WARNING  ACHTUNG  UWAGA
+
+		   the code below changes HCLK clock rate to 24M. This is
+		   required to write OTP bits (7.2.2 in STMP378x Target
+		   Specification), and might affect LCD operation, for example.
+		   Moreover, this hacky code changes VDDIO to 2.8V; and resto-
+		   res it only on otp_close(). This may affect... anything.
+
+		   You are warned now.
+		 */
+		otp_hclk_saved = clk_get_rate(hclk);
+		clk_set_rate(hclk, 24000);
+		/* Set the voltage to 2.8V */
+		otp_voltage_saved = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+		__raw_writel(
+			(otp_voltage_saved & ~BM_POWER_VDDIOCTRL_TRG) | 0x00, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+
+		r = otp_wait_busy(BM_OCOTP_CTRL_RD_BANK_OPEN);
+		if (r < 0) {
+			__raw_writel(otp_voltage_saved, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+			clk_set_rate(hclk, otp_hclk_saved);
+			clk_put(hclk);
+			err = -ETIMEDOUT;
+			goto out;
+		}
+
+		clk_put(hclk);
+	}
+
+	else {
+		pr_debug("%s: unknown mode '%d'\n", __func__, mode);
+		err = -EINVAL;
+		goto out;
+	}
+
+	otp_mode = mode;
+	return 0;
+out:
+	mutex_unlock(&otp_mutex);
+	pr_debug("%s: status %d\n", __func__, err);
+	return err;
+}
+
+/**
+ * otp_close - close the OTP bits after opening by otp_open
+ **/
+static void otp_close(void)
+{
+	struct clk *hclk;
+
+	if (!mutex_is_locked(&otp_mutex)) {
+		printk(KERN_ERR"%s: wasn't opened\n", __func__);
+		return;
+	}
+
+	if (otp_mode == O_RDONLY) {
+		/* 5. clear RD_BANK_OPEN */
+		__raw_writel(BM_OCOTP_CTRL_RD_BANK_OPEN, REGS_OCOTP_BASE + HW_OCOTP_CTRL_CLR);
+	}
+
+	else if (otp_mode == O_WRONLY) {
+		hclk = clk_get(NULL, "hclk");
+		clk_set_rate(hclk, otp_hclk_saved);
+		__raw_writel(otp_voltage_saved, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+		otp_wait_busy(0);
+		__raw_writel(BM_OCOTP_CTRL_RELOAD_SHADOWS, REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+		otp_wait_busy(BM_OCOTP_CTRL_RELOAD_SHADOWS);
+	}
+
+	else {
+		return; /* -EINVAL. Who does really check close? */
+	}
+
+	otp_mode = 0;
+	mutex_unlock(&otp_mutex);
+}
+
+/**
+ * otp_read_bits - read the content of OTP
+ *
+ * @start: offset from 0, in u32's
+ * @len: number of OTP u32's to read
+ * @bits: caller-allocated buffer to save bits
+ * @size: size of @bits
+ *
+ * Returns number of u32's saved to buffer
+ **/
+static size_t otp_read_bits(int start, int len, u32 *bits, size_t size)
+{
+	int ofs;
+
+	BUG_ON(!mutex_is_locked(&otp_mutex));
+
+	/* read all stuff that caller needs */
+	if (start + len > 4 * 8)  		/* 4 banks, 8 registers each */
+		len = 4 * 8 - start;
+
+	for (ofs = start; ofs < len; ofs++) {
+		if (size/sizeof(*bits) <= 0)	/* we drained out the buffer */
+			break;
+		*bits = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CUSTn(ofs));
+		bits++;
+		size -= sizeof(*bits);
+	}
+
+	return ofs - start;	/* number of u32's that we saved to buffer */
+}
+
+/**
+ * otp_write_bits - store OTP bits
+ *
+ * @offset: offset from 0, in u32's
+ * @data: the u32 to write
+ * @magic: the magic value to be stored in UNLOCK field
+ *
+ **/
+static int otp_write_bits(int offset, u32 data, u32 magic)
+{
+	u32 c;
+	int r;
+
+	BUG_ON(!mutex_is_locked(&otp_mutex));
+
+	if (offset < 0 || offset > 0x1F)
+		return -EINVAL;
+
+	c = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+	c &= ~BM_OCOTP_CTRL_ADDR;
+	c |= BF(offset, OCOTP_CTRL_ADDR);
+	c |= BF(magic, OCOTP_CTRL_WR_UNLOCK);
+	__raw_writel(c, REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+
+	__raw_writel(data, REGS_OCOTP_BASE + HW_OCOTP_DATA);
+
+	r = otp_wait_busy(0);
+	if (r < 0)
+		return r;
+
+	udelay(2);
+	return 0;
+}
+
+static ssize_t otp_id_show(void *context, char *page, int ascii)
+{
+	char s[60];
+	int ret;
+	int n, i, j, r;
+	u32 otp_bits[4 * 8];
+
+	r = otp_open(O_RDONLY);
+	if (r < 0)
+		return 0;
+	n = otp_read_bits(0, 4 * 8, otp_bits, sizeof(otp_bits));
+	otp_close();
+
+	ret = 0;
+
+
+	if (ascii) {
+
+		strcpy(page, "");
+		ret = 0;
+
+		if (otp_full) {
+			for (i = 0; i < 4; i++) {
+
+				ret += sprintf(s, "Bank %d: ", i);
+				strcat(page, s);
+
+				for (j = 0; j < 8; j++) {
+
+					if (i * 4 + j > n)
+						break;
+					ret += sprintf(s, "%08X ",
+						otp_bits[i * 4 + j]);
+					strcat(page, s);
+				}
+
+				strcat(page, "\n");
+				ret++;
+			}
+		} else {
+			for (i = 0; i < OTP_USER_SIZE; i++) {
+				ret += sprintf(s, "%08X ",
+					otp_bits[i + OTP_USER_OFFSET]);
+				strcat(page, s);
+			}
+			strcat(page, "\n");
+			ret++;
+		}
+	} else {
+
+		if (otp_full) {
+			memcpy(page, otp_bits, sizeof(otp_bits));
+			ret = sizeof(otp_bits);
+		} else {
+			memcpy(page, otp_bits + OTP_USER_OFFSET,
+					OTP_USER_SIZE * sizeof(u32));
+			ret = OTP_USER_SIZE * sizeof(u32);
+		}
+	}
+
+	return ret;
+}
+
+static int otp_check_dry_run(const char *page, size_t count)
+{
+	if (count >= 3 && memcmp(page, "+++", 3) == 0)
+		return 3;
+	return 0;
+}
+
+static ssize_t otp_id_store(void *context, const char *page,
+				size_t count, int ascii)
+{
+	int r = 0;
+	const char *p, *cp, *d;
+	unsigned long index, value;
+	char tmps[20];	/* subject of strtoul */
+	int dry_run;
+
+	r = otp_open(O_WRONLY);
+	if (r < 0) {
+		printk(KERN_ERR"Cannot open OTP in WRITE mode\n");
+		return r;
+	}
+
+	if (ascii) {
+
+		dry_run = otp_check_dry_run(page, count);
+		if (dry_run > 0)
+			page += dry_run;
+
+		index = 0;
+		cp = page;
+
+		memset(tmps, 0, sizeof(tmps));
+
+		for (index = 0, cp = page; cp != NULL; index++) {
+			p = strchr(cp, ',');
+
+			d = strchr(cp, ':');
+			if (d && (!p || d < p)) {
+				strncpy(tmps, cp,
+					min_t(int, d - cp, sizeof(tmps) - 1));
+				r = strict_strtoul(tmps, 0, &index);
+				if (r < 0) {
+					pr_debug("Cannot parse '%s'\n", tmps);
+					break;
+				}
+				cp = d + 1;
+			}
+
+			memset(tmps, 0, sizeof(tmps));
+
+			if (!p)
+				strncpy(tmps, cp, sizeof(tmps));
+			else
+				strncpy(tmps, cp,
+					min_t(int, p - cp, sizeof(tmps) - 1));
+			r = strict_strtoul(tmps, 0, &value);
+			if (r < 0) {
+				pr_debug("Cannot parse '%s'\n", tmps);
+				break;
+			}
+
+			memset(tmps, 0, sizeof(tmps));
+
+			cp = p ? ++p : NULL;
+
+			if (!otp_full) {
+				index += OTP_USER_OFFSET;
+				if (index > OTP_USER_SIZE) {
+					printk(KERN_ERR"Cannot write at "
+							"offset %ld\n", index);
+					continue;
+				}
+			}
+
+			r = 0;
+			if (!dry_run) {
+				pr_debug("Index %ld, value 0x%08lx\n",
+						index, value);
+				r = otp_write_bits(index, value, 0x3e77);
+			} else
+				printk(KERN_NOTICE
+					"Dry-run: writing 0x%08lX => [%ld]\n",
+						value, index);
+			if (r < 0)
+				break;
+		}
+	} else {
+		printk(KERN_ERR"Binary write is not supported\n");
+		r = -ENOSYS;
+	}
+	otp_close();
+	return (r >= 0) ? count : r;
+}
+
+static struct uid_ops otp_ops = {
+	.id_show = otp_id_show,
+	.id_store = otp_id_store,
+};
+
+static int __init_or_module otp_init(void)
+{
+	void *p;
+
+	mutex_init(&otp_mutex);
+	p = uid_provider_init("otp", &otp_ops, NULL);
+	if (IS_ERR(p))
+		return PTR_ERR(p);
+	return 0;
+}
+
+static void __exit otp_remove(void)
+{
+	uid_provider_remove("otp");
+}
+
+module_param(otp_full, int, 0600);
+module_init(otp_init);
+module_exit(otp_remove);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("dmitry pervushin <dimka@embeddedalley.com>");
+MODULE_DESCRIPTION("Unique ID: OTP");
diff --git a/arch/arm/mach-mx23/pinctrl.c b/arch/arm/mach-mx23/pinctrl.c
new file mode 100644
index 0000000..0cb85e2
--- /dev/null
+++ b/arch/arm/mach-mx23/pinctrl.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/pinctrl.h>
+
+#include "regs-pinctrl.h"
+
+#define PINCTRL_BASE_ADDR IO_ADDRESS(PINCTRL_PHYS_ADDR)
+
+static int
+mx23_pin2id(struct pinctrl_chip *chip, unsigned int pin, unsigned int *id)
+{
+	int bank;
+	bank = MXS_PIN_TO_BANK(pin & MXS_GPIO_MASK);
+	if (bank == MXS_PIN_BANK_MAX)
+		return -EINVAL;
+	*id = MXS_PIN_TO_PINID(pin & MXS_GPIO_MASK);
+	return bank;
+}
+
+static unsigned int mx23_get_gpio(struct pin_bank *bank, unsigned int id)
+{
+	if (bank->gpio_port >= MXS_NON_GPIO)
+		return -EINVAL;
+	return bank->gpio_port * PINS_PER_BANK + id;
+}
+
+static void mx23_set_strength(struct pin_bank *bank,
+			      unsigned int id, enum pad_strength strength)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_DRIVE0;
+	addr += 0x40 * bank->id + 0x10 * (id >> 3);
+	id &= 0x7;
+	id *= 4;
+	__raw_writel(PAD_CLEAR << id, addr + CLR_REGISTER);
+	__raw_writel(strength << id, addr + SET_REGISTER);
+}
+
+static void mx23_set_voltage(struct pin_bank *bank,
+			     unsigned int id, enum pad_voltage volt)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_DRIVE0;
+	addr += 0x40 * bank->id + 0x10 * (id >> 3);
+	id &= 0x7;
+	id = id * 4 + 2;
+	if (volt == PAD_1_8V)
+		__raw_writel(1 << id, addr + CLR_REGISTER);
+	else
+		__raw_writel(1 << id, addr + SET_REGISTER);
+}
+
+static void mx23_set_pullup(struct pin_bank *bank, unsigned int id, int pullup)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_PULL0;
+	addr += 0x10 * bank->id;
+	if (pullup)
+		__raw_writel(1 << id, addr + SET_REGISTER);
+	else
+		__raw_writel(1 << id, addr + CLR_REGISTER);
+}
+
+static void mx23_set_type(struct pin_bank *bank,
+			  unsigned int id, enum pin_fun cfg)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_MUXSEL0;
+	addr += 0x20 * bank->id + 0x10 * (id >> 4);
+	id &= 0xF;
+	id *= 2;
+	__raw_writel(0x3 << id, addr + CLR_REGISTER);
+	__raw_writel(cfg << id, addr + SET_REGISTER);
+}
+
+static struct pin_bank mx23_pin_banks[6] = {
+	[0] = {
+	       .id = 0,
+	       .gpio_port = 0,
+	       },
+	[1] = {
+	       .id = 1,
+	       .gpio_port = 1,
+	       },
+	[2] = {
+	       .id = 2,
+	       .gpio_port = 2,
+	       },
+	[3] = {
+	       .id = 3,
+	       .gpio_port = 3,
+	       },
+	[4] = {
+	       .id = 4,
+	       .gpio_port = 4,
+	       },
+	[5] = {
+	       .id = 5,
+	       .gpio_port = MXS_NON_GPIO,
+	       }
+};
+
+static struct pinctrl_chip mx23_pinctrl = {
+	.name = "pinctrl",
+	.banks = mx23_pin_banks,
+	.pin2id = mx23_pin2id,
+	.get_gpio = mx23_get_gpio,
+	.set_strength = mx23_set_strength,
+	.set_voltage = mx23_set_voltage,
+	.set_pullup = mx23_set_pullup,
+	.set_type = mx23_set_type,
+};
+
+int __init mx23_pinctrl_init(void)
+{
+	int i;
+	if (__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR) &
+	    BM_PINCTRL_CTRL_SFTRST) {
+		__raw_writel(BM_PINCTRL_CTRL_SFTRST,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+		for (i = 0; i < 10000; i++) {
+			if (!(__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL) &
+			      BM_PINCTRL_CTRL_SFTRST))
+				break;
+			udelay(2);
+		}
+		if (i >= 10000)
+			return -EFAULT;
+
+		__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	}
+
+	__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+		     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	mx23_pinctrl.bank_size = ARRAY_SIZE(mx23_pin_banks);
+	return mxs_set_pinctrl_chip(&mx23_pinctrl);
+}
diff --git a/arch/arm/mach-mx23/pm.c b/arch/arm/mach-mx23/pm.c
new file mode 100644
index 0000000..0538326
--- /dev/null
+++ b/arch/arm/mach-mx23/pm.c
@@ -0,0 +1,651 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#include <linux/suspend.h>
+#include <linux/rtc.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+
+#include <asm/cacheflush.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include <mach/regs-rtc.h>
+#include "regs-clkctrl.h"
+#include "regs-pinctrl.h"
+#include <mach/regs-power.h>
+#include <mach/regs-pwm.h>
+#include <mach/regs-rtc.h>
+#include <mach/../../regs-icoll.h>
+#include "regs-dram.h"
+
+#include "sleep.h"
+
+#define PENDING_IRQ_RETRY 100
+static void *saved_sram;
+static int saved_sleep_state;
+
+#define WAIT_DC_OK_CYCLES 24000
+#define WAIT_CYCLE(n) for (i = 0; i < n; i++);
+#define LOWER_VDDIO 10
+#define LOWER_VDDA 9
+#define LOWER_VDDD 8
+#define MAX_POWEROFF_CODE_SIZE (6 * 1024)
+#define REGS_CLKCTRL_BASE IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+
+static void mx23_standby(void)
+{
+	int i;
+	u32 reg_vddd, reg_vdda, reg_vddio;
+	/* DDR EnterSelfrefreshMode */
+	__raw_writel(
+	BF_DRAM_CTL16_LOWPOWER_AUTO_ENABLE(0x2) |
+	__raw_readl(IO_ADDRESS(DRAM_PHYS_ADDR)
+		+ HW_DRAM_CTL16),
+	IO_ADDRESS(DRAM_PHYS_ADDR) + HW_DRAM_CTL16);
+
+	__raw_writel(
+	BF_DRAM_CTL16_LOWPOWER_CONTROL(0x2) |
+	__raw_readl(IO_ADDRESS(DRAM_PHYS_ADDR)
+		+ HW_DRAM_CTL16),
+	IO_ADDRESS(DRAM_PHYS_ADDR) + HW_DRAM_CTL16);
+	/* Gating EMI CLock */
+	__raw_writel(BM_CLKCTRL_EMI_CLKGATE |
+			__raw_readl(REGS_CLKCTRL_BASE + HW_CLKCTRL_EMI),
+			REGS_CLKCTRL_BASE + HW_CLKCTRL_EMI);
+
+	/* Disable PLL */
+	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_PLLCTRL0_CLR);
+
+	/* Reduce the VDDIO (3.050 volt) */
+	reg_vddio = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	__raw_writel(reg_vddio | BM_POWER_VDDIOCTRL_BO_OFFSET,
+		REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL) &
+		~BM_POWER_VDDIOCTRL_TRG) | LOWER_VDDIO,
+		REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+	/* Reduce VDDA 1.725volt */
+	reg_vdda = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	__raw_writel(reg_vdda | BM_POWER_VDDACTRL_BO_OFFSET,
+		REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_VDDACTRL) &
+		~BM_POWER_VDDACTRL_TRG) | LOWER_VDDA,
+		REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+
+	/* wait for DC_OK */
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+	/* Reduce VDDD 1.000 volt */
+	reg_vddd = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	__raw_writel(reg_vddd | BM_POWER_VDDDCTRL_BO_OFFSET,
+		REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_VDDDCTRL) &
+		~BM_POWER_VDDDCTRL_TRG) | LOWER_VDDD,
+		REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+	/* optimize the DCDC loop gain */
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_LOOPCTRL) &
+		~BM_POWER_LOOPCTRL_EN_RCSCALE),
+		REGS_POWER_BASE + HW_POWER_LOOPCTRL);
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_LOOPCTRL) &
+		~BM_POWER_LOOPCTRL_DC_R) |
+		(2<<BP_POWER_LOOPCTRL_DC_R),
+		REGS_POWER_BASE + HW_POWER_LOOPCTRL);
+
+	/* half the fets */
+	__raw_writel(BM_POWER_MINPWR_HALF_FETS,
+		REGS_POWER_BASE + HW_POWER_MINPWR_SET);
+	__raw_writel(BM_POWER_MINPWR_DOUBLE_FETS,
+		REGS_POWER_BASE + HW_POWER_MINPWR_CLR);
+
+	__raw_writel(BM_POWER_LOOPCTRL_CM_HYST_THRESH,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_CLR);
+	__raw_writel(BM_POWER_LOOPCTRL_EN_CM_HYST,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_CLR);
+	__raw_writel(BM_POWER_LOOPCTRL_EN_DF_HYST,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_CLR);
+
+
+	/* enable PFM */
+	__raw_writel(BM_POWER_LOOPCTRL_HYST_SIGN,
+		REGS_POWER_BASE + HW_POWER_LOOPCTRL_SET);
+	__raw_writel(BM_POWER_MINPWR_EN_DC_PFM,
+		REGS_POWER_BASE + HW_POWER_MINPWR_SET);
+
+	__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_CPU_SET);
+	/* Power off ... */
+	asm("mcr     p15, 0, r2, c7, c0, 4");
+	__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,
+			REGS_CLKCTRL_BASE + HW_CLKCTRL_CPU_CLR);
+
+	/* Enable PLL */
+	__raw_writel(BM_CLKCTRL_PLLCTRL0_POWER,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_PLLCTRL0_SET);
+
+	/* restore the DCDC parameter */
+
+	__raw_writel(BM_POWER_MINPWR_EN_DC_PFM,
+			REGS_POWER_BASE + HW_POWER_MINPWR_CLR);
+	__raw_writel(BM_POWER_LOOPCTRL_HYST_SIGN,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_CLR);
+	__raw_writel(BM_POWER_LOOPCTRL_EN_DF_HYST,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_SET);
+	__raw_writel(BM_POWER_LOOPCTRL_EN_CM_HYST,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_SET);
+	__raw_writel(BM_POWER_LOOPCTRL_CM_HYST_THRESH,
+			REGS_POWER_BASE + HW_POWER_LOOPCTRL_SET);
+
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_LOOPCTRL) &
+		~BM_POWER_LOOPCTRL_DC_R) |
+		(2<<BP_POWER_LOOPCTRL_DC_R),
+		REGS_POWER_BASE + HW_POWER_LOOPCTRL);
+	__raw_writel((__raw_readl(REGS_POWER_BASE + HW_POWER_LOOPCTRL) &
+		~BM_POWER_LOOPCTRL_EN_RCSCALE) |
+		(3 << BP_POWER_LOOPCTRL_EN_RCSCALE),
+		REGS_POWER_BASE + HW_POWER_LOOPCTRL);
+
+	/* double the fets */
+	__raw_writel(BM_POWER_MINPWR_HALF_FETS,
+		REGS_POWER_BASE + HW_POWER_MINPWR_CLR);
+	__raw_writel(BM_POWER_MINPWR_DOUBLE_FETS,
+		REGS_POWER_BASE + HW_POWER_MINPWR_SET);
+
+
+	/* Restore VDDD */
+	__raw_writel(reg_vddd, REGS_POWER_BASE + HW_POWER_VDDDCTRL);
+
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+	__raw_writel(reg_vdda, REGS_POWER_BASE + HW_POWER_VDDACTRL);
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+	__raw_writel(reg_vddio, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	WAIT_CYCLE(WAIT_DC_OK_CYCLES)
+	while (!(__raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+		BM_POWER_STS_DC_OK))
+		;
+
+
+	/* Ungating EMI CLock */
+	__raw_writel(~BM_CLKCTRL_EMI_CLKGATE &
+			__raw_readl(REGS_CLKCTRL_BASE + HW_CLKCTRL_EMI),
+			REGS_CLKCTRL_BASE + HW_CLKCTRL_EMI);
+
+	/* LeaveSelfrefreshMode */
+	__raw_writel(
+	(~BF_DRAM_CTL16_LOWPOWER_CONTROL(0x2)) &
+	__raw_readl(IO_ADDRESS(DRAM_PHYS_ADDR)
+		+ HW_DRAM_CTL16),
+	IO_ADDRESS(DRAM_PHYS_ADDR) + HW_DRAM_CTL16);
+
+	__raw_writel(
+	(~BF_DRAM_CTL16_LOWPOWER_AUTO_ENABLE(0x2)) &
+	__raw_readl(IO_ADDRESS(DRAM_PHYS_ADDR)
+		+ HW_DRAM_CTL16),
+	IO_ADDRESS(DRAM_PHYS_ADDR) + HW_DRAM_CTL16);
+}
+
+static inline void do_standby(void)
+{
+	void (*mx23_cpu_standby_ptr) (void);
+	struct clk *cpu_clk;
+	struct clk *osc_clk;
+	struct clk *pll_clk;
+	struct clk *hbus_clk;
+	struct clk *cpu_parent = NULL;
+	int cpu_rate = 0;
+	int hbus_rate = 0;
+	u32 reg_clkctrl_clkseq, reg_clkctrl_xtal;
+	unsigned long iram_phy_addr;
+	void *iram_virtual_addr;
+
+	/*
+	 * 1) switch clock domains from PLL to 24MHz
+	 * 2) lower voltage (TODO)
+	 * 3) switch EMI to 24MHz and turn PLL off (done in sleep.S)
+	 */
+
+
+	/* make sure SRAM copy gets physically written into SDRAM.
+	 * SDRAM will be placed into self-refresh during power down
+	 */
+	flush_cache_all();
+	iram_virtual_addr = iram_alloc(MAX_POWEROFF_CODE_SIZE, &iram_phy_addr);
+	if (iram_virtual_addr == NULL) {
+		pr_info("can not get iram for suspend\n");
+		return;
+	}
+
+	/* copy suspend function into SRAM */
+	memcpy(iram_virtual_addr, mx23_standby,
+			MAX_POWEROFF_CODE_SIZE);
+
+	/* now switch the CPU to ref_xtal */
+	cpu_clk = clk_get(NULL, "cpu");
+	osc_clk = clk_get(NULL, "ref_xtal");
+	pll_clk = clk_get(NULL, "pll.0");
+	hbus_clk = clk_get(NULL, "h");
+
+	if (!IS_ERR(cpu_clk) && !IS_ERR(osc_clk)) {
+		cpu_rate = clk_get_rate(cpu_clk);
+		cpu_parent = clk_get_parent(cpu_clk);
+		hbus_rate = clk_get_rate(hbus_clk);
+		clk_set_parent(cpu_clk, osc_clk);
+	}
+
+	local_fiq_disable();
+	mxs_nomatch_suspend_timer();
+
+	__raw_writel(BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_SET);
+
+	reg_clkctrl_clkseq = __raw_readl(REGS_CLKCTRL_BASE +
+		HW_CLKCTRL_CLKSEQ);
+
+	__raw_writel(BM_CLKCTRL_CLKSEQ_BYPASS_ETM |
+		BM_CLKCTRL_CLKSEQ_BYPASS_SSP |
+		BM_CLKCTRL_CLKSEQ_BYPASS_GPMI |
+		BM_CLKCTRL_CLKSEQ_BYPASS_IR |
+		BM_CLKCTRL_CLKSEQ_BYPASS_PIX |
+		BM_CLKCTRL_CLKSEQ_BYPASS_SAIF,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_CLKSEQ_SET);
+
+	reg_clkctrl_xtal = __raw_readl(REGS_CLKCTRL_BASE + HW_CLKCTRL_XTAL);
+
+	__raw_writel(reg_clkctrl_xtal | BM_CLKCTRL_XTAL_FILT_CLK24M_GATE |
+		BM_CLKCTRL_XTAL_PWM_CLK24M_GATE |
+		BM_CLKCTRL_XTAL_DRI_CLK24M_GATE,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_XTAL);
+
+	/* do suspend */
+	mx23_cpu_standby_ptr = iram_virtual_addr;
+	mx23_cpu_standby_ptr();
+
+	__raw_writel(reg_clkctrl_clkseq, REGS_CLKCTRL_BASE + HW_CLKCTRL_CLKSEQ);
+	__raw_writel(reg_clkctrl_xtal, REGS_CLKCTRL_BASE + HW_CLKCTRL_XTAL);
+
+	saved_sleep_state = 0;  /* waking from standby */
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	mxs_nomatch_resume_timer();
+
+	local_fiq_enable();
+
+	if (cpu_parent) {
+		clk_set_parent(cpu_clk, cpu_parent);
+		clk_set_rate(cpu_clk, cpu_rate);
+		clk_set_rate(hbus_clk, hbus_rate);
+	}
+
+	clk_put(hbus_clk);
+	clk_put(pll_clk);
+	clk_put(osc_clk);
+	clk_put(cpu_clk);
+
+	iram_free(iram_phy_addr, MAX_POWEROFF_CODE_SIZE);
+}
+
+static u32 clk_regs[] = {
+		HW_CLKCTRL_PLLCTRL0,
+		HW_CLKCTRL_XTAL,
+		HW_CLKCTRL_PIX,
+		HW_CLKCTRL_SSP,
+		HW_CLKCTRL_GPMI,
+		HW_CLKCTRL_FRAC,
+		HW_CLKCTRL_CLKSEQ,
+};
+
+static noinline void do_mem(void)
+{
+	unsigned long iram_phy_addr;
+	void *iram_virtual_addr;
+	void (*mx23_cpu_suspend_ptr) (u32);
+	struct sleep_data saved_context;
+	int i;
+	struct clk *cpu_clk;
+	struct clk *osc_clk;
+	struct clk *pll_clk;
+	struct clk *hbus_clk;
+	int cpu_rate = 0;
+	int hbus_rate = 0;
+
+	saved_context.fingerprint = SLEEP_DATA_FINGERPRINT;
+
+	saved_context.old_c00 = __raw_readl(0xC0000000);
+	saved_context.old_c04 = __raw_readl(0xC0000004);
+	__raw_writel((u32)&saved_context, (void *)0xC0000000);
+
+	iram_virtual_addr = iram_alloc(MAX_POWEROFF_CODE_SIZE, &iram_phy_addr);
+	if (iram_virtual_addr == NULL) {
+		pr_info("can not get iram for suspend\n");
+		return;
+	}
+
+	local_irq_disable();
+	local_fiq_disable();
+
+	/* mxs_dma_suspend(); */
+	mxs_nomatch_suspend_timer();
+
+	/* clocks */
+	for (i = 0; i < ARRAY_SIZE(clk_regs); i++)
+		saved_context.clks[i] =
+				__raw_readl(clk_regs[i]);
+
+	/* interrupt collector */
+	/*
+	saved_context.icoll_ctrl =
+		__raw_readl(REGS_ICOLL_BASE + HW_ICOLL_CTRL);
+	if (machine_is_mx23()) {
+#ifdef CONFIG_MACH_MX23
+		for (i = 0; i < 16; i++)
+			saved_context.icoll.prio[i] =
+			__raw_readl(REGS_ICOLL_BASE + HW_ICOLL_PRIORITYn(i));
+#endif
+	} else if (machine_is_mx23()) {
+#ifdef CONFIG_MACH_STMP378X
+		for (i = 0; i < 128; i++)
+			saved_context.icoll.intr[i] =
+			__raw_readl(REGS_ICOLL_BASE + HW_ICOLL_INTERRUPTn(i));
+#endif
+	}
+	*/
+
+	/* save pinmux state */
+	for (i = 0; i < 0x100; i++)
+		saved_context.pinmux[i] =
+			__raw_readl(IO_ADDRESS(PINCTRL_PHYS_ADDR) + (i<<4));
+
+	cpu_clk = clk_get(NULL, "cpu");
+	osc_clk = clk_get(NULL, "osc_24M");
+	pll_clk = clk_get(NULL, "pll");
+	hbus_clk = clk_get(NULL, "hclk");
+
+	cpu_rate = clk_get_rate(cpu_clk);
+	hbus_rate = clk_get_rate(hbus_clk);
+
+
+	/* set the PERSISTENT_SLEEP_BIT for bootloader */
+	__raw_writel(1 << 10,
+		IO_ADDRESS(RTC_PHYS_ADDR) + HW_RTC_PERSISTENT1_SET);
+	/* XXX: temp */
+
+	/*
+	 * make sure SRAM copy gets physically written into SDRAM.
+	 * SDRAM will be placed into self-refresh during power down
+	 */
+	flush_cache_all();
+
+	/*copy suspend function into SRAM */
+	memcpy(iram_virtual_addr, mx23_cpu_suspend,
+		MAX_POWEROFF_CODE_SIZE);
+
+	/* do suspend */
+	mx23_cpu_suspend_ptr = (void *)MX23_OCRAM_BASE;
+	mx23_cpu_suspend_ptr(0);
+
+	saved_sleep_state = 1;	/* waking from non-standby state */
+
+
+	/* clocks */
+	for (i = 0; i < ARRAY_SIZE(clk_regs); i++)
+		__raw_writel(saved_context.clks[i],
+			clk_regs[i]);
+
+	/* interrupt collector */
+/*
+	__raw_writel(saved_context.icoll_ctrl, REGS_ICOLL_BASE + HW_ICOLL_CTRL);
+	if (machine_is_mx23()) {
+#ifdef CONFIG_MACH_MX23
+		for (i = 0; i < 16; i++)
+			__raw_writel(saved_context.icoll.prio[i],
+			REGS_ICOLL_BASE + HW_ICOLL_PRIORITYn(i));
+#endif
+	} else if (machine_is_mx23()) {
+#ifdef CONFIG_MACH_STMP378X
+		for (i = 0; i < 128; i++)
+			__raw_writel(saved_context.icoll.intr[i],
+			REGS_ICOLL_BASE + HW_ICOLL_INTERRUPTn(i));
+#endif
+	}
+*/
+
+	/* restore pinmux state */
+	for (i = 0; i < 0x100; i++)
+		__raw_writel(saved_context.pinmux[i],
+				IO_ADDRESS(PINCTRL_PHYS_ADDR) + (i<<4));
+
+	clk_set_rate(cpu_clk, cpu_rate);
+	clk_set_rate(hbus_clk, hbus_rate);
+
+	__raw_writel(saved_context.old_c00, 0xC0000000);
+	__raw_writel(saved_context.old_c04, 0xC0000004);
+
+	clk_put(hbus_clk);
+	clk_put(pll_clk);
+	clk_put(osc_clk);
+	clk_put(cpu_clk);
+
+	mxs_nomatch_resume_timer();
+	/* mxs_dma_resume(); */
+
+	iram_free(iram_phy_addr, MAX_POWEROFF_CODE_SIZE);
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+static int mx23_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		do_standby();
+		break;
+	case PM_SUSPEND_MEM:
+		do_mem();
+		break;
+	}
+	return 0;
+}
+
+static int mx23_pm_valid(suspend_state_t state)
+{
+	return (state == PM_SUSPEND_STANDBY) ||
+	       (state == PM_SUSPEND_MEM);
+}
+
+static suspend_state_t saved_state;
+
+static int mx23_pm_begin(suspend_state_t state)
+{
+	saved_state = state;
+	return 0;
+}
+
+static void mx23_pm_end(void)
+{
+	/*XXX: Nothing to do */
+}
+
+suspend_state_t mx23_pm_get_target(void)
+{
+	return saved_state;
+}
+EXPORT_SYMBOL(mx23_pm_get_target);
+
+/**
+ * mx23_pm_get_sleep_state - get sleep state we waking from
+ *
+ * returns boolean: 0 if waking up from standby, 1 otherwise
+ */
+int mx23_pm_sleep_was_deep(void)
+{
+	return saved_sleep_state;
+}
+EXPORT_SYMBOL(mx23_pm_sleep_was_deep);
+
+static struct platform_suspend_ops mx23_suspend_ops = {
+	.enter	= mx23_pm_enter,
+	.valid	= mx23_pm_valid,
+	.begin	= mx23_pm_begin,
+	.end	= mx23_pm_end,
+};
+
+void mx23_pm_idle(void)
+{
+	local_irq_disable();
+	local_fiq_disable();
+	if (need_resched()) {
+		local_fiq_enable();
+		local_irq_enable();
+		return;
+	}
+
+	__raw_writel(1<<12, REGS_CLKCTRL_BASE + HW_CLKCTRL_CPU_SET);
+	__asm__ __volatile__ ("mcr	p15, 0, r0, c7, c0, 4");
+
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+static void mx23_pm_power_off(void)
+{
+	__raw_writel((0x3e77 << 16) | 1, REGS_POWER_BASE + HW_POWER_RESET);
+}
+
+struct mx23_pswitch_state {
+	int dev_running;
+};
+
+static DECLARE_COMPLETION(suspend_request);
+
+static int suspend_thread_fn(void *data)
+{
+	while (1) {
+		wait_for_completion_interruptible(&suspend_request);
+		pm_suspend(PM_SUSPEND_STANDBY);
+	}
+	return 0;
+}
+
+static struct mx23_pswitch_state pswitch_state = {
+	.dev_running = 0,
+};
+
+static irqreturn_t pswitch_interrupt(int irq, void *dev)
+{
+	int pin_value, i;
+
+	/* check if irq by pswitch */
+	if (!(__raw_readl(REGS_POWER_BASE + HW_POWER_CTRL) &
+		BM_POWER_CTRL_PSWITCH_IRQ))
+		return IRQ_HANDLED;
+	for (i = 0; i < 3000; i++) {
+		pin_value = __raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+			BF_POWER_STS_PSWITCH(0x1);
+		if (pin_value == 0)
+			break;
+		mdelay(1);
+	}
+	if (i < 3000) {
+		pr_info("pswitch goto suspend\n");
+		complete(&suspend_request);
+	} else {
+		pr_info("release pswitch to power down\n");
+		for (i = 0; i < 5000; i++) {
+			pin_value = __raw_readl(REGS_POWER_BASE + HW_POWER_STS)
+				& BF_POWER_STS_PSWITCH(0x1);
+			if (pin_value == 0)
+				break;
+			mdelay(1);
+		}
+		pr_info("pswitch power down\n");
+		mx23_pm_power_off();
+	}
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction pswitch_irq = {
+	.name		= "pswitch",
+	.flags		= IRQF_DISABLED | IRQF_SHARED,
+	.handler	= pswitch_interrupt,
+	.dev_id		= &pswitch_state,
+};
+
+static void init_pswitch(void)
+{
+	kthread_run(suspend_thread_fn, NULL, "pswitch");
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	__raw_writel(BM_POWER_CTRL_POLARITY_PSWITCH |
+		BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_SET);
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	setup_irq(IRQ_VDD5V, &pswitch_irq);
+}
+
+static int __init mx23_pm_init(void)
+{
+	saved_sram = kmalloc(0x4000, GFP_ATOMIC);
+	if (!saved_sram) {
+		printk(KERN_ERR
+		 "PM Suspend: can't allocate memory to save portion of SRAM\n");
+		return -ENOMEM;
+	}
+
+	pm_power_off = mx23_pm_power_off;
+	pm_idle = mx23_pm_idle;
+	suspend_set_ops(&mx23_suspend_ops);
+	init_pswitch();
+	return 0;
+}
+
+late_initcall(mx23_pm_init);
diff --git a/arch/arm/mach-mx23/power.c b/arch/arm/mach-mx23/power.c
new file mode 100644
index 0000000..4f4f6b8
--- /dev/null
+++ b/arch/arm/mach-mx23/power.c
@@ -0,0 +1,523 @@
+/*
+ * Freescale STMP378X voltage regulator low-level driver
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/* #define DEBUG */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <mach/power.h>
+#include <mach/regulator.h>
+#include <mach/regs-power.h>
+
+static int get_voltage(struct mxs_regulator *sreg)
+{
+	struct mxs_platform_regulator_data *rdata = sreg->rdata;
+	u32 val = __raw_readl(rdata->control_reg) & 0x1f;
+	int uv  = rdata->min_voltage + val *
+		  (rdata->max_voltage - rdata->min_voltage) / 0x1f;
+	return uv;
+}
+
+static int get_bo_voltage(struct mxs_regulator *sreg)
+{
+	int uv;
+	int offs;
+
+	if (!sreg->parent)
+		return -EINVAL;
+
+	uv = get_voltage(sreg->parent);
+	offs = (__raw_readl(sreg->parent->rdata->control_reg) & ~0x700) >> 8;
+	return uv - 25000*offs;
+}
+
+static int set_voltage(struct mxs_regulator *sreg, int uv)
+{
+	u32 val, reg, i;
+
+	pr_debug("%s: uv %d, min %d, max %d\n", __func__,
+		uv, sreg->rdata->min_voltage, sreg->rdata->max_voltage);
+
+	if (uv < sreg->rdata->min_voltage || uv > sreg->rdata->max_voltage)
+		return -EINVAL;
+
+	val = (uv - sreg->rdata->min_voltage) * 0x1f /
+			(sreg->rdata->max_voltage - sreg->rdata->min_voltage);
+	reg = (__raw_readl(sreg->rdata->control_reg) & ~0x1f);
+	pr_debug("%s: calculated val %d\n", __func__, val);
+	__raw_writel(val | reg, sreg->rdata->control_reg);
+	for (i = 20; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	__raw_writel(val | reg, sreg->rdata->control_reg);
+	for (i = 40000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	for (i = 40000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+out:
+	return !i;
+}
+
+static int set_bo_voltage(struct mxs_regulator *sreg, int bo_uv)
+{
+	int uv;
+	int offs;
+	u32 reg;
+	int i;
+
+	if (!sreg->parent)
+		return -EINVAL;
+
+	uv = get_voltage(sreg->parent);
+	offs = (uv - bo_uv) / 25000;
+	if (offs < 0 || offs > 7)
+		return -EINVAL;
+
+	reg = (__raw_readl(sreg->parent->rdata->control_reg) & ~0x700);
+	pr_debug("%s: calculated offs %d\n", __func__, offs);
+	__raw_writel((offs << 8) | reg, sreg->parent->rdata->control_reg);
+
+	for (i = 10000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	for (i = 10000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+out:
+	return !i;
+}
+
+static int enable(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int disable(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int is_enabled(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 1;
+}
+
+static int set_mode(struct mxs_regulator *sreg, int mode)
+{
+	int ret = 0;
+	u32 val;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		val = __raw_readl(sreg->rdata->control_reg);
+		__raw_writel(val | (1 << 17), sreg->rdata->control_reg);
+		break;
+
+	case REGULATOR_MODE_NORMAL:
+		val = __raw_readl(sreg->rdata->control_reg);
+		__raw_writel(val & ~(1<<17), sreg->rdata->control_reg);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int get_mode(struct mxs_regulator *sreg)
+{
+	u32 val = __raw_readl(sreg->rdata->control_reg) & (1 << 17);
+
+	return val ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;
+}
+
+static struct mxs_platform_regulator_data vddd_data = {
+	.name		= "vddd",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDDCTRL),
+	.min_voltage	= 800000,
+	.max_voltage	= 1575000,
+};
+
+static struct mxs_platform_regulator_data vdddbo_data = {
+	.name		= "vddd_bo",
+	.parent_name	= "vddd",
+	.set_voltage	= set_bo_voltage,
+	.get_voltage	= get_bo_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.min_voltage	= 800000,
+	.max_voltage	= 1575000,
+};
+
+static struct mxs_platform_regulator_data vdda_data = {
+	.name		= "vdda",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDACTRL),
+	.min_voltage	= 1500000,
+	.max_voltage	= 2275000,
+};
+
+static struct mxs_platform_regulator_data vddio_data = {
+	.name		= "vddio",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDIOCTRL),
+	.min_voltage	= 2800000,
+	.max_voltage	= 3575000,
+};
+
+static struct regulator_init_data vddd_init = {
+	.constraints = {
+		.name			= "vddd",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+static struct regulator_init_data vdddbo_init = {
+	.constraints = {
+		.name			= "vdddbo",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+
+static struct regulator_init_data vdda_init = {
+	.constraints = {
+		.name			= "vdda",
+		.min_uV			= 1500000,
+		.max_uV			= 2275000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+
+static struct regulator_init_data vddio_init = {
+	.constraints = {
+		.name			= "vddio",
+		.min_uV			= 2800000,
+		.max_uV			= 3575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+/* now the current regulators */
+/* Restriction: .... no set_current call on root regulator */
+static int main_add_current(struct mxs_regulator *sreg,
+			    int uA)
+{
+
+	pr_debug("%s: enter reg %s, uA=%d\n",
+		 __func__, sreg->regulator.name, uA);
+	if (uA > 0 && (sreg->cur_current + uA > sreg->rdata->max_current))
+		return -EINVAL;
+	else
+		sreg->cur_current += uA;
+	return 0;
+}
+
+static int cur_reg_set_current(struct mxs_regulator *sreg, int uA)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	pr_debug("%s: enter reg %s, uA=%d\n",
+		 __func__, sreg->regulator.name, uA);
+
+	if (sreg->parent) {
+		spin_lock_irqsave(&sreg->parent->lock, flags);
+		ret = main_add_current(sreg->parent, uA - sreg->cur_current);
+		spin_unlock_irqrestore(&sreg->parent->lock, flags);
+	}
+
+
+	if ((!ret) || (!sreg->parent))
+		goto out;
+
+	if (sreg->mode == REGULATOR_MODE_FAST)
+		return ret;
+
+	while (ret) {
+		wait_event(sreg->parent->wait_q ,
+			   (uA - sreg->cur_current <
+			    sreg->parent->rdata->max_current -
+			    sreg->parent->cur_current));
+		spin_lock_irqsave(&sreg->parent->lock, flags);
+		ret = main_add_current(sreg->parent, uA - sreg->cur_current);
+		spin_unlock_irqrestore(&sreg->parent->lock, flags);
+	}
+out:
+	if (sreg->parent && (uA - sreg->cur_current < 0))
+		wake_up_all(&sreg->parent->wait_q);
+	sreg->cur_current = uA;
+	return 0;
+
+}
+
+static int cur_reg_get_current(struct mxs_regulator *sreg)
+{
+	return sreg->cur_current;
+}
+
+static int enable_cur_reg(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int disable_cur_reg(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int cur_reg_is_enabled(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 1;
+}
+
+static int cur_reg_set_mode(struct mxs_regulator *sreg, int mode)
+{
+	int ret = 0;
+
+	switch (mode) {
+	case REGULATOR_MODE_NORMAL:
+	case REGULATOR_MODE_FAST:
+		sreg->mode = mode;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int cur_reg_get_mode(struct mxs_regulator *sreg)
+{
+	return sreg->mode;
+}
+
+static struct mxs_platform_regulator_data overall_cur_data = {
+	.name		= "overall_current",
+	.set_current	= cur_reg_set_current,
+	.get_current	= cur_reg_get_current,
+	.enable		= enable_cur_reg,
+	.disable	= disable_cur_reg,
+	.is_enabled	= cur_reg_is_enabled,
+	.set_mode	= cur_reg_set_mode,
+	.get_mode	= cur_reg_get_mode,
+	.max_current	= 0x7fffffff,
+};
+
+static struct regulator_init_data overall_cur_init = {
+	.constraints = {
+		.name			= "overall_current",
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL |
+					  REGULATOR_MODE_FAST,
+		.valid_ops_mask		= REGULATOR_CHANGE_CURRENT |
+					  REGULATOR_CHANGE_MODE,
+		.max_uA                 = 0x7fffffff,
+		.min_uA                 = 0x0,
+		.always_on		= 1,
+	}
+};
+
+static struct mxs_platform_regulator_data sibling_cur_data = {
+	.parent_name	= "overall_current",
+	.set_current	= cur_reg_set_current,
+	.get_current	= cur_reg_get_current,
+	.enable		= enable_cur_reg,
+	.disable	= disable_cur_reg,
+	.is_enabled	= cur_reg_is_enabled,
+	.set_mode	= cur_reg_set_mode,
+	.get_mode	= cur_reg_get_mode,
+};
+
+
+static const char *device_names[] = {
+	"mxs-duart", "mxs-bl", "mxs-i2c"
+};
+
+static int sibling_current_devices_num;
+
+int mxs_platform_add_regulator(const char *name, int count)
+{
+	int i;
+	pr_debug("%s: name %s, count %d\n", __func__, name, count);
+	for (i = sibling_current_devices_num;
+	     i < sibling_current_devices_num + count;
+	     i++) {
+		struct regulator_init_data *sibling_init =
+			kzalloc(sizeof(struct regulator_init_data),
+			GFP_KERNEL);
+		struct mxs_regulator *curr_reg =
+			kzalloc(sizeof(struct mxs_regulator),
+			GFP_KERNEL);
+		struct mxs_platform_regulator_data *d =
+			kzalloc(sizeof(struct mxs_platform_regulator_data),
+			GFP_KERNEL);
+		if (!d || !curr_reg || !sibling_init)
+			return -ENOMEM;
+
+		sibling_init->constraints.valid_modes_mask =
+			REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST;
+		sibling_init->constraints.valid_ops_mask =
+			REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_MODE;
+		sibling_init->constraints.max_uA = 0x7fffffff;
+		sibling_init->constraints.min_uA = 0x0;
+
+		memcpy(d, &sibling_cur_data, sizeof(sibling_cur_data));
+		d->parent_name = kstrdup(sibling_cur_data.parent_name,
+					 GFP_KERNEL);
+		snprintf(d->name, 80, "%s-%d",
+			 name, i - sibling_current_devices_num + 1);
+		sibling_init->constraints.name = kstrdup(d->name, GFP_KERNEL);
+		sibling_init->constraints.always_on = 1;
+		curr_reg->rdata = d;
+		mxs_register_regulator(curr_reg, 101 + i, sibling_init);
+	}
+	sibling_current_devices_num += count;
+	return 0;
+}
+
+static struct mxs_regulator vddd_reg = {
+		.rdata = &vddd_data,
+};
+
+static struct mxs_regulator vdda_reg = {
+		.rdata = &vdda_data,
+};
+
+static struct mxs_regulator vddio_reg = {
+		.rdata = &vddio_data,
+};
+
+static struct mxs_regulator vdddbo_reg = {
+		.rdata = &vdddbo_data,
+};
+
+static struct mxs_regulator overall_cur_reg = {
+		.rdata = &overall_cur_data,
+};
+
+
+static int __init regulators_init(void)
+{
+	int i;
+	int retval = 0;
+	u32 vddio = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL) & ~0x1f;
+	pr_debug("regulators_init \n");
+	__raw_writel(vddio | 0x14, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	vdddbo_reg.parent = &vddd_reg;
+	mxs_register_regulator(&vddd_reg, MXS_VDDD, &vddd_init);
+	mxs_register_regulator(&vdddbo_reg, MXS_VDDDBO, &vdddbo_init);
+	mxs_register_regulator(&vdda_reg, MXS_VDDA, &vdda_init);
+	mxs_register_regulator(&vddio_reg, MXS_VDDIO, &vddio_init);
+	mxs_register_regulator(&overall_cur_reg,
+		MXS_OVERALL_CUR, &overall_cur_init);
+
+	for (i = 0; i < ARRAY_SIZE(device_names); i++) {
+		retval = mxs_platform_add_regulator(device_names[i], 1);
+		if (retval)
+			return retval;
+	}
+	mxs_platform_add_regulator("mmc_ssp", 2);
+	mxs_platform_add_regulator("charger", 1);
+	mxs_platform_add_regulator("power-test", 1);
+	mxs_platform_add_regulator("cpufreq", 1);
+	return 0;
+}
+postcore_initcall(regulators_init);
diff --git a/arch/arm/mach-mx23/regs-clkctrl.h b/arch/arm/mach-mx23/regs-clkctrl.h
new file mode 100644
index 0000000..7b8e089
--- /dev/null
+++ b/arch/arm/mach-mx23/regs-clkctrl.h
@@ -0,0 +1,442 @@
+/*
+ * Freescale CLKCTRL Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.48
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___CLKCTRL_H
+#define __ARCH_ARM___CLKCTRL_H
+
+
+#define HW_CLKCTRL_PLLCTRL0	(0x00000000)
+#define HW_CLKCTRL_PLLCTRL0_SET	(0x00000004)
+#define HW_CLKCTRL_PLLCTRL0_CLR	(0x00000008)
+#define HW_CLKCTRL_PLLCTRL0_TOG	(0x0000000c)
+
+#define BP_CLKCTRL_PLLCTRL0_RSRVD6	30
+#define BM_CLKCTRL_PLLCTRL0_RSRVD6	0xC0000000
+#define BF_CLKCTRL_PLLCTRL0_RSRVD6(v) \
+		(((v) << 30) & BM_CLKCTRL_PLLCTRL0_RSRVD6)
+#define BP_CLKCTRL_PLLCTRL0_LFR_SEL	28
+#define BM_CLKCTRL_PLLCTRL0_LFR_SEL	0x30000000
+#define BF_CLKCTRL_PLLCTRL0_LFR_SEL(v)  \
+		(((v) << 28) & BM_CLKCTRL_PLLCTRL0_LFR_SEL)
+#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLLCTRL0_LFR_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLLCTRL0_RSRVD5	26
+#define BM_CLKCTRL_PLLCTRL0_RSRVD5	0x0C000000
+#define BF_CLKCTRL_PLLCTRL0_RSRVD5(v)  \
+		(((v) << 26) & BM_CLKCTRL_PLLCTRL0_RSRVD5)
+#define BP_CLKCTRL_PLLCTRL0_CP_SEL	24
+#define BM_CLKCTRL_PLLCTRL0_CP_SEL	0x03000000
+#define BF_CLKCTRL_PLLCTRL0_CP_SEL(v)  \
+		(((v) << 24) & BM_CLKCTRL_PLLCTRL0_CP_SEL)
+#define BV_CLKCTRL_PLLCTRL0_CP_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLLCTRL0_CP_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLLCTRL0_CP_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLLCTRL0_CP_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLLCTRL0_RSRVD4	22
+#define BM_CLKCTRL_PLLCTRL0_RSRVD4	0x00C00000
+#define BF_CLKCTRL_PLLCTRL0_RSRVD4(v)  \
+		(((v) << 22) & BM_CLKCTRL_PLLCTRL0_RSRVD4)
+#define BP_CLKCTRL_PLLCTRL0_DIV_SEL	20
+#define BM_CLKCTRL_PLLCTRL0_DIV_SEL	0x00300000
+#define BF_CLKCTRL_PLLCTRL0_DIV_SEL(v)  \
+		(((v) << 20) & BM_CLKCTRL_PLLCTRL0_DIV_SEL)
+#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__LOWER     0x1
+#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__LOWEST    0x2
+#define BV_CLKCTRL_PLLCTRL0_DIV_SEL__UNDEFINED 0x3
+#define BM_CLKCTRL_PLLCTRL0_RSRVD3	0x00080000
+#define BM_CLKCTRL_PLLCTRL0_EN_USB_CLKS	0x00040000
+#define BM_CLKCTRL_PLLCTRL0_RSRVD2	0x00020000
+#define BM_CLKCTRL_PLLCTRL0_POWER	0x00010000
+#define BP_CLKCTRL_PLLCTRL0_RSRVD1	0
+#define BM_CLKCTRL_PLLCTRL0_RSRVD1	0x0000FFFF
+#define BF_CLKCTRL_PLLCTRL0_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLLCTRL0_RSRVD1)
+
+#define HW_CLKCTRL_PLLCTRL1	(0x00000010)
+
+#define BM_CLKCTRL_PLLCTRL1_LOCK	0x80000000
+#define BM_CLKCTRL_PLLCTRL1_FORCE_LOCK	0x40000000
+#define BP_CLKCTRL_PLLCTRL1_RSRVD1	16
+#define BM_CLKCTRL_PLLCTRL1_RSRVD1	0x3FFF0000
+#define BF_CLKCTRL_PLLCTRL1_RSRVD1(v)  \
+		(((v) << 16) & BM_CLKCTRL_PLLCTRL1_RSRVD1)
+#define BP_CLKCTRL_PLLCTRL1_LOCK_COUNT	0
+#define BM_CLKCTRL_PLLCTRL1_LOCK_COUNT	0x0000FFFF
+#define BF_CLKCTRL_PLLCTRL1_LOCK_COUNT(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLLCTRL1_LOCK_COUNT)
+
+#define HW_CLKCTRL_CPU	(0x00000020)
+#define HW_CLKCTRL_CPU_SET	(0x00000024)
+#define HW_CLKCTRL_CPU_CLR	(0x00000028)
+#define HW_CLKCTRL_CPU_TOG	(0x0000002c)
+
+#define BP_CLKCTRL_CPU_RSRVD5	30
+#define BM_CLKCTRL_CPU_RSRVD5	0xC0000000
+#define BF_CLKCTRL_CPU_RSRVD5(v) \
+		(((v) << 30) & BM_CLKCTRL_CPU_RSRVD5)
+#define BM_CLKCTRL_CPU_BUSY_REF_XTAL	0x20000000
+#define BM_CLKCTRL_CPU_BUSY_REF_CPU	0x10000000
+#define BM_CLKCTRL_CPU_RSRVD4	0x08000000
+#define BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN	0x04000000
+#define BP_CLKCTRL_CPU_DIV_XTAL	16
+#define BM_CLKCTRL_CPU_DIV_XTAL	0x03FF0000
+#define BF_CLKCTRL_CPU_DIV_XTAL(v)  \
+		(((v) << 16) & BM_CLKCTRL_CPU_DIV_XTAL)
+#define BP_CLKCTRL_CPU_RSRVD3	13
+#define BM_CLKCTRL_CPU_RSRVD3	0x0000E000
+#define BF_CLKCTRL_CPU_RSRVD3(v)  \
+		(((v) << 13) & BM_CLKCTRL_CPU_RSRVD3)
+#define BM_CLKCTRL_CPU_INTERRUPT_WAIT	0x00001000
+#define BM_CLKCTRL_CPU_RSRVD2	0x00000800
+#define BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN	0x00000400
+#define BP_CLKCTRL_CPU_RSRVD1	6
+#define BM_CLKCTRL_CPU_RSRVD1	0x000003C0
+#define BF_CLKCTRL_CPU_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_CPU_RSRVD1)
+#define BP_CLKCTRL_CPU_DIV_CPU	0
+#define BM_CLKCTRL_CPU_DIV_CPU	0x0000003F
+#define BF_CLKCTRL_CPU_DIV_CPU(v)  \
+		(((v) << 0) & BM_CLKCTRL_CPU_DIV_CPU)
+
+#define HW_CLKCTRL_HBUS	(0x00000030)
+#define HW_CLKCTRL_HBUS_SET	(0x00000034)
+#define HW_CLKCTRL_HBUS_CLR	(0x00000038)
+#define HW_CLKCTRL_HBUS_TOG	(0x0000003c)
+
+#define BP_CLKCTRL_HBUS_RSRVD4	30
+#define BM_CLKCTRL_HBUS_RSRVD4	0xC0000000
+#define BF_CLKCTRL_HBUS_RSRVD4(v) \
+		(((v) << 30) & BM_CLKCTRL_HBUS_RSRVD4)
+#define BM_CLKCTRL_HBUS_BUSY	0x20000000
+#define BM_CLKCTRL_HBUS_DCP_AS_ENABLE	0x10000000
+#define BM_CLKCTRL_HBUS_PXP_AS_ENABLE	0x08000000
+#define BM_CLKCTRL_HBUS_APBHDMA_AS_ENABLE	0x04000000
+#define BM_CLKCTRL_HBUS_APBXDMA_AS_ENABLE	0x02000000
+#define BM_CLKCTRL_HBUS_TRAFFIC_JAM_AS_ENABLE	0x01000000
+#define BM_CLKCTRL_HBUS_TRAFFIC_AS_ENABLE	0x00800000
+#define BM_CLKCTRL_HBUS_CPU_DATA_AS_ENABLE	0x00400000
+#define BM_CLKCTRL_HBUS_CPU_INSTR_AS_ENABLE	0x00200000
+#define BM_CLKCTRL_HBUS_AUTO_SLOW_MODE	0x00100000
+#define BM_CLKCTRL_HBUS_RSRVD2	0x00080000
+#define BP_CLKCTRL_HBUS_SLOW_DIV	16
+#define BM_CLKCTRL_HBUS_SLOW_DIV	0x00070000
+#define BF_CLKCTRL_HBUS_SLOW_DIV(v)  \
+		(((v) << 16) & BM_CLKCTRL_HBUS_SLOW_DIV)
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY1  0x0
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY2  0x1
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY4  0x2
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY8  0x3
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY16 0x4
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY32 0x5
+#define BP_CLKCTRL_HBUS_RSRVD1	6
+#define BM_CLKCTRL_HBUS_RSRVD1	0x0000FFC0
+#define BF_CLKCTRL_HBUS_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_HBUS_RSRVD1)
+#define BM_CLKCTRL_HBUS_DIV_FRAC_EN	0x00000020
+#define BP_CLKCTRL_HBUS_DIV	0
+#define BM_CLKCTRL_HBUS_DIV	0x0000001F
+#define BF_CLKCTRL_HBUS_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_HBUS_DIV)
+
+#define HW_CLKCTRL_XBUS	(0x00000040)
+
+#define BM_CLKCTRL_XBUS_BUSY	0x80000000
+#define BP_CLKCTRL_XBUS_RSRVD1	11
+#define BM_CLKCTRL_XBUS_RSRVD1	0x7FFFF800
+#define BF_CLKCTRL_XBUS_RSRVD1(v)  \
+		(((v) << 11) & BM_CLKCTRL_XBUS_RSRVD1)
+#define BM_CLKCTRL_XBUS_DIV_FRAC_EN	0x00000400
+#define BP_CLKCTRL_XBUS_DIV	0
+#define BM_CLKCTRL_XBUS_DIV	0x000003FF
+#define BF_CLKCTRL_XBUS_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_XBUS_DIV)
+
+#define HW_CLKCTRL_XTAL	(0x00000050)
+#define HW_CLKCTRL_XTAL_SET	(0x00000054)
+#define HW_CLKCTRL_XTAL_CLR	(0x00000058)
+#define HW_CLKCTRL_XTAL_TOG	(0x0000005c)
+
+#define BM_CLKCTRL_XTAL_UART_CLK_GATE	0x80000000
+#define BM_CLKCTRL_XTAL_FILT_CLK24M_GATE	0x40000000
+#define BM_CLKCTRL_XTAL_PWM_CLK24M_GATE	0x20000000
+#define BM_CLKCTRL_XTAL_DRI_CLK24M_GATE	0x10000000
+#define BM_CLKCTRL_XTAL_DIGCTRL_CLK1M_GATE	0x08000000
+#define BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	0x04000000
+#define BP_CLKCTRL_XTAL_RSRVD1	2
+#define BM_CLKCTRL_XTAL_RSRVD1	0x03FFFFFC
+#define BF_CLKCTRL_XTAL_RSRVD1(v)  \
+		(((v) << 2) & BM_CLKCTRL_XTAL_RSRVD1)
+#define BP_CLKCTRL_XTAL_DIV_UART	0
+#define BM_CLKCTRL_XTAL_DIV_UART	0x00000003
+#define BF_CLKCTRL_XTAL_DIV_UART(v)  \
+		(((v) << 0) & BM_CLKCTRL_XTAL_DIV_UART)
+
+#define HW_CLKCTRL_PIX	(0x00000060)
+
+#define BM_CLKCTRL_PIX_CLKGATE	0x80000000
+#define BM_CLKCTRL_PIX_RSRVD2	0x40000000
+#define BM_CLKCTRL_PIX_BUSY	0x20000000
+#define BP_CLKCTRL_PIX_RSRVD1	13
+#define BM_CLKCTRL_PIX_RSRVD1	0x1FFFE000
+#define BF_CLKCTRL_PIX_RSRVD1(v)  \
+		(((v) << 13) & BM_CLKCTRL_PIX_RSRVD1)
+#define BM_CLKCTRL_PIX_DIV_FRAC_EN	0x00001000
+#define BP_CLKCTRL_PIX_DIV	0
+#define BM_CLKCTRL_PIX_DIV	0x00000FFF
+#define BF_CLKCTRL_PIX_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_PIX_DIV)
+
+#define HW_CLKCTRL_SSP	(0x00000070)
+
+#define BM_CLKCTRL_SSP_CLKGATE	0x80000000
+#define BM_CLKCTRL_SSP_RSRVD2	0x40000000
+#define BM_CLKCTRL_SSP_BUSY	0x20000000
+#define BP_CLKCTRL_SSP_RSRVD1	10
+#define BM_CLKCTRL_SSP_RSRVD1	0x1FFFFC00
+#define BF_CLKCTRL_SSP_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_SSP_RSRVD1)
+#define BM_CLKCTRL_SSP_DIV_FRAC_EN	0x00000200
+#define BP_CLKCTRL_SSP_DIV	0
+#define BM_CLKCTRL_SSP_DIV	0x000001FF
+#define BF_CLKCTRL_SSP_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SSP_DIV)
+
+#define HW_CLKCTRL_GPMI	(0x00000080)
+
+#define BM_CLKCTRL_GPMI_CLKGATE	0x80000000
+#define BM_CLKCTRL_GPMI_RSRVD2	0x40000000
+#define BM_CLKCTRL_GPMI_BUSY	0x20000000
+#define BP_CLKCTRL_GPMI_RSRVD1	11
+#define BM_CLKCTRL_GPMI_RSRVD1	0x1FFFF800
+#define BF_CLKCTRL_GPMI_RSRVD1(v)  \
+		(((v) << 11) & BM_CLKCTRL_GPMI_RSRVD1)
+#define BM_CLKCTRL_GPMI_DIV_FRAC_EN	0x00000400
+#define BP_CLKCTRL_GPMI_DIV	0
+#define BM_CLKCTRL_GPMI_DIV	0x000003FF
+#define BF_CLKCTRL_GPMI_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_GPMI_DIV)
+
+#define HW_CLKCTRL_SPDIF	(0x00000090)
+
+#define BM_CLKCTRL_SPDIF_CLKGATE	0x80000000
+#define BP_CLKCTRL_SPDIF_RSRVD	0
+#define BM_CLKCTRL_SPDIF_RSRVD	0x7FFFFFFF
+#define BF_CLKCTRL_SPDIF_RSRVD(v)  \
+		(((v) << 0) & BM_CLKCTRL_SPDIF_RSRVD)
+
+#define HW_CLKCTRL_EMI	(0x000000a0)
+
+#define BM_CLKCTRL_EMI_CLKGATE	0x80000000
+#define BM_CLKCTRL_EMI_SYNC_MODE_EN	0x40000000
+#define BM_CLKCTRL_EMI_BUSY_REF_XTAL	0x20000000
+#define BM_CLKCTRL_EMI_BUSY_REF_EMI	0x10000000
+#define BM_CLKCTRL_EMI_BUSY_REF_CPU	0x08000000
+#define BM_CLKCTRL_EMI_BUSY_SYNC_MODE	0x04000000
+#define BP_CLKCTRL_EMI_RSRVD3	18
+#define BM_CLKCTRL_EMI_RSRVD3	0x03FC0000
+#define BF_CLKCTRL_EMI_RSRVD3(v)  \
+		(((v) << 18) & BM_CLKCTRL_EMI_RSRVD3)
+#define BM_CLKCTRL_EMI_BUSY_DCC_RESYNC	0x00020000
+#define BM_CLKCTRL_EMI_DCC_RESYNC_ENABLE	0x00010000
+#define BP_CLKCTRL_EMI_RSRVD2	12
+#define BM_CLKCTRL_EMI_RSRVD2	0x0000F000
+#define BF_CLKCTRL_EMI_RSRVD2(v)  \
+		(((v) << 12) & BM_CLKCTRL_EMI_RSRVD2)
+#define BP_CLKCTRL_EMI_DIV_XTAL	8
+#define BM_CLKCTRL_EMI_DIV_XTAL	0x00000F00
+#define BF_CLKCTRL_EMI_DIV_XTAL(v)  \
+		(((v) << 8) & BM_CLKCTRL_EMI_DIV_XTAL)
+#define BP_CLKCTRL_EMI_RSRVD1	6
+#define BM_CLKCTRL_EMI_RSRVD1	0x000000C0
+#define BF_CLKCTRL_EMI_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_EMI_RSRVD1)
+#define BP_CLKCTRL_EMI_DIV_EMI	0
+#define BM_CLKCTRL_EMI_DIV_EMI	0x0000003F
+#define BF_CLKCTRL_EMI_DIV_EMI(v)  \
+		(((v) << 0) & BM_CLKCTRL_EMI_DIV_EMI)
+
+#define HW_CLKCTRL_IR	(0x000000b0)
+
+#define BM_CLKCTRL_IR_CLKGATE	0x80000000
+#define BM_CLKCTRL_IR_RSRVD3	0x40000000
+#define BM_CLKCTRL_IR_AUTO_DIV	0x20000000
+#define BM_CLKCTRL_IR_IR_BUSY	0x10000000
+#define BM_CLKCTRL_IR_IROV_BUSY	0x08000000
+#define BP_CLKCTRL_IR_RSRVD2	25
+#define BM_CLKCTRL_IR_RSRVD2	0x06000000
+#define BF_CLKCTRL_IR_RSRVD2(v)  \
+		(((v) << 25) & BM_CLKCTRL_IR_RSRVD2)
+#define BP_CLKCTRL_IR_IROV_DIV	16
+#define BM_CLKCTRL_IR_IROV_DIV	0x01FF0000
+#define BF_CLKCTRL_IR_IROV_DIV(v)  \
+		(((v) << 16) & BM_CLKCTRL_IR_IROV_DIV)
+#define BP_CLKCTRL_IR_RSRVD1	10
+#define BM_CLKCTRL_IR_RSRVD1	0x0000FC00
+#define BF_CLKCTRL_IR_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_IR_RSRVD1)
+#define BP_CLKCTRL_IR_IR_DIV	0
+#define BM_CLKCTRL_IR_IR_DIV	0x000003FF
+#define BF_CLKCTRL_IR_IR_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_IR_IR_DIV)
+
+#define HW_CLKCTRL_SAIF	(0x000000c0)
+
+#define BM_CLKCTRL_SAIF_CLKGATE	0x80000000
+#define BM_CLKCTRL_SAIF_RSRVD2	0x40000000
+#define BM_CLKCTRL_SAIF_BUSY	0x20000000
+#define BP_CLKCTRL_SAIF_RSRVD1	17
+#define BM_CLKCTRL_SAIF_RSRVD1	0x1FFE0000
+#define BF_CLKCTRL_SAIF_RSRVD1(v)  \
+		(((v) << 17) & BM_CLKCTRL_SAIF_RSRVD1)
+#define BM_CLKCTRL_SAIF_DIV_FRAC_EN	0x00010000
+#define BP_CLKCTRL_SAIF_DIV	0
+#define BM_CLKCTRL_SAIF_DIV	0x0000FFFF
+#define BF_CLKCTRL_SAIF_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SAIF_DIV)
+
+#define HW_CLKCTRL_TV	(0x000000d0)
+
+#define BM_CLKCTRL_TV_CLK_TV108M_GATE	0x80000000
+#define BM_CLKCTRL_TV_CLK_TV_GATE	0x40000000
+#define BP_CLKCTRL_TV_RSRVD	0
+#define BM_CLKCTRL_TV_RSRVD	0x3FFFFFFF
+#define BF_CLKCTRL_TV_RSRVD(v)  \
+		(((v) << 0) & BM_CLKCTRL_TV_RSRVD)
+
+#define HW_CLKCTRL_ETM	(0x000000e0)
+
+#define BM_CLKCTRL_ETM_CLKGATE	0x80000000
+#define BM_CLKCTRL_ETM_RSRVD2	0x40000000
+#define BM_CLKCTRL_ETM_BUSY	0x20000000
+#define BP_CLKCTRL_ETM_RSRVD1	7
+#define BM_CLKCTRL_ETM_RSRVD1	0x1FFFFF80
+#define BF_CLKCTRL_ETM_RSRVD1(v)  \
+		(((v) << 7) & BM_CLKCTRL_ETM_RSRVD1)
+#define BM_CLKCTRL_ETM_DIV_FRAC_EN	0x00000040
+#define BP_CLKCTRL_ETM_DIV	0
+#define BM_CLKCTRL_ETM_DIV	0x0000003F
+#define BF_CLKCTRL_ETM_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_ETM_DIV)
+
+#define HW_CLKCTRL_FRAC	(0x000000f0)
+#define HW_CLKCTRL_FRAC_SET	(0x000000f4)
+#define HW_CLKCTRL_FRAC_CLR	(0x000000f8)
+#define HW_CLKCTRL_FRAC_TOG	(0x000000fc)
+
+#define BM_CLKCTRL_FRAC_CLKGATEIO	0x80000000
+#define BM_CLKCTRL_FRAC_IO_STABLE	0x40000000
+#define BP_CLKCTRL_FRAC_IOFRAC	24
+#define BM_CLKCTRL_FRAC_IOFRAC	0x3F000000
+#define BF_CLKCTRL_FRAC_IOFRAC(v)  \
+		(((v) << 24) & BM_CLKCTRL_FRAC_IOFRAC)
+#define BM_CLKCTRL_FRAC_CLKGATEPIX	0x00800000
+#define BM_CLKCTRL_FRAC_PIX_STABLE	0x00400000
+#define BP_CLKCTRL_FRAC_PIXFRAC	16
+#define BM_CLKCTRL_FRAC_PIXFRAC	0x003F0000
+#define BF_CLKCTRL_FRAC_PIXFRAC(v)  \
+		(((v) << 16) & BM_CLKCTRL_FRAC_PIXFRAC)
+#define BM_CLKCTRL_FRAC_CLKGATEEMI	0x00008000
+#define BM_CLKCTRL_FRAC_EMI_STABLE	0x00004000
+#define BP_CLKCTRL_FRAC_EMIFRAC	8
+#define BM_CLKCTRL_FRAC_EMIFRAC	0x00003F00
+#define BF_CLKCTRL_FRAC_EMIFRAC(v)  \
+		(((v) << 8) & BM_CLKCTRL_FRAC_EMIFRAC)
+#define BM_CLKCTRL_FRAC_CLKGATECPU	0x00000080
+#define BM_CLKCTRL_FRAC_CPU_STABLE	0x00000040
+#define BP_CLKCTRL_FRAC_CPUFRAC	0
+#define BM_CLKCTRL_FRAC_CPUFRAC	0x0000003F
+#define BF_CLKCTRL_FRAC_CPUFRAC(v)  \
+		(((v) << 0) & BM_CLKCTRL_FRAC_CPUFRAC)
+
+#define HW_CLKCTRL_FRAC1	(0x00000100)
+#define HW_CLKCTRL_FRAC1_SET	(0x00000104)
+#define HW_CLKCTRL_FRAC1_CLR	(0x00000108)
+#define HW_CLKCTRL_FRAC1_TOG	(0x0000010c)
+
+#define BM_CLKCTRL_FRAC1_CLKGATEVID	0x80000000
+#define BM_CLKCTRL_FRAC1_VID_STABLE	0x40000000
+#define BP_CLKCTRL_FRAC1_RSRVD1	0
+#define BM_CLKCTRL_FRAC1_RSRVD1	0x3FFFFFFF
+#define BF_CLKCTRL_FRAC1_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_FRAC1_RSRVD1)
+
+#define HW_CLKCTRL_CLKSEQ	(0x00000110)
+#define HW_CLKCTRL_CLKSEQ_SET	(0x00000114)
+#define HW_CLKCTRL_CLKSEQ_CLR	(0x00000118)
+#define HW_CLKCTRL_CLKSEQ_TOG	(0x0000011c)
+
+#define BP_CLKCTRL_CLKSEQ_RSRVD1	9
+#define BM_CLKCTRL_CLKSEQ_RSRVD1	0xFFFFFE00
+#define BF_CLKCTRL_CLKSEQ_RSRVD1(v) \
+		(((v) << 9) & BM_CLKCTRL_CLKSEQ_RSRVD1)
+#define BM_CLKCTRL_CLKSEQ_BYPASS_ETM	0x00000100
+#define BM_CLKCTRL_CLKSEQ_BYPASS_CPU	0x00000080
+#define BM_CLKCTRL_CLKSEQ_BYPASS_EMI	0x00000040
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP	0x00000020
+#define BM_CLKCTRL_CLKSEQ_BYPASS_GPMI	0x00000010
+#define BM_CLKCTRL_CLKSEQ_BYPASS_IR	0x00000008
+#define BM_CLKCTRL_CLKSEQ_RSRVD0	0x00000004
+#define BM_CLKCTRL_CLKSEQ_BYPASS_PIX	0x00000002
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF	0x00000001
+
+#define HW_CLKCTRL_RESET	(0x00000120)
+
+#define BP_CLKCTRL_RESET_RSRVD	2
+#define BM_CLKCTRL_RESET_RSRVD	0xFFFFFFFC
+#define BF_CLKCTRL_RESET_RSRVD(v) \
+		(((v) << 2) & BM_CLKCTRL_RESET_RSRVD)
+#define BM_CLKCTRL_RESET_CHIP	0x00000002
+#define BM_CLKCTRL_RESET_DIG	0x00000001
+
+#define HW_CLKCTRL_STATUS	(0x00000130)
+
+#define BP_CLKCTRL_STATUS_CPU_LIMIT	30
+#define BM_CLKCTRL_STATUS_CPU_LIMIT	0xC0000000
+#define BF_CLKCTRL_STATUS_CPU_LIMIT(v) \
+		(((v) << 30) & BM_CLKCTRL_STATUS_CPU_LIMIT)
+#define BP_CLKCTRL_STATUS_RSRVD	0
+#define BM_CLKCTRL_STATUS_RSRVD	0x3FFFFFFF
+#define BF_CLKCTRL_STATUS_RSRVD(v)  \
+		(((v) << 0) & BM_CLKCTRL_STATUS_RSRVD)
+
+#define HW_CLKCTRL_VERSION	(0x00000140)
+
+#define BP_CLKCTRL_VERSION_MAJOR	24
+#define BM_CLKCTRL_VERSION_MAJOR	0xFF000000
+#define BF_CLKCTRL_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_CLKCTRL_VERSION_MAJOR)
+#define BP_CLKCTRL_VERSION_MINOR	16
+#define BM_CLKCTRL_VERSION_MINOR	0x00FF0000
+#define BF_CLKCTRL_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_CLKCTRL_VERSION_MINOR)
+#define BP_CLKCTRL_VERSION_STEP	0
+#define BM_CLKCTRL_VERSION_STEP	0x0000FFFF
+#define BF_CLKCTRL_VERSION_STEP(v)  \
+		(((v) << 0) & BM_CLKCTRL_VERSION_STEP)
+#endif /* __ARCH_ARM___CLKCTRL_H */
diff --git a/arch/arm/mach-mx23/regs-digctl.h b/arch/arm/mach-mx23/regs-digctl.h
new file mode 100644
index 0000000..291ba92
--- /dev/null
+++ b/arch/arm/mach-mx23/regs-digctl.h
@@ -0,0 +1,724 @@
+/*
+ * Freescale DIGCTL Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.0
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___DIGCTL_H
+#define __ARCH_ARM___DIGCTL_H
+
+
+#define HW_DIGCTL_CTRL	(0x00000000)
+#define HW_DIGCTL_CTRL_SET	(0x00000004)
+#define HW_DIGCTL_CTRL_CLR	(0x00000008)
+#define HW_DIGCTL_CTRL_TOG	(0x0000000c)
+
+#define BM_DIGCTL_CTRL_RSVD3	0x80000000
+#define BM_DIGCTL_CTRL_XTAL24M_GATE	0x40000000
+#define BM_DIGCTL_CTRL_TRAP_IRQ	0x20000000
+#define BP_DIGCTL_CTRL_RSVD2	27
+#define BM_DIGCTL_CTRL_RSVD2	0x18000000
+#define BF_DIGCTL_CTRL_RSVD2(v)  \
+		(((v) << 27) & BM_DIGCTL_CTRL_RSVD2)
+#define BM_DIGCTL_CTRL_CACHE_BIST_TMODE	0x04000000
+#define BM_DIGCTL_CTRL_LCD_BIST_CLKEN	0x02000000
+#define BM_DIGCTL_CTRL_LCD_BIST_START	0x01000000
+#define BM_DIGCTL_CTRL_DCP_BIST_CLKEN	0x00800000
+#define BM_DIGCTL_CTRL_DCP_BIST_START	0x00400000
+#define BM_DIGCTL_CTRL_ARM_BIST_CLKEN	0x00200000
+#define BM_DIGCTL_CTRL_USB_TESTMODE	0x00100000
+#define BM_DIGCTL_CTRL_ANALOG_TESTMODE	0x00080000
+#define BM_DIGCTL_CTRL_DIGITAL_TESTMODE	0x00040000
+#define BM_DIGCTL_CTRL_ARM_BIST_START	0x00020000
+#define BM_DIGCTL_CTRL_UART_LOOPBACK	0x00010000
+#define BV_DIGCTL_CTRL_UART_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_UART_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_SAIF_LOOPBACK	0x00008000
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__LOOPIT 0x1
+#define BP_DIGCTL_CTRL_SAIF_CLKMUX_SEL	13
+#define BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL	0x00006000
+#define BF_DIGCTL_CTRL_SAIF_CLKMUX_SEL(v)  \
+		(((v) << 13) & BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL)
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__MBL_CLK_OUT         0x0
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__BL_CLK_OUT          0x1
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__M_CLK_OUT_BL_CLK_IN 0x2
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__BL_CLK_IN           0x3
+#define BM_DIGCTL_CTRL_SAIF_CLKMST_SEL	0x00001000
+#define BV_DIGCTL_CTRL_SAIF_CLKMST_SEL__SAIF1_MST 0x0
+#define BV_DIGCTL_CTRL_SAIF_CLKMST_SEL__SAIF2_MST 0x1
+#define BM_DIGCTL_CTRL_SAIF_ALT_BITCLK_SEL	0x00000800
+#define BM_DIGCTL_CTRL_RSVD1	0x00000400
+#define BM_DIGCTL_CTRL_SY_ENDIAN	0x00000200
+#define BM_DIGCTL_CTRL_SY_SFTRST	0x00000100
+#define BM_DIGCTL_CTRL_SY_CLKGATE	0x00000080
+#define BM_DIGCTL_CTRL_USE_SERIAL_JTAG	0x00000040
+#define BV_DIGCTL_CTRL_USE_SERIAL_JTAG__OLD_JTAG    0x0
+#define BV_DIGCTL_CTRL_USE_SERIAL_JTAG__SERIAL_JTAG 0x1
+#define BM_DIGCTL_CTRL_TRAP_IN_RANGE	0x00000020
+#define BM_DIGCTL_CTRL_TRAP_ENABLE	0x00000010
+#define BM_DIGCTL_CTRL_DEBUG_DISABLE	0x00000008
+#define BM_DIGCTL_CTRL_USB_CLKGATE	0x00000004
+#define BV_DIGCTL_CTRL_USB_CLKGATE__RUN     0x0
+#define BV_DIGCTL_CTRL_USB_CLKGATE__NO_CLKS 0x1
+#define BM_DIGCTL_CTRL_JTAG_SHIELD	0x00000002
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__NORMAL     0x0
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__SHIELDS_UP 0x1
+#define BM_DIGCTL_CTRL_LATCH_ENTROPY	0x00000001
+
+#define HW_DIGCTL_STATUS	(0x00000010)
+#define HW_DIGCTL_STATUS_SET	(0x00000014)
+#define HW_DIGCTL_STATUS_CLR	(0x00000018)
+#define HW_DIGCTL_STATUS_TOG	(0x0000001c)
+
+#define BM_DIGCTL_STATUS_USB_HS_PRESENT	0x80000000
+#define BM_DIGCTL_STATUS_USB_OTG_PRESENT	0x40000000
+#define BM_DIGCTL_STATUS_USB_HOST_PRESENT	0x20000000
+#define BM_DIGCTL_STATUS_USB_DEVICE_PRESENT	0x10000000
+#define BP_DIGCTL_STATUS_RSVD2	11
+#define BM_DIGCTL_STATUS_RSVD2	0x0FFFF800
+#define BF_DIGCTL_STATUS_RSVD2(v)  \
+		(((v) << 11) & BM_DIGCTL_STATUS_RSVD2)
+#define BM_DIGCTL_STATUS_DCP_BIST_FAIL	0x00000400
+#define BM_DIGCTL_STATUS_DCP_BIST_PASS	0x00000200
+#define BM_DIGCTL_STATUS_DCP_BIST_DONE	0x00000100
+#define BM_DIGCTL_STATUS_LCD_BIST_FAIL	0x00000080
+#define BM_DIGCTL_STATUS_LCD_BIST_PASS	0x00000040
+#define BM_DIGCTL_STATUS_LCD_BIST_DONE	0x00000020
+#define BM_DIGCTL_STATUS_JTAG_IN_USE	0x00000010
+#define BP_DIGCTL_STATUS_PACKAGE_TYPE	1
+#define BM_DIGCTL_STATUS_PACKAGE_TYPE	0x0000000E
+#define BF_DIGCTL_STATUS_PACKAGE_TYPE(v)  \
+		(((v) << 1) & BM_DIGCTL_STATUS_PACKAGE_TYPE)
+#define BM_DIGCTL_STATUS_WRITTEN	0x00000001
+
+#define HW_DIGCTL_HCLKCOUNT	(0x00000020)
+#define HW_DIGCTL_HCLKCOUNT_SET	(0x00000024)
+#define HW_DIGCTL_HCLKCOUNT_CLR	(0x00000028)
+#define HW_DIGCTL_HCLKCOUNT_TOG	(0x0000002c)
+
+#define BP_DIGCTL_HCLKCOUNT_COUNT	0
+#define BM_DIGCTL_HCLKCOUNT_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_HCLKCOUNT_COUNT(v)	(v)
+
+#define HW_DIGCTL_RAMCTRL	(0x00000030)
+#define HW_DIGCTL_RAMCTRL_SET	(0x00000034)
+#define HW_DIGCTL_RAMCTRL_CLR	(0x00000038)
+#define HW_DIGCTL_RAMCTRL_TOG	(0x0000003c)
+
+#define BP_DIGCTL_RAMCTRL_RSVD1	12
+#define BM_DIGCTL_RAMCTRL_RSVD1	0xFFFFF000
+#define BF_DIGCTL_RAMCTRL_RSVD1(v) \
+		(((v) << 12) & BM_DIGCTL_RAMCTRL_RSVD1)
+#define BP_DIGCTL_RAMCTRL_SPEED_SELECT	8
+#define BM_DIGCTL_RAMCTRL_SPEED_SELECT	0x00000F00
+#define BF_DIGCTL_RAMCTRL_SPEED_SELECT(v)  \
+		(((v) << 8) & BM_DIGCTL_RAMCTRL_SPEED_SELECT)
+#define BP_DIGCTL_RAMCTRL_RSVD0	1
+#define BM_DIGCTL_RAMCTRL_RSVD0	0x000000FE
+#define BF_DIGCTL_RAMCTRL_RSVD0(v)  \
+		(((v) << 1) & BM_DIGCTL_RAMCTRL_RSVD0)
+#define BM_DIGCTL_RAMCTRL_RAM_REPAIR_EN	0x00000001
+
+#define HW_DIGCTL_RAMREPAIR	(0x00000040)
+#define HW_DIGCTL_RAMREPAIR_SET	(0x00000044)
+#define HW_DIGCTL_RAMREPAIR_CLR	(0x00000048)
+#define HW_DIGCTL_RAMREPAIR_TOG	(0x0000004c)
+
+#define BP_DIGCTL_RAMREPAIR_RSVD1	16
+#define BM_DIGCTL_RAMREPAIR_RSVD1	0xFFFF0000
+#define BF_DIGCTL_RAMREPAIR_RSVD1(v) \
+		(((v) << 16) & BM_DIGCTL_RAMREPAIR_RSVD1)
+#define BP_DIGCTL_RAMREPAIR_ADDR	0
+#define BM_DIGCTL_RAMREPAIR_ADDR	0x0000FFFF
+#define BF_DIGCTL_RAMREPAIR_ADDR(v)  \
+		(((v) << 0) & BM_DIGCTL_RAMREPAIR_ADDR)
+
+#define HW_DIGCTL_ROMCTRL	(0x00000050)
+#define HW_DIGCTL_ROMCTRL_SET	(0x00000054)
+#define HW_DIGCTL_ROMCTRL_CLR	(0x00000058)
+#define HW_DIGCTL_ROMCTRL_TOG	(0x0000005c)
+
+#define BP_DIGCTL_ROMCTRL_RSVD0	4
+#define BM_DIGCTL_ROMCTRL_RSVD0	0xFFFFFFF0
+#define BF_DIGCTL_ROMCTRL_RSVD0(v) \
+		(((v) << 4) & BM_DIGCTL_ROMCTRL_RSVD0)
+#define BP_DIGCTL_ROMCTRL_RD_MARGIN	0
+#define BM_DIGCTL_ROMCTRL_RD_MARGIN	0x0000000F
+#define BF_DIGCTL_ROMCTRL_RD_MARGIN(v)  \
+		(((v) << 0) & BM_DIGCTL_ROMCTRL_RD_MARGIN)
+
+#define HW_DIGCTL_WRITEONCE	(0x00000060)
+
+#define BP_DIGCTL_WRITEONCE_BITS	0
+#define BM_DIGCTL_WRITEONCE_BITS	0xFFFFFFFF
+#define BF_DIGCTL_WRITEONCE_BITS(v)	(v)
+
+#define HW_DIGCTL_ENTROPY	(0x00000090)
+
+#define BP_DIGCTL_ENTROPY_VALUE	0
+#define BM_DIGCTL_ENTROPY_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_VALUE(v)	(v)
+
+#define HW_DIGCTL_ENTROPY_LATCHED	(0x000000a0)
+
+#define BP_DIGCTL_ENTROPY_LATCHED_VALUE	0
+#define BM_DIGCTL_ENTROPY_LATCHED_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_LATCHED_VALUE(v)	(v)
+
+#define HW_DIGCTL_SJTAGDBG	(0x000000b0)
+#define HW_DIGCTL_SJTAGDBG_SET	(0x000000b4)
+#define HW_DIGCTL_SJTAGDBG_CLR	(0x000000b8)
+#define HW_DIGCTL_SJTAGDBG_TOG	(0x000000bc)
+
+#define BP_DIGCTL_SJTAGDBG_RSVD2	27
+#define BM_DIGCTL_SJTAGDBG_RSVD2	0xF8000000
+#define BF_DIGCTL_SJTAGDBG_RSVD2(v) \
+		(((v) << 27) & BM_DIGCTL_SJTAGDBG_RSVD2)
+#define BP_DIGCTL_SJTAGDBG_SJTAG_STATE	16
+#define BM_DIGCTL_SJTAGDBG_SJTAG_STATE	0x07FF0000
+#define BF_DIGCTL_SJTAGDBG_SJTAG_STATE(v)  \
+		(((v) << 16) & BM_DIGCTL_SJTAGDBG_SJTAG_STATE)
+#define BP_DIGCTL_SJTAGDBG_RSVD1	11
+#define BM_DIGCTL_SJTAGDBG_RSVD1	0x0000F800
+#define BF_DIGCTL_SJTAGDBG_RSVD1(v)  \
+		(((v) << 11) & BM_DIGCTL_SJTAGDBG_RSVD1)
+#define BM_DIGCTL_SJTAGDBG_SJTAG_TDO	0x00000400
+#define BM_DIGCTL_SJTAGDBG_SJTAG_TDI	0x00000200
+#define BM_DIGCTL_SJTAGDBG_SJTAG_MODE	0x00000100
+#define BP_DIGCTL_SJTAGDBG_DELAYED_ACTIVE	4
+#define BM_DIGCTL_SJTAGDBG_DELAYED_ACTIVE	0x000000F0
+#define BF_DIGCTL_SJTAGDBG_DELAYED_ACTIVE(v)  \
+		(((v) << 4) & BM_DIGCTL_SJTAGDBG_DELAYED_ACTIVE)
+#define BM_DIGCTL_SJTAGDBG_ACTIVE	0x00000008
+#define BM_DIGCTL_SJTAGDBG_SJTAG_PIN_STATE	0x00000004
+#define BM_DIGCTL_SJTAGDBG_SJTAG_DEBUG_DATA	0x00000002
+#define BM_DIGCTL_SJTAGDBG_SJTAG_DEBUG_OE	0x00000001
+
+#define HW_DIGCTL_MICROSECONDS	(0x000000c0)
+#define HW_DIGCTL_MICROSECONDS_SET	(0x000000c4)
+#define HW_DIGCTL_MICROSECONDS_CLR	(0x000000c8)
+#define HW_DIGCTL_MICROSECONDS_TOG	(0x000000cc)
+
+#define BP_DIGCTL_MICROSECONDS_VALUE	0
+#define BM_DIGCTL_MICROSECONDS_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_MICROSECONDS_VALUE(v)	(v)
+
+#define HW_DIGCTL_DBGRD	(0x000000d0)
+
+#define BP_DIGCTL_DBGRD_COMPLEMENT	0
+#define BM_DIGCTL_DBGRD_COMPLEMENT	0xFFFFFFFF
+#define BF_DIGCTL_DBGRD_COMPLEMENT(v)	(v)
+
+#define HW_DIGCTL_DBG	(0x000000e0)
+
+#define BP_DIGCTL_DBG_VALUE	0
+#define BM_DIGCTL_DBG_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_DBG_VALUE(v)	(v)
+
+#define HW_DIGCTL_OCRAM_BIST_CSR	(0x000000f0)
+#define HW_DIGCTL_OCRAM_BIST_CSR_SET	(0x000000f4)
+#define HW_DIGCTL_OCRAM_BIST_CSR_CLR	(0x000000f8)
+#define HW_DIGCTL_OCRAM_BIST_CSR_TOG	(0x000000fc)
+
+#define BP_DIGCTL_OCRAM_BIST_CSR_RSVD1	11
+#define BM_DIGCTL_OCRAM_BIST_CSR_RSVD1	0xFFFFF800
+#define BF_DIGCTL_OCRAM_BIST_CSR_RSVD1(v) \
+		(((v) << 11) & BM_DIGCTL_OCRAM_BIST_CSR_RSVD1)
+#define BM_DIGCTL_OCRAM_BIST_CSR_BIST_DEBUG_MODE	0x00000400
+#define BM_DIGCTL_OCRAM_BIST_CSR_BIST_DATA_CHANGE	0x00000200
+#define BM_DIGCTL_OCRAM_BIST_CSR_BIST_CLKEN	0x00000100
+#define BP_DIGCTL_OCRAM_BIST_CSR_RSVD0	4
+#define BM_DIGCTL_OCRAM_BIST_CSR_RSVD0	0x000000F0
+#define BF_DIGCTL_OCRAM_BIST_CSR_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_OCRAM_BIST_CSR_RSVD0)
+#define BM_DIGCTL_OCRAM_BIST_CSR_FAIL	0x00000008
+#define BM_DIGCTL_OCRAM_BIST_CSR_PASS	0x00000004
+#define BM_DIGCTL_OCRAM_BIST_CSR_DONE	0x00000002
+#define BM_DIGCTL_OCRAM_BIST_CSR_START	0x00000001
+
+#define HW_DIGCTL_OCRAM_STATUS0	(0x00000110)
+#define HW_DIGCTL_OCRAM_STATUS0_SET	(0x00000114)
+#define HW_DIGCTL_OCRAM_STATUS0_CLR	(0x00000118)
+#define HW_DIGCTL_OCRAM_STATUS0_TOG	(0x0000011c)
+
+#define BP_DIGCTL_OCRAM_STATUS0_FAILDATA00	0
+#define BM_DIGCTL_OCRAM_STATUS0_FAILDATA00	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS0_FAILDATA00(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS1	(0x00000120)
+#define HW_DIGCTL_OCRAM_STATUS1_SET	(0x00000124)
+#define HW_DIGCTL_OCRAM_STATUS1_CLR	(0x00000128)
+#define HW_DIGCTL_OCRAM_STATUS1_TOG	(0x0000012c)
+
+#define BP_DIGCTL_OCRAM_STATUS1_FAILDATA01	0
+#define BM_DIGCTL_OCRAM_STATUS1_FAILDATA01	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS1_FAILDATA01(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS2	(0x00000130)
+#define HW_DIGCTL_OCRAM_STATUS2_SET	(0x00000134)
+#define HW_DIGCTL_OCRAM_STATUS2_CLR	(0x00000138)
+#define HW_DIGCTL_OCRAM_STATUS2_TOG	(0x0000013c)
+
+#define BP_DIGCTL_OCRAM_STATUS2_FAILDATA10	0
+#define BM_DIGCTL_OCRAM_STATUS2_FAILDATA10	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS2_FAILDATA10(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS3	(0x00000140)
+#define HW_DIGCTL_OCRAM_STATUS3_SET	(0x00000144)
+#define HW_DIGCTL_OCRAM_STATUS3_CLR	(0x00000148)
+#define HW_DIGCTL_OCRAM_STATUS3_TOG	(0x0000014c)
+
+#define BP_DIGCTL_OCRAM_STATUS3_FAILDATA11	0
+#define BM_DIGCTL_OCRAM_STATUS3_FAILDATA11	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS3_FAILDATA11(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS4	(0x00000150)
+#define HW_DIGCTL_OCRAM_STATUS4_SET	(0x00000154)
+#define HW_DIGCTL_OCRAM_STATUS4_CLR	(0x00000158)
+#define HW_DIGCTL_OCRAM_STATUS4_TOG	(0x0000015c)
+
+#define BP_DIGCTL_OCRAM_STATUS4_FAILDATA20	0
+#define BM_DIGCTL_OCRAM_STATUS4_FAILDATA20	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS4_FAILDATA20(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS5	(0x00000160)
+#define HW_DIGCTL_OCRAM_STATUS5_SET	(0x00000164)
+#define HW_DIGCTL_OCRAM_STATUS5_CLR	(0x00000168)
+#define HW_DIGCTL_OCRAM_STATUS5_TOG	(0x0000016c)
+
+#define BP_DIGCTL_OCRAM_STATUS5_FAILDATA21	0
+#define BM_DIGCTL_OCRAM_STATUS5_FAILDATA21	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS5_FAILDATA21(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS6	(0x00000170)
+#define HW_DIGCTL_OCRAM_STATUS6_SET	(0x00000174)
+#define HW_DIGCTL_OCRAM_STATUS6_CLR	(0x00000178)
+#define HW_DIGCTL_OCRAM_STATUS6_TOG	(0x0000017c)
+
+#define BP_DIGCTL_OCRAM_STATUS6_FAILDATA30	0
+#define BM_DIGCTL_OCRAM_STATUS6_FAILDATA30	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS6_FAILDATA30(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS7	(0x00000180)
+#define HW_DIGCTL_OCRAM_STATUS7_SET	(0x00000184)
+#define HW_DIGCTL_OCRAM_STATUS7_CLR	(0x00000188)
+#define HW_DIGCTL_OCRAM_STATUS7_TOG	(0x0000018c)
+
+#define BP_DIGCTL_OCRAM_STATUS7_FAILDATA31	0
+#define BM_DIGCTL_OCRAM_STATUS7_FAILDATA31	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS7_FAILDATA31(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS8	(0x00000190)
+#define HW_DIGCTL_OCRAM_STATUS8_SET	(0x00000194)
+#define HW_DIGCTL_OCRAM_STATUS8_CLR	(0x00000198)
+#define HW_DIGCTL_OCRAM_STATUS8_TOG	(0x0000019c)
+
+#define BP_DIGCTL_OCRAM_STATUS8_RSVD3	29
+#define BM_DIGCTL_OCRAM_STATUS8_RSVD3	0xE0000000
+#define BF_DIGCTL_OCRAM_STATUS8_RSVD3(v) \
+		(((v) << 29) & BM_DIGCTL_OCRAM_STATUS8_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR01	16
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR01	0x1FFF0000
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR01(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR01)
+#define BP_DIGCTL_OCRAM_STATUS8_RSVD2	13
+#define BM_DIGCTL_OCRAM_STATUS8_RSVD2	0x0000E000
+#define BF_DIGCTL_OCRAM_STATUS8_RSVD2(v)  \
+		(((v) << 13) & BM_DIGCTL_OCRAM_STATUS8_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR00	0
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR00	0x00001FFF
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR00)
+
+#define HW_DIGCTL_OCRAM_STATUS9	(0x000001a0)
+#define HW_DIGCTL_OCRAM_STATUS9_SET	(0x000001a4)
+#define HW_DIGCTL_OCRAM_STATUS9_CLR	(0x000001a8)
+#define HW_DIGCTL_OCRAM_STATUS9_TOG	(0x000001ac)
+
+#define BP_DIGCTL_OCRAM_STATUS9_RSVD3	29
+#define BM_DIGCTL_OCRAM_STATUS9_RSVD3	0xE0000000
+#define BF_DIGCTL_OCRAM_STATUS9_RSVD3(v) \
+		(((v) << 29) & BM_DIGCTL_OCRAM_STATUS9_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR11	16
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR11	0x1FFF0000
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR11(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR11)
+#define BP_DIGCTL_OCRAM_STATUS9_RSVD2	13
+#define BM_DIGCTL_OCRAM_STATUS9_RSVD2	0x0000E000
+#define BF_DIGCTL_OCRAM_STATUS9_RSVD2(v)  \
+		(((v) << 13) & BM_DIGCTL_OCRAM_STATUS9_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR10	0
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR10	0x00001FFF
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR10(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR10)
+
+#define HW_DIGCTL_OCRAM_STATUS10	(0x000001b0)
+#define HW_DIGCTL_OCRAM_STATUS10_SET	(0x000001b4)
+#define HW_DIGCTL_OCRAM_STATUS10_CLR	(0x000001b8)
+#define HW_DIGCTL_OCRAM_STATUS10_TOG	(0x000001bc)
+
+#define BP_DIGCTL_OCRAM_STATUS10_RSVD3	29
+#define BM_DIGCTL_OCRAM_STATUS10_RSVD3	0xE0000000
+#define BF_DIGCTL_OCRAM_STATUS10_RSVD3(v) \
+		(((v) << 29) & BM_DIGCTL_OCRAM_STATUS10_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR21	16
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR21	0x1FFF0000
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR21(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR21)
+#define BP_DIGCTL_OCRAM_STATUS10_RSVD2	13
+#define BM_DIGCTL_OCRAM_STATUS10_RSVD2	0x0000E000
+#define BF_DIGCTL_OCRAM_STATUS10_RSVD2(v)  \
+		(((v) << 13) & BM_DIGCTL_OCRAM_STATUS10_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR20	0
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR20	0x00001FFF
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR20)
+
+#define HW_DIGCTL_OCRAM_STATUS11	(0x000001c0)
+#define HW_DIGCTL_OCRAM_STATUS11_SET	(0x000001c4)
+#define HW_DIGCTL_OCRAM_STATUS11_CLR	(0x000001c8)
+#define HW_DIGCTL_OCRAM_STATUS11_TOG	(0x000001cc)
+
+#define BP_DIGCTL_OCRAM_STATUS11_RSVD3	29
+#define BM_DIGCTL_OCRAM_STATUS11_RSVD3	0xE0000000
+#define BF_DIGCTL_OCRAM_STATUS11_RSVD3(v) \
+		(((v) << 29) & BM_DIGCTL_OCRAM_STATUS11_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR31	16
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR31	0x1FFF0000
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR31(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR31)
+#define BP_DIGCTL_OCRAM_STATUS11_RSVD2	13
+#define BM_DIGCTL_OCRAM_STATUS11_RSVD2	0x0000E000
+#define BF_DIGCTL_OCRAM_STATUS11_RSVD2(v)  \
+		(((v) << 13) & BM_DIGCTL_OCRAM_STATUS11_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR30	0
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR30	0x00001FFF
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR30(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR30)
+
+#define HW_DIGCTL_OCRAM_STATUS12	(0x000001d0)
+#define HW_DIGCTL_OCRAM_STATUS12_SET	(0x000001d4)
+#define HW_DIGCTL_OCRAM_STATUS12_CLR	(0x000001d8)
+#define HW_DIGCTL_OCRAM_STATUS12_TOG	(0x000001dc)
+
+#define BP_DIGCTL_OCRAM_STATUS12_RSVD3	28
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD3	0xF0000000
+#define BF_DIGCTL_OCRAM_STATUS12_RSVD3(v) \
+		(((v) << 28) & BM_DIGCTL_OCRAM_STATUS12_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE11	24
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11	0x0F000000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE11(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11)
+#define BP_DIGCTL_OCRAM_STATUS12_RSVD2	20
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD2	0x00F00000
+#define BF_DIGCTL_OCRAM_STATUS12_RSVD2(v)  \
+		(((v) << 20) & BM_DIGCTL_OCRAM_STATUS12_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE10	16
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10	0x000F0000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE10(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10)
+#define BP_DIGCTL_OCRAM_STATUS12_RSVD1	12
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD1	0x0000F000
+#define BF_DIGCTL_OCRAM_STATUS12_RSVD1(v)  \
+		(((v) << 12) & BM_DIGCTL_OCRAM_STATUS12_RSVD1)
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE01	8
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01	0x00000F00
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE01(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01)
+#define BP_DIGCTL_OCRAM_STATUS12_RSVD0	4
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD0	0x000000F0
+#define BF_DIGCTL_OCRAM_STATUS12_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_OCRAM_STATUS12_RSVD0)
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0x0000000F
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00)
+
+#define HW_DIGCTL_OCRAM_STATUS13	(0x000001e0)
+#define HW_DIGCTL_OCRAM_STATUS13_SET	(0x000001e4)
+#define HW_DIGCTL_OCRAM_STATUS13_CLR	(0x000001e8)
+#define HW_DIGCTL_OCRAM_STATUS13_TOG	(0x000001ec)
+
+#define BP_DIGCTL_OCRAM_STATUS13_RSVD3	28
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD3	0xF0000000
+#define BF_DIGCTL_OCRAM_STATUS13_RSVD3(v) \
+		(((v) << 28) & BM_DIGCTL_OCRAM_STATUS13_RSVD3)
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE31	24
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31	0x0F000000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE31(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31)
+#define BP_DIGCTL_OCRAM_STATUS13_RSVD2	20
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD2	0x00F00000
+#define BF_DIGCTL_OCRAM_STATUS13_RSVD2(v)  \
+		(((v) << 20) & BM_DIGCTL_OCRAM_STATUS13_RSVD2)
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE30	16
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30	0x000F0000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE30(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30)
+#define BP_DIGCTL_OCRAM_STATUS13_RSVD1	12
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD1	0x0000F000
+#define BF_DIGCTL_OCRAM_STATUS13_RSVD1(v)  \
+		(((v) << 12) & BM_DIGCTL_OCRAM_STATUS13_RSVD1)
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE21	8
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21	0x00000F00
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE21(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21)
+#define BP_DIGCTL_OCRAM_STATUS13_RSVD0	4
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD0	0x000000F0
+#define BF_DIGCTL_OCRAM_STATUS13_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_OCRAM_STATUS13_RSVD0)
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0x0000000F
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20)
+
+#define HW_DIGCTL_SCRATCH0	(0x00000290)
+
+#define BP_DIGCTL_SCRATCH0_PTR	0
+#define BM_DIGCTL_SCRATCH0_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH0_PTR(v)	(v)
+
+#define HW_DIGCTL_SCRATCH1	(0x000002a0)
+
+#define BP_DIGCTL_SCRATCH1_PTR	0
+#define BM_DIGCTL_SCRATCH1_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH1_PTR(v)	(v)
+
+#define HW_DIGCTL_ARMCACHE	(0x000002b0)
+
+#define BP_DIGCTL_ARMCACHE_RSVD4	18
+#define BM_DIGCTL_ARMCACHE_RSVD4	0xFFFC0000
+#define BF_DIGCTL_ARMCACHE_RSVD4(v) \
+		(((v) << 18) & BM_DIGCTL_ARMCACHE_RSVD4)
+#define BP_DIGCTL_ARMCACHE_VALID_SS	16
+#define BM_DIGCTL_ARMCACHE_VALID_SS	0x00030000
+#define BF_DIGCTL_ARMCACHE_VALID_SS(v)  \
+		(((v) << 16) & BM_DIGCTL_ARMCACHE_VALID_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD3	14
+#define BM_DIGCTL_ARMCACHE_RSVD3	0x0000C000
+#define BF_DIGCTL_ARMCACHE_RSVD3(v)  \
+		(((v) << 14) & BM_DIGCTL_ARMCACHE_RSVD3)
+#define BP_DIGCTL_ARMCACHE_DRTY_SS	12
+#define BM_DIGCTL_ARMCACHE_DRTY_SS	0x00003000
+#define BF_DIGCTL_ARMCACHE_DRTY_SS(v)  \
+		(((v) << 12) & BM_DIGCTL_ARMCACHE_DRTY_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD2	10
+#define BM_DIGCTL_ARMCACHE_RSVD2	0x00000C00
+#define BF_DIGCTL_ARMCACHE_RSVD2(v)  \
+		(((v) << 10) & BM_DIGCTL_ARMCACHE_RSVD2)
+#define BP_DIGCTL_ARMCACHE_CACHE_SS	8
+#define BM_DIGCTL_ARMCACHE_CACHE_SS	0x00000300
+#define BF_DIGCTL_ARMCACHE_CACHE_SS(v)  \
+		(((v) << 8) & BM_DIGCTL_ARMCACHE_CACHE_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD1	6
+#define BM_DIGCTL_ARMCACHE_RSVD1	0x000000C0
+#define BF_DIGCTL_ARMCACHE_RSVD1(v)  \
+		(((v) << 6) & BM_DIGCTL_ARMCACHE_RSVD1)
+#define BP_DIGCTL_ARMCACHE_DTAG_SS	4
+#define BM_DIGCTL_ARMCACHE_DTAG_SS	0x00000030
+#define BF_DIGCTL_ARMCACHE_DTAG_SS(v)  \
+		(((v) << 4) & BM_DIGCTL_ARMCACHE_DTAG_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD0	2
+#define BM_DIGCTL_ARMCACHE_RSVD0	0x0000000C
+#define BF_DIGCTL_ARMCACHE_RSVD0(v)  \
+		(((v) << 2) & BM_DIGCTL_ARMCACHE_RSVD0)
+#define BP_DIGCTL_ARMCACHE_ITAG_SS	0
+#define BM_DIGCTL_ARMCACHE_ITAG_SS	0x00000003
+#define BF_DIGCTL_ARMCACHE_ITAG_SS(v)  \
+		(((v) << 0) & BM_DIGCTL_ARMCACHE_ITAG_SS)
+
+#define HW_DIGCTL_DEBUG_TRAP_ADDR_LOW	(0x000002c0)
+
+#define BP_DIGCTL_DEBUG_TRAP_ADDR_LOW_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_ADDR_LOW_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_ADDR_LOW_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_ADDR_HIGH	(0x000002d0)
+
+#define BP_DIGCTL_DEBUG_TRAP_ADDR_HIGH_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_ADDR_HIGH_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_ADDR_HIGH_ADDR(v)	(v)
+
+#define HW_DIGCTL_SGTL	(0x00000300)
+
+#define BP_DIGCTL_SGTL_COPYRIGHT	0
+#define BM_DIGCTL_SGTL_COPYRIGHT	0xFFFFFFFF
+#define BF_DIGCTL_SGTL_COPYRIGHT(v)	(v)
+
+#define HW_DIGCTL_CHIPID	(0x00000310)
+
+#define BP_DIGCTL_CHIPID_PRODUCT_CODE	16
+#define BM_DIGCTL_CHIPID_PRODUCT_CODE	0xFFFF0000
+#define BF_DIGCTL_CHIPID_PRODUCT_CODE(v) \
+		(((v) << 16) & BM_DIGCTL_CHIPID_PRODUCT_CODE)
+#define BP_DIGCTL_CHIPID_RSVD0	8
+#define BM_DIGCTL_CHIPID_RSVD0	0x0000FF00
+#define BF_DIGCTL_CHIPID_RSVD0(v)  \
+		(((v) << 8) & BM_DIGCTL_CHIPID_RSVD0)
+#define BP_DIGCTL_CHIPID_REVISION	0
+#define BM_DIGCTL_CHIPID_REVISION	0x000000FF
+#define BF_DIGCTL_CHIPID_REVISION(v)  \
+		(((v) << 0) & BM_DIGCTL_CHIPID_REVISION)
+
+#define HW_DIGCTL_AHB_STATS_SELECT	(0x00000330)
+
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD3	28
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD3	0xF0000000
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD3(v) \
+		(((v) << 28) & BM_DIGCTL_AHB_STATS_SELECT_RSVD3)
+#define BP_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	24
+#define BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	0x0F000000
+#define BF_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT(v)  \
+		(((v) << 24) & BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBH 0x1
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBX 0x2
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__USB  0x4
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD2	20
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD2	0x00F00000
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD2(v)  \
+		(((v) << 20) & BM_DIGCTL_AHB_STATS_SELECT_RSVD2)
+#define BP_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	16
+#define BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	0x000F0000
+#define BF_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT(v)  \
+		(((v) << 16) & BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT__ARM_D 0x1
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD1	12
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD1	0x0000F000
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD1(v)  \
+		(((v) << 12) & BM_DIGCTL_AHB_STATS_SELECT_RSVD1)
+#define BP_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	8
+#define BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	0x00000F00
+#define BF_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT(v)  \
+		(((v) << 8) & BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT__ARM_I 0x1
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD0	4
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD0	0x000000F0
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_AHB_STATS_SELECT_RSVD0)
+#define BP_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT	0
+#define BM_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT	0x0000000F
+#define BF_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT(v)  \
+		(((v) << 0) & BM_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT__ECC8   0x1
+#define BV_DIGCTL_AHB_STATS_SELECT_L0_MASTER_SELECT__CRYPTO 0x2
+
+#define HW_DIGCTL_L0_AHB_ACTIVE_CYCLES	(0x00000340)
+
+#define BP_DIGCTL_L0_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L0_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L0_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L0_AHB_DATA_STALLED	(0x00000350)
+
+#define BP_DIGCTL_L0_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L0_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L0_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L0_AHB_DATA_CYCLES	(0x00000360)
+
+#define BP_DIGCTL_L0_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L0_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L0_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_ACTIVE_CYCLES	(0x00000370)
+
+#define BP_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_STALLED	(0x00000380)
+
+#define BP_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_CYCLES	(0x00000390)
+
+#define BP_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_ACTIVE_CYCLES	(0x000003a0)
+
+#define BP_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_STALLED	(0x000003b0)
+
+#define BP_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_CYCLES	(0x000003c0)
+
+#define BP_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_ACTIVE_CYCLES	(0x000003d0)
+
+#define BP_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_STALLED	(0x000003e0)
+
+#define BP_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_CYCLES	(0x000003f0)
+
+#define BP_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+/*
+ *  multi-register-define name HW_DIGCTL_MPTEn_LOC
+ *              base 0x00000400
+ *              count 16
+ *              offset 0x10
+ */
+#define HW_DIGCTL_MPTEn_LOC(n)	(0x00000400 + (n) * 0x10)
+#define BP_DIGCTL_MPTEn_LOC_RSVD0	12
+#define BM_DIGCTL_MPTEn_LOC_RSVD0	0xFFFFF000
+#define BF_DIGCTL_MPTEn_LOC_RSVD0(v) \
+		(((v) << 12) & BM_DIGCTL_MPTEn_LOC_RSVD0)
+#define BP_DIGCTL_MPTEn_LOC_LOC	0
+#define BM_DIGCTL_MPTEn_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTEn_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTEn_LOC_LOC)
+
+#define HW_DIGCTL_EMICLK_DELAY	(0x00000500)
+
+#define BP_DIGCTL_EMICLK_DELAY_RSVD0	5
+#define BM_DIGCTL_EMICLK_DELAY_RSVD0	0xFFFFFFE0
+#define BF_DIGCTL_EMICLK_DELAY_RSVD0(v) \
+		(((v) << 5) & BM_DIGCTL_EMICLK_DELAY_RSVD0)
+#define BP_DIGCTL_EMICLK_DELAY_NUM_TAPS	0
+#define BM_DIGCTL_EMICLK_DELAY_NUM_TAPS	0x0000001F
+#define BF_DIGCTL_EMICLK_DELAY_NUM_TAPS(v)  \
+		(((v) << 0) & BM_DIGCTL_EMICLK_DELAY_NUM_TAPS)
+#endif /* __ARCH_ARM___DIGCTL_H */
diff --git a/arch/arm/mach-mx23/regs-dram.h b/arch/arm/mach-mx23/regs-dram.h
new file mode 100644
index 0000000..be2fcfa
--- /dev/null
+++ b/arch/arm/mach-mx23/regs-dram.h
@@ -0,0 +1,890 @@
+/*
+ * Freescale DRAM Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ */
+
+#ifndef __ARCH_ARM___DRAM_H
+#define __ARCH_ARM___DRAM_H  1
+
+#define REGS_DRAM_PHYS (0x800E0000)
+#define REGS_DRAM_SIZE 0x00002000
+
+#define HW_DRAM_CTL00	(0x00000000)
+
+#define BP_DRAM_CTL00_RSVD4	25
+#define BM_DRAM_CTL00_RSVD4	0xFE000000
+#define BF_DRAM_CTL00_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL00_RSVD4)
+#define BM_DRAM_CTL00_AHB0_W_PRIORITY	0x01000000
+#define BP_DRAM_CTL00_RSVD3	17
+#define BM_DRAM_CTL00_RSVD3	0x00FE0000
+#define BF_DRAM_CTL00_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL00_RSVD3)
+#define BM_DRAM_CTL00_AHB0_R_PRIORITY	0x00010000
+#define BP_DRAM_CTL00_RSVD2	9
+#define BM_DRAM_CTL00_RSVD2	0x0000FE00
+#define BF_DRAM_CTL00_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL00_RSVD2)
+#define BM_DRAM_CTL00_AHB0_FIFO_TYPE_REG	0x00000100
+#define BP_DRAM_CTL00_RSVD1	1
+#define BM_DRAM_CTL00_RSVD1	0x000000FE
+#define BF_DRAM_CTL00_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL00_RSVD1)
+#define BM_DRAM_CTL00_ADDR_CMP_EN	0x00000001
+
+#define HW_DRAM_CTL01	(0x00000004)
+
+#define BP_DRAM_CTL01_RSVD4	25
+#define BM_DRAM_CTL01_RSVD4	0xFE000000
+#define BF_DRAM_CTL01_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL01_RSVD4)
+#define BM_DRAM_CTL01_AHB2_FIFO_TYPE_REG	0x01000000
+#define BP_DRAM_CTL01_RSVD3	17
+#define BM_DRAM_CTL01_RSVD3	0x00FE0000
+#define BF_DRAM_CTL01_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL01_RSVD3)
+#define BM_DRAM_CTL01_AHB1_W_PRIORITY	0x00010000
+#define BP_DRAM_CTL01_RSVD2	9
+#define BM_DRAM_CTL01_RSVD2	0x0000FE00
+#define BF_DRAM_CTL01_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL01_RSVD2)
+#define BM_DRAM_CTL01_AHB1_R_PRIORITY	0x00000100
+#define BP_DRAM_CTL01_RSVD1	1
+#define BM_DRAM_CTL01_RSVD1	0x000000FE
+#define BF_DRAM_CTL01_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL01_RSVD1)
+#define BM_DRAM_CTL01_AHB1_FIFO_TYPE_REG	0x00000001
+
+#define HW_DRAM_CTL02	(0x00000008)
+
+#define BP_DRAM_CTL02_RSVD4	25
+#define BM_DRAM_CTL02_RSVD4	0xFE000000
+#define BF_DRAM_CTL02_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL02_RSVD4)
+#define BM_DRAM_CTL02_AHB3_R_PRIORITY	0x01000000
+#define BP_DRAM_CTL02_RSVD3	17
+#define BM_DRAM_CTL02_RSVD3	0x00FE0000
+#define BF_DRAM_CTL02_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL02_RSVD3)
+#define BM_DRAM_CTL02_AHB3_FIFO_TYPE_REG	0x00010000
+#define BP_DRAM_CTL02_RSVD2	9
+#define BM_DRAM_CTL02_RSVD2	0x0000FE00
+#define BF_DRAM_CTL02_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL02_RSVD2)
+#define BM_DRAM_CTL02_AHB2_W_PRIORITY	0x00000100
+#define BP_DRAM_CTL02_RSVD1	1
+#define BM_DRAM_CTL02_RSVD1	0x000000FE
+#define BF_DRAM_CTL02_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL02_RSVD1)
+#define BM_DRAM_CTL02_AHB2_R_PRIORITY	0x00000001
+
+#define HW_DRAM_CTL03	(0x0000000c)
+
+#define BP_DRAM_CTL03_RSVD4	25
+#define BM_DRAM_CTL03_RSVD4	0xFE000000
+#define BF_DRAM_CTL03_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL03_RSVD4)
+#define BM_DRAM_CTL03_AUTO_REFRESH_MODE	0x01000000
+#define BP_DRAM_CTL03_RSVD3	17
+#define BM_DRAM_CTL03_RSVD3	0x00FE0000
+#define BF_DRAM_CTL03_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL03_RSVD3)
+#define BM_DRAM_CTL03_AREFRESH	0x00010000
+#define BP_DRAM_CTL03_RSVD2	9
+#define BM_DRAM_CTL03_RSVD2	0x0000FE00
+#define BF_DRAM_CTL03_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL03_RSVD2)
+#define BM_DRAM_CTL03_AP	0x00000100
+#define BP_DRAM_CTL03_RSVD1	1
+#define BM_DRAM_CTL03_RSVD1	0x000000FE
+#define BF_DRAM_CTL03_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL03_RSVD1)
+#define BM_DRAM_CTL03_AHB3_W_PRIORITY	0x00000001
+
+#define HW_DRAM_CTL04	(0x00000010)
+
+#define BP_DRAM_CTL04_RSVD4	25
+#define BM_DRAM_CTL04_RSVD4	0xFE000000
+#define BF_DRAM_CTL04_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL04_RSVD4)
+#define BM_DRAM_CTL04_DLL_BYPASS_MODE	0x01000000
+#define BP_DRAM_CTL04_RSVD3	17
+#define BM_DRAM_CTL04_RSVD3	0x00FE0000
+#define BF_DRAM_CTL04_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL04_RSVD3)
+#define BM_DRAM_CTL04_DLLLOCKREG	0x00010000
+#define BP_DRAM_CTL04_RSVD2	9
+#define BM_DRAM_CTL04_RSVD2	0x0000FE00
+#define BF_DRAM_CTL04_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL04_RSVD2)
+#define BM_DRAM_CTL04_CONCURRENTAP	0x00000100
+#define BP_DRAM_CTL04_RSVD1	1
+#define BM_DRAM_CTL04_RSVD1	0x000000FE
+#define BF_DRAM_CTL04_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL04_RSVD1)
+#define BM_DRAM_CTL04_BANK_SPLIT_EN	0x00000001
+
+#define HW_DRAM_CTL05	(0x00000014)
+
+#define BP_DRAM_CTL05_RSVD4	25
+#define BM_DRAM_CTL05_RSVD4	0xFE000000
+#define BF_DRAM_CTL05_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL05_RSVD4)
+#define BM_DRAM_CTL05_INTRPTREADA	0x01000000
+#define BP_DRAM_CTL05_RSVD3	17
+#define BM_DRAM_CTL05_RSVD3	0x00FE0000
+#define BF_DRAM_CTL05_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL05_RSVD3)
+#define BM_DRAM_CTL05_INTRPTAPBURST	0x00010000
+#define BP_DRAM_CTL05_RSVD2	9
+#define BM_DRAM_CTL05_RSVD2	0x0000FE00
+#define BF_DRAM_CTL05_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL05_RSVD2)
+#define BM_DRAM_CTL05_FAST_WRITE	0x00000100
+#define BP_DRAM_CTL05_RSVD1	1
+#define BM_DRAM_CTL05_RSVD1	0x000000FE
+#define BF_DRAM_CTL05_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL05_RSVD1)
+#define BM_DRAM_CTL05_EN_LOWPOWER_MODE	0x00000001
+
+#define HW_DRAM_CTL06	(0x00000018)
+
+#define BP_DRAM_CTL06_RSVD4	25
+#define BM_DRAM_CTL06_RSVD4	0xFE000000
+#define BF_DRAM_CTL06_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL06_RSVD4)
+#define BM_DRAM_CTL06_POWER_DOWN	0x01000000
+#define BP_DRAM_CTL06_RSVD3	17
+#define BM_DRAM_CTL06_RSVD3	0x00FE0000
+#define BF_DRAM_CTL06_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL06_RSVD3)
+#define BM_DRAM_CTL06_PLACEMENT_EN	0x00010000
+#define BP_DRAM_CTL06_RSVD2	9
+#define BM_DRAM_CTL06_RSVD2	0x0000FE00
+#define BF_DRAM_CTL06_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL06_RSVD2)
+#define BM_DRAM_CTL06_NO_CMD_INIT	0x00000100
+#define BP_DRAM_CTL06_RSVD1	1
+#define BM_DRAM_CTL06_RSVD1	0x000000FE
+#define BF_DRAM_CTL06_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL06_RSVD1)
+#define BM_DRAM_CTL06_INTRPTWRITEA	0x00000001
+
+#define HW_DRAM_CTL07	(0x0000001c)
+
+#define BP_DRAM_CTL07_RSVD4	25
+#define BM_DRAM_CTL07_RSVD4	0xFE000000
+#define BF_DRAM_CTL07_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL07_RSVD4)
+#define BM_DRAM_CTL07_RW_SAME_EN	0x01000000
+#define BP_DRAM_CTL07_RSVD3	17
+#define BM_DRAM_CTL07_RSVD3	0x00FE0000
+#define BF_DRAM_CTL07_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL07_RSVD3)
+#define BM_DRAM_CTL07_REG_DIMM_ENABLE	0x00010000
+#define BP_DRAM_CTL07_RSVD2	9
+#define BM_DRAM_CTL07_RSVD2	0x0000FE00
+#define BF_DRAM_CTL07_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL07_RSVD2)
+#define BM_DRAM_CTL07_RD2RD_TURN	0x00000100
+#define BP_DRAM_CTL07_RSVD1	1
+#define BM_DRAM_CTL07_RSVD1	0x000000FE
+#define BF_DRAM_CTL07_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL07_RSVD1)
+#define BM_DRAM_CTL07_PRIORITY_EN	0x00000001
+
+#define HW_DRAM_CTL08	(0x00000020)
+
+#define BP_DRAM_CTL08_RSVD4	25
+#define BM_DRAM_CTL08_RSVD4	0xFE000000
+#define BF_DRAM_CTL08_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL08_RSVD4)
+#define BM_DRAM_CTL08_TRAS_LOCKOUT	0x01000000
+#define BP_DRAM_CTL08_RSVD3	17
+#define BM_DRAM_CTL08_RSVD3	0x00FE0000
+#define BF_DRAM_CTL08_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL08_RSVD3)
+#define BM_DRAM_CTL08_START	0x00010000
+#define BP_DRAM_CTL08_RSVD2	9
+#define BM_DRAM_CTL08_RSVD2	0x0000FE00
+#define BF_DRAM_CTL08_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL08_RSVD2)
+#define BM_DRAM_CTL08_SREFRESH	0x00000100
+#define BP_DRAM_CTL08_RSVD1	1
+#define BM_DRAM_CTL08_RSVD1	0x000000FE
+#define BF_DRAM_CTL08_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL08_RSVD1)
+#define BM_DRAM_CTL08_SDR_MODE	0x00000001
+
+#define HW_DRAM_CTL09	(0x00000024)
+
+#define BP_DRAM_CTL09_RSVD4	26
+#define BM_DRAM_CTL09_RSVD4	0xFC000000
+#define BF_DRAM_CTL09_RSVD4(v) \
+		(((v) << 26) & BM_DRAM_CTL09_RSVD4)
+#define BP_DRAM_CTL09_OUT_OF_RANGE_TYPE	24
+#define BM_DRAM_CTL09_OUT_OF_RANGE_TYPE	0x03000000
+#define BF_DRAM_CTL09_OUT_OF_RANGE_TYPE(v)  \
+		(((v) << 24) & BM_DRAM_CTL09_OUT_OF_RANGE_TYPE)
+#define BP_DRAM_CTL09_RSVD3	18
+#define BM_DRAM_CTL09_RSVD3	0x00FC0000
+#define BF_DRAM_CTL09_RSVD3(v)  \
+		(((v) << 18) & BM_DRAM_CTL09_RSVD3)
+#define BP_DRAM_CTL09_OUT_OF_RANGE_SOURCE_ID	16
+#define BM_DRAM_CTL09_OUT_OF_RANGE_SOURCE_ID	0x00030000
+#define BF_DRAM_CTL09_OUT_OF_RANGE_SOURCE_ID(v)  \
+		(((v) << 16) & BM_DRAM_CTL09_OUT_OF_RANGE_SOURCE_ID)
+#define BP_DRAM_CTL09_RSVD2	9
+#define BM_DRAM_CTL09_RSVD2	0x0000FE00
+#define BF_DRAM_CTL09_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL09_RSVD2)
+#define BM_DRAM_CTL09_WRITE_MODEREG	0x00000100
+#define BP_DRAM_CTL09_RSVD1	1
+#define BM_DRAM_CTL09_RSVD1	0x000000FE
+#define BF_DRAM_CTL09_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL09_RSVD1)
+#define BM_DRAM_CTL09_WRITEINTERP	0x00000001
+
+#define HW_DRAM_CTL10	(0x00000028)
+
+#define BP_DRAM_CTL10_RSVD4	27
+#define BM_DRAM_CTL10_RSVD4	0xF8000000
+#define BF_DRAM_CTL10_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL10_RSVD4)
+#define BP_DRAM_CTL10_AGE_COUNT	24
+#define BM_DRAM_CTL10_AGE_COUNT	0x07000000
+#define BF_DRAM_CTL10_AGE_COUNT(v)  \
+		(((v) << 24) & BM_DRAM_CTL10_AGE_COUNT)
+#define BP_DRAM_CTL10_RSVD3	19
+#define BM_DRAM_CTL10_RSVD3	0x00F80000
+#define BF_DRAM_CTL10_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL10_RSVD3)
+#define BP_DRAM_CTL10_ADDR_PINS	16
+#define BM_DRAM_CTL10_ADDR_PINS	0x00070000
+#define BF_DRAM_CTL10_ADDR_PINS(v)  \
+		(((v) << 16) & BM_DRAM_CTL10_ADDR_PINS)
+#define BP_DRAM_CTL10_RSVD2	10
+#define BM_DRAM_CTL10_RSVD2	0x0000FC00
+#define BF_DRAM_CTL10_RSVD2(v)  \
+		(((v) << 10) & BM_DRAM_CTL10_RSVD2)
+#define BP_DRAM_CTL10_TEMRS	8
+#define BM_DRAM_CTL10_TEMRS	0x00000300
+#define BF_DRAM_CTL10_TEMRS(v)  \
+		(((v) << 8) & BM_DRAM_CTL10_TEMRS)
+#define BP_DRAM_CTL10_RSVD1	2
+#define BM_DRAM_CTL10_RSVD1	0x000000FC
+#define BF_DRAM_CTL10_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL10_RSVD1)
+#define BP_DRAM_CTL10_Q_FULLNESS	0
+#define BM_DRAM_CTL10_Q_FULLNESS	0x00000003
+#define BF_DRAM_CTL10_Q_FULLNESS(v)  \
+		(((v) << 0) & BM_DRAM_CTL10_Q_FULLNESS)
+
+#define HW_DRAM_CTL11	(0x0000002c)
+
+#define BP_DRAM_CTL11_RSVD4	27
+#define BM_DRAM_CTL11_RSVD4	0xF8000000
+#define BF_DRAM_CTL11_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL11_RSVD4)
+#define BP_DRAM_CTL11_MAX_CS_REG	24
+#define BM_DRAM_CTL11_MAX_CS_REG	0x07000000
+#define BF_DRAM_CTL11_MAX_CS_REG(v)  \
+		(((v) << 24) & BM_DRAM_CTL11_MAX_CS_REG)
+#define BP_DRAM_CTL11_RSVD3	19
+#define BM_DRAM_CTL11_RSVD3	0x00F80000
+#define BF_DRAM_CTL11_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL11_RSVD3)
+#define BP_DRAM_CTL11_COMMAND_AGE_COUNT	16
+#define BM_DRAM_CTL11_COMMAND_AGE_COUNT	0x00070000
+#define BF_DRAM_CTL11_COMMAND_AGE_COUNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL11_COMMAND_AGE_COUNT)
+#define BP_DRAM_CTL11_RSVD2	11
+#define BM_DRAM_CTL11_RSVD2	0x0000F800
+#define BF_DRAM_CTL11_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL11_RSVD2)
+#define BP_DRAM_CTL11_COLUMN_SIZE	8
+#define BM_DRAM_CTL11_COLUMN_SIZE	0x00000700
+#define BF_DRAM_CTL11_COLUMN_SIZE(v)  \
+		(((v) << 8) & BM_DRAM_CTL11_COLUMN_SIZE)
+#define BP_DRAM_CTL11_RSVD1	3
+#define BM_DRAM_CTL11_RSVD1	0x000000F8
+#define BF_DRAM_CTL11_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL11_RSVD1)
+#define BP_DRAM_CTL11_CASLAT	0
+#define BM_DRAM_CTL11_CASLAT	0x00000007
+#define BF_DRAM_CTL11_CASLAT(v)  \
+		(((v) << 0) & BM_DRAM_CTL11_CASLAT)
+
+#define HW_DRAM_CTL12	(0x00000030)
+
+#define BP_DRAM_CTL12_RSVD3	27
+#define BM_DRAM_CTL12_RSVD3	0xF8000000
+#define BF_DRAM_CTL12_RSVD3(v) \
+		(((v) << 27) & BM_DRAM_CTL12_RSVD3)
+#define BP_DRAM_CTL12_TWR_INT	24
+#define BM_DRAM_CTL12_TWR_INT	0x07000000
+#define BF_DRAM_CTL12_TWR_INT(v)  \
+		(((v) << 24) & BM_DRAM_CTL12_TWR_INT)
+#define BP_DRAM_CTL12_RSVD2	19
+#define BM_DRAM_CTL12_RSVD2	0x00F80000
+#define BF_DRAM_CTL12_RSVD2(v)  \
+		(((v) << 19) & BM_DRAM_CTL12_RSVD2)
+#define BP_DRAM_CTL12_TRRD	16
+#define BM_DRAM_CTL12_TRRD	0x00070000
+#define BF_DRAM_CTL12_TRRD(v)  \
+		(((v) << 16) & BM_DRAM_CTL12_TRRD)
+#define BP_DRAM_CTL12_OBSOLETE	8
+#define BM_DRAM_CTL12_OBSOLETE	0x0000FF00
+#define BF_DRAM_CTL12_OBSOLETE(v)  \
+		(((v) << 8) & BM_DRAM_CTL12_OBSOLETE)
+#define BP_DRAM_CTL12_RSVD1	3
+#define BM_DRAM_CTL12_RSVD1	0x000000F8
+#define BF_DRAM_CTL12_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL12_RSVD1)
+#define BP_DRAM_CTL12_TCKE	0
+#define BM_DRAM_CTL12_TCKE	0x00000007
+#define BF_DRAM_CTL12_TCKE(v)  \
+		(((v) << 0) & BM_DRAM_CTL12_TCKE)
+
+#define HW_DRAM_CTL13	(0x00000034)
+
+#define BP_DRAM_CTL13_RSVD4	28
+#define BM_DRAM_CTL13_RSVD4	0xF0000000
+#define BF_DRAM_CTL13_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL13_RSVD4)
+#define BP_DRAM_CTL13_CASLAT_LIN_GATE	24
+#define BM_DRAM_CTL13_CASLAT_LIN_GATE	0x0F000000
+#define BF_DRAM_CTL13_CASLAT_LIN_GATE(v)  \
+		(((v) << 24) & BM_DRAM_CTL13_CASLAT_LIN_GATE)
+#define BP_DRAM_CTL13_RSVD3	20
+#define BM_DRAM_CTL13_RSVD3	0x00F00000
+#define BF_DRAM_CTL13_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL13_RSVD3)
+#define BP_DRAM_CTL13_CASLAT_LIN	16
+#define BM_DRAM_CTL13_CASLAT_LIN	0x000F0000
+#define BF_DRAM_CTL13_CASLAT_LIN(v)  \
+		(((v) << 16) & BM_DRAM_CTL13_CASLAT_LIN)
+#define BP_DRAM_CTL13_RSVD2	12
+#define BM_DRAM_CTL13_RSVD2	0x0000F000
+#define BF_DRAM_CTL13_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL13_RSVD2)
+#define BP_DRAM_CTL13_APREBIT	8
+#define BM_DRAM_CTL13_APREBIT	0x00000F00
+#define BF_DRAM_CTL13_APREBIT(v)  \
+		(((v) << 8) & BM_DRAM_CTL13_APREBIT)
+#define BP_DRAM_CTL13_RSVD1	3
+#define BM_DRAM_CTL13_RSVD1	0x000000F8
+#define BF_DRAM_CTL13_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL13_RSVD1)
+#define BP_DRAM_CTL13_TWTR	0
+#define BM_DRAM_CTL13_TWTR	0x00000007
+#define BF_DRAM_CTL13_TWTR(v)  \
+		(((v) << 0) & BM_DRAM_CTL13_TWTR)
+
+#define HW_DRAM_CTL14	(0x00000038)
+
+#define BP_DRAM_CTL14_RSVD4	28
+#define BM_DRAM_CTL14_RSVD4	0xF0000000
+#define BF_DRAM_CTL14_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL14_RSVD4)
+#define BP_DRAM_CTL14_MAX_COL_REG	24
+#define BM_DRAM_CTL14_MAX_COL_REG	0x0F000000
+#define BF_DRAM_CTL14_MAX_COL_REG(v)  \
+		(((v) << 24) & BM_DRAM_CTL14_MAX_COL_REG)
+#define BP_DRAM_CTL14_RSVD3	20
+#define BM_DRAM_CTL14_RSVD3	0x00F00000
+#define BF_DRAM_CTL14_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL14_RSVD3)
+#define BP_DRAM_CTL14_LOWPOWER_REFRESH_ENABLE	16
+#define BM_DRAM_CTL14_LOWPOWER_REFRESH_ENABLE	0x000F0000
+#define BF_DRAM_CTL14_LOWPOWER_REFRESH_ENABLE(v)  \
+		(((v) << 16) & BM_DRAM_CTL14_LOWPOWER_REFRESH_ENABLE)
+#define BP_DRAM_CTL14_RSVD2	12
+#define BM_DRAM_CTL14_RSVD2	0x0000F000
+#define BF_DRAM_CTL14_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL14_RSVD2)
+#define BP_DRAM_CTL14_INITAREF	8
+#define BM_DRAM_CTL14_INITAREF	0x00000F00
+#define BF_DRAM_CTL14_INITAREF(v)  \
+		(((v) << 8) & BM_DRAM_CTL14_INITAREF)
+#define BP_DRAM_CTL14_RSVD1	4
+#define BM_DRAM_CTL14_RSVD1	0x000000F0
+#define BF_DRAM_CTL14_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL14_RSVD1)
+#define BP_DRAM_CTL14_CS_MAP	0
+#define BM_DRAM_CTL14_CS_MAP	0x0000000F
+#define BF_DRAM_CTL14_CS_MAP(v)  \
+		(((v) << 0) & BM_DRAM_CTL14_CS_MAP)
+
+#define HW_DRAM_CTL15	(0x0000003c)
+
+#define BP_DRAM_CTL15_RSVD4	28
+#define BM_DRAM_CTL15_RSVD4	0xF0000000
+#define BF_DRAM_CTL15_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL15_RSVD4)
+#define BP_DRAM_CTL15_TRP	24
+#define BM_DRAM_CTL15_TRP	0x0F000000
+#define BF_DRAM_CTL15_TRP(v)  \
+		(((v) << 24) & BM_DRAM_CTL15_TRP)
+#define BP_DRAM_CTL15_RSVD3	20
+#define BM_DRAM_CTL15_RSVD3	0x00F00000
+#define BF_DRAM_CTL15_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL15_RSVD3)
+#define BP_DRAM_CTL15_TDAL	16
+#define BM_DRAM_CTL15_TDAL	0x000F0000
+#define BF_DRAM_CTL15_TDAL(v)  \
+		(((v) << 16) & BM_DRAM_CTL15_TDAL)
+#define BP_DRAM_CTL15_RSVD2	12
+#define BM_DRAM_CTL15_RSVD2	0x0000F000
+#define BF_DRAM_CTL15_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL15_RSVD2)
+#define BP_DRAM_CTL15_PORT_BUSY	8
+#define BM_DRAM_CTL15_PORT_BUSY	0x00000F00
+#define BF_DRAM_CTL15_PORT_BUSY(v)  \
+		(((v) << 8) & BM_DRAM_CTL15_PORT_BUSY)
+#define BP_DRAM_CTL15_RSVD1	4
+#define BM_DRAM_CTL15_RSVD1	0x000000F0
+#define BF_DRAM_CTL15_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL15_RSVD1)
+#define BP_DRAM_CTL15_MAX_ROW_REG	0
+#define BM_DRAM_CTL15_MAX_ROW_REG	0x0000000F
+#define BF_DRAM_CTL15_MAX_ROW_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL15_MAX_ROW_REG)
+
+#define HW_DRAM_CTL16	(0x00000040)
+
+#define BP_DRAM_CTL16_RSVD4	29
+#define BM_DRAM_CTL16_RSVD4	0xE0000000
+#define BF_DRAM_CTL16_RSVD4(v) \
+		(((v) << 29) & BM_DRAM_CTL16_RSVD4)
+#define BP_DRAM_CTL16_TMRD	24
+#define BM_DRAM_CTL16_TMRD	0x1F000000
+#define BF_DRAM_CTL16_TMRD(v)  \
+		(((v) << 24) & BM_DRAM_CTL16_TMRD)
+#define BP_DRAM_CTL16_RSVD3	21
+#define BM_DRAM_CTL16_RSVD3	0x00E00000
+#define BF_DRAM_CTL16_RSVD3(v)  \
+		(((v) << 21) & BM_DRAM_CTL16_RSVD3)
+#define BP_DRAM_CTL16_LOWPOWER_CONTROL	16
+#define BM_DRAM_CTL16_LOWPOWER_CONTROL	0x001F0000
+#define BF_DRAM_CTL16_LOWPOWER_CONTROL(v)  \
+		(((v) << 16) & BM_DRAM_CTL16_LOWPOWER_CONTROL)
+#define BP_DRAM_CTL16_RSVD2	13
+#define BM_DRAM_CTL16_RSVD2	0x0000E000
+#define BF_DRAM_CTL16_RSVD2(v)  \
+		(((v) << 13) & BM_DRAM_CTL16_RSVD2)
+#define BP_DRAM_CTL16_LOWPOWER_AUTO_ENABLE	8
+#define BM_DRAM_CTL16_LOWPOWER_AUTO_ENABLE	0x00001F00
+#define BF_DRAM_CTL16_LOWPOWER_AUTO_ENABLE(v)  \
+		(((v) << 8) & BM_DRAM_CTL16_LOWPOWER_AUTO_ENABLE)
+#define BP_DRAM_CTL16_RSVD1	4
+#define BM_DRAM_CTL16_RSVD1	0x000000F0
+#define BF_DRAM_CTL16_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL16_RSVD1)
+#define BP_DRAM_CTL16_INT_ACK	0
+#define BM_DRAM_CTL16_INT_ACK	0x0000000F
+#define BF_DRAM_CTL16_INT_ACK(v)  \
+		(((v) << 0) & BM_DRAM_CTL16_INT_ACK)
+
+#define HW_DRAM_CTL17	(0x00000044)
+
+#define BP_DRAM_CTL17_DLL_START_POINT	24
+#define BM_DRAM_CTL17_DLL_START_POINT	0xFF000000
+#define BF_DRAM_CTL17_DLL_START_POINT(v) \
+		(((v) << 24) & BM_DRAM_CTL17_DLL_START_POINT)
+#define BP_DRAM_CTL17_DLL_LOCK	16
+#define BM_DRAM_CTL17_DLL_LOCK	0x00FF0000
+#define BF_DRAM_CTL17_DLL_LOCK(v)  \
+		(((v) << 16) & BM_DRAM_CTL17_DLL_LOCK)
+#define BP_DRAM_CTL17_DLL_INCREMENT	8
+#define BM_DRAM_CTL17_DLL_INCREMENT	0x0000FF00
+#define BF_DRAM_CTL17_DLL_INCREMENT(v)  \
+		(((v) << 8) & BM_DRAM_CTL17_DLL_INCREMENT)
+#define BP_DRAM_CTL17_RSVD1	5
+#define BM_DRAM_CTL17_RSVD1	0x000000E0
+#define BF_DRAM_CTL17_RSVD1(v)  \
+		(((v) << 5) & BM_DRAM_CTL17_RSVD1)
+#define BP_DRAM_CTL17_TRC	0
+#define BM_DRAM_CTL17_TRC	0x0000001F
+#define BF_DRAM_CTL17_TRC(v)  \
+		(((v) << 0) & BM_DRAM_CTL17_TRC)
+
+#define HW_DRAM_CTL18	(0x00000048)
+
+#define BM_DRAM_CTL18_RSVD4	0x80000000
+#define BP_DRAM_CTL18_DLL_DQS_DELAY_1	24
+#define BM_DRAM_CTL18_DLL_DQS_DELAY_1	0x7F000000
+#define BF_DRAM_CTL18_DLL_DQS_DELAY_1(v)  \
+		(((v) << 24) & BM_DRAM_CTL18_DLL_DQS_DELAY_1)
+#define BM_DRAM_CTL18_RSVD3	0x00800000
+#define BP_DRAM_CTL18_DLL_DQS_DELAY_0	16
+#define BM_DRAM_CTL18_DLL_DQS_DELAY_0	0x007F0000
+#define BF_DRAM_CTL18_DLL_DQS_DELAY_0(v)  \
+		(((v) << 16) & BM_DRAM_CTL18_DLL_DQS_DELAY_0)
+#define BP_DRAM_CTL18_RSVD2	13
+#define BM_DRAM_CTL18_RSVD2	0x0000E000
+#define BF_DRAM_CTL18_RSVD2(v)  \
+		(((v) << 13) & BM_DRAM_CTL18_RSVD2)
+#define BP_DRAM_CTL18_INT_STATUS	8
+#define BM_DRAM_CTL18_INT_STATUS	0x00001F00
+#define BF_DRAM_CTL18_INT_STATUS(v)  \
+		(((v) << 8) & BM_DRAM_CTL18_INT_STATUS)
+#define BP_DRAM_CTL18_RSVD1	5
+#define BM_DRAM_CTL18_RSVD1	0x000000E0
+#define BF_DRAM_CTL18_RSVD1(v)  \
+		(((v) << 5) & BM_DRAM_CTL18_RSVD1)
+#define BP_DRAM_CTL18_INT_MASK	0
+#define BM_DRAM_CTL18_INT_MASK	0x0000001F
+#define BF_DRAM_CTL18_INT_MASK(v)  \
+		(((v) << 0) & BM_DRAM_CTL18_INT_MASK)
+
+#define HW_DRAM_CTL19	(0x0000004c)
+
+#define BP_DRAM_CTL19_DQS_OUT_SHIFT_BYPASS	24
+#define BM_DRAM_CTL19_DQS_OUT_SHIFT_BYPASS	0xFF000000
+#define BF_DRAM_CTL19_DQS_OUT_SHIFT_BYPASS(v) \
+		(((v) << 24) & BM_DRAM_CTL19_DQS_OUT_SHIFT_BYPASS)
+#define BM_DRAM_CTL19_RSVD1	0x00800000
+#define BP_DRAM_CTL19_DQS_OUT_SHIFT	16
+#define BM_DRAM_CTL19_DQS_OUT_SHIFT	0x007F0000
+#define BF_DRAM_CTL19_DQS_OUT_SHIFT(v)  \
+		(((v) << 16) & BM_DRAM_CTL19_DQS_OUT_SHIFT)
+#define BP_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_1	8
+#define BM_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_1	0x0000FF00
+#define BF_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_1(v)  \
+		(((v) << 8) & BM_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_1)
+#define BP_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_0	0
+#define BM_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_0	0x000000FF
+#define BF_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL19_DLL_DQS_DELAY_BYPASS_0)
+
+#define HW_DRAM_CTL20	(0x00000050)
+
+#define BP_DRAM_CTL20_TRCD_INT	24
+#define BM_DRAM_CTL20_TRCD_INT	0xFF000000
+#define BF_DRAM_CTL20_TRCD_INT(v) \
+		(((v) << 24) & BM_DRAM_CTL20_TRCD_INT)
+#define BP_DRAM_CTL20_TRAS_MIN	16
+#define BM_DRAM_CTL20_TRAS_MIN	0x00FF0000
+#define BF_DRAM_CTL20_TRAS_MIN(v)  \
+		(((v) << 16) & BM_DRAM_CTL20_TRAS_MIN)
+#define BP_DRAM_CTL20_WR_DQS_SHIFT_BYPASS	8
+#define BM_DRAM_CTL20_WR_DQS_SHIFT_BYPASS	0x0000FF00
+#define BF_DRAM_CTL20_WR_DQS_SHIFT_BYPASS(v)  \
+		(((v) << 8) & BM_DRAM_CTL20_WR_DQS_SHIFT_BYPASS)
+#define BM_DRAM_CTL20_RSVD1	0x00000080
+#define BP_DRAM_CTL20_WR_DQS_SHIFT	0
+#define BM_DRAM_CTL20_WR_DQS_SHIFT	0x0000007F
+#define BF_DRAM_CTL20_WR_DQS_SHIFT(v)  \
+		(((v) << 0) & BM_DRAM_CTL20_WR_DQS_SHIFT)
+
+#define HW_DRAM_CTL21	(0x00000054)
+
+#define BP_DRAM_CTL21_OBSOLETE	24
+#define BM_DRAM_CTL21_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL21_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL21_OBSOLETE)
+#define BP_DRAM_CTL21_RSVD1	18
+#define BM_DRAM_CTL21_RSVD1	0x00FC0000
+#define BF_DRAM_CTL21_RSVD1(v)  \
+		(((v) << 18) & BM_DRAM_CTL21_RSVD1)
+#define BP_DRAM_CTL21_OUT_OF_RANGE_LENGTH	8
+#define BM_DRAM_CTL21_OUT_OF_RANGE_LENGTH	0x0003FF00
+#define BF_DRAM_CTL21_OUT_OF_RANGE_LENGTH(v)  \
+		(((v) << 8) & BM_DRAM_CTL21_OUT_OF_RANGE_LENGTH)
+#define BP_DRAM_CTL21_TRFC	0
+#define BM_DRAM_CTL21_TRFC	0x000000FF
+#define BF_DRAM_CTL21_TRFC(v)  \
+		(((v) << 0) & BM_DRAM_CTL21_TRFC)
+
+#define HW_DRAM_CTL22	(0x00000058)
+
+#define BP_DRAM_CTL22_RSVD2	27
+#define BM_DRAM_CTL22_RSVD2	0xF8000000
+#define BF_DRAM_CTL22_RSVD2(v) \
+		(((v) << 27) & BM_DRAM_CTL22_RSVD2)
+#define BP_DRAM_CTL22_AHB0_WRCNT	16
+#define BM_DRAM_CTL22_AHB0_WRCNT	0x07FF0000
+#define BF_DRAM_CTL22_AHB0_WRCNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL22_AHB0_WRCNT)
+#define BP_DRAM_CTL22_RSVD1	11
+#define BM_DRAM_CTL22_RSVD1	0x0000F800
+#define BF_DRAM_CTL22_RSVD1(v)  \
+		(((v) << 11) & BM_DRAM_CTL22_RSVD1)
+#define BP_DRAM_CTL22_AHB0_RDCNT	0
+#define BM_DRAM_CTL22_AHB0_RDCNT	0x000007FF
+#define BF_DRAM_CTL22_AHB0_RDCNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL22_AHB0_RDCNT)
+
+#define HW_DRAM_CTL23	(0x0000005c)
+
+#define BP_DRAM_CTL23_RSVD2	27
+#define BM_DRAM_CTL23_RSVD2	0xF8000000
+#define BF_DRAM_CTL23_RSVD2(v) \
+		(((v) << 27) & BM_DRAM_CTL23_RSVD2)
+#define BP_DRAM_CTL23_AHB1_WRCNT	16
+#define BM_DRAM_CTL23_AHB1_WRCNT	0x07FF0000
+#define BF_DRAM_CTL23_AHB1_WRCNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL23_AHB1_WRCNT)
+#define BP_DRAM_CTL23_RSVD1	11
+#define BM_DRAM_CTL23_RSVD1	0x0000F800
+#define BF_DRAM_CTL23_RSVD1(v)  \
+		(((v) << 11) & BM_DRAM_CTL23_RSVD1)
+#define BP_DRAM_CTL23_AHB1_RDCNT	0
+#define BM_DRAM_CTL23_AHB1_RDCNT	0x000007FF
+#define BF_DRAM_CTL23_AHB1_RDCNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL23_AHB1_RDCNT)
+
+#define HW_DRAM_CTL24	(0x00000060)
+
+#define BP_DRAM_CTL24_RSVD2	27
+#define BM_DRAM_CTL24_RSVD2	0xF8000000
+#define BF_DRAM_CTL24_RSVD2(v) \
+		(((v) << 27) & BM_DRAM_CTL24_RSVD2)
+#define BP_DRAM_CTL24_AHB2_WRCNT	16
+#define BM_DRAM_CTL24_AHB2_WRCNT	0x07FF0000
+#define BF_DRAM_CTL24_AHB2_WRCNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL24_AHB2_WRCNT)
+#define BP_DRAM_CTL24_RSVD1	11
+#define BM_DRAM_CTL24_RSVD1	0x0000F800
+#define BF_DRAM_CTL24_RSVD1(v)  \
+		(((v) << 11) & BM_DRAM_CTL24_RSVD1)
+#define BP_DRAM_CTL24_AHB2_RDCNT	0
+#define BM_DRAM_CTL24_AHB2_RDCNT	0x000007FF
+#define BF_DRAM_CTL24_AHB2_RDCNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL24_AHB2_RDCNT)
+
+#define HW_DRAM_CTL25	(0x00000064)
+
+#define BP_DRAM_CTL25_RSVD2	27
+#define BM_DRAM_CTL25_RSVD2	0xF8000000
+#define BF_DRAM_CTL25_RSVD2(v) \
+		(((v) << 27) & BM_DRAM_CTL25_RSVD2)
+#define BP_DRAM_CTL25_AHB3_WRCNT	16
+#define BM_DRAM_CTL25_AHB3_WRCNT	0x07FF0000
+#define BF_DRAM_CTL25_AHB3_WRCNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL25_AHB3_WRCNT)
+#define BP_DRAM_CTL25_RSVD1	11
+#define BM_DRAM_CTL25_RSVD1	0x0000F800
+#define BF_DRAM_CTL25_RSVD1(v)  \
+		(((v) << 11) & BM_DRAM_CTL25_RSVD1)
+#define BP_DRAM_CTL25_AHB3_RDCNT	0
+#define BM_DRAM_CTL25_AHB3_RDCNT	0x000007FF
+#define BF_DRAM_CTL25_AHB3_RDCNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL25_AHB3_RDCNT)
+
+#define HW_DRAM_CTL26	(0x00000068)
+
+#define BP_DRAM_CTL26_OBSOLETE	16
+#define BM_DRAM_CTL26_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL26_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL26_OBSOLETE)
+#define BP_DRAM_CTL26_RSVD1	12
+#define BM_DRAM_CTL26_RSVD1	0x0000F000
+#define BF_DRAM_CTL26_RSVD1(v)  \
+		(((v) << 12) & BM_DRAM_CTL26_RSVD1)
+#define BP_DRAM_CTL26_TREF	0
+#define BM_DRAM_CTL26_TREF	0x00000FFF
+#define BF_DRAM_CTL26_TREF(v)  \
+		(((v) << 0) & BM_DRAM_CTL26_TREF)
+
+#define HW_DRAM_CTL27	(0x0000006c)
+
+#define BP_DRAM_CTL27_OBSOLETE	0
+#define BM_DRAM_CTL27_OBSOLETE	0xFFFFFFFF
+#define BF_DRAM_CTL27_OBSOLETE(v)	(v)
+
+#define HW_DRAM_CTL28	(0x00000070)
+
+#define BP_DRAM_CTL28_OBSOLETE	0
+#define BM_DRAM_CTL28_OBSOLETE	0xFFFFFFFF
+#define BF_DRAM_CTL28_OBSOLETE(v)	(v)
+
+#define HW_DRAM_CTL29	(0x00000074)
+
+#define BP_DRAM_CTL29_LOWPOWER_INTERNAL_CNT	16
+#define BM_DRAM_CTL29_LOWPOWER_INTERNAL_CNT	0xFFFF0000
+#define BF_DRAM_CTL29_LOWPOWER_INTERNAL_CNT(v) \
+		(((v) << 16) & BM_DRAM_CTL29_LOWPOWER_INTERNAL_CNT)
+#define BP_DRAM_CTL29_LOWPOWER_EXTERNAL_CNT	0
+#define BM_DRAM_CTL29_LOWPOWER_EXTERNAL_CNT	0x0000FFFF
+#define BF_DRAM_CTL29_LOWPOWER_EXTERNAL_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL29_LOWPOWER_EXTERNAL_CNT)
+
+#define HW_DRAM_CTL30	(0x00000078)
+
+#define BP_DRAM_CTL30_LOWPOWER_REFRESH_HOLD	16
+#define BM_DRAM_CTL30_LOWPOWER_REFRESH_HOLD	0xFFFF0000
+#define BF_DRAM_CTL30_LOWPOWER_REFRESH_HOLD(v) \
+		(((v) << 16) & BM_DRAM_CTL30_LOWPOWER_REFRESH_HOLD)
+#define BP_DRAM_CTL30_LOWPOWER_POWER_DOWN_CNT	0
+#define BM_DRAM_CTL30_LOWPOWER_POWER_DOWN_CNT	0x0000FFFF
+#define BF_DRAM_CTL30_LOWPOWER_POWER_DOWN_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL30_LOWPOWER_POWER_DOWN_CNT)
+
+#define HW_DRAM_CTL31	(0x0000007c)
+
+#define BP_DRAM_CTL31_TDLL	16
+#define BM_DRAM_CTL31_TDLL	0xFFFF0000
+#define BF_DRAM_CTL31_TDLL(v) \
+		(((v) << 16) & BM_DRAM_CTL31_TDLL)
+#define BP_DRAM_CTL31_LOWPOWER_SELF_REFRESH_CNT	0
+#define BM_DRAM_CTL31_LOWPOWER_SELF_REFRESH_CNT	0x0000FFFF
+#define BF_DRAM_CTL31_LOWPOWER_SELF_REFRESH_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL31_LOWPOWER_SELF_REFRESH_CNT)
+
+#define HW_DRAM_CTL32	(0x00000080)
+
+#define BP_DRAM_CTL32_TXSNR	16
+#define BM_DRAM_CTL32_TXSNR	0xFFFF0000
+#define BF_DRAM_CTL32_TXSNR(v) \
+		(((v) << 16) & BM_DRAM_CTL32_TXSNR)
+#define BP_DRAM_CTL32_TRAS_MAX	0
+#define BM_DRAM_CTL32_TRAS_MAX	0x0000FFFF
+#define BF_DRAM_CTL32_TRAS_MAX(v)  \
+		(((v) << 0) & BM_DRAM_CTL32_TRAS_MAX)
+
+#define HW_DRAM_CTL33	(0x00000084)
+
+#define BP_DRAM_CTL33_VERSION	16
+#define BM_DRAM_CTL33_VERSION	0xFFFF0000
+#define BF_DRAM_CTL33_VERSION(v) \
+		(((v) << 16) & BM_DRAM_CTL33_VERSION)
+#define BP_DRAM_CTL33_TXSR	0
+#define BM_DRAM_CTL33_TXSR	0x0000FFFF
+#define BF_DRAM_CTL33_TXSR(v)  \
+		(((v) << 0) & BM_DRAM_CTL33_TXSR)
+
+#define HW_DRAM_CTL34	(0x00000088)
+
+#define BP_DRAM_CTL34_RSVD1	24
+#define BM_DRAM_CTL34_RSVD1	0xFF000000
+#define BF_DRAM_CTL34_RSVD1(v) \
+		(((v) << 24) & BM_DRAM_CTL34_RSVD1)
+#define BP_DRAM_CTL34_TINIT	0
+#define BM_DRAM_CTL34_TINIT	0x00FFFFFF
+#define BF_DRAM_CTL34_TINIT(v)  \
+		(((v) << 0) & BM_DRAM_CTL34_TINIT)
+
+#define HW_DRAM_CTL35	(0x0000008c)
+
+#define BM_DRAM_CTL35_RSVD1	0x80000000
+#define BP_DRAM_CTL35_OUT_OF_RANGE_ADDR	0
+#define BM_DRAM_CTL35_OUT_OF_RANGE_ADDR	0x7FFFFFFF
+#define BF_DRAM_CTL35_OUT_OF_RANGE_ADDR(v)  \
+		(((v) << 0) & BM_DRAM_CTL35_OUT_OF_RANGE_ADDR)
+
+#define HW_DRAM_CTL36	(0x00000090)
+
+#define BP_DRAM_CTL36_RSVD4	25
+#define BM_DRAM_CTL36_RSVD4	0xFE000000
+#define BF_DRAM_CTL36_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL36_RSVD4)
+#define BM_DRAM_CTL36_PWRUP_SREFRESH_EXIT	0x01000000
+#define BP_DRAM_CTL36_RSVD3	17
+#define BM_DRAM_CTL36_RSVD3	0x00FE0000
+#define BF_DRAM_CTL36_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL36_RSVD3)
+#define BM_DRAM_CTL36_ENABLE_QUICK_SREFRESH	0x00010000
+#define BP_DRAM_CTL36_RSVD2	9
+#define BM_DRAM_CTL36_RSVD2	0x0000FE00
+#define BF_DRAM_CTL36_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL36_RSVD2)
+#define BM_DRAM_CTL36_BUS_SHARE_ENABLE	0x00000100
+#define BP_DRAM_CTL36_RSVD1	1
+#define BM_DRAM_CTL36_RSVD1	0x000000FE
+#define BF_DRAM_CTL36_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL36_RSVD1)
+#define BM_DRAM_CTL36_ACTIVE_AGING	0x00000001
+
+#define HW_DRAM_CTL37	(0x00000094)
+
+#define BP_DRAM_CTL37_OBSOLETE	24
+#define BM_DRAM_CTL37_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL37_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL37_OBSOLETE)
+#define BP_DRAM_CTL37_RSVD2	18
+#define BM_DRAM_CTL37_RSVD2	0x00FC0000
+#define BF_DRAM_CTL37_RSVD2(v)  \
+		(((v) << 18) & BM_DRAM_CTL37_RSVD2)
+#define BP_DRAM_CTL37_BUS_SHARE_TIMEOUT	8
+#define BM_DRAM_CTL37_BUS_SHARE_TIMEOUT	0x0003FF00
+#define BF_DRAM_CTL37_BUS_SHARE_TIMEOUT(v)  \
+		(((v) << 8) & BM_DRAM_CTL37_BUS_SHARE_TIMEOUT)
+#define BP_DRAM_CTL37_RSVD1	1
+#define BM_DRAM_CTL37_RSVD1	0x000000FE
+#define BF_DRAM_CTL37_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL37_RSVD1)
+#define BM_DRAM_CTL37_TREF_ENABLE	0x00000001
+
+#define HW_DRAM_CTL38	(0x00000098)
+
+#define BP_DRAM_CTL38_RSVD2	29
+#define BM_DRAM_CTL38_RSVD2	0xE0000000
+#define BF_DRAM_CTL38_RSVD2(v) \
+		(((v) << 29) & BM_DRAM_CTL38_RSVD2)
+#define BP_DRAM_CTL38_EMRS2_DATA_0	16
+#define BM_DRAM_CTL38_EMRS2_DATA_0	0x1FFF0000
+#define BF_DRAM_CTL38_EMRS2_DATA_0(v)  \
+		(((v) << 16) & BM_DRAM_CTL38_EMRS2_DATA_0)
+#define BP_DRAM_CTL38_RSVD1	13
+#define BM_DRAM_CTL38_RSVD1	0x0000E000
+#define BF_DRAM_CTL38_RSVD1(v)  \
+		(((v) << 13) & BM_DRAM_CTL38_RSVD1)
+#define BP_DRAM_CTL38_EMRS1_DATA	0
+#define BM_DRAM_CTL38_EMRS1_DATA	0x00001FFF
+#define BF_DRAM_CTL38_EMRS1_DATA(v)  \
+		(((v) << 0) & BM_DRAM_CTL38_EMRS1_DATA)
+
+#define HW_DRAM_CTL39	(0x0000009c)
+
+#define BP_DRAM_CTL39_RSVD2	29
+#define BM_DRAM_CTL39_RSVD2	0xE0000000
+#define BF_DRAM_CTL39_RSVD2(v) \
+		(((v) << 29) & BM_DRAM_CTL39_RSVD2)
+#define BP_DRAM_CTL39_EMRS2_DATA_2	16
+#define BM_DRAM_CTL39_EMRS2_DATA_2	0x1FFF0000
+#define BF_DRAM_CTL39_EMRS2_DATA_2(v)  \
+		(((v) << 16) & BM_DRAM_CTL39_EMRS2_DATA_2)
+#define BP_DRAM_CTL39_RSVD1	13
+#define BM_DRAM_CTL39_RSVD1	0x0000E000
+#define BF_DRAM_CTL39_RSVD1(v)  \
+		(((v) << 13) & BM_DRAM_CTL39_RSVD1)
+#define BP_DRAM_CTL39_EMRS2_DATA_1	0
+#define BM_DRAM_CTL39_EMRS2_DATA_1	0x00001FFF
+#define BF_DRAM_CTL39_EMRS2_DATA_1(v)  \
+		(((v) << 0) & BM_DRAM_CTL39_EMRS2_DATA_1)
+
+#define HW_DRAM_CTL40	(0x000000a0)
+
+#define BP_DRAM_CTL40_TPDEX	16
+#define BM_DRAM_CTL40_TPDEX	0xFFFF0000
+#define BF_DRAM_CTL40_TPDEX(v) \
+		(((v) << 16) & BM_DRAM_CTL40_TPDEX)
+#define BP_DRAM_CTL40_RSVD1	13
+#define BM_DRAM_CTL40_RSVD1	0x0000E000
+#define BF_DRAM_CTL40_RSVD1(v)  \
+		(((v) << 13) & BM_DRAM_CTL40_RSVD1)
+#define BP_DRAM_CTL40_EMRS2_DATA_3	0
+#define BM_DRAM_CTL40_EMRS2_DATA_3	0x00001FFF
+#define BF_DRAM_CTL40_EMRS2_DATA_3(v)  \
+		(((v) << 0) & BM_DRAM_CTL40_EMRS2_DATA_3)
+#endif /* __ARCH_ARM___DRAM_H */
diff --git a/arch/arm/mach-mx23/regs-pinctrl.h b/arch/arm/mach-mx23/regs-pinctrl.h
new file mode 100644
index 0000000..d38f7bd
--- /dev/null
+++ b/arch/arm/mach-mx23/regs-pinctrl.h
@@ -0,0 +1,1879 @@
+/*
+ * Freescale PINCTRL Register Definitions
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.19
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PINCTRL_H
+#define __ARCH_ARM___PINCTRL_H
+
+
+#define HW_PINCTRL_CTRL	(0x00000000)
+#define HW_PINCTRL_CTRL_SET	(0x00000004)
+#define HW_PINCTRL_CTRL_CLR	(0x00000008)
+#define HW_PINCTRL_CTRL_TOG	(0x0000000c)
+
+#define BM_PINCTRL_CTRL_SFTRST	0x80000000
+#define BM_PINCTRL_CTRL_CLKGATE	0x40000000
+#define BP_PINCTRL_CTRL_RSRVD2	28
+#define BM_PINCTRL_CTRL_RSRVD2	0x30000000
+#define BF_PINCTRL_CTRL_RSRVD2(v)  \
+		(((v) << 28) & BM_PINCTRL_CTRL_RSRVD2)
+#define BM_PINCTRL_CTRL_PRESENT3	0x08000000
+#define BM_PINCTRL_CTRL_PRESENT2	0x04000000
+#define BM_PINCTRL_CTRL_PRESENT1	0x02000000
+#define BM_PINCTRL_CTRL_PRESENT0	0x01000000
+#define BP_PINCTRL_CTRL_RSRVD1	3
+#define BM_PINCTRL_CTRL_RSRVD1	0x00FFFFF8
+#define BF_PINCTRL_CTRL_RSRVD1(v)  \
+		(((v) << 3) & BM_PINCTRL_CTRL_RSRVD1)
+#define BM_PINCTRL_CTRL_IRQOUT2	0x00000004
+#define BM_PINCTRL_CTRL_IRQOUT1	0x00000002
+#define BM_PINCTRL_CTRL_IRQOUT0	0x00000001
+
+#define HW_PINCTRL_MUXSEL0	(0x00000100)
+#define HW_PINCTRL_MUXSEL0_SET	(0x00000104)
+#define HW_PINCTRL_MUXSEL0_CLR	(0x00000108)
+#define HW_PINCTRL_MUXSEL0_TOG	(0x0000010c)
+
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN15	30
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL0_BANK0_PIN15)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN14	28
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL0_BANK0_PIN14)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN13	26
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL0_BANK0_PIN13)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN12	24
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL0_BANK0_PIN12)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN11	22
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL0_BANK0_PIN11)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN10	20
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL0_BANK0_PIN10)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN09	18
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL0_BANK0_PIN09)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN08	16
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL0_BANK0_PIN08)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN07	14
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL0_BANK0_PIN07)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN06	12
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL0_BANK0_PIN06)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN05	10
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL0_BANK0_PIN05)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN04	8
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL0_BANK0_PIN04)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN03	6
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL0_BANK0_PIN03)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN02	4
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL0_BANK0_PIN02)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN01	2
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL0_BANK0_PIN01)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN00	0
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL0_BANK0_PIN00)
+
+#define HW_PINCTRL_MUXSEL1	(0x00000110)
+#define HW_PINCTRL_MUXSEL1_SET	(0x00000114)
+#define HW_PINCTRL_MUXSEL1_CLR	(0x00000118)
+#define HW_PINCTRL_MUXSEL1_TOG	(0x0000011c)
+
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN31	30
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN31	0xC0000000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN31(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL1_BANK0_PIN31)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN30	28
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN30	0x30000000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN30(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL1_BANK0_PIN30)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN29	26
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN29	0x0C000000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN29(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL1_BANK0_PIN29)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN28	24
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL1_BANK0_PIN28)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN27	22
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL1_BANK0_PIN27)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN26	20
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL1_BANK0_PIN26)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN25	18
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL1_BANK0_PIN25)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN24	16
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL1_BANK0_PIN24)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN23	14
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL1_BANK0_PIN23)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN22	12
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL1_BANK0_PIN22)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN21	10
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL1_BANK0_PIN21)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN20	8
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL1_BANK0_PIN20)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN19	6
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL1_BANK0_PIN19)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN18	4
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL1_BANK0_PIN18)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN17	2
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL1_BANK0_PIN17)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN16	0
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL1_BANK0_PIN16)
+
+#define HW_PINCTRL_MUXSEL2	(0x00000120)
+#define HW_PINCTRL_MUXSEL2_SET	(0x00000124)
+#define HW_PINCTRL_MUXSEL2_CLR	(0x00000128)
+#define HW_PINCTRL_MUXSEL2_TOG	(0x0000012c)
+
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN15	30
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL2_BANK1_PIN15)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN14	28
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL2_BANK1_PIN14)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN13	26
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL2_BANK1_PIN13)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN12	24
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL2_BANK1_PIN12)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN11	22
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL2_BANK1_PIN11)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN10	20
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL2_BANK1_PIN10)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN09	18
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL2_BANK1_PIN09)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN08	16
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL2_BANK1_PIN08)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN07	14
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL2_BANK1_PIN07)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN06	12
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL2_BANK1_PIN06)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN05	10
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL2_BANK1_PIN05)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN04	8
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL2_BANK1_PIN04)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN03	6
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL2_BANK1_PIN03)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN02	4
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL2_BANK1_PIN02)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN01	2
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL2_BANK1_PIN01)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN00	0
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL2_BANK1_PIN00)
+
+#define HW_PINCTRL_MUXSEL3	(0x00000130)
+#define HW_PINCTRL_MUXSEL3_SET	(0x00000134)
+#define HW_PINCTRL_MUXSEL3_CLR	(0x00000138)
+#define HW_PINCTRL_MUXSEL3_TOG	(0x0000013c)
+
+#define BP_PINCTRL_MUXSEL3_RSRVD0	30
+#define BM_PINCTRL_MUXSEL3_RSRVD0	0xC0000000
+#define BF_PINCTRL_MUXSEL3_RSRVD0(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL3_RSRVD0)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN30	28
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN30	0x30000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN30(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL3_BANK1_PIN30)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN29	26
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN29	0x0C000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN29(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL3_BANK1_PIN29)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN28	24
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL3_BANK1_PIN28)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN27	22
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL3_BANK1_PIN27)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN26	20
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL3_BANK1_PIN26)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN25	18
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL3_BANK1_PIN25)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN24	16
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL3_BANK1_PIN24)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN23	14
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL3_BANK1_PIN23)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN22	12
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL3_BANK1_PIN22)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN21	10
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL3_BANK1_PIN21)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN20	8
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL3_BANK1_PIN20)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN19	6
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL3_BANK1_PIN19)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN18	4
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL3_BANK1_PIN18)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN17	2
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL3_BANK1_PIN17)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN16	0
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL3_BANK1_PIN16)
+
+#define HW_PINCTRL_MUXSEL4	(0x00000140)
+#define HW_PINCTRL_MUXSEL4_SET	(0x00000144)
+#define HW_PINCTRL_MUXSEL4_CLR	(0x00000148)
+#define HW_PINCTRL_MUXSEL4_TOG	(0x0000014c)
+
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN15	30
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL4_BANK2_PIN15)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN14	28
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL4_BANK2_PIN14)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN13	26
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL4_BANK2_PIN13)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN12	24
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL4_BANK2_PIN12)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN11	22
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL4_BANK2_PIN11)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN10	20
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL4_BANK2_PIN10)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN09	18
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL4_BANK2_PIN09)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN08	16
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL4_BANK2_PIN08)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN07	14
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL4_BANK2_PIN07)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN06	12
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL4_BANK2_PIN06)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN05	10
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL4_BANK2_PIN05)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN04	8
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL4_BANK2_PIN04)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN03	6
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL4_BANK2_PIN03)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN02	4
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL4_BANK2_PIN02)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN01	2
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL4_BANK2_PIN01)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN00	0
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL4_BANK2_PIN00)
+
+#define HW_PINCTRL_MUXSEL5	(0x00000150)
+#define HW_PINCTRL_MUXSEL5_SET	(0x00000154)
+#define HW_PINCTRL_MUXSEL5_CLR	(0x00000158)
+#define HW_PINCTRL_MUXSEL5_TOG	(0x0000015c)
+
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN31	30
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN31	0xC0000000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN31(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL5_BANK2_PIN31)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN30	28
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN30	0x30000000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN30(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL5_BANK2_PIN30)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN29	26
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN29	0x0C000000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN29(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL5_BANK2_PIN29)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN28	24
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL5_BANK2_PIN28)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN27	22
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL5_BANK2_PIN27)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN26	20
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL5_BANK2_PIN26)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN25	18
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL5_BANK2_PIN25)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN24	16
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL5_BANK2_PIN24)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN23	14
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL5_BANK2_PIN23)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN22	12
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL5_BANK2_PIN22)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN21	10
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL5_BANK2_PIN21)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN20	8
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL5_BANK2_PIN20)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN19	6
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL5_BANK2_PIN19)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN18	4
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL5_BANK2_PIN18)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN17	2
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL5_BANK2_PIN17)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN16	0
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL5_BANK2_PIN16)
+
+#define HW_PINCTRL_MUXSEL6	(0x00000160)
+#define HW_PINCTRL_MUXSEL6_SET	(0x00000164)
+#define HW_PINCTRL_MUXSEL6_CLR	(0x00000168)
+#define HW_PINCTRL_MUXSEL6_TOG	(0x0000016c)
+
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN15	30
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL6_BANK3_PIN15)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN14	28
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL6_BANK3_PIN14)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN13	26
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL6_BANK3_PIN13)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN12	24
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL6_BANK3_PIN12)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN11	22
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL6_BANK3_PIN11)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN10	20
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL6_BANK3_PIN10)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN09	18
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL6_BANK3_PIN09)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN08	16
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL6_BANK3_PIN08)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN07	14
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL6_BANK3_PIN07)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN06	12
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL6_BANK3_PIN06)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN05	10
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL6_BANK3_PIN05)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN04	8
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL6_BANK3_PIN04)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN03	6
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL6_BANK3_PIN03)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN02	4
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL6_BANK3_PIN02)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN01	2
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL6_BANK3_PIN01)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN00	0
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL6_BANK3_PIN00)
+
+#define HW_PINCTRL_MUXSEL7	(0x00000170)
+#define HW_PINCTRL_MUXSEL7_SET	(0x00000174)
+#define HW_PINCTRL_MUXSEL7_CLR	(0x00000178)
+#define HW_PINCTRL_MUXSEL7_TOG	(0x0000017c)
+
+#define BP_PINCTRL_MUXSEL7_RSRVD0	12
+#define BM_PINCTRL_MUXSEL7_RSRVD0	0xFFFFF000
+#define BF_PINCTRL_MUXSEL7_RSRVD0(v) \
+		(((v) << 12) & BM_PINCTRL_MUXSEL7_RSRVD0)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN21	10
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL7_BANK3_PIN21)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN20	8
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL7_BANK3_PIN20)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN19	6
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL7_BANK3_PIN19)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN18	4
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL7_BANK3_PIN18)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN17	2
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL7_BANK3_PIN17)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN16	0
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL7_BANK3_PIN16)
+
+#define HW_PINCTRL_DRIVE0	(0x00000200)
+#define HW_PINCTRL_DRIVE0_SET	(0x00000204)
+#define HW_PINCTRL_DRIVE0_CLR	(0x00000208)
+#define HW_PINCTRL_DRIVE0_TOG	(0x0000020c)
+
+#define BP_PINCTRL_DRIVE0_RSRVD7	30
+#define BM_PINCTRL_DRIVE0_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE0_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE0_RSRVD7)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN07_MA	28
+#define BM_PINCTRL_DRIVE0_BANK0_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE0_BANK0_PIN07_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD6	26
+#define BM_PINCTRL_DRIVE0_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE0_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE0_RSRVD6)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN06_MA	24
+#define BM_PINCTRL_DRIVE0_BANK0_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE0_BANK0_PIN06_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD5	22
+#define BM_PINCTRL_DRIVE0_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE0_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE0_RSRVD5)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN05_MA	20
+#define BM_PINCTRL_DRIVE0_BANK0_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE0_BANK0_PIN05_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD4	18
+#define BM_PINCTRL_DRIVE0_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE0_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE0_RSRVD4)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN04_MA	16
+#define BM_PINCTRL_DRIVE0_BANK0_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE0_BANK0_PIN04_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD3	14
+#define BM_PINCTRL_DRIVE0_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE0_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE0_RSRVD3)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN03_MA	12
+#define BM_PINCTRL_DRIVE0_BANK0_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE0_BANK0_PIN03_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD2	10
+#define BM_PINCTRL_DRIVE0_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE0_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE0_RSRVD2)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN02_MA	8
+#define BM_PINCTRL_DRIVE0_BANK0_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE0_BANK0_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE0_BANK0_PIN02_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD1	6
+#define BM_PINCTRL_DRIVE0_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE0_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE0_RSRVD1)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN01_MA	4
+#define BM_PINCTRL_DRIVE0_BANK0_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE0_BANK0_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE0_BANK0_PIN01_MA)
+#define BP_PINCTRL_DRIVE0_RSRVD0	2
+#define BM_PINCTRL_DRIVE0_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE0_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE0_RSRVD0)
+#define BP_PINCTRL_DRIVE0_BANK0_PIN00_MA	0
+#define BM_PINCTRL_DRIVE0_BANK0_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE0_BANK0_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE0_BANK0_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE1	(0x00000210)
+#define HW_PINCTRL_DRIVE1_SET	(0x00000214)
+#define HW_PINCTRL_DRIVE1_CLR	(0x00000218)
+#define HW_PINCTRL_DRIVE1_TOG	(0x0000021c)
+
+#define BP_PINCTRL_DRIVE1_RSRVD7	30
+#define BM_PINCTRL_DRIVE1_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE1_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE1_RSRVD7)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN15_MA	28
+#define BM_PINCTRL_DRIVE1_BANK0_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE1_BANK0_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE1_BANK0_PIN15_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD6	26
+#define BM_PINCTRL_DRIVE1_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE1_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE1_RSRVD6)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN14_MA	24
+#define BM_PINCTRL_DRIVE1_BANK0_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE1_BANK0_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE1_BANK0_PIN14_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD5	22
+#define BM_PINCTRL_DRIVE1_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE1_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE1_RSRVD5)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN13_MA	20
+#define BM_PINCTRL_DRIVE1_BANK0_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE1_BANK0_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE1_BANK0_PIN13_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD4	18
+#define BM_PINCTRL_DRIVE1_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE1_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE1_RSRVD4)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN12_MA	16
+#define BM_PINCTRL_DRIVE1_BANK0_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE1_BANK0_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE1_BANK0_PIN12_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD3	14
+#define BM_PINCTRL_DRIVE1_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE1_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE1_RSRVD3)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN11_MA	12
+#define BM_PINCTRL_DRIVE1_BANK0_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE1_BANK0_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE1_BANK0_PIN11_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD2	10
+#define BM_PINCTRL_DRIVE1_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE1_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE1_RSRVD2)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN10_MA	8
+#define BM_PINCTRL_DRIVE1_BANK0_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE1_BANK0_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE1_BANK0_PIN10_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD1	6
+#define BM_PINCTRL_DRIVE1_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE1_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE1_RSRVD1)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN09_MA	4
+#define BM_PINCTRL_DRIVE1_BANK0_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE1_BANK0_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE1_BANK0_PIN09_MA)
+#define BP_PINCTRL_DRIVE1_RSRVD0	2
+#define BM_PINCTRL_DRIVE1_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE1_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE1_RSRVD0)
+#define BP_PINCTRL_DRIVE1_BANK0_PIN08_MA	0
+#define BM_PINCTRL_DRIVE1_BANK0_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE1_BANK0_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE1_BANK0_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE2	(0x00000220)
+#define HW_PINCTRL_DRIVE2_SET	(0x00000224)
+#define HW_PINCTRL_DRIVE2_CLR	(0x00000228)
+#define HW_PINCTRL_DRIVE2_TOG	(0x0000022c)
+
+#define BP_PINCTRL_DRIVE2_RSRVD7	30
+#define BM_PINCTRL_DRIVE2_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE2_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE2_RSRVD7)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN23_MA	28
+#define BM_PINCTRL_DRIVE2_BANK0_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE2_BANK0_PIN23_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD6	26
+#define BM_PINCTRL_DRIVE2_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE2_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE2_RSRVD6)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN22_MA	24
+#define BM_PINCTRL_DRIVE2_BANK0_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE2_BANK0_PIN22_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD5	22
+#define BM_PINCTRL_DRIVE2_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE2_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE2_RSRVD5)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN21_MA	20
+#define BM_PINCTRL_DRIVE2_BANK0_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE2_BANK0_PIN21_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD4	18
+#define BM_PINCTRL_DRIVE2_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE2_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE2_RSRVD4)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN20_MA	16
+#define BM_PINCTRL_DRIVE2_BANK0_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE2_BANK0_PIN20_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD3	14
+#define BM_PINCTRL_DRIVE2_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE2_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE2_RSRVD3)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN19_MA	12
+#define BM_PINCTRL_DRIVE2_BANK0_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE2_BANK0_PIN19_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD2	10
+#define BM_PINCTRL_DRIVE2_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE2_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE2_RSRVD2)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN18_MA	8
+#define BM_PINCTRL_DRIVE2_BANK0_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE2_BANK0_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE2_BANK0_PIN18_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD1	6
+#define BM_PINCTRL_DRIVE2_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE2_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE2_RSRVD1)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN17_MA	4
+#define BM_PINCTRL_DRIVE2_BANK0_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE2_BANK0_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE2_BANK0_PIN17_MA)
+#define BP_PINCTRL_DRIVE2_RSRVD0	2
+#define BM_PINCTRL_DRIVE2_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE2_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE2_RSRVD0)
+#define BP_PINCTRL_DRIVE2_BANK0_PIN16_MA	0
+#define BM_PINCTRL_DRIVE2_BANK0_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE2_BANK0_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE2_BANK0_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE3	(0x00000230)
+#define HW_PINCTRL_DRIVE3_SET	(0x00000234)
+#define HW_PINCTRL_DRIVE3_CLR	(0x00000238)
+#define HW_PINCTRL_DRIVE3_TOG	(0x0000023c)
+
+#define BP_PINCTRL_DRIVE3_RSRVD7	30
+#define BM_PINCTRL_DRIVE3_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE3_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE3_RSRVD7)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN31_MA	28
+#define BM_PINCTRL_DRIVE3_BANK0_PIN31_MA	0x30000000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN31_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE3_BANK0_PIN31_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD6	26
+#define BM_PINCTRL_DRIVE3_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE3_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE3_RSRVD6)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN30_MA	24
+#define BM_PINCTRL_DRIVE3_BANK0_PIN30_MA	0x03000000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN30_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE3_BANK0_PIN30_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD5	22
+#define BM_PINCTRL_DRIVE3_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE3_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE3_RSRVD5)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN29_MA	20
+#define BM_PINCTRL_DRIVE3_BANK0_PIN29_MA	0x00300000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN29_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE3_BANK0_PIN29_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD4	18
+#define BM_PINCTRL_DRIVE3_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE3_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE3_RSRVD4)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN28_MA	16
+#define BM_PINCTRL_DRIVE3_BANK0_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE3_BANK0_PIN28_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD3	14
+#define BM_PINCTRL_DRIVE3_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE3_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE3_RSRVD3)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN27_MA	12
+#define BM_PINCTRL_DRIVE3_BANK0_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE3_BANK0_PIN27_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD2	10
+#define BM_PINCTRL_DRIVE3_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE3_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE3_RSRVD2)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN26_MA	8
+#define BM_PINCTRL_DRIVE3_BANK0_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE3_BANK0_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE3_BANK0_PIN26_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD1	6
+#define BM_PINCTRL_DRIVE3_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE3_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE3_RSRVD1)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN25_MA	4
+#define BM_PINCTRL_DRIVE3_BANK0_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE3_BANK0_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE3_BANK0_PIN25_MA)
+#define BP_PINCTRL_DRIVE3_RSRVD0	2
+#define BM_PINCTRL_DRIVE3_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE3_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE3_RSRVD0)
+#define BP_PINCTRL_DRIVE3_BANK0_PIN24_MA	0
+#define BM_PINCTRL_DRIVE3_BANK0_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE3_BANK0_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE3_BANK0_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE4	(0x00000240)
+#define HW_PINCTRL_DRIVE4_SET	(0x00000244)
+#define HW_PINCTRL_DRIVE4_CLR	(0x00000248)
+#define HW_PINCTRL_DRIVE4_TOG	(0x0000024c)
+
+#define BP_PINCTRL_DRIVE4_RSRVD7	30
+#define BM_PINCTRL_DRIVE4_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE4_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE4_RSRVD7)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN07_MA	28
+#define BM_PINCTRL_DRIVE4_BANK1_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE4_BANK1_PIN07_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD6	26
+#define BM_PINCTRL_DRIVE4_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE4_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE4_RSRVD6)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN06_MA	24
+#define BM_PINCTRL_DRIVE4_BANK1_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE4_BANK1_PIN06_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD5	22
+#define BM_PINCTRL_DRIVE4_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE4_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE4_RSRVD5)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN05_MA	20
+#define BM_PINCTRL_DRIVE4_BANK1_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE4_BANK1_PIN05_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD4	18
+#define BM_PINCTRL_DRIVE4_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE4_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE4_RSRVD4)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN04_MA	16
+#define BM_PINCTRL_DRIVE4_BANK1_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE4_BANK1_PIN04_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD3	14
+#define BM_PINCTRL_DRIVE4_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE4_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE4_RSRVD3)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN03_MA	12
+#define BM_PINCTRL_DRIVE4_BANK1_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE4_BANK1_PIN03_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD2	10
+#define BM_PINCTRL_DRIVE4_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE4_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE4_RSRVD2)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN02_MA	8
+#define BM_PINCTRL_DRIVE4_BANK1_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE4_BANK1_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE4_BANK1_PIN02_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD1	6
+#define BM_PINCTRL_DRIVE4_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE4_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE4_RSRVD1)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN01_MA	4
+#define BM_PINCTRL_DRIVE4_BANK1_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE4_BANK1_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE4_BANK1_PIN01_MA)
+#define BP_PINCTRL_DRIVE4_RSRVD0	2
+#define BM_PINCTRL_DRIVE4_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE4_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE4_RSRVD0)
+#define BP_PINCTRL_DRIVE4_BANK1_PIN00_MA	0
+#define BM_PINCTRL_DRIVE4_BANK1_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE4_BANK1_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE4_BANK1_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE5	(0x00000250)
+#define HW_PINCTRL_DRIVE5_SET	(0x00000254)
+#define HW_PINCTRL_DRIVE5_CLR	(0x00000258)
+#define HW_PINCTRL_DRIVE5_TOG	(0x0000025c)
+
+#define BP_PINCTRL_DRIVE5_RSRVD7	30
+#define BM_PINCTRL_DRIVE5_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE5_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE5_RSRVD7)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN15_MA	28
+#define BM_PINCTRL_DRIVE5_BANK1_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE5_BANK1_PIN15_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD6	26
+#define BM_PINCTRL_DRIVE5_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE5_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE5_RSRVD6)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN14_MA	24
+#define BM_PINCTRL_DRIVE5_BANK1_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE5_BANK1_PIN14_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD5	22
+#define BM_PINCTRL_DRIVE5_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE5_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE5_RSRVD5)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN13_MA	20
+#define BM_PINCTRL_DRIVE5_BANK1_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE5_BANK1_PIN13_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD4	18
+#define BM_PINCTRL_DRIVE5_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE5_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE5_RSRVD4)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN12_MA	16
+#define BM_PINCTRL_DRIVE5_BANK1_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE5_BANK1_PIN12_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD3	14
+#define BM_PINCTRL_DRIVE5_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE5_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE5_RSRVD3)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN11_MA	12
+#define BM_PINCTRL_DRIVE5_BANK1_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE5_BANK1_PIN11_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD2	10
+#define BM_PINCTRL_DRIVE5_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE5_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE5_RSRVD2)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN10_MA	8
+#define BM_PINCTRL_DRIVE5_BANK1_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE5_BANK1_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE5_BANK1_PIN10_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD1	6
+#define BM_PINCTRL_DRIVE5_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE5_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE5_RSRVD1)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN09_MA	4
+#define BM_PINCTRL_DRIVE5_BANK1_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE5_BANK1_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE5_BANK1_PIN09_MA)
+#define BP_PINCTRL_DRIVE5_RSRVD0	2
+#define BM_PINCTRL_DRIVE5_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE5_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE5_RSRVD0)
+#define BP_PINCTRL_DRIVE5_BANK1_PIN08_MA	0
+#define BM_PINCTRL_DRIVE5_BANK1_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE5_BANK1_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE5_BANK1_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE6	(0x00000260)
+#define HW_PINCTRL_DRIVE6_SET	(0x00000264)
+#define HW_PINCTRL_DRIVE6_CLR	(0x00000268)
+#define HW_PINCTRL_DRIVE6_TOG	(0x0000026c)
+
+#define BP_PINCTRL_DRIVE6_RSRVD7	30
+#define BM_PINCTRL_DRIVE6_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE6_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE6_RSRVD7)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN23_MA	28
+#define BM_PINCTRL_DRIVE6_BANK1_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE6_BANK1_PIN23_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD6	26
+#define BM_PINCTRL_DRIVE6_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE6_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE6_RSRVD6)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN22_MA	24
+#define BM_PINCTRL_DRIVE6_BANK1_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE6_BANK1_PIN22_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD5	22
+#define BM_PINCTRL_DRIVE6_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE6_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE6_RSRVD5)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN21_MA	20
+#define BM_PINCTRL_DRIVE6_BANK1_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE6_BANK1_PIN21_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD4	18
+#define BM_PINCTRL_DRIVE6_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE6_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE6_RSRVD4)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN20_MA	16
+#define BM_PINCTRL_DRIVE6_BANK1_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE6_BANK1_PIN20_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD3	14
+#define BM_PINCTRL_DRIVE6_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE6_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE6_RSRVD3)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN19_MA	12
+#define BM_PINCTRL_DRIVE6_BANK1_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE6_BANK1_PIN19_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD2	10
+#define BM_PINCTRL_DRIVE6_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE6_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE6_RSRVD2)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN18_MA	8
+#define BM_PINCTRL_DRIVE6_BANK1_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE6_BANK1_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE6_BANK1_PIN18_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD1	6
+#define BM_PINCTRL_DRIVE6_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE6_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE6_RSRVD1)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN17_MA	4
+#define BM_PINCTRL_DRIVE6_BANK1_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE6_BANK1_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE6_BANK1_PIN17_MA)
+#define BP_PINCTRL_DRIVE6_RSRVD0	2
+#define BM_PINCTRL_DRIVE6_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE6_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE6_RSRVD0)
+#define BP_PINCTRL_DRIVE6_BANK1_PIN16_MA	0
+#define BM_PINCTRL_DRIVE6_BANK1_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE6_BANK1_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE6_BANK1_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE7	(0x00000270)
+#define HW_PINCTRL_DRIVE7_SET	(0x00000274)
+#define HW_PINCTRL_DRIVE7_CLR	(0x00000278)
+#define HW_PINCTRL_DRIVE7_TOG	(0x0000027c)
+
+#define BP_PINCTRL_DRIVE7_RSRVD7	28
+#define BM_PINCTRL_DRIVE7_RSRVD7	0xF0000000
+#define BF_PINCTRL_DRIVE7_RSRVD7(v) \
+		(((v) << 28) & BM_PINCTRL_DRIVE7_RSRVD7)
+#define BP_PINCTRL_DRIVE7_RSRVD6	26
+#define BM_PINCTRL_DRIVE7_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE7_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE7_RSRVD6)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN30_MA	24
+#define BM_PINCTRL_DRIVE7_BANK1_PIN30_MA	0x03000000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN30_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE7_BANK1_PIN30_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD5	22
+#define BM_PINCTRL_DRIVE7_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE7_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE7_RSRVD5)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN29_MA	20
+#define BM_PINCTRL_DRIVE7_BANK1_PIN29_MA	0x00300000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN29_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE7_BANK1_PIN29_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD4	18
+#define BM_PINCTRL_DRIVE7_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE7_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE7_RSRVD4)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN28_MA	16
+#define BM_PINCTRL_DRIVE7_BANK1_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE7_BANK1_PIN28_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD3	14
+#define BM_PINCTRL_DRIVE7_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE7_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE7_RSRVD3)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN27_MA	12
+#define BM_PINCTRL_DRIVE7_BANK1_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE7_BANK1_PIN27_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD2	10
+#define BM_PINCTRL_DRIVE7_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE7_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE7_RSRVD2)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN26_MA	8
+#define BM_PINCTRL_DRIVE7_BANK1_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE7_BANK1_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE7_BANK1_PIN26_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD1	6
+#define BM_PINCTRL_DRIVE7_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE7_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE7_RSRVD1)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN25_MA	4
+#define BM_PINCTRL_DRIVE7_BANK1_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE7_BANK1_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE7_BANK1_PIN25_MA)
+#define BP_PINCTRL_DRIVE7_RSRVD0	2
+#define BM_PINCTRL_DRIVE7_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE7_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE7_RSRVD0)
+#define BP_PINCTRL_DRIVE7_BANK1_PIN24_MA	0
+#define BM_PINCTRL_DRIVE7_BANK1_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE7_BANK1_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE7_BANK1_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE8	(0x00000280)
+#define HW_PINCTRL_DRIVE8_SET	(0x00000284)
+#define HW_PINCTRL_DRIVE8_CLR	(0x00000288)
+#define HW_PINCTRL_DRIVE8_TOG	(0x0000028c)
+
+#define BP_PINCTRL_DRIVE8_RSRVD7	30
+#define BM_PINCTRL_DRIVE8_RSRVD7	0xC0000000
+#define BF_PINCTRL_DRIVE8_RSRVD7(v) \
+		(((v) << 30) & BM_PINCTRL_DRIVE8_RSRVD7)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN07_MA	28
+#define BM_PINCTRL_DRIVE8_BANK2_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE8_BANK2_PIN07_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD6	26
+#define BM_PINCTRL_DRIVE8_RSRVD6	0x0C000000
+#define BF_PINCTRL_DRIVE8_RSRVD6(v)  \
+		(((v) << 26) & BM_PINCTRL_DRIVE8_RSRVD6)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN06_MA	24
+#define BM_PINCTRL_DRIVE8_BANK2_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE8_BANK2_PIN06_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD5	22
+#define BM_PINCTRL_DRIVE8_RSRVD5	0x00C00000
+#define BF_PINCTRL_DRIVE8_RSRVD5(v)  \
+		(((v) << 22) & BM_PINCTRL_DRIVE8_RSRVD5)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN05_MA	20
+#define BM_PINCTRL_DRIVE8_BANK2_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE8_BANK2_PIN05_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD4	18
+#define BM_PINCTRL_DRIVE8_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE8_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE8_RSRVD4)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN04_MA	16
+#define BM_PINCTRL_DRIVE8_BANK2_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE8_BANK2_PIN04_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD3	14
+#define BM_PINCTRL_DRIVE8_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE8_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE8_RSRVD3)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN03_MA	12
+#define BM_PINCTRL_DRIVE8_BANK2_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE8_BANK2_PIN03_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD2	10
+#define BM_PINCTRL_DRIVE8_RSRVD2	0x00000C00
+#define BF_PINCTRL_DRIVE8_RSRVD2(v)  \
+		(((v) << 10) & BM_PINCTRL_DRIVE8_RSRVD2)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN02_MA	8
+#define BM_PINCTRL_DRIVE8_BANK2_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE8_BANK2_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE8_BANK2_PIN02_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD1	6
+#define BM_PINCTRL_DRIVE8_RSRVD1	0x000000C0
+#define BF_PINCTRL_DRIVE8_RSRVD1(v)  \
+		(((v) << 6) & BM_PINCTRL_DRIVE8_RSRVD1)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN01_MA	4
+#define BM_PINCTRL_DRIVE8_BANK2_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE8_BANK2_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE8_BANK2_PIN01_MA)
+#define BP_PINCTRL_DRIVE8_RSRVD0	2
+#define BM_PINCTRL_DRIVE8_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE8_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE8_RSRVD0)
+#define BP_PINCTRL_DRIVE8_BANK2_PIN00_MA	0
+#define BM_PINCTRL_DRIVE8_BANK2_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE8_BANK2_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE8_BANK2_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE9	(0x00000290)
+#define HW_PINCTRL_DRIVE9_SET	(0x00000294)
+#define HW_PINCTRL_DRIVE9_CLR	(0x00000298)
+#define HW_PINCTRL_DRIVE9_TOG	(0x0000029c)
+
+#define BM_PINCTRL_DRIVE9_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN15_MA	28
+#define BM_PINCTRL_DRIVE9_BANK2_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE9_BANK2_PIN15_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN14_MA	24
+#define BM_PINCTRL_DRIVE9_BANK2_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE9_BANK2_PIN14_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN13_MA	20
+#define BM_PINCTRL_DRIVE9_BANK2_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE9_BANK2_PIN13_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN12_MA	16
+#define BM_PINCTRL_DRIVE9_BANK2_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE9_BANK2_PIN12_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN11_V	0x00004000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN11_MA	12
+#define BM_PINCTRL_DRIVE9_BANK2_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE9_BANK2_PIN11_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE9_BANK2_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE9_BANK2_PIN10_MA	8
+#define BM_PINCTRL_DRIVE9_BANK2_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE9_BANK2_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE9_BANK2_PIN10_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE9_BANK2_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE9_BANK2_PIN09_MA	4
+#define BM_PINCTRL_DRIVE9_BANK2_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE9_BANK2_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE9_BANK2_PIN09_MA)
+#define BP_PINCTRL_DRIVE9_RSRVD0	2
+#define BM_PINCTRL_DRIVE9_RSRVD0	0x0000000C
+#define BF_PINCTRL_DRIVE9_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_DRIVE9_RSRVD0)
+#define BP_PINCTRL_DRIVE9_BANK2_PIN08_MA	0
+#define BM_PINCTRL_DRIVE9_BANK2_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE9_BANK2_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE9_BANK2_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE10	(0x000002a0)
+#define HW_PINCTRL_DRIVE10_SET	(0x000002a4)
+#define HW_PINCTRL_DRIVE10_CLR	(0x000002a8)
+#define HW_PINCTRL_DRIVE10_TOG	(0x000002ac)
+
+#define BM_PINCTRL_DRIVE10_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN23_V	0x40000000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN23_MA	28
+#define BM_PINCTRL_DRIVE10_BANK2_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE10_BANK2_PIN23_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN22_V	0x04000000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN22_MA	24
+#define BM_PINCTRL_DRIVE10_BANK2_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE10_BANK2_PIN22_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN21_MA	20
+#define BM_PINCTRL_DRIVE10_BANK2_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE10_BANK2_PIN21_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN20_MA	16
+#define BM_PINCTRL_DRIVE10_BANK2_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE10_BANK2_PIN20_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN19_V	0x00004000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN19_MA	12
+#define BM_PINCTRL_DRIVE10_BANK2_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE10_BANK2_PIN19_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE10_BANK2_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE10_BANK2_PIN18_MA	8
+#define BM_PINCTRL_DRIVE10_BANK2_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE10_BANK2_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE10_BANK2_PIN18_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE10_BANK2_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE10_BANK2_PIN17_MA	4
+#define BM_PINCTRL_DRIVE10_BANK2_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE10_BANK2_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE10_BANK2_PIN17_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE10_BANK2_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE10_BANK2_PIN16_MA	0
+#define BM_PINCTRL_DRIVE10_BANK2_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE10_BANK2_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE10_BANK2_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE11	(0x000002b0)
+#define HW_PINCTRL_DRIVE11_SET	(0x000002b4)
+#define HW_PINCTRL_DRIVE11_CLR	(0x000002b8)
+#define HW_PINCTRL_DRIVE11_TOG	(0x000002bc)
+
+#define BM_PINCTRL_DRIVE11_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE11_BANK2_PIN31_V	0x40000000
+#define BP_PINCTRL_DRIVE11_BANK2_PIN31_MA	28
+#define BM_PINCTRL_DRIVE11_BANK2_PIN31_MA	0x30000000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN31_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE11_BANK2_PIN31_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE11_BANK2_PIN30_V	0x04000000
+#define BP_PINCTRL_DRIVE11_BANK2_PIN30_MA	24
+#define BM_PINCTRL_DRIVE11_BANK2_PIN30_MA	0x03000000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN30_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE11_BANK2_PIN30_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE11_BANK2_PIN29_V	0x00400000
+#define BP_PINCTRL_DRIVE11_BANK2_PIN29_MA	20
+#define BM_PINCTRL_DRIVE11_BANK2_PIN29_MA	0x00300000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN29_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE11_BANK2_PIN29_MA)
+#define BP_PINCTRL_DRIVE11_RSRVD4	18
+#define BM_PINCTRL_DRIVE11_RSRVD4	0x000C0000
+#define BF_PINCTRL_DRIVE11_RSRVD4(v)  \
+		(((v) << 18) & BM_PINCTRL_DRIVE11_RSRVD4)
+#define BP_PINCTRL_DRIVE11_BANK2_PIN28_MA	16
+#define BM_PINCTRL_DRIVE11_BANK2_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE11_BANK2_PIN28_MA)
+#define BP_PINCTRL_DRIVE11_RSRVD3	14
+#define BM_PINCTRL_DRIVE11_RSRVD3	0x0000C000
+#define BF_PINCTRL_DRIVE11_RSRVD3(v)  \
+		(((v) << 14) & BM_PINCTRL_DRIVE11_RSRVD3)
+#define BP_PINCTRL_DRIVE11_BANK2_PIN27_MA	12
+#define BM_PINCTRL_DRIVE11_BANK2_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE11_BANK2_PIN27_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE11_BANK2_PIN26_V	0x00000400
+#define BP_PINCTRL_DRIVE11_BANK2_PIN26_MA	8
+#define BM_PINCTRL_DRIVE11_BANK2_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE11_BANK2_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE11_BANK2_PIN26_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE11_BANK2_PIN25_V	0x00000040
+#define BP_PINCTRL_DRIVE11_BANK2_PIN25_MA	4
+#define BM_PINCTRL_DRIVE11_BANK2_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE11_BANK2_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE11_BANK2_PIN25_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE11_BANK2_PIN24_V	0x00000004
+#define BP_PINCTRL_DRIVE11_BANK2_PIN24_MA	0
+#define BM_PINCTRL_DRIVE11_BANK2_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE11_BANK2_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE11_BANK2_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE12	(0x000002c0)
+#define HW_PINCTRL_DRIVE12_SET	(0x000002c4)
+#define HW_PINCTRL_DRIVE12_CLR	(0x000002c8)
+#define HW_PINCTRL_DRIVE12_TOG	(0x000002cc)
+
+#define BM_PINCTRL_DRIVE12_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN07_MA	28
+#define BM_PINCTRL_DRIVE12_BANK3_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE12_BANK3_PIN07_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN06_MA	24
+#define BM_PINCTRL_DRIVE12_BANK3_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE12_BANK3_PIN06_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN05_MA	20
+#define BM_PINCTRL_DRIVE12_BANK3_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE12_BANK3_PIN05_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN04_MA	16
+#define BM_PINCTRL_DRIVE12_BANK3_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE12_BANK3_PIN04_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN03_MA	12
+#define BM_PINCTRL_DRIVE12_BANK3_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE12_BANK3_PIN03_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE12_BANK3_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE12_BANK3_PIN02_MA	8
+#define BM_PINCTRL_DRIVE12_BANK3_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE12_BANK3_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE12_BANK3_PIN02_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE12_BANK3_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE12_BANK3_PIN01_MA	4
+#define BM_PINCTRL_DRIVE12_BANK3_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE12_BANK3_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE12_BANK3_PIN01_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE12_BANK3_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE12_BANK3_PIN00_MA	0
+#define BM_PINCTRL_DRIVE12_BANK3_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE12_BANK3_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE12_BANK3_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE13	(0x000002d0)
+#define HW_PINCTRL_DRIVE13_SET	(0x000002d4)
+#define HW_PINCTRL_DRIVE13_CLR	(0x000002d8)
+#define HW_PINCTRL_DRIVE13_TOG	(0x000002dc)
+
+#define BM_PINCTRL_DRIVE13_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN15_MA	28
+#define BM_PINCTRL_DRIVE13_BANK3_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE13_BANK3_PIN15_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN14_MA	24
+#define BM_PINCTRL_DRIVE13_BANK3_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE13_BANK3_PIN14_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN13_MA	20
+#define BM_PINCTRL_DRIVE13_BANK3_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE13_BANK3_PIN13_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN12_MA	16
+#define BM_PINCTRL_DRIVE13_BANK3_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE13_BANK3_PIN12_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN11_V	0x00004000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN11_MA	12
+#define BM_PINCTRL_DRIVE13_BANK3_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE13_BANK3_PIN11_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE13_BANK3_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE13_BANK3_PIN10_MA	8
+#define BM_PINCTRL_DRIVE13_BANK3_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE13_BANK3_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE13_BANK3_PIN10_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE13_BANK3_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE13_BANK3_PIN09_MA	4
+#define BM_PINCTRL_DRIVE13_BANK3_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE13_BANK3_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE13_BANK3_PIN09_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE13_BANK3_PIN08_V	0x00000004
+#define BP_PINCTRL_DRIVE13_BANK3_PIN08_MA	0
+#define BM_PINCTRL_DRIVE13_BANK3_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE13_BANK3_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE13_BANK3_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE14	(0x000002e0)
+#define HW_PINCTRL_DRIVE14_SET	(0x000002e4)
+#define HW_PINCTRL_DRIVE14_CLR	(0x000002e8)
+#define HW_PINCTRL_DRIVE14_TOG	(0x000002ec)
+
+#define BP_PINCTRL_DRIVE14_RSRVD6	24
+#define BM_PINCTRL_DRIVE14_RSRVD6	0xFF000000
+#define BF_PINCTRL_DRIVE14_RSRVD6(v) \
+		(((v) << 24) & BM_PINCTRL_DRIVE14_RSRVD6)
+#define BM_PINCTRL_DRIVE14_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN21_MA	20
+#define BM_PINCTRL_DRIVE14_BANK3_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE14_BANK3_PIN21_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN20_MA	16
+#define BM_PINCTRL_DRIVE14_BANK3_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE14_BANK3_PIN20_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN19_V	0x00004000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN19_MA	12
+#define BM_PINCTRL_DRIVE14_BANK3_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE14_BANK3_PIN19_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE14_BANK3_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE14_BANK3_PIN18_MA	8
+#define BM_PINCTRL_DRIVE14_BANK3_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE14_BANK3_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE14_BANK3_PIN18_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE14_BANK3_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE14_BANK3_PIN17_MA	4
+#define BM_PINCTRL_DRIVE14_BANK3_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE14_BANK3_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE14_BANK3_PIN17_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE14_BANK3_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE14_BANK3_PIN16_MA	0
+#define BM_PINCTRL_DRIVE14_BANK3_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE14_BANK3_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE14_BANK3_PIN16_MA)
+
+#define HW_PINCTRL_PULL0	(0x00000400)
+#define HW_PINCTRL_PULL0_SET	(0x00000404)
+#define HW_PINCTRL_PULL0_CLR	(0x00000408)
+#define HW_PINCTRL_PULL0_TOG	(0x0000040c)
+
+#define BM_PINCTRL_PULL0_BANK0_PIN31	0x80000000
+#define BM_PINCTRL_PULL0_BANK0_PIN30	0x40000000
+#define BM_PINCTRL_PULL0_BANK0_PIN29	0x20000000
+#define BM_PINCTRL_PULL0_BANK0_PIN28	0x10000000
+#define BM_PINCTRL_PULL0_BANK0_PIN27	0x08000000
+#define BM_PINCTRL_PULL0_BANK0_PIN26	0x04000000
+#define BP_PINCTRL_PULL0_RSRVD2	23
+#define BM_PINCTRL_PULL0_RSRVD2	0x03800000
+#define BF_PINCTRL_PULL0_RSRVD2(v)  \
+		(((v) << 23) & BM_PINCTRL_PULL0_RSRVD2)
+#define BM_PINCTRL_PULL0_BANK0_PIN22	0x00400000
+#define BM_PINCTRL_PULL0_BANK0_PIN21	0x00200000
+#define BM_PINCTRL_PULL0_BANK0_PIN20	0x00100000
+#define BM_PINCTRL_PULL0_BANK0_PIN19	0x00080000
+#define BM_PINCTRL_PULL0_BANK0_PIN18	0x00040000
+#define BP_PINCTRL_PULL0_RSRVD1	16
+#define BM_PINCTRL_PULL0_RSRVD1	0x00030000
+#define BF_PINCTRL_PULL0_RSRVD1(v)  \
+		(((v) << 16) & BM_PINCTRL_PULL0_RSRVD1)
+#define BM_PINCTRL_PULL0_BANK0_PIN15	0x00008000
+#define BP_PINCTRL_PULL0_RSRVD0	12
+#define BM_PINCTRL_PULL0_RSRVD0	0x00007000
+#define BF_PINCTRL_PULL0_RSRVD0(v)  \
+		(((v) << 12) & BM_PINCTRL_PULL0_RSRVD0)
+#define BM_PINCTRL_PULL0_BANK0_PIN11	0x00000800
+#define BM_PINCTRL_PULL0_BANK0_PIN10	0x00000400
+#define BM_PINCTRL_PULL0_BANK0_PIN09	0x00000200
+#define BM_PINCTRL_PULL0_BANK0_PIN08	0x00000100
+#define BM_PINCTRL_PULL0_BANK0_PIN07	0x00000080
+#define BM_PINCTRL_PULL0_BANK0_PIN06	0x00000040
+#define BM_PINCTRL_PULL0_BANK0_PIN05	0x00000020
+#define BM_PINCTRL_PULL0_BANK0_PIN04	0x00000010
+#define BM_PINCTRL_PULL0_BANK0_PIN03	0x00000008
+#define BM_PINCTRL_PULL0_BANK0_PIN02	0x00000004
+#define BM_PINCTRL_PULL0_BANK0_PIN01	0x00000002
+#define BM_PINCTRL_PULL0_BANK0_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL1	(0x00000410)
+#define HW_PINCTRL_PULL1_SET	(0x00000414)
+#define HW_PINCTRL_PULL1_CLR	(0x00000418)
+#define HW_PINCTRL_PULL1_TOG	(0x0000041c)
+
+#define BP_PINCTRL_PULL1_RSRVD3	29
+#define BM_PINCTRL_PULL1_RSRVD3	0xE0000000
+#define BF_PINCTRL_PULL1_RSRVD3(v) \
+		(((v) << 29) & BM_PINCTRL_PULL1_RSRVD3)
+#define BM_PINCTRL_PULL1_BANK1_PIN28	0x10000000
+#define BP_PINCTRL_PULL1_RSRVD2	23
+#define BM_PINCTRL_PULL1_RSRVD2	0x0F800000
+#define BF_PINCTRL_PULL1_RSRVD2(v)  \
+		(((v) << 23) & BM_PINCTRL_PULL1_RSRVD2)
+#define BM_PINCTRL_PULL1_BANK1_PIN22	0x00400000
+#define BP_PINCTRL_PULL1_RSRVD1	19
+#define BM_PINCTRL_PULL1_RSRVD1	0x00380000
+#define BF_PINCTRL_PULL1_RSRVD1(v)  \
+		(((v) << 19) & BM_PINCTRL_PULL1_RSRVD1)
+#define BM_PINCTRL_PULL1_BANK1_PIN18	0x00040000
+#define BP_PINCTRL_PULL1_RSRVD0	0
+#define BM_PINCTRL_PULL1_RSRVD0	0x0003FFFF
+#define BF_PINCTRL_PULL1_RSRVD0(v)  \
+		(((v) << 0) & BM_PINCTRL_PULL1_RSRVD0)
+
+#define HW_PINCTRL_PULL2	(0x00000420)
+#define HW_PINCTRL_PULL2_SET	(0x00000424)
+#define HW_PINCTRL_PULL2_CLR	(0x00000428)
+#define HW_PINCTRL_PULL2_TOG	(0x0000042c)
+
+#define BP_PINCTRL_PULL2_RSRVD2	29
+#define BM_PINCTRL_PULL2_RSRVD2	0xE0000000
+#define BF_PINCTRL_PULL2_RSRVD2(v) \
+		(((v) << 29) & BM_PINCTRL_PULL2_RSRVD2)
+#define BM_PINCTRL_PULL2_BANK2_PIN28	0x10000000
+#define BM_PINCTRL_PULL2_BANK2_PIN27	0x08000000
+#define BP_PINCTRL_PULL2_RSRVD1	9
+#define BM_PINCTRL_PULL2_RSRVD1	0x07FFFE00
+#define BF_PINCTRL_PULL2_RSRVD1(v)  \
+		(((v) << 9) & BM_PINCTRL_PULL2_RSRVD1)
+#define BM_PINCTRL_PULL2_BANK2_PIN08	0x00000100
+#define BP_PINCTRL_PULL2_RSRVD0	6
+#define BM_PINCTRL_PULL2_RSRVD0	0x000000C0
+#define BF_PINCTRL_PULL2_RSRVD0(v)  \
+		(((v) << 6) & BM_PINCTRL_PULL2_RSRVD0)
+#define BM_PINCTRL_PULL2_BANK2_PIN05	0x00000020
+#define BM_PINCTRL_PULL2_BANK2_PIN04	0x00000010
+#define BM_PINCTRL_PULL2_BANK2_PIN03	0x00000008
+#define BM_PINCTRL_PULL2_BANK2_PIN02	0x00000004
+#define BM_PINCTRL_PULL2_BANK2_PIN01	0x00000002
+#define BM_PINCTRL_PULL2_BANK2_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL3	(0x00000430)
+#define HW_PINCTRL_PULL3_SET	(0x00000434)
+#define HW_PINCTRL_PULL3_CLR	(0x00000438)
+#define HW_PINCTRL_PULL3_TOG	(0x0000043c)
+
+#define BP_PINCTRL_PULL3_RSRVD0	18
+#define BM_PINCTRL_PULL3_RSRVD0	0xFFFC0000
+#define BF_PINCTRL_PULL3_RSRVD0(v) \
+		(((v) << 18) & BM_PINCTRL_PULL3_RSRVD0)
+#define BM_PINCTRL_PULL3_BANK3_PIN17	0x00020000
+#define BM_PINCTRL_PULL3_BANK3_PIN16	0x00010000
+#define BM_PINCTRL_PULL3_BANK3_PIN15	0x00008000
+#define BM_PINCTRL_PULL3_BANK3_PIN14	0x00004000
+#define BM_PINCTRL_PULL3_BANK3_PIN13	0x00002000
+#define BM_PINCTRL_PULL3_BANK3_PIN12	0x00001000
+#define BM_PINCTRL_PULL3_BANK3_PIN11	0x00000800
+#define BM_PINCTRL_PULL3_BANK3_PIN10	0x00000400
+#define BM_PINCTRL_PULL3_BANK3_PIN09	0x00000200
+#define BM_PINCTRL_PULL3_BANK3_PIN08	0x00000100
+#define BM_PINCTRL_PULL3_BANK3_PIN07	0x00000080
+#define BM_PINCTRL_PULL3_BANK3_PIN06	0x00000040
+#define BM_PINCTRL_PULL3_BANK3_PIN05	0x00000020
+#define BM_PINCTRL_PULL3_BANK3_PIN04	0x00000010
+#define BM_PINCTRL_PULL3_BANK3_PIN03	0x00000008
+#define BM_PINCTRL_PULL3_BANK3_PIN02	0x00000004
+#define BM_PINCTRL_PULL3_BANK3_PIN01	0x00000002
+#define BM_PINCTRL_PULL3_BANK3_PIN00	0x00000001
+
+#define HW_PINCTRL_DOUT0	(0x00000500)
+#define HW_PINCTRL_DOUT0_SET	(0x00000504)
+#define HW_PINCTRL_DOUT0_CLR	(0x00000508)
+#define HW_PINCTRL_DOUT0_TOG	(0x0000050c)
+
+#define BP_PINCTRL_DOUT0_DOUT	0
+#define BM_PINCTRL_DOUT0_DOUT	0xFFFFFFFF
+#define BF_PINCTRL_DOUT0_DOUT(v)	(v)
+
+#define HW_PINCTRL_DOUT1	(0x00000510)
+#define HW_PINCTRL_DOUT1_SET	(0x00000514)
+#define HW_PINCTRL_DOUT1_CLR	(0x00000518)
+#define HW_PINCTRL_DOUT1_TOG	(0x0000051c)
+
+#define BM_PINCTRL_DOUT1_RSRVD1	0x80000000
+#define BP_PINCTRL_DOUT1_DOUT	0
+#define BM_PINCTRL_DOUT1_DOUT	0x7FFFFFFF
+#define BF_PINCTRL_DOUT1_DOUT(v)  \
+		(((v) << 0) & BM_PINCTRL_DOUT1_DOUT)
+
+#define HW_PINCTRL_DOUT2	(0x00000520)
+#define HW_PINCTRL_DOUT2_SET	(0x00000524)
+#define HW_PINCTRL_DOUT2_CLR	(0x00000528)
+#define HW_PINCTRL_DOUT2_TOG	(0x0000052c)
+
+#define BP_PINCTRL_DOUT2_DOUT	0
+#define BM_PINCTRL_DOUT2_DOUT	0xFFFFFFFF
+#define BF_PINCTRL_DOUT2_DOUT(v)	(v)
+
+#define HW_PINCTRL_DIN0	(0x00000600)
+#define HW_PINCTRL_DIN0_SET	(0x00000604)
+#define HW_PINCTRL_DIN0_CLR	(0x00000608)
+#define HW_PINCTRL_DIN0_TOG	(0x0000060c)
+
+#define BP_PINCTRL_DIN0_DIN	0
+#define BM_PINCTRL_DIN0_DIN	0xFFFFFFFF
+#define BF_PINCTRL_DIN0_DIN(v)	(v)
+
+#define HW_PINCTRL_DIN1	(0x00000610)
+#define HW_PINCTRL_DIN1_SET	(0x00000614)
+#define HW_PINCTRL_DIN1_CLR	(0x00000618)
+#define HW_PINCTRL_DIN1_TOG	(0x0000061c)
+
+#define BM_PINCTRL_DIN1_RSRVD1	0x80000000
+#define BP_PINCTRL_DIN1_DIN	0
+#define BM_PINCTRL_DIN1_DIN	0x7FFFFFFF
+#define BF_PINCTRL_DIN1_DIN(v)  \
+		(((v) << 0) & BM_PINCTRL_DIN1_DIN)
+
+#define HW_PINCTRL_DIN2	(0x00000620)
+#define HW_PINCTRL_DIN2_SET	(0x00000624)
+#define HW_PINCTRL_DIN2_CLR	(0x00000628)
+#define HW_PINCTRL_DIN2_TOG	(0x0000062c)
+
+#define BP_PINCTRL_DIN2_DIN	0
+#define BM_PINCTRL_DIN2_DIN	0xFFFFFFFF
+#define BF_PINCTRL_DIN2_DIN(v)	(v)
+
+#define HW_PINCTRL_DOE0	(0x00000700)
+#define HW_PINCTRL_DOE0_SET	(0x00000704)
+#define HW_PINCTRL_DOE0_CLR	(0x00000708)
+#define HW_PINCTRL_DOE0_TOG	(0x0000070c)
+
+#define BP_PINCTRL_DOE0_DOE	0
+#define BM_PINCTRL_DOE0_DOE	0xFFFFFFFF
+#define BF_PINCTRL_DOE0_DOE(v)	(v)
+
+#define HW_PINCTRL_DOE1	(0x00000710)
+#define HW_PINCTRL_DOE1_SET	(0x00000714)
+#define HW_PINCTRL_DOE1_CLR	(0x00000718)
+#define HW_PINCTRL_DOE1_TOG	(0x0000071c)
+
+#define BM_PINCTRL_DOE1_RSRVD1	0x80000000
+#define BP_PINCTRL_DOE1_DOE	0
+#define BM_PINCTRL_DOE1_DOE	0x7FFFFFFF
+#define BF_PINCTRL_DOE1_DOE(v)  \
+		(((v) << 0) & BM_PINCTRL_DOE1_DOE)
+
+#define HW_PINCTRL_DOE2	(0x00000720)
+#define HW_PINCTRL_DOE2_SET	(0x00000724)
+#define HW_PINCTRL_DOE2_CLR	(0x00000728)
+#define HW_PINCTRL_DOE2_TOG	(0x0000072c)
+
+#define BP_PINCTRL_DOE2_DOE	0
+#define BM_PINCTRL_DOE2_DOE	0xFFFFFFFF
+#define BF_PINCTRL_DOE2_DOE(v)	(v)
+
+#define HW_PINCTRL_PIN2IRQ0	(0x00000800)
+#define HW_PINCTRL_PIN2IRQ0_SET	(0x00000804)
+#define HW_PINCTRL_PIN2IRQ0_CLR	(0x00000808)
+#define HW_PINCTRL_PIN2IRQ0_TOG	(0x0000080c)
+
+#define BP_PINCTRL_PIN2IRQ0_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ0_PIN2IRQ	0xFFFFFFFF
+#define BF_PINCTRL_PIN2IRQ0_PIN2IRQ(v)	(v)
+
+#define HW_PINCTRL_PIN2IRQ1	(0x00000810)
+#define HW_PINCTRL_PIN2IRQ1_SET	(0x00000814)
+#define HW_PINCTRL_PIN2IRQ1_CLR	(0x00000818)
+#define HW_PINCTRL_PIN2IRQ1_TOG	(0x0000081c)
+
+#define BM_PINCTRL_PIN2IRQ1_RSRVD1	0x80000000
+#define BP_PINCTRL_PIN2IRQ1_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ1_PIN2IRQ	0x7FFFFFFF
+#define BF_PINCTRL_PIN2IRQ1_PIN2IRQ(v)  \
+		(((v) << 0) & BM_PINCTRL_PIN2IRQ1_PIN2IRQ)
+
+#define HW_PINCTRL_PIN2IRQ2	(0x00000820)
+#define HW_PINCTRL_PIN2IRQ2_SET	(0x00000824)
+#define HW_PINCTRL_PIN2IRQ2_CLR	(0x00000828)
+#define HW_PINCTRL_PIN2IRQ2_TOG	(0x0000082c)
+
+#define BP_PINCTRL_PIN2IRQ2_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ2_PIN2IRQ	0xFFFFFFFF
+#define BF_PINCTRL_PIN2IRQ2_PIN2IRQ(v)	(v)
+
+#define HW_PINCTRL_IRQEN0	(0x00000900)
+#define HW_PINCTRL_IRQEN0_SET	(0x00000904)
+#define HW_PINCTRL_IRQEN0_CLR	(0x00000908)
+#define HW_PINCTRL_IRQEN0_TOG	(0x0000090c)
+
+#define BP_PINCTRL_IRQEN0_IRQEN	0
+#define BM_PINCTRL_IRQEN0_IRQEN	0xFFFFFFFF
+#define BF_PINCTRL_IRQEN0_IRQEN(v)	(v)
+
+#define HW_PINCTRL_IRQEN1	(0x00000910)
+#define HW_PINCTRL_IRQEN1_SET	(0x00000914)
+#define HW_PINCTRL_IRQEN1_CLR	(0x00000918)
+#define HW_PINCTRL_IRQEN1_TOG	(0x0000091c)
+
+#define BM_PINCTRL_IRQEN1_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQEN1_IRQEN	0
+#define BM_PINCTRL_IRQEN1_IRQEN	0x7FFFFFFF
+#define BF_PINCTRL_IRQEN1_IRQEN(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQEN1_IRQEN)
+
+#define HW_PINCTRL_IRQEN2	(0x00000920)
+#define HW_PINCTRL_IRQEN2_SET	(0x00000924)
+#define HW_PINCTRL_IRQEN2_CLR	(0x00000928)
+#define HW_PINCTRL_IRQEN2_TOG	(0x0000092c)
+
+#define BP_PINCTRL_IRQEN2_IRQEN	0
+#define BM_PINCTRL_IRQEN2_IRQEN	0xFFFFFFFF
+#define BF_PINCTRL_IRQEN2_IRQEN(v)	(v)
+
+#define HW_PINCTRL_IRQLEVEL0	(0x00000a00)
+#define HW_PINCTRL_IRQLEVEL0_SET	(0x00000a04)
+#define HW_PINCTRL_IRQLEVEL0_CLR	(0x00000a08)
+#define HW_PINCTRL_IRQLEVEL0_TOG	(0x00000a0c)
+
+#define BP_PINCTRL_IRQLEVEL0_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL0_IRQLEVEL	0xFFFFFFFF
+#define BF_PINCTRL_IRQLEVEL0_IRQLEVEL(v)	(v)
+
+#define HW_PINCTRL_IRQLEVEL1	(0x00000a10)
+#define HW_PINCTRL_IRQLEVEL1_SET	(0x00000a14)
+#define HW_PINCTRL_IRQLEVEL1_CLR	(0x00000a18)
+#define HW_PINCTRL_IRQLEVEL1_TOG	(0x00000a1c)
+
+#define BM_PINCTRL_IRQLEVEL1_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQLEVEL1_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL1_IRQLEVEL	0x7FFFFFFF
+#define BF_PINCTRL_IRQLEVEL1_IRQLEVEL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQLEVEL1_IRQLEVEL)
+
+#define HW_PINCTRL_IRQLEVEL2	(0x00000a20)
+#define HW_PINCTRL_IRQLEVEL2_SET	(0x00000a24)
+#define HW_PINCTRL_IRQLEVEL2_CLR	(0x00000a28)
+#define HW_PINCTRL_IRQLEVEL2_TOG	(0x00000a2c)
+
+#define BP_PINCTRL_IRQLEVEL2_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL2_IRQLEVEL	0xFFFFFFFF
+#define BF_PINCTRL_IRQLEVEL2_IRQLEVEL(v)	(v)
+
+#define HW_PINCTRL_IRQPOL0	(0x00000b00)
+#define HW_PINCTRL_IRQPOL0_SET	(0x00000b04)
+#define HW_PINCTRL_IRQPOL0_CLR	(0x00000b08)
+#define HW_PINCTRL_IRQPOL0_TOG	(0x00000b0c)
+
+#define BP_PINCTRL_IRQPOL0_IRQPOL	0
+#define BM_PINCTRL_IRQPOL0_IRQPOL	0xFFFFFFFF
+#define BF_PINCTRL_IRQPOL0_IRQPOL(v)	(v)
+
+#define HW_PINCTRL_IRQPOL1	(0x00000b10)
+#define HW_PINCTRL_IRQPOL1_SET	(0x00000b14)
+#define HW_PINCTRL_IRQPOL1_CLR	(0x00000b18)
+#define HW_PINCTRL_IRQPOL1_TOG	(0x00000b1c)
+
+#define BM_PINCTRL_IRQPOL1_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQPOL1_IRQPOL	0
+#define BM_PINCTRL_IRQPOL1_IRQPOL	0x7FFFFFFF
+#define BF_PINCTRL_IRQPOL1_IRQPOL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQPOL1_IRQPOL)
+
+#define HW_PINCTRL_IRQPOL2	(0x00000b20)
+#define HW_PINCTRL_IRQPOL2_SET	(0x00000b24)
+#define HW_PINCTRL_IRQPOL2_CLR	(0x00000b28)
+#define HW_PINCTRL_IRQPOL2_TOG	(0x00000b2c)
+
+#define BP_PINCTRL_IRQPOL2_IRQPOL	0
+#define BM_PINCTRL_IRQPOL2_IRQPOL	0xFFFFFFFF
+#define BF_PINCTRL_IRQPOL2_IRQPOL(v)	(v)
+
+#define HW_PINCTRL_IRQSTAT0	(0x00000c00)
+#define HW_PINCTRL_IRQSTAT0_SET	(0x00000c04)
+#define HW_PINCTRL_IRQSTAT0_CLR	(0x00000c08)
+#define HW_PINCTRL_IRQSTAT0_TOG	(0x00000c0c)
+
+#define BP_PINCTRL_IRQSTAT0_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT0_IRQSTAT	0xFFFFFFFF
+#define BF_PINCTRL_IRQSTAT0_IRQSTAT(v)	(v)
+
+#define HW_PINCTRL_IRQSTAT1	(0x00000c10)
+#define HW_PINCTRL_IRQSTAT1_SET	(0x00000c14)
+#define HW_PINCTRL_IRQSTAT1_CLR	(0x00000c18)
+#define HW_PINCTRL_IRQSTAT1_TOG	(0x00000c1c)
+
+#define BM_PINCTRL_IRQSTAT1_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQSTAT1_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT1_IRQSTAT	0x7FFFFFFF
+#define BF_PINCTRL_IRQSTAT1_IRQSTAT(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQSTAT1_IRQSTAT)
+
+#define HW_PINCTRL_IRQSTAT2	(0x00000c20)
+#define HW_PINCTRL_IRQSTAT2_SET	(0x00000c24)
+#define HW_PINCTRL_IRQSTAT2_CLR	(0x00000c28)
+#define HW_PINCTRL_IRQSTAT2_TOG	(0x00000c2c)
+
+#define BP_PINCTRL_IRQSTAT2_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT2_IRQSTAT	0xFFFFFFFF
+#define BF_PINCTRL_IRQSTAT2_IRQSTAT(v)	(v)
+#endif /* __ARCH_ARM___PINCTRL_H */
diff --git a/arch/arm/mach-mx23/serial.c b/arch/arm/mach-mx23/serial.c
new file mode 100644
index 0000000..85a08cd
--- /dev/null
+++ b/arch/arm/mach-mx23/serial.c
@@ -0,0 +1,161 @@
+/*
+  * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License along
+  * with this program; if not, write to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+  */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/dma.h>
+#include "device.h"
+
+#if defined(CONFIG_SERIAL_MXS_AUART) || \
+	defined(CONFIG_SERIAL_MXS_AUART_MODULE)
+
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+static struct resource auart1_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART1_PHYS_ADDR,
+	 .end	= AUART1_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP_INTERNAL,
+	 .end	= IRQ_UARTAPP_INTERNAL,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP_RX_DMA,
+	 .end	= IRQ_UARTAPP_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP_TX_DMA,
+	 .end	= IRQ_UARTAPP_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart1_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART1_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = 8,
+	.timeout = HZ,
+};
+#endif
+
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+static struct resource auart2_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART2_PHYS_ADDR,
+	 .end	= AUART2_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP2_INTERNAL,
+	 .end	= IRQ_UARTAPP2_INTERNAL,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP2_RX_DMA,
+	 .end	= IRQ_UARTAPP2_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_UARTAPP2_TX_DMA,
+	 .end	= IRQ_UARTAPP2_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart2_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART2_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = 8,
+	.timeout = HZ,
+};
+#endif
+
+void __init mx23_init_auart(void)
+{
+	int i;
+	struct mxs_dev_lookup *plookup;
+	struct platform_device *pdev;
+
+	plookup = mxs_get_devices("mxs-auart");
+	if (plookup == NULL || IS_ERR(plookup))
+		return;
+	for (i = 0; i < plookup->size; i++) {
+		pdev = plookup->pdev + i;
+		switch (pdev->id) {
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+		case 1:
+			pdev->resource = auart1_resource;
+			pdev->num_resources = ARRAY_SIZE(auart1_resource);
+			pdev->dev.platform_data = &mxs_auart1_platdata;
+			break;
+#endif
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+		case 2:
+			pdev->resource = auart2_resource;
+			pdev->num_resources = ARRAY_SIZE(auart2_resource);
+			pdev->dev.platform_data = &mxs_auart2_platdata;
+			break;
+#endif
+		default:
+			break;
+		}
+		mxs_add_device(pdev, 3);
+	}
+}
+#else
+void __init mx23_init_auart(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx23/sleep.S b/arch/arm/mach-mx23/sleep.S
new file mode 100644
index 0000000..0e6b00f
--- /dev/null
+++ b/arch/arm/mach-mx23/sleep.S
@@ -0,0 +1,553 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <asm/pgtable-hwdef.h>
+#include <mach/hardware.h>
+#include <mach/regs-power.h>
+#include "regs-clkctrl.h"
+#include "sleep.h"
+
+#define HW_CLKCTRL_CPU_ADDR \
+	(MX23_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR) + HW_CLKCTRL_CPU)
+#define HW_POWER_MINPWR_ADDR \
+	(MX23_SOC_IO_ADDRESS(POWER_PHYS_ADDR) + HW_POWER_MINPWR)
+#define HW_POWER_RESET_ADDR \
+	(MX23_SOC_IO_ADDRESS(POWER_PHYS_ADDR) + HW_POWER_RESET)
+
+#define HW_DRAM_CTL06	MX23_SOC_IO_ADDRESS(0x800E0018)
+#define HW_DRAM_CTL08	MX23_SOC_IO_ADDRESS(0x800E0020)
+#define HW_EMI_STAT	MX23_SOC_IO_ADDRESS(0x80020010)
+#define HW_RTC_PERSISTENT0 \
+			MX23_SOC_IO_ADDRESS(0x8005C060)
+
+#define PHYS_RAM_START		0x40000000
+
+.global cpu_arm926_switch_mm
+
+		.text
+
+.align 8
+ENTRY(mx23_cpu_standby)
+	@ save registers on stack
+	stmfd	sp!, {r0 - r9, lr}
+
+	adr	r9, __mx23_temp_stack
+
+	@ clean cache
+	ldr	r1, __mx23_flush_cache_addr
+	mov	lr, pc
+	mov	pc, r1
+
+	@ put DRAM into self refresh
+	mov	r0, #(HW_DRAM_CTL08 & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(1 << 8)
+	str	r1, [r0]
+	@ wait for it to actually happen
+	mov	r0, #(HW_EMI_STAT & 0x000000FF)
+	orr	r0, r0, #(HW_EMI_STAT & 0x0000FF00)
+	orr	r0, r0, #(HW_EMI_STAT & 0x00FF0000)
+	orr	r0, r0, #(HW_EMI_STAT & 0xFF000000)
+1:	ldr	r1, [r0]
+	teq	r1, #(1 << 1)
+	beq	1b
+	nop
+	nop
+	nop
+	nop
+	nop
+
+#ifdef CONFIG_STMP378X_RAM_FREQ_SCALING
+	@ RAM to clk from xtal
+	mov	lr, pc
+	b	mx23_ram_save_timings
+	mov	lr, pc
+	b	mx23_ram_24M_set_timings
+
+	mov	r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0xFF000000)
+	ldr	r4, [r0]
+	mov	r1, #(1<<6)
+	str	r1, [r0, #4]
+1:	ldr	r1, [r0]
+	tst	r1, #BM_CLKCTRL_EMI_BUSY_REF_XTAL
+	bne	1b
+
+	@ save RAM divisors
+	mov	r0, #(HW_CLKCTRL_FRAC_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_FRAC_ADDR & 0xFF000000)
+	ldr	r8, [r0]
+	and	r8, r8, #(0x3F << 8)
+	lsr	r8, r8, #8
+	mov	r0, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+	ldr	r7, [r0]
+	and	r7, r7, #0x3F
+
+	@ shut the PLL down
+	mov	r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0xFF000000)
+	mov	r1, #(1<<16)
+	str	r1, [r0, #0x08]	@ clear
+
+	@ set vddd to minimum
+	mov	r0, #(HW_POWER_VDDDCTRL_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0xFF000000)
+	ldr	r6, [r0]
+	bic	r1, r6, #0xFF
+	bic	r1, r1, #0x30
+	orr	r1, r1, #0xa
+	str	r1, [r0]
+	/* now wait 1000 us = 24000 cycles */
+	mov	r0, #24 << 10
+3:	sub	r0, r0, #1
+	cmp	r0, #0
+	bne	3b
+	nop
+#endif
+
+	@ do enter standby
+	mov	r0, #(HW_CLKCTRL_CPU_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0xFF000000)
+	mov	r1, #(1<<12)
+	str	r1, [r0, #4]
+	mov	r2, #0
+	mcr	p15, 0, r2, c7, c0, 4
+	nop
+
+	@ sleeping now...
+
+	@ remove INTERRUPT_WAIT bit
+	str	r1, [r0, #8]
+	nop
+	nop
+	nop
+
+#ifdef CONFIG_STMP378X_RAM_FREQ_SCALING
+	@ restore vddd
+	mov	r0, #(HW_POWER_VDDDCTRL_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_POWER_VDDDCTRL_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	str	r6, [r0]
+	/* now wait 1000 us = 24000 cycles */
+	mov	r0, #24 << 10
+12:	sub	r0, r0, #1
+	cmp	r0, #0
+	bne	12b
+	nop
+
+	@ put the PLL back up
+	mov	r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_PLLCTRL0_ADDR & 0xFF000000)
+	mov	r1, #(1<<16)
+	str	r1, [r0, #0x04]	@ set
+	/* now wait 10 us = 240 cycles */
+	mov	r0, #240
+11:	sub	r0, r0, #1
+	cmp	r0, #0
+	bne	11b
+	nop
+
+	@ set divisors and switch EMI back to PLL
+	mov	lr, pc
+	b	mx23_ram_restore_timings
+	mov	lr, pc
+	b	__mx23_emi_set_values
+
+	mov	r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CLKSEQ_ADDR & 0xFF000000)
+	mov	r1, #(1<<6)
+	str	r1, [r0, #8]
+
+	mov	r0, #(HW_CLKCTRL_EMI_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_EMI_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	bic	r1, #BM_CLKCTRL_EMI_DCC_RESYNC_ENABLE
+	str	r1, [r0]
+#endif
+
+	@ restore normal DRAM mode
+	mov	r0, #(HW_DRAM_CTL08 & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0xFF000000)
+	ldr	r1, [r0]
+	bic	r1, r1, #(1 << 8)
+	str	r1, [r0]
+	@ wait for it to actually happen
+	mov	r0, #(HW_EMI_STAT & 0x000000FF)
+	orr	r0, r0, #(HW_EMI_STAT & 0x0000FF00)
+	orr	r0, r0, #(HW_EMI_STAT & 0x00FF0000)
+	orr	r0, r0, #(HW_EMI_STAT & 0xFF000000)
+102:	ldr	r1, [r0]
+	tst	r1, #(1 << 1)
+	bne	102b
+
+	nop
+	nop
+	nop
+
+	@ restore regs and return
+	ldmfd   sp!, {r0 - r9, pc}
+
+	.space	0x100
+__mx23_temp_stack:
+	.word	0
+
+#ifdef CONFIG_STMP378X_RAM_FREQ_SCALING
+#include "emi.inc"
+#endif
+
+__mx23_flush_cache_addr:
+	.word	arm926_flush_kern_cache_all
+
+ENTRY(mx23_standby_alloc_sz)
+	.word	. - mx23_cpu_standby
+
+ENTRY(mx23_cpu_suspend)
+	@ save registers on stack
+	stmfd	sp!, {r1 - r12, lr}
+
+	@ save context
+	mov	r0, #0xd3	@ SVC, Interrupts disabled
+	msr	cpsr, r0
+	mov	r1, #0xC0000000
+	ldr	r1, [r1]
+	mrc	p15, 0, r0, c1, c0, 0
+	str	r0, [r1, #MMUCTL_OFFS]
+	mrc	p15, 0, r0, c15, c1, 0
+	str	r0, [r1, #MMUCPACCESS_OFS]
+	mrc	p15, 0, r0, c2, c0, 0
+	str	r0, [r1, #MMUTTB_OFFS]
+	mrc	p15, 0, r0, c3, c0, 0
+	str	r0, [r1, #MMUDOMAIN_OFFS]
+	mrc	p15, 0, r0, c13, c0, 0
+	str	r0, [r1, #MMUPID_OFFS]
+
+	str	sp, [r1, #SVC_SP_OFFS]
+	mrs	r0, spsr
+	str	r0, [r1, #SVC_SPSR_OFFS]
+
+	add	r2, r1, #FIQ_SPSR_OFFS
+	mov	r0, #0xd1	@ FIQ, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, r8-r12, sp, lr}
+
+	add	r2, r1, #ABT_SPSR_OFFS
+	mov	r0, #0xd7	@ ABT, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #IRQ_SPSR_OFFS
+	mov	r0, #0xd2	@ IRQ, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #UND_SPSR_OFFS
+	mov	r0, #0xdb	@ UND, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #SYS_SP_OFFS
+	mov	r0, #0xdf	@ SYS, Interrupts disabled
+	msr	cpsr, r0
+	stmia	r2!, {sp, lr}
+
+	add	r2, r1, #SVC_R8_OFFS
+	mov	r0, #0xd3	@ Back to SVC, Interrupts disabled
+	msr	cpsr, r0
+
+	@ save entry point
+	sub	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	mov	r0, #0xC0000000
+	str	r1, [r0]
+	ldr	r1, __mx23_resume_point
+	sub	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	str	r1, [r0, #4]
+	mov	r0, #0
+
+	@ clean cache
+	ldr	r1, __mx23_flush_cache_addr2
+	mov	lr, pc
+	mov	pc, r1
+
+	@ enable internal xtal
+	mov	r2, #(HW_POWER_MINPWR_ADDR & 0x000000FF)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0x0000FF00)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0x00FF0000)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0xFF000000)
+	ldr	r1, [r2]
+	orr	r1, r1, #(1<<9)
+	str	r1, [r2]
+	orr	r1, r1, #(1<<8)
+	str	r1, [r2]
+
+	@ enable RTC/RAM clocks
+	mov	r0, #(HW_RTC_PERSISTENT0 & 0x000000FF)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0 & 0x0000FF00)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0 & 0x00FF0000)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0 & 0xFF000000)
+	mov	r1, #((1<<4)|(1<<5)|1)
+	str	r1, [r0, #4]
+
+	@ put DRAM into self refresh
+	mov	r0, #(HW_DRAM_CTL08 & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL08 & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(1 << 8)
+	str	r1, [r0]
+	@ wait for it to actually happen
+	mov	r0, #(HW_EMI_STAT & 0x000000FF)
+	orr	r0, r0, #(HW_EMI_STAT & 0x0000FF00)
+	orr	r0, r0, #(HW_EMI_STAT & 0x00FF0000)
+	orr	r0, r0, #(HW_EMI_STAT & 0xFF000000)
+1:	ldr	r1, [r0]
+	teq	r1, #(1 << 1)
+	beq	1b
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	@ power off RAM
+	mov	r0, #(HW_DRAM_CTL06 & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL06 & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL06 & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL06 & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(1<<24)
+	str	r1, [r0]
+	nop
+	nop
+	nop
+	nop
+
+	@ do enter sleep
+	mov	r0, #(HW_POWER_RESET_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0xFF000000)
+	mov	r1, #0xFF000000
+	orr	r1, r1, #0x00FF0000
+	str	r1, [r0, #8]
+	mov	r1, #0x3E000000
+	orr	r1, r1, #0x00770000
+	str	r1, [r0, #4]
+	mov	r1, #2
+	str	r1, [r0, #8]
+	mov	r1, #1
+	str	r1, [r0, #4]
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	@ sleeping now...
+
+__restore_context:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c10, 4	@ Drain write buffer
+	mcr	p15, 0, r0, c8, c7, 0	@ Invalidate TLBs
+	mcr	p15, 0, r0, c7, c7, 0	@ Invalidate I & D cache
+	nop
+	nop
+
+	mov	r0, #0xd3
+	msr	cpsr, r0
+
+	bl	__create_temp_page_tables
+	mov	r3, r4
+
+	mov	r1, #PHYS_RAM_START
+	ldr	r1, [r1]
+	ldr	r2, [r1, #MMUDOMAIN_OFFS]
+	ldr	r4, [r1, #MMUCPACCESS_OFS]
+	ldr	r5, [r1, #MMUPID_OFFS]
+	ldr	r6, =__resume_after_mmu
+	ldr	r7, [r1, #MMUCTL_OFFS]
+	ldr	r8, [r1, #MMUTTB_OFFS]
+	add	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	mov	r0, #0
+@	mcr	p15, 0, r4, c15, c1, 0	@ cpaccess
+	mcr	p15, 0, r5, c13, c0, 0	@ pid
+	mcr	p15, 0, r2, c3, c0, 0	@ domain
+	mcr	p15, 0, r3, c2, c0, 0	@ ttb
+	b	1f
+	.align 5
+1:	mov	r0, r0
+	mcr     p15, 0, r7, c1, c0, 0	@ mmuctl
+	nop
+	mrc	p15, 0, r0, c3, c0, 0	@ read id
+	mov	r0, r0
+	mov	r0, r0
+	sub	pc, r6, r5, lsr #32
+	nop
+	nop
+	nop
+__resume_after_mmu:
+	mov	r0, #0
+	mcr	p15, 0, r0, c8, c7, 0	@ Invalidate TLBs
+	mcr	p15, 0, r0, c7, c7, 0	@ Invalidate I & D cache
+
+	mov	r0, r8
+	bl	cpu_arm926_switch_mm
+
+	mov	r0, #0xd1 @FIQ, Interrupts disabled
+	ldr	r2, [r1, #FIQ_SPSR_OFFS]
+	add	r3, r1, #FIQ_R8_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {r8-r12, sp, lr}
+
+	mov	r0, #0xd7 @ABT, Interrupts disabled
+	ldr	r2, [r1, #ABT_SPSR_OFFS]
+	add	r3, r1, #ABT_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xd2 @IRQ, Interrupts disabled
+	ldr	r2, [r1, #IRQ_SPSR_OFFS]
+	add	r3, r1, #IRQ_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xdb @UND, Interrupts disabled
+	ldr	r2, [r1, #UND_SPSR_OFFS]
+	add	r3, r1, #UND_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xdf @SYS, Interrupts disabled
+	add	r3, r1, #SYS_SP_OFFS
+	msr	cpsr, r0
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xd3 @SVC, interrupts disabled
+	ldr	r2, [r1, #SVC_SPSR_OFFS]
+	ldr	r3, [r1, #SVC_SP_OFFS]
+	msr	cpsr, r0
+	msr	spsr, r2
+	mov	sp, r3
+
+#if 0
+	@ select CPU bypass, will be cleared afterwards
+	ldr	r0, =HW_CLKCTRL_CLKSEQ_ADDR
+	ldr	r2, =HW_CLKCTRL_HBUS_ADDR
+	ldr	r4, =HW_CLKCTRL_CPU_ADDR
+	mov	r1, #(1<<7)
+	ldr	r3, [r2]
+	bic	r3, r3, #BM_CLKCTRL_HBUS_DIV
+	orr	r3, r3, #1
+	ldr	r5, [r4]
+	bic	r5, r5, #BM_CLKCTRL_CPU_DIV_CPU
+	orr	r5, r5, #1
+	str	r1, [r0, #4]
+	str	r3, [r2]
+	str	r5, [r4]
+#endif
+	@ restore regs and return
+	ldmfd   sp!, {r1 - r12, lr}
+	mov	pc, lr
+
+__mx23_flush_cache_addr2:
+	.word	arm926_flush_kern_cache_all
+__mx23_resume_point:
+	.word	__restore_context
+ENTRY(mx23_s2ram_alloc_sz)
+	.word	. - mx23_cpu_suspend
+
+__create_temp_page_tables:
+	ldr	r4, =(__temp_ttb - 0xC0000000 + PHYS_RAM_START)
+
+	/*
+	 * Clear the 16K level 1 swapper page table
+	 */
+	mov	r0, r4
+	mov	r3, #0
+	add	r6, r0, #0x4000
+1:	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	teq	r0, r6
+	bne	1b
+
+	/*
+	 * Create identity mapping for the area close to where we are to
+	 * cater for the MMU enable.
+	 */
+	mov	r6, pc, lsr #20			@ kind of where we are
+	ldr	r7, =\
+	(PMD_TYPE_SECT | PMD_SECT_BUFFERABLE | PMD_SECT_CACHEABLE\
+	| PMD_BIT4 | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ)
+
+	orr	r3, r7, r6, lsl #20		@ flags + kernel base
+	str	r3, [r4, r6, lsl #2]		@ identity mapping
+
+	mov	r6, r6, lsl #20
+	add	r6, r6, #(0xC0000000-PHYS_RAM_START)
+	str	r3, [r4, r6, lsr #18]
+
+	mov	pc, lr
+	.ltorg
+
+	.section ".sdata", "a"
+	.align 14
+__temp_ttb:
+	.space 0x8000
diff --git a/arch/arm/mach-mx23/sleep.h b/arch/arm/mach-mx23/sleep.h
new file mode 100644
index 0000000..54695bc
--- /dev/null
+++ b/arch/arm/mach-mx23/sleep.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef __PM_H__
+#define __PM_H__
+
+#include "regs-clkctrl.h"
+
+#define MMUTTB1_MASK		0x00003FE0
+#define MMUTTBC_MASK		0xFFFFFFFC
+
+#define LINK_OFFS	0x08
+#define MMUCTL_OFFS	0x0C
+#define MMUAUXCTL_OFFS	0x10
+#define MMUCPACCESS_OFS	0x14
+#define MMUTTB_OFFS	0x18
+#define MMUPID_OFFS	0x1C
+#define MMUDOMAIN_OFFS	0x20
+#define SVC_R8_OFFS	0x2C
+#define SVC_SP_OFFS	0x40
+#define SVC_SPSR_OFFS	0x44
+#define FIQ_SPSR_OFFS	0x48
+#define FIQ_R8_OFFS	0x4C
+#define FIQ_SP_OFFS	0x60
+#define ABT_R8_OFFS	0x68
+#define ABT_SPSR_OFFS	0x7C
+#define ABT_SP_OFFS	0x80
+#define IRQ_R8_OFFS	0x88
+#define IRQ_SPSR_OFFS	0x9C
+#define IRQ_SP_OFFS	0xA0
+#define UND_SPSR_OFFS	0xA8
+#define UND_SP_OFFS	0xAC
+#define SYS_SPSR_OFFS	0xB4
+#define SYS_SP_OFFS	0xB8
+
+#ifndef __ASSEMBLER__
+#define SLEEP_DATA_FINGERPRINT 0xdeadbeef
+struct sleep_data {
+	u32		fingerprint;
+	u32		wake_addr;
+	u32		link_addr;
+	u32		mmuctl;
+	u32		mmuauxctl;
+	u32		mmucpaccess;
+	u32		mmuttb;
+	u32		mmupid;
+	u32		mmudomain;
+	u32		svc_r6;
+	u32		svc_r7;
+	u32		svc_r8;
+	u32		svc_r9;
+	u32		svc_r10;
+	u32		svc_r11;
+	u32		svc_r12;
+	u32		svc_sp;
+	u32		svc_spsr;
+	u32		fiq_spsr;
+	u32		fiq_r8;
+	u32		fiq_r9;
+	u32		fiq_r10;
+	u32		fiq_r11;
+	u32		fiq_r12;
+	u32		fiq_sp;
+	u32		fiq_lr;
+	u32		abt_r8;
+	u32		abt_r9;
+	u32		abt_r10;
+	u32		abt_r11;
+	u32		abt_r12;
+	u32		abt_spsr;
+	u32		abt_sp;
+	u32		abt_lr;
+	u32		irq_r8;
+	u32		irq_r9;
+	u32		irq_r10;
+	u32		irq_r11;
+	u32		irq_r12;
+	u32		irq_spsr;
+	u32		irq_sp;
+	u32		irq_lr;
+	u32		und_spsr;
+	u32		und_sp;
+	u32		und_lr;
+	u32		sys_spsr;
+	u32		sys_sp;
+	u32		sys_lr;
+	u32		pinmux[0x100];
+	u32		icoll_ctrl;
+	union {
+		u32		prio[0x10];
+		u32		intr[0x80];
+	} icoll;
+	u32		clks[16];
+	u32		old_c00;
+	u32		old_c04;
+};
+
+extern int mx23_s2ram_alloc_sz;
+void mx23_cpu_suspend(void);
+extern int mx23_standby_alloc_sz;
+void mx23_cpu_standby(void);
+void mxs_nomatch_suspend_timer(void);
+void mxs_nomatch_resume_timer(void);
+
+void *iram_alloc(unsigned int size, unsigned long *dma_addr);
+void iram_free(unsigned long addr, unsigned int size);
+#endif /* __ASSEMBLER__ */
+#endif /* __PM_H__ */
diff --git a/arch/arm/mach-mx23/usb.h b/arch/arm/mach-mx23/usb.h
new file mode 100644
index 0000000..689603d
--- /dev/null
+++ b/arch/arm/mach-mx23/usb.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+extern void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+					 bool enable);
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx23/usb_dr.c b/arch/arm/mach-mx23/usb_dr.c
new file mode 100644
index 0000000..ed4bde7
--- /dev/null
+++ b/arch/arm/mach-mx23/usb_dr.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/irqs.h>
+#include <mach/mx23.h>
+#include "usb.h"
+#include "mx23_pins.h"
+
+#define USB_POWER_ENABLE MXS_PIN_TO_GPIO(PINID_GPMI_CE2N)
+#define USB_ID_PIN	 MXS_PIN_TO_GPIO(PINID_ROTARYA)
+
+static void usb_host_phy_resume(struct fsl_usb2_platform_data *plat)
+{
+	fsl_platform_set_usb_phy_dis(plat, 0);
+}
+
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_clk0");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	return usbotg_init(pdev);
+}
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,	/* 500 mA max power */
+	.platform_resume = usb_host_phy_resume,
+	.transceiver       = "utmi",
+	.phy_regs          = USBPHY_PHYS_ADDR,
+	.id_gpio	   = USB_ID_PIN,
+};
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start	= (u32)USBCTRL_PHYS_ADDR,
+		.end	= (u32)(USBCTRL_PHYS_ADDR + 0x1ff),
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= IRQ_USB_CTRL,
+		.flags	= IORESOURCE_IRQ,
+	},
+
+	[2] = {
+		.start = IRQ_USB_WAKEUP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{}
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev  = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	PDATA->change_ahb_burst = 1;
+	PDATA->ahb_burst_mode = 0;
+	return 0;
+}
+
+/* utmi_init will be call by otg, host and perperial tree time*/
+void fsl_phy_usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+}
+
+void fsl_phy_usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+void fsl_phy_set_power(struct fsl_xcvr_ops *this,
+		      struct fsl_usb2_platform_data *pdata, int on)
+{
+	int ret;
+	ret = gpio_request(USB_POWER_ENABLE, "usb_power");
+	if (ret) {
+		pr_err("fail request usb power control pin\n");
+		return;
+	}
+	gpio_direction_output(USB_POWER_ENABLE, on);
+	gpio_set_value(USB_POWER_ENABLE, on);
+	gpio_free(USB_POWER_ENABLE);
+}
+
+#ifdef CONFIG_MXS_VBUS_CURRENT_DRAW
+	fs_initcall(usb_dr_init);
+#else
+	module_init(usb_dr_init);
+#endif
diff --git a/arch/arm/mach-mx28/Kconfig b/arch/arm/mach-mx28/Kconfig
new file mode 100644
index 0000000..f099ca3
--- /dev/null
+++ b/arch/arm/mach-mx28/Kconfig
@@ -0,0 +1,20 @@
+choice
+	prompt "Select i.MXS board type"
+
+config MACH_MX28EVK
+	bool "Freescale MX28 EVK board"
+	depends on ARCH_MX28
+	select USB_ARCH_HAS_EHCI
+
+endchoice
+
+config VECTORS_PHY_ADDR
+	int "vectors address"
+	default 0
+	help
+	  This config set vectors table is located which physical address
+
+config MXS_TIMER_WITH_MACH
+	bool "System Timer support Compare Match interrupt"
+	default y
+
diff --git a/arch/arm/mach-mx28/Makefile b/arch/arm/mach-mx28/Makefile
new file mode 100644
index 0000000..23869ad
--- /dev/null
+++ b/arch/arm/mach-mx28/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the linux kernel.
+#
+obj-y += pinctrl.o clock.o device.o serial.o power.o bus_freq.o pm.o sleep.o
+
+# Board select
+obj-$(CONFIG_MACH_MX28EVK) += mx28evk.o mx28evk_pins.o
+obj-$(CONFIG_GENERIC_GPIO) += gpio.o
+obj-$(CONFIG_MXS_RAM_FREQ_SCALING) +=emi.o emi_settings.o
+
+# USB support
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y   += usb_dr.o
+endif
+obj-$(CONFIG_USB_EHCI_ARC_H1)   += usb_h1.o
diff --git a/arch/arm/mach-mx28/Makefile.boot b/arch/arm/mach-mx28/Makefile.boot
new file mode 100644
index 0000000..1568ad4
--- /dev/null
+++ b/arch/arm/mach-mx28/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x40008000
+params_phys-y	:= 0x40000100
+initrd_phys-y	:= 0x40800000
diff --git a/arch/arm/mach-mx28/bus_freq.c b/arch/arm/mach-mx28/bus_freq.c
new file mode 100644
index 0000000..1ea76cb
--- /dev/null
+++ b/arch/arm/mach-mx28/bus_freq.c
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module.
+ *
+ * @ingroup PM
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include <mach/bus_freq.h>
+
+#include "regs-clkctrl.h"
+#include "regs-digctl.h"
+
+#define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define DIGCTRL_BASE_ADDR IO_ADDRESS(DIGCTL_PHYS_ADDR)
+#define BF(value, field) (((value) << BP_##field) & BM_##field)
+
+struct profile profiles[] = {
+	{ 454736, 151580, 196360, 0, 1550000,
+	1450000, 355000, 3300000, 1750000, 24000, 0 },
+	{ 392727, 130910, 160000, 0, 1475000,
+	1375000, 225000, 3300000, 1750000, 24000, 0 },
+	{ 360000, 120000, 130910, 0, 1375000,
+	1275000, 200000, 3300000, 1750000, 24000, 0 },
+	{ 261818, 130910, 130910, 0, 1275000,
+	1175000, 173000, 3300000, 1750000, 24000, 0 },
+	{  64000,  64000, 130910, 3, 1050000,
+	975000, 150000, 3300000, 1750000, 24000, 0 },
+	{  0,  0,  0, 0, 0,
+	0, 0, 0, 0, 0, 0 },
+};
+
+static struct device *busfreq_dev;
+static struct clk *usb_clk0;
+static struct clk *usb_clk1;
+static struct clk *lcdif_clk;
+u32 clkseq_setting;
+
+int low_freq_used(void)
+{
+	if ((clk_get_usecount(usb_clk0) == 0)
+	    && (clk_get_usecount(usb_clk1) == 0)
+	    && (clk_get_usecount(lcdif_clk) == 0))
+		return 1;
+	else
+		return 0;
+}
+
+int is_hclk_autoslow_ok(void)
+{
+	if ((clk_get_usecount(usb_clk0) == 0)
+	    && (clk_get_usecount(usb_clk1) == 0))
+		return 1;
+	else
+		return 0;
+}
+
+int timing_ctrl_rams(int ss)
+{
+	__raw_writel(BF(ss, DIGCTL_ARMCACHE_VALID_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_DRTY_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_CACHE_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_DTAG_SS) |
+				      BF(ss, DIGCTL_ARMCACHE_ITAG_SS),
+				      DIGCTRL_BASE_ADDR + HW_DIGCTL_ARMCACHE);
+	return 0;
+}
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	busfreq_dev = &pdev->dev;
+
+	usb_clk0 = clk_get(NULL, "usb_clk0");
+	if (IS_ERR(usb_clk0)) {
+		ret = PTR_ERR(usb_clk0);
+		goto out_usb0;
+	}
+
+	usb_clk1 = clk_get(NULL, "usb_clk1");
+	if (IS_ERR(usb_clk1)) {
+		ret = PTR_ERR(usb_clk1);
+		goto out_usb1;
+	}
+
+	lcdif_clk = clk_get(NULL, "dis_lcdif");
+	if (IS_ERR(lcdif_clk)) {
+		ret = PTR_ERR(lcdif_clk);
+		goto out_lcd;
+	}
+	return 0;
+
+out_lcd:
+	clk_put(usb_clk1);
+out_usb1:
+	clk_put(usb_clk0);
+out_usb0:
+	return ret;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		},
+	.probe = busfreq_probe,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx28/clock.c b/arch/arm/mach-mx28/clock.c
new file mode 100644
index 0000000..ae6f49d
--- /dev/null
+++ b/arch/arm/mach-mx28/clock.c
@@ -0,0 +1,1774 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/iram_alloc.h>
+#include <linux/platform_device.h>
+
+#include <mach/clock.h>
+
+#include "regs-clkctrl.h"
+#include "regs-digctl.h"
+#include "emi_settings.h"
+
+#define HW_SAIF_CTRL    (0x00000000)
+#define HW_SAIF_STAT    (0x00000010)
+#define SAIF0_CTRL (IO_ADDRESS(SAIF0_PHYS_ADDR) + HW_SAIF_CTRL)
+#define SAIF0_STAT (IO_ADDRESS(SAIF0_PHYS_ADDR) + HW_SAIF_STAT)
+#define SAIF1_CTRL (IO_ADDRESS(SAIF1_PHYS_ADDR) + HW_SAIF_CTRL)
+#define SAIF1_STAT (IO_ADDRESS(SAIF1_PHYS_ADDR) + HW_SAIF_STAT)
+#define BM_SAIF_CTRL_RUN        0x00000001
+#define BM_SAIF_STAT_BUSY       0x00000001
+#define CLKCTRL_BASE_ADDR IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define DIGCTRL_BASE_ADDR IO_ADDRESS(DIGCTL_PHYS_ADDR)
+
+/* external clock input */
+static struct clk xtal_clk[];
+static unsigned long xtal_clk_rate[3] = { 24000000, 24000000, 32000 };
+
+static unsigned long enet_mii_phy_rate;
+
+static inline int clk_is_busy(struct clk *clk)
+{
+	return __raw_readl(clk->busy_reg) & (1 << clk->busy_bits);
+}
+
+static bool mx28_enable_h_autoslow(bool enable)
+{
+	bool currently_enabled;
+
+	if (__raw_readl(CLKCTRL_BASE_ADDR+HW_CLKCTRL_HBUS) &
+		BM_CLKCTRL_HBUS_ASM_ENABLE)
+		currently_enabled = true;
+	else
+		currently_enabled = false;
+
+	if (enable)
+		__raw_writel(BM_CLKCTRL_HBUS_ASM_ENABLE,
+			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_SET);
+	else
+		__raw_writel(BM_CLKCTRL_HBUS_ASM_ENABLE,
+			CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS_CLR);
+	return currently_enabled;
+}
+
+
+static void mx28_set_hbus_autoslow_flags(u16 mask)
+{
+	u32 reg;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	reg &= 0xFFFF;
+	reg |= mask << 16;
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+}
+
+static int mx28_raw_enable(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk->enable_reg) {
+		reg = __raw_readl(clk->enable_reg);
+		reg &= ~clk->enable_bits;
+		__raw_writel(reg, clk->enable_reg);
+	}
+	return 0;
+}
+
+static void mx28_raw_disable(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk->enable_reg) {
+		reg = __raw_readl(clk->enable_reg);
+		reg |= clk->enable_bits;
+		__raw_writel(reg, clk->enable_reg);
+	}
+}
+
+static unsigned int
+mx28_get_frac_div(unsigned long root_rate, unsigned long rate, unsigned mask)
+{
+	unsigned long mult_rate;
+	unsigned int div;
+	mult_rate = rate * (mask + 1);
+	div = mult_rate / root_rate;
+	if ((mult_rate % root_rate) && (div < mask))
+		div--;
+	return div;
+}
+
+static unsigned long xtal_get_rate(struct clk *clk)
+{
+	int id = clk - xtal_clk;
+	return xtal_clk_rate[id];
+}
+
+static struct clk xtal_clk[] = {
+	{
+	 .flags = RATE_FIXED,
+	 .get_rate = xtal_get_rate,
+	 },
+	{
+	 .flags = RATE_FIXED,
+	 .get_rate = xtal_get_rate,
+	 },
+	{
+	 .flags = RATE_FIXED,
+	 .get_rate = xtal_get_rate,
+	 },
+};
+
+static struct clk ref_xtal_clk = {
+	.parent = &xtal_clk[0],
+};
+
+static unsigned long pll_get_rate(struct clk *clk);
+static int pll_enable(struct clk *clk);
+static void pll_disable(struct clk *clk);
+static int pll_set_rate(struct clk *clk, unsigned long rate);
+static struct clk pll_clk[] = {
+	{
+	 .parent = &ref_xtal_clk,
+	 .flags = RATE_FIXED,
+	 .get_rate = pll_get_rate,
+	 .set_rate = pll_set_rate,
+	 .enable = pll_enable,
+	 .disable = pll_disable,
+	 },
+	{
+	 .parent = &ref_xtal_clk,
+	 .flags = RATE_FIXED,
+	 .get_rate = pll_get_rate,
+	 .set_rate = pll_set_rate,
+	 .enable = pll_enable,
+	 .disable = pll_disable,
+	 },
+	{
+	 .parent = &ref_xtal_clk,
+	 .flags = RATE_FIXED,
+	 .get_rate = pll_get_rate,
+	 .set_rate = pll_set_rate,
+	 .enable = pll_enable,
+	 .disable = pll_disable,
+	 }
+};
+
+static unsigned long pll_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk == (pll_clk + 2))
+		return 50000000;
+	if (clk == pll_clk) {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL1);
+		reg = (reg & BM_CLKCTRL_PLL0CTRL0_DIV_SEL) >>
+			BP_CLKCTRL_PLL0CTRL0_DIV_SEL;
+	} else {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL1);
+		reg = (reg & BM_CLKCTRL_PLL1CTRL0_DIV_SEL) >>
+			BP_CLKCTRL_PLL1CTRL0_DIV_SEL;
+	}
+	switch (reg) {
+	case 0:
+		return 480000000;
+	case 1:
+		return 384000000;
+	case 2:
+		return 288000000;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div, reg;
+
+	if (clk == pll_clk + 2)
+		return -EINVAL;
+
+	switch (rate) {
+	case 480000000:
+		div = 0;
+		break;
+	case 384000000:
+		div = 1;
+		break;
+	case 288000000:
+		div = 2;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (clk == pll_clk) {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL1);
+		reg &= ~BM_CLKCTRL_PLL0CTRL0_DIV_SEL;
+		reg |= BF_CLKCTRL_PLL0CTRL0_DIV_SEL(div);
+		__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL1);
+	} else {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL1);
+		reg &= ~BM_CLKCTRL_PLL1CTRL0_DIV_SEL;
+		reg |= BF_CLKCTRL_PLL1CTRL0_DIV_SEL(div);
+		__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL1);
+	}
+	return 0;
+}
+
+static int pll_enable(struct clk *clk)
+{
+	int timeout = 100;
+	unsigned long reg;
+	switch (clk - pll_clk) {
+	case 0:
+		__raw_writel(BM_CLKCTRL_PLL0CTRL0_POWER |
+			     BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL0_SET);
+		do {
+			udelay(10);
+			reg = __raw_readl(CLKCTRL_BASE_ADDR +
+					  HW_CLKCTRL_PLL0CTRL1);
+			timeout--;
+		} while ((timeout > 0) && !(reg & BM_CLKCTRL_PLL0CTRL1_LOCK));
+		if (timeout <= 0)
+			return -EFAULT;
+		return 0;
+	case 1:
+		__raw_writel(BM_CLKCTRL_PLL1CTRL0_POWER |
+			     BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL0_SET);
+		do {
+			udelay(10);
+			reg = __raw_readl(CLKCTRL_BASE_ADDR +
+					  HW_CLKCTRL_PLL1CTRL1);
+			timeout--;
+		} while ((timeout > 0) && !(reg & BM_CLKCTRL_PLL1CTRL1_LOCK));
+		if (timeout <= 0)
+			return -EFAULT;
+		return 0;
+	case 2:
+		__raw_writel(BM_CLKCTRL_PLL2CTRL0_POWER,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL2CTRL0_SET);
+		udelay(10);
+		__raw_writel(BM_CLKCTRL_PLL2CTRL0_CLKGATE,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL2CTRL0_CLR);
+		break;
+	}
+	return -ENODEV;
+}
+
+static void pll_disable(struct clk *clk)
+{
+	switch (clk - pll_clk) {
+	case 0:
+		__raw_writel(BM_CLKCTRL_PLL0CTRL0_POWER |
+			     BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL0CTRL0_CLR);
+		return;
+	case 1:
+		__raw_writel(BM_CLKCTRL_PLL1CTRL0_POWER |
+			     BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL1CTRL0_CLR);
+		return;
+	case 2:
+		__raw_writel(BM_CLKCTRL_PLL2CTRL0_CLKGATE,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL2CTRL0_SET);
+		__raw_writel(BM_CLKCTRL_PLL2CTRL0_POWER,
+			     CLKCTRL_BASE_ADDR + HW_CLKCTRL_PLL2CTRL0_CLR);
+		break;
+	}
+	return;
+}
+
+static inline unsigned long
+ref_clk_get_rate(unsigned long base, unsigned int div)
+{
+	unsigned long rate = base / 1000;
+	return 1000 * ((rate * 18) / div);
+}
+
+static unsigned long ref_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long base = clk->parent->get_rate(clk->parent);
+	unsigned long div = (base  * 18) / rate;
+	return (base / div) * 18;
+}
+
+static int ref_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long base = clk->parent->get_rate(clk->parent);
+	unsigned long div = ((base/1000)  * 18) / (rate/1000);
+	if (rate != ((base / div) * 18))
+		return -EINVAL;
+	if (clk->scale_reg == 0)
+		return -EINVAL;
+	base = __raw_readl(clk->scale_reg);
+	base &= ~(0x3F << clk->scale_bits);
+	base |= (div << clk->scale_bits);
+	__raw_writel(base, clk->scale_reg);
+	return 0;
+}
+
+static unsigned long ref_cpu_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0) &
+	    BM_CLKCTRL_FRAC0_CPUFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+
+static struct clk ref_cpu_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = ref_cpu_get_rate,
+	.round_rate = ref_clk_round_rate,
+	.set_rate = ref_clk_set_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	.enable_bits = BM_CLKCTRL_FRAC0_CLKGATECPU,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	.scale_bits = BP_CLKCTRL_FRAC0_CPUFRAC,
+};
+
+static unsigned long ref_emi_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0) &
+	    BM_CLKCTRL_FRAC0_EMIFRAC;
+	reg >>= BP_CLKCTRL_FRAC0_EMIFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_emi_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = ref_emi_get_rate,
+	.set_rate = ref_clk_set_rate,
+	.round_rate = ref_clk_round_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	.enable_bits = BM_CLKCTRL_FRAC0_CLKGATEEMI,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	.scale_bits = BP_CLKCTRL_FRAC0_EMIFRAC,
+};
+
+static unsigned long ref_io_get_rate(struct clk *clk);
+static struct clk ref_io_clk[] = {
+	{
+	 .parent = &pll_clk[0],
+	 .get_rate = ref_io_get_rate,
+	 .set_rate = ref_clk_set_rate,
+	 .round_rate = ref_clk_round_rate,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	 .enable_bits = BM_CLKCTRL_FRAC0_CLKGATEIO0,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	 .scale_bits = BP_CLKCTRL_FRAC0_IO0FRAC,
+	 },
+	{
+	 .parent = &pll_clk[0],
+	 .get_rate = ref_io_get_rate,
+	 .set_rate = ref_clk_set_rate,
+	 .round_rate = ref_clk_round_rate,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	 .enable_bits = BM_CLKCTRL_FRAC0_CLKGATEIO1,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	 .scale_bits = BP_CLKCTRL_FRAC0_IO1FRAC,
+	 },
+};
+
+static unsigned long ref_io_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	if (clk == ref_io_clk) {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0) &
+		    BM_CLKCTRL_FRAC0_IO0FRAC;
+		reg >>= BP_CLKCTRL_FRAC0_IO0FRAC;
+	} else {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0) &
+		    BM_CLKCTRL_FRAC0_IO1FRAC;
+		reg >>= BP_CLKCTRL_FRAC0_IO1FRAC;
+	}
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static unsigned long ref_pix_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1) &
+	    BM_CLKCTRL_FRAC1_PIXFRAC;
+	reg >>= BP_CLKCTRL_FRAC1_PIXFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_pix_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = ref_pix_get_rate,
+	.set_rate = ref_clk_set_rate,
+	.round_rate = ref_clk_round_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.enable_bits = BM_CLKCTRL_FRAC1_CLKGATEPIX,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.scale_bits = BP_CLKCTRL_FRAC1_PIXFRAC,
+};
+
+static unsigned long ref_hsadc_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1) &
+	    BM_CLKCTRL_FRAC1_HSADCFRAC;
+	reg >>= BP_CLKCTRL_FRAC1_HSADCFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_hsadc_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = ref_hsadc_get_rate,
+	.set_rate = ref_clk_set_rate,
+	.round_rate = ref_clk_round_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.enable_bits = BM_CLKCTRL_FRAC1_CLKGATEHSADC,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.scale_bits = BP_CLKCTRL_FRAC1_HSADCFRAC,
+};
+
+static unsigned long ref_gpmi_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1) &
+	    BM_CLKCTRL_FRAC1_GPMIFRAC;
+	reg >>= BP_CLKCTRL_FRAC1_GPMIFRAC;
+	return ref_clk_get_rate(clk->parent->get_rate(clk->parent), reg);
+}
+
+static struct clk ref_gpmi_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = ref_gpmi_get_rate,
+	.set_rate = ref_clk_set_rate,
+	.round_rate = ref_clk_round_rate,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.enable_bits = BM_CLKCTRL_FRAC1_CLKGATEGPMI,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC1,
+	.scale_bits = BP_CLKCTRL_FRAC1_GPMIFRAC,
+};
+
+static unsigned long cpu_get_rate(struct clk *clk)
+{
+	unsigned long rate, div;
+	rate = (clk->parent->get_rate(clk->parent));
+	div = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU) &
+			  BM_CLKCTRL_CPU_DIV_CPU;
+	rate = rate/div;
+			return rate;
+		}
+
+static unsigned long cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long frac_rate, root_rate = clk->parent->get_rate(clk->parent);
+	unsigned int div = root_rate / rate;
+	if (div == 0)
+		return root_rate;
+	if (clk->parent == &ref_cpu_clk) {
+		if (div > 0x3F)
+			div = 0x3F;
+		return root_rate / div;
+	}
+
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	return rate;
+}
+
+static struct clk  h_clk;
+static int cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate =
+			clk->parent->parent->get_rate(clk->parent->parent);
+	int i;
+	u32 clkctrl_cpu = 1;
+	u32 c = clkctrl_cpu;
+	u32 clkctrl_frac = 1;
+	u32 val;
+	u32 reg_val, hclk_reg;
+
+	if (rate < 24000)
+		return -EINVAL;
+	else if (rate == 24000) {
+		/* switch to the 24M source */
+		clk_set_parent(clk, &ref_xtal_clk);
+	} else {
+		for ( ; c < 0x40; c++) {
+			u32 f = ((root_rate/1000)*18/c + (rate/1000)/2) /
+				(rate/1000);
+			int s1, s2;
+
+			if (f < 18 || f > 35)
+				continue;
+			s1 = (root_rate/1000)*18/clkctrl_frac/clkctrl_cpu -
+			     (rate/1000);
+			s2 = (root_rate/1000)*18/c/f - (rate/1000);
+			if (abs(s1) > abs(s2)) {
+				clkctrl_cpu = c;
+				clkctrl_frac = f;
+			}
+			if (s2 == 0)
+				break;
+		};
+		if (c == 0x40) {
+			int  d = (root_rate/1000)*18/clkctrl_frac/clkctrl_cpu -
+				(rate/1000);
+			if ((abs(d) > 100) || (clkctrl_frac < 18) ||
+				(clkctrl_frac > 35))
+				return -EINVAL;
+		}
+
+		/* Set safe hbus clock divider. A divider of 3 ensure that
+		 * the Vddd voltage required for the cpuclk is sufficiently
+		 * high for the hbus clock.
+		 */
+		hclk_reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+		if ((hclk_reg & BP_CLKCTRL_HBUS_DIV) != 3) {
+			hclk_reg &= ~(BM_CLKCTRL_HBUS_DIV);
+			hclk_reg |= BF_CLKCTRL_HBUS_DIV(3);
+
+			/* change hclk divider to safe value for any ref_cpu
+			 * value.
+			 */
+			__raw_writel(hclk_reg, CLKCTRL_BASE_ADDR +
+				     HW_CLKCTRL_HBUS);
+		}
+
+		for (i = 10000; i; i--)
+			if (!clk_is_busy(&h_clk))
+				break;
+		if (!i) {
+			printk(KERN_ERR "couldn't set up HCLK divisor\n");
+			return -ETIMEDOUT;
+		}
+
+		/* Set Frac div */
+		val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);
+		val &= ~(BM_CLKCTRL_FRAC0_CPUFRAC << BP_CLKCTRL_FRAC0_CPUFRAC);
+		val |= clkctrl_frac;
+		__raw_writel(val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0);
+		/* Do not gate */
+		__raw_writel(BM_CLKCTRL_FRAC0_CLKGATECPU, CLKCTRL_BASE_ADDR +
+			     HW_CLKCTRL_FRAC0_CLR);
+
+		/* write clkctrl_cpu */
+		reg_val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
+		reg_val &= ~0x3F;
+		reg_val |= clkctrl_cpu;
+
+		__raw_writel(reg_val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CPU);
+
+		for (i = 10000; i; i--)
+			if (!clk_is_busy(clk))
+				break;
+		if (!i) {
+			printk(KERN_ERR "couldn't set up CPU divisor\n");
+			return -ETIMEDOUT;
+		}
+	}
+	return 0;
+}
+
+static int cpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+
+	if (clk->bypass_reg) {
+		if (parent == clk->parent)
+			return 0;
+		if (parent == &ref_xtal_clk) {
+			__raw_writel(1 << clk->bypass_bits,
+				clk->bypass_reg + SET_REGISTER);
+			ret = 0;
+		}
+		if (ret && (parent == &ref_cpu_clk)) {
+			__raw_writel(1 << clk->bypass_bits,
+				clk->bypass_reg + CLR_REGISTER);
+			ret = 0;
+		}
+		if (!ret)
+			clk->parent = parent;
+	}
+	return ret;
+}
+
+static struct clk cpu_clk = {
+	.parent = &ref_cpu_clk,
+	.get_rate = cpu_get_rate,
+	.round_rate = cpu_round_rate,
+	.set_rate = cpu_set_rate,
+	.set_parent = cpu_set_parent,
+	.bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits = 18,
+	.busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.busy_bits = 28,
+};
+
+static unsigned long uart_get_rate(struct clk *clk)
+{
+	unsigned int div;
+	div = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL) &
+	    BM_CLKCTRL_XTAL_DIV_UART;
+	return clk->parent->get_rate(clk->parent) / div;
+}
+
+static struct clk uart_clk = {
+	.parent = &ref_xtal_clk,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_UART_CLK_GATE,
+	.get_rate = uart_get_rate,
+};
+
+static struct clk pwm_clk = {
+	.parent = &ref_xtal_clk,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_PWM_CLK24M_GATE,
+};
+
+static unsigned long clk_32k_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 750;
+}
+
+static struct clk clk_32k = {
+	.parent = &ref_xtal_clk,
+	.flags = RATE_FIXED,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XTAL,
+	.enable_bits = BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE,
+	.get_rate = clk_32k_get_rate,
+};
+
+static unsigned long lradc_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 16;
+}
+
+static struct clk lradc_clk = {
+	.parent = &clk_32k,
+	.flags = RATE_FIXED,
+	.get_rate = lradc_get_rate,
+};
+
+static unsigned long x_get_rate(struct clk *clk)
+{
+	unsigned long reg, div;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
+	div = reg & BM_CLKCTRL_XBUS_DIV;
+	if (!(reg & BM_CLKCTRL_XBUS_DIV_FRAC_EN))
+		return clk->parent->get_rate(clk->parent) / div;
+	return (clk->parent->get_rate(clk->parent) / 0x400) * div;
+}
+
+static unsigned long x_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int root_rate, frac_rate;
+	unsigned int div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	return rate;
+}
+
+static int x_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate;
+	unsigned int reg, div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return -EINVAL;
+
+	if (root_rate % rate) {
+		div = mx28_get_frac_div(root_rate / 1000, rate / 1000, 0x3FF);
+		if (((root_rate / 0x400) * div) > rate)
+			return -EINVAL;
+	}
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
+	reg &= ~(BM_CLKCTRL_XBUS_DIV | BM_CLKCTRL_XBUS_DIV_FRAC_EN);
+	if (root_rate % rate)
+		reg |= BM_CLKCTRL_XBUS_DIV_FRAC_EN;
+	reg |= BF_CLKCTRL_XBUS_DIV(div);
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS);
+	return 0;
+}
+
+static struct clk x_clk = {
+	.parent = &ref_xtal_clk,
+	.get_rate = x_get_rate,
+	.set_rate = x_set_rate,
+	.round_rate = x_round_rate,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_XBUS,
+	.scale_bits = BM_CLKCTRL_XBUS_BUSY,
+};
+
+static struct clk ana_clk = {
+	.parent = &ref_xtal_clk,
+};
+
+static unsigned long rtc_get_rate(struct clk *clk)
+{
+	if (clk->parent == &xtal_clk[2])
+		return clk->parent->get_rate(clk->parent);
+	return clk->parent->get_rate(clk->parent) / 768;
+}
+
+static struct clk rtc_clk = {
+	.parent = &ref_xtal_clk,
+	.get_rate = rtc_get_rate,
+};
+
+static struct clk flexcan_clk[] = {
+	{
+	 .parent = &ref_xtal_clk,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FLEXCAN,
+	 .enable_bits = BM_CLKCTRL_FLEXCAN_STOP_CAN0,
+	 },
+	{
+	 .parent = &ref_xtal_clk,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_FLEXCAN,
+	 .enable_bits = BM_CLKCTRL_FLEXCAN_STOP_CAN1,
+	 },
+};
+
+static unsigned long h_get_rate(struct clk *clk)
+{
+	unsigned long reg, div;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	div = reg & BM_CLKCTRL_HBUS_DIV;
+		return clk->parent->get_rate(clk->parent) / div;
+}
+
+static unsigned long h_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int root_rate, frac_rate;
+	unsigned int div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x20))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	else
+		return root_rate / (div + 1);
+}
+
+static int h_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate;
+	unsigned long round_rate;
+	unsigned int reg, div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	round_rate =  h_round_rate(clk, rate);
+	div = root_rate / round_rate;
+	if ((div == 0) || (div >= 0x20))
+		return -EINVAL;
+
+	if (root_rate % round_rate)
+			return -EINVAL;
+
+	if ((root_rate < rate) && (root_rate == 64000000))
+		div = 3;
+
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+	reg &= ~(BM_CLKCTRL_HBUS_DIV_FRAC_EN | BM_CLKCTRL_HBUS_DIV);
+	reg |= BF_CLKCTRL_HBUS_DIV(div);
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS);
+
+	if (clk->busy_reg) {
+		int i;
+		for (i = 10000; i; i--)
+			if (!clk_is_busy(clk))
+				break;
+		if (!i) {
+			printk(KERN_ERR "couldn't set up AHB divisor\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static struct clk h_clk = {
+	.parent = &cpu_clk,
+	.get_rate = h_get_rate,
+	.set_rate = h_set_rate,
+	.round_rate = h_round_rate,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_HBUS,
+	.busy_bits	= 31,
+};
+
+static struct clk ocrom_clk = {
+	.parent = &h_clk,
+};
+
+static unsigned long emi_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI);
+	if (clk->parent == &ref_emi_clk)
+		reg = (reg & BM_CLKCTRL_EMI_DIV_EMI);
+	else
+		reg = (reg & BM_CLKCTRL_EMI_DIV_XTAL) >>
+		    BP_CLKCTRL_EMI_DIV_XTAL;
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static int emi_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+	if (clk->bypass_reg) {
+		if (parent == clk->parent)
+			return 0;
+		if (parent == &ref_xtal_clk) {
+			__raw_writel(1 << clk->bypass_bits,
+				clk->bypass_reg + SET_REGISTER);
+			ret = 0;
+		}
+		if (ret && (parent == &ref_emi_clk)) {
+			__raw_writel(0 << clk->bypass_bits,
+				clk->bypass_reg + CLR_REGISTER);
+			ret = 0;
+		}
+		if (!ret)
+			clk->parent = parent;
+	}
+	return ret;
+}
+
+static unsigned long emi_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate = clk->parent->get_rate(clk->parent);
+	unsigned int div = root_rate / rate;
+	if (div == 0)
+		return root_rate;
+	if (clk->parent == &ref_emi_clk) {
+		if (div > 0x3F)
+			div = 0x3F;
+		return root_rate / div;
+	}
+	if (div > 0xF)
+		div = 0xF;
+	return root_rate / div;
+}
+
+static int emi_set_rate(struct clk *clk, unsigned long rate)
+{
+	int i;
+	struct mxs_emi_scaling_data emi;
+	unsigned long iram_phy;
+	void (*f) (struct mxs_emi_scaling_data *, unsigned int *);
+	f = iram_alloc((unsigned int)mxs_ram_freq_scale_end -
+		(unsigned int)mxs_ram_freq_scale, &iram_phy);
+	if (NULL == f) {
+		pr_err("%s Not enough iram\n", __func__);
+		return -ENOMEM;
+	}
+	memcpy(f, mxs_ram_freq_scale,
+	       (unsigned int)mxs_ram_freq_scale_end -
+	       (unsigned int)mxs_ram_freq_scale);
+
+	if (rate <= 133000000) {
+		emi.emi_div = 3;
+		emi.frac_div = 22;
+		emi.new_freq = 133;
+		DDR2EmiController_EDE1116_133MHz();
+	} else if (rate <= 166000000) {
+		emi.emi_div = 2;
+		emi.frac_div = 27;
+		emi.new_freq = 166;
+		DDR2EmiController_EDE1116_166MHz();
+	} else {
+		emi.emi_div = 2;
+		emi.frac_div = 22;
+		emi.new_freq = 200;
+		DDR2EmiController_EDE1116_200MHz();
+		}
+
+	local_irq_disable();
+	local_fiq_disable();
+	f(&emi, get_current_emidata());
+	local_fiq_enable();
+	local_irq_enable();
+	iram_free(iram_phy,
+		(unsigned int)mxs_ram_freq_scale_end -
+	       (unsigned int)mxs_ram_freq_scale);
+
+	for (i = 10000; i; i--)
+		if (!clk_is_busy(clk))
+			break;
+
+	if (!i) {
+		printk(KERN_ERR "couldn't set up EMI divisor\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static struct clk emi_clk = {
+	.parent = &ref_emi_clk,
+	.get_rate = emi_get_rate,
+	.set_rate = emi_set_rate,
+	.round_rate = emi_round_rate,
+	.set_parent = emi_set_parent,
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI,
+	.enable_bits = BM_CLKCTRL_EMI_CLKGATE,
+	.scale_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_FRAC0,
+	.busy_reg	= CLKCTRL_BASE_ADDR + HW_CLKCTRL_EMI,
+	.busy_bits	= 28,
+	.bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits = 7,
+};
+
+static unsigned long ssp_get_rate(struct clk *clk);
+
+static int ssp_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+	int div = (clk_get_rate(clk->parent) + rate - 1) / rate;
+	u32 reg_frac;
+	const int mask = 0x1FF;
+	int try = 10;
+	int i = -1;
+
+	if (div == 0 || div > mask)
+		goto out;
+
+	reg_frac = __raw_readl(clk->scale_reg);
+	reg_frac &= ~(mask << clk->scale_bits);
+
+	while (try--) {
+		__raw_writel(reg_frac | (div << clk->scale_bits),
+				clk->scale_reg);
+
+		if (clk->busy_reg) {
+			for (i = 10000; i; i--)
+				if (!clk_is_busy(clk))
+					break;
+		}
+		if (i)
+			break;
+	}
+
+	if (!i)
+		ret = -ETIMEDOUT;
+	else
+		ret = 0;
+
+out:
+	if (ret != 0)
+		pr_err("%s: error %d\n", __func__, ret);
+	return ret;
+}
+
+static int ssp_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+
+	if (clk->bypass_reg) {
+		if (clk->parent == parent)
+			return 0;
+		if (parent == &ref_io_clk[0] || parent == &ref_io_clk[1])
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + CLR_REGISTER);
+		else
+			__raw_writel(1 << clk->bypass_bits,
+					clk->bypass_reg + SET_REGISTER);
+		clk->parent = parent;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static struct clk ssp_clk[] = {
+	{
+	 .parent = &ref_io_clk[0],
+	 .get_rate = ssp_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0,
+	 .enable_bits = BM_CLKCTRL_SSP0_CLKGATE,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0,
+	 .busy_bits = 29,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0,
+	 .scale_bits = 0,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 3,
+	 .set_rate = ssp_set_rate,
+	 .set_parent = ssp_set_parent,
+	 },
+	{
+	 .parent = &ref_io_clk[0],
+	 .get_rate = ssp_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1,
+	 .enable_bits = BM_CLKCTRL_SSP1_CLKGATE,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1,
+	 .busy_bits = 29,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1,
+	 .scale_bits = 0,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 4,
+	 .set_rate = ssp_set_rate,
+	 .set_parent = ssp_set_parent,
+	 },
+	{
+	 .parent = &ref_io_clk[1],
+	 .get_rate = ssp_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2,
+	 .enable_bits = BM_CLKCTRL_SSP2_CLKGATE,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2,
+	 .busy_bits = 29,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2,
+	 .scale_bits = 0,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 5,
+	 .set_rate = ssp_set_rate,
+	 .set_parent = ssp_set_parent,
+	 },
+	{
+	 .parent = &ref_io_clk[1],
+	 .get_rate = ssp_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3,
+	 .enable_bits = BM_CLKCTRL_SSP3_CLKGATE,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3,
+	 .busy_bits = 29,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3,
+	 .scale_bits = 0,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 6,
+	 .set_rate = ssp_set_rate,
+	 .set_parent = ssp_set_parent,
+	 },
+};
+
+static unsigned long ssp_get_rate(struct clk *clk)
+{
+	unsigned int reg, div;
+	switch (clk - ssp_clk) {
+	case 0:
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP0);
+		div = reg & BM_CLKCTRL_SSP0_DIV;
+		reg &= BM_CLKCTRL_SSP0_DIV_FRAC_EN;
+		break;
+	case 1:
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP1);
+		div = reg & BM_CLKCTRL_SSP1_DIV;
+		reg &= BM_CLKCTRL_SSP1_DIV_FRAC_EN;
+		break;
+	case 2:
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP2);
+		div = reg & BM_CLKCTRL_SSP2_DIV;
+		reg &= BM_CLKCTRL_SSP2_DIV_FRAC_EN;
+		break;
+	case 3:
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SSP3);
+		div = reg & BM_CLKCTRL_SSP3_DIV;
+		reg &= BM_CLKCTRL_SSP3_DIV_FRAC_EN;
+		break;
+	default:
+		return 0;
+	}
+	if (!reg)
+		return clk->parent->get_rate(clk->parent) / div;
+	return (clk->parent->get_rate(clk->parent) / 0x200) / div;
+}
+
+static unsigned long lcdif_get_rate(struct clk *clk)
+{
+	long rate = clk->parent->get_rate(clk->parent);
+	long div;
+
+	div = __raw_readl(clk->scale_reg);
+	if (!(div & BM_CLKCTRL_DIS_LCDIF_DIV_FRAC_EN)) {
+		div = (div >> clk->scale_bits) & BM_CLKCTRL_DIS_LCDIF_DIV;
+		return rate / (div ? div : 1);
+	}
+
+	div = (div >> clk->scale_bits) & BM_CLKCTRL_DIS_LCDIF_DIV;
+	rate /= (BM_CLKCTRL_DIS_LCDIF_DIV >> clk->scale_bits) + 1;
+	rate *= div;
+	return rate;
+}
+
+static int lcdif_set_rate(struct clk *clk, unsigned long rate)
+{
+	int reg_val;
+
+	reg_val = __raw_readl(clk->scale_reg);
+	reg_val &= ~(BM_CLKCTRL_DIS_LCDIF_DIV | BM_CLKCTRL_DIS_LCDIF_CLKGATE);
+	reg_val |= (1 << BP_CLKCTRL_DIS_LCDIF_DIV) & BM_CLKCTRL_DIS_LCDIF_DIV;
+	__raw_writel(reg_val, clk->scale_reg);
+	if (clk->busy_reg) {
+		int i;
+		for (i = 10000; i; i--)
+			if (!clk_is_busy(clk))
+				break;
+		if (!i)
+			return -ETIMEDOUT;
+	}
+
+	reg_val = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+	reg_val |= BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF;
+	__raw_writel(reg_val, CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+
+	return 0;
+}
+
+static int lcdif_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+	if (clk->bypass_reg) {
+		if (parent == clk->parent)
+			return 0;
+		if (parent == &ref_xtal_clk) {
+			__raw_writel(1 << clk->bypass_bits,
+				clk->bypass_reg + SET_REGISTER);
+			ret = 0;
+		}
+		if (ret && (parent == &ref_pix_clk)) {
+			__raw_writel(0 << clk->bypass_bits,
+				clk->bypass_reg + CLR_REGISTER);
+			ret = 0;
+		}
+		if (!ret)
+			clk->parent = parent;
+	}
+	return ret;
+}
+
+static struct clk dis_lcdif_clk = {
+	.parent = &pll_clk[0],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF,
+	.scale_bits = 0,
+	.busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF,
+	.busy_bits = 29,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_DIS_LCDIF,
+	.enable_bits = 31,
+	.bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits = 14,
+	.get_rate = lcdif_get_rate,
+	.set_rate = lcdif_set_rate,
+	.set_parent = lcdif_set_parent,
+	.flags = CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long hsadc_get_rate(struct clk *clk)
+{
+	unsigned int reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_HSADC);
+	reg = (reg & BM_CLKCTRL_HSADC_FREQDIV) >> BP_CLKCTRL_HSADC_FREQDIV;
+	return clk->parent->get_rate(clk->parent) / ((1 << reg) * 9);
+}
+
+static int hsadc_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int reg = clk->parent->get_rate(clk->parent);
+	if ((reg / rate) % 9)
+		return -EINVAL;
+	reg = reg / 9;
+	switch (reg) {
+	case 1:
+		reg = BM_CLKCTRL_HSADC_RESETB;
+		break;
+	case 2:
+		reg = 1 | BM_CLKCTRL_HSADC_RESETB;
+		break;
+	case 4:
+		reg = 2 | BM_CLKCTRL_HSADC_RESETB;
+		break;
+	case 8:
+		reg = 3 | BM_CLKCTRL_HSADC_RESETB;
+		break;
+	default:
+		return -EINVAL;
+	}
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_HSADC);
+	return 0;
+}
+
+static unsigned long hsadc_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div;
+	unsigned int reg = clk->parent->get_rate(clk->parent);
+	div = ((reg / rate) + 8) / 9;
+	if (div <= 1)
+		return reg;
+	if (div > 4)
+		return reg >> 3;
+	if (div > 2)
+		return reg >> 2;
+	return reg >> 1;
+}
+
+static struct clk hsadc_clk = {
+	.parent = &ref_hsadc_clk,
+	.get_rate = hsadc_get_rate,
+	.set_rate = hsadc_set_rate,
+	.round_rate = hsadc_round_rate,
+};
+
+static unsigned long gpmi_get_rate(struct clk *clk)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI) &
+	    BM_CLKCTRL_GPMI_DIV;
+	return clk->parent->get_rate(clk->parent) / reg;
+}
+
+static int gpmi_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+	if (clk->bypass_reg) {
+		if (parent == clk->parent)
+			return 0;
+		if (parent == &ref_xtal_clk) {
+			__raw_writel(1 << clk->bypass_bits,
+				clk->bypass_reg + SET_REGISTER);
+			ret = 0;
+		}
+		if (ret && (parent == &ref_gpmi_clk)) {
+			__raw_writel(0 << clk->bypass_bits,
+				clk->bypass_reg + CLR_REGISTER);
+			ret = 0;
+		}
+		if (!ret)
+			clk->parent = parent;
+	}
+	return ret;
+}
+
+static unsigned long gpmi_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int root_rate, frac_rate;
+	unsigned int div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	frac_rate = root_rate % rate;
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return root_rate;
+	if (frac_rate == 0)
+		return rate;
+	return rate;
+}
+
+static int gpmi_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long root_rate;
+	unsigned int reg, div;
+	root_rate = clk->parent->get_rate(clk->parent);
+	div = root_rate / rate;
+	if ((div == 0) || (div >= 0x400))
+		return -EINVAL;
+
+	if (root_rate % rate) {
+		div = mx28_get_frac_div(root_rate / 1000, rate / 1000, 0x3FF);
+		if (((root_rate / 0x400) * div) > rate)
+			return -EINVAL;
+	}
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
+	reg &= ~(BM_CLKCTRL_GPMI_DIV | BM_CLKCTRL_GPMI_DIV_FRAC_EN);
+	if (root_rate % rate)
+		reg |= BM_CLKCTRL_GPMI_DIV_FRAC_EN;
+	reg |= BF_CLKCTRL_GPMI_DIV(div);
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
+
+	do {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI);
+	} while (reg & BM_CLKCTRL_GPMI_BUSY);
+	return 0;
+}
+
+static struct clk gpmi_clk = {
+	.parent = &ref_gpmi_clk,
+	.set_parent = gpmi_set_parent,
+	.get_rate = gpmi_get_rate,
+	.set_rate = gpmi_set_rate,
+	.round_rate = gpmi_round_rate,
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_GPMI,
+	.enable_bits = BM_CLKCTRL_GPMI_CLKGATE,
+	.bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	.bypass_bits = 2,
+};
+
+static unsigned long saif_get_rate(struct clk *clk);
+static unsigned long saif_set_rate(struct clk *clk, unsigned int rate);
+static unsigned long saif_set_parent(struct clk *clk, struct clk *parent);
+
+static struct clk saif_clk[] = {
+	{
+	 .parent = &pll_clk[0],
+	 .get_rate = saif_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0,
+	 .enable_bits = BM_CLKCTRL_SAIF0_CLKGATE,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0,
+	 .scale_bits = 0,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0,
+	 .busy_bits = 29,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 0,
+	 .set_rate = saif_set_rate,
+	 .set_parent = saif_set_parent,
+	 },
+	{
+	 .parent = &pll_clk[0],
+	 .get_rate = saif_get_rate,
+	 .enable = mx28_raw_enable,
+	 .disable = mx28_raw_disable,
+	 .enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1,
+	 .enable_bits = BM_CLKCTRL_SAIF1_CLKGATE,
+	 .scale_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1,
+	 .scale_bits = 0,
+	 .busy_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1,
+	 .busy_bits = 29,
+	 .bypass_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ,
+	 .bypass_bits = 1,
+	 .set_rate = saif_set_rate,
+	 .set_parent = saif_set_parent,
+	 },
+};
+
+static unsigned long saif_get_rate(struct clk *clk)
+{
+	unsigned long reg, div;
+	if (clk == saif_clk) {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF0);
+		div = reg & BM_CLKCTRL_SAIF0_DIV;
+		reg &= BM_CLKCTRL_SAIF0_DIV_FRAC_EN;
+	} else {
+		reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_SAIF1);
+		div = reg & BM_CLKCTRL_SAIF1_DIV;
+		reg &= BM_CLKCTRL_SAIF1_DIV_FRAC_EN;
+	}
+	if (!reg)
+		return clk->parent->get_rate(clk->parent) / div;
+	return (clk->parent->get_rate(clk->parent) / 0x10000) * div;
+}
+
+static unsigned long saif_set_rate(struct clk *clk, unsigned int rate)
+{
+	u16 div = 0;
+	u32 clkctrl_saif;
+	u64 rates;
+	struct clk *parent = clk->parent;
+
+	pr_debug("%s: rate %d, parent rate %d\n", __func__, rate,
+			clk_get_rate(parent));
+
+	if (rate > clk_get_rate(parent))
+		return -EINVAL;
+	/*saif clock always use frac div*/
+	rates = 65536 * (u64)rate;
+	rates = rates + (u64)(clk_get_rate(parent) / 2);
+	do_div(rates, clk_get_rate(parent));
+	div = rates;
+
+	pr_debug("%s: div calculated is %d\n", __func__, div);
+	if (!div)
+		return -EINVAL;
+
+	clkctrl_saif = __raw_readl(clk->scale_reg);
+	clkctrl_saif &= ~BM_CLKCTRL_SAIF0_DIV_FRAC_EN;
+	clkctrl_saif &= ~BM_CLKCTRL_SAIF0_DIV;
+	clkctrl_saif |= div;
+	clkctrl_saif |= BM_CLKCTRL_SAIF0_DIV_FRAC_EN;
+	clkctrl_saif &= ~BM_CLKCTRL_SAIF0_CLKGATE;
+	__raw_writel(clkctrl_saif, clk->scale_reg);
+	if (clk->busy_reg) {
+		int i;
+		for (i = 10000; i; i--)
+			if (!clk_is_busy(clk))
+				break;
+		if (!i) {
+			pr_err("couldn't set up SAIF clk divisor\n");
+			return -ETIMEDOUT;
+		}
+	}
+	return 0;
+}
+
+static unsigned long saif_set_parent(struct clk *clk, struct clk *parent)
+{
+	int ret = -EINVAL;
+	int shift = 4;
+	/*bypass*/
+	if (parent == &pll_clk[0])
+		shift = 8;
+	if (clk->bypass_reg) {
+		__raw_writel(1 << clk->bypass_bits, clk->bypass_reg + shift);
+		ret = 0;
+	}
+	return ret;
+}
+
+static int saif_mclk_enable(struct clk *clk)
+{
+	/*Check if enabled already*/
+	if (__raw_readl(clk->busy_reg) & clk->busy_bits)
+		return 0;
+	 /*Enable saif to enable mclk*/
+	__raw_writel(0x1, clk->enable_reg);
+	mdelay(1);
+	__raw_writel(0x1, clk->enable_reg);
+	mdelay(1);
+	return 0;
+}
+
+static int saif_mclk_disable(struct clk *clk)
+{
+	/*Check if disabled already*/
+	if (!(__raw_readl(clk->busy_reg) & clk->busy_bits))
+		return 0;
+	 /*Disable saif to disable mclk*/
+	__raw_writel(0x0, clk->enable_reg);
+	mdelay(1);
+	__raw_writel(0x0, clk->enable_reg);
+	mdelay(1);
+	return 0;
+}
+
+static struct clk saif_mclk[] = {
+	{
+	 .parent = &saif_clk[0],
+	 .enable = saif_mclk_enable,
+	 .disable = saif_mclk_disable,
+	 .enable_reg = SAIF0_CTRL,
+	 .enable_bits = BM_SAIF_CTRL_RUN,
+	 .busy_reg = SAIF0_STAT,
+	 .busy_bits = BM_SAIF_STAT_BUSY,
+	 },
+	{
+	 .parent = &saif_clk[1],
+	 .enable = saif_mclk_enable,
+	 .disable = saif_mclk_disable,
+	 .enable_reg = SAIF1_CTRL,
+	 .enable_bits = BM_SAIF_CTRL_RUN,
+	 .busy_reg = SAIF1_STAT,
+	 .busy_bits = BM_SAIF_STAT_BUSY,
+	 },
+};
+
+static unsigned long pcmspdif_get_rate(struct clk *clk)
+{
+	return clk->parent->get_rate(clk->parent) / 4;
+}
+
+static struct clk pcmspdif_clk = {
+	.parent = &pll_clk[0],
+	.get_rate = pcmspdif_get_rate,
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_SPDIF,
+	.enable_bits = BM_CLKCTRL_SPDIF_CLKGATE,
+};
+
+/* usb_clk for usb0 */
+static struct clk usb_clk0 = {
+	.parent = &pll_clk[0],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL,
+	.enable_bits = BM_DIGCTL_CTRL_USB0_CLKGATE,
+	.flags = CPU_FREQ_TRIG_UPDATE,
+};
+
+/* usb_clk for usb1 */
+static struct clk usb_clk1 = {
+	.parent = &pll_clk[1],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = DIGCTRL_BASE_ADDR + HW_DIGCTL_CTRL,
+	.enable_bits = BM_DIGCTL_CTRL_USB1_CLKGATE,
+	.flags = CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk enet_out_clk = {
+	.parent = &pll_clk[2],
+	.enable = mx28_raw_enable,
+	.disable = mx28_raw_disable,
+	.enable_reg = CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET,
+	.enable_bits = BM_CLKCTRL_ENET_DISABLE,
+};
+
+static struct clk_lookup onchip_clocks[] = {
+	{
+	 .con_id = "xtal.0",
+	 .clk = &xtal_clk[0],
+	 },
+	{
+	 .con_id = "xtal.1",
+	 .clk = &xtal_clk[1],
+	 },
+	{
+	 .con_id = "xtal.2",
+	 .clk = &xtal_clk[2],
+	 },
+	{
+	 .con_id = "pll.0",
+	 .clk = &pll_clk[0],
+	 },
+	{
+	 .con_id = "pll.1",
+	 .clk = &pll_clk[1],
+	 },
+	{
+	 .con_id = "pll.2",
+	 .clk = &pll_clk[2],
+	 },
+	{
+	 .con_id = "ref_xtal",
+	 .clk = &ref_xtal_clk,
+	 },
+	{
+	 .con_id = "ref_cpu",
+	 .clk = &ref_cpu_clk,
+	 },
+	{
+	 .con_id = "ref_emi",
+	 .clk = &ref_emi_clk,
+	 },
+	{
+	 .con_id = "ref_io.0",
+	 .clk = &ref_io_clk[0],
+	 },
+	{
+	 .con_id = "ref_io.1",
+	 .clk = &ref_io_clk[1],
+	 },
+	{
+	 .con_id = "ref_pix",
+	 .clk = &ref_pix_clk,
+	 },
+	{
+	 .con_id = "ref_hsadc",
+	 .clk = &ref_hsadc_clk,
+	 },
+	{
+	 .con_id = "ref_gpmi",
+	 .clk = &ref_gpmi_clk,
+	 },
+	{
+	 .con_id = "ana",
+	 .clk = &ana_clk,
+	 },
+	{
+	 .con_id = "rtc",
+	 .clk = &rtc_clk,
+	 },
+	{
+	 .con_id = "cpu",
+	 .clk = &cpu_clk,
+	 },
+	{
+	 .con_id = "h",
+	 .clk = &h_clk,
+	 },
+	{
+	 .con_id = "x",
+	 .clk = &x_clk,
+	 },
+	{
+	 .con_id = "ocrom",
+	 .clk = &ocrom_clk,
+	 },
+	{
+	 .con_id = "clk_32k",
+	 .clk = &clk_32k,
+	 },
+	{
+	 .con_id = "uart",
+	 .clk = &uart_clk,
+	 },
+	{
+	 .con_id = "pwm",
+	 .clk = &pwm_clk,
+	 },
+	{
+	 .con_id = "lradc",
+	 .clk = &lradc_clk,
+	 },
+	{
+	 .con_id = "ssp.0",
+	 .clk = &ssp_clk[0],
+	 },
+	{
+	 .con_id = "ssp.1",
+	 .clk = &ssp_clk[1],
+	 },
+	{
+	 .con_id = "ssp.2",
+	 .clk = &ssp_clk[2],
+	 },
+	{
+	 .con_id = "ssp.3",
+	 .clk = &ssp_clk[3],
+	 },
+	{
+	 .con_id = "gpmi",
+	 .clk = &gpmi_clk,
+	 },
+	{
+	 .con_id = "spdif",
+	 .clk = &pcmspdif_clk,
+	 },
+	{
+	 .con_id = "saif.0",
+	 .clk = &saif_clk[0],
+	 },
+	{
+	 .con_id = "saif.1",
+	 .clk = &saif_clk[1],
+	 },
+	{
+	 .con_id = "emi",
+	 .clk = &emi_clk,
+	 },
+	{
+	 .con_id = "dis_lcdif",
+	 .clk = &dis_lcdif_clk,
+	 },
+	{
+	 .con_id = "hsadc",
+	 .clk = &hsadc_clk,
+	 },
+	{
+	 .con_id = "can_clk",
+	 .dev_id = "FlexCAN.0",
+	 .clk = &flexcan_clk[0],
+	 },
+	{
+	 .con_id = "can_clk",
+	 .dev_id = "FlexCAN.1",
+	 .clk = &flexcan_clk[1],
+	 },
+	{
+	.con_id = "usb_clk0",
+	.clk = &usb_clk0,
+	},
+	{
+	.con_id = "usb_clk1",
+	.clk = &usb_clk1,
+	},
+	{
+	.con_id = "fec_clk",
+	.clk = &enet_out_clk,
+	},
+	{
+	.con_id = "saif_mclk.0",
+	.clk = &saif_mclk[0],
+	},
+	{
+	.con_id = "saif_mclk.1",
+	.clk = &saif_mclk[1],
+	}
+};
+
+static void mx28_clock_scan(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_CLKSEQ);
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_CPU)
+		cpu_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF)
+		dis_lcdif_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_EMI)
+		emi_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP3)
+		ssp_clk[3].parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP2)
+		ssp_clk[2].parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP1)
+		ssp_clk[1].parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SSP0)
+		ssp_clk[0].parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_GPMI)
+		gpmi_clk.parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF1)
+		saif_clk[1].parent = &ref_xtal_clk;
+	if (reg & BM_CLKCTRL_CLKSEQ_BYPASS_SAIF0)
+		saif_clk[0].parent = &ref_xtal_clk;
+};
+
+void __init mx28_set_input_clk(unsigned long xtal0,
+			       unsigned long xtal1,
+			       unsigned long xtal2, unsigned long enet)
+{
+	xtal_clk_rate[0] = xtal0;
+	xtal_clk_rate[1] = xtal1;
+	xtal_clk_rate[2] = xtal2;
+	enet_mii_phy_rate = enet;
+}
+
+void  mx28_enet_clk_hook(void)
+{
+	unsigned long reg;
+
+	reg =  __raw_readl(CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
+
+	reg &= ~BM_CLKCTRL_ENET_SLEEP;
+	reg |= BM_CLKCTRL_ENET_CLK_OUT_EN;
+	/* select clock for 1588 module */
+	reg |= BM_CLKCTRL_ENET_1588_40MHZ;
+
+	__raw_writel(reg, CLKCTRL_BASE_ADDR + HW_CLKCTRL_ENET);
+}
+
+void __init mx28_clock_init(void)
+{
+	int i;
+	mx28_clock_scan();
+	mx28_enet_clk_hook();
+	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++)
+		clk_register(&onchip_clocks[i]);
+
+	clk_enable(&cpu_clk);
+	clk_enable(&emi_clk);
+
+	clk_en_public_h_asm_ctrl(mx28_enable_h_autoslow,
+		mx28_set_hbus_autoslow_flags);
+}
diff --git a/arch/arm/mach-mx28/device.c b/arch/arm/mach-mx28/device.c
new file mode 100644
index 0000000..1d7b424
--- /dev/null
+++ b/arch/arm/mach-mx28/device.c
@@ -0,0 +1,1508 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/phy.h>
+#include <linux/fec.h>
+#include <linux/gpmi-nfc.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-timrot.h>
+#include <mach/regs-lradc.h>
+#include <mach/device.h>
+#include <mach/dma.h>
+#include <mach/lradc.h>
+#include <mach/lcdif.h>
+#include <mach/ddi_bc.h>
+#include <mach/pinctrl.h>
+
+#include "regs-digctl.h"
+#include "device.h"
+#include "mx28evk.h"
+#include "mx28_pins.h"
+
+#if defined(CONFIG_SERIAL_MXS_DUART) || \
+	defined(CONFIG_SERIAL_MXS_DUART_MODULE)
+static struct resource duart_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = DUART_PHYS_ADDR,
+	 .end = DUART_PHYS_ADDR + 0x1000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_DUART,
+	 .end = IRQ_DUART,
+	 },
+};
+
+static void __init mx28_init_duart(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-duart", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = duart_resource;
+	pdev->num_resources = ARRAY_SIZE(duart_resource);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void mx28_init_duart(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_DMA_ENGINE)
+static struct resource mxs_ahb_apbh_res = {
+	.flags = IORESOURCE_MEM,
+	.start = APBH_DMA_PHYS_ADDR,
+	.end = APBH_DMA_PHYS_ADDR + 0x2000 - 1,
+};
+
+static struct mxs_dma_plat_data mxs_ahb_apbh_data = {
+	.chan_base = MXS_DMA_CHANNEL_AHB_APBH,
+	.chan_num = 16,
+};
+
+static struct resource mxs_ahb_apbx_res = {
+	.flags = IORESOURCE_MEM,
+	.start = APBX_DMA_PHYS_ADDR,
+	.end = APBX_DMA_PHYS_ADDR + 0x2000 - 1,
+};
+
+static struct mxs_dma_plat_data mxs_ahb_apbx_data = {
+	.chan_base = MXS_DMA_CHANNEL_AHB_APBX,
+	.chan_num = 16,
+};
+
+static void __init mx28_init_dma(void)
+{
+	int i;
+	struct mxs_dev_lookup *lookup;
+	struct platform_device *pdev;
+	lookup = mxs_get_devices("mxs-dma");
+	if (lookup == NULL || IS_ERR(lookup))
+		return;
+	for (i = 0; i < lookup->size; i++) {
+		pdev = lookup->pdev + i;
+		if (!strcmp(pdev->name, "mxs-dma-apbh")) {
+			pdev->resource = &mxs_ahb_apbh_res;
+			pdev->dev.platform_data = &mxs_ahb_apbh_data;
+		} else if (!strcmp(pdev->name, "mxs-dma-apbx")) {
+			pdev->resource = &mxs_ahb_apbx_res;
+			pdev->dev.platform_data = &mxs_ahb_apbx_data;
+		} else
+			continue;
+		pdev->num_resources = 1;
+		mxs_add_device(pdev, 0);
+	}
+}
+#else
+static void mx28_init_dma(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+static struct resource framebuffer_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LCDIF_PHYS_ADDR,
+	 .end   = LCDIF_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LCDIF,
+	 .end   = IRQ_LCDIF,
+	 },
+};
+
+static struct mxs_platform_fb_data mxs_framebuffer_pdata = {
+	.list = LIST_HEAD_INIT(mxs_framebuffer_pdata.list),
+};
+
+static void __init mx28_init_lcdif(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-fb", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = framebuffer_resource;
+	pdev->num_resources = ARRAY_SIZE(framebuffer_resource);
+	pdev->dev.platform_data = &mxs_framebuffer_pdata;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_lcdif(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_VIDEO_MXS_PXP) || \
+	defined(CONFIG_VIDEO_MXS_PXP_MODULE)
+static struct resource pxp_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= (unsigned int)IO_ADDRESS(PXP_PHYS_ADDR),
+		.end	= (unsigned int)IO_ADDRESS(PXP_PHYS_ADDR) + 0x2000 - 1,
+	}, {
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_PXP,
+		.end	= IRQ_PXP,
+	},
+};
+static void __init mx28_init_pxp(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-pxp", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = pxp_resource;
+	pdev->num_resources = ARRAY_SIZE(pxp_resource);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_pxp(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_MXS_VIIM) || defined(CONFIG_MXS_VIIM_MODULE)
+struct resource viim_resources[] = {
+	[0] = {
+		.start  = DIGCTL_PHYS_ADDR,
+		.end    = DIGCTL_PHYS_ADDR + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = OCOTP_PHYS_ADDR,
+		.end    = OCOTP_PHYS_ADDR + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+static void __init mx28_init_viim(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs_viim", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->resource = viim_resources;
+	pdev->num_resources = ARRAY_SIZE(viim_resources);
+
+	mxs_add_device(pdev, 2);
+}
+#else
+static void __init mx28_init_viim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+#ifdef	CONFIG_I2C_MXS_SELECT0
+static struct resource i2c0_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = I2C0_PHYS_ADDR,
+	 .end   = I2C0_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_I2C0,
+	 .end   = MXS_DMA_CHANNEL_AHB_APBX_I2C0,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C0_ERROR,
+	 .end   = IRQ_I2C0_ERROR,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C0_DMA,
+	 .end   = IRQ_I2C0_DMA,
+	 },
+};
+
+static struct mxs_i2c_plat_data i2c0_platdata = {
+#ifdef	CONFIG_I2C_MXS_SELECT0_PIOQUEUE_MODE
+	.pioqueue_mode = 1,
+#endif
+};
+#endif
+
+#ifdef	CONFIG_I2C_MXS_SELECT1
+static struct resource i2c1_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = I2C1_PHYS_ADDR,
+	 .end   = I2C1_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_I2C1,
+	 .end   = MXS_DMA_CHANNEL_AHB_APBX_I2C1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C1_ERROR,
+	 .end   = IRQ_I2C1_ERROR,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_I2C1_DMA,
+	 .end   = IRQ_I2C1_DMA,
+	 },
+};
+
+static struct mxs_i2c_plat_data i2c1_platdata = {
+#ifdef	CONFIG_I2C_MXS_SELECT1_PIOQUEUE_MODE
+	.pioqueue_mode = 1,
+#endif
+};
+#endif
+
+static void __init mx28_init_i2c(void)
+{
+	int i;
+	struct mxs_dev_lookup *lookup;
+	struct platform_device *pdev;
+
+	lookup = mxs_get_devices("mxs-i2c");
+	if (lookup == NULL || IS_ERR(lookup))
+		return;
+	for (i = 0; i < lookup->size; i++) {
+		pdev = lookup->pdev + i;
+		switch (pdev->id) {
+#ifdef	CONFIG_I2C_MXS_SELECT0
+		case 0:
+			pdev->resource = i2c0_resource;
+			pdev->num_resources = ARRAY_SIZE(i2c0_resource);
+			pdev->dev.platform_data = &i2c0_platdata;
+			break;
+#endif
+#ifdef	CONFIG_I2C_MXS_SELECT1
+		case 1:
+			pdev->resource = i2c1_resource;
+			pdev->num_resources = ARRAY_SIZE(i2c1_resource);
+			pdev->dev.platform_data = &i2c1_platdata;
+			break;
+#endif
+		default:
+			return;
+		}
+		mxs_add_device(pdev, 2);
+	}
+}
+#else
+static void __init mx28_init_i2c(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MTD_NAND_GPMI_NFC)
+
+extern int enable_gpmi;
+
+static int gpmi_nfc_platform_init(unsigned int max_chip_count)
+{
+	return !enable_gpmi;
+}
+
+static void gpmi_nfc_platform_exit(unsigned int max_chip_count)
+{
+}
+
+static const char *gpmi_nfc_partition_source_types[] = { "cmdlinepart", 0 };
+
+static struct gpmi_nfc_platform_data  gpmi_nfc_platform_data = {
+	.nfc_version             = 1,
+	.boot_rom_version        = 1,
+	.clock_name              = "gpmi",
+	.platform_init           = gpmi_nfc_platform_init,
+	.platform_exit           = gpmi_nfc_platform_exit,
+	.min_prop_delay_in_ns    = 5,
+	.max_prop_delay_in_ns    = 9,
+	.max_chip_count          = 2,
+	.boot_area_size_in_bytes = 20 * SZ_1M,
+	.partition_source_types  = gpmi_nfc_partition_source_types,
+	.partitions              = 0,
+	.partition_count         = 0,
+};
+
+static struct resource gpmi_nfc_resources[] = {
+	{
+	 .name  = GPMI_NFC_GPMI_REGS_ADDR_RES_NAME,
+	 .flags = IORESOURCE_MEM,
+	 .start = GPMI_PHYS_ADDR,
+	 .end   = GPMI_PHYS_ADDR + SZ_8K - 1,
+	 },
+	{
+	 .name  = GPMI_NFC_GPMI_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_GPMI,
+	 .end   = IRQ_GPMI,
+	},
+	{
+	 .name  = GPMI_NFC_BCH_REGS_ADDR_RES_NAME,
+	 .flags = IORESOURCE_MEM,
+	 .start = BCH_PHYS_ADDR,
+	 .end   = BCH_PHYS_ADDR + SZ_8K - 1,
+	 },
+	{
+	 .name  = GPMI_NFC_BCH_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_BCH,
+	 .end   = IRQ_BCH,
+	 },
+	{
+	 .name  = GPMI_NFC_DMA_CHANNELS_RES_NAME,
+	 .flags = IORESOURCE_DMA,
+	 .start	= MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	 .end	= MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	 },
+	{
+	 .name  = GPMI_NFC_DMA_INTERRUPT_RES_NAME,
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_GPMI_DMA,
+	 .end   = IRQ_GPMI_DMA,
+	},
+};
+
+static void __init mx28_init_gpmi_nfc(void)
+{
+	struct platform_device  *pdev;
+
+	pdev = mxs_get_device(GPMI_NFC_DRIVER_NAME, 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->dev.platform_data = &gpmi_nfc_platform_data;
+	pdev->resource          =  gpmi_nfc_resources;
+	pdev->num_resources     = ARRAY_SIZE(gpmi_nfc_resources);
+	mxs_add_device(pdev, 1);
+}
+#else
+static void mx28_init_gpmi_nfc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
+#if defined(CONFIG_MACH_MX28EVK)
+#define MMC0_POWER	MXS_PIN_TO_GPIO(PINID_PWM3)
+#define MMC1_POWER	MXS_PIN_TO_GPIO(PINID_PWM4)
+#define MMC0_WP		MXS_PIN_TO_GPIO(PINID_SSP1_SCK)
+#define MMC1_WP		MXS_PIN_TO_GPIO(PINID_GPMI_RESETN)
+#endif
+
+static int mxs_mmc_get_wp_ssp0(void)
+{
+	return gpio_get_value(MMC0_WP);
+}
+
+static int mxs_mmc_hw_init_ssp0(void)
+{
+	int ret = 0;
+
+	/* Configure write protect GPIO pin */
+	ret = gpio_request(MMC0_WP, "mmc0_wp");
+	if (ret)
+		goto out_wp;
+
+	gpio_set_value(MMC0_WP, 0);
+	gpio_direction_input(MMC0_WP);
+
+	/* Configure POWER pin as gpio to drive power to MMC slot */
+	ret = gpio_request(MMC0_POWER, "mmc0_power");
+	if (ret)
+		goto out_power;
+
+	gpio_direction_output(MMC0_POWER, 0);
+	mdelay(100);
+
+	return 0;
+
+out_power:
+	gpio_free(MMC0_WP);
+out_wp:
+	return ret;
+}
+
+static void mxs_mmc_hw_release_ssp0(void)
+{
+	gpio_free(MMC0_POWER);
+	gpio_free(MMC0_WP);
+
+}
+
+static void mxs_mmc_cmd_pullup_ssp0(int enable)
+{
+	mxs_set_pullup(PINID_SSP0_CMD, enable, "mmc0_cmd");
+}
+
+static unsigned long mxs_mmc_setclock_ssp0(unsigned long hz)
+{
+	struct clk *ssp = clk_get(NULL, "ssp.0"), *parent;
+
+	if (hz > 1000000)
+		parent = clk_get(NULL, "ref_io.0");
+	else
+		parent = clk_get(NULL, "xtal.0");
+
+	clk_set_parent(ssp, parent);
+	clk_set_rate(ssp, 2 * hz);
+	clk_put(parent);
+	clk_put(ssp);
+
+	return hz;
+}
+
+static int mxs_mmc_get_wp_ssp1(void)
+{
+	return gpio_get_value(MMC1_WP);
+}
+
+static int mxs_mmc_hw_init_ssp1(void)
+{
+	int ret = 0;
+
+	/* Configure write protect GPIO pin */
+	ret = gpio_request(MMC1_WP, "mmc1_wp");
+	if (ret)
+		goto out_wp;
+
+	gpio_set_value(MMC1_WP, 0);
+	gpio_direction_input(MMC1_WP);
+
+	/* Configure POWER pin as gpio to drive power to MMC slot */
+	ret = gpio_request(MMC1_POWER, "mmc1_power");
+	if (ret)
+		goto out_power;
+
+	gpio_direction_output(MMC1_POWER, 0);
+	mdelay(100);
+
+	return 0;
+
+out_power:
+	gpio_free(MMC1_WP);
+out_wp:
+	return ret;
+}
+
+static void mxs_mmc_hw_release_ssp1(void)
+{
+	gpio_free(MMC1_POWER);
+	gpio_free(MMC1_WP);
+}
+
+static void mxs_mmc_cmd_pullup_ssp1(int enable)
+{
+	mxs_set_pullup(PINID_GPMI_RDY1, enable, "mmc1_cmd");
+}
+
+static unsigned long mxs_mmc_setclock_ssp1(unsigned long hz)
+{
+	struct clk *ssp = clk_get(NULL, "ssp.1"), *parent;
+
+	if (hz > 1000000)
+		parent = clk_get(NULL, "ref_io.0");
+	else
+		parent = clk_get(NULL, "xtal.0");
+
+	clk_set_parent(ssp, parent);
+	clk_set_rate(ssp, 2 * hz);
+	clk_put(parent);
+	clk_put(ssp);
+
+	return hz;
+}
+
+static struct mxs_mmc_platform_data mmc0_data = {
+	.hw_init	= mxs_mmc_hw_init_ssp0,
+	.hw_release	= mxs_mmc_hw_release_ssp0,
+	.get_wp		= mxs_mmc_get_wp_ssp0,
+	.cmd_pullup	= mxs_mmc_cmd_pullup_ssp0,
+	.setclock	= mxs_mmc_setclock_ssp0,
+	.caps 		= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA
+				| MMC_CAP_DATA_DDR,
+	.min_clk	= 400000,
+	.max_clk	= 48000000,
+	.read_uA        = 50000,
+	.write_uA       = 70000,
+	.clock_mmc = "ssp.0",
+	.power_mmc = NULL,
+};
+
+static struct resource mmc0_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= SSP0_PHYS_ADDR,
+		.end	= SSP0_PHYS_ADDR + 0x2000 - 1,
+	},
+	{
+		.flags	= IORESOURCE_DMA,
+		.start	= MXS_DMA_CHANNEL_AHB_APBH_SSP0,
+		.end	= MXS_DMA_CHANNEL_AHB_APBH_SSP0,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP0_DMA,
+		.end	= IRQ_SSP0_DMA,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP0,
+		.end	= IRQ_SSP0,
+	},
+};
+
+static struct mxs_mmc_platform_data mmc1_data = {
+	.hw_init	= mxs_mmc_hw_init_ssp1,
+	.hw_release	= mxs_mmc_hw_release_ssp1,
+	.get_wp		= mxs_mmc_get_wp_ssp1,
+	.cmd_pullup	= mxs_mmc_cmd_pullup_ssp1,
+	.setclock	= mxs_mmc_setclock_ssp1,
+	.caps 		= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA
+				| MMC_CAP_DATA_DDR,
+	.min_clk	= 400000,
+	.max_clk	= 48000000,
+	.read_uA        = 50000,
+	.write_uA       = 70000,
+	.clock_mmc = "ssp.1",
+	.power_mmc = NULL,
+};
+
+static struct resource mmc1_resource[] = {
+	{
+		.flags	= IORESOURCE_MEM,
+		.start	= SSP1_PHYS_ADDR,
+		.end	= SSP1_PHYS_ADDR + 0x2000 - 1,
+	},
+	{
+		.flags	= IORESOURCE_DMA,
+		.start	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+		.end	= MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP1_DMA,
+		.end	= IRQ_SSP1_DMA,
+	},
+	{
+		.flags	= IORESOURCE_IRQ,
+		.start	= IRQ_SSP1,
+		.end	= IRQ_SSP1,
+	},
+};
+
+static void __init mx28_init_mmc(void)
+{
+	struct platform_device *pdev;
+
+	if (mxs_get_type(PINID_SSP0_CMD) == PIN_FUN1) {
+		pdev = mxs_get_device("mxs-mmc", 0);
+		if (pdev == NULL || IS_ERR(pdev))
+			return;
+		pdev->resource = mmc0_resource;
+		pdev->num_resources = ARRAY_SIZE(mmc0_resource);
+		pdev->dev.platform_data = &mmc0_data;
+		mxs_add_device(pdev, 2);
+	}
+
+	if (mxs_get_type(PINID_GPMI_RDY1) == PIN_FUN2) {
+		pdev = mxs_get_device("mxs-mmc", 1);
+		if (pdev == NULL || IS_ERR(pdev))
+			return;
+		pdev->resource = mmc1_resource;
+		pdev->num_resources = ARRAY_SIZE(mmc1_resource);
+		pdev->dev.platform_data = &mmc1_data;
+		mxs_add_device(pdev, 2);
+	}
+}
+#else
+static void mx28_init_mmc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_WATCHDOG) || defined(CONFIG_MXS_WATCHDOG_MODULE)
+static struct resource mx28_wdt_res = {
+	.flags = IORESOURCE_MEM,
+	.start = RTC_PHYS_ADDR,
+	.end   = RTC_PHYS_ADDR + 0x2000 - 1,
+};
+
+static void __init mx28_init_wdt(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-wdt", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = &mx28_wdt_res;
+	pdev->num_resources = 1;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_wdt(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXS) || defined(CONFIG_RTC_DRV_MXS_MODULE)
+static struct resource mx28_rtc_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = RTC_PHYS_ADDR,
+	 .end   = RTC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_RTC_ALARM,
+	 .end   = IRQ_RTC_ALARM,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_RTC_1MSEC,
+	 .end   = IRQ_RTC_1MSEC,
+	},
+};
+
+static void __init mx28_init_rtc(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-rtc", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx28_rtc_res;
+	pdev->num_resources = ARRAY_SIZE(mx28_rtc_res);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_rtc(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+static struct resource fec0_resource[] = {
+	{
+		.start  = ENET_PHYS_ADDR,
+		.end    = ENET_PHYS_ADDR + 0x3fff,
+		.flags  = IORESOURCE_MEM
+	},
+	{
+		.start  = IRQ_ENET_MAC0,
+		.end    = IRQ_ENET_MAC0,
+		.flags  = IORESOURCE_IRQ
+	},
+};
+
+static struct resource fec1_resource[] = {
+	{
+		.start  = ENET_PHYS_ADDR + 0x4000,
+		.end    = ENET_PHYS_ADDR + 0x7fff,
+		.flags  = IORESOURCE_MEM
+	},
+	{
+		.start  = IRQ_ENET_MAC1,
+		.end    = IRQ_ENET_MAC1,
+		.flags  = IORESOURCE_IRQ
+	},
+};
+
+extern int mx28evk_enet_gpio_init(void);
+static struct fec_platform_data fec_pdata0 = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+	.init = mx28evk_enet_gpio_init,
+};
+
+static struct fec_platform_data fec_pdata1 = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+	.init = mx28evk_enet_gpio_init,
+};
+
+static void __init mx28_init_fec(void)
+{
+	struct platform_device *pdev;
+	struct mxs_dev_lookup *lookup;
+	int i;
+
+	lookup = mxs_get_devices("mxs-fec");
+	if (lookup == NULL || IS_ERR(lookup))
+		return;
+
+	for (i = 0; i < lookup->size; i++) {
+		pdev = lookup->pdev + i;
+		switch (pdev->id) {
+		case 0:
+			pdev->resource = fec0_resource;
+			pdev->num_resources = ARRAY_SIZE(fec0_resource);
+			pdev->dev.platform_data = &fec_pdata0;
+			break;
+		case 1:
+			pdev->resource = fec1_resource;
+			pdev->num_resources = ARRAY_SIZE(fec1_resource);
+			pdev->dev.platform_data = &fec_pdata1;
+			break;
+		default:
+			return;
+		}
+		mxs_add_device(pdev, 2);
+	}
+}
+#else
+static void __init mx28_init_fec(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_FEC_L2SWITCH)
+static struct resource l2switch_resources[] = {
+	{
+		.start  = ENET_PHYS_ADDR,
+		.end    = ENET_PHYS_ADDR + 0x17FFC,
+		.flags  = IORESOURCE_MEM
+	},
+	{
+		.start  = IRQ_ENET_SWI,
+		.end    = IRQ_ENET_SWI,
+		.flags  = IORESOURCE_IRQ
+	},
+};
+
+/* Define the fixed address of the L2 Switch hardware. */
+static unsigned int switch_platform_hw[2] = {
+	(0x800F8000),
+	(0x800FC000),
+};
+
+static struct fec_platform_data fec_enet = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+	.init = mx28evk_enet_gpio_init,
+};
+
+static struct switch_platform_data l2switch_data = {
+	.id 		= 0,
+	.fec_enet	= &fec_enet,
+	.hash_table	= 0,
+	.switch_hw	= switch_platform_hw,
+};
+
+static void __init mx28_init_l2switch(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-l2switch", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->resource = l2switch_resources;
+	pdev->num_resources = ARRAY_SIZE(l2switch_resources);
+	pdev->dev.platform_data = &l2switch_data;
+	mxs_add_device(pdev, 2);
+}
+#else
+static void __init mx28_init_l2switch(void)
+{
+	;
+}
+#endif
+
+#ifdef CONFIG_MXS_LRADC
+struct mxs_lradc_plat_data mx28_lradc_data = {
+	.vddio_voltage = BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL10,
+	.battery_voltage = BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL7,
+};
+
+static struct resource mx28_lradc_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+};
+
+static void __init mx28_init_lradc(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-lradc", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx28_lradc_res;
+	pdev->num_resources = ARRAY_SIZE(mx28_lradc_res);
+	pdev->dev.platform_data = &mx28_lradc_data;
+	mxs_add_device(pdev, 0);
+}
+#else
+static void __init mx28_init_lradc(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_KEYBOARD_MXS) || defined(CONFIG_KEYBOARD_MXS_MODULE)
+static struct mxskbd_keypair keyboard_data[] = {
+	{ 100, KEY_F4 },
+	{ 306, KEY_F5 },
+	{ 626, KEY_F6 },
+	{ 932, KEY_F7 },
+	{ 1260, KEY_F8 },
+	{ 1584, KEY_F9 },
+	{ 1907, KEY_F10 },
+	{ 2207, KEY_F11 },
+	{ 2525, KEY_F12 },
+	{ 2831, KEY_F13},
+	{ 3134, KEY_F14 },
+	{ -1, 0 },
+};
+
+static struct mxs_kbd_plat_data mxs_kbd_data = {
+	.keypair = keyboard_data,
+	.channel = LRADC_CH1,
+	.btn_enable = BM_LRADC_CTRL0_BUTTON1_DETECT_ENABLE,
+	.btn_irq_stat = BM_LRADC_CTRL1_BUTTON1_DETECT_IRQ,
+	.btn_irq_ctrl = BM_LRADC_CTRL1_BUTTON1_DETECT_IRQ_EN,
+};
+
+static struct resource mx28_kbd_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LRADC_CH1,
+	 .end   = IRQ_LRADC_CH1,
+	 },
+};
+
+static void __init mx28_init_kbd(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-kbd", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx28_kbd_res;
+	pdev->num_resources = ARRAY_SIZE(mx28_kbd_res);
+	pdev->dev.platform_data = &mxs_kbd_data;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_kbd(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
+static struct mxs_touchscreen_plat_data mx28_ts_data = {
+	.x_plus_chan = LRADC_TOUCH_X_PLUS,
+	.x_minus_chan = LRADC_TOUCH_X_MINUS,
+	.y_plus_chan = LRADC_TOUCH_Y_PLUS,
+	.y_minus_chan = LRADC_TOUCH_Y_MINUS,
+	.x_plus_val = BM_LRADC_CTRL0_XPULSW,
+	.x_minus_val = BF_LRADC_CTRL0_XNURSW(2),
+	.y_plus_val = BF_LRADC_CTRL0_YPLLSW(1),
+	.y_minus_val = BM_LRADC_CTRL0_YNLRSW,
+	.x_plus_mask = BM_LRADC_CTRL0_XPULSW,
+	.x_minus_mask = BM_LRADC_CTRL0_XNURSW,
+	.y_plus_mask = BM_LRADC_CTRL0_YPLLSW,
+	.y_minus_mask = BM_LRADC_CTRL0_YNLRSW,
+};
+
+static struct resource mx28_ts_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = LRADC_PHYS_ADDR,
+	 .end   = LRADC_PHYS_ADDR + 0x2000 - 1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LRADC_TOUCH,
+	 .end   = IRQ_LRADC_TOUCH,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_LRADC_CH5,
+	 .end   = IRQ_LRADC_CH5,
+	 },
+};
+
+static void __init mx28_init_ts(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-ts", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = mx28_ts_res;
+	pdev->num_resources = ARRAY_SIZE(mx28_ts_res);
+	pdev->dev.platform_data = &mx28_ts_data;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_ts(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
+static void flexcan_xcvr_enable(int id, int en)
+{
+	static int pwdn;
+	if (en) {
+		if (!pwdn++)
+			gpio_set_value(MXS_PIN_TO_GPIO(PINID_SSP1_CMD), 1);
+	} else {
+		if (!--pwdn)
+			gpio_set_value(MXS_PIN_TO_GPIO(PINID_SSP1_CMD), 0);
+	}
+}
+
+struct flexcan_platform_data flexcan_data[] = {
+	{
+	.core_reg = NULL,
+	.io_reg = NULL,
+	.xcvr_enable = flexcan_xcvr_enable,
+	.br_clksrc = 1,
+	.br_rjw = 2,
+	.br_presdiv = 2,
+	.br_propseg = 2,
+	.br_pseg1 = 3,
+	.br_pseg2 = 7,
+	.bcc = 1,
+	.srx_dis = 1,
+	.smp = 1,
+	.boff_rec = 1,
+	.ext_msg = 1,
+	.std_msg = 1,
+	},
+	{
+	.core_reg = NULL,
+	.io_reg = NULL,
+	.xcvr_enable = flexcan_xcvr_enable,
+	.br_clksrc = 1,
+	.br_rjw = 2,
+	.br_presdiv = 2,
+	.br_propseg = 2,
+	.br_pseg1 = 3,
+	.br_pseg2 = 7,
+	.bcc = 1,
+	.srx_dis = 1,
+	.boff_rec = 1,
+	.ext_msg = 1,
+	.std_msg = 1,
+	},
+};
+
+static struct resource flexcan0_resources[] = {
+	{
+	    .start = CAN0_PHYS_ADDR,
+	    .end = CAN0_PHYS_ADDR + 0x1FFF,
+	    .flags = IORESOURCE_MEM,},
+	{
+	    .start = IRQ_CAN0,
+	    .end = IRQ_CAN0,
+	    .flags = IORESOURCE_IRQ,},
+};
+static struct resource flexcan1_resources[] = {
+	{
+	    .start = CAN1_PHYS_ADDR,
+	    .end = CAN1_PHYS_ADDR + 0x1FFF,
+	    .flags = IORESOURCE_MEM,},
+	{
+	    .start = IRQ_CAN1,
+	    .end = IRQ_CAN1,
+	    .flags = IORESOURCE_IRQ,},
+};
+
+static inline void mx28_init_flexcan(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("FlexCAN", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = flexcan0_resources;
+	pdev->num_resources = ARRAY_SIZE(flexcan0_resources);
+	pdev->dev.platform_data = &flexcan_data[0];
+	mxs_add_device(pdev, 2);
+
+	pdev = mxs_get_device("FlexCAN", 1);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = flexcan1_resources;
+	pdev->num_resources = ARRAY_SIZE(flexcan1_resources);
+	pdev->dev.platform_data = &flexcan_data[1];
+	mxs_add_device(pdev, 2);
+}
+#else
+static inline void mx28_init_flexcan(void)
+{
+}
+#endif
+#if defined(CONFIG_BATTERY_MXS)
+/* battery info data */
+static ddi_bc_Cfg_t battery_data = {
+	.u32StateMachinePeriod		 = 100,		/* ms */
+	.u16CurrentRampSlope		 = 75,		/* mA/s */
+	.u16ConditioningThresholdVoltage = 2900, 	/* mV */
+	.u16ConditioningMaxVoltage	 = 3000,	/* mV */
+	.u16ConditioningCurrent		 = 160,		/* mA */
+	.u32ConditioningTimeout		 = 4*60*60*1000, /* ms (4 hours) */
+	.u16ChargingVoltage		 = 4200,	/* mV */
+	/* FIXME: the current comparator could have h/w bugs in current
+	 * detection through POWER_STS.CHRGSTS bit */
+	.u16ChargingCurrent		 = 600,		/* mA 600 */
+	.u16ChargingThresholdCurrent	 = 60,		/* mA 60 */
+	.u32ChargingTimeout		 = 4*60*60*1000,/* ms (4 hours) */
+	.u32TopOffPeriod		 = 30*60*1000,	/* ms (30 minutes) */
+	.monitorDieTemp			 = 1,		/* Monitor the die */
+	.u8DieTempHigh			 = 75,		/* deg centigrade */
+	.u8DieTempLow			 = 65,		/* deg centigrade */
+	.u16DieTempSafeCurrent		 = 0,		/* mA */
+	.monitorBatteryTemp		 = 0,		/* Monitor the battery*/
+	.u8BatteryTempChannel		 = 0,		/* LRADC 0 */
+	.u16BatteryTempHigh		 = 642,		/* Unknown units */
+	.u16BatteryTempLow		 = 497,		/* Unknown units */
+	.u16BatteryTempSafeCurrent	 = 0,		/* mA */
+};
+
+static struct resource battery_resource[] = {
+	{/* 0 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDD5V,
+		.end    = IRQ_VDD5V,
+	},
+	{/* 1 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_DCDC4P2_BRNOUT,
+		.end    = IRQ_DCDC4P2_BRNOUT,
+	},
+	{/* 2 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_BATT_BRNOUT,
+		.end    = IRQ_BATT_BRNOUT,
+	},
+	{/* 3 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDDD_BRNOUT,
+		.end    = IRQ_VDDD_BRNOUT,
+	},
+	{/* 4 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDDA_BRNOUT,
+		.end    = IRQ_VDDA_BRNOUT,
+	},
+	{/* 5 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDDIO_BRNOUT,
+		.end    = IRQ_VDDIO_BRNOUT,
+	},
+	{/* 6 */
+		.flags  = IORESOURCE_IRQ,
+		.start  = IRQ_VDD5V_DROOP,
+		.end    = IRQ_VDD5V_DROOP,
+	},
+};
+
+static void mx28_init_battery(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-battery", 0);
+	if (pdev) {
+		pdev->resource = battery_resource,
+		pdev->num_resources = ARRAY_SIZE(battery_resource),
+		pdev->dev.platform_data = &battery_data;
+		mxs_add_device(pdev, 3);
+	}
+}
+#else
+static void mx28_init_battery(void)
+{
+}
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_DCP)
+
+static struct resource dcp_resources[] = {
+
+	{
+		.flags = IORESOURCE_MEM,
+		.start = DCP_PHYS_ADDR,
+		.end   = DCP_PHYS_ADDR + 0x2000 - 1,
+	}, {
+		.flags = IORESOURCE_IRQ,
+		.start = IRQ_DCP_VMI,
+		.end = IRQ_DCP_VMI,
+	}, {
+		.flags = IORESOURCE_IRQ,
+		.start = IRQ_DCP,
+		.end = IRQ_DCP,
+	},
+};
+
+static void __init mx28_init_dcp(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("dcp", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->resource = dcp_resources;
+	pdev->num_resources = ARRAY_SIZE(dcp_resources);
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28_init_dcp(void)
+{
+	;
+}
+#endif
+
+#if defined(CONFIG_SND_MXS_SOC_DAI) || defined(CONFIG_SND_MXS_SOC_DAI_MODULE)
+static int audio_clk_init(struct clk *clk)
+{
+	struct clk *pll_clk;
+	struct clk *saif_mclk0;
+	struct clk *saif_mclk1;
+	int ret = -EINVAL;
+	if (IS_ERR(clk)) {
+		pr_err("%s:failed to get clk\n", __func__);
+		goto err_clk_init;
+	}
+	pll_clk = clk_get(NULL, "pll.0");
+	if (IS_ERR(pll_clk)) {
+		pr_err("%s:failed to get pll_clk\n", __func__);
+		goto err_clk_init;
+	}
+	saif_mclk0 = clk_get(NULL, "saif_mclk.0");
+	if (IS_ERR(saif_mclk0)) {
+		pr_err("%s:failed to get saif_mclk\n", __func__);
+		goto err_clk_init;
+	}
+	saif_mclk1 = clk_get(NULL, "saif_mclk.1");
+	if (IS_ERR(saif_mclk1)) {
+		pr_err("%s:failed to get saif_mclk\n", __func__);
+		goto err_clk_init;
+	}
+	ret = clk_set_parent(clk, pll_clk);
+	if (ret) {
+		pr_err("%s:failed to set parent clk\n", __func__);
+		goto err_clk_init;
+	}
+	ret = 0;
+	/*set a default freq of 12M to sgtl5000*/
+	clk_set_rate(clk, 12000000);
+	clk_enable(clk);
+	/*set the saif clk mux, saif0/saif1 both use saif0 clk*/
+	__raw_writel(BF_DIGCTL_CTRL_SAIF_CLKMUX_SEL(0x2), \
+			IO_ADDRESS(DIGCTL_PHYS_ADDR) + HW_DIGCTL_CTRL);
+
+	/*enable saif0/saif1 clk output*/
+	clk_enable(saif_mclk0);
+	clk_enable(saif_mclk1);
+err_clk_init:
+	return ret;
+}
+
+static int audio_clk_finit(void)
+{
+	struct clk *saif_clk;
+	struct clk *saif_mclk0;
+	struct clk *saif_mclk1;
+	int ret = 0;
+	saif_clk = clk_get(NULL, "saif.0");
+	if (IS_ERR(saif_clk)) {
+		pr_err("%s:failed to get saif_clk\n", __func__);
+		ret = -EINVAL;
+		goto err_clk_finit;
+	}
+	clk_disable(saif_clk);
+
+	saif_mclk0 = clk_get(NULL, "saif_mclk.0");
+	if (IS_ERR(saif_mclk0)) {
+		pr_err("%s:failed to get saif_mclk\n", __func__);
+		goto err_clk_finit;
+	}
+	clk_disable(saif_mclk0);
+
+	saif_mclk1 = clk_get(NULL, "saif_mclk.1");
+	if (IS_ERR(saif_mclk1)) {
+		pr_err("%s:failed to get saif_mclk\n", __func__);
+		goto err_clk_finit;
+	}
+	clk_disable(saif_mclk1);
+err_clk_finit:
+	return ret;
+}
+
+static struct mxs_audio_platform_data audio_plat_data;
+#endif
+
+#if defined(CONFIG_SND_SOC_SGTL5000) || defined(CONFIG_SND_SOC_SGTL5000_MODULE)
+void __init mx28_init_audio(void)
+{	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-sgtl5000", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	mxs_add_device(pdev, 3);
+	audio_plat_data.saif_mclock = clk_get(NULL, "saif.0");
+	audio_clk_init(audio_plat_data.saif_mclock);
+	pdev->dev.platform_data = &audio_plat_data;
+}
+#else
+void __init mx28_init_audio(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+       defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+void __init mx28_init_spdif(void)
+{	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-spdif", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	mxs_add_device(pdev, 3);
+}
+#else
+static inline mx28_init_spdif(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXS_PERSISTENT)
+static const struct mxs_persistent_bit_config
+mx28_persistent_bit_config[] = {
+	{ .reg = 0, .start =  0, .width =  1,
+		.name = "CLOCKSOURCE" },
+	{ .reg = 0, .start =  1, .width =  1,
+		.name = "ALARM_WAKE_EN" },
+	{ .reg = 0, .start =  2, .width =  1,
+		.name = "ALARM_EN" },
+	{ .reg = 0, .start =  3, .width =  1,
+		.name = "CLK_SECS" },
+	{ .reg = 0, .start =  4, .width =  1,
+		.name = "XTAL24MHZ_PWRUP" },
+	{ .reg = 0, .start =  5, .width =  1,
+		.name = "XTAL32MHZ_PWRUP" },
+	{ .reg = 0, .start =  6, .width =  1,
+		.name = "XTAL32_FREQ" },
+	{ .reg = 0, .start =  7, .width =  1,
+		.name = "ALARM_WAKE" },
+	{ .reg = 0, .start =  8, .width =  5,
+		.name = "MSEC_RES" },
+	{ .reg = 0, .start = 13, .width =  1,
+		.name = "DISABLE_XTALOK" },
+	{ .reg = 0, .start = 14, .width =  2,
+		.name = "LOWERBIAS" },
+	{ .reg = 0, .start = 16, .width =  1,
+		.name = "DISABLE_PSWITCH" },
+	{ .reg = 0, .start = 17, .width =  1,
+		.name = "AUTO_RESTART" },
+	{ .reg = 0, .start = 18, .width = 1,
+		.name = "ENABLE_LRADC_PWRUP" },
+	{ .reg = 0, .start = 20, .width = 1,
+		.name = "THERMAL_RESET" },
+	{ .reg = 0, .start = 21, .width = 1,
+		.name = "EXTERNAL_RESET" },
+	{ .reg = 0, .start = 28, .width = 4,
+		.name = "ADJ_POSLIMITBUCK" },
+	{ .reg = 1, .start =  0, .width =  1,
+		.name = "FORCE_RECOVERY" },
+	{ .reg = 1, .start =  1, .width =  1,
+		.name = "ROM_REDUNDANT_BOOT" },
+	{ .reg = 1, .start =  2, .width =  1,
+		.name = "NAND_SDK_BLOCK_REWRITE" },
+	{ .reg = 1, .start =  3, .width =  1,
+		.name = "SD_SPEED_ENABLE" },
+	{ .reg = 1, .start =  4, .width =  1,
+		.name = "SD_INIT_SEQ_1_DISABLE" },
+	{ .reg = 1, .start =  5, .width =  1,
+		.name = "SD_CMD0_DISABLE" },
+	{ .reg = 1, .start =  6, .width =  1,
+		.name = "SD_INIT_SEQ_2_ENABLE" },
+	{ .reg = 1, .start =  7, .width =  1,
+		.name = "OTG_ATL_ROLE_BIT" },
+	{ .reg = 1, .start =  8, .width =  1,
+		.name = "OTG_HNP_BIT" },
+	{ .reg = 1, .start =  9, .width =  1,
+		.name = "USB_LOW_POWER_MODE" },
+	{ .reg = 1, .start = 10, .width =  1,
+		.name = "SKIP_CHECKDISK" },
+	{ .reg = 1, .start = 11, .width =  1,
+		.name = "USB_BOOT_PLAYER_MODE" },
+	{ .reg = 1, .start = 12, .width =  1,
+		.name = "ENUMERATE_500MA_TWICE" },
+	{ .reg = 1, .start = 13, .width = 19,
+		.name = "SPARE_GENERAL" },
+
+	{ .reg = 2, .start =  0, .width = 32,
+		.name = "SPARE_2" },
+	{ .reg = 3, .start =  0, .width = 32,
+		.name = "SPARE_3" },
+	{ .reg = 4, .start =  0, .width = 32,
+		.name = "SPARE_4" },
+	{ .reg = 5, .start =  0, .width = 32,
+		.name = "SPARE_5" },
+};
+
+static struct mxs_platform_persistent_data mx28_persistent_data = {
+	.bit_config_tab = mx28_persistent_bit_config,
+	.bit_config_cnt = ARRAY_SIZE(mx28_persistent_bit_config),
+};
+
+static struct resource mx28_persistent_res[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = RTC_PHYS_ADDR,
+	 .end   = RTC_PHYS_ADDR + 0x2000 - 1,
+	 },
+};
+
+static void mx28_init_persistent(void)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-persistent", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+	pdev->dev.platform_data = &mx28_persistent_data;
+	pdev->resource = mx28_persistent_res,
+	pdev->num_resources = ARRAY_SIZE(mx28_persistent_res),
+	mxs_add_device(pdev, 3);
+}
+#else
+static void mx28_init_persistent()
+{
+}
+#endif
+
+int __init mx28_device_init(void)
+{
+	mx28_init_dma();
+	mx28_init_viim();
+	mx28_init_duart();
+	mx28_init_i2c();
+	mx28_init_lradc();
+	mx28_init_auart();
+	mx28_init_mmc();
+	mx28_init_gpmi_nfc();
+	mx28_init_wdt();
+	mx28_init_rtc();
+	mx28_init_fec();
+	mx28_init_l2switch();
+	mx28_init_flexcan();
+	mx28_init_kbd();
+	mx28_init_ts();
+	mx28_init_audio();
+	mx28_init_spdif();
+	mx28_init_lcdif();
+	mx28_init_pxp();
+	mx28_init_dcp();
+	mx28_init_battery();
+	mx28_init_persistent();
+	return 0;
+}
+
+static struct __initdata map_desc mx28_io_desc[] = {
+	{
+	 .virtual = MX28_SOC_IO_VIRT_BASE,
+	 .pfn = __phys_to_pfn(MX28_SOC_IO_PHYS_BASE),
+	 .length = MX28_SOC_IO_AREA_SIZE,
+	 .type = MT_DEVICE,
+	 },
+	 {
+	 .virtual = MX28_OCRAM_BASE,
+	 .pfn = __phys_to_pfn(MX28_OCRAM_PHBASE),
+	 .length = MX28_OCRAM_SIZE,
+	 .type	= MT_DEVICE,
+	 }
+};
+
+void __init mx28_map_io(void)
+{
+	iotable_init(mx28_io_desc, ARRAY_SIZE(mx28_io_desc));
+}
+
+void __init mx28_irq_init(void)
+{
+	avic_init_irq(IO_ADDRESS(ICOLL_PHYS_ADDR), ARCH_NR_IRQS);
+}
+
+static void mx28_timer_init(void)
+{
+	int i, reg;
+	mx28_clock_init();
+
+	mx28_timer.clk = clk_get(NULL, "clk_32k");
+	if (mx28_timer.clk == NULL || IS_ERR(mx28_timer.clk))
+		return;
+	__raw_writel(BM_TIMROT_ROTCTRL_SFTRST,
+		     mx28_timer.base + HW_TIMROT_ROTCTRL_CLR);
+	for (i = 0; i < 10000; i++) {
+		reg = __raw_readl(mx28_timer.base + HW_TIMROT_ROTCTRL);
+		if (!(reg & BM_TIMROT_ROTCTRL_SFTRST))
+			break;
+		udelay(2);
+	}
+	if (i >= 10000)
+		return;
+	__raw_writel(BM_TIMROT_ROTCTRL_CLKGATE,
+		     mx28_timer.base + HW_TIMROT_ROTCTRL_CLR);
+
+	reg = __raw_readl(mx28_timer.base + HW_TIMROT_ROTCTRL);
+	for (i = 0; i < 4; i++) {
+		if (!(reg & (BM_TIMROT_ROTCTRL_TIM0_PRESENT << i)))
+			continue;
+		mx28_timer.id = i;
+		mx28_timer.irq = IRQ_TIMER0 + i;
+		mxs_timer_init(&mx28_timer);
+		return;
+	}
+}
+
+struct mxs_sys_timer mx28_timer = {
+	.timer = {
+		  .init = mx28_timer_init,
+		  },
+	.clk_sel = BV_TIMROT_TIMCTRLn_SELECT__32KHZ_XTAL,
+	.base = IO_ADDRESS(TIMROT_PHYS_ADDR),
+};
+
diff --git a/arch/arm/mach-mx28/device.h b/arch/arm/mach-mx28/device.h
new file mode 100644
index 0000000..6fac8f6
--- /dev/null
+++ b/arch/arm/mach-mx28/device.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_DEVICE_H__
+#define __ASM_ARCH_MACH_DEVICE_H__
+
+extern struct mxs_sys_timer mx28_timer;
+
+extern void __init mx28_map_io(void);
+extern void __init mx28_clock_init(void);
+extern void __init mx28_irq_init(void);
+extern int __init mx28_pinctrl_init(void);
+extern int __init mx28_gpio_init(void);
+extern int __init mx28_device_init(void);
+extern void __init mx28_init_auart(void);
+extern void __init
+mx28_set_input_clk(unsigned long, unsigned long, unsigned long, unsigned long);
+
+#endif
diff --git a/arch/arm/mach-mx28/emi.S b/arch/arm/mach-mx28/emi.S
new file mode 100644
index 0000000..ec25b4e
--- /dev/null
+++ b/arch/arm/mach-mx28/emi.S
@@ -0,0 +1,220 @@
+/*
+ * Freescale MX28 low level RAM frequency manipulation
+ *
+ * Author: Vitaly Wool <vital@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/system.h>
+#include <asm/pgtable-hwdef.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-power.h>
+#include "regs-clkctrl.h"
+#include "regs-dram.h"
+#include "regs-digctl.h"
+
+#include "emi_settings.h"
+
+.global cpu_arm926_switch_mm
+
+.align 8
+ENTRY(mxs_ram_freq_scale)
+	stmfd	sp!, {r1 - r10, lr}
+	ldr	r5, [r0, #SCALING_DATA_NEW_FREQ_OFFSET]
+	ldr	r6, [r0, #SCALING_DATA_CUR_FREQ_OFFSET]
+	ldr	r7, [r0, #SCALING_DATA_EMI_DIV_OFFSET]
+	mov	r7, r7,	LSL #BP_CLKCTRL_EMI_DIV_EMI
+	ldr	r8, [r0, #SCALING_DATA_FRAC_DIV_OFFSET]
+	mov	r8, r8,	LSL #BP_CLKCTRL_FRAC0_EMIFRAC
+
+	@copy memory setting to iram
+	mov	r2, #MX28_DRAMCTRLREGNUM
+	adr	r0, __mx28_emisetting
+1:	ldr	r3, [r1]
+	str 	r3, [r0]
+	add 	r0, r0, #4
+	add 	r1, r1, #4
+	subs 	r2, r2, #1
+	bne 1b
+
+	@set temp static to iram.
+	adr	r9, __mxs_temp_stack
+
+	@ clean cache
+	ldr	r1, __mxs_flush_cache_addr
+	mov	lr, pc
+	mov	pc, r1
+
+	mov r2, #MX28_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR)&0xFF
+	orr r2, r2,  #MX28_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR)&0xFF00
+	orr r2, r2,  #MX28_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR)&0xFF0000
+	orr r2, r2,  #MX28_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR)&0xFF000000
+
+	mov r0, r2
+	bl lock_vector_tlb
+
+	mov r0, #MX28_SOC_IO_ADDRESS(DRAM_PHYS_ADDR)&0xFF
+	orr r0, r0, #MX28_SOC_IO_ADDRESS(DRAM_PHYS_ADDR)&0xFF00
+	orr r0, r0, #MX28_SOC_IO_ADDRESS(DRAM_PHYS_ADDR)&0xFF0000
+	orr r0, r0, #MX28_SOC_IO_ADDRESS(DRAM_PHYS_ADDR)&0xFF000000
+
+	@ Make sure emi not busy
+2:
+	ldr r1, [r0, #HW_DRAM_CTL08]
+	tst r1, #BM_DRAM_CTL08_CONTROLLER_BUSY
+	bne 2b
+
+	@ put DRAM into self refresh
+	ldr r1, [r0, #HW_DRAM_CTL17]
+	orr r1, r1, #BM_DRAM_CTL17_SREFRESH
+	str	r1,  [r0, #HW_DRAM_CTL17]
+3:
+	ldr r1, [r0, #HW_DRAM_CTL172]
+	tst r1, #BM_DRAM_CTL172_CKE_STATUS
+	beq 3b
+
+	ldr r1, [r0, #HW_DRAM_CTL58]
+	orr r1, #BF_DRAM_CTL58_INT_MASK(0x100)
+	str r1, [r0, #HW_DRAM_CTL58]
+
+	@stop emi controller
+	ldr r1, [r0, #HW_DRAM_CTL16]
+	bic r1, r1, #BM_DRAM_CTL16_START
+	str r1, [r0, #HW_DRAM_CTL16]
+
+	@clear lock status HW_DRAM_CTL164_CLR(BF_DRAM_CTL164_INT_ACK(0x3ff));
+	ldr r1, [r0, #HW_DRAM_CTL164]
+	bic r1, r1, #BF_DRAM_CTL164_INT_ACK(0xff)
+	bic r1, r1, #BF_DRAM_CTL164_INT_ACK(0x300)
+	str r1, [r0, #HW_DRAM_CTL164]
+
+	ldr r1, [r2, #HW_CLKCTRL_FRAC0]
+	and r1, #BM_CLKCTRL_FRAC0_EMIFRAC
+	ldr r3, [r2, #HW_CLKCTRL_EMI]
+	and r3, #BM_CLKCTRL_EMI_DIV_EMI
+
+/*
+ *	The fractional divider and integer divider must be written in such
+ *	an order to guarantee that when going from a lower frequency to a
+ *	higher frequency that any intermediate frequencies do not exceed
+ *	the final frequency. For this reason, we must make sure to check
+ *	the current divider values with the new divider values and write
+ *	them in the correct order.
+ */
+
+	ldr r9, [r2, #HW_CLKCTRL_FRAC0]
+	bic r9, #BM_CLKCTRL_FRAC0_EMIFRAC
+	orr r9, r8
+
+	ldr r10, [r2, #HW_CLKCTRL_EMI]
+	bic r10, #BM_CLKCTRL_EMI_DIV_EMI
+	orr r10, r7
+
+	cmp r8, r1
+	strgt r9,   [r2, #HW_CLKCTRL_FRAC0]
+	cmp r7, r3
+	strgt r10,  [r2, #HW_CLKCTRL_EMI]
+
+	cmp r8, r1
+	strlt r9,   [r2, #HW_CLKCTRL_FRAC0]
+	cmp r7, r3
+	strlt r10,  [r2, #HW_CLKCTRL_EMI]
+
+	@copy memory setting to iram
+	mov     r3, r0
+	adr     r4, __mx28_emisetting
+	mov 	r6, #MX28_DRAMCTRLREGNUM
+8:	ldr     r5, [r4]
+	str     r5, [r3]
+	add     r3, r3, #4
+	add     r4, r4, #4
+	subs    r6, r6, #1
+	bne 8b
+
+7:      ldr     r1, [r2, #HW_CLKCTRL_EMI]
+        tst     r1, #BM_CLKCTRL_EMI_BUSY_REF_EMI
+	bne     7b
+
+	@Restart memory controller
+	ldr r1, [r0, #HW_DRAM_CTL16]
+	orr r1, #BM_DRAM_CTL16_START
+	str	r1, [r0, #HW_DRAM_CTL16]
+
+	/*Wait DLL is locked*/
+9:
+	ldr r1, [r0, #HW_DRAM_CTL21]
+	tst r1, #BM_DRAM_CTL21_DLLLOCKREG
+	beq 9b
+
+
+    	@11. Exit Memory self-refresh
+	ldr r1, [r0, #HW_DRAM_CTL17]
+	bic r1, r1, #BM_DRAM_CTL17_SREFRESH
+	str r1, [r0, #HW_DRAM_CTL17]
+
+	@Wait Memory device exit into self-refresh
+10:
+	ldr r1, [r0, #HW_DRAM_CTL172]
+	tst r1, #BM_DRAM_CTL172_CKE_STATUS
+	bne 10b
+
+	mov	r2, #MX28_SOC_IO_ADDRESS(DIGCTL_PHYS_ADDR)&0xFF
+	orr	r2, r2, #MX28_SOC_IO_ADDRESS(DIGCTL_PHYS_ADDR)&0xFF00
+	orr	r2, r2, #MX28_SOC_IO_ADDRESS(DIGCTL_PHYS_ADDR)&0xFF0000
+	orr	r2, r2, #MX28_SOC_IO_ADDRESS(DIGCTL_PHYS_ADDR)&0xFF000000
+
+	ldr 	r0, [r2, #HW_DIGCTL_MICROSECONDS];
+	add	r0, #100
+11:	ldr	r1, [r2, #HW_DIGCTL_MICROSECONDS];
+	cmp	r1, r0
+	blt	11b
+
+@ restore regs and return
+	ldmfd   sp!, {r1 - r10, lr}
+	mov	pc, lr
+
+	.space	0x100
+__mxs_temp_stack:
+	.word	0
+__mx28_emisetting:
+	.space MX28_DRAMCTRLREGNUM*4
+
+lock_vector_tlb:
+        mov r1, r0 @ set r1 to the value of the address to be locked down
+        mcr p15,0,r1,c8,c7,1    @ invalidate TLB single entry to ensure that
+                                @ LockAddr is not already in the TLB
+        mrc p15,0,r0,c10,c0,0   @ read the lockdown register
+        orr r0,r0,#1            @ set the preserve bit
+        mcr p15,0,r0,c10,c0,0   @ write to the lockdown register
+        ldr r1,[r1]             @ TLB will miss, and entry will be loaded
+        mrc p15,0,r0,c10,c0,0   @ read the lockdown register (victim will have
+                                @ incremented)
+        bic r0,r0,#1            @ clear preserve bit
+        mcr p15,0,r0,c10,c0,0   @ write to the lockdown registerADR r1,LockAddr
+        mov pc,lr
+
+__mxs_flush_cache_addr:
+	.word	arm926_flush_kern_cache_all
+
+ENTRY(mxs_ram_funcs_sz)
+	.word	. - mxs_ram_freq_scale
+ENTRY(mxs_ram_freq_scale_end)
diff --git a/arch/arm/mach-mx28/emi_settings.c b/arch/arm/mach-mx28/emi_settings.c
new file mode 100644
index 0000000..7dd62b9
--- /dev/null
+++ b/arch/arm/mach-mx28/emi_settings.c
@@ -0,0 +1,680 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/phy.h>
+#include <linux/fec.h>
+
+#include <asm/mach/map.h>
+
+#include <mach/mx28.h>
+#include <mach/clock.h>
+#include "emi_settings.h"
+
+static unsigned int DRAM_REG[MX28_DRAMCTRLREGNUM];
+unsigned int *get_current_emidata()
+{
+	return DRAM_REG;
+}
+
+void test_emi_change()
+{
+	struct mxs_emi_scaling_data emi;
+	void (*f) (struct mxs_emi_scaling_data *, unsigned int *);
+	f = (void *)MX28_OCRAM_BASE;
+	memcpy(f, mxs_ram_freq_scale,
+	       (unsigned int)mxs_ram_freq_scale_end -
+	       (unsigned int)mxs_ram_freq_scale);
+
+	pr_debug("start change emi frequency test\n");
+	pr_debug("begin change 133\n");
+	emi.emi_div = 3;	/* 130Mhz */
+	emi.frac_div = 22;	/* 392Mhz */
+	emi.new_freq = 133;
+	DDR2EmiController_EDE1116_133MHz();
+	f(&emi, get_current_emidata());
+	pr_debug("end change 133\n");
+
+	pr_debug("begin change 166\n");
+	emi.emi_div = 2;	/* 160Mhz */
+	emi.frac_div = 27;	/* 320Mhz */
+	emi.new_freq = 166;
+	DDR2EmiController_EDE1116_166MHz();
+	f(&emi, get_current_emidata());
+	pr_debug("end change 166\n");
+
+	pr_debug("begin change 200\n");
+	emi.emi_div = 2;	/* 192Mhz */
+	emi.frac_div = 22;	/* 392Mhz */
+	emi.new_freq = 200;
+	DDR2EmiController_EDE1116_200MHz();
+	f(&emi, get_current_emidata());
+	pr_debug("end change 200\n");
+
+	pr_debug("begin change 166\n");
+	emi.emi_div = 2;	/* 166Mhz */
+	emi.frac_div = 26;	/* 332Mhz */
+	emi.new_freq = 166;
+	DDR2EmiController_EDE1116_166MHz();
+	f(&emi, get_current_emidata());
+	pr_debug("end change 166\n");
+
+	pr_debug("begin change 133\n");
+	emi.emi_div = 3;	/* 130Mhz */
+	emi.frac_div = 22;	/* 392Mhz */
+	emi.new_freq = 133;
+	DDR2EmiController_EDE1116_133MHz();
+	f(&emi, get_current_emidata());
+	pr_debug("end change 133\n");
+	pr_debug("finish change emi frequency test\n");
+}
+
+void DDR2EmiController_EDE1116_133MHz(void)
+{
+	DRAM_REG[0] = 0x00000000;
+	DRAM_REG[1] = 0x00000000;
+	DRAM_REG[2] = 0x00000000;
+	DRAM_REG[3] = 0x00000000;
+	DRAM_REG[4] = 0x00000000;
+	DRAM_REG[5] = 0x00000000;
+	DRAM_REG[6] = 0x00000000;
+	DRAM_REG[7] = 0x00000000;
+	DRAM_REG[8] = 0x00000000;
+	DRAM_REG[9] = 0x00000000;
+	DRAM_REG[10] = 0x00000000;
+	DRAM_REG[11] = 0x00000000;
+	DRAM_REG[12] = 0x00000000;
+	DRAM_REG[13] = 0x00000000;
+	DRAM_REG[14] = 0x00000000;
+	DRAM_REG[15] = 0x00000000;
+	DRAM_REG[16] = 0x00000000;
+	DRAM_REG[17] = 0x00000100;
+	DRAM_REG[18] = 0x00000000;
+	DRAM_REG[19] = 0x00000000;
+	DRAM_REG[20] = 0x00000000;
+	DRAM_REG[21] = 0x00000000;
+	DRAM_REG[22] = 0x00000000;
+	DRAM_REG[23] = 0x00000000;
+	DRAM_REG[24] = 0x00000000;
+	DRAM_REG[25] = 0x00000000;
+	DRAM_REG[26] = 0x00010101;
+	DRAM_REG[27] = 0x01010101;
+	DRAM_REG[28] = 0x000f0f01;
+	DRAM_REG[29] = 0x0f02020a;
+	DRAM_REG[30] = 0x00000000;
+	DRAM_REG[31] = 0x00010101;
+	DRAM_REG[32] = 0x00000100;
+	DRAM_REG[33] = 0x00000100;
+	DRAM_REG[34] = 0x00000000;
+	DRAM_REG[35] = 0x00000002;
+	DRAM_REG[36] = 0x01010000;
+	DRAM_REG[37] = 0x07080403;
+	DRAM_REG[38] = 0x04003603;
+	DRAM_REG[39] = 0x070000c8;
+	DRAM_REG[40] = 0x0200682b;
+	DRAM_REG[41] = 0x00020208;
+	DRAM_REG[42] = 0x00246c06;
+	DRAM_REG[43] = 0x02110409;
+	DRAM_REG[44] = 0x01020202;
+	DRAM_REG[45] = 0x00c80013;
+	DRAM_REG[46] = 0x00000000;
+	DRAM_REG[47] = 0x00000000;
+	DRAM_REG[48] = 0x00012100;
+	DRAM_REG[49] = 0xffff0303;
+	DRAM_REG[50] = 0x00012100;
+	DRAM_REG[51] = 0xffff0303;
+	DRAM_REG[52] = 0x00012100;
+	DRAM_REG[53] = 0xffff0303;
+	DRAM_REG[54] = 0x00012100;
+	DRAM_REG[55] = 0xffff0303;
+	DRAM_REG[56] = 0x00000003;
+	DRAM_REG[57] = 0x00000000;
+	DRAM_REG[58] = 0x00000000;
+	DRAM_REG[59] = 0x00000000;
+	DRAM_REG[60] = 0x00000000;
+	DRAM_REG[61] = 0x00000000;
+	DRAM_REG[62] = 0x00000000;
+	DRAM_REG[63] = 0x00000000;
+	DRAM_REG[64] = 0x00000000;
+	DRAM_REG[65] = 0x00000000;
+	DRAM_REG[66] = 0x00000409;
+	DRAM_REG[67] = 0x01000f02;
+	DRAM_REG[68] = 0x04090409;
+	DRAM_REG[69] = 0x00000200;
+	DRAM_REG[70] = 0x00020006;
+	DRAM_REG[71] = 0xf4004a27;
+	DRAM_REG[72] = 0xf4004a27;
+	DRAM_REG[73] = 0xf4004a27;
+	DRAM_REG[74] = 0xf4004a27;
+	DRAM_REG[75] = 0x07400300;
+	DRAM_REG[76] = 0x07400300;
+	DRAM_REG[77] = 0x07400300;
+	DRAM_REG[78] = 0x07400300;
+	DRAM_REG[79] = 0x00000005;
+	DRAM_REG[80] = 0x00000000;
+	DRAM_REG[81] = 0x00000000;
+	DRAM_REG[82] = 0x01000000;
+	DRAM_REG[83] = 0x01020408;
+	DRAM_REG[84] = 0x08040201;
+	DRAM_REG[85] = 0x000f1133;
+	DRAM_REG[86] = 0x00000000;
+	DRAM_REG[87] = 0x00001f04;
+	DRAM_REG[88] = 0x00001f04;
+	DRAM_REG[89] = 0x00001f04;
+	DRAM_REG[90] = 0x00001f04;
+	DRAM_REG[91] = 0x00001f04;
+	DRAM_REG[92] = 0x00001f04;
+	DRAM_REG[93] = 0x00001f04;
+	DRAM_REG[94] = 0x00001f04;
+	DRAM_REG[95] = 0x00000000;
+	DRAM_REG[96] = 0x00000000;
+	DRAM_REG[97] = 0x00000000;
+	DRAM_REG[98] = 0x00000000;
+	DRAM_REG[99] = 0x00000000;
+	DRAM_REG[100] = 0x00000000;
+	DRAM_REG[101] = 0x00000000;
+	DRAM_REG[102] = 0x00000000;
+	DRAM_REG[103] = 0x00000000;
+	DRAM_REG[104] = 0x00000000;
+	DRAM_REG[105] = 0x00000000;
+	DRAM_REG[106] = 0x00000000;
+	DRAM_REG[107] = 0x00000000;
+	DRAM_REG[108] = 0x00000000;
+	DRAM_REG[109] = 0x00000000;
+	DRAM_REG[110] = 0x00000000;
+	DRAM_REG[111] = 0x00000000;
+	DRAM_REG[112] = 0x00000000;
+	DRAM_REG[113] = 0x00000000;
+	DRAM_REG[114] = 0x00000000;
+	DRAM_REG[115] = 0x00000000;
+	DRAM_REG[116] = 0x00000000;
+	DRAM_REG[117] = 0x00000000;
+	DRAM_REG[118] = 0x00000000;
+	DRAM_REG[119] = 0x00000000;
+	DRAM_REG[120] = 0x00000000;
+	DRAM_REG[121] = 0x00000000;
+	DRAM_REG[122] = 0x00000000;
+	DRAM_REG[123] = 0x00000000;
+	DRAM_REG[124] = 0x00000000;
+	DRAM_REG[125] = 0x00000000;
+	DRAM_REG[126] = 0x00000000;
+	DRAM_REG[127] = 0x00000000;
+	DRAM_REG[128] = 0x00000000;
+	DRAM_REG[129] = 0x00000000;
+	DRAM_REG[130] = 0x00000000;
+	DRAM_REG[131] = 0x00000000;
+	DRAM_REG[132] = 0x00000000;
+	DRAM_REG[133] = 0x00000000;
+	DRAM_REG[134] = 0x00000000;
+	DRAM_REG[135] = 0x00000000;
+	DRAM_REG[136] = 0x00000000;
+	DRAM_REG[137] = 0x00000000;
+	DRAM_REG[138] = 0x00000000;
+	DRAM_REG[139] = 0x00000000;
+	DRAM_REG[140] = 0x00000000;
+	DRAM_REG[141] = 0x00000000;
+	DRAM_REG[142] = 0x00000000;
+	DRAM_REG[143] = 0x00000000;
+	DRAM_REG[144] = 0x00000000;
+	DRAM_REG[145] = 0x00000000;
+	DRAM_REG[146] = 0x00000000;
+	DRAM_REG[147] = 0x00000000;
+	DRAM_REG[148] = 0x00000000;
+	DRAM_REG[149] = 0x00000000;
+	DRAM_REG[150] = 0x00000000;
+	DRAM_REG[151] = 0x00000000;
+	DRAM_REG[152] = 0x00000000;
+	DRAM_REG[153] = 0x00000000;
+	DRAM_REG[154] = 0x00000000;
+	DRAM_REG[155] = 0x00000000;
+	DRAM_REG[156] = 0x00000000;
+	DRAM_REG[157] = 0x00000000;
+	DRAM_REG[158] = 0x00000000;
+	DRAM_REG[159] = 0x00000000;
+	DRAM_REG[160] = 0x00000000;
+	DRAM_REG[161] = 0x00000000;
+	DRAM_REG[162] = 0x00010000;
+	DRAM_REG[163] = 0x00030404;
+	DRAM_REG[164] = 0x00000002;
+	DRAM_REG[165] = 0x00000000;
+	DRAM_REG[166] = 0x00000000;
+	DRAM_REG[167] = 0x00000000;
+	DRAM_REG[168] = 0x00000000;
+	DRAM_REG[169] = 0x00000000;
+	DRAM_REG[170] = 0x00000000;
+	DRAM_REG[171] = 0x01010000;
+	DRAM_REG[172] = 0x01000000;
+	DRAM_REG[173] = 0x03030000;
+	DRAM_REG[174] = 0x00010303;
+	DRAM_REG[175] = 0x01020202;
+	DRAM_REG[176] = 0x00000000;
+	DRAM_REG[177] = 0x02030303;
+	DRAM_REG[178] = 0x21002103;
+	DRAM_REG[179] = 0x00040900;
+	DRAM_REG[180] = 0x04090409;
+	DRAM_REG[181] = 0x02420242;
+	DRAM_REG[182] = 0x02420242;
+	DRAM_REG[183] = 0x00040004;
+	DRAM_REG[184] = 0x00040004;
+	DRAM_REG[185] = 0x00000000;
+	DRAM_REG[186] = 0x00000000;
+	DRAM_REG[187] = 0x00000000;
+	DRAM_REG[188] = 0x00000000;
+	DRAM_REG[189] = 0xffffffff;
+
+}
+
+void DDR2EmiController_EDE1116_166MHz(void)
+{
+
+	DRAM_REG[0] = 0x00000000;
+	DRAM_REG[1] = 0x00000000;
+	DRAM_REG[2] = 0x00000000;
+	DRAM_REG[3] = 0x00000000;
+	DRAM_REG[4] = 0x00000000;
+	DRAM_REG[5] = 0x00000000;
+	DRAM_REG[6] = 0x00000000;
+	DRAM_REG[7] = 0x00000000;
+	DRAM_REG[8] = 0x00000000;
+	DRAM_REG[9] = 0x00000000;
+	DRAM_REG[10] = 0x00000000;
+	DRAM_REG[11] = 0x00000000;
+	DRAM_REG[12] = 0x00000000;
+	DRAM_REG[13] = 0x00000000;
+	DRAM_REG[14] = 0x00000000;
+	DRAM_REG[15] = 0x00000000;
+	DRAM_REG[16] = 0x00000000;
+	DRAM_REG[17] = 0x00000100;
+	DRAM_REG[18] = 0x00000000;
+	DRAM_REG[19] = 0x00000000;
+	DRAM_REG[20] = 0x00000000;
+	DRAM_REG[21] = 0x00000000;
+	DRAM_REG[22] = 0x00000000;
+	DRAM_REG[23] = 0x00000000;
+	DRAM_REG[24] = 0x00000000;
+	DRAM_REG[25] = 0x00000000;
+	DRAM_REG[26] = 0x00010101;
+	DRAM_REG[27] = 0x01010101;
+	DRAM_REG[28] = 0x000f0f01;
+	DRAM_REG[29] = 0x0f02020a;
+	DRAM_REG[30] = 0x00000000;
+	DRAM_REG[31] = 0x00010101;
+	DRAM_REG[32] = 0x00000100;
+	DRAM_REG[33] = 0x00000100;
+	DRAM_REG[34] = 0x00000000;
+	DRAM_REG[35] = 0x00000002;
+	DRAM_REG[36] = 0x01010000;
+	DRAM_REG[37] = 0x07080403;
+	DRAM_REG[38] = 0x06004303;
+	DRAM_REG[39] = 0x090000c8;
+	DRAM_REG[40] = 0x02008236;
+	DRAM_REG[41] = 0x0002030a;
+	DRAM_REG[42] = 0x002d8908;
+	DRAM_REG[43] = 0x0316050e;
+	DRAM_REG[44] = 0x02030202;
+	DRAM_REG[45] = 0x00c80017;
+	DRAM_REG[46] = 0x00000000;
+	DRAM_REG[47] = 0x00000000;
+	DRAM_REG[48] = 0x00012100;
+	DRAM_REG[49] = 0xffff0303;
+	DRAM_REG[50] = 0x00012100;
+	DRAM_REG[51] = 0xff000303;
+	DRAM_REG[52] = 0x00012100;
+	DRAM_REG[53] = 0xffff0303;
+	DRAM_REG[54] = 0x00012100;
+	DRAM_REG[55] = 0xffff0303;
+	DRAM_REG[56] = 0x00000003;
+	DRAM_REG[57] = 0x00000000;
+	DRAM_REG[58] = 0x00000000;
+	DRAM_REG[59] = 0x00000000;
+	DRAM_REG[60] = 0x00000000;
+	DRAM_REG[61] = 0x00000000;
+	DRAM_REG[62] = 0x00000000;
+	DRAM_REG[63] = 0x00000000;
+	DRAM_REG[64] = 0x00000000;
+	DRAM_REG[65] = 0x00000000;
+	DRAM_REG[66] = 0x0000050e;
+	DRAM_REG[67] = 0x01000f02;
+	DRAM_REG[68] = 0x050e050e;
+	DRAM_REG[69] = 0x00000200;
+	DRAM_REG[70] = 0x00020007;
+	DRAM_REG[71] = 0xf5004a27;
+	DRAM_REG[72] = 0xf5004a27;
+	DRAM_REG[73] = 0xf5004a27;
+	DRAM_REG[74] = 0xf5004a27;
+	DRAM_REG[75] = 0x07400300;
+	DRAM_REG[76] = 0x07400300;
+	DRAM_REG[77] = 0x07400300;
+	DRAM_REG[78] = 0x07400300;
+	DRAM_REG[79] = 0x00000006;
+	DRAM_REG[80] = 0x00000000;
+	DRAM_REG[81] = 0x00000000;
+	DRAM_REG[82] = 0x01000000;
+	DRAM_REG[83] = 0x01020408;
+	DRAM_REG[84] = 0x08040201;
+	DRAM_REG[85] = 0x000f1133;
+	DRAM_REG[86] = 0x00000000;
+	DRAM_REG[87] = 0x00001f04;
+	DRAM_REG[88] = 0x00001f04;
+	DRAM_REG[89] = 0x00001f04;
+	DRAM_REG[90] = 0x00001f04;
+	DRAM_REG[91] = 0x00001f04;
+	DRAM_REG[92] = 0x00001f04;
+	DRAM_REG[93] = 0x00001f04;
+	DRAM_REG[94] = 0x00001f04;
+	DRAM_REG[95] = 0x00000000;
+	DRAM_REG[96] = 0x00000000;
+	DRAM_REG[97] = 0x00000000;
+	DRAM_REG[98] = 0x00000000;
+	DRAM_REG[99] = 0x00000000;
+	DRAM_REG[100] = 0x00000000;
+	DRAM_REG[101] = 0x00000000;
+	DRAM_REG[102] = 0x00000000;
+	DRAM_REG[103] = 0x00000000;
+	DRAM_REG[104] = 0x00000000;
+	DRAM_REG[105] = 0x00000000;
+	DRAM_REG[106] = 0x00000000;
+	DRAM_REG[107] = 0x00000000;
+	DRAM_REG[108] = 0x00000000;
+	DRAM_REG[109] = 0x00000000;
+	DRAM_REG[110] = 0x00000000;
+	DRAM_REG[111] = 0x00000000;
+	DRAM_REG[112] = 0x00000000;
+	DRAM_REG[113] = 0x00000000;
+	DRAM_REG[114] = 0x00000000;
+	DRAM_REG[115] = 0x00000000;
+	DRAM_REG[116] = 0x00000000;
+	DRAM_REG[117] = 0x00000000;
+	DRAM_REG[118] = 0x00000000;
+	DRAM_REG[119] = 0x00000000;
+	DRAM_REG[120] = 0x00000000;
+	DRAM_REG[121] = 0x00000000;
+	DRAM_REG[122] = 0x00000000;
+	DRAM_REG[123] = 0x00000000;
+	DRAM_REG[124] = 0x00000000;
+	DRAM_REG[125] = 0x00000000;
+	DRAM_REG[126] = 0x00000000;
+	DRAM_REG[127] = 0x00000000;
+	DRAM_REG[128] = 0x00000000;
+	DRAM_REG[129] = 0x00000000;
+	DRAM_REG[130] = 0x00000000;
+	DRAM_REG[131] = 0x00000000;
+	DRAM_REG[132] = 0x00000000;
+	DRAM_REG[133] = 0x00000000;
+	DRAM_REG[134] = 0x00000000;
+	DRAM_REG[135] = 0x00000000;
+	DRAM_REG[136] = 0x00000000;
+	DRAM_REG[137] = 0x00000000;
+	DRAM_REG[138] = 0x00000000;
+	DRAM_REG[139] = 0x00000000;
+	DRAM_REG[140] = 0x00000000;
+	DRAM_REG[141] = 0x00000000;
+	DRAM_REG[142] = 0x00000000;
+	DRAM_REG[143] = 0x00000000;
+	DRAM_REG[144] = 0x00000000;
+	DRAM_REG[145] = 0x00000000;
+	DRAM_REG[146] = 0x00000000;
+	DRAM_REG[147] = 0x00000000;
+	DRAM_REG[148] = 0x00000000;
+	DRAM_REG[149] = 0x00000000;
+	DRAM_REG[150] = 0x00000000;
+	DRAM_REG[151] = 0x00000000;
+	DRAM_REG[152] = 0x00000000;
+	DRAM_REG[153] = 0x00000000;
+	DRAM_REG[154] = 0x00000000;
+	DRAM_REG[155] = 0x00000000;
+	DRAM_REG[156] = 0x00000000;
+	DRAM_REG[157] = 0x00000000;
+	DRAM_REG[158] = 0x00000000;
+	DRAM_REG[159] = 0x00000000;
+	DRAM_REG[160] = 0x00000000;
+	DRAM_REG[161] = 0x00000000;
+	DRAM_REG[162] = 0x00010000;
+	DRAM_REG[163] = 0x00030404;
+	DRAM_REG[164] = 0x00000002;
+	DRAM_REG[165] = 0x00000000;
+	DRAM_REG[166] = 0x00000000;
+	DRAM_REG[167] = 0x00000000;
+	DRAM_REG[168] = 0x00000000;
+	DRAM_REG[169] = 0x00000000;
+	DRAM_REG[170] = 0x00000000;
+	DRAM_REG[171] = 0x01010000;
+	DRAM_REG[172] = 0x01000000;
+	DRAM_REG[173] = 0x03030000;
+	DRAM_REG[174] = 0x00010303;
+	DRAM_REG[175] = 0x01020202;
+	DRAM_REG[176] = 0x00000000;
+	DRAM_REG[177] = 0x02040303;
+	DRAM_REG[178] = 0x21002103;
+	DRAM_REG[179] = 0x00050e00;
+	DRAM_REG[180] = 0x050e050e;
+	DRAM_REG[181] = 0x04420442;
+	DRAM_REG[182] = 0x04420442;
+	DRAM_REG[183] = 0x00040004;
+	DRAM_REG[184] = 0x00040004;
+	DRAM_REG[185] = 0x00000000;
+	DRAM_REG[186] = 0x00000000;
+	DRAM_REG[187] = 0x00000000;
+	DRAM_REG[188] = 0x00000000;
+	DRAM_REG[189] = 0xffffffff;
+
+}
+
+void DDR2EmiController_EDE1116_200MHz(void)
+{
+	DRAM_REG[0] = 0x00000000;
+	DRAM_REG[1] = 0x00000000;
+	DRAM_REG[2] = 0x00000000;
+	DRAM_REG[3] = 0x00000000;
+	DRAM_REG[4] = 0x00000000;
+	DRAM_REG[5] = 0x00000000;
+	DRAM_REG[6] = 0x00000000;
+	DRAM_REG[7] = 0x00000000;
+	DRAM_REG[8] = 0x00000000;
+	DRAM_REG[9] = 0x00000000;
+	DRAM_REG[10] = 0x00000000;
+	DRAM_REG[11] = 0x00000000;
+	DRAM_REG[12] = 0x00000000;
+	DRAM_REG[13] = 0x00000000;
+	DRAM_REG[14] = 0x00000000;
+	DRAM_REG[15] = 0x00000000;
+	DRAM_REG[16] = 0x00000000;
+	DRAM_REG[17] = 0x00000100;
+	DRAM_REG[18] = 0x00000000;
+	DRAM_REG[19] = 0x00000000;
+	DRAM_REG[20] = 0x00000000;
+	DRAM_REG[21] = 0x00000000;
+	DRAM_REG[22] = 0x00000000;
+	DRAM_REG[23] = 0x00000000;
+	DRAM_REG[24] = 0x00000000;
+	DRAM_REG[25] = 0x00000000;
+	DRAM_REG[26] = 0x00010101;
+	DRAM_REG[27] = 0x01010101;
+	DRAM_REG[28] = 0x000f0f01;
+	DRAM_REG[29] = 0x0f02020a;
+	DRAM_REG[30] = 0x00000000;
+	DRAM_REG[31] = 0x00010101;
+	DRAM_REG[32] = 0x00000100;
+	DRAM_REG[33] = 0x00000100;
+	DRAM_REG[34] = 0x00000000;
+	DRAM_REG[35] = 0x00000002;
+	DRAM_REG[36] = 0x01010000;
+	DRAM_REG[37] = 0x07080403;
+	DRAM_REG[38] = 0x06005003;
+	DRAM_REG[39] = 0x0a0000c8;
+	DRAM_REG[40] = 0x02009c40;
+	DRAM_REG[41] = 0x0002030c;
+	DRAM_REG[42] = 0x0036a609;
+	DRAM_REG[43] = 0x031a0612;
+	DRAM_REG[44] = 0x02030202;
+	DRAM_REG[45] = 0x00c8001c;
+	DRAM_REG[46] = 0x00000000;
+	DRAM_REG[47] = 0x00000000;
+	DRAM_REG[48] = 0x00012100;
+	DRAM_REG[49] = 0xffff0303;
+	DRAM_REG[50] = 0x00012100;
+	DRAM_REG[51] = 0xffff0303;
+	DRAM_REG[52] = 0x00012100;
+	DRAM_REG[53] = 0xffff0303;
+	DRAM_REG[54] = 0x00012100;
+	DRAM_REG[55] = 0xffff0303;
+	DRAM_REG[56] = 0x00000003;
+	DRAM_REG[57] = 0x00000000;
+	DRAM_REG[58] = 0x00000000;
+	DRAM_REG[59] = 0x00000000;
+	DRAM_REG[60] = 0x00000000;
+	DRAM_REG[61] = 0x00000000;
+	DRAM_REG[62] = 0x00000000;
+	DRAM_REG[63] = 0x00000000;
+	DRAM_REG[64] = 0x00000000;
+	DRAM_REG[65] = 0x00000000;
+	DRAM_REG[66] = 0x00000612;
+	DRAM_REG[67] = 0x01000f02;
+	DRAM_REG[68] = 0x06120612;
+	DRAM_REG[69] = 0x00000200;
+	DRAM_REG[70] = 0x00020007;
+	DRAM_REG[71] = 0xf4004a27;
+	DRAM_REG[72] = 0xf4004a27;
+	DRAM_REG[73] = 0xf4004a27;
+	DRAM_REG[74] = 0xf4004a27;
+	DRAM_REG[75] = 0x07400300;
+	DRAM_REG[76] = 0x07400300;
+	DRAM_REG[77] = 0x07400300;
+	DRAM_REG[78] = 0x07400300;
+	DRAM_REG[79] = 0x00000005;
+	DRAM_REG[80] = 0x00000000;
+	DRAM_REG[81] = 0x00000000;
+	DRAM_REG[82] = 0x01000000;
+	DRAM_REG[83] = 0x01020408;
+	DRAM_REG[84] = 0x08040201;
+	DRAM_REG[85] = 0x000f1133;
+	DRAM_REG[86] = 0x00000000;
+	DRAM_REG[87] = 0x00001f04;
+	DRAM_REG[88] = 0x00001f04;
+	DRAM_REG[89] = 0x00001f04;
+	DRAM_REG[90] = 0x00001f04;
+	DRAM_REG[91] = 0x00001f04;
+	DRAM_REG[92] = 0x00001f04;
+	DRAM_REG[93] = 0x00001f04;
+	DRAM_REG[94] = 0x00001f04;
+	DRAM_REG[95] = 0x00000000;
+	DRAM_REG[96] = 0x00000000;
+	DRAM_REG[97] = 0x00000000;
+	DRAM_REG[98] = 0x00000000;
+	DRAM_REG[99] = 0x00000000;
+	DRAM_REG[100] = 0x00000000;
+	DRAM_REG[101] = 0x00000000;
+	DRAM_REG[102] = 0x00000000;
+	DRAM_REG[103] = 0x00000000;
+	DRAM_REG[104] = 0x00000000;
+	DRAM_REG[105] = 0x00000000;
+	DRAM_REG[106] = 0x00000000;
+	DRAM_REG[107] = 0x00000000;
+	DRAM_REG[108] = 0x00000000;
+	DRAM_REG[109] = 0x00000000;
+	DRAM_REG[110] = 0x00000000;
+	DRAM_REG[111] = 0x00000000;
+	DRAM_REG[112] = 0x00000000;
+	DRAM_REG[113] = 0x00000000;
+	DRAM_REG[114] = 0x00000000;
+	DRAM_REG[115] = 0x00000000;
+	DRAM_REG[116] = 0x00000000;
+	DRAM_REG[117] = 0x00000000;
+	DRAM_REG[118] = 0x00000000;
+	DRAM_REG[119] = 0x00000000;
+	DRAM_REG[120] = 0x00000000;
+	DRAM_REG[121] = 0x00000000;
+	DRAM_REG[122] = 0x00000000;
+	DRAM_REG[123] = 0x00000000;
+	DRAM_REG[124] = 0x00000000;
+	DRAM_REG[125] = 0x00000000;
+	DRAM_REG[126] = 0x00000000;
+	DRAM_REG[127] = 0x00000000;
+	DRAM_REG[128] = 0x00000000;
+	DRAM_REG[129] = 0x00000000;
+	DRAM_REG[130] = 0x00000000;
+	DRAM_REG[131] = 0x00000000;
+	DRAM_REG[132] = 0x00000000;
+	DRAM_REG[133] = 0x00000000;
+	DRAM_REG[134] = 0x00000000;
+	DRAM_REG[135] = 0x00000000;
+	DRAM_REG[136] = 0x00000000;
+	DRAM_REG[137] = 0x00000000;
+	DRAM_REG[138] = 0x00000000;
+	DRAM_REG[139] = 0x00000000;
+	DRAM_REG[140] = 0x00000000;
+	DRAM_REG[141] = 0x00000000;
+	DRAM_REG[142] = 0x00000000;
+	DRAM_REG[143] = 0x00000000;
+	DRAM_REG[144] = 0x00000000;
+	DRAM_REG[145] = 0x00000000;
+	DRAM_REG[146] = 0x00000000;
+	DRAM_REG[147] = 0x00000000;
+	DRAM_REG[148] = 0x00000000;
+	DRAM_REG[149] = 0x00000000;
+	DRAM_REG[150] = 0x00000000;
+	DRAM_REG[151] = 0x00000000;
+	DRAM_REG[152] = 0x00000000;
+	DRAM_REG[153] = 0x00000000;
+	DRAM_REG[154] = 0x00000000;
+	DRAM_REG[155] = 0x00000000;
+	DRAM_REG[156] = 0x00000000;
+	DRAM_REG[157] = 0x00000000;
+	DRAM_REG[158] = 0x00000000;
+	DRAM_REG[159] = 0x00000000;
+	DRAM_REG[160] = 0x00000000;
+	DRAM_REG[161] = 0x00000000;
+	DRAM_REG[162] = 0x00010000;
+	DRAM_REG[163] = 0x00030404;
+	DRAM_REG[164] = 0x00000003;
+	DRAM_REG[165] = 0x00000000;
+	DRAM_REG[166] = 0x00000000;
+	DRAM_REG[167] = 0x00000000;
+	DRAM_REG[168] = 0x00000000;
+	DRAM_REG[169] = 0x00000000;
+	DRAM_REG[170] = 0x00000000;
+	DRAM_REG[171] = 0x01010000;
+	DRAM_REG[172] = 0x01000000;
+	DRAM_REG[173] = 0x03030000;
+	DRAM_REG[174] = 0x00010303;
+	DRAM_REG[175] = 0x01020202;
+	DRAM_REG[176] = 0x00000000;
+	DRAM_REG[177] = 0x02040303;
+	DRAM_REG[178] = 0x21002103;
+	DRAM_REG[179] = 0x00061200;
+	DRAM_REG[180] = 0x06120612;
+	DRAM_REG[181] = 0x04420442;
+	DRAM_REG[182] = 0x04420442;
+	DRAM_REG[183] = 0x00040004;
+	DRAM_REG[184] = 0x00040004;
+	DRAM_REG[185] = 0x00000000;
+	DRAM_REG[186] = 0x00000000;
+	DRAM_REG[187] = 0x00000000;
+	DRAM_REG[188] = 0x00000000;
+	DRAM_REG[189] = 0xffffffff;
+
+}
diff --git a/arch/arm/mach-mx28/emi_settings.h b/arch/arm/mach-mx28/emi_settings.h
new file mode 100644
index 0000000..745bf5d
--- /dev/null
+++ b/arch/arm/mach-mx28/emi_settings.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _EMI_SETTINGS_H_
+#define _EMI_SETTINGS_H_
+
+#define MX28_DRAMCTRLREGNUM 190
+
+#define SCALING_DATA_EMI_DIV_OFFSET     0
+#define SCALING_DATA_FRAC_DIV_OFFSET    4
+#define SCALING_DATA_CUR_FREQ_OFFSET    8
+#define SCALING_DATA_NEW_FREQ_OFFSET    12
+
+#ifndef __ASSEMBLER__
+void mxs_ram_freq_scale_end();
+void DDR2EmiController_EDE1116_133MHz();
+void DDR2EmiController_EDE1116_166MHz();
+void DDR2EmiController_EDE1116_200MHz();
+unsigned int *get_current_emidata();
+#endif
+
+#endif
diff --git a/arch/arm/mach-mx28/gpio.c b/arch/arm/mach-mx28/gpio.c
new file mode 100644
index 0000000..4f7d424
--- /dev/null
+++ b/arch/arm/mach-mx28/gpio.c
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include <mach/pinctrl.h>
+
+#include "regs-pinctrl.h"
+
+#define PINCTRL_BASE_ADDR IO_ADDRESS(PINCTRL_PHYS_ADDR)
+
+static int
+mx28_gpio_direction(struct mxs_gpio_port *port, int pin, unsigned int input)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	if (input)
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOE0_CLR);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOE0_SET);
+
+	return 0;
+}
+
+static int mx28_gpio_get(struct mxs_gpio_port *port, int pin)
+{
+	unsigned int data;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	data = __raw_readl(base + HW_PINCTRL_DIN0);
+	return data & (1 << pin);
+}
+
+static void mx28_gpio_set(struct mxs_gpio_port *port, int pin, int data)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	if (data)
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOUT0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_DOUT0_CLR);
+}
+
+static unsigned int mx28_gpio_irq_stat(struct mxs_gpio_port *port)
+{
+	unsigned int mask;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	mask = __raw_readl(base + HW_PINCTRL_IRQSTAT0);
+	mask &= __raw_readl(base + HW_PINCTRL_IRQEN0);
+	return mask;
+}
+
+static int
+mx28_gpio_set_irq_type(struct mxs_gpio_port *port, int pin, unsigned int type)
+{
+	unsigned int level, pol;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		level = 0;
+		pol = 1;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		level = 0;
+		pol = 0;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		level = 1;
+		pol = 1;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		level = 1;
+		pol = 0;
+		break;
+	default:
+		pr_debug("%s: Incorrect GPIO interrupt type 0x%x\n",
+			 __func__, type);
+		return -ENXIO;
+	}
+
+	if (level)
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQLEVEL0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQLEVEL0_CLR);
+
+	if (pol)
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQPOL0_SET);
+	else
+		__raw_writel(1 << pin, base + HW_PINCTRL_IRQPOL0_CLR);
+
+	return 0;
+}
+
+static void mx28_gpio_unmask_irq(struct mxs_gpio_port *port, int pin)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	__raw_writel(1 << pin, base + HW_PINCTRL_IRQEN0_SET);
+}
+
+static void mx28_gpio_mask_irq(struct mxs_gpio_port *port, int pin)
+{
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	__raw_writel(1 << pin, base + HW_PINCTRL_IRQEN0_CLR);
+}
+
+static void mx28_gpio_ack_irq(struct mxs_gpio_port *port, int pin)
+{
+	unsigned int mask;
+	void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * port->id;
+	mask = 1 << pin;
+	if (mask)
+		__raw_writel(mask, base + HW_PINCTRL_IRQSTAT0_CLR);
+}
+
+static struct mxs_gpio_port mx28_gpios[] = {
+	{
+	 .irq = IRQ_GPIO0,
+	 },
+	{
+	 .irq = IRQ_GPIO1,
+	 },
+	{
+	 .irq = IRQ_GPIO2,
+	 },
+	{
+	 .irq = IRQ_GPIO3,
+	 },
+	{
+	 .irq = IRQ_GPIO4,
+	 },
+};
+
+static struct mxs_gpio_chip mx28_gpio_chip = {
+	.set_dir = mx28_gpio_direction,
+	.get = mx28_gpio_get,
+	.set = mx28_gpio_set,
+	.get_irq_stat = mx28_gpio_irq_stat,
+	.set_irq_type = mx28_gpio_set_irq_type,
+	.unmask_irq = mx28_gpio_unmask_irq,
+	.mask_irq = mx28_gpio_mask_irq,
+	.ack_irq = mx28_gpio_ack_irq,
+};
+
+int __init mx28_gpio_init(void)
+{
+	int i;
+	unsigned int reg;
+	if (__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR) &
+	    BM_PINCTRL_CTRL_SFTRST) {
+		__raw_writel(BM_PINCTRL_CTRL_SFTRST,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+		for (i = 0; i < 10000; i++) {
+			if (!(__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL) &
+			      BM_PINCTRL_CTRL_SFTRST))
+				break;
+			udelay(2);
+		}
+		if (i >= 10000)
+			return -EFAULT;
+
+		__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	}
+
+	reg = __raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL);
+	for (i = 0; i < ARRAY_SIZE(mx28_gpios); i++) {
+		void __iomem *base = PINCTRL_BASE_ADDR + 0x10 * i;
+		if (!(reg & (BM_PINCTRL_CTRL_PRESENT0 << i)))
+			continue;
+		mxs_set_gpio_chip(&mx28_gpios[i], &mx28_gpio_chip);
+		mx28_gpios[i].id = i;
+		__raw_writel(0, base + HW_PINCTRL_IRQEN0);
+		__raw_writel(0xFFFFFFFF, base + HW_PINCTRL_PIN2IRQ0);
+		mx28_gpios[i].child_irq = MXS_GPIO_IRQ_START +
+		    (i * PINS_PER_BANK);
+		mxs_add_gpio_port(&mx28_gpios[i]);
+	}
+	return 0;
+}
diff --git a/arch/arm/mach-mx28/include/mach/dma.h b/arch/arm/mach-mx28/include/mach/dma.h
new file mode 100644
index 0000000..ad8076c
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/dma.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_DMA_H__
+#define __ASM_ARCH_MACH_DMA_H__
+
+enum {
+	MXS_DMA_CHANNEL_AHB_APBH = 0,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP0 = MXS_DMA_CHANNEL_AHB_APBH,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP1,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP2,
+	MXS_DMA_CHANNEL_AHB_APBH_SSP3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI0,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI1,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI2,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI3,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI4,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI5,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI6,
+	MXS_DMA_CHANNEL_AHB_APBH_GPMI7,
+	MXS_DMA_CHANNEL_AHB_APBH_HSADC,
+	MXS_DMA_CHANNEL_AHB_APBH_LCDIF,
+	MXS_DMA_CHANNEL_AHB_APBH_14,
+	MXS_DMA_CHANNEL_AHB_APBH_15,
+	MXS_DMA_CHANNEL_AHB_APBX = 16,
+	MXS_DMA_CHANNEL_AHB_APBX_UART4_RX = MXS_DMA_CHANNEL_AHB_APBX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART4_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_SPDIF,
+	MXS_DMA_CHANNEL_AHB_APBX_03,
+	MXS_DMA_CHANNEL_AHB_APBX_SAIF0,
+	MXS_DMA_CHANNEL_AHB_APBX_SAIF1,
+	MXS_DMA_CHANNEL_AHB_APBX_I2C0,
+	MXS_DMA_CHANNEL_AHB_APBX_I2C1,
+	MXS_DMA_CHANNEL_AHB_APBX_UART0_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART0_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART3_RX,
+	MXS_DMA_CHANNEL_AHB_APBX_UART3_TX,
+	MAX_DMA_CHANNELS,
+};
+#endif /* __ASM_ARCH_MACH_MX28_H__ */
diff --git a/arch/arm/mach-mx28/include/mach/lcdif.h b/arch/arm/mach-mx28/include/mach/lcdif.h
new file mode 100644
index 0000000..23fff95
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/lcdif.h
@@ -0,0 +1,276 @@
+/*
+ * Freescale MXS LCDIF interfaces
+ *
+ * Author: Vitaly Wool <vital@embeddedalley.com>
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _ARCH_ARM_LCDIF_H
+#define _ARCH_ARM_LCDIF_H
+
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <linux/backlight.h>
+#include <linux/dma-mapping.h>
+#include <linux/regulator/consumer.h>
+#include <linux/platform_device.h>
+
+#include <mach/device.h>
+
+#include "regs-lcdif.h"
+
+#define REGS_LCDIF_BASE IO_ADDRESS(LCDIF_PHYS_ADDR)
+
+enum {
+	SPI_MOSI = 0,
+	SPI_SCLK,
+	SPI_CS,
+};
+
+struct mxs_lcd_dma_chain_info {
+	dma_addr_t *dma_addr_p;
+	unsigned offset;
+};
+
+enum {
+	MXS_LCD_PANEL_SYSTEM = 0,
+	MXS_LCD_PANEL_VSYNC,
+	MXS_LCD_PANEL_DOTCLK,
+	MXS_LCD_PANEL_DVI,
+};
+
+struct mxs_platform_bl_data;
+struct mxs_platform_fb_entry {
+	char name[16];
+	u16 x_res;
+	u16 y_res;
+	u16 bpp;
+	u32 cycle_time_ns;
+	int lcd_type;
+	int (*init_panel) (struct device *, dma_addr_t, int,
+			   struct mxs_platform_fb_entry *);
+	void (*release_panel) (struct device *, struct mxs_platform_fb_entry *);
+	int (*blank_panel) (int);
+	void (*run_panel) (void);
+	void (*stop_panel) (void);
+	int (*pan_display) (dma_addr_t);
+	int (*update_panel) (void *, struct mxs_platform_fb_entry *);
+	struct list_head link;
+	struct mxs_platform_bl_data *bl_data;
+};
+
+struct mxs_platform_fb_data {
+	struct list_head list;
+	struct mxs_platform_fb_entry *cur;
+	struct mxs_platform_fb_entry *next;
+};
+
+#define MXS_LCDIF_PANEL_INIT	1
+#define MXS_LCDIF_PANEL_RELEASE	2
+
+struct mxs_platform_bl_data {
+	struct list_head list;
+	struct regulator *regulator;
+	int bl_gpio;
+	int bl_max_intensity;
+	int bl_cons_intensity;
+	int bl_default_intensity;
+	int (*init_bl) (struct mxs_platform_bl_data *);
+	int (*set_bl_intensity) (struct mxs_platform_bl_data *,
+				 struct backlight_device *, int);
+	void (*free_bl) (struct mxs_platform_bl_data *);
+};
+
+static inline void mxs_lcd_register_entry(struct mxs_platform_fb_entry
+					  *pentry, struct mxs_platform_fb_data
+					  *pdata)
+{
+	list_add_tail(&pentry->link, &pdata->list);
+	if (!pdata->cur)
+		pdata->cur = pentry;
+}
+
+static inline void mxs_lcd_move_pentry_up(struct mxs_platform_fb_entry
+					  *pentry, struct mxs_platform_fb_data
+					  *pdata)
+{
+	list_move(&pentry->link, &pdata->list);
+}
+
+static inline int mxs_lcd_iterate_pdata(struct mxs_platform_fb_data
+					*pdata,
+					int (*func) (struct
+						     mxs_platform_fb_entry
+						     * pentry, void *data,
+						     int ret_prev), void *data)
+{
+	struct mxs_platform_fb_entry *pentry;
+	int ret = 0;
+	list_for_each_entry(pentry, &pdata->list, link) {
+		ret = func(pentry, data, ret);
+	}
+	return ret;
+}
+
+static inline void mxs_lcd_set_bl_pdata(struct mxs_platform_bl_data
+					*pdata)
+{
+	struct platform_device *pdev;
+	pdev = mxs_get_device("mxs-bl", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->dev.platform_data = pdata;
+}
+
+void mxs_init_lcdif(void);
+int mxs_lcdif_dma_init(struct device *dev, dma_addr_t phys, int memsize);
+void mxs_lcdif_dma_release(void);
+void mxs_lcdif_run(void);
+void mxs_lcdif_stop(void);
+int mxs_lcdif_pan_display(dma_addr_t addr);
+
+int mxs_lcdif_register_client(struct notifier_block *nb);
+void mxs_lcdif_unregister_client(struct notifier_block *nb);
+void mxs_lcdif_notify_clients(unsigned long event,
+			      struct mxs_platform_fb_entry *pentry);
+
+#ifndef FBIO_WAITFORVSYNC
+#define FBIO_WAITFORVSYNC		_IOW('F', 0x20, u_int32_t)
+#endif
+
+static inline void setup_dotclk_panel(u16 v_pulse_width,
+				      u16 v_period,
+				      u16 v_wait_cnt,
+				      u16 v_active,
+				      u16 h_pulse_width,
+				      u16 h_period,
+				      u16 h_wait_cnt,
+				      u16 h_active, int enable_present)
+{
+	u32 val;
+
+	__raw_writel(BM_LCDIF_CTRL_DATA_SHIFT_DIR,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+	__raw_writel(BM_LCDIF_CTRL_SHIFT_NUM_BITS,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+
+	__raw_writel(BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL1_CLR);
+	__raw_writel(BF_LCDIF_CTRL1_BYTE_PACKING_FORMAT(7) |
+		     BM_LCDIF_CTRL1_RECOVER_ON_UNDERFLOW,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL1_SET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+	val &= ~(BM_LCDIF_TRANSFER_COUNT_V_COUNT |
+		 BM_LCDIF_TRANSFER_COUNT_H_COUNT);
+	val |= BF_LCDIF_TRANSFER_COUNT_H_COUNT(h_active) |
+	    BF_LCDIF_TRANSFER_COUNT_V_COUNT(v_active);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_TRANSFER_COUNT);
+
+	__raw_writel(BM_LCDIF_CTRL_VSYNC_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_WAIT_FOR_VSYNC_EDGE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_DVI_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BM_LCDIF_CTRL_DOTCLK_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+	__raw_writel(BM_LCDIF_CTRL_BYPASS_COUNT,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+	__raw_writel(BM_LCDIF_CTRL_WORD_LENGTH |
+		     BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE |
+		     BM_LCDIF_CTRL_LCD_DATABUS_WIDTH,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(BF_LCDIF_CTRL_WORD_LENGTH(3) |	/* 24 bit */
+		     BM_LCDIF_CTRL_DATA_SELECT |	/* data mode */
+		     BF_LCDIF_CTRL_INPUT_DATA_SWIZZLE(0) |	/* no swap */
+		     BF_LCDIF_CTRL_LCD_DATABUS_WIDTH(3),	/* 24 bit */
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_SET);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_POL |
+		 BM_LCDIF_VDCTRL0_HSYNC_POL |
+		 BM_LCDIF_VDCTRL0_ENABLE_POL | BM_LCDIF_VDCTRL0_DOTCLK_POL);
+	val |= BM_LCDIF_VDCTRL0_ENABLE_POL | BM_LCDIF_VDCTRL0_DOTCLK_POL;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_OEB);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);	/* vsync is output */
+
+	/*
+	 * need enable sig for true RGB i/f.  Or, if not true RGB, leave it
+	 * zero.
+	 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val |= BM_LCDIF_VDCTRL0_ENABLE_PRESENT;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	/*
+	 * For DOTCLK mode, count VSYNC_PERIOD in terms of complete hz lines
+	 */
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	val &= ~(BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT |
+		 BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT);
+	val |= BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT |
+	    BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+
+	__raw_writel(BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH,
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0_CLR);
+	__raw_writel(v_pulse_width, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0_SET);
+
+	__raw_writel(BF_LCDIF_VDCTRL1_VSYNC_PERIOD(v_period),
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL1);
+
+	__raw_writel(BF_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH(h_pulse_width) |
+		     BF_LCDIF_VDCTRL2_HSYNC_PERIOD(h_period),
+		     REGS_LCDIF_BASE + HW_LCDIF_VDCTRL2);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+	val &= ~BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT;
+	val |= BF_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT(h_active);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+	val &= ~(BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT |
+		 BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT);
+	val |= BF_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT(h_wait_cnt) |
+	    BF_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT(v_wait_cnt);
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+
+	val = __raw_readl(REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+	val |= BM_LCDIF_VDCTRL4_SYNC_SIGNALS_ON;
+	__raw_writel(val, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL4);
+}
+
+static inline void release_dotclk_panel(void)
+{
+	__raw_writel(BM_LCDIF_CTRL_DOTCLK_MODE,
+		     REGS_LCDIF_BASE + HW_LCDIF_CTRL_CLR);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL0);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL1);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL2);
+	__raw_writel(0, REGS_LCDIF_BASE + HW_LCDIF_VDCTRL3);
+}
+
+#endif /* _ARCH_ARM_LCDIF_H */
diff --git a/arch/arm/mach-mx28/include/mach/mx28.h b/arch/arm/mach-mx28/include/mach/mx28.h
new file mode 100644
index 0000000..0972532
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/mx28.h
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MACH_MX28_H__
+#define __ASM_ARCH_MACH_MX28_H__
+
+#include <asm/sizes.h>
+
+#define MX28_SOC_IO_PHYS_BASE	0x80000000
+#define MX28_SOC_IO_VIRT_BASE	0xF0000000
+#define MX28_SOC_IO_AREA_SIZE	SZ_1M
+
+/* Virtual address where OCRAM is mapped */
+#define MX28_OCRAM_PHBASE   0x00000000
+#ifdef __ASSEMBLER__
+#define MX28_OCRAM_BASE     0xf1000000
+#else
+#define MX28_OCRAM_BASE     (void __iomem *)0xf1000000
+#endif
+#define MX28_OCRAM_SIZE     (128 * SZ_1K)
+
+
+#define ICOLL_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x000000)
+#define HSADC_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x002000)
+#define APBH_DMA_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x004000)
+#define PERFMON_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x006000)
+#define BCH_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x00A000)
+#define GPMI_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x00C000)
+#define SSP0_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x010000)
+#define SSP1_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x012000)
+#define SSP2_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x014000)
+#define SSP3_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x016000)
+#define PINCTRL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x018000)
+#define DIGCTL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x01C000)
+#define ETM_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x022000)
+#define APBX_DMA_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x024000)
+#define DCP_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x028000)
+#define PXP_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x02A000)
+#define OCOTP_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x02C000)
+#define AXI_AHB0_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x02E000)
+#define LCDIF_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x030000)
+#define CAN0_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x032000)
+#define CAN1_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x034000)
+#define SIMDBG_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C000)
+#define SIMGPMISEL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C200)
+#define SIMSSPSEL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C300)
+#define SIMMEMSEL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C400)
+#define GPIOMON_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C500)
+#define SIMENET_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C700)
+#define ARMJTAG_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x03C800)
+#define CLKCTRL_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x040000)
+#define SAIF0_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x042000)
+#define POWER_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x044000)
+#define SAIF1_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x046000)
+#define LRADC_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x050000)
+#define SPDIF_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x054000)
+#define RTC_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x056000)
+#define I2C0_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x058000)
+#define I2C1_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x05A000)
+#define PWM_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x064000)
+#define TIMROT_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x068000)
+#define AUART0_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x06A000)
+#define AUART1_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x06C000)
+#define AUART2_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x06E000)
+#define AUART3_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x070000)
+#define AUART4_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x072000)
+#define DUART_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x074000)
+#define USBPHY0_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x07C000)
+#define USBPHY1_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x07E000)
+#define USBCTRL0_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x080000)
+#define USBCTRL1_PHYS_ADDR	(MX28_SOC_IO_PHYS_BASE + 0x090000)
+#define DFLPT_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x0C0000)
+#define DRAM_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x0E0000)
+#define ENET_PHYS_ADDR		(MX28_SOC_IO_PHYS_BASE + 0x0F0000)
+
+/* IRQ Definitions */
+#define IRQ_BATT_BRNOUT			0
+#define IRQ_VDDD_BRNOUT			1
+#define IRQ_VDDIO_BRNOUT		2
+#define IRQ_VDDA_BRNOUT			3
+#define IRQ_VDD5V_DROOP			4
+#define IRQ_DCDC4P2_BRNOUT		5
+#define IRQ_VDD5V			6
+#define IRQ_RESV7			7
+#define IRQ_CAN0			8
+#define IRQ_CAN1			9
+#define IRQ_LRADC_TOUCH			10
+#define IRQ_RESV11			11
+#define IRQ_RESV12			12
+#define IRQ_HSADC			13
+#define IRQ_IRADC_THRESH0		14
+#define IRQ_IRADC_THRESH1		15
+#define IRQ_LRADC_CH0			16
+#define IRQ_LRADC_CH1			17
+#define IRQ_LRADC_CH2			18
+#define IRQ_LRADC_CH3			19
+#define IRQ_LRADC_CH4			20
+#define IRQ_LRADC_CH5			21
+#define IRQ_LRADC_CH6			22
+#define IRQ_LRADC_CH7			23
+#define IRQ_LRADC_BUTTON0		24
+#define IRQ_LRADC_BUTTON1		25
+#define IRQ_RESV26			26
+#define IRQ_PERFMON			27
+#define IRQ_RTC_1MSEC			28
+#define IRQ_RTC_ALARM			29
+#define IRQ_RESV30			30
+#define IRQ_COMMS			31
+#define IRQ_EMI_ERR			32
+#define IRQ_RESV33			33
+#define IRQ_RESV34			34
+#define IRQ_RESV35			35
+#define IRQ_RESV36			36
+#define IRQ_RESV37			37
+#define IRQ_LCDIF			38
+#define IRQ_PXP				39
+#define IRQ_RESV40			40
+#define IRQ_BCH				41
+#define IRQ_GPMI			42
+#define IRQ_RESV43			43
+#define IRQ_RESV44			44
+#define IRQ_SPDIF_ERROR			45
+#define IRQ_RESV46			46
+#define IRQ_DUART			47
+#define IRQ_TIMER0			48
+#define IRQ_TIMER1			49
+#define IRQ_TIMER2			50
+#define IRQ_TIMER3			51
+#define IRQ_DCP_VMI			52
+#define IRQ_DCP				53
+#define IRQ_DCP_SECURE			54
+#define IRQ_RESV55			55
+#define IRQ_RESV56			56
+#define IRQ_RESV57			57
+#define IRQ_SAIF1			58
+#define IRQ_SAIF0			59
+#define IRQ_RESV60			60
+#define IRQ_RESV61			61
+#define IRQ_RESV62			62
+#define IRQ_RESV63			63
+#define IRQ_RESV64			64
+#define IRQ_RESV65			65
+#define IRQ_SPDIF_DMA			66
+#define IRQ_RESV67			67
+#define IRQ_I2C0_DMA			68
+#define IRQ_I2C1_DMA			69
+#define IRQ_AUART0_RX_DMA		70
+#define IRQ_AUART0_TX_DMA		71
+#define IRQ_AUART1_RX_DMA		72
+#define IRQ_AUART1_TX_DMA		73
+#define IRQ_AUART2_RX_DMA		74
+#define IRQ_AUART2_TX_DMA		75
+#define IRQ_AUART3_RX_DMA		76
+#define IRQ_AUART3_TX_DMA		77
+#define IRQ_AUART4_RX_DMA		78
+#define IRQ_AUART4_TX_DMA		79
+#define IRQ_SAIF0_DMA			80
+#define IRQ_SAIF1_DMA			81
+#define IRQ_SSP0_DMA			82
+#define IRQ_SSP1_DMA			83
+#define IRQ_SSP2_DMA			84
+#define IRQ_SSP3_DMA			85
+#define IRQ_LCDIF_DMA			86
+#define IRQ_HSADC_DMA			87
+#define IRQ_GPMI_DMA			88
+#define IRQ_DIGCTL_DEBUG_TRAP		89
+#define IRQ_RESV90			90
+#define IRQ_RESV91			91
+#define IRQ_USB1			92
+#define IRQ_USB0			93
+#define IRQ_USB1_WAKEUP			94
+#define IRQ_USB0_WAKEUP			95
+#define IRQ_SSP0			96
+#define IRQ_SSP1			97
+#define IRQ_SSP2			98
+#define IRQ_SSP3			99
+#define IRQ_ENET_SWI			100
+#define IRQ_ENET_MAC0			101
+#define IRQ_ENET_MAC1			102
+#define IRQ_ENET_MAC0_1588		103
+#define IRQ_ENET_MAC1_1588		104
+#define IRQ_RESV105			105
+#define IRQ_RESV106			106
+#define IRQ_RESV107			107
+#define IRQ_RESV108			108
+#define IRQ_RESV109			109
+#define IRQ_I2C1_ERROR			110
+#define IRQ_I2C0_ERROR			111
+#define IRQ_AUART0			112
+#define IRQ_AUART1			113
+#define IRQ_AUART2			114
+#define IRQ_AUART3			115
+#define IRQ_AUART4			116
+#define IRQ_RESV117			117
+#define IRQ_RESV118			118
+#define IRQ_RESV119			119
+#define IRQ_RESV120			120
+#define IRQ_RESV121			121
+#define IRQ_RESV122			122
+#define IRQ_GPIO4			123
+#define IRQ_GPIO3			124
+#define IRQ_GPIO2			125
+#define IRQ_GPIO1			126
+#define IRQ_GPIO0			127
+
+#define ARCH_NR_IRQS		128
+
+/* On i.MX28, all interrupt sources can be configured as FIQ */
+#define FIQ_START		IRQ_BATT_BRNOUT
+
+#define MX28_SOC_IO_ADDRESS(x) \
+	((x) - MX28_SOC_IO_PHYS_BASE + MX28_SOC_IO_VIRT_BASE)
+
+#ifdef __ASSEMBLER__
+#define IO_ADDRESS(x)		\
+		MX28_SOC_IO_ADDRESS(x)
+#else
+#define IO_ADDRESS(x)		\
+	(void __force __iomem *) 	\
+	(((x) >= (unsigned long)MX28_SOC_IO_PHYS_BASE) && \
+	 ((x) < (unsigned long)MX28_SOC_IO_PHYS_BASE + \
+				MX28_SOC_IO_AREA_SIZE) ? \
+		MX28_SOC_IO_ADDRESS(x) : 0xDEADBEEF)
+#endif
+
+#ifdef CONFIG_MXS_EARLY_CONSOLE
+#define MXS_DEBUG_CONSOLE_PHYS DUART_PHYS_ADDR
+#define MXS_DEBUG_CONSOLE_VIRT IO_ADDRESS(DUART_PHYS_ADDR)
+#endif
+#endif /* __ASM_ARCH_MACH_MX28_H__ */
diff --git a/arch/arm/mach-mx28/include/mach/regs-apbh.h b/arch/arm/mach-mx28/include/mach/regs-apbh.h
new file mode 100644
index 0000000..23f26ca
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-apbh.h
@@ -0,0 +1,535 @@
+/*
+ * Freescale APBH Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.57
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___APBH_H
+#define __ARCH_ARM___APBH_H
+
+#define HW_APBH_CTRL0	(0x00000000)
+#define HW_APBH_CTRL0_SET	(0x00000004)
+#define HW_APBH_CTRL0_CLR	(0x00000008)
+#define HW_APBH_CTRL0_TOG	(0x0000000c)
+
+#define BM_APBH_CTRL0_SFTRST	0x80000000
+#define BM_APBH_CTRL0_CLKGATE	0x40000000
+#define BM_APBH_CTRL0_AHB_BURST8_EN	0x20000000
+#define BM_APBH_CTRL0_APB_BURST_EN	0x10000000
+#define BP_APBH_CTRL0_RSVD0	16
+#define BM_APBH_CTRL0_RSVD0	0x0FFF0000
+#define BF_APBH_CTRL0_RSVD0(v)  \
+		(((v) << 16) & BM_APBH_CTRL0_RSVD0)
+#define BP_APBH_CTRL0_CLKGATE_CHANNEL	0
+#define BM_APBH_CTRL0_CLKGATE_CHANNEL	0x0000FFFF
+#define BF_APBH_CTRL0_CLKGATE_CHANNEL(v)  \
+		(((v) << 0) & BM_APBH_CTRL0_CLKGATE_CHANNEL)
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP0  0x0001
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP1  0x0002
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP2  0x0004
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__SSP3  0x0008
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND0 0x0010
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND1 0x0020
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND2 0x0040
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND3 0x0080
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND4 0x0100
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND5 0x0200
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND6 0x0400
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__NAND7 0x0800
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__HSADC 0x1000
+#define BV_APBH_CTRL0_CLKGATE_CHANNEL__LCDIF 0x2000
+
+#define HW_APBH_CTRL1	(0x00000010)
+#define HW_APBH_CTRL1_SET	(0x00000014)
+#define HW_APBH_CTRL1_CLR	(0x00000018)
+#define HW_APBH_CTRL1_TOG	(0x0000001c)
+
+#define BM_APBH_CTRL1_CH15_CMDCMPLT_IRQ_EN	0x80000000
+#define BM_APBH_CTRL1_CH14_CMDCMPLT_IRQ_EN	0x40000000
+#define BM_APBH_CTRL1_CH13_CMDCMPLT_IRQ_EN	0x20000000
+#define BM_APBH_CTRL1_CH12_CMDCMPLT_IRQ_EN	0x10000000
+#define BM_APBH_CTRL1_CH11_CMDCMPLT_IRQ_EN	0x08000000
+#define BM_APBH_CTRL1_CH10_CMDCMPLT_IRQ_EN	0x04000000
+#define BM_APBH_CTRL1_CH9_CMDCMPLT_IRQ_EN	0x02000000
+#define BM_APBH_CTRL1_CH8_CMDCMPLT_IRQ_EN	0x01000000
+#define BM_APBH_CTRL1_CH7_CMDCMPLT_IRQ_EN	0x00800000
+#define BM_APBH_CTRL1_CH6_CMDCMPLT_IRQ_EN	0x00400000
+#define BM_APBH_CTRL1_CH5_CMDCMPLT_IRQ_EN	0x00200000
+#define BM_APBH_CTRL1_CH4_CMDCMPLT_IRQ_EN	0x00100000
+#define BM_APBH_CTRL1_CH3_CMDCMPLT_IRQ_EN	0x00080000
+#define BM_APBH_CTRL1_CH2_CMDCMPLT_IRQ_EN	0x00040000
+#define BM_APBH_CTRL1_CH1_CMDCMPLT_IRQ_EN	0x00020000
+#define BM_APBH_CTRL1_CH0_CMDCMPLT_IRQ_EN	0x00010000
+#define BM_APBH_CTRL1_CH15_CMDCMPLT_IRQ	0x00008000
+#define BM_APBH_CTRL1_CH14_CMDCMPLT_IRQ	0x00004000
+#define BM_APBH_CTRL1_CH13_CMDCMPLT_IRQ	0x00002000
+#define BM_APBH_CTRL1_CH12_CMDCMPLT_IRQ	0x00001000
+#define BM_APBH_CTRL1_CH11_CMDCMPLT_IRQ	0x00000800
+#define BM_APBH_CTRL1_CH10_CMDCMPLT_IRQ	0x00000400
+#define BM_APBH_CTRL1_CH9_CMDCMPLT_IRQ	0x00000200
+#define BM_APBH_CTRL1_CH8_CMDCMPLT_IRQ	0x00000100
+#define BM_APBH_CTRL1_CH7_CMDCMPLT_IRQ	0x00000080
+#define BM_APBH_CTRL1_CH6_CMDCMPLT_IRQ	0x00000040
+#define BM_APBH_CTRL1_CH5_CMDCMPLT_IRQ	0x00000020
+#define BM_APBH_CTRL1_CH4_CMDCMPLT_IRQ	0x00000010
+#define BM_APBH_CTRL1_CH3_CMDCMPLT_IRQ	0x00000008
+#define BM_APBH_CTRL1_CH2_CMDCMPLT_IRQ	0x00000004
+#define BM_APBH_CTRL1_CH1_CMDCMPLT_IRQ	0x00000002
+#define BM_APBH_CTRL1_CH0_CMDCMPLT_IRQ	0x00000001
+
+#define HW_APBH_CTRL2	(0x00000020)
+#define HW_APBH_CTRL2_SET	(0x00000024)
+#define HW_APBH_CTRL2_CLR	(0x00000028)
+#define HW_APBH_CTRL2_TOG	(0x0000002c)
+
+#define BM_APBH_CTRL2_CH15_ERROR_STATUS	0x80000000
+#define BV_APBH_CTRL2_CH15_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH15_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH14_ERROR_STATUS	0x40000000
+#define BV_APBH_CTRL2_CH14_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH14_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH13_ERROR_STATUS	0x20000000
+#define BV_APBH_CTRL2_CH13_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH13_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH12_ERROR_STATUS	0x10000000
+#define BV_APBH_CTRL2_CH12_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH12_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH11_ERROR_STATUS	0x08000000
+#define BV_APBH_CTRL2_CH11_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH11_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH10_ERROR_STATUS	0x04000000
+#define BV_APBH_CTRL2_CH10_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH10_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH9_ERROR_STATUS	0x02000000
+#define BV_APBH_CTRL2_CH9_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH9_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH8_ERROR_STATUS	0x01000000
+#define BV_APBH_CTRL2_CH8_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH8_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH7_ERROR_STATUS	0x00800000
+#define BV_APBH_CTRL2_CH7_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH7_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH6_ERROR_STATUS	0x00400000
+#define BV_APBH_CTRL2_CH6_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH6_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH5_ERROR_STATUS	0x00200000
+#define BV_APBH_CTRL2_CH5_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH5_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH4_ERROR_STATUS	0x00100000
+#define BV_APBH_CTRL2_CH4_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH4_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH3_ERROR_STATUS	0x00080000
+#define BV_APBH_CTRL2_CH3_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH3_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH2_ERROR_STATUS	0x00040000
+#define BV_APBH_CTRL2_CH2_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH2_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH1_ERROR_STATUS	0x00020000
+#define BV_APBH_CTRL2_CH1_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH1_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH0_ERROR_STATUS	0x00010000
+#define BV_APBH_CTRL2_CH0_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBH_CTRL2_CH0_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBH_CTRL2_CH15_ERROR_IRQ	0x00008000
+#define BM_APBH_CTRL2_CH14_ERROR_IRQ	0x00004000
+#define BM_APBH_CTRL2_CH13_ERROR_IRQ	0x00002000
+#define BM_APBH_CTRL2_CH12_ERROR_IRQ	0x00001000
+#define BM_APBH_CTRL2_CH11_ERROR_IRQ	0x00000800
+#define BM_APBH_CTRL2_CH10_ERROR_IRQ	0x00000400
+#define BM_APBH_CTRL2_CH9_ERROR_IRQ	0x00000200
+#define BM_APBH_CTRL2_CH8_ERROR_IRQ	0x00000100
+#define BM_APBH_CTRL2_CH7_ERROR_IRQ	0x00000080
+#define BM_APBH_CTRL2_CH6_ERROR_IRQ	0x00000040
+#define BM_APBH_CTRL2_CH5_ERROR_IRQ	0x00000020
+#define BM_APBH_CTRL2_CH4_ERROR_IRQ	0x00000010
+#define BM_APBH_CTRL2_CH3_ERROR_IRQ	0x00000008
+#define BM_APBH_CTRL2_CH2_ERROR_IRQ	0x00000004
+#define BM_APBH_CTRL2_CH1_ERROR_IRQ	0x00000002
+#define BM_APBH_CTRL2_CH0_ERROR_IRQ	0x00000001
+
+#define HW_APBH_CHANNEL_CTRL	(0x00000030)
+#define HW_APBH_CHANNEL_CTRL_SET	(0x00000034)
+#define HW_APBH_CHANNEL_CTRL_CLR	(0x00000038)
+#define HW_APBH_CHANNEL_CTRL_TOG	(0x0000003c)
+
+#define BP_APBH_CHANNEL_CTRL_RESET_CHANNEL	16
+#define BM_APBH_CHANNEL_CTRL_RESET_CHANNEL	0xFFFF0000
+#define BF_APBH_CHANNEL_CTRL_RESET_CHANNEL(v) \
+		(((v) << 16) & BM_APBH_CHANNEL_CTRL_RESET_CHANNEL)
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__SSP0  0x0001
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__SSP1  0x0002
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__SSP2  0x0004
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__SSP3  0x0008
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND0 0x0010
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND1 0x0020
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND2 0x0040
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND3 0x0080
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND4 0x0100
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND5 0x0200
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND6 0x0400
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__NAND7 0x0800
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__HSADC 0x1000
+#define BV_APBH_CHANNEL_CTRL_RESET_CHANNEL__LCDIF 0x2000
+#define BP_APBH_CHANNEL_CTRL_FREEZE_CHANNEL	0
+#define BM_APBH_CHANNEL_CTRL_FREEZE_CHANNEL	0x0000FFFF
+#define BF_APBH_CHANNEL_CTRL_FREEZE_CHANNEL(v)  \
+		(((v) << 0) & BM_APBH_CHANNEL_CTRL_FREEZE_CHANNEL)
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__SSP0  0x0001
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__SSP1  0x0002
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__SSP2  0x0004
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__SSP3  0x0008
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND0 0x0010
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND1 0x0020
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND2 0x0040
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND3 0x0080
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND4 0x0100
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND5 0x0200
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND6 0x0400
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__NAND7 0x0800
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__HSADC 0x1000
+#define BV_APBH_CHANNEL_CTRL_FREEZE_CHANNEL__LCDIF 0x2000
+
+#define HW_APBH_DEVSEL	(0x00000040)
+
+#define BP_APBH_DEVSEL_CH15	30
+#define BM_APBH_DEVSEL_CH15	0xC0000000
+#define BF_APBH_DEVSEL_CH15(v) \
+		(((v) << 30) & BM_APBH_DEVSEL_CH15)
+#define BP_APBH_DEVSEL_CH14	28
+#define BM_APBH_DEVSEL_CH14	0x30000000
+#define BF_APBH_DEVSEL_CH14(v)  \
+		(((v) << 28) & BM_APBH_DEVSEL_CH14)
+#define BP_APBH_DEVSEL_CH13	26
+#define BM_APBH_DEVSEL_CH13	0x0C000000
+#define BF_APBH_DEVSEL_CH13(v)  \
+		(((v) << 26) & BM_APBH_DEVSEL_CH13)
+#define BP_APBH_DEVSEL_CH12	24
+#define BM_APBH_DEVSEL_CH12	0x03000000
+#define BF_APBH_DEVSEL_CH12(v)  \
+		(((v) << 24) & BM_APBH_DEVSEL_CH12)
+#define BP_APBH_DEVSEL_CH11	22
+#define BM_APBH_DEVSEL_CH11	0x00C00000
+#define BF_APBH_DEVSEL_CH11(v)  \
+		(((v) << 22) & BM_APBH_DEVSEL_CH11)
+#define BP_APBH_DEVSEL_CH10	20
+#define BM_APBH_DEVSEL_CH10	0x00300000
+#define BF_APBH_DEVSEL_CH10(v)  \
+		(((v) << 20) & BM_APBH_DEVSEL_CH10)
+#define BP_APBH_DEVSEL_CH9	18
+#define BM_APBH_DEVSEL_CH9	0x000C0000
+#define BF_APBH_DEVSEL_CH9(v)  \
+		(((v) << 18) & BM_APBH_DEVSEL_CH9)
+#define BP_APBH_DEVSEL_CH8	16
+#define BM_APBH_DEVSEL_CH8	0x00030000
+#define BF_APBH_DEVSEL_CH8(v)  \
+		(((v) << 16) & BM_APBH_DEVSEL_CH8)
+#define BP_APBH_DEVSEL_CH7	14
+#define BM_APBH_DEVSEL_CH7	0x0000C000
+#define BF_APBH_DEVSEL_CH7(v)  \
+		(((v) << 14) & BM_APBH_DEVSEL_CH7)
+#define BP_APBH_DEVSEL_CH6	12
+#define BM_APBH_DEVSEL_CH6	0x00003000
+#define BF_APBH_DEVSEL_CH6(v)  \
+		(((v) << 12) & BM_APBH_DEVSEL_CH6)
+#define BP_APBH_DEVSEL_CH5	10
+#define BM_APBH_DEVSEL_CH5	0x00000C00
+#define BF_APBH_DEVSEL_CH5(v)  \
+		(((v) << 10) & BM_APBH_DEVSEL_CH5)
+#define BP_APBH_DEVSEL_CH4	8
+#define BM_APBH_DEVSEL_CH4	0x00000300
+#define BF_APBH_DEVSEL_CH4(v)  \
+		(((v) << 8) & BM_APBH_DEVSEL_CH4)
+#define BP_APBH_DEVSEL_CH3	6
+#define BM_APBH_DEVSEL_CH3	0x000000C0
+#define BF_APBH_DEVSEL_CH3(v)  \
+		(((v) << 6) & BM_APBH_DEVSEL_CH3)
+#define BP_APBH_DEVSEL_CH2	4
+#define BM_APBH_DEVSEL_CH2	0x00000030
+#define BF_APBH_DEVSEL_CH2(v)  \
+		(((v) << 4) & BM_APBH_DEVSEL_CH2)
+#define BP_APBH_DEVSEL_CH1	2
+#define BM_APBH_DEVSEL_CH1	0x0000000C
+#define BF_APBH_DEVSEL_CH1(v)  \
+		(((v) << 2) & BM_APBH_DEVSEL_CH1)
+#define BP_APBH_DEVSEL_CH0	0
+#define BM_APBH_DEVSEL_CH0	0x00000003
+#define BF_APBH_DEVSEL_CH0(v)  \
+		(((v) << 0) & BM_APBH_DEVSEL_CH0)
+
+#define HW_APBH_DMA_BURST_SIZE	(0x00000050)
+
+#define BP_APBH_DMA_BURST_SIZE_CH15	30
+#define BM_APBH_DMA_BURST_SIZE_CH15	0xC0000000
+#define BF_APBH_DMA_BURST_SIZE_CH15(v) \
+		(((v) << 30) & BM_APBH_DMA_BURST_SIZE_CH15)
+#define BP_APBH_DMA_BURST_SIZE_CH14	28
+#define BM_APBH_DMA_BURST_SIZE_CH14	0x30000000
+#define BF_APBH_DMA_BURST_SIZE_CH14(v)  \
+		(((v) << 28) & BM_APBH_DMA_BURST_SIZE_CH14)
+#define BP_APBH_DMA_BURST_SIZE_CH13	26
+#define BM_APBH_DMA_BURST_SIZE_CH13	0x0C000000
+#define BF_APBH_DMA_BURST_SIZE_CH13(v)  \
+		(((v) << 26) & BM_APBH_DMA_BURST_SIZE_CH13)
+#define BP_APBH_DMA_BURST_SIZE_CH12	24
+#define BM_APBH_DMA_BURST_SIZE_CH12	0x03000000
+#define BF_APBH_DMA_BURST_SIZE_CH12(v)  \
+		(((v) << 24) & BM_APBH_DMA_BURST_SIZE_CH12)
+#define BP_APBH_DMA_BURST_SIZE_CH11	22
+#define BM_APBH_DMA_BURST_SIZE_CH11	0x00C00000
+#define BF_APBH_DMA_BURST_SIZE_CH11(v)  \
+		(((v) << 22) & BM_APBH_DMA_BURST_SIZE_CH11)
+#define BP_APBH_DMA_BURST_SIZE_CH10	20
+#define BM_APBH_DMA_BURST_SIZE_CH10	0x00300000
+#define BF_APBH_DMA_BURST_SIZE_CH10(v)  \
+		(((v) << 20) & BM_APBH_DMA_BURST_SIZE_CH10)
+#define BP_APBH_DMA_BURST_SIZE_CH9	18
+#define BM_APBH_DMA_BURST_SIZE_CH9	0x000C0000
+#define BF_APBH_DMA_BURST_SIZE_CH9(v)  \
+		(((v) << 18) & BM_APBH_DMA_BURST_SIZE_CH9)
+#define BP_APBH_DMA_BURST_SIZE_CH8	16
+#define BM_APBH_DMA_BURST_SIZE_CH8	0x00030000
+#define BF_APBH_DMA_BURST_SIZE_CH8(v)  \
+		(((v) << 16) & BM_APBH_DMA_BURST_SIZE_CH8)
+#define BP_APBH_DMA_BURST_SIZE_CH7	14
+#define BM_APBH_DMA_BURST_SIZE_CH7	0x0000C000
+#define BF_APBH_DMA_BURST_SIZE_CH7(v)  \
+		(((v) << 14) & BM_APBH_DMA_BURST_SIZE_CH7)
+#define BP_APBH_DMA_BURST_SIZE_CH6	12
+#define BM_APBH_DMA_BURST_SIZE_CH6	0x00003000
+#define BF_APBH_DMA_BURST_SIZE_CH6(v)  \
+		(((v) << 12) & BM_APBH_DMA_BURST_SIZE_CH6)
+#define BP_APBH_DMA_BURST_SIZE_CH5	10
+#define BM_APBH_DMA_BURST_SIZE_CH5	0x00000C00
+#define BF_APBH_DMA_BURST_SIZE_CH5(v)  \
+		(((v) << 10) & BM_APBH_DMA_BURST_SIZE_CH5)
+#define BP_APBH_DMA_BURST_SIZE_CH4	8
+#define BM_APBH_DMA_BURST_SIZE_CH4	0x00000300
+#define BF_APBH_DMA_BURST_SIZE_CH4(v)  \
+		(((v) << 8) & BM_APBH_DMA_BURST_SIZE_CH4)
+#define BP_APBH_DMA_BURST_SIZE_CH3	6
+#define BM_APBH_DMA_BURST_SIZE_CH3	0x000000C0
+#define BF_APBH_DMA_BURST_SIZE_CH3(v)  \
+		(((v) << 6) & BM_APBH_DMA_BURST_SIZE_CH3)
+#define BV_APBH_DMA_BURST_SIZE_CH3__BURST0 0x0
+#define BV_APBH_DMA_BURST_SIZE_CH3__BURST4 0x1
+#define BV_APBH_DMA_BURST_SIZE_CH3__BURST8 0x2
+#define BP_APBH_DMA_BURST_SIZE_CH2	4
+#define BM_APBH_DMA_BURST_SIZE_CH2	0x00000030
+#define BF_APBH_DMA_BURST_SIZE_CH2(v)  \
+		(((v) << 4) & BM_APBH_DMA_BURST_SIZE_CH2)
+#define BV_APBH_DMA_BURST_SIZE_CH2__BURST0 0x0
+#define BV_APBH_DMA_BURST_SIZE_CH2__BURST4 0x1
+#define BV_APBH_DMA_BURST_SIZE_CH2__BURST8 0x2
+#define BP_APBH_DMA_BURST_SIZE_CH1	2
+#define BM_APBH_DMA_BURST_SIZE_CH1	0x0000000C
+#define BF_APBH_DMA_BURST_SIZE_CH1(v)  \
+		(((v) << 2) & BM_APBH_DMA_BURST_SIZE_CH1)
+#define BV_APBH_DMA_BURST_SIZE_CH1__BURST0 0x0
+#define BV_APBH_DMA_BURST_SIZE_CH1__BURST4 0x1
+#define BV_APBH_DMA_BURST_SIZE_CH1__BURST8 0x2
+#define BP_APBH_DMA_BURST_SIZE_CH0	0
+#define BM_APBH_DMA_BURST_SIZE_CH0	0x00000003
+#define BF_APBH_DMA_BURST_SIZE_CH0(v)  \
+		(((v) << 0) & BM_APBH_DMA_BURST_SIZE_CH0)
+#define BV_APBH_DMA_BURST_SIZE_CH0__BURST0 0x0
+#define BV_APBH_DMA_BURST_SIZE_CH0__BURST4 0x1
+#define BV_APBH_DMA_BURST_SIZE_CH0__BURST8 0x2
+
+#define HW_APBH_DEBUG	(0x00000060)
+
+#define BP_APBH_DEBUG_RSVD	1
+#define BM_APBH_DEBUG_RSVD	0xFFFFFFFE
+#define BF_APBH_DEBUG_RSVD(v) \
+		(((v) << 1) & BM_APBH_DEBUG_RSVD)
+#define BM_APBH_DEBUG_GPMI_ONE_FIFO	0x00000001
+
+/*
+ *  multi-register-define name HW_APBH_CHn_CURCMDAR
+ *              base 0x00000100
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_CURCMDAR(n)	(0x00000100 + (n) * 0x70)
+#define BP_APBH_CHn_CURCMDAR_CMD_ADDR	0
+#define BM_APBH_CHn_CURCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBH_CHn_CURCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_NXTCMDAR
+ *              base 0x00000110
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_NXTCMDAR(n)	(0x00000110 + (n) * 0x70)
+#define BP_APBH_CHn_NXTCMDAR_CMD_ADDR	0
+#define BM_APBH_CHn_NXTCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBH_CHn_NXTCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_CMD
+ *              base 0x00000120
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_CMD(n)	(0x00000120 + (n) * 0x70)
+#define BP_APBH_CHn_CMD_XFER_COUNT	16
+#define BM_APBH_CHn_CMD_XFER_COUNT	0xFFFF0000
+#define BF_APBH_CHn_CMD_XFER_COUNT(v) \
+		(((v) << 16) & BM_APBH_CHn_CMD_XFER_COUNT)
+#define BP_APBH_CHn_CMD_CMDWORDS	12
+#define BM_APBH_CHn_CMD_CMDWORDS	0x0000F000
+#define BF_APBH_CHn_CMD_CMDWORDS(v)  \
+		(((v) << 12) & BM_APBH_CHn_CMD_CMDWORDS)
+#define BP_APBH_CHn_CMD_RSVD1	9
+#define BM_APBH_CHn_CMD_RSVD1	0x00000E00
+#define BF_APBH_CHn_CMD_RSVD1(v)  \
+		(((v) << 9) & BM_APBH_CHn_CMD_RSVD1)
+#define BM_APBH_CHn_CMD_HALTONTERMINATE	0x00000100
+#define BM_APBH_CHn_CMD_WAIT4ENDCMD	0x00000080
+#define BM_APBH_CHn_CMD_SEMAPHORE	0x00000040
+#define BM_APBH_CHn_CMD_NANDWAIT4READY	0x00000020
+#define BM_APBH_CHn_CMD_NANDLOCK	0x00000010
+#define BM_APBH_CHn_CMD_IRQONCMPLT	0x00000008
+#define BM_APBH_CHn_CMD_CHAIN	0x00000004
+#define BP_APBH_CHn_CMD_COMMAND	0
+#define BM_APBH_CHn_CMD_COMMAND	0x00000003
+#define BF_APBH_CHn_CMD_COMMAND(v)  \
+		(((v) << 0) & BM_APBH_CHn_CMD_COMMAND)
+#define BV_APBH_CHn_CMD_COMMAND__NO_DMA_XFER 0x0
+#define BV_APBH_CHn_CMD_COMMAND__DMA_WRITE   0x1
+#define BV_APBH_CHn_CMD_COMMAND__DMA_READ    0x2
+#define BV_APBH_CHn_CMD_COMMAND__DMA_SENSE   0x3
+
+/*
+ *  multi-register-define name HW_APBH_CHn_BAR
+ *              base 0x00000130
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_BAR(n)	(0x00000130 + (n) * 0x70)
+#define BP_APBH_CHn_BAR_ADDRESS	0
+#define BM_APBH_CHn_BAR_ADDRESS	0xFFFFFFFF
+#define BF_APBH_CHn_BAR_ADDRESS(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_SEMA
+ *              base 0x00000140
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_SEMA(n)	(0x00000140 + (n) * 0x70)
+#define BP_APBH_CHn_SEMA_RSVD2	24
+#define BM_APBH_CHn_SEMA_RSVD2	0xFF000000
+#define BF_APBH_CHn_SEMA_RSVD2(v) \
+		(((v) << 24) & BM_APBH_CHn_SEMA_RSVD2)
+#define BP_APBH_CHn_SEMA_PHORE	16
+#define BM_APBH_CHn_SEMA_PHORE	0x00FF0000
+#define BF_APBH_CHn_SEMA_PHORE(v)  \
+		(((v) << 16) & BM_APBH_CHn_SEMA_PHORE)
+#define BP_APBH_CHn_SEMA_RSVD1	8
+#define BM_APBH_CHn_SEMA_RSVD1	0x0000FF00
+#define BF_APBH_CHn_SEMA_RSVD1(v)  \
+		(((v) << 8) & BM_APBH_CHn_SEMA_RSVD1)
+#define BP_APBH_CHn_SEMA_INCREMENT_SEMA	0
+#define BM_APBH_CHn_SEMA_INCREMENT_SEMA	0x000000FF
+#define BF_APBH_CHn_SEMA_INCREMENT_SEMA(v)  \
+		(((v) << 0) & BM_APBH_CHn_SEMA_INCREMENT_SEMA)
+
+/*
+ *  multi-register-define name HW_APBH_CHn_DEBUG1
+ *              base 0x00000150
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_DEBUG1(n)	(0x00000150 + (n) * 0x70)
+#define BM_APBH_CHn_DEBUG1_REQ	0x80000000
+#define BM_APBH_CHn_DEBUG1_BURST	0x40000000
+#define BM_APBH_CHn_DEBUG1_KICK	0x20000000
+#define BM_APBH_CHn_DEBUG1_END	0x10000000
+#define BM_APBH_CHn_DEBUG1_SENSE	0x08000000
+#define BM_APBH_CHn_DEBUG1_READY	0x04000000
+#define BM_APBH_CHn_DEBUG1_LOCK	0x02000000
+#define BM_APBH_CHn_DEBUG1_NEXTCMDADDRVALID	0x01000000
+#define BM_APBH_CHn_DEBUG1_RD_FIFO_EMPTY	0x00800000
+#define BM_APBH_CHn_DEBUG1_RD_FIFO_FULL	0x00400000
+#define BM_APBH_CHn_DEBUG1_WR_FIFO_EMPTY	0x00200000
+#define BM_APBH_CHn_DEBUG1_WR_FIFO_FULL	0x00100000
+#define BP_APBH_CHn_DEBUG1_RSVD1	5
+#define BM_APBH_CHn_DEBUG1_RSVD1	0x000FFFE0
+#define BF_APBH_CHn_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_APBH_CHn_DEBUG1_RSVD1)
+#define BP_APBH_CHn_DEBUG1_STATEMACHINE	0
+#define BM_APBH_CHn_DEBUG1_STATEMACHINE	0x0000001F
+#define BF_APBH_CHn_DEBUG1_STATEMACHINE(v)  \
+		(((v) << 0) & BM_APBH_CHn_DEBUG1_STATEMACHINE)
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__IDLE            0x00
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD1        0x01
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD3        0x02
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD2        0x03
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__XFER_DECODE     0x04
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_WAIT        0x05
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__REQ_CMD4        0x06
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__PIO_REQ         0x07
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_FLUSH      0x08
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_WAIT       0x09
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WRITE           0x0C
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__READ_REQ        0x0D
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__CHECK_CHAIN     0x0E
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__XFER_COMPLETE   0x0F
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__TERMINATE       0x14
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WAIT_END        0x15
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WRITE_WAIT      0x1C
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__HALT_AFTER_TERM 0x1D
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__CHECK_WAIT      0x1E
+#define BV_APBH_CHn_DEBUG1_STATEMACHINE__WAIT_READY      0x1F
+
+/*
+ *  multi-register-define name HW_APBH_CHn_DEBUG2
+ *              base 0x00000160
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBH_CHn_DEBUG2(n)	(0x00000160 + (n) * 0x70)
+#define BP_APBH_CHn_DEBUG2_APB_BYTES	16
+#define BM_APBH_CHn_DEBUG2_APB_BYTES	0xFFFF0000
+#define BF_APBH_CHn_DEBUG2_APB_BYTES(v) \
+		(((v) << 16) & BM_APBH_CHn_DEBUG2_APB_BYTES)
+#define BP_APBH_CHn_DEBUG2_AHB_BYTES	0
+#define BM_APBH_CHn_DEBUG2_AHB_BYTES	0x0000FFFF
+#define BF_APBH_CHn_DEBUG2_AHB_BYTES(v)  \
+		(((v) << 0) & BM_APBH_CHn_DEBUG2_AHB_BYTES)
+
+#define HW_APBH_VERSION	(0x00000800)
+
+#define BP_APBH_VERSION_MAJOR	24
+#define BM_APBH_VERSION_MAJOR	0xFF000000
+#define BF_APBH_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_APBH_VERSION_MAJOR)
+#define BP_APBH_VERSION_MINOR	16
+#define BM_APBH_VERSION_MINOR	0x00FF0000
+#define BF_APBH_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_APBH_VERSION_MINOR)
+#define BP_APBH_VERSION_STEP	0
+#define BM_APBH_VERSION_STEP	0x0000FFFF
+#define BF_APBH_VERSION_STEP(v)  \
+		(((v) << 0) & BM_APBH_VERSION_STEP)
+#endif /* __ARCH_ARM___APBH_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-i2c.h b/arch/arm/mach-mx28/include/mach/regs-i2c.h
new file mode 100755
index 0000000..7199744
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-i2c.h
@@ -0,0 +1,498 @@
+/*
+ * Freescale I2C Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.54
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___I2C_H
+#define __ARCH_ARM___I2C_H
+
+
+#define HW_I2C_CTRL0	(0x00000000)
+#define HW_I2C_CTRL0_SET	(0x00000004)
+#define HW_I2C_CTRL0_CLR	(0x00000008)
+#define HW_I2C_CTRL0_TOG	(0x0000000c)
+
+#define BM_I2C_CTRL0_SFTRST	0x80000000
+#define BV_I2C_CTRL0_SFTRST__RUN   0x0
+#define BV_I2C_CTRL0_SFTRST__RESET 0x1
+#define BM_I2C_CTRL0_CLKGATE	0x40000000
+#define BV_I2C_CTRL0_CLKGATE__RUN     0x0
+#define BV_I2C_CTRL0_CLKGATE__NO_CLKS 0x1
+#define BM_I2C_CTRL0_RUN	0x20000000
+#define BV_I2C_CTRL0_RUN__HALT 0x0
+#define BV_I2C_CTRL0_RUN__RUN  0x1
+#define BM_I2C_CTRL0_RSVD2	0x10000000
+#define BM_I2C_CTRL0_PRE_ACK	0x08000000
+#define BM_I2C_CTRL0_ACKNOWLEDGE	0x04000000
+#define BV_I2C_CTRL0_ACKNOWLEDGE__SNAK 0x0
+#define BV_I2C_CTRL0_ACKNOWLEDGE__ACK  0x1
+#define BM_I2C_CTRL0_SEND_NAK_ON_LAST	0x02000000
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__ACK_IT 0x0
+#define BV_I2C_CTRL0_SEND_NAK_ON_LAST__NAK_IT 0x1
+#define BM_I2C_CTRL0_RSVD1	0x01000000
+#define BM_I2C_CTRL0_MULTI_MASTER	0x00800000
+#define BV_I2C_CTRL0_MULTI_MASTER__SINGLE   0x0
+#define BV_I2C_CTRL0_MULTI_MASTER__MULTIPLE 0x1
+#define BM_I2C_CTRL0_CLOCK_HELD	0x00400000
+#define BV_I2C_CTRL0_CLOCK_HELD__RELEASE  0x0
+#define BV_I2C_CTRL0_CLOCK_HELD__HELD_LOW 0x1
+#define BM_I2C_CTRL0_RETAIN_CLOCK	0x00200000
+#define BV_I2C_CTRL0_RETAIN_CLOCK__RELEASE  0x0
+#define BV_I2C_CTRL0_RETAIN_CLOCK__HOLD_LOW 0x1
+#define BM_I2C_CTRL0_POST_SEND_STOP	0x00100000
+#define BV_I2C_CTRL0_POST_SEND_STOP__NO_STOP   0x0
+#define BV_I2C_CTRL0_POST_SEND_STOP__SEND_STOP 0x1
+#define BM_I2C_CTRL0_PRE_SEND_START	0x00080000
+#define BV_I2C_CTRL0_PRE_SEND_START__NO_START   0x0
+#define BV_I2C_CTRL0_PRE_SEND_START__SEND_START 0x1
+#define BM_I2C_CTRL0_SLAVE_ADDRESS_ENABLE	0x00040000
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__DISABLED 0x0
+#define BV_I2C_CTRL0_SLAVE_ADDRESS_ENABLE__ENABLED  0x1
+#define BM_I2C_CTRL0_MASTER_MODE	0x00020000
+#define BV_I2C_CTRL0_MASTER_MODE__SLAVE  0x0
+#define BV_I2C_CTRL0_MASTER_MODE__MASTER 0x1
+#define BM_I2C_CTRL0_DIRECTION	0x00010000
+#define BV_I2C_CTRL0_DIRECTION__RECEIVE  0x0
+#define BV_I2C_CTRL0_DIRECTION__TRANSMIT 0x1
+#define BP_I2C_CTRL0_XFER_COUNT	0
+#define BM_I2C_CTRL0_XFER_COUNT	0x0000FFFF
+#define BF_I2C_CTRL0_XFER_COUNT(v)  \
+		(((v) << 0) & BM_I2C_CTRL0_XFER_COUNT)
+
+#define HW_I2C_TIMING0	(0x00000010)
+#define HW_I2C_TIMING0_SET	(0x00000014)
+#define HW_I2C_TIMING0_CLR	(0x00000018)
+#define HW_I2C_TIMING0_TOG	(0x0000001c)
+
+#define BP_I2C_TIMING0_RSVD2	26
+#define BM_I2C_TIMING0_RSVD2	0xFC000000
+#define BF_I2C_TIMING0_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING0_RSVD2)
+#define BP_I2C_TIMING0_HIGH_COUNT	16
+#define BM_I2C_TIMING0_HIGH_COUNT	0x03FF0000
+#define BF_I2C_TIMING0_HIGH_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING0_HIGH_COUNT)
+#define BP_I2C_TIMING0_RSVD1	10
+#define BM_I2C_TIMING0_RSVD1	0x0000FC00
+#define BF_I2C_TIMING0_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING0_RSVD1)
+#define BP_I2C_TIMING0_RCV_COUNT	0
+#define BM_I2C_TIMING0_RCV_COUNT	0x000003FF
+#define BF_I2C_TIMING0_RCV_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING0_RCV_COUNT)
+
+#define HW_I2C_TIMING1	(0x00000020)
+#define HW_I2C_TIMING1_SET	(0x00000024)
+#define HW_I2C_TIMING1_CLR	(0x00000028)
+#define HW_I2C_TIMING1_TOG	(0x0000002c)
+
+#define BP_I2C_TIMING1_RSVD2	26
+#define BM_I2C_TIMING1_RSVD2	0xFC000000
+#define BF_I2C_TIMING1_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING1_RSVD2)
+#define BP_I2C_TIMING1_LOW_COUNT	16
+#define BM_I2C_TIMING1_LOW_COUNT	0x03FF0000
+#define BF_I2C_TIMING1_LOW_COUNT(v)  \
+		(((v) << 16) & BM_I2C_TIMING1_LOW_COUNT)
+#define BP_I2C_TIMING1_RSVD1	10
+#define BM_I2C_TIMING1_RSVD1	0x0000FC00
+#define BF_I2C_TIMING1_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING1_RSVD1)
+#define BP_I2C_TIMING1_XMIT_COUNT	0
+#define BM_I2C_TIMING1_XMIT_COUNT	0x000003FF
+#define BF_I2C_TIMING1_XMIT_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING1_XMIT_COUNT)
+
+#define HW_I2C_TIMING2	(0x00000030)
+#define HW_I2C_TIMING2_SET	(0x00000034)
+#define HW_I2C_TIMING2_CLR	(0x00000038)
+#define HW_I2C_TIMING2_TOG	(0x0000003c)
+
+#define BP_I2C_TIMING2_RSVD2	26
+#define BM_I2C_TIMING2_RSVD2	0xFC000000
+#define BF_I2C_TIMING2_RSVD2(v) \
+		(((v) << 26) & BM_I2C_TIMING2_RSVD2)
+#define BP_I2C_TIMING2_BUS_FREE	16
+#define BM_I2C_TIMING2_BUS_FREE	0x03FF0000
+#define BF_I2C_TIMING2_BUS_FREE(v)  \
+		(((v) << 16) & BM_I2C_TIMING2_BUS_FREE)
+#define BP_I2C_TIMING2_RSVD1	10
+#define BM_I2C_TIMING2_RSVD1	0x0000FC00
+#define BF_I2C_TIMING2_RSVD1(v)  \
+		(((v) << 10) & BM_I2C_TIMING2_RSVD1)
+#define BP_I2C_TIMING2_LEADIN_COUNT	0
+#define BM_I2C_TIMING2_LEADIN_COUNT	0x000003FF
+#define BF_I2C_TIMING2_LEADIN_COUNT(v)  \
+		(((v) << 0) & BM_I2C_TIMING2_LEADIN_COUNT)
+
+#define HW_I2C_CTRL1	(0x00000040)
+#define HW_I2C_CTRL1_SET	(0x00000044)
+#define HW_I2C_CTRL1_CLR	(0x00000048)
+#define HW_I2C_CTRL1_TOG	(0x0000004c)
+
+#define BM_I2C_CTRL1_RSVD1	0x80000000
+#define BM_I2C_CTRL1_RD_QUEUE_IRQ	0x40000000
+#define BV_I2C_CTRL1_RD_QUEUE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_RD_QUEUE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_WR_QUEUE_IRQ	0x20000000
+#define BV_I2C_CTRL1_WR_QUEUE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_WR_QUEUE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_CLR_GOT_A_NAK	0x10000000
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__DO_NOTHING 0x0
+#define BV_I2C_CTRL1_CLR_GOT_A_NAK__CLEAR      0x1
+#define BM_I2C_CTRL1_ACK_MODE	0x08000000
+#define BV_I2C_CTRL1_ACK_MODE__ACK_AFTER_HOLD_LOW  0x0
+#define BV_I2C_CTRL1_ACK_MODE__ACK_BEFORE_HOLD_LOW 0x1
+#define BM_I2C_CTRL1_FORCE_DATA_IDLE	0x04000000
+#define BM_I2C_CTRL1_FORCE_CLK_IDLE	0x02000000
+#define BM_I2C_CTRL1_BCAST_SLAVE_EN	0x01000000
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__NO_BCAST    0x0
+#define BV_I2C_CTRL1_BCAST_SLAVE_EN__WATCH_BCAST 0x1
+#define BP_I2C_CTRL1_SLAVE_ADDRESS_BYTE	16
+#define BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE	0x00FF0000
+#define BF_I2C_CTRL1_SLAVE_ADDRESS_BYTE(v)  \
+		(((v) << 16) & BM_I2C_CTRL1_SLAVE_ADDRESS_BYTE)
+#define BM_I2C_CTRL1_BUS_FREE_IRQ_EN	0x00008000
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN	0x00004000
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN	0x00002000
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN	0x00001000
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ_EN	0x00000800
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ_EN	0x00000400
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ_EN	0x00000200
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ_EN	0x00000100
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_CTRL1_BUS_FREE_IRQ	0x00000080
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_BUS_FREE_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ	0x00000040
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_DATA_ENGINE_CMPLT_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_NO_SLAVE_ACK_IRQ	0x00000020
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_NO_SLAVE_ACK_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ	0x00000010
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_OVERSIZE_XFER_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_EARLY_TERM_IRQ	0x00000008
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_EARLY_TERM_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_MASTER_LOSS_IRQ	0x00000004
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_MASTER_LOSS_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_STOP_IRQ	0x00000002
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_STOP_IRQ__REQUEST    0x1
+#define BM_I2C_CTRL1_SLAVE_IRQ	0x00000001
+#define BV_I2C_CTRL1_SLAVE_IRQ__NO_REQUEST 0x0
+#define BV_I2C_CTRL1_SLAVE_IRQ__REQUEST    0x1
+
+#define HW_I2C_STAT	(0x00000050)
+
+#define BM_I2C_STAT_MASTER_PRESENT	0x80000000
+#define BV_I2C_STAT_MASTER_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_MASTER_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_SLAVE_PRESENT	0x40000000
+#define BV_I2C_STAT_SLAVE_PRESENT__UNAVAILABLE 0x0
+#define BV_I2C_STAT_SLAVE_PRESENT__AVAILABLE   0x1
+#define BM_I2C_STAT_ANY_ENABLED_IRQ	0x20000000
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__NO_REQUESTS          0x0
+#define BV_I2C_STAT_ANY_ENABLED_IRQ__AT_LEAST_ONE_REQUEST 0x1
+#define BM_I2C_STAT_GOT_A_NAK	0x10000000
+#define BV_I2C_STAT_GOT_A_NAK__NO_NAK       0x0
+#define BV_I2C_STAT_GOT_A_NAK__DETECTED_NAK 0x1
+#define BP_I2C_STAT_RSVD1	24
+#define BM_I2C_STAT_RSVD1	0x0F000000
+#define BF_I2C_STAT_RSVD1(v)  \
+		(((v) << 24) & BM_I2C_STAT_RSVD1)
+#define BP_I2C_STAT_RCVD_SLAVE_ADDR	16
+#define BM_I2C_STAT_RCVD_SLAVE_ADDR	0x00FF0000
+#define BF_I2C_STAT_RCVD_SLAVE_ADDR(v)  \
+		(((v) << 16) & BM_I2C_STAT_RCVD_SLAVE_ADDR)
+#define BM_I2C_STAT_SLAVE_ADDR_EQ_ZERO	0x00008000
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__ZERO_NOT_MATCHED 0x0
+#define BV_I2C_STAT_SLAVE_ADDR_EQ_ZERO__WAS_ZERO         0x1
+#define BM_I2C_STAT_SLAVE_FOUND	0x00004000
+#define BV_I2C_STAT_SLAVE_FOUND__IDLE    0x0
+#define BV_I2C_STAT_SLAVE_FOUND__WAITING 0x1
+#define BM_I2C_STAT_SLAVE_SEARCHING	0x00002000
+#define BV_I2C_STAT_SLAVE_SEARCHING__IDLE   0x0
+#define BV_I2C_STAT_SLAVE_SEARCHING__ACTIVE 0x1
+#define BM_I2C_STAT_DATA_ENGINE_DMA_WAIT	0x00001000
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__CONTINUE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_DMA_WAIT__WAITING  0x1
+#define BM_I2C_STAT_BUS_BUSY	0x00000800
+#define BV_I2C_STAT_BUS_BUSY__IDLE 0x0
+#define BV_I2C_STAT_BUS_BUSY__BUSY 0x1
+#define BM_I2C_STAT_CLK_GEN_BUSY	0x00000400
+#define BV_I2C_STAT_CLK_GEN_BUSY__IDLE 0x0
+#define BV_I2C_STAT_CLK_GEN_BUSY__BUSY 0x1
+#define BM_I2C_STAT_DATA_ENGINE_BUSY	0x00000200
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_DATA_ENGINE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_SLAVE_BUSY	0x00000100
+#define BV_I2C_STAT_SLAVE_BUSY__IDLE 0x0
+#define BV_I2C_STAT_SLAVE_BUSY__BUSY 0x1
+#define BM_I2C_STAT_BUS_FREE_IRQ_SUMMARY	0x00000080
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_BUS_FREE_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY	0x00000040
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_DATA_ENGINE_CMPLT_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY	0x00000020
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_NO_SLAVE_ACK_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY	0x00000010
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_OVERSIZE_XFER_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_EARLY_TERM_IRQ_SUMMARY	0x00000008
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_EARLY_TERM_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY	0x00000004
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_MASTER_LOSS_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY	0x00000002
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_STOP_IRQ_SUMMARY__REQUEST    0x1
+#define BM_I2C_STAT_SLAVE_IRQ_SUMMARY	0x00000001
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__NO_REQUEST 0x0
+#define BV_I2C_STAT_SLAVE_IRQ_SUMMARY__REQUEST    0x1
+
+#define HW_I2C_QUEUECTRL	(0x00000060)
+#define HW_I2C_QUEUECTRL_SET	(0x00000064)
+#define HW_I2C_QUEUECTRL_CLR	(0x00000068)
+#define HW_I2C_QUEUECTRL_TOG	(0x0000006c)
+
+#define BP_I2C_QUEUECTRL_RSVD3	21
+#define BM_I2C_QUEUECTRL_RSVD3	0xFFE00000
+#define BF_I2C_QUEUECTRL_RSVD3(v) \
+		(((v) << 21) & BM_I2C_QUEUECTRL_RSVD3)
+#define BP_I2C_QUEUECTRL_RD_THRESH	16
+#define BM_I2C_QUEUECTRL_RD_THRESH	0x001F0000
+#define BF_I2C_QUEUECTRL_RD_THRESH(v)  \
+		(((v) << 16) & BM_I2C_QUEUECTRL_RD_THRESH)
+#define BP_I2C_QUEUECTRL_RSVD2	13
+#define BM_I2C_QUEUECTRL_RSVD2	0x0000E000
+#define BF_I2C_QUEUECTRL_RSVD2(v)  \
+		(((v) << 13) & BM_I2C_QUEUECTRL_RSVD2)
+#define BP_I2C_QUEUECTRL_WR_THRESH	8
+#define BM_I2C_QUEUECTRL_WR_THRESH	0x00001F00
+#define BF_I2C_QUEUECTRL_WR_THRESH(v)  \
+		(((v) << 8) & BM_I2C_QUEUECTRL_WR_THRESH)
+#define BP_I2C_QUEUECTRL_RSVD1	6
+#define BM_I2C_QUEUECTRL_RSVD1	0x000000C0
+#define BF_I2C_QUEUECTRL_RSVD1(v)  \
+		(((v) << 6) & BM_I2C_QUEUECTRL_RSVD1)
+#define BM_I2C_QUEUECTRL_QUEUE_RUN	0x00000020
+#define BV_I2C_QUEUECTRL_QUEUE_RUN__STOP  0x0
+#define BV_I2C_QUEUECTRL_QUEUE_RUN__START 0x1
+#define BM_I2C_QUEUECTRL_RD_CLEAR	0x00000010
+#define BM_I2C_QUEUECTRL_WR_CLEAR	0x00000008
+#define BM_I2C_QUEUECTRL_PIO_QUEUE_MODE	0x00000004
+#define BM_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN	0x00000002
+#define BV_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_QUEUECTRL_RD_QUEUE_IRQ_EN__ENABLED  0x1
+#define BM_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN	0x00000001
+#define BV_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN__DISABLED 0x0
+#define BV_I2C_QUEUECTRL_WR_QUEUE_IRQ_EN__ENABLED  0x1
+
+#define HW_I2C_QUEUESTAT	(0x00000070)
+#define HW_I2C_QUEUESTAT_SET	(0x00000074)
+#define HW_I2C_QUEUESTAT_CLR	(0x00000078)
+#define HW_I2C_QUEUESTAT_TOG	(0x0000007c)
+
+#define BP_I2C_QUEUESTAT_RSVD2	15
+#define BM_I2C_QUEUESTAT_RSVD2	0xFFFF8000
+#define BF_I2C_QUEUESTAT_RSVD2(v) \
+		(((v) << 15) & BM_I2C_QUEUESTAT_RSVD2)
+#define BM_I2C_QUEUESTAT_RD_QUEUE_FULL	0x00004000
+#define BM_I2C_QUEUESTAT_RD_QUEUE_EMPTY	0x00002000
+#define BP_I2C_QUEUESTAT_RD_QUEUE_CNT	8
+#define BM_I2C_QUEUESTAT_RD_QUEUE_CNT	0x00001F00
+#define BF_I2C_QUEUESTAT_RD_QUEUE_CNT(v)  \
+		(((v) << 8) & BM_I2C_QUEUESTAT_RD_QUEUE_CNT)
+#define BM_I2C_QUEUESTAT_RSVD1	0x00000080
+#define BM_I2C_QUEUESTAT_WR_QUEUE_FULL	0x00000040
+#define BM_I2C_QUEUESTAT_WR_QUEUE_EMPTY	0x00000020
+#define BP_I2C_QUEUESTAT_WR_QUEUE_CNT	0
+#define BM_I2C_QUEUESTAT_WR_QUEUE_CNT	0x0000001F
+#define BF_I2C_QUEUESTAT_WR_QUEUE_CNT(v)  \
+		(((v) << 0) & BM_I2C_QUEUESTAT_WR_QUEUE_CNT)
+
+#define HW_I2C_QUEUECMD	(0x00000080)
+#define HW_I2C_QUEUECMD_SET	(0x00000084)
+#define HW_I2C_QUEUECMD_CLR	(0x00000088)
+#define HW_I2C_QUEUECMD_TOG	(0x0000008c)
+
+#define BP_I2C_QUEUECMD_RSVD2	28
+#define BM_I2C_QUEUECMD_RSVD2	0xF0000000
+#define BF_I2C_QUEUECMD_RSVD2(v) \
+		(((v) << 28) & BM_I2C_QUEUECMD_RSVD2)
+#define BM_I2C_QUEUECMD_PRE_ACK	0x08000000
+#define BM_I2C_QUEUECMD_ACKNOWLEDGE	0x04000000
+#define BV_I2C_QUEUECMD_ACKNOWLEDGE__SNAK 0x0
+#define BV_I2C_QUEUECMD_ACKNOWLEDGE__ACK  0x1
+#define BM_I2C_QUEUECMD_SEND_NAK_ON_LAST	0x02000000
+#define BV_I2C_QUEUECMD_SEND_NAK_ON_LAST__ACK_IT 0x0
+#define BV_I2C_QUEUECMD_SEND_NAK_ON_LAST__NAK_IT 0x1
+#define BM_I2C_QUEUECMD_RSVD1	0x01000000
+#define BM_I2C_QUEUECMD_MULTI_MASTER	0x00800000
+#define BV_I2C_QUEUECMD_MULTI_MASTER__SINGLE   0x0
+#define BV_I2C_QUEUECMD_MULTI_MASTER__MULTIPLE 0x1
+#define BM_I2C_QUEUECMD_CLOCK_HELD	0x00400000
+#define BV_I2C_QUEUECMD_CLOCK_HELD__RELEASE  0x0
+#define BV_I2C_QUEUECMD_CLOCK_HELD__HELD_LOW 0x1
+#define BM_I2C_QUEUECMD_RETAIN_CLOCK	0x00200000
+#define BV_I2C_QUEUECMD_RETAIN_CLOCK__RELEASE  0x0
+#define BV_I2C_QUEUECMD_RETAIN_CLOCK__HOLD_LOW 0x1
+#define BM_I2C_QUEUECMD_POST_SEND_STOP	0x00100000
+#define BV_I2C_QUEUECMD_POST_SEND_STOP__NO_STOP   0x0
+#define BV_I2C_QUEUECMD_POST_SEND_STOP__SEND_STOP 0x1
+#define BM_I2C_QUEUECMD_PRE_SEND_START	0x00080000
+#define BV_I2C_QUEUECMD_PRE_SEND_START__NO_START   0x0
+#define BV_I2C_QUEUECMD_PRE_SEND_START__SEND_START 0x1
+#define BM_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE	0x00040000
+#define BV_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE__DISABLED 0x0
+#define BV_I2C_QUEUECMD_SLAVE_ADDRESS_ENABLE__ENABLED  0x1
+#define BM_I2C_QUEUECMD_MASTER_MODE	0x00020000
+#define BV_I2C_QUEUECMD_MASTER_MODE__SLAVE  0x0
+#define BV_I2C_QUEUECMD_MASTER_MODE__MASTER 0x1
+#define BM_I2C_QUEUECMD_DIRECTION	0x00010000
+#define BV_I2C_QUEUECMD_DIRECTION__RECEIVE  0x0
+#define BV_I2C_QUEUECMD_DIRECTION__TRANSMIT 0x1
+#define BP_I2C_QUEUECMD_XFER_COUNT	0
+#define BM_I2C_QUEUECMD_XFER_COUNT	0x0000FFFF
+#define BF_I2C_QUEUECMD_XFER_COUNT(v)  \
+		(((v) << 0) & BM_I2C_QUEUECMD_XFER_COUNT)
+
+#define HW_I2C_QUEUEDATA	(0x00000090)
+
+#define BP_I2C_QUEUEDATA_DATA	0
+#define BM_I2C_QUEUEDATA_DATA	0xFFFFFFFF
+#define BF_I2C_QUEUEDATA_DATA(v)	(v)
+
+#define HW_I2C_DATA	(0x000000a0)
+
+#define BP_I2C_DATA_DATA	0
+#define BM_I2C_DATA_DATA	0xFFFFFFFF
+#define BF_I2C_DATA_DATA(v)	(v)
+
+#define HW_I2C_DEBUG0	(0x000000b0)
+#define HW_I2C_DEBUG0_SET	(0x000000b4)
+#define HW_I2C_DEBUG0_CLR	(0x000000b8)
+#define HW_I2C_DEBUG0_TOG	(0x000000bc)
+
+#define BM_I2C_DEBUG0_DMAREQ	0x80000000
+#define BM_I2C_DEBUG0_DMAENDCMD	0x40000000
+#define BM_I2C_DEBUG0_DMAKICK	0x20000000
+#define BM_I2C_DEBUG0_DMATERMINATE	0x10000000
+#define BP_I2C_DEBUG0_STATE_VALUE	26
+#define BM_I2C_DEBUG0_STATE_VALUE	0x0C000000
+#define BF_I2C_DEBUG0_STATE_VALUE(v)  \
+		(((v) << 26) & BM_I2C_DEBUG0_STATE_VALUE)
+#define BP_I2C_DEBUG0_DMA_STATE	16
+#define BM_I2C_DEBUG0_DMA_STATE	0x03FF0000
+#define BF_I2C_DEBUG0_DMA_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG0_DMA_STATE)
+#define BM_I2C_DEBUG0_START_TOGGLE	0x00008000
+#define BM_I2C_DEBUG0_STOP_TOGGLE	0x00004000
+#define BM_I2C_DEBUG0_GRAB_TOGGLE	0x00002000
+#define BM_I2C_DEBUG0_CHANGE_TOGGLE	0x00001000
+#define BM_I2C_DEBUG0_STATE_LATCH	0x00000800
+#define BM_I2C_DEBUG0_SLAVE_HOLD_CLK	0x00000400
+#define BP_I2C_DEBUG0_SLAVE_STATE	0
+#define BM_I2C_DEBUG0_SLAVE_STATE	0x000003FF
+#define BF_I2C_DEBUG0_SLAVE_STATE(v)  \
+		(((v) << 0) & BM_I2C_DEBUG0_SLAVE_STATE)
+
+#define HW_I2C_DEBUG1	(0x000000c0)
+#define HW_I2C_DEBUG1_SET	(0x000000c4)
+#define HW_I2C_DEBUG1_CLR	(0x000000c8)
+#define HW_I2C_DEBUG1_TOG	(0x000000cc)
+
+#define BM_I2C_DEBUG1_I2C_CLK_IN	0x80000000
+#define BM_I2C_DEBUG1_I2C_DATA_IN	0x40000000
+#define BP_I2C_DEBUG1_RSVD4	28
+#define BM_I2C_DEBUG1_RSVD4	0x30000000
+#define BF_I2C_DEBUG1_RSVD4(v)  \
+		(((v) << 28) & BM_I2C_DEBUG1_RSVD4)
+#define BP_I2C_DEBUG1_DMA_BYTE_ENABLES	24
+#define BM_I2C_DEBUG1_DMA_BYTE_ENABLES	0x0F000000
+#define BF_I2C_DEBUG1_DMA_BYTE_ENABLES(v)  \
+		(((v) << 24) & BM_I2C_DEBUG1_DMA_BYTE_ENABLES)
+#define BP_I2C_DEBUG1_CLK_GEN_STATE	16
+#define BM_I2C_DEBUG1_CLK_GEN_STATE	0x00FF0000
+#define BF_I2C_DEBUG1_CLK_GEN_STATE(v)  \
+		(((v) << 16) & BM_I2C_DEBUG1_CLK_GEN_STATE)
+#define BP_I2C_DEBUG1_RSVD2	11
+#define BM_I2C_DEBUG1_RSVD2	0x0000F800
+#define BF_I2C_DEBUG1_RSVD2(v)  \
+		(((v) << 11) & BM_I2C_DEBUG1_RSVD2)
+#define BP_I2C_DEBUG1_LST_MODE	9
+#define BM_I2C_DEBUG1_LST_MODE	0x00000600
+#define BF_I2C_DEBUG1_LST_MODE(v)  \
+		(((v) << 9) & BM_I2C_DEBUG1_LST_MODE)
+#define BV_I2C_DEBUG1_LST_MODE__BCAST    0x0
+#define BV_I2C_DEBUG1_LST_MODE__MY_WRITE 0x1
+#define BV_I2C_DEBUG1_LST_MODE__MY_READ  0x2
+#define BV_I2C_DEBUG1_LST_MODE__NOT_ME   0x3
+#define BM_I2C_DEBUG1_LOCAL_SLAVE_TEST	0x00000100
+#define BP_I2C_DEBUG1_RSVD1	5
+#define BM_I2C_DEBUG1_RSVD1	0x000000E0
+#define BF_I2C_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_I2C_DEBUG1_RSVD1)
+#define BM_I2C_DEBUG1_FORCE_CLK_ON	0x00000010
+#define BM_I2C_DEBUG1_FORCE_ARB_LOSS	0x00000008
+#define BM_I2C_DEBUG1_FORCE_RCV_ACK	0x00000004
+#define BM_I2C_DEBUG1_FORCE_I2C_DATA_OE	0x00000002
+#define BM_I2C_DEBUG1_FORCE_I2C_CLK_OE	0x00000001
+
+#define HW_I2C_VERSION	(0x000000d0)
+
+#define BP_I2C_VERSION_MAJOR	24
+#define BM_I2C_VERSION_MAJOR	0xFF000000
+#define BF_I2C_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_I2C_VERSION_MAJOR)
+#define BP_I2C_VERSION_MINOR	16
+#define BM_I2C_VERSION_MINOR	0x00FF0000
+#define BF_I2C_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_I2C_VERSION_MINOR)
+#define BP_I2C_VERSION_STEP	0
+#define BM_I2C_VERSION_STEP	0x0000FFFF
+#define BF_I2C_VERSION_STEP(v)  \
+		(((v) << 0) & BM_I2C_VERSION_STEP)
+#endif /* __ARCH_ARM___I2C_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-icoll.h b/arch/arm/mach-mx28/include/mach/regs-icoll.h
new file mode 100644
index 0000000..f06ac0d
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-icoll.h
@@ -0,0 +1,293 @@
+/*
+ * Freescale ICOLL Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.50
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___ICOLL_H
+#define __ARCH_ARM___ICOLL_H
+
+#define HW_ICOLL_VECTOR	(0x00000000)
+#define HW_ICOLL_VECTOR_SET	(0x00000004)
+#define HW_ICOLL_VECTOR_CLR	(0x00000008)
+#define HW_ICOLL_VECTOR_TOG	(0x0000000c)
+
+#define BP_ICOLL_VECTOR_IRQVECTOR	2
+#define BM_ICOLL_VECTOR_IRQVECTOR	0xFFFFFFFC
+#define BF_ICOLL_VECTOR_IRQVECTOR(v) \
+		(((v) << 2) & BM_ICOLL_VECTOR_IRQVECTOR)
+#define BP_ICOLL_VECTOR_RSRVD1	0
+#define BM_ICOLL_VECTOR_RSRVD1	0x00000003
+#define BF_ICOLL_VECTOR_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_VECTOR_RSRVD1)
+
+#define HW_ICOLL_LEVELACK	(0x00000010)
+
+#define BP_ICOLL_LEVELACK_RSRVD1	4
+#define BM_ICOLL_LEVELACK_RSRVD1	0xFFFFFFF0
+#define BF_ICOLL_LEVELACK_RSRVD1(v) \
+		(((v) << 4) & BM_ICOLL_LEVELACK_RSRVD1)
+#define BP_ICOLL_LEVELACK_IRQLEVELACK	0
+#define BM_ICOLL_LEVELACK_IRQLEVELACK	0x0000000F
+#define BF_ICOLL_LEVELACK_IRQLEVELACK(v)  \
+		(((v) << 0) & BM_ICOLL_LEVELACK_IRQLEVELACK)
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0 0x1
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL1 0x2
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL2 0x4
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL3 0x8
+
+#define HW_ICOLL_CTRL	(0x00000020)
+#define HW_ICOLL_CTRL_SET	(0x00000024)
+#define HW_ICOLL_CTRL_CLR	(0x00000028)
+#define HW_ICOLL_CTRL_TOG	(0x0000002c)
+
+#define BM_ICOLL_CTRL_SFTRST	0x80000000
+#define BV_ICOLL_CTRL_SFTRST__RUN      0x0
+#define BV_ICOLL_CTRL_SFTRST__IN_RESET 0x1
+#define BM_ICOLL_CTRL_CLKGATE	0x40000000
+#define BV_ICOLL_CTRL_CLKGATE__RUN       0x0
+#define BV_ICOLL_CTRL_CLKGATE__NO_CLOCKS 0x1
+#define BP_ICOLL_CTRL_RSRVD3	24
+#define BM_ICOLL_CTRL_RSRVD3	0x3F000000
+#define BF_ICOLL_CTRL_RSRVD3(v)  \
+		(((v) << 24) & BM_ICOLL_CTRL_RSRVD3)
+#define BP_ICOLL_CTRL_VECTOR_PITCH	21
+#define BM_ICOLL_CTRL_VECTOR_PITCH	0x00E00000
+#define BF_ICOLL_CTRL_VECTOR_PITCH(v)  \
+		(((v) << 21) & BM_ICOLL_CTRL_VECTOR_PITCH)
+#define BV_ICOLL_CTRL_VECTOR_PITCH__DEFAULT_BY4 0x0
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY4         0x1
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY8         0x2
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY12        0x3
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY16        0x4
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY20        0x5
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY24        0x6
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY28        0x7
+#define BM_ICOLL_CTRL_BYPASS_FSM	0x00100000
+#define BV_ICOLL_CTRL_BYPASS_FSM__NORMAL 0x0
+#define BV_ICOLL_CTRL_BYPASS_FSM__BYPASS 0x1
+#define BM_ICOLL_CTRL_NO_NESTING	0x00080000
+#define BV_ICOLL_CTRL_NO_NESTING__NORMAL  0x0
+#define BV_ICOLL_CTRL_NO_NESTING__NO_NEST 0x1
+#define BM_ICOLL_CTRL_ARM_RSE_MODE	0x00040000
+#define BM_ICOLL_CTRL_FIQ_FINAL_ENABLE	0x00020000
+#define BV_ICOLL_CTRL_FIQ_FINAL_ENABLE__DISABLE 0x0
+#define BV_ICOLL_CTRL_FIQ_FINAL_ENABLE__ENABLE  0x1
+#define BM_ICOLL_CTRL_IRQ_FINAL_ENABLE	0x00010000
+#define BV_ICOLL_CTRL_IRQ_FINAL_ENABLE__DISABLE 0x0
+#define BV_ICOLL_CTRL_IRQ_FINAL_ENABLE__ENABLE  0x1
+#define BP_ICOLL_CTRL_RSRVD1	0
+#define BM_ICOLL_CTRL_RSRVD1	0x0000FFFF
+#define BF_ICOLL_CTRL_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_CTRL_RSRVD1)
+
+#define HW_ICOLL_VBASE	(0x00000040)
+#define HW_ICOLL_VBASE_SET	(0x00000044)
+#define HW_ICOLL_VBASE_CLR	(0x00000048)
+#define HW_ICOLL_VBASE_TOG	(0x0000004c)
+
+#define BP_ICOLL_VBASE_TABLE_ADDRESS	2
+#define BM_ICOLL_VBASE_TABLE_ADDRESS	0xFFFFFFFC
+#define BF_ICOLL_VBASE_TABLE_ADDRESS(v) \
+		(((v) << 2) & BM_ICOLL_VBASE_TABLE_ADDRESS)
+#define BP_ICOLL_VBASE_RSRVD1	0
+#define BM_ICOLL_VBASE_RSRVD1	0x00000003
+#define BF_ICOLL_VBASE_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_VBASE_RSRVD1)
+
+#define HW_ICOLL_STAT	(0x00000070)
+
+#define BP_ICOLL_STAT_RSRVD1	7
+#define BM_ICOLL_STAT_RSRVD1	0xFFFFFF80
+#define BF_ICOLL_STAT_RSRVD1(v) \
+		(((v) << 7) & BM_ICOLL_STAT_RSRVD1)
+#define BP_ICOLL_STAT_VECTOR_NUMBER	0
+#define BM_ICOLL_STAT_VECTOR_NUMBER	0x0000007F
+#define BF_ICOLL_STAT_VECTOR_NUMBER(v)  \
+		(((v) << 0) & BM_ICOLL_STAT_VECTOR_NUMBER)
+
+/*
+ *  multi-register-define name HW_ICOLL_RAWn
+ *              base 0x000000A0
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_ICOLL_RAWn(n)	(0x000000a0 + (n) * 0x10)
+#define HW_ICOLL_RAWn_SET(n)	(0x000000a4 + (n) * 0x10)
+#define HW_ICOLL_RAWn_CLR(n)	(0x000000a8 + (n) * 0x10)
+#define HW_ICOLL_RAWn_TOG(n)	(0x000000ac + (n) * 0x10)
+#define BP_ICOLL_RAWn_RAW_IRQS	0
+#define BM_ICOLL_RAWn_RAW_IRQS	0xFFFFFFFF
+#define BF_ICOLL_RAWn_RAW_IRQS(v)	(v)
+
+/*
+ *  multi-register-define name HW_ICOLL_INTERRUPTn
+ *              base 0x00000120
+ *              count 128
+ *              offset 0x10
+ */
+#define HW_ICOLL_INTERRUPTn(n)	(0x00000120 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_SET(n)	(0x00000124 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_CLR(n)	(0x00000128 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_TOG(n)	(0x0000012c + (n) * 0x10)
+#define BP_ICOLL_INTERRUPTn_RSRVD1	5
+#define BM_ICOLL_INTERRUPTn_RSRVD1	0xFFFFFFE0
+#define BF_ICOLL_INTERRUPTn_RSRVD1(v) \
+		(((v) << 5) & BM_ICOLL_INTERRUPTn_RSRVD1)
+#define BM_ICOLL_INTERRUPTn_ENFIQ	0x00000010
+#define BV_ICOLL_INTERRUPTn_ENFIQ__DISABLE 0x0
+#define BV_ICOLL_INTERRUPTn_ENFIQ__ENABLE  0x1
+#define BM_ICOLL_INTERRUPTn_SOFTIRQ	0x00000008
+#define BV_ICOLL_INTERRUPTn_SOFTIRQ__NO_INTERRUPT    0x0
+#define BV_ICOLL_INTERRUPTn_SOFTIRQ__FORCE_INTERRUPT 0x1
+#define BM_ICOLL_INTERRUPTn_ENABLE	0x00000004
+#define BV_ICOLL_INTERRUPTn_ENABLE__DISABLE 0x0
+#define BV_ICOLL_INTERRUPTn_ENABLE__ENABLE  0x1
+#define BP_ICOLL_INTERRUPTn_PRIORITY	0
+#define BM_ICOLL_INTERRUPTn_PRIORITY	0x00000003
+#define BF_ICOLL_INTERRUPTn_PRIORITY(v)  \
+		(((v) << 0) & BM_ICOLL_INTERRUPTn_PRIORITY)
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL0 0x0
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL1 0x1
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL2 0x2
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL3 0x3
+
+#define HW_ICOLL_DEBUG	(0x00001120)
+#define HW_ICOLL_DEBUG_SET	(0x00001124)
+#define HW_ICOLL_DEBUG_CLR	(0x00001128)
+#define HW_ICOLL_DEBUG_TOG	(0x0000112c)
+
+#define BP_ICOLL_DEBUG_INSERVICE	28
+#define BM_ICOLL_DEBUG_INSERVICE	0xF0000000
+#define BF_ICOLL_DEBUG_INSERVICE(v) \
+		(((v) << 28) & BM_ICOLL_DEBUG_INSERVICE)
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_LEVEL_REQUESTS	24
+#define BM_ICOLL_DEBUG_LEVEL_REQUESTS	0x0F000000
+#define BF_ICOLL_DEBUG_LEVEL_REQUESTS(v)  \
+		(((v) << 24) & BM_ICOLL_DEBUG_LEVEL_REQUESTS)
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_REQUESTS_BY_LEVEL	20
+#define BM_ICOLL_DEBUG_REQUESTS_BY_LEVEL	0x00F00000
+#define BF_ICOLL_DEBUG_REQUESTS_BY_LEVEL(v)  \
+		(((v) << 20) & BM_ICOLL_DEBUG_REQUESTS_BY_LEVEL)
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_RSRVD2	18
+#define BM_ICOLL_DEBUG_RSRVD2	0x000C0000
+#define BF_ICOLL_DEBUG_RSRVD2(v)  \
+		(((v) << 18) & BM_ICOLL_DEBUG_RSRVD2)
+#define BM_ICOLL_DEBUG_FIQ	0x00020000
+#define BV_ICOLL_DEBUG_FIQ__NO_FIQ_REQUESTED 0x0
+#define BV_ICOLL_DEBUG_FIQ__FIQ_REQUESTED    0x1
+#define BM_ICOLL_DEBUG_IRQ	0x00010000
+#define BV_ICOLL_DEBUG_IRQ__NO_IRQ_REQUESTED 0x0
+#define BV_ICOLL_DEBUG_IRQ__IRQ_REQUESTED    0x1
+#define BP_ICOLL_DEBUG_RSRVD1	10
+#define BM_ICOLL_DEBUG_RSRVD1	0x0000FC00
+#define BF_ICOLL_DEBUG_RSRVD1(v)  \
+		(((v) << 10) & BM_ICOLL_DEBUG_RSRVD1)
+#define BP_ICOLL_DEBUG_VECTOR_FSM	0
+#define BM_ICOLL_DEBUG_VECTOR_FSM	0x000003FF
+#define BF_ICOLL_DEBUG_VECTOR_FSM(v)  \
+		(((v) << 0) & BM_ICOLL_DEBUG_VECTOR_FSM)
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_IDLE         0x000
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE1  0x001
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE2  0x002
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_PENDING      0x004
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE3  0x008
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE4  0x010
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING1 0x020
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING2 0x040
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING3 0x080
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE5  0x100
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE6  0x200
+
+#define HW_ICOLL_DBGREAD0	(0x00001130)
+#define HW_ICOLL_DBGREAD0_SET	(0x00001134)
+#define HW_ICOLL_DBGREAD0_CLR	(0x00001138)
+#define HW_ICOLL_DBGREAD0_TOG	(0x0000113c)
+
+#define BP_ICOLL_DBGREAD0_VALUE	0
+#define BM_ICOLL_DBGREAD0_VALUE	0xFFFFFFFF
+#define BF_ICOLL_DBGREAD0_VALUE(v)	(v)
+
+#define HW_ICOLL_DBGREAD1	(0x00001140)
+#define HW_ICOLL_DBGREAD1_SET	(0x00001144)
+#define HW_ICOLL_DBGREAD1_CLR	(0x00001148)
+#define HW_ICOLL_DBGREAD1_TOG	(0x0000114c)
+
+#define BP_ICOLL_DBGREAD1_VALUE	0
+#define BM_ICOLL_DBGREAD1_VALUE	0xFFFFFFFF
+#define BF_ICOLL_DBGREAD1_VALUE(v)	(v)
+
+#define HW_ICOLL_DBGFLAG	(0x00001150)
+#define HW_ICOLL_DBGFLAG_SET	(0x00001154)
+#define HW_ICOLL_DBGFLAG_CLR	(0x00001158)
+#define HW_ICOLL_DBGFLAG_TOG	(0x0000115c)
+
+#define BP_ICOLL_DBGFLAG_RSRVD1	16
+#define BM_ICOLL_DBGFLAG_RSRVD1	0xFFFF0000
+#define BF_ICOLL_DBGFLAG_RSRVD1(v) \
+		(((v) << 16) & BM_ICOLL_DBGFLAG_RSRVD1)
+#define BP_ICOLL_DBGFLAG_FLAG	0
+#define BM_ICOLL_DBGFLAG_FLAG	0x0000FFFF
+#define BF_ICOLL_DBGFLAG_FLAG(v)  \
+		(((v) << 0) & BM_ICOLL_DBGFLAG_FLAG)
+
+/*
+ *  multi-register-define name HW_ICOLL_DBGREQUESTn
+ *              base 0x00001160
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_ICOLL_DBGREQUESTn(n)	(0x00001160 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_SET(n)	(0x00001164 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_CLR(n)	(0x00001168 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_TOG(n)	(0x0000116c + (n) * 0x10)
+#define BP_ICOLL_DBGREQUESTn_BITS	0
+#define BM_ICOLL_DBGREQUESTn_BITS	0xFFFFFFFF
+#define BF_ICOLL_DBGREQUESTn_BITS(v)	(v)
+
+#define HW_ICOLL_VERSION	(0x000011e0)
+
+#define BP_ICOLL_VERSION_MAJOR	24
+#define BM_ICOLL_VERSION_MAJOR	0xFF000000
+#define BF_ICOLL_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_ICOLL_VERSION_MAJOR)
+#define BP_ICOLL_VERSION_MINOR	16
+#define BM_ICOLL_VERSION_MINOR	0x00FF0000
+#define BF_ICOLL_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_ICOLL_VERSION_MINOR)
+#define BP_ICOLL_VERSION_STEP	0
+#define BM_ICOLL_VERSION_STEP	0x0000FFFF
+#define BF_ICOLL_VERSION_STEP(v)  \
+		(((v) << 0) & BM_ICOLL_VERSION_STEP)
+#endif /* __ARCH_ARM___ICOLL_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-lcdif.h b/arch/arm/mach-mx28/include/mach/regs-lcdif.h
new file mode 100644
index 0000000..6a0e008
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-lcdif.h
@@ -0,0 +1,680 @@
+/*
+ * Freescale LCDIF Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.32
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___LCDIF_H
+#define __ARCH_ARM___LCDIF_H
+
+
+#define HW_LCDIF_CTRL	(0x00000000)
+#define HW_LCDIF_CTRL_SET	(0x00000004)
+#define HW_LCDIF_CTRL_CLR	(0x00000008)
+#define HW_LCDIF_CTRL_TOG	(0x0000000c)
+
+#define BM_LCDIF_CTRL_SFTRST	0x80000000
+#define BM_LCDIF_CTRL_CLKGATE	0x40000000
+#define BM_LCDIF_CTRL_YCBCR422_INPUT	0x20000000
+#define BM_LCDIF_CTRL_READ_WRITEB	0x10000000
+#define BM_LCDIF_CTRL_WAIT_FOR_VSYNC_EDGE	0x08000000
+#define BM_LCDIF_CTRL_DATA_SHIFT_DIR	0x04000000
+#define BV_LCDIF_CTRL_DATA_SHIFT_DIR__TXDATA_SHIFT_LEFT  0x0
+#define BV_LCDIF_CTRL_DATA_SHIFT_DIR__TXDATA_SHIFT_RIGHT 0x1
+#define BP_LCDIF_CTRL_SHIFT_NUM_BITS	21
+#define BM_LCDIF_CTRL_SHIFT_NUM_BITS	0x03E00000
+#define BF_LCDIF_CTRL_SHIFT_NUM_BITS(v)  \
+		(((v) << 21) & BM_LCDIF_CTRL_SHIFT_NUM_BITS)
+#define BM_LCDIF_CTRL_DVI_MODE	0x00100000
+#define BM_LCDIF_CTRL_BYPASS_COUNT	0x00080000
+#define BM_LCDIF_CTRL_VSYNC_MODE	0x00040000
+#define BM_LCDIF_CTRL_DOTCLK_MODE	0x00020000
+#define BM_LCDIF_CTRL_DATA_SELECT	0x00010000
+#define BV_LCDIF_CTRL_DATA_SELECT__CMD_MODE  0x0
+#define BV_LCDIF_CTRL_DATA_SELECT__DATA_MODE 0x1
+#define BP_LCDIF_CTRL_INPUT_DATA_SWIZZLE	14
+#define BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE	0x0000C000
+#define BF_LCDIF_CTRL_INPUT_DATA_SWIZZLE(v)  \
+		(((v) << 14) & BM_LCDIF_CTRL_INPUT_DATA_SWIZZLE)
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__NO_SWAP         0x0
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__LITTLE_ENDIAN   0x0
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__BIG_ENDIAN_SWAP 0x1
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__SWAP_ALL_BYTES  0x1
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__HWD_SWAP        0x2
+#define BV_LCDIF_CTRL_INPUT_DATA_SWIZZLE__HWD_BYTE_SWAP   0x3
+#define BP_LCDIF_CTRL_CSC_DATA_SWIZZLE	12
+#define BM_LCDIF_CTRL_CSC_DATA_SWIZZLE	0x00003000
+#define BF_LCDIF_CTRL_CSC_DATA_SWIZZLE(v)  \
+		(((v) << 12) & BM_LCDIF_CTRL_CSC_DATA_SWIZZLE)
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__NO_SWAP         0x0
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__LITTLE_ENDIAN   0x0
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__BIG_ENDIAN_SWAP 0x1
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__SWAP_ALL_BYTES  0x1
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__HWD_SWAP        0x2
+#define BV_LCDIF_CTRL_CSC_DATA_SWIZZLE__HWD_BYTE_SWAP   0x3
+#define BP_LCDIF_CTRL_LCD_DATABUS_WIDTH	10
+#define BM_LCDIF_CTRL_LCD_DATABUS_WIDTH	0x00000C00
+#define BF_LCDIF_CTRL_LCD_DATABUS_WIDTH(v)  \
+		(((v) << 10) & BM_LCDIF_CTRL_LCD_DATABUS_WIDTH)
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__16_BIT 0x0
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__8_BIT  0x1
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__18_BIT 0x2
+#define BV_LCDIF_CTRL_LCD_DATABUS_WIDTH__24_BIT 0x3
+#define BP_LCDIF_CTRL_WORD_LENGTH	8
+#define BM_LCDIF_CTRL_WORD_LENGTH	0x00000300
+#define BF_LCDIF_CTRL_WORD_LENGTH(v)  \
+		(((v) << 8) & BM_LCDIF_CTRL_WORD_LENGTH)
+#define BV_LCDIF_CTRL_WORD_LENGTH__16_BIT 0x0
+#define BV_LCDIF_CTRL_WORD_LENGTH__8_BIT  0x1
+#define BV_LCDIF_CTRL_WORD_LENGTH__18_BIT 0x2
+#define BV_LCDIF_CTRL_WORD_LENGTH__24_BIT 0x3
+#define BM_LCDIF_CTRL_RGB_TO_YCBCR422_CSC	0x00000080
+#define BM_LCDIF_CTRL_ENABLE_PXP_HANDSHAKE	0x00000040
+#define BM_LCDIF_CTRL_LCDIF_MASTER	0x00000020
+#define BM_LCDIF_CTRL_RSRVD0	0x00000010
+#define BM_LCDIF_CTRL_DATA_FORMAT_16_BIT	0x00000008
+#define BM_LCDIF_CTRL_DATA_FORMAT_18_BIT	0x00000004
+#define BV_LCDIF_CTRL_DATA_FORMAT_18_BIT__LOWER_18_BITS_VALID 0x0
+#define BV_LCDIF_CTRL_DATA_FORMAT_18_BIT__UPPER_18_BITS_VALID 0x1
+#define BM_LCDIF_CTRL_DATA_FORMAT_24_BIT	0x00000002
+#define BV_LCDIF_CTRL_DATA_FORMAT_24_BIT__ALL_24_BITS_VALID          0x0
+#define BV_LCDIF_CTRL_DATA_FORMAT_24_BIT__DROP_UPPER_2_BITS_PER_BYTE 0x1
+#define BM_LCDIF_CTRL_RUN	0x00000001
+
+#define HW_LCDIF_CTRL1	(0x00000010)
+#define HW_LCDIF_CTRL1_SET	(0x00000014)
+#define HW_LCDIF_CTRL1_CLR	(0x00000018)
+#define HW_LCDIF_CTRL1_TOG	(0x0000001c)
+
+#define BP_LCDIF_CTRL1_RSRVD1	28
+#define BM_LCDIF_CTRL1_RSRVD1	0xF0000000
+#define BF_LCDIF_CTRL1_RSRVD1(v) \
+		(((v) << 28) & BM_LCDIF_CTRL1_RSRVD1)
+#define BM_LCDIF_CTRL1_COMBINE_MPU_WR_STRB	0x08000000
+#define BM_LCDIF_CTRL1_BM_ERROR_IRQ_EN	0x04000000
+#define BM_LCDIF_CTRL1_BM_ERROR_IRQ	0x02000000
+#define BV_LCDIF_CTRL1_BM_ERROR_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_BM_ERROR_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_RECOVER_ON_UNDERFLOW	0x01000000
+#define BM_LCDIF_CTRL1_INTERLACE_FIELDS	0x00800000
+#define BM_LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD	0x00400000
+#define BM_LCDIF_CTRL1_FIFO_CLEAR	0x00200000
+#define BM_LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS	0x00100000
+#define BP_LCDIF_CTRL1_BYTE_PACKING_FORMAT	16
+#define BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT	0x000F0000
+#define BF_LCDIF_CTRL1_BYTE_PACKING_FORMAT(v)  \
+		(((v) << 16) & BM_LCDIF_CTRL1_BYTE_PACKING_FORMAT)
+#define BM_LCDIF_CTRL1_OVERFLOW_IRQ_EN	0x00008000
+#define BM_LCDIF_CTRL1_UNDERFLOW_IRQ_EN	0x00004000
+#define BM_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN	0x00002000
+#define BM_LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN	0x00001000
+#define BM_LCDIF_CTRL1_OVERFLOW_IRQ	0x00000800
+#define BV_LCDIF_CTRL1_OVERFLOW_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_OVERFLOW_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_UNDERFLOW_IRQ	0x00000400
+#define BV_LCDIF_CTRL1_UNDERFLOW_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_UNDERFLOW_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ	0x00000200
+#define BV_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_CUR_FRAME_DONE_IRQ__REQUEST    0x1
+#define BM_LCDIF_CTRL1_VSYNC_EDGE_IRQ	0x00000100
+#define BV_LCDIF_CTRL1_VSYNC_EDGE_IRQ__NO_REQUEST 0x0
+#define BV_LCDIF_CTRL1_VSYNC_EDGE_IRQ__REQUEST    0x1
+#define BP_LCDIF_CTRL1_RSRVD0	3
+#define BM_LCDIF_CTRL1_RSRVD0	0x000000F8
+#define BF_LCDIF_CTRL1_RSRVD0(v)  \
+		(((v) << 3) & BM_LCDIF_CTRL1_RSRVD0)
+#define BM_LCDIF_CTRL1_BUSY_ENABLE	0x00000004
+#define BV_LCDIF_CTRL1_BUSY_ENABLE__BUSY_DISABLED 0x0
+#define BV_LCDIF_CTRL1_BUSY_ENABLE__BUSY_ENABLED  0x1
+#define BM_LCDIF_CTRL1_MODE86	0x00000002
+#define BV_LCDIF_CTRL1_MODE86__8080_MODE 0x0
+#define BV_LCDIF_CTRL1_MODE86__6800_MODE 0x1
+#define BM_LCDIF_CTRL1_RESET	0x00000001
+#define BV_LCDIF_CTRL1_RESET__LCDRESET_LOW  0x0
+#define BV_LCDIF_CTRL1_RESET__LCDRESET_HIGH 0x1
+
+#define HW_LCDIF_CTRL2	(0x00000020)
+#define HW_LCDIF_CTRL2_SET	(0x00000024)
+#define HW_LCDIF_CTRL2_CLR	(0x00000028)
+#define HW_LCDIF_CTRL2_TOG	(0x0000002c)
+
+#define BP_LCDIF_CTRL2_RSRVD5	24
+#define BM_LCDIF_CTRL2_RSRVD5	0xFF000000
+#define BF_LCDIF_CTRL2_RSRVD5(v) \
+		(((v) << 24) & BM_LCDIF_CTRL2_RSRVD5)
+#define BP_LCDIF_CTRL2_OUTSTANDING_REQS	21
+#define BM_LCDIF_CTRL2_OUTSTANDING_REQS	0x00E00000
+#define BF_LCDIF_CTRL2_OUTSTANDING_REQS(v)  \
+		(((v) << 21) & BM_LCDIF_CTRL2_OUTSTANDING_REQS)
+#define BV_LCDIF_CTRL2_OUTSTANDING_REQS__REQ_1  0x0
+#define BV_LCDIF_CTRL2_OUTSTANDING_REQS__REQ_2  0x1
+#define BV_LCDIF_CTRL2_OUTSTANDING_REQS__REQ_4  0x2
+#define BV_LCDIF_CTRL2_OUTSTANDING_REQS__REQ_8  0x3
+#define BV_LCDIF_CTRL2_OUTSTANDING_REQS__REQ_16 0x4
+#define BM_LCDIF_CTRL2_BURST_LEN_8	0x00100000
+#define BM_LCDIF_CTRL2_RSRVD4	0x00080000
+#define BP_LCDIF_CTRL2_ODD_LINE_PATTERN	16
+#define BM_LCDIF_CTRL2_ODD_LINE_PATTERN	0x00070000
+#define BF_LCDIF_CTRL2_ODD_LINE_PATTERN(v)  \
+		(((v) << 16) & BM_LCDIF_CTRL2_ODD_LINE_PATTERN)
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__RGB 0x0
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__RBG 0x1
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__GBR 0x2
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__GRB 0x3
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__BRG 0x4
+#define BV_LCDIF_CTRL2_ODD_LINE_PATTERN__BGR 0x5
+#define BM_LCDIF_CTRL2_RSRVD3	0x00008000
+#define BP_LCDIF_CTRL2_EVEN_LINE_PATTERN	12
+#define BM_LCDIF_CTRL2_EVEN_LINE_PATTERN	0x00007000
+#define BF_LCDIF_CTRL2_EVEN_LINE_PATTERN(v)  \
+		(((v) << 12) & BM_LCDIF_CTRL2_EVEN_LINE_PATTERN)
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__RGB 0x0
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__RBG 0x1
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__GBR 0x2
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__GRB 0x3
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__BRG 0x4
+#define BV_LCDIF_CTRL2_EVEN_LINE_PATTERN__BGR 0x5
+#define BM_LCDIF_CTRL2_RSRVD2	0x00000800
+#define BM_LCDIF_CTRL2_READ_PACK_DIR	0x00000400
+#define BM_LCDIF_CTRL2_READ_MODE_OUTPUT_IN_RGB_FORMAT	0x00000200
+#define BM_LCDIF_CTRL2_READ_MODE_6_BIT_INPUT	0x00000100
+#define BM_LCDIF_CTRL2_RSRVD1	0x00000080
+#define BP_LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS	4
+#define BM_LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS	0x00000070
+#define BF_LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS(v)  \
+		(((v) << 4) & BM_LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS)
+#define BP_LCDIF_CTRL2_INITIAL_DUMMY_READ	1
+#define BM_LCDIF_CTRL2_INITIAL_DUMMY_READ	0x0000000E
+#define BF_LCDIF_CTRL2_INITIAL_DUMMY_READ(v)  \
+		(((v) << 1) & BM_LCDIF_CTRL2_INITIAL_DUMMY_READ)
+#define BM_LCDIF_CTRL2_RSRVD0	0x00000001
+
+#define HW_LCDIF_TRANSFER_COUNT	(0x00000030)
+
+#define BP_LCDIF_TRANSFER_COUNT_V_COUNT	16
+#define BM_LCDIF_TRANSFER_COUNT_V_COUNT	0xFFFF0000
+#define BF_LCDIF_TRANSFER_COUNT_V_COUNT(v) \
+		(((v) << 16) & BM_LCDIF_TRANSFER_COUNT_V_COUNT)
+#define BP_LCDIF_TRANSFER_COUNT_H_COUNT	0
+#define BM_LCDIF_TRANSFER_COUNT_H_COUNT	0x0000FFFF
+#define BF_LCDIF_TRANSFER_COUNT_H_COUNT(v)  \
+		(((v) << 0) & BM_LCDIF_TRANSFER_COUNT_H_COUNT)
+
+#define HW_LCDIF_CUR_BUF	(0x00000040)
+
+#define BP_LCDIF_CUR_BUF_ADDR	0
+#define BM_LCDIF_CUR_BUF_ADDR	0xFFFFFFFF
+#define BF_LCDIF_CUR_BUF_ADDR(v)	(v)
+
+#define HW_LCDIF_NEXT_BUF	(0x00000050)
+
+#define BP_LCDIF_NEXT_BUF_ADDR	0
+#define BM_LCDIF_NEXT_BUF_ADDR	0xFFFFFFFF
+#define BF_LCDIF_NEXT_BUF_ADDR(v)	(v)
+
+#define HW_LCDIF_TIMING	(0x00000060)
+
+#define BP_LCDIF_TIMING_CMD_HOLD	24
+#define BM_LCDIF_TIMING_CMD_HOLD	0xFF000000
+#define BF_LCDIF_TIMING_CMD_HOLD(v) \
+		(((v) << 24) & BM_LCDIF_TIMING_CMD_HOLD)
+#define BP_LCDIF_TIMING_CMD_SETUP	16
+#define BM_LCDIF_TIMING_CMD_SETUP	0x00FF0000
+#define BF_LCDIF_TIMING_CMD_SETUP(v)  \
+		(((v) << 16) & BM_LCDIF_TIMING_CMD_SETUP)
+#define BP_LCDIF_TIMING_DATA_HOLD	8
+#define BM_LCDIF_TIMING_DATA_HOLD	0x0000FF00
+#define BF_LCDIF_TIMING_DATA_HOLD(v)  \
+		(((v) << 8) & BM_LCDIF_TIMING_DATA_HOLD)
+#define BP_LCDIF_TIMING_DATA_SETUP	0
+#define BM_LCDIF_TIMING_DATA_SETUP	0x000000FF
+#define BF_LCDIF_TIMING_DATA_SETUP(v)  \
+		(((v) << 0) & BM_LCDIF_TIMING_DATA_SETUP)
+
+#define HW_LCDIF_VDCTRL0	(0x00000070)
+#define HW_LCDIF_VDCTRL0_SET	(0x00000074)
+#define HW_LCDIF_VDCTRL0_CLR	(0x00000078)
+#define HW_LCDIF_VDCTRL0_TOG	(0x0000007c)
+
+#define BP_LCDIF_VDCTRL0_RSRVD2	30
+#define BM_LCDIF_VDCTRL0_RSRVD2	0xC0000000
+#define BF_LCDIF_VDCTRL0_RSRVD2(v) \
+		(((v) << 30) & BM_LCDIF_VDCTRL0_RSRVD2)
+#define BM_LCDIF_VDCTRL0_VSYNC_OEB	0x20000000
+#define BV_LCDIF_VDCTRL0_VSYNC_OEB__VSYNC_OUTPUT 0x0
+#define BV_LCDIF_VDCTRL0_VSYNC_OEB__VSYNC_INPUT  0x1
+#define BM_LCDIF_VDCTRL0_ENABLE_PRESENT	0x10000000
+#define BM_LCDIF_VDCTRL0_VSYNC_POL	0x08000000
+#define BM_LCDIF_VDCTRL0_HSYNC_POL	0x04000000
+#define BM_LCDIF_VDCTRL0_DOTCLK_POL	0x02000000
+#define BM_LCDIF_VDCTRL0_ENABLE_POL	0x01000000
+#define BP_LCDIF_VDCTRL0_RSRVD1	22
+#define BM_LCDIF_VDCTRL0_RSRVD1	0x00C00000
+#define BF_LCDIF_VDCTRL0_RSRVD1(v)  \
+		(((v) << 22) & BM_LCDIF_VDCTRL0_RSRVD1)
+#define BM_LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT	0x00200000
+#define BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT	0x00100000
+#define BM_LCDIF_VDCTRL0_HALF_LINE	0x00080000
+#define BM_LCDIF_VDCTRL0_HALF_LINE_MODE	0x00040000
+#define BP_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH	0
+#define BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH	0x0003FFFF
+#define BF_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH)
+
+#define HW_LCDIF_VDCTRL1	(0x00000080)
+
+#define BP_LCDIF_VDCTRL1_VSYNC_PERIOD	0
+#define BM_LCDIF_VDCTRL1_VSYNC_PERIOD	0xFFFFFFFF
+#define BF_LCDIF_VDCTRL1_VSYNC_PERIOD(v)	(v)
+
+#define HW_LCDIF_VDCTRL2	(0x00000090)
+
+#define BP_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH	18
+#define BM_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH	0xFFFC0000
+#define BF_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH(v) \
+		(((v) << 18) & BM_LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH)
+#define BP_LCDIF_VDCTRL2_HSYNC_PERIOD	0
+#define BM_LCDIF_VDCTRL2_HSYNC_PERIOD	0x0003FFFF
+#define BF_LCDIF_VDCTRL2_HSYNC_PERIOD(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL2_HSYNC_PERIOD)
+
+#define HW_LCDIF_VDCTRL3	(0x000000a0)
+
+#define BP_LCDIF_VDCTRL3_RSRVD0	30
+#define BM_LCDIF_VDCTRL3_RSRVD0	0xC0000000
+#define BF_LCDIF_VDCTRL3_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_VDCTRL3_RSRVD0)
+#define BM_LCDIF_VDCTRL3_MUX_SYNC_SIGNALS	0x20000000
+#define BM_LCDIF_VDCTRL3_VSYNC_ONLY	0x10000000
+#define BP_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT	16
+#define BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT	0x0FFF0000
+#define BF_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT(v)  \
+		(((v) << 16) & BM_LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT)
+#define BP_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT	0
+#define BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT	0x0000FFFF
+#define BF_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL3_VERTICAL_WAIT_CNT)
+
+#define HW_LCDIF_VDCTRL4	(0x000000b0)
+
+#define BP_LCDIF_VDCTRL4_DOTCLK_DLY_SEL	29
+#define BM_LCDIF_VDCTRL4_DOTCLK_DLY_SEL	0xE0000000
+#define BF_LCDIF_VDCTRL4_DOTCLK_DLY_SEL(v) \
+		(((v) << 29) & BM_LCDIF_VDCTRL4_DOTCLK_DLY_SEL)
+#define BP_LCDIF_VDCTRL4_RSRVD0	19
+#define BM_LCDIF_VDCTRL4_RSRVD0	0x1FF80000
+#define BF_LCDIF_VDCTRL4_RSRVD0(v)  \
+		(((v) << 19) & BM_LCDIF_VDCTRL4_RSRVD0)
+#define BM_LCDIF_VDCTRL4_SYNC_SIGNALS_ON	0x00040000
+#define BP_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT	0
+#define BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT	0x0003FFFF
+#define BF_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT)
+
+#define HW_LCDIF_DVICTRL0	(0x000000c0)
+
+#define BP_LCDIF_DVICTRL0_RSRVD1	28
+#define BM_LCDIF_DVICTRL0_RSRVD1	0xF0000000
+#define BF_LCDIF_DVICTRL0_RSRVD1(v) \
+		(((v) << 28) & BM_LCDIF_DVICTRL0_RSRVD1)
+#define BP_LCDIF_DVICTRL0_H_ACTIVE_CNT	16
+#define BM_LCDIF_DVICTRL0_H_ACTIVE_CNT	0x0FFF0000
+#define BF_LCDIF_DVICTRL0_H_ACTIVE_CNT(v)  \
+		(((v) << 16) & BM_LCDIF_DVICTRL0_H_ACTIVE_CNT)
+#define BP_LCDIF_DVICTRL0_RSRVD0	12
+#define BM_LCDIF_DVICTRL0_RSRVD0	0x0000F000
+#define BF_LCDIF_DVICTRL0_RSRVD0(v)  \
+		(((v) << 12) & BM_LCDIF_DVICTRL0_RSRVD0)
+#define BP_LCDIF_DVICTRL0_H_BLANKING_CNT	0
+#define BM_LCDIF_DVICTRL0_H_BLANKING_CNT	0x00000FFF
+#define BF_LCDIF_DVICTRL0_H_BLANKING_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL0_H_BLANKING_CNT)
+
+#define HW_LCDIF_DVICTRL1	(0x000000d0)
+
+#define BP_LCDIF_DVICTRL1_RSRVD0	30
+#define BM_LCDIF_DVICTRL1_RSRVD0	0xC0000000
+#define BF_LCDIF_DVICTRL1_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_DVICTRL1_RSRVD0)
+#define BP_LCDIF_DVICTRL1_F1_START_LINE	20
+#define BM_LCDIF_DVICTRL1_F1_START_LINE	0x3FF00000
+#define BF_LCDIF_DVICTRL1_F1_START_LINE(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL1_F1_START_LINE)
+#define BP_LCDIF_DVICTRL1_F1_END_LINE	10
+#define BM_LCDIF_DVICTRL1_F1_END_LINE	0x000FFC00
+#define BF_LCDIF_DVICTRL1_F1_END_LINE(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL1_F1_END_LINE)
+#define BP_LCDIF_DVICTRL1_F2_START_LINE	0
+#define BM_LCDIF_DVICTRL1_F2_START_LINE	0x000003FF
+#define BF_LCDIF_DVICTRL1_F2_START_LINE(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL1_F2_START_LINE)
+
+#define HW_LCDIF_DVICTRL2	(0x000000e0)
+
+#define BP_LCDIF_DVICTRL2_RSRVD0	30
+#define BM_LCDIF_DVICTRL2_RSRVD0	0xC0000000
+#define BF_LCDIF_DVICTRL2_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_DVICTRL2_RSRVD0)
+#define BP_LCDIF_DVICTRL2_F2_END_LINE	20
+#define BM_LCDIF_DVICTRL2_F2_END_LINE	0x3FF00000
+#define BF_LCDIF_DVICTRL2_F2_END_LINE(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL2_F2_END_LINE)
+#define BP_LCDIF_DVICTRL2_V1_BLANK_START_LINE	10
+#define BM_LCDIF_DVICTRL2_V1_BLANK_START_LINE	0x000FFC00
+#define BF_LCDIF_DVICTRL2_V1_BLANK_START_LINE(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL2_V1_BLANK_START_LINE)
+#define BP_LCDIF_DVICTRL2_V1_BLANK_END_LINE	0
+#define BM_LCDIF_DVICTRL2_V1_BLANK_END_LINE	0x000003FF
+#define BF_LCDIF_DVICTRL2_V1_BLANK_END_LINE(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL2_V1_BLANK_END_LINE)
+
+#define HW_LCDIF_DVICTRL3	(0x000000f0)
+
+#define BP_LCDIF_DVICTRL3_RSRVD0	30
+#define BM_LCDIF_DVICTRL3_RSRVD0	0xC0000000
+#define BF_LCDIF_DVICTRL3_RSRVD0(v) \
+		(((v) << 30) & BM_LCDIF_DVICTRL3_RSRVD0)
+#define BP_LCDIF_DVICTRL3_V2_BLANK_START_LINE	20
+#define BM_LCDIF_DVICTRL3_V2_BLANK_START_LINE	0x3FF00000
+#define BF_LCDIF_DVICTRL3_V2_BLANK_START_LINE(v)  \
+		(((v) << 20) & BM_LCDIF_DVICTRL3_V2_BLANK_START_LINE)
+#define BP_LCDIF_DVICTRL3_V2_BLANK_END_LINE	10
+#define BM_LCDIF_DVICTRL3_V2_BLANK_END_LINE	0x000FFC00
+#define BF_LCDIF_DVICTRL3_V2_BLANK_END_LINE(v)  \
+		(((v) << 10) & BM_LCDIF_DVICTRL3_V2_BLANK_END_LINE)
+#define BP_LCDIF_DVICTRL3_V_LINES_CNT	0
+#define BM_LCDIF_DVICTRL3_V_LINES_CNT	0x000003FF
+#define BF_LCDIF_DVICTRL3_V_LINES_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL3_V_LINES_CNT)
+
+#define HW_LCDIF_DVICTRL4	(0x00000100)
+
+#define BP_LCDIF_DVICTRL4_Y_FILL_VALUE	24
+#define BM_LCDIF_DVICTRL4_Y_FILL_VALUE	0xFF000000
+#define BF_LCDIF_DVICTRL4_Y_FILL_VALUE(v) \
+		(((v) << 24) & BM_LCDIF_DVICTRL4_Y_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_CB_FILL_VALUE	16
+#define BM_LCDIF_DVICTRL4_CB_FILL_VALUE	0x00FF0000
+#define BF_LCDIF_DVICTRL4_CB_FILL_VALUE(v)  \
+		(((v) << 16) & BM_LCDIF_DVICTRL4_CB_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_CR_FILL_VALUE	8
+#define BM_LCDIF_DVICTRL4_CR_FILL_VALUE	0x0000FF00
+#define BF_LCDIF_DVICTRL4_CR_FILL_VALUE(v)  \
+		(((v) << 8) & BM_LCDIF_DVICTRL4_CR_FILL_VALUE)
+#define BP_LCDIF_DVICTRL4_H_FILL_CNT	0
+#define BM_LCDIF_DVICTRL4_H_FILL_CNT	0x000000FF
+#define BF_LCDIF_DVICTRL4_H_FILL_CNT(v)  \
+		(((v) << 0) & BM_LCDIF_DVICTRL4_H_FILL_CNT)
+
+#define HW_LCDIF_CSC_COEFF0	(0x00000110)
+
+#define BP_LCDIF_CSC_COEFF0_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF0_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF0_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF0_RSRVD1)
+#define BP_LCDIF_CSC_COEFF0_C0	16
+#define BM_LCDIF_CSC_COEFF0_C0	0x03FF0000
+#define BF_LCDIF_CSC_COEFF0_C0(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF0_C0)
+#define BP_LCDIF_CSC_COEFF0_RSRVD0	2
+#define BM_LCDIF_CSC_COEFF0_RSRVD0	0x0000FFFC
+#define BF_LCDIF_CSC_COEFF0_RSRVD0(v)  \
+		(((v) << 2) & BM_LCDIF_CSC_COEFF0_RSRVD0)
+#define BP_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER	0
+#define BM_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER	0x00000003
+#define BF_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER)
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__SAMPLE_AND_HOLD 0x0
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__RSRVD           0x1
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__INTERSTITIAL    0x2
+#define BV_LCDIF_CSC_COEFF0_CSC_SUBSAMPLE_FILTER__COSITED         0x3
+
+#define HW_LCDIF_CSC_COEFF1	(0x00000120)
+
+#define BP_LCDIF_CSC_COEFF1_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF1_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF1_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF1_RSRVD1)
+#define BP_LCDIF_CSC_COEFF1_C2	16
+#define BM_LCDIF_CSC_COEFF1_C2	0x03FF0000
+#define BF_LCDIF_CSC_COEFF1_C2(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF1_C2)
+#define BP_LCDIF_CSC_COEFF1_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF1_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF1_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF1_RSRVD0)
+#define BP_LCDIF_CSC_COEFF1_C1	0
+#define BM_LCDIF_CSC_COEFF1_C1	0x000003FF
+#define BF_LCDIF_CSC_COEFF1_C1(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF1_C1)
+
+#define HW_LCDIF_CSC_COEFF2	(0x00000130)
+
+#define BP_LCDIF_CSC_COEFF2_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF2_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF2_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF2_RSRVD1)
+#define BP_LCDIF_CSC_COEFF2_C4	16
+#define BM_LCDIF_CSC_COEFF2_C4	0x03FF0000
+#define BF_LCDIF_CSC_COEFF2_C4(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF2_C4)
+#define BP_LCDIF_CSC_COEFF2_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF2_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF2_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF2_RSRVD0)
+#define BP_LCDIF_CSC_COEFF2_C3	0
+#define BM_LCDIF_CSC_COEFF2_C3	0x000003FF
+#define BF_LCDIF_CSC_COEFF2_C3(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF2_C3)
+
+#define HW_LCDIF_CSC_COEFF3	(0x00000140)
+
+#define BP_LCDIF_CSC_COEFF3_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF3_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF3_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF3_RSRVD1)
+#define BP_LCDIF_CSC_COEFF3_C6	16
+#define BM_LCDIF_CSC_COEFF3_C6	0x03FF0000
+#define BF_LCDIF_CSC_COEFF3_C6(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF3_C6)
+#define BP_LCDIF_CSC_COEFF3_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF3_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF3_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF3_RSRVD0)
+#define BP_LCDIF_CSC_COEFF3_C5	0
+#define BM_LCDIF_CSC_COEFF3_C5	0x000003FF
+#define BF_LCDIF_CSC_COEFF3_C5(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF3_C5)
+
+#define HW_LCDIF_CSC_COEFF4	(0x00000150)
+
+#define BP_LCDIF_CSC_COEFF4_RSRVD1	26
+#define BM_LCDIF_CSC_COEFF4_RSRVD1	0xFC000000
+#define BF_LCDIF_CSC_COEFF4_RSRVD1(v) \
+		(((v) << 26) & BM_LCDIF_CSC_COEFF4_RSRVD1)
+#define BP_LCDIF_CSC_COEFF4_C8	16
+#define BM_LCDIF_CSC_COEFF4_C8	0x03FF0000
+#define BF_LCDIF_CSC_COEFF4_C8(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_COEFF4_C8)
+#define BP_LCDIF_CSC_COEFF4_RSRVD0	10
+#define BM_LCDIF_CSC_COEFF4_RSRVD0	0x0000FC00
+#define BF_LCDIF_CSC_COEFF4_RSRVD0(v)  \
+		(((v) << 10) & BM_LCDIF_CSC_COEFF4_RSRVD0)
+#define BP_LCDIF_CSC_COEFF4_C7	0
+#define BM_LCDIF_CSC_COEFF4_C7	0x000003FF
+#define BF_LCDIF_CSC_COEFF4_C7(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_COEFF4_C7)
+
+#define HW_LCDIF_CSC_OFFSET	(0x00000160)
+
+#define BP_LCDIF_CSC_OFFSET_RSRVD1	25
+#define BM_LCDIF_CSC_OFFSET_RSRVD1	0xFE000000
+#define BF_LCDIF_CSC_OFFSET_RSRVD1(v) \
+		(((v) << 25) & BM_LCDIF_CSC_OFFSET_RSRVD1)
+#define BP_LCDIF_CSC_OFFSET_CBCR_OFFSET	16
+#define BM_LCDIF_CSC_OFFSET_CBCR_OFFSET	0x01FF0000
+#define BF_LCDIF_CSC_OFFSET_CBCR_OFFSET(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_OFFSET_CBCR_OFFSET)
+#define BP_LCDIF_CSC_OFFSET_RSRVD0	9
+#define BM_LCDIF_CSC_OFFSET_RSRVD0	0x0000FE00
+#define BF_LCDIF_CSC_OFFSET_RSRVD0(v)  \
+		(((v) << 9) & BM_LCDIF_CSC_OFFSET_RSRVD0)
+#define BP_LCDIF_CSC_OFFSET_Y_OFFSET	0
+#define BM_LCDIF_CSC_OFFSET_Y_OFFSET	0x000001FF
+#define BF_LCDIF_CSC_OFFSET_Y_OFFSET(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_OFFSET_Y_OFFSET)
+
+#define HW_LCDIF_CSC_LIMIT	(0x00000170)
+
+#define BP_LCDIF_CSC_LIMIT_CBCR_MIN	24
+#define BM_LCDIF_CSC_LIMIT_CBCR_MIN	0xFF000000
+#define BF_LCDIF_CSC_LIMIT_CBCR_MIN(v) \
+		(((v) << 24) & BM_LCDIF_CSC_LIMIT_CBCR_MIN)
+#define BP_LCDIF_CSC_LIMIT_CBCR_MAX	16
+#define BM_LCDIF_CSC_LIMIT_CBCR_MAX	0x00FF0000
+#define BF_LCDIF_CSC_LIMIT_CBCR_MAX(v)  \
+		(((v) << 16) & BM_LCDIF_CSC_LIMIT_CBCR_MAX)
+#define BP_LCDIF_CSC_LIMIT_Y_MIN	8
+#define BM_LCDIF_CSC_LIMIT_Y_MIN	0x0000FF00
+#define BF_LCDIF_CSC_LIMIT_Y_MIN(v)  \
+		(((v) << 8) & BM_LCDIF_CSC_LIMIT_Y_MIN)
+#define BP_LCDIF_CSC_LIMIT_Y_MAX	0
+#define BM_LCDIF_CSC_LIMIT_Y_MAX	0x000000FF
+#define BF_LCDIF_CSC_LIMIT_Y_MAX(v)  \
+		(((v) << 0) & BM_LCDIF_CSC_LIMIT_Y_MAX)
+
+#define HW_LCDIF_DATA	(0x00000180)
+
+#define BP_LCDIF_DATA_DATA_THREE	24
+#define BM_LCDIF_DATA_DATA_THREE	0xFF000000
+#define BF_LCDIF_DATA_DATA_THREE(v) \
+		(((v) << 24) & BM_LCDIF_DATA_DATA_THREE)
+#define BP_LCDIF_DATA_DATA_TWO	16
+#define BM_LCDIF_DATA_DATA_TWO	0x00FF0000
+#define BF_LCDIF_DATA_DATA_TWO(v)  \
+		(((v) << 16) & BM_LCDIF_DATA_DATA_TWO)
+#define BP_LCDIF_DATA_DATA_ONE	8
+#define BM_LCDIF_DATA_DATA_ONE	0x0000FF00
+#define BF_LCDIF_DATA_DATA_ONE(v)  \
+		(((v) << 8) & BM_LCDIF_DATA_DATA_ONE)
+#define BP_LCDIF_DATA_DATA_ZERO	0
+#define BM_LCDIF_DATA_DATA_ZERO	0x000000FF
+#define BF_LCDIF_DATA_DATA_ZERO(v)  \
+		(((v) << 0) & BM_LCDIF_DATA_DATA_ZERO)
+
+#define HW_LCDIF_BM_ERROR_STAT	(0x00000190)
+
+#define BP_LCDIF_BM_ERROR_STAT_ADDR	0
+#define BM_LCDIF_BM_ERROR_STAT_ADDR	0xFFFFFFFF
+#define BF_LCDIF_BM_ERROR_STAT_ADDR(v)	(v)
+
+#define HW_LCDIF_CRC_STAT	(0x000001a0)
+
+#define BP_LCDIF_CRC_STAT_CRC_VALUE	0
+#define BM_LCDIF_CRC_STAT_CRC_VALUE	0xFFFFFFFF
+#define BF_LCDIF_CRC_STAT_CRC_VALUE(v)	(v)
+
+#define HW_LCDIF_STAT	(0x000001b0)
+
+#define BM_LCDIF_STAT_PRESENT	0x80000000
+#define BM_LCDIF_STAT_DMA_REQ	0x40000000
+#define BM_LCDIF_STAT_LFIFO_FULL	0x20000000
+#define BM_LCDIF_STAT_LFIFO_EMPTY	0x10000000
+#define BM_LCDIF_STAT_TXFIFO_FULL	0x08000000
+#define BM_LCDIF_STAT_TXFIFO_EMPTY	0x04000000
+#define BM_LCDIF_STAT_BUSY	0x02000000
+#define BM_LCDIF_STAT_DVI_CURRENT_FIELD	0x01000000
+#define BP_LCDIF_STAT_RSRVD0	9
+#define BM_LCDIF_STAT_RSRVD0	0x00FFFE00
+#define BF_LCDIF_STAT_RSRVD0(v)  \
+		(((v) << 9) & BM_LCDIF_STAT_RSRVD0)
+#define BP_LCDIF_STAT_LFIFO_COUNT	0
+#define BM_LCDIF_STAT_LFIFO_COUNT	0x000001FF
+#define BF_LCDIF_STAT_LFIFO_COUNT(v)  \
+		(((v) << 0) & BM_LCDIF_STAT_LFIFO_COUNT)
+
+#define HW_LCDIF_VERSION	(0x000001c0)
+
+#define BP_LCDIF_VERSION_MAJOR	24
+#define BM_LCDIF_VERSION_MAJOR	0xFF000000
+#define BF_LCDIF_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_LCDIF_VERSION_MAJOR)
+#define BP_LCDIF_VERSION_MINOR	16
+#define BM_LCDIF_VERSION_MINOR	0x00FF0000
+#define BF_LCDIF_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_LCDIF_VERSION_MINOR)
+#define BP_LCDIF_VERSION_STEP	0
+#define BM_LCDIF_VERSION_STEP	0x0000FFFF
+#define BF_LCDIF_VERSION_STEP(v)  \
+		(((v) << 0) & BM_LCDIF_VERSION_STEP)
+
+#define HW_LCDIF_DEBUG0	(0x000001d0)
+
+#define BM_LCDIF_DEBUG0_STREAMING_END_DETECTED	0x80000000
+#define BM_LCDIF_DEBUG0_WAIT_FOR_VSYNC_EDGE_OUT	0x40000000
+#define BM_LCDIF_DEBUG0_SYNC_SIGNALS_ON_REG	0x20000000
+#define BM_LCDIF_DEBUG0_DMACMDKICK	0x10000000
+#define BM_LCDIF_DEBUG0_ENABLE	0x08000000
+#define BM_LCDIF_DEBUG0_HSYNC	0x04000000
+#define BM_LCDIF_DEBUG0_VSYNC	0x02000000
+#define BM_LCDIF_DEBUG0_CUR_FRAME_TX	0x01000000
+#define BM_LCDIF_DEBUG0_EMPTY_WORD	0x00800000
+#define BP_LCDIF_DEBUG0_CUR_STATE	16
+#define BM_LCDIF_DEBUG0_CUR_STATE	0x007F0000
+#define BF_LCDIF_DEBUG0_CUR_STATE(v)  \
+		(((v) << 16) & BM_LCDIF_DEBUG0_CUR_STATE)
+#define BM_LCDIF_DEBUG0_PXP_LCDIF_B0_READY	0x00008000
+#define BM_LCDIF_DEBUG0_LCDIF_PXP_B0_DONE	0x00004000
+#define BM_LCDIF_DEBUG0_PXP_LCDIF_B1_READY	0x00002000
+#define BM_LCDIF_DEBUG0_LCDIF_PXP_B1_DONE	0x00001000
+#define BP_LCDIF_DEBUG0_CUR_REQ_STATE	10
+#define BM_LCDIF_DEBUG0_CUR_REQ_STATE	0x00000C00
+#define BF_LCDIF_DEBUG0_CUR_REQ_STATE(v)  \
+		(((v) << 10) & BM_LCDIF_DEBUG0_CUR_REQ_STATE)
+#define BM_LCDIF_DEBUG0_MST_AVALID	0x00000200
+#define BP_LCDIF_DEBUG0_MST_OUTSTANDING_REQS	4
+#define BM_LCDIF_DEBUG0_MST_OUTSTANDING_REQS	0x000001F0
+#define BF_LCDIF_DEBUG0_MST_OUTSTANDING_REQS(v)  \
+		(((v) << 4) & BM_LCDIF_DEBUG0_MST_OUTSTANDING_REQS)
+#define BP_LCDIF_DEBUG0_MST_WORDS	0
+#define BM_LCDIF_DEBUG0_MST_WORDS	0x0000000F
+#define BF_LCDIF_DEBUG0_MST_WORDS(v)  \
+		(((v) << 0) & BM_LCDIF_DEBUG0_MST_WORDS)
+
+#define HW_LCDIF_DEBUG1	(0x000001e0)
+
+#define BP_LCDIF_DEBUG1_H_DATA_COUNT	16
+#define BM_LCDIF_DEBUG1_H_DATA_COUNT	0xFFFF0000
+#define BF_LCDIF_DEBUG1_H_DATA_COUNT(v) \
+		(((v) << 16) & BM_LCDIF_DEBUG1_H_DATA_COUNT)
+#define BP_LCDIF_DEBUG1_V_DATA_COUNT	0
+#define BM_LCDIF_DEBUG1_V_DATA_COUNT	0x0000FFFF
+#define BF_LCDIF_DEBUG1_V_DATA_COUNT(v)  \
+		(((v) << 0) & BM_LCDIF_DEBUG1_V_DATA_COUNT)
+
+#define HW_LCDIF_DEBUG2	(0x000001f0)
+
+#define BP_LCDIF_DEBUG2_MST_ADDRESS	0
+#define BM_LCDIF_DEBUG2_MST_ADDRESS	0xFFFFFFFF
+#define BF_LCDIF_DEBUG2_MST_ADDRESS(v)	(v)
+#endif /* __ARCH_ARM___LCDIF_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-lradc.h b/arch/arm/mach-mx28/include/mach/regs-lradc.h
new file mode 100644
index 0000000..d7906b9
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-lradc.h
@@ -0,0 +1,772 @@
+/*
+ * Freescale LRADC Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.50
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___LRADC_H
+#define __ARCH_ARM___LRADC_H
+
+
+#define HW_LRADC_CTRL0	(0x00000000)
+#define HW_LRADC_CTRL0_SET	(0x00000004)
+#define HW_LRADC_CTRL0_CLR	(0x00000008)
+#define HW_LRADC_CTRL0_TOG	(0x0000000c)
+
+#define BM_LRADC_CTRL0_SFTRST	0x80000000
+#define BM_LRADC_CTRL0_CLKGATE	0x40000000
+#define BP_LRADC_CTRL0_RSRVD2	27
+#define BM_LRADC_CTRL0_RSRVD2	0x38000000
+#define BF_LRADC_CTRL0_RSRVD2(v)  \
+		(((v) << 27) & BM_LRADC_CTRL0_RSRVD2)
+#define BM_LRADC_CTRL0_ONCHIP_GROUNDREF	0x04000000
+#define BV_LRADC_CTRL0_ONCHIP_GROUNDREF__OFF 0x0
+#define BV_LRADC_CTRL0_ONCHIP_GROUNDREF__ON  0x1
+#define BM_LRADC_CTRL0_BUTTON1_DETECT_ENABLE	0x02000000
+#define BV_LRADC_CTRL0_BUTTON1_DETECT_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_BUTTON1_DETECT_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_BUTTON0_DETECT_ENABLE	0x01000000
+#define BV_LRADC_CTRL0_BUTTON0_DETECT_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_BUTTON0_DETECT_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_TOUCH_DETECT_ENABLE	0x00800000
+#define BV_LRADC_CTRL0_TOUCH_DETECT_ENABLE__OFF 0x0
+#define BV_LRADC_CTRL0_TOUCH_DETECT_ENABLE__ON  0x1
+#define BM_LRADC_CTRL0_TOUCH_SCREEN_TYPE	0x00400000
+#define BM_LRADC_CTRL0_YNLRSW	0x00200000
+#define BP_LRADC_CTRL0_YPLLSW	19
+#define BM_LRADC_CTRL0_YPLLSW	0x00180000
+#define BF_LRADC_CTRL0_YPLLSW(v)  \
+		(((v) << 19) & BM_LRADC_CTRL0_YPLLSW)
+#define BP_LRADC_CTRL0_XNURSW	17
+#define BM_LRADC_CTRL0_XNURSW	0x00060000
+#define BF_LRADC_CTRL0_XNURSW(v)  \
+		(((v) << 17) & BM_LRADC_CTRL0_XNURSW)
+#define BM_LRADC_CTRL0_XPULSW	0x00010000
+#define BP_LRADC_CTRL0_RSRVD1	8
+#define BM_LRADC_CTRL0_RSRVD1	0x0000FF00
+#define BF_LRADC_CTRL0_RSRVD1(v)  \
+		(((v) << 8) & BM_LRADC_CTRL0_RSRVD1)
+#define BP_LRADC_CTRL0_SCHEDULE	0
+#define BM_LRADC_CTRL0_SCHEDULE	0x000000FF
+#define BF_LRADC_CTRL0_SCHEDULE(v)  \
+		(((v) << 0) & BM_LRADC_CTRL0_SCHEDULE)
+
+#define HW_LRADC_CTRL1	(0x00000010)
+#define HW_LRADC_CTRL1_SET	(0x00000014)
+#define HW_LRADC_CTRL1_CLR	(0x00000018)
+#define HW_LRADC_CTRL1_TOG	(0x0000001c)
+
+#define BP_LRADC_CTRL1_RSRVD2	29
+#define BM_LRADC_CTRL1_RSRVD2	0xE0000000
+#define BF_LRADC_CTRL1_RSRVD2(v) \
+		(((v) << 29) & BM_LRADC_CTRL1_RSRVD2)
+#define BM_LRADC_CTRL1_BUTTON1_DETECT_IRQ_EN	0x10000000
+#define BV_LRADC_CTRL1_BUTTON1_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_BUTTON1_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_BUTTON0_DETECT_IRQ_EN	0x08000000
+#define BV_LRADC_CTRL1_BUTTON0_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_BUTTON0_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ_EN	0x04000000
+#define BV_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ_EN	0x02000000
+#define BV_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN	0x01000000
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC7_IRQ_EN	0x00800000
+#define BV_LRADC_CTRL1_LRADC7_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC7_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC6_IRQ_EN	0x00400000
+#define BV_LRADC_CTRL1_LRADC6_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC6_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC5_IRQ_EN	0x00200000
+#define BV_LRADC_CTRL1_LRADC5_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC5_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC4_IRQ_EN	0x00100000
+#define BV_LRADC_CTRL1_LRADC4_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC4_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC3_IRQ_EN	0x00080000
+#define BV_LRADC_CTRL1_LRADC3_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC3_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC2_IRQ_EN	0x00040000
+#define BV_LRADC_CTRL1_LRADC2_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC2_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC1_IRQ_EN	0x00020000
+#define BV_LRADC_CTRL1_LRADC1_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC1_IRQ_EN__ENABLE  0x1
+#define BM_LRADC_CTRL1_LRADC0_IRQ_EN	0x00010000
+#define BV_LRADC_CTRL1_LRADC0_IRQ_EN__DISABLE 0x0
+#define BV_LRADC_CTRL1_LRADC0_IRQ_EN__ENABLE  0x1
+#define BP_LRADC_CTRL1_RSRVD1	13
+#define BM_LRADC_CTRL1_RSRVD1	0x0000E000
+#define BF_LRADC_CTRL1_RSRVD1(v)  \
+		(((v) << 13) & BM_LRADC_CTRL1_RSRVD1)
+#define BM_LRADC_CTRL1_BUTTON1_DETECT_IRQ	0x00001000
+#define BV_LRADC_CTRL1_BUTTON1_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_BUTTON1_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_BUTTON0_DETECT_IRQ	0x00000800
+#define BV_LRADC_CTRL1_BUTTON0_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_BUTTON0_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ	0x00000400
+#define BV_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_THRESHOLD1_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ	0x00000200
+#define BV_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_THRESHOLD0_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_TOUCH_DETECT_IRQ	0x00000100
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_TOUCH_DETECT_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC7_IRQ	0x00000080
+#define BV_LRADC_CTRL1_LRADC7_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC7_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC6_IRQ	0x00000040
+#define BV_LRADC_CTRL1_LRADC6_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC6_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC5_IRQ	0x00000020
+#define BV_LRADC_CTRL1_LRADC5_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC5_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC4_IRQ	0x00000010
+#define BV_LRADC_CTRL1_LRADC4_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC4_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC3_IRQ	0x00000008
+#define BV_LRADC_CTRL1_LRADC3_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC3_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC2_IRQ	0x00000004
+#define BV_LRADC_CTRL1_LRADC2_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC2_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC1_IRQ	0x00000002
+#define BV_LRADC_CTRL1_LRADC1_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC1_IRQ__PENDING 0x1
+#define BM_LRADC_CTRL1_LRADC0_IRQ	0x00000001
+#define BV_LRADC_CTRL1_LRADC0_IRQ__CLEAR   0x0
+#define BV_LRADC_CTRL1_LRADC0_IRQ__PENDING 0x1
+
+#define HW_LRADC_CTRL2	(0x00000020)
+#define HW_LRADC_CTRL2_SET	(0x00000024)
+#define HW_LRADC_CTRL2_CLR	(0x00000028)
+#define HW_LRADC_CTRL2_TOG	(0x0000002c)
+
+#define BP_LRADC_CTRL2_DIVIDE_BY_TWO	24
+#define BM_LRADC_CTRL2_DIVIDE_BY_TWO	0xFF000000
+#define BF_LRADC_CTRL2_DIVIDE_BY_TWO(v) \
+		(((v) << 24) & BM_LRADC_CTRL2_DIVIDE_BY_TWO)
+#define BP_LRADC_CTRL2_RSRVD3	16
+#define BM_LRADC_CTRL2_RSRVD3	0x00FF0000
+#define BF_LRADC_CTRL2_RSRVD3(v)  \
+		(((v) << 16) & BM_LRADC_CTRL2_RSRVD3)
+#define BM_LRADC_CTRL2_TEMPSENSE_PWD	0x00008000
+#define BV_LRADC_CTRL2_TEMPSENSE_PWD__ENABLE  0x0
+#define BV_LRADC_CTRL2_TEMPSENSE_PWD__DISABLE 0x1
+#define BP_LRADC_CTRL2_VTHSENSE	13
+#define BM_LRADC_CTRL2_VTHSENSE	0x00006000
+#define BF_LRADC_CTRL2_VTHSENSE(v)  \
+		(((v) << 13) & BM_LRADC_CTRL2_VTHSENSE)
+#define BM_LRADC_CTRL2_DISABLE_MUXAMP_BYPASS	0x00001000
+#define BP_LRADC_CTRL2_RSRVD2	10
+#define BM_LRADC_CTRL2_RSRVD2	0x00000C00
+#define BF_LRADC_CTRL2_RSRVD2(v)  \
+		(((v) << 10) & BM_LRADC_CTRL2_RSRVD2)
+#define BM_LRADC_CTRL2_TEMP_SENSOR_IENABLE1	0x00000200
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE1__DISABLE 0x0
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE1__ENABLE  0x1
+#define BM_LRADC_CTRL2_TEMP_SENSOR_IENABLE0	0x00000100
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE0__DISABLE 0x0
+#define BV_LRADC_CTRL2_TEMP_SENSOR_IENABLE0__ENABLE  0x1
+#define BP_LRADC_CTRL2_TEMP_ISRC1	4
+#define BM_LRADC_CTRL2_TEMP_ISRC1	0x000000F0
+#define BF_LRADC_CTRL2_TEMP_ISRC1(v)  \
+		(((v) << 4) & BM_LRADC_CTRL2_TEMP_ISRC1)
+#define BV_LRADC_CTRL2_TEMP_ISRC1__300  0xF
+#define BV_LRADC_CTRL2_TEMP_ISRC1__280  0xE
+#define BV_LRADC_CTRL2_TEMP_ISRC1__260  0xD
+#define BV_LRADC_CTRL2_TEMP_ISRC1__240  0xC
+#define BV_LRADC_CTRL2_TEMP_ISRC1__220  0xB
+#define BV_LRADC_CTRL2_TEMP_ISRC1__200  0xA
+#define BV_LRADC_CTRL2_TEMP_ISRC1__180  0x9
+#define BV_LRADC_CTRL2_TEMP_ISRC1__160  0x8
+#define BV_LRADC_CTRL2_TEMP_ISRC1__140  0x7
+#define BV_LRADC_CTRL2_TEMP_ISRC1__120  0x6
+#define BV_LRADC_CTRL2_TEMP_ISRC1__100  0x5
+#define BV_LRADC_CTRL2_TEMP_ISRC1__80   0x4
+#define BV_LRADC_CTRL2_TEMP_ISRC1__60   0x3
+#define BV_LRADC_CTRL2_TEMP_ISRC1__40   0x2
+#define BV_LRADC_CTRL2_TEMP_ISRC1__20   0x1
+#define BV_LRADC_CTRL2_TEMP_ISRC1__ZERO 0x0
+#define BP_LRADC_CTRL2_TEMP_ISRC0	0
+#define BM_LRADC_CTRL2_TEMP_ISRC0	0x0000000F
+#define BF_LRADC_CTRL2_TEMP_ISRC0(v)  \
+		(((v) << 0) & BM_LRADC_CTRL2_TEMP_ISRC0)
+#define BV_LRADC_CTRL2_TEMP_ISRC0__300  0xF
+#define BV_LRADC_CTRL2_TEMP_ISRC0__280  0xE
+#define BV_LRADC_CTRL2_TEMP_ISRC0__260  0xD
+#define BV_LRADC_CTRL2_TEMP_ISRC0__240  0xC
+#define BV_LRADC_CTRL2_TEMP_ISRC0__220  0xB
+#define BV_LRADC_CTRL2_TEMP_ISRC0__200  0xA
+#define BV_LRADC_CTRL2_TEMP_ISRC0__180  0x9
+#define BV_LRADC_CTRL2_TEMP_ISRC0__160  0x8
+#define BV_LRADC_CTRL2_TEMP_ISRC0__140  0x7
+#define BV_LRADC_CTRL2_TEMP_ISRC0__120  0x6
+#define BV_LRADC_CTRL2_TEMP_ISRC0__100  0x5
+#define BV_LRADC_CTRL2_TEMP_ISRC0__80   0x4
+#define BV_LRADC_CTRL2_TEMP_ISRC0__60   0x3
+#define BV_LRADC_CTRL2_TEMP_ISRC0__40   0x2
+#define BV_LRADC_CTRL2_TEMP_ISRC0__20   0x1
+#define BV_LRADC_CTRL2_TEMP_ISRC0__ZERO 0x0
+
+#define HW_LRADC_CTRL3	(0x00000030)
+#define HW_LRADC_CTRL3_SET	(0x00000034)
+#define HW_LRADC_CTRL3_CLR	(0x00000038)
+#define HW_LRADC_CTRL3_TOG	(0x0000003c)
+
+#define BP_LRADC_CTRL3_RSRVD5	26
+#define BM_LRADC_CTRL3_RSRVD5	0xFC000000
+#define BF_LRADC_CTRL3_RSRVD5(v) \
+		(((v) << 26) & BM_LRADC_CTRL3_RSRVD5)
+#define BP_LRADC_CTRL3_DISCARD	24
+#define BM_LRADC_CTRL3_DISCARD	0x03000000
+#define BF_LRADC_CTRL3_DISCARD(v)  \
+		(((v) << 24) & BM_LRADC_CTRL3_DISCARD)
+#define BV_LRADC_CTRL3_DISCARD__1_SAMPLE  0x1
+#define BV_LRADC_CTRL3_DISCARD__2_SAMPLES 0x2
+#define BV_LRADC_CTRL3_DISCARD__3_SAMPLES 0x3
+#define BM_LRADC_CTRL3_FORCE_ANALOG_PWUP	0x00800000
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWUP__OFF 0x0
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWUP__ON  0x1
+#define BM_LRADC_CTRL3_FORCE_ANALOG_PWDN	0x00400000
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWDN__ON  0x0
+#define BV_LRADC_CTRL3_FORCE_ANALOG_PWDN__OFF 0x1
+#define BP_LRADC_CTRL3_RSRVD4	14
+#define BM_LRADC_CTRL3_RSRVD4	0x003FC000
+#define BF_LRADC_CTRL3_RSRVD4(v)  \
+		(((v) << 14) & BM_LRADC_CTRL3_RSRVD4)
+#define BP_LRADC_CTRL3_RSRVD3	10
+#define BM_LRADC_CTRL3_RSRVD3	0x00003C00
+#define BF_LRADC_CTRL3_RSRVD3(v)  \
+		(((v) << 10) & BM_LRADC_CTRL3_RSRVD3)
+#define BP_LRADC_CTRL3_CYCLE_TIME	8
+#define BM_LRADC_CTRL3_CYCLE_TIME	0x00000300
+#define BF_LRADC_CTRL3_CYCLE_TIME(v)  \
+		(((v) << 8) & BM_LRADC_CTRL3_CYCLE_TIME)
+#define BV_LRADC_CTRL3_CYCLE_TIME__6MHZ 0x0
+#define BV_LRADC_CTRL3_CYCLE_TIME__4MHZ 0x1
+#define BV_LRADC_CTRL3_CYCLE_TIME__3MHZ 0x2
+#define BV_LRADC_CTRL3_CYCLE_TIME__2MHZ 0x3
+#define BP_LRADC_CTRL3_RSRVD2	6
+#define BM_LRADC_CTRL3_RSRVD2	0x000000C0
+#define BF_LRADC_CTRL3_RSRVD2(v)  \
+		(((v) << 6) & BM_LRADC_CTRL3_RSRVD2)
+#define BP_LRADC_CTRL3_HIGH_TIME	4
+#define BM_LRADC_CTRL3_HIGH_TIME	0x00000030
+#define BF_LRADC_CTRL3_HIGH_TIME(v)  \
+		(((v) << 4) & BM_LRADC_CTRL3_HIGH_TIME)
+#define BV_LRADC_CTRL3_HIGH_TIME__42NS  0x0
+#define BV_LRADC_CTRL3_HIGH_TIME__83NS  0x1
+#define BV_LRADC_CTRL3_HIGH_TIME__125NS 0x2
+#define BV_LRADC_CTRL3_HIGH_TIME__250NS 0x3
+#define BP_LRADC_CTRL3_RSRVD1	2
+#define BM_LRADC_CTRL3_RSRVD1	0x0000000C
+#define BF_LRADC_CTRL3_RSRVD1(v)  \
+		(((v) << 2) & BM_LRADC_CTRL3_RSRVD1)
+#define BM_LRADC_CTRL3_DELAY_CLOCK	0x00000002
+#define BV_LRADC_CTRL3_DELAY_CLOCK__NORMAL  0x0
+#define BV_LRADC_CTRL3_DELAY_CLOCK__DELAYED 0x1
+#define BM_LRADC_CTRL3_INVERT_CLOCK	0x00000001
+#define BV_LRADC_CTRL3_INVERT_CLOCK__NORMAL 0x0
+#define BV_LRADC_CTRL3_INVERT_CLOCK__INVERT 0x1
+
+#define HW_LRADC_STATUS	(0x00000040)
+#define HW_LRADC_STATUS_SET	(0x00000044)
+#define HW_LRADC_STATUS_CLR	(0x00000048)
+#define HW_LRADC_STATUS_TOG	(0x0000004c)
+
+#define BP_LRADC_STATUS_RSRVD3	29
+#define BM_LRADC_STATUS_RSRVD3	0xE0000000
+#define BF_LRADC_STATUS_RSRVD3(v) \
+		(((v) << 29) & BM_LRADC_STATUS_RSRVD3)
+#define BM_LRADC_STATUS_BUTTON1_PRESENT	0x10000000
+#define BM_LRADC_STATUS_BUTTON0_PRESENT	0x08000000
+#define BM_LRADC_STATUS_TEMP1_PRESENT	0x04000000
+#define BM_LRADC_STATUS_TEMP0_PRESENT	0x02000000
+#define BM_LRADC_STATUS_TOUCH_PANEL_PRESENT	0x01000000
+#define BM_LRADC_STATUS_CHANNEL7_PRESENT	0x00800000
+#define BM_LRADC_STATUS_CHANNEL6_PRESENT	0x00400000
+#define BM_LRADC_STATUS_CHANNEL5_PRESENT	0x00200000
+#define BM_LRADC_STATUS_CHANNEL4_PRESENT	0x00100000
+#define BM_LRADC_STATUS_CHANNEL3_PRESENT	0x00080000
+#define BM_LRADC_STATUS_CHANNEL2_PRESENT	0x00040000
+#define BM_LRADC_STATUS_CHANNEL1_PRESENT	0x00020000
+#define BM_LRADC_STATUS_CHANNEL0_PRESENT	0x00010000
+#define BP_LRADC_STATUS_RSRVD2	3
+#define BM_LRADC_STATUS_RSRVD2	0x0000FFF8
+#define BF_LRADC_STATUS_RSRVD2(v)  \
+		(((v) << 3) & BM_LRADC_STATUS_RSRVD2)
+#define BM_LRADC_STATUS_BUTTON1_DETECT_RAW	0x00000004
+#define BV_LRADC_STATUS_BUTTON1_DETECT_RAW__OPEN 0x0
+#define BV_LRADC_STATUS_BUTTON1_DETECT_RAW__HIT  0x1
+#define BM_LRADC_STATUS_BUTTON0_DETECT_RAW	0x00000002
+#define BV_LRADC_STATUS_BUTTON0_DETECT_RAW__OPEN 0x0
+#define BV_LRADC_STATUS_BUTTON0_DETECT_RAW__HIT  0x1
+#define BM_LRADC_STATUS_TOUCH_DETECT_RAW	0x00000001
+#define BV_LRADC_STATUS_TOUCH_DETECT_RAW__OPEN 0x0
+#define BV_LRADC_STATUS_TOUCH_DETECT_RAW__HIT  0x1
+
+/*
+ *  multi-register-define name HW_LRADC_CHn
+ *              base 0x00000050
+ *              count 6
+ *              offset 0x10
+ */
+#define HW_LRADC_CHn(n)	(0x00000050 + (n) * 0x10)
+#define HW_LRADC_CHn_SET(n)	(0x00000054 + (n) * 0x10)
+#define HW_LRADC_CHn_CLR(n)	(0x00000058 + (n) * 0x10)
+#define HW_LRADC_CHn_TOG(n)	(0x0000005c + (n) * 0x10)
+#define BM_LRADC_CHn_TOGGLE	0x80000000
+#define BM_LRADC_CHn_RSRVD2	0x40000000
+#define BM_LRADC_CHn_ACCUMULATE	0x20000000
+#define BP_LRADC_CHn_NUM_SAMPLES	24
+#define BM_LRADC_CHn_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CHn_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CHn_NUM_SAMPLES)
+#define BP_LRADC_CHn_RSRVD1	18
+#define BM_LRADC_CHn_RSRVD1	0x00FC0000
+#define BF_LRADC_CHn_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CHn_RSRVD1)
+#define BP_LRADC_CHn_VALUE	0
+#define BM_LRADC_CHn_VALUE	0x0003FFFF
+#define BF_LRADC_CHn_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CHn_VALUE)
+
+#define HW_LRADC_CH6	(0x000000b0)
+#define HW_LRADC_CH6_SET	(0x000000b4)
+#define HW_LRADC_CH6_CLR	(0x000000b8)
+#define HW_LRADC_CH6_TOG	(0x000000bc)
+
+#define BM_LRADC_CH6_TOGGLE	0x80000000
+#define BM_LRADC_CH6_RSRVD2	0x40000000
+#define BM_LRADC_CH6_ACCUMULATE	0x20000000
+#define BP_LRADC_CH6_NUM_SAMPLES	24
+#define BM_LRADC_CH6_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CH6_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CH6_NUM_SAMPLES)
+#define BP_LRADC_CH6_RSRVD1	18
+#define BM_LRADC_CH6_RSRVD1	0x00FC0000
+#define BF_LRADC_CH6_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CH6_RSRVD1)
+#define BP_LRADC_CH6_VALUE	0
+#define BM_LRADC_CH6_VALUE	0x0003FFFF
+#define BF_LRADC_CH6_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CH6_VALUE)
+
+#define HW_LRADC_CH7	(0x000000c0)
+#define HW_LRADC_CH7_SET	(0x000000c4)
+#define HW_LRADC_CH7_CLR	(0x000000c8)
+#define HW_LRADC_CH7_TOG	(0x000000cc)
+
+#define BM_LRADC_CH7_TOGGLE	0x80000000
+#define BM_LRADC_CH7_TESTMODE_TOGGLE	0x40000000
+#define BM_LRADC_CH7_ACCUMULATE	0x20000000
+#define BP_LRADC_CH7_NUM_SAMPLES	24
+#define BM_LRADC_CH7_NUM_SAMPLES	0x1F000000
+#define BF_LRADC_CH7_NUM_SAMPLES(v)  \
+		(((v) << 24) & BM_LRADC_CH7_NUM_SAMPLES)
+#define BP_LRADC_CH7_RSRVD1	18
+#define BM_LRADC_CH7_RSRVD1	0x00FC0000
+#define BF_LRADC_CH7_RSRVD1(v)  \
+		(((v) << 18) & BM_LRADC_CH7_RSRVD1)
+#define BP_LRADC_CH7_VALUE	0
+#define BM_LRADC_CH7_VALUE	0x0003FFFF
+#define BF_LRADC_CH7_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_CH7_VALUE)
+
+/*
+ *  multi-register-define name HW_LRADC_DELAYn
+ *              base 0x000000D0
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_LRADC_DELAYn(n)	(0x000000d0 + (n) * 0x10)
+#define HW_LRADC_DELAYn_SET(n)	(0x000000d4 + (n) * 0x10)
+#define HW_LRADC_DELAYn_CLR(n)	(0x000000d8 + (n) * 0x10)
+#define HW_LRADC_DELAYn_TOG(n)	(0x000000dc + (n) * 0x10)
+#define BP_LRADC_DELAYn_TRIGGER_LRADCS	24
+#define BM_LRADC_DELAYn_TRIGGER_LRADCS	0xFF000000
+#define BF_LRADC_DELAYn_TRIGGER_LRADCS(v) \
+		(((v) << 24) & BM_LRADC_DELAYn_TRIGGER_LRADCS)
+#define BP_LRADC_DELAYn_RSRVD2	21
+#define BM_LRADC_DELAYn_RSRVD2	0x00E00000
+#define BF_LRADC_DELAYn_RSRVD2(v)  \
+		(((v) << 21) & BM_LRADC_DELAYn_RSRVD2)
+#define BM_LRADC_DELAYn_KICK	0x00100000
+#define BP_LRADC_DELAYn_TRIGGER_DELAYS	16
+#define BM_LRADC_DELAYn_TRIGGER_DELAYS	0x000F0000
+#define BF_LRADC_DELAYn_TRIGGER_DELAYS(v)  \
+		(((v) << 16) & BM_LRADC_DELAYn_TRIGGER_DELAYS)
+#define BP_LRADC_DELAYn_LOOP_COUNT	11
+#define BM_LRADC_DELAYn_LOOP_COUNT	0x0000F800
+#define BF_LRADC_DELAYn_LOOP_COUNT(v)  \
+		(((v) << 11) & BM_LRADC_DELAYn_LOOP_COUNT)
+#define BP_LRADC_DELAYn_DELAY	0
+#define BM_LRADC_DELAYn_DELAY	0x000007FF
+#define BF_LRADC_DELAYn_DELAY(v)  \
+		(((v) << 0) & BM_LRADC_DELAYn_DELAY)
+
+#define HW_LRADC_DEBUG0	(0x00000110)
+#define HW_LRADC_DEBUG0_SET	(0x00000114)
+#define HW_LRADC_DEBUG0_CLR	(0x00000118)
+#define HW_LRADC_DEBUG0_TOG	(0x0000011c)
+
+#define BP_LRADC_DEBUG0_READONLY	16
+#define BM_LRADC_DEBUG0_READONLY	0xFFFF0000
+#define BF_LRADC_DEBUG0_READONLY(v) \
+		(((v) << 16) & BM_LRADC_DEBUG0_READONLY)
+#define BP_LRADC_DEBUG0_RSRVD1	12
+#define BM_LRADC_DEBUG0_RSRVD1	0x0000F000
+#define BF_LRADC_DEBUG0_RSRVD1(v)  \
+		(((v) << 12) & BM_LRADC_DEBUG0_RSRVD1)
+#define BP_LRADC_DEBUG0_STATE	0
+#define BM_LRADC_DEBUG0_STATE	0x00000FFF
+#define BF_LRADC_DEBUG0_STATE(v)  \
+		(((v) << 0) & BM_LRADC_DEBUG0_STATE)
+
+#define HW_LRADC_DEBUG1	(0x00000120)
+#define HW_LRADC_DEBUG1_SET	(0x00000124)
+#define HW_LRADC_DEBUG1_CLR	(0x00000128)
+#define HW_LRADC_DEBUG1_TOG	(0x0000012c)
+
+#define BP_LRADC_DEBUG1_RSRVD3	24
+#define BM_LRADC_DEBUG1_RSRVD3	0xFF000000
+#define BF_LRADC_DEBUG1_RSRVD3(v) \
+		(((v) << 24) & BM_LRADC_DEBUG1_RSRVD3)
+#define BP_LRADC_DEBUG1_REQUEST	16
+#define BM_LRADC_DEBUG1_REQUEST	0x00FF0000
+#define BF_LRADC_DEBUG1_REQUEST(v)  \
+		(((v) << 16) & BM_LRADC_DEBUG1_REQUEST)
+#define BP_LRADC_DEBUG1_RSRVD2	13
+#define BM_LRADC_DEBUG1_RSRVD2	0x0000E000
+#define BF_LRADC_DEBUG1_RSRVD2(v)  \
+		(((v) << 13) & BM_LRADC_DEBUG1_RSRVD2)
+#define BP_LRADC_DEBUG1_TESTMODE_COUNT	8
+#define BM_LRADC_DEBUG1_TESTMODE_COUNT	0x00001F00
+#define BF_LRADC_DEBUG1_TESTMODE_COUNT(v)  \
+		(((v) << 8) & BM_LRADC_DEBUG1_TESTMODE_COUNT)
+#define BP_LRADC_DEBUG1_RSRVD1	3
+#define BM_LRADC_DEBUG1_RSRVD1	0x000000F8
+#define BF_LRADC_DEBUG1_RSRVD1(v)  \
+		(((v) << 3) & BM_LRADC_DEBUG1_RSRVD1)
+#define BM_LRADC_DEBUG1_TESTMODE6	0x00000004
+#define BV_LRADC_DEBUG1_TESTMODE6__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE6__TEST   0x1
+#define BM_LRADC_DEBUG1_TESTMODE5	0x00000002
+#define BV_LRADC_DEBUG1_TESTMODE5__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE5__TEST   0x1
+#define BM_LRADC_DEBUG1_TESTMODE	0x00000001
+#define BV_LRADC_DEBUG1_TESTMODE__NORMAL 0x0
+#define BV_LRADC_DEBUG1_TESTMODE__TEST   0x1
+
+#define HW_LRADC_CONVERSION	(0x00000130)
+#define HW_LRADC_CONVERSION_SET	(0x00000134)
+#define HW_LRADC_CONVERSION_CLR	(0x00000138)
+#define HW_LRADC_CONVERSION_TOG	(0x0000013c)
+
+#define BP_LRADC_CONVERSION_RSRVD3	21
+#define BM_LRADC_CONVERSION_RSRVD3	0xFFE00000
+#define BF_LRADC_CONVERSION_RSRVD3(v) \
+		(((v) << 21) & BM_LRADC_CONVERSION_RSRVD3)
+#define BM_LRADC_CONVERSION_AUTOMATIC	0x00100000
+#define BV_LRADC_CONVERSION_AUTOMATIC__DISABLE 0x0
+#define BV_LRADC_CONVERSION_AUTOMATIC__ENABLE  0x1
+#define BP_LRADC_CONVERSION_RSRVD2	18
+#define BM_LRADC_CONVERSION_RSRVD2	0x000C0000
+#define BF_LRADC_CONVERSION_RSRVD2(v)  \
+		(((v) << 18) & BM_LRADC_CONVERSION_RSRVD2)
+#define BP_LRADC_CONVERSION_SCALE_FACTOR	16
+#define BM_LRADC_CONVERSION_SCALE_FACTOR	0x00030000
+#define BF_LRADC_CONVERSION_SCALE_FACTOR(v)  \
+		(((v) << 16) & BM_LRADC_CONVERSION_SCALE_FACTOR)
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__NIMH       0x0
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__DUAL_NIMH  0x1
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__LI_ION     0x2
+#define BV_LRADC_CONVERSION_SCALE_FACTOR__ALT_LI_ION 0x3
+#define BP_LRADC_CONVERSION_RSRVD1	10
+#define BM_LRADC_CONVERSION_RSRVD1	0x0000FC00
+#define BF_LRADC_CONVERSION_RSRVD1(v)  \
+		(((v) << 10) & BM_LRADC_CONVERSION_RSRVD1)
+#define BP_LRADC_CONVERSION_SCALED_BATT_VOLTAGE	0
+#define BM_LRADC_CONVERSION_SCALED_BATT_VOLTAGE	0x000003FF
+#define BF_LRADC_CONVERSION_SCALED_BATT_VOLTAGE(v)  \
+		(((v) << 0) & BM_LRADC_CONVERSION_SCALED_BATT_VOLTAGE)
+
+#define HW_LRADC_CTRL4	(0x00000140)
+#define HW_LRADC_CTRL4_SET	(0x00000144)
+#define HW_LRADC_CTRL4_CLR	(0x00000148)
+#define HW_LRADC_CTRL4_TOG	(0x0000014c)
+
+#define BP_LRADC_CTRL4_LRADC7SELECT	28
+#define BM_LRADC_CTRL4_LRADC7SELECT	0xF0000000
+#define BF_LRADC_CTRL4_LRADC7SELECT(v) \
+		(((v) << 28) & BM_LRADC_CTRL4_LRADC7SELECT)
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC7SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC6SELECT	24
+#define BM_LRADC_CTRL4_LRADC6SELECT	0x0F000000
+#define BF_LRADC_CTRL4_LRADC6SELECT(v)  \
+		(((v) << 24) & BM_LRADC_CTRL4_LRADC6SELECT)
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC6SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC5SELECT	20
+#define BM_LRADC_CTRL4_LRADC5SELECT	0x00F00000
+#define BF_LRADC_CTRL4_LRADC5SELECT(v)  \
+		(((v) << 20) & BM_LRADC_CTRL4_LRADC5SELECT)
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC5SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC4SELECT	16
+#define BM_LRADC_CTRL4_LRADC4SELECT	0x000F0000
+#define BF_LRADC_CTRL4_LRADC4SELECT(v)  \
+		(((v) << 16) & BM_LRADC_CTRL4_LRADC4SELECT)
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC4SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC3SELECT	12
+#define BM_LRADC_CTRL4_LRADC3SELECT	0x0000F000
+#define BF_LRADC_CTRL4_LRADC3SELECT(v)  \
+		(((v) << 12) & BM_LRADC_CTRL4_LRADC3SELECT)
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC3SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC2SELECT	8
+#define BM_LRADC_CTRL4_LRADC2SELECT	0x00000F00
+#define BF_LRADC_CTRL4_LRADC2SELECT(v)  \
+		(((v) << 8) & BM_LRADC_CTRL4_LRADC2SELECT)
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC2SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC1SELECT	4
+#define BM_LRADC_CTRL4_LRADC1SELECT	0x000000F0
+#define BF_LRADC_CTRL4_LRADC1SELECT(v)  \
+		(((v) << 4) & BM_LRADC_CTRL4_LRADC1SELECT)
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC1SELECT__CHANNEL15 0xF
+#define BP_LRADC_CTRL4_LRADC0SELECT	0
+#define BM_LRADC_CTRL4_LRADC0SELECT	0x0000000F
+#define BF_LRADC_CTRL4_LRADC0SELECT(v)  \
+		(((v) << 0) & BM_LRADC_CTRL4_LRADC0SELECT)
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL0  0x0
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL1  0x1
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL2  0x2
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL3  0x3
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL4  0x4
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL5  0x5
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL6  0x6
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL7  0x7
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL8  0x8
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL9  0x9
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL10 0xA
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL11 0xB
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL12 0xC
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL13 0xD
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL14 0xE
+#define BV_LRADC_CTRL4_LRADC0SELECT__CHANNEL15 0xF
+
+#define HW_LRADC_THRESHOLD0	(0x00000150)
+#define HW_LRADC_THRESHOLD0_SET	(0x00000154)
+#define HW_LRADC_THRESHOLD0_CLR	(0x00000158)
+#define HW_LRADC_THRESHOLD0_TOG	(0x0000015c)
+
+#define BP_LRADC_THRESHOLD0_RSRVD1	25
+#define BM_LRADC_THRESHOLD0_RSRVD1	0xFE000000
+#define BF_LRADC_THRESHOLD0_RSRVD1(v) \
+		(((v) << 25) & BM_LRADC_THRESHOLD0_RSRVD1)
+#define BM_LRADC_THRESHOLD0_ENABLE	0x01000000
+#define BM_LRADC_THRESHOLD0_BATTCHRG_DISABLE	0x00800000
+#define BP_LRADC_THRESHOLD0_CHANNEL_SEL	20
+#define BM_LRADC_THRESHOLD0_CHANNEL_SEL	0x00700000
+#define BF_LRADC_THRESHOLD0_CHANNEL_SEL(v)  \
+		(((v) << 20) & BM_LRADC_THRESHOLD0_CHANNEL_SEL)
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL0 0x0
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL1 0x1
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL2 0x2
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL3 0x3
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL4 0x4
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL5 0x5
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL6 0x6
+#define BV_LRADC_THRESHOLD0_CHANNEL_SEL__CHANNEL7 0x7
+#define BP_LRADC_THRESHOLD0_SETTING	18
+#define BM_LRADC_THRESHOLD0_SETTING	0x000C0000
+#define BF_LRADC_THRESHOLD0_SETTING(v)  \
+		(((v) << 18) & BM_LRADC_THRESHOLD0_SETTING)
+#define BV_LRADC_THRESHOLD0_SETTING__NO_COMPARE  0x0
+#define BV_LRADC_THRESHOLD0_SETTING__DETECT_LOW  0x1
+#define BV_LRADC_THRESHOLD0_SETTING__DETECT_HIGH 0x2
+#define BV_LRADC_THRESHOLD0_SETTING__RESERVED    0x3
+#define BP_LRADC_THRESHOLD0_VALUE	0
+#define BM_LRADC_THRESHOLD0_VALUE	0x0003FFFF
+#define BF_LRADC_THRESHOLD0_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_THRESHOLD0_VALUE)
+
+#define HW_LRADC_THRESHOLD1	(0x00000160)
+#define HW_LRADC_THRESHOLD1_SET	(0x00000164)
+#define HW_LRADC_THRESHOLD1_CLR	(0x00000168)
+#define HW_LRADC_THRESHOLD1_TOG	(0x0000016c)
+
+#define BP_LRADC_THRESHOLD1_RSRVD1	25
+#define BM_LRADC_THRESHOLD1_RSRVD1	0xFE000000
+#define BF_LRADC_THRESHOLD1_RSRVD1(v) \
+		(((v) << 25) & BM_LRADC_THRESHOLD1_RSRVD1)
+#define BM_LRADC_THRESHOLD1_ENABLE	0x01000000
+#define BM_LRADC_THRESHOLD1_BATTCHRG_DISABLE	0x00800000
+#define BP_LRADC_THRESHOLD1_CHANNEL_SEL	20
+#define BM_LRADC_THRESHOLD1_CHANNEL_SEL	0x00700000
+#define BF_LRADC_THRESHOLD1_CHANNEL_SEL(v)  \
+		(((v) << 20) & BM_LRADC_THRESHOLD1_CHANNEL_SEL)
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL0 0x0
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL1 0x1
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL2 0x2
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL3 0x3
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL4 0x4
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL5 0x5
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL6 0x6
+#define BV_LRADC_THRESHOLD1_CHANNEL_SEL__CHANNEL7 0x7
+#define BP_LRADC_THRESHOLD1_SETTING	18
+#define BM_LRADC_THRESHOLD1_SETTING	0x000C0000
+#define BF_LRADC_THRESHOLD1_SETTING(v)  \
+		(((v) << 18) & BM_LRADC_THRESHOLD1_SETTING)
+#define BV_LRADC_THRESHOLD1_SETTING__NO_COMPARE  0x0
+#define BV_LRADC_THRESHOLD1_SETTING__DETECT_LOW  0x1
+#define BV_LRADC_THRESHOLD1_SETTING__DETECT_HIGH 0x2
+#define BV_LRADC_THRESHOLD1_SETTING__RESERVED    0x3
+#define BP_LRADC_THRESHOLD1_VALUE	0
+#define BM_LRADC_THRESHOLD1_VALUE	0x0003FFFF
+#define BF_LRADC_THRESHOLD1_VALUE(v)  \
+		(((v) << 0) & BM_LRADC_THRESHOLD1_VALUE)
+
+#define HW_LRADC_VERSION	(0x00000170)
+
+#define BP_LRADC_VERSION_MAJOR	24
+#define BM_LRADC_VERSION_MAJOR	0xFF000000
+#define BF_LRADC_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_LRADC_VERSION_MAJOR)
+#define BP_LRADC_VERSION_MINOR	16
+#define BM_LRADC_VERSION_MINOR	0x00FF0000
+#define BF_LRADC_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_LRADC_VERSION_MINOR)
+#define BP_LRADC_VERSION_STEP	0
+#define BM_LRADC_VERSION_STEP	0x0000FFFF
+#define BF_LRADC_VERSION_STEP(v)  \
+		(((v) << 0) & BM_LRADC_VERSION_STEP)
+#endif /* __ARCH_ARM___LRADC_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-power.h b/arch/arm/mach-mx28/include/mach/regs-power.h
new file mode 100644
index 0000000..8f6a8ee
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-power.h
@@ -0,0 +1,683 @@
+/*
+ * Freescale POWER Register Definitions
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.0
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___POWER_H
+#define __ARCH_ARM___POWER_H
+
+
+#include <mach/mx28.h>
+
+#define REGS_POWER_BASE IO_ADDRESS(POWER_PHYS_ADDR)
+#define REGS_POWER_PHYS (0x80044000)
+#define REGS_POWER_SIZE 0x00002000
+
+#define HW_POWER_CTRL	(0x00000000)
+#define HW_POWER_CTRL_SET	(0x00000004)
+#define HW_POWER_CTRL_CLR	(0x00000008)
+#define HW_POWER_CTRL_TOG	(0x0000000c)
+
+#define BP_POWER_CTRL_RSRVD2	28
+#define BM_POWER_CTRL_RSRVD2	0xF0000000
+#define BF_POWER_CTRL_RSRVD2(v) \
+		(((v) << 28) & BM_POWER_CTRL_RSRVD2)
+#define BM_POWER_CTRL_PSWITCH_MID_TRAN	0x08000000
+#define BP_POWER_CTRL_RSRVD1	25
+#define BM_POWER_CTRL_RSRVD1	0x06000000
+#define BF_POWER_CTRL_RSRVD1(v)  \
+		(((v) << 25) & BM_POWER_CTRL_RSRVD1)
+#define BM_POWER_CTRL_DCDC4P2_BO_IRQ	0x01000000
+#define BM_POWER_CTRL_ENIRQ_DCDC4P2_BO	0x00800000
+#define BM_POWER_CTRL_VDD5V_DROOP_IRQ	0x00400000
+#define BM_POWER_CTRL_ENIRQ_VDD5V_DROOP	0x00200000
+#define BM_POWER_CTRL_PSWITCH_IRQ	0x00100000
+#define BM_POWER_CTRL_PSWITCH_IRQ_SRC	0x00080000
+#define BM_POWER_CTRL_POLARITY_PSWITCH	0x00040000
+#define BM_POWER_CTRL_ENIRQ_PSWITCH	0x00020000
+#define BM_POWER_CTRL_POLARITY_DC_OK	0x00010000
+#define BM_POWER_CTRL_DC_OK_IRQ	0x00008000
+#define BM_POWER_CTRL_ENIRQ_DC_OK	0x00004000
+#define BM_POWER_CTRL_BATT_BO_IRQ	0x00002000
+#define BM_POWER_CTRL_ENIRQBATT_BO	0x00001000
+#define BM_POWER_CTRL_VDDIO_BO_IRQ	0x00000800
+#define BM_POWER_CTRL_ENIRQ_VDDIO_BO	0x00000400
+#define BM_POWER_CTRL_VDDA_BO_IRQ	0x00000200
+#define BM_POWER_CTRL_ENIRQ_VDDA_BO	0x00000100
+#define BM_POWER_CTRL_VDDD_BO_IRQ	0x00000080
+#define BM_POWER_CTRL_ENIRQ_VDDD_BO	0x00000040
+#define BM_POWER_CTRL_POLARITY_VBUSVALID	0x00000020
+#define BM_POWER_CTRL_VBUSVALID_IRQ	0x00000010
+#define BM_POWER_CTRL_ENIRQ_VBUS_VALID	0x00000008
+#define BM_POWER_CTRL_POLARITY_VDD5V_GT_VDDIO	0x00000004
+#define BM_POWER_CTRL_VDD5V_GT_VDDIO_IRQ	0x00000002
+#define BM_POWER_CTRL_ENIRQ_VDD5V_GT_VDDIO	0x00000001
+
+#define HW_POWER_5VCTRL	(0x00000010)
+#define HW_POWER_5VCTRL_SET	(0x00000014)
+#define HW_POWER_5VCTRL_CLR	(0x00000018)
+#define HW_POWER_5VCTRL_TOG	(0x0000001c)
+
+#define BP_POWER_5VCTRL_RSRVD6	30
+#define BM_POWER_5VCTRL_RSRVD6	0xC0000000
+#define BF_POWER_5VCTRL_RSRVD6(v) \
+		(((v) << 30) & BM_POWER_5VCTRL_RSRVD6)
+#define BP_POWER_5VCTRL_VBUSDROOP_TRSH	28
+#define BM_POWER_5VCTRL_VBUSDROOP_TRSH	0x30000000
+#define BF_POWER_5VCTRL_VBUSDROOP_TRSH(v)  \
+		(((v) << 28) & BM_POWER_5VCTRL_VBUSDROOP_TRSH)
+#define BM_POWER_5VCTRL_RSRVD5	0x08000000
+#define BP_POWER_5VCTRL_HEADROOM_ADJ	24
+#define BM_POWER_5VCTRL_HEADROOM_ADJ	0x07000000
+#define BF_POWER_5VCTRL_HEADROOM_ADJ(v)  \
+		(((v) << 24) & BM_POWER_5VCTRL_HEADROOM_ADJ)
+#define BP_POWER_5VCTRL_RSRVD4	22
+#define BM_POWER_5VCTRL_RSRVD4	0x00C00000
+#define BF_POWER_5VCTRL_RSRVD4(v)  \
+		(((v) << 22) & BM_POWER_5VCTRL_RSRVD4)
+#define BP_POWER_5VCTRL_PWD_CHARGE_4P2	20
+#define BM_POWER_5VCTRL_PWD_CHARGE_4P2	0x00300000
+#define BF_POWER_5VCTRL_PWD_CHARGE_4P2(v)  \
+		(((v) << 20) & BM_POWER_5VCTRL_PWD_CHARGE_4P2)
+#define BP_POWER_5VCTRL_RSRVD3	18
+#define BM_POWER_5VCTRL_RSRVD3	0x000C0000
+#define BF_POWER_5VCTRL_RSRVD3(v)  \
+		(((v) << 18) & BM_POWER_5VCTRL_RSRVD3)
+#define BP_POWER_5VCTRL_CHARGE_4P2_ILIMIT	12
+#define BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT	0x0003F000
+#define BF_POWER_5VCTRL_CHARGE_4P2_ILIMIT(v)  \
+		(((v) << 12) & BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT)
+#define BM_POWER_5VCTRL_RSRVD2	0x00000800
+#define BP_POWER_5VCTRL_VBUSVALID_TRSH	8
+#define BM_POWER_5VCTRL_VBUSVALID_TRSH	0x00000700
+#define BF_POWER_5VCTRL_VBUSVALID_TRSH(v)  \
+		(((v) << 8) & BM_POWER_5VCTRL_VBUSVALID_TRSH)
+#define BM_POWER_5VCTRL_PWDN_5VBRNOUT	0x00000080
+#define BM_POWER_5VCTRL_ENABLE_LINREG_ILIMIT	0x00000040
+#define BM_POWER_5VCTRL_DCDC_XFER	0x00000020
+#define BM_POWER_5VCTRL_VBUSVALID_5VDETECT	0x00000010
+#define BM_POWER_5VCTRL_VBUSVALID_TO_B	0x00000008
+#define BM_POWER_5VCTRL_ILIMIT_EQ_ZERO	0x00000004
+#define BM_POWER_5VCTRL_PWRUP_VBUS_CMPS	0x00000002
+#define BM_POWER_5VCTRL_ENABLE_DCDC	0x00000001
+
+#define HW_POWER_MINPWR	(0x00000020)
+#define HW_POWER_MINPWR_SET	(0x00000024)
+#define HW_POWER_MINPWR_CLR	(0x00000028)
+#define HW_POWER_MINPWR_TOG	(0x0000002c)
+
+#define BP_POWER_MINPWR_RSRVD1	15
+#define BM_POWER_MINPWR_RSRVD1	0xFFFF8000
+#define BF_POWER_MINPWR_RSRVD1(v) \
+		(((v) << 15) & BM_POWER_MINPWR_RSRVD1)
+#define BM_POWER_MINPWR_LOWPWR_4P2	0x00004000
+#define BM_POWER_MINPWR_VDAC_DUMP_CTRL	0x00002000
+#define BM_POWER_MINPWR_PWD_BO	0x00001000
+#define BM_POWER_MINPWR_USE_VDDXTAL_VBG	0x00000800
+#define BM_POWER_MINPWR_PWD_ANA_CMPS	0x00000400
+#define BM_POWER_MINPWR_ENABLE_OSC	0x00000200
+#define BM_POWER_MINPWR_SELECT_OSC	0x00000100
+#define BM_POWER_MINPWR_VBG_OFF	0x00000080
+#define BM_POWER_MINPWR_DOUBLE_FETS	0x00000040
+#define BM_POWER_MINPWR_HALF_FETS	0x00000020
+#define BM_POWER_MINPWR_LESSANA_I	0x00000010
+#define BM_POWER_MINPWR_PWD_XTAL24	0x00000008
+#define BM_POWER_MINPWR_DC_STOPCLK	0x00000004
+#define BM_POWER_MINPWR_EN_DC_PFM	0x00000002
+#define BM_POWER_MINPWR_DC_HALFCLK	0x00000001
+
+#define HW_POWER_CHARGE	(0x00000030)
+#define HW_POWER_CHARGE_SET	(0x00000034)
+#define HW_POWER_CHARGE_CLR	(0x00000038)
+#define HW_POWER_CHARGE_TOG	(0x0000003c)
+
+#define BP_POWER_CHARGE_RSRVD6	27
+#define BM_POWER_CHARGE_RSRVD6	0xF8000000
+#define BF_POWER_CHARGE_RSRVD6(v) \
+		(((v) << 27) & BM_POWER_CHARGE_RSRVD6)
+#define BP_POWER_CHARGE_ADJ_VOLT	24
+#define BM_POWER_CHARGE_ADJ_VOLT	0x07000000
+#define BF_POWER_CHARGE_ADJ_VOLT(v)  \
+		(((v) << 24) & BM_POWER_CHARGE_ADJ_VOLT)
+#define BM_POWER_CHARGE_RSRVD5	0x00800000
+#define BM_POWER_CHARGE_ENABLE_LOAD	0x00400000
+#define BM_POWER_CHARGE_RSRVD4	0x00200000
+#define BM_POWER_CHARGE_ENABLE_FAULT_DETECT	0x00100000
+#define BM_POWER_CHARGE_CHRG_STS_OFF	0x00080000
+#define BM_POWER_CHARGE_LIION_4P1	0x00040000
+#define BM_POWER_CHARGE_RSRVD3	0x00020000
+#define BM_POWER_CHARGE_PWD_BATTCHRG	0x00010000
+#define BP_POWER_CHARGE_RSRVD2	14
+#define BM_POWER_CHARGE_RSRVD2	0x0000C000
+#define BF_POWER_CHARGE_RSRVD2(v)  \
+		(((v) << 14) & BM_POWER_CHARGE_RSRVD2)
+#define BM_POWER_CHARGE_ENABLE_CHARGER_USB1	0x00002000
+#define BM_POWER_CHARGE_ENABLE_CHARGER_USB0	0x00001000
+#define BP_POWER_CHARGE_STOP_ILIMIT	8
+#define BM_POWER_CHARGE_STOP_ILIMIT	0x00000F00
+#define BF_POWER_CHARGE_STOP_ILIMIT(v)  \
+		(((v) << 8) & BM_POWER_CHARGE_STOP_ILIMIT)
+#define BP_POWER_CHARGE_RSRVD1	6
+#define BM_POWER_CHARGE_RSRVD1	0x000000C0
+#define BF_POWER_CHARGE_RSRVD1(v)  \
+		(((v) << 6) & BM_POWER_CHARGE_RSRVD1)
+#define BP_POWER_CHARGE_BATTCHRG_I	0
+#define BM_POWER_CHARGE_BATTCHRG_I	0x0000003F
+#define BF_POWER_CHARGE_BATTCHRG_I(v)  \
+		(((v) << 0) & BM_POWER_CHARGE_BATTCHRG_I)
+
+#define HW_POWER_VDDDCTRL	(0x00000040)
+
+#define BP_POWER_VDDDCTRL_ADJTN	28
+#define BM_POWER_VDDDCTRL_ADJTN	0xF0000000
+#define BF_POWER_VDDDCTRL_ADJTN(v) \
+		(((v) << 28) & BM_POWER_VDDDCTRL_ADJTN)
+#define BP_POWER_VDDDCTRL_RSRVD4	24
+#define BM_POWER_VDDDCTRL_RSRVD4	0x0F000000
+#define BF_POWER_VDDDCTRL_RSRVD4(v)  \
+		(((v) << 24) & BM_POWER_VDDDCTRL_RSRVD4)
+#define BM_POWER_VDDDCTRL_PWDN_BRNOUT	0x00800000
+#define BM_POWER_VDDDCTRL_DISABLE_STEPPING	0x00400000
+#define BM_POWER_VDDDCTRL_ENABLE_LINREG	0x00200000
+#define BM_POWER_VDDDCTRL_DISABLE_FET	0x00100000
+#define BP_POWER_VDDDCTRL_RSRVD3	18
+#define BM_POWER_VDDDCTRL_RSRVD3	0x000C0000
+#define BF_POWER_VDDDCTRL_RSRVD3(v)  \
+		(((v) << 18) & BM_POWER_VDDDCTRL_RSRVD3)
+#define BP_POWER_VDDDCTRL_LINREG_OFFSET	16
+#define BM_POWER_VDDDCTRL_LINREG_OFFSET	0x00030000
+#define BF_POWER_VDDDCTRL_LINREG_OFFSET(v)  \
+		(((v) << 16) & BM_POWER_VDDDCTRL_LINREG_OFFSET)
+#define BP_POWER_VDDDCTRL_RSRVD2	11
+#define BM_POWER_VDDDCTRL_RSRVD2	0x0000F800
+#define BF_POWER_VDDDCTRL_RSRVD2(v)  \
+		(((v) << 11) & BM_POWER_VDDDCTRL_RSRVD2)
+#define BP_POWER_VDDDCTRL_BO_OFFSET	8
+#define BM_POWER_VDDDCTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDDCTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDDCTRL_BO_OFFSET)
+#define BP_POWER_VDDDCTRL_RSRVD1	5
+#define BM_POWER_VDDDCTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDDCTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDDCTRL_RSRVD1)
+#define BP_POWER_VDDDCTRL_TRG	0
+#define BM_POWER_VDDDCTRL_TRG	0x0000001F
+#define BF_POWER_VDDDCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDDCTRL_TRG)
+
+#define HW_POWER_VDDACTRL	(0x00000050)
+
+#define BP_POWER_VDDACTRL_RSRVD4	20
+#define BM_POWER_VDDACTRL_RSRVD4	0xFFF00000
+#define BF_POWER_VDDACTRL_RSRVD4(v) \
+		(((v) << 20) & BM_POWER_VDDACTRL_RSRVD4)
+#define BM_POWER_VDDACTRL_PWDN_BRNOUT	0x00080000
+#define BM_POWER_VDDACTRL_DISABLE_STEPPING	0x00040000
+#define BM_POWER_VDDACTRL_ENABLE_LINREG	0x00020000
+#define BM_POWER_VDDACTRL_DISABLE_FET	0x00010000
+#define BP_POWER_VDDACTRL_RSRVD3	14
+#define BM_POWER_VDDACTRL_RSRVD3	0x0000C000
+#define BF_POWER_VDDACTRL_RSRVD3(v)  \
+		(((v) << 14) & BM_POWER_VDDACTRL_RSRVD3)
+#define BP_POWER_VDDACTRL_LINREG_OFFSET	12
+#define BM_POWER_VDDACTRL_LINREG_OFFSET	0x00003000
+#define BF_POWER_VDDACTRL_LINREG_OFFSET(v)  \
+		(((v) << 12) & BM_POWER_VDDACTRL_LINREG_OFFSET)
+#define BM_POWER_VDDACTRL_RSRVD2	0x00000800
+#define BP_POWER_VDDACTRL_BO_OFFSET	8
+#define BM_POWER_VDDACTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDACTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDACTRL_BO_OFFSET)
+#define BP_POWER_VDDACTRL_RSRVD1	5
+#define BM_POWER_VDDACTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDACTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDACTRL_RSRVD1)
+#define BP_POWER_VDDACTRL_TRG	0
+#define BM_POWER_VDDACTRL_TRG	0x0000001F
+#define BF_POWER_VDDACTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDACTRL_TRG)
+
+#define HW_POWER_VDDIOCTRL	(0x00000060)
+
+#define BP_POWER_VDDIOCTRL_RSRVD5	24
+#define BM_POWER_VDDIOCTRL_RSRVD5	0xFF000000
+#define BF_POWER_VDDIOCTRL_RSRVD5(v) \
+		(((v) << 24) & BM_POWER_VDDIOCTRL_RSRVD5)
+#define BP_POWER_VDDIOCTRL_ADJTN	20
+#define BM_POWER_VDDIOCTRL_ADJTN	0x00F00000
+#define BF_POWER_VDDIOCTRL_ADJTN(v)  \
+		(((v) << 20) & BM_POWER_VDDIOCTRL_ADJTN)
+#define BM_POWER_VDDIOCTRL_RSRVD4	0x00080000
+#define BM_POWER_VDDIOCTRL_PWDN_BRNOUT	0x00040000
+#define BM_POWER_VDDIOCTRL_DISABLE_STEPPING	0x00020000
+#define BM_POWER_VDDIOCTRL_DISABLE_FET	0x00010000
+#define BP_POWER_VDDIOCTRL_RSRVD3	14
+#define BM_POWER_VDDIOCTRL_RSRVD3	0x0000C000
+#define BF_POWER_VDDIOCTRL_RSRVD3(v)  \
+		(((v) << 14) & BM_POWER_VDDIOCTRL_RSRVD3)
+#define BP_POWER_VDDIOCTRL_LINREG_OFFSET	12
+#define BM_POWER_VDDIOCTRL_LINREG_OFFSET	0x00003000
+#define BF_POWER_VDDIOCTRL_LINREG_OFFSET(v)  \
+		(((v) << 12) & BM_POWER_VDDIOCTRL_LINREG_OFFSET)
+#define BM_POWER_VDDIOCTRL_RSRVD2	0x00000800
+#define BP_POWER_VDDIOCTRL_BO_OFFSET	8
+#define BM_POWER_VDDIOCTRL_BO_OFFSET	0x00000700
+#define BF_POWER_VDDIOCTRL_BO_OFFSET(v)  \
+		(((v) << 8) & BM_POWER_VDDIOCTRL_BO_OFFSET)
+#define BP_POWER_VDDIOCTRL_RSRVD1	5
+#define BM_POWER_VDDIOCTRL_RSRVD1	0x000000E0
+#define BF_POWER_VDDIOCTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_VDDIOCTRL_RSRVD1)
+#define BP_POWER_VDDIOCTRL_TRG	0
+#define BM_POWER_VDDIOCTRL_TRG	0x0000001F
+#define BF_POWER_VDDIOCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDIOCTRL_TRG)
+
+#define HW_POWER_VDDMEMCTRL	(0x00000070)
+
+#define BP_POWER_VDDMEMCTRL_RSRVD2	11
+#define BM_POWER_VDDMEMCTRL_RSRVD2	0xFFFFF800
+#define BF_POWER_VDDMEMCTRL_RSRVD2(v) \
+		(((v) << 11) & BM_POWER_VDDMEMCTRL_RSRVD2)
+#define BM_POWER_VDDMEMCTRL_PULLDOWN_ACTIVE	0x00000400
+#define BM_POWER_VDDMEMCTRL_ENABLE_ILIMIT	0x00000200
+#define BM_POWER_VDDMEMCTRL_ENABLE_LINREG	0x00000100
+#define BP_POWER_VDDMEMCTRL_BO_OFFSET	5
+#define BM_POWER_VDDMEMCTRL_BO_OFFSET	0x000000E0
+#define BF_POWER_VDDMEMCTRL_BO_OFFSET(v)  \
+		(((v) << 5) & BM_POWER_VDDMEMCTRL_BO_OFFSET)
+#define BP_POWER_VDDMEMCTRL_TRG	0
+#define BM_POWER_VDDMEMCTRL_TRG	0x0000001F
+#define BF_POWER_VDDMEMCTRL_TRG(v)  \
+		(((v) << 0) & BM_POWER_VDDMEMCTRL_TRG)
+
+#define HW_POWER_DCDC4P2	(0x00000080)
+
+#define BP_POWER_DCDC4P2_DROPOUT_CTRL	28
+#define BM_POWER_DCDC4P2_DROPOUT_CTRL	0xF0000000
+#define BF_POWER_DCDC4P2_DROPOUT_CTRL(v) \
+		(((v) << 28) & BM_POWER_DCDC4P2_DROPOUT_CTRL)
+#define BP_POWER_DCDC4P2_RSRVD5	26
+#define BM_POWER_DCDC4P2_RSRVD5	0x0C000000
+#define BF_POWER_DCDC4P2_RSRVD5(v)  \
+		(((v) << 26) & BM_POWER_DCDC4P2_RSRVD5)
+#define BP_POWER_DCDC4P2_ISTEAL_THRESH	24
+#define BM_POWER_DCDC4P2_ISTEAL_THRESH	0x03000000
+#define BF_POWER_DCDC4P2_ISTEAL_THRESH(v)  \
+		(((v) << 24) & BM_POWER_DCDC4P2_ISTEAL_THRESH)
+#define BM_POWER_DCDC4P2_ENABLE_4P2	0x00800000
+#define BM_POWER_DCDC4P2_ENABLE_DCDC	0x00400000
+#define BM_POWER_DCDC4P2_HYST_DIR	0x00200000
+#define BM_POWER_DCDC4P2_HYST_THRESH	0x00100000
+#define BM_POWER_DCDC4P2_RSRVD3	0x00080000
+#define BP_POWER_DCDC4P2_TRG	16
+#define BM_POWER_DCDC4P2_TRG	0x00070000
+#define BF_POWER_DCDC4P2_TRG(v)  \
+		(((v) << 16) & BM_POWER_DCDC4P2_TRG)
+#define BP_POWER_DCDC4P2_RSRVD2	13
+#define BM_POWER_DCDC4P2_RSRVD2	0x0000E000
+#define BF_POWER_DCDC4P2_RSRVD2(v)  \
+		(((v) << 13) & BM_POWER_DCDC4P2_RSRVD2)
+#define BP_POWER_DCDC4P2_BO	8
+#define BM_POWER_DCDC4P2_BO	0x00001F00
+#define BF_POWER_DCDC4P2_BO(v)  \
+		(((v) << 8) & BM_POWER_DCDC4P2_BO)
+#define BP_POWER_DCDC4P2_RSRVD1	5
+#define BM_POWER_DCDC4P2_RSRVD1	0x000000E0
+#define BF_POWER_DCDC4P2_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_DCDC4P2_RSRVD1)
+#define BP_POWER_DCDC4P2_CMPTRIP	0
+#define BM_POWER_DCDC4P2_CMPTRIP	0x0000001F
+#define BF_POWER_DCDC4P2_CMPTRIP(v)  \
+		(((v) << 0) & BM_POWER_DCDC4P2_CMPTRIP)
+
+#define HW_POWER_MISC	(0x00000090)
+
+#define BP_POWER_MISC_RSRVD2	7
+#define BM_POWER_MISC_RSRVD2	0xFFFFFF80
+#define BF_POWER_MISC_RSRVD2(v) \
+		(((v) << 7) & BM_POWER_MISC_RSRVD2)
+#define BP_POWER_MISC_FREQSEL	4
+#define BM_POWER_MISC_FREQSEL	0x00000070
+#define BF_POWER_MISC_FREQSEL(v)  \
+		(((v) << 4) & BM_POWER_MISC_FREQSEL)
+#define BM_POWER_MISC_DISABLEFET_BO_LOGIC	0x00000008
+#define BM_POWER_MISC_DELAY_TIMING	0x00000004
+#define BM_POWER_MISC_TEST	0x00000002
+#define BM_POWER_MISC_SEL_PLLCLK	0x00000001
+
+#define HW_POWER_DCLIMITS	(0x000000a0)
+
+#define BP_POWER_DCLIMITS_RSRVD3	16
+#define BM_POWER_DCLIMITS_RSRVD3	0xFFFF0000
+#define BF_POWER_DCLIMITS_RSRVD3(v) \
+		(((v) << 16) & BM_POWER_DCLIMITS_RSRVD3)
+#define BM_POWER_DCLIMITS_RSRVD2	0x00008000
+#define BP_POWER_DCLIMITS_POSLIMIT_BUCK	8
+#define BM_POWER_DCLIMITS_POSLIMIT_BUCK	0x00007F00
+#define BF_POWER_DCLIMITS_POSLIMIT_BUCK(v)  \
+		(((v) << 8) & BM_POWER_DCLIMITS_POSLIMIT_BUCK)
+#define BM_POWER_DCLIMITS_RSRVD1	0x00000080
+#define BP_POWER_DCLIMITS_NEGLIMIT	0
+#define BM_POWER_DCLIMITS_NEGLIMIT	0x0000007F
+#define BF_POWER_DCLIMITS_NEGLIMIT(v)  \
+		(((v) << 0) & BM_POWER_DCLIMITS_NEGLIMIT)
+
+#define HW_POWER_LOOPCTRL	(0x000000b0)
+#define HW_POWER_LOOPCTRL_SET	(0x000000b4)
+#define HW_POWER_LOOPCTRL_CLR	(0x000000b8)
+#define HW_POWER_LOOPCTRL_TOG	(0x000000bc)
+
+#define BP_POWER_LOOPCTRL_RSRVD3	21
+#define BM_POWER_LOOPCTRL_RSRVD3	0xFFE00000
+#define BF_POWER_LOOPCTRL_RSRVD3(v) \
+		(((v) << 21) & BM_POWER_LOOPCTRL_RSRVD3)
+#define BM_POWER_LOOPCTRL_TOGGLE_DIF	0x00100000
+#define BM_POWER_LOOPCTRL_HYST_SIGN	0x00080000
+#define BM_POWER_LOOPCTRL_EN_CM_HYST	0x00040000
+#define BM_POWER_LOOPCTRL_EN_DF_HYST	0x00020000
+#define BM_POWER_LOOPCTRL_CM_HYST_THRESH	0x00010000
+#define BM_POWER_LOOPCTRL_DF_HYST_THRESH	0x00008000
+#define BM_POWER_LOOPCTRL_RCSCALE_THRESH	0x00004000
+#define BP_POWER_LOOPCTRL_EN_RCSCALE	12
+#define BM_POWER_LOOPCTRL_EN_RCSCALE	0x00003000
+#define BF_POWER_LOOPCTRL_EN_RCSCALE(v)  \
+		(((v) << 12) & BM_POWER_LOOPCTRL_EN_RCSCALE)
+#define BM_POWER_LOOPCTRL_RSRVD2	0x00000800
+#define BP_POWER_LOOPCTRL_DC_FF	8
+#define BM_POWER_LOOPCTRL_DC_FF	0x00000700
+#define BF_POWER_LOOPCTRL_DC_FF(v)  \
+		(((v) << 8) & BM_POWER_LOOPCTRL_DC_FF)
+#define BP_POWER_LOOPCTRL_DC_R	4
+#define BM_POWER_LOOPCTRL_DC_R	0x000000F0
+#define BF_POWER_LOOPCTRL_DC_R(v)  \
+		(((v) << 4) & BM_POWER_LOOPCTRL_DC_R)
+#define BP_POWER_LOOPCTRL_RSRVD1	2
+#define BM_POWER_LOOPCTRL_RSRVD1	0x0000000C
+#define BF_POWER_LOOPCTRL_RSRVD1(v)  \
+		(((v) << 2) & BM_POWER_LOOPCTRL_RSRVD1)
+#define BP_POWER_LOOPCTRL_DC_C	0
+#define BM_POWER_LOOPCTRL_DC_C	0x00000003
+#define BF_POWER_LOOPCTRL_DC_C(v)  \
+		(((v) << 0) & BM_POWER_LOOPCTRL_DC_C)
+
+#define HW_POWER_STS	(0x000000c0)
+
+#define BP_POWER_STS_RSRVD3	30
+#define BM_POWER_STS_RSRVD3	0xC0000000
+#define BF_POWER_STS_RSRVD3(v) \
+		(((v) << 30) & BM_POWER_STS_RSRVD3)
+#define BP_POWER_STS_PWRUP_SOURCE	24
+#define BM_POWER_STS_PWRUP_SOURCE	0x3F000000
+#define BF_POWER_STS_PWRUP_SOURCE(v)  \
+		(((v) << 24) & BM_POWER_STS_PWRUP_SOURCE)
+#define BP_POWER_STS_RSRVD2	22
+#define BM_POWER_STS_RSRVD2	0x00C00000
+#define BF_POWER_STS_RSRVD2(v)  \
+		(((v) << 22) & BM_POWER_STS_RSRVD2)
+#define BP_POWER_STS_PSWITCH	20
+#define BM_POWER_STS_PSWITCH	0x00300000
+#define BF_POWER_STS_PSWITCH(v)  \
+		(((v) << 20) & BM_POWER_STS_PSWITCH)
+#define BM_POWER_STS_THERMAL_WARNING	0x00080000
+#define BM_POWER_STS_VDDMEM_BO	0x00040000
+#define BM_POWER_STS_AVALID0_STATUS	0x00020000
+#define BM_POWER_STS_BVALID0_STATUS	0x00010000
+#define BM_POWER_STS_VBUSVALID0_STATUS	0x00008000
+#define BM_POWER_STS_SESSEND0_STATUS	0x00004000
+#define BM_POWER_STS_BATT_BO	0x00002000
+#define BM_POWER_STS_VDD5V_FAULT	0x00001000
+#define BM_POWER_STS_CHRGSTS	0x00000800
+#define BM_POWER_STS_DCDC_4P2_BO	0x00000400
+#define BM_POWER_STS_DC_OK	0x00000200
+#define BM_POWER_STS_VDDIO_BO	0x00000100
+#define BM_POWER_STS_VDDA_BO	0x00000080
+#define BM_POWER_STS_VDDD_BO	0x00000040
+#define BM_POWER_STS_VDD5V_GT_VDDIO	0x00000020
+#define BM_POWER_STS_VDD5V_DROOP	0x00000010
+#define BM_POWER_STS_AVALID0	0x00000008
+#define BM_POWER_STS_BVALID0	0x00000004
+#define BM_POWER_STS_VBUSVALID0	0x00000002
+#define BM_POWER_STS_SESSEND0	0x00000001
+
+#define HW_POWER_SPEED	(0x000000d0)
+#define HW_POWER_SPEED_SET	(0x000000d4)
+#define HW_POWER_SPEED_CLR	(0x000000d8)
+#define HW_POWER_SPEED_TOG	(0x000000dc)
+
+#define BP_POWER_SPEED_RSRVD1	24
+#define BM_POWER_SPEED_RSRVD1	0xFF000000
+#define BF_POWER_SPEED_RSRVD1(v) \
+		(((v) << 24) & BM_POWER_SPEED_RSRVD1)
+#define BP_POWER_SPEED_STATUS	8
+#define BM_POWER_SPEED_STATUS	0x00FFFF00
+#define BF_POWER_SPEED_STATUS(v)  \
+		(((v) << 8) & BM_POWER_SPEED_STATUS)
+#define BP_POWER_SPEED_STATUS_SEL	6
+#define BM_POWER_SPEED_STATUS_SEL	0x000000C0
+#define BF_POWER_SPEED_STATUS_SEL(v)  \
+		(((v) << 6) & BM_POWER_SPEED_STATUS_SEL)
+#define BV_POWER_SPEED_STATUS_SEL__DCDC_STAT 0x0
+#define BV_POWER_SPEED_STATUS_SEL__CORE_STAT 0x1
+#define BV_POWER_SPEED_STATUS_SEL__ARM_STAT  0x2
+#define BP_POWER_SPEED_RSRVD0	2
+#define BM_POWER_SPEED_RSRVD0	0x0000003C
+#define BF_POWER_SPEED_RSRVD0(v)  \
+		(((v) << 2) & BM_POWER_SPEED_RSRVD0)
+#define BP_POWER_SPEED_CTRL	0
+#define BM_POWER_SPEED_CTRL	0x00000003
+#define BF_POWER_SPEED_CTRL(v)  \
+		(((v) << 0) & BM_POWER_SPEED_CTRL)
+
+#define HW_POWER_BATTMONITOR	(0x000000e0)
+
+#define BP_POWER_BATTMONITOR_RSRVD3	26
+#define BM_POWER_BATTMONITOR_RSRVD3	0xFC000000
+#define BF_POWER_BATTMONITOR_RSRVD3(v) \
+		(((v) << 26) & BM_POWER_BATTMONITOR_RSRVD3)
+#define BP_POWER_BATTMONITOR_BATT_VAL	16
+#define BM_POWER_BATTMONITOR_BATT_VAL	0x03FF0000
+#define BF_POWER_BATTMONITOR_BATT_VAL(v)  \
+		(((v) << 16) & BM_POWER_BATTMONITOR_BATT_VAL)
+#define BP_POWER_BATTMONITOR_RSRVD2	12
+#define BM_POWER_BATTMONITOR_RSRVD2	0x0000F000
+#define BF_POWER_BATTMONITOR_RSRVD2(v)  \
+		(((v) << 12) & BM_POWER_BATTMONITOR_RSRVD2)
+#define BM_POWER_BATTMONITOR_PWDN_BATTBRNOUT_5VDETECT_ENABLE	0x00000800
+#define BM_POWER_BATTMONITOR_EN_BATADJ	0x00000400
+#define BM_POWER_BATTMONITOR_PWDN_BATTBRNOUT	0x00000200
+#define BM_POWER_BATTMONITOR_BRWNOUT_PWD	0x00000100
+#define BP_POWER_BATTMONITOR_RSRVD1	5
+#define BM_POWER_BATTMONITOR_RSRVD1	0x000000E0
+#define BF_POWER_BATTMONITOR_RSRVD1(v)  \
+		(((v) << 5) & BM_POWER_BATTMONITOR_RSRVD1)
+#define BP_POWER_BATTMONITOR_BRWNOUT_LVL	0
+#define BM_POWER_BATTMONITOR_BRWNOUT_LVL	0x0000001F
+#define BF_POWER_BATTMONITOR_BRWNOUT_LVL(v)  \
+		(((v) << 0) & BM_POWER_BATTMONITOR_BRWNOUT_LVL)
+
+#define HW_POWER_RESET	(0x00000100)
+#define HW_POWER_RESET_SET	(0x00000104)
+#define HW_POWER_RESET_CLR	(0x00000108)
+#define HW_POWER_RESET_TOG	(0x0000010c)
+
+#define BP_POWER_RESET_UNLOCK	16
+#define BM_POWER_RESET_UNLOCK	0xFFFF0000
+#define BF_POWER_RESET_UNLOCK(v) \
+		(((v) << 16) & BM_POWER_RESET_UNLOCK)
+#define BV_POWER_RESET_UNLOCK__KEY 0x3E77
+#define BP_POWER_RESET_RSRVD1	3
+#define BM_POWER_RESET_RSRVD1	0x0000FFF8
+#define BF_POWER_RESET_RSRVD1(v)  \
+		(((v) << 3) & BM_POWER_RESET_RSRVD1)
+#define BM_POWER_RESET_FASTFALLPSWITCH_OFF	0x00000004
+#define BM_POWER_RESET_PWD_OFF	0x00000002
+#define BM_POWER_RESET_PWD	0x00000001
+
+#define HW_POWER_DEBUG	(0x00000110)
+#define HW_POWER_DEBUG_SET	(0x00000114)
+#define HW_POWER_DEBUG_CLR	(0x00000118)
+#define HW_POWER_DEBUG_TOG	(0x0000011c)
+
+#define BP_POWER_DEBUG_RSRVD0	4
+#define BM_POWER_DEBUG_RSRVD0	0xFFFFFFF0
+#define BF_POWER_DEBUG_RSRVD0(v) \
+		(((v) << 4) & BM_POWER_DEBUG_RSRVD0)
+#define BM_POWER_DEBUG_VBUSVALIDPIOLOCK	0x00000008
+#define BM_POWER_DEBUG_AVALIDPIOLOCK	0x00000004
+#define BM_POWER_DEBUG_BVALIDPIOLOCK	0x00000002
+#define BM_POWER_DEBUG_SESSENDPIOLOCK	0x00000001
+
+#define HW_POWER_THERMAL	(0x00000120)
+#define HW_POWER_THERMAL_SET	(0x00000124)
+#define HW_POWER_THERMAL_CLR	(0x00000128)
+#define HW_POWER_THERMAL_TOG	(0x0000012c)
+
+#define BP_POWER_THERMAL_RSRVD0	9
+#define BM_POWER_THERMAL_RSRVD0	0xFFFFFE00
+#define BF_POWER_THERMAL_RSRVD0(v) \
+		(((v) << 9) & BM_POWER_THERMAL_RSRVD0)
+#define BM_POWER_THERMAL_TEST	0x00000100
+#define BM_POWER_THERMAL_PWD	0x00000080
+#define BM_POWER_THERMAL_LOW_POWER	0x00000040
+#define BP_POWER_THERMAL_OFFSET_ADJ	4
+#define BM_POWER_THERMAL_OFFSET_ADJ	0x00000030
+#define BF_POWER_THERMAL_OFFSET_ADJ(v)  \
+		(((v) << 4) & BM_POWER_THERMAL_OFFSET_ADJ)
+#define BM_POWER_THERMAL_OFFSET_ADJ_ENABLE	0x00000008
+#define BP_POWER_THERMAL_TEMP_THRESHOLD	0
+#define BM_POWER_THERMAL_TEMP_THRESHOLD	0x00000007
+#define BF_POWER_THERMAL_TEMP_THRESHOLD(v)  \
+		(((v) << 0) & BM_POWER_THERMAL_TEMP_THRESHOLD)
+
+#define HW_POWER_USB1CTRL	(0x00000130)
+#define HW_POWER_USB1CTRL_SET	(0x00000134)
+#define HW_POWER_USB1CTRL_CLR	(0x00000138)
+#define HW_POWER_USB1CTRL_TOG	(0x0000013c)
+
+#define BP_POWER_USB1CTRL_RSRVD0	4
+#define BM_POWER_USB1CTRL_RSRVD0	0xFFFFFFF0
+#define BF_POWER_USB1CTRL_RSRVD0(v) \
+		(((v) << 4) & BM_POWER_USB1CTRL_RSRVD0)
+#define BM_POWER_USB1CTRL_AVALID1	0x00000008
+#define BM_POWER_USB1CTRL_BVALID1	0x00000004
+#define BM_POWER_USB1CTRL_VBUSVALID1	0x00000002
+#define BM_POWER_USB1CTRL_SESSEND1	0x00000001
+
+#define HW_POWER_SPECIAL	(0x00000140)
+#define HW_POWER_SPECIAL_SET	(0x00000144)
+#define HW_POWER_SPECIAL_CLR	(0x00000148)
+#define HW_POWER_SPECIAL_TOG	(0x0000014c)
+
+#define BP_POWER_SPECIAL_TEST	0
+#define BM_POWER_SPECIAL_TEST	0xFFFFFFFF
+#define BF_POWER_SPECIAL_TEST(v)	(v)
+
+#define HW_POWER_VERSION	(0x00000150)
+
+#define BP_POWER_VERSION_MAJOR	24
+#define BM_POWER_VERSION_MAJOR	0xFF000000
+#define BF_POWER_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_POWER_VERSION_MAJOR)
+#define BP_POWER_VERSION_MINOR	16
+#define BM_POWER_VERSION_MINOR	0x00FF0000
+#define BF_POWER_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_POWER_VERSION_MINOR)
+#define BP_POWER_VERSION_STEP	0
+#define BM_POWER_VERSION_STEP	0x0000FFFF
+#define BF_POWER_VERSION_STEP(v)  \
+		(((v) << 0) & BM_POWER_VERSION_STEP)
+
+#define HW_POWER_ANACLKCTRL	(0x00000160)
+#define HW_POWER_ANACLKCTRL_SET	(0x00000164)
+#define HW_POWER_ANACLKCTRL_CLR	(0x00000168)
+#define HW_POWER_ANACLKCTRL_TOG	(0x0000016c)
+
+#define BM_POWER_ANACLKCTRL_CKGATE_O	0x80000000
+#define BP_POWER_ANACLKCTRL_OUTDIV	28
+#define BM_POWER_ANACLKCTRL_OUTDIV	0x70000000
+#define BF_POWER_ANACLKCTRL_OUTDIV(v)  \
+		(((v) << 28) & BM_POWER_ANACLKCTRL_OUTDIV)
+#define BM_POWER_ANACLKCTRL_INVERT_OUTCLK	0x08000000
+#define BM_POWER_ANACLKCTRL_CKGATE_I	0x04000000
+#define BP_POWER_ANACLKCTRL_RSRVD4	11
+#define BM_POWER_ANACLKCTRL_RSRVD4	0x03FFF800
+#define BF_POWER_ANACLKCTRL_RSRVD4(v)  \
+		(((v) << 11) & BM_POWER_ANACLKCTRL_RSRVD4)
+#define BM_POWER_ANACLKCTRL_DITHER_OFF	0x00000400
+#define BM_POWER_ANACLKCTRL_SLOW_DITHER	0x00000200
+#define BM_POWER_ANACLKCTRL_INVERT_INCLK	0x00000100
+#define BP_POWER_ANACLKCTRL_RSRVD3	6
+#define BM_POWER_ANACLKCTRL_RSRVD3	0x000000C0
+#define BF_POWER_ANACLKCTRL_RSRVD3(v)  \
+		(((v) << 6) & BM_POWER_ANACLKCTRL_RSRVD3)
+#define BP_POWER_ANACLKCTRL_INCLK_SHIFT	4
+#define BM_POWER_ANACLKCTRL_INCLK_SHIFT	0x00000030
+#define BF_POWER_ANACLKCTRL_INCLK_SHIFT(v)  \
+		(((v) << 4) & BM_POWER_ANACLKCTRL_INCLK_SHIFT)
+#define BM_POWER_ANACLKCTRL_RSRVD2	0x00000008
+#define BP_POWER_ANACLKCTRL_INDIV	0
+#define BM_POWER_ANACLKCTRL_INDIV	0x00000007
+#define BF_POWER_ANACLKCTRL_INDIV(v)  \
+		(((v) << 0) & BM_POWER_ANACLKCTRL_INDIV)
+
+#define HW_POWER_REFCTRL	(0x00000170)
+#define HW_POWER_REFCTRL_SET	(0x00000174)
+#define HW_POWER_REFCTRL_CLR	(0x00000178)
+#define HW_POWER_REFCTRL_TOG	(0x0000017c)
+
+#define BP_POWER_REFCTRL_RSRVD5	27
+#define BM_POWER_REFCTRL_RSRVD5	0xF8000000
+#define BF_POWER_REFCTRL_RSRVD5(v) \
+		(((v) << 27) & BM_POWER_REFCTRL_RSRVD5)
+#define BM_POWER_REFCTRL_FASTSETTLING	0x04000000
+#define BM_POWER_REFCTRL_RAISE_REF	0x02000000
+#define BM_POWER_REFCTRL_XTAL_BGR_BIAS	0x01000000
+#define BM_POWER_REFCTRL_RSRVD4	0x00800000
+#define BP_POWER_REFCTRL_VBG_ADJ	20
+#define BM_POWER_REFCTRL_VBG_ADJ	0x00700000
+#define BF_POWER_REFCTRL_VBG_ADJ(v)  \
+		(((v) << 20) & BM_POWER_REFCTRL_VBG_ADJ)
+#define BM_POWER_REFCTRL_LOW_PWR	0x00080000
+#define BM_POWER_REFCTRL_RSRVD3	0x00040000
+#define BP_POWER_REFCTRL_BIAS_CTRL	16
+#define BM_POWER_REFCTRL_BIAS_CTRL	0x00030000
+#define BF_POWER_REFCTRL_BIAS_CTRL(v)  \
+		(((v) << 16) & BM_POWER_REFCTRL_BIAS_CTRL)
+#define BM_POWER_REFCTRL_RSRVD2	0x00008000
+#define BM_POWER_REFCTRL_VDDXTAL_TO_VDDD	0x00004000
+#define BM_POWER_REFCTRL_ADJ_ANA	0x00002000
+#define BM_POWER_REFCTRL_ADJ_VAG	0x00001000
+#define BP_POWER_REFCTRL_ANA_REFVAL	8
+#define BM_POWER_REFCTRL_ANA_REFVAL	0x00000F00
+#define BF_POWER_REFCTRL_ANA_REFVAL(v)  \
+		(((v) << 8) & BM_POWER_REFCTRL_ANA_REFVAL)
+#define BP_POWER_REFCTRL_VAG_VAL	4
+#define BM_POWER_REFCTRL_VAG_VAL	0x000000F0
+#define BF_POWER_REFCTRL_VAG_VAL(v)  \
+		(((v) << 4) & BM_POWER_REFCTRL_VAG_VAL)
+#define BP_POWER_REFCTRL_RSRVD1	0
+#define BM_POWER_REFCTRL_RSRVD1	0x0000000F
+#define BF_POWER_REFCTRL_RSRVD1(v)  \
+		(((v) << 0) & BM_POWER_REFCTRL_RSRVD1)
+#endif /* __ARCH_ARM___POWER_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-pwm.h b/arch/arm/mach-mx28/include/mach/regs-pwm.h
new file mode 100644
index 0000000..ac0ebfb
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-pwm.h
@@ -0,0 +1,147 @@
+/*
+ * Freescale PWM Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.30
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PWM_H
+#define __ARCH_ARM___PWM_H
+
+#include <mach/mx28.h>
+
+#define REGS_PWM_BASE IO_ADDRESS(PWM_PHYS_ADDR)
+#define REGS_PWM_PHYS (0x80064000)
+#define REGS_PWM_SIZE 0x00002000
+
+#define HW_PWM_CTRL	(0x00000000)
+#define HW_PWM_CTRL_SET	(0x00000004)
+#define HW_PWM_CTRL_CLR	(0x00000008)
+#define HW_PWM_CTRL_TOG	(0x0000000c)
+
+#define BM_PWM_CTRL_SFTRST	0x80000000
+#define BM_PWM_CTRL_CLKGATE	0x40000000
+#define BM_PWM_CTRL_PWM7_PRESENT	0x20000000
+#define BM_PWM_CTRL_PWM6_PRESENT	0x10000000
+#define BM_PWM_CTRL_PWM5_PRESENT	0x08000000
+#define BM_PWM_CTRL_PWM4_PRESENT	0x04000000
+#define BM_PWM_CTRL_PWM3_PRESENT	0x02000000
+#define BM_PWM_CTRL_PWM2_PRESENT	0x01000000
+#define BM_PWM_CTRL_PWM1_PRESENT	0x00800000
+#define BM_PWM_CTRL_PWM0_PRESENT	0x00400000
+#define BP_PWM_CTRL_RSRVD1	10
+#define BM_PWM_CTRL_RSRVD1	0x003FFC00
+#define BF_PWM_CTRL_RSRVD1(v)  \
+		(((v) << 10) & BM_PWM_CTRL_RSRVD1)
+#define BM_PWM_CTRL_OUTPUT_CUTOFF_EN	0x00000200
+#define BM_PWM_CTRL_RSRVD2	0x00000100
+#define BM_PWM_CTRL_PWM7_ENABLE	0x00000080
+#define BM_PWM_CTRL_PWM6_ENABLE	0x00000040
+#define BM_PWM_CTRL_PWM5_ENABLE	0x00000020
+#define BM_PWM_CTRL_PWM4_ENABLE	0x00000010
+#define BM_PWM_CTRL_PWM3_ENABLE	0x00000008
+#define BM_PWM_CTRL_PWM2_ENABLE	0x00000004
+#define BM_PWM_CTRL_PWM1_ENABLE	0x00000002
+#define BM_PWM_CTRL_PWM0_ENABLE	0x00000001
+
+/*
+ *  multi-register-define name HW_PWM_ACTIVEn
+ *              base 0x00000010
+ *              count 8
+ *              offset 0x20
+ */
+#define HW_PWM_ACTIVEn(n)	(0x00000010 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_SET(n)	(0x00000014 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_CLR(n)	(0x00000018 + (n) * 0x20)
+#define HW_PWM_ACTIVEn_TOG(n)	(0x0000001c + (n) * 0x20)
+#define BP_PWM_ACTIVEn_INACTIVE	16
+#define BM_PWM_ACTIVEn_INACTIVE	0xFFFF0000
+#define BF_PWM_ACTIVEn_INACTIVE(v) \
+		(((v) << 16) & BM_PWM_ACTIVEn_INACTIVE)
+#define BP_PWM_ACTIVEn_ACTIVE	0
+#define BM_PWM_ACTIVEn_ACTIVE	0x0000FFFF
+#define BF_PWM_ACTIVEn_ACTIVE(v)  \
+		(((v) << 0) & BM_PWM_ACTIVEn_ACTIVE)
+
+/*
+ *  multi-register-define name HW_PWM_PERIODn
+ *              base 0x00000020
+ *              count 8
+ *              offset 0x20
+ */
+#define HW_PWM_PERIODn(n)	(0x00000020 + (n) * 0x20)
+#define HW_PWM_PERIODn_SET(n)	(0x00000024 + (n) * 0x20)
+#define HW_PWM_PERIODn_CLR(n)	(0x00000028 + (n) * 0x20)
+#define HW_PWM_PERIODn_TOG(n)	(0x0000002c + (n) * 0x20)
+#define BP_PWM_PERIODn_RSRVD2	27
+#define BM_PWM_PERIODn_RSRVD2	0xF8000000
+#define BF_PWM_PERIODn_RSRVD2(v) \
+		(((v) << 27) & BM_PWM_PERIODn_RSRVD2)
+#define BM_PWM_PERIODn_HSADC_OUT	0x04000000
+#define BM_PWM_PERIODn_HSADC_CLK_SEL	0x02000000
+#define BM_PWM_PERIODn_MATT_SEL	0x01000000
+#define BM_PWM_PERIODn_MATT	0x00800000
+#define BP_PWM_PERIODn_CDIV	20
+#define BM_PWM_PERIODn_CDIV	0x00700000
+#define BF_PWM_PERIODn_CDIV(v)  \
+		(((v) << 20) & BM_PWM_PERIODn_CDIV)
+#define BV_PWM_PERIODn_CDIV__DIV_1    0x0
+#define BV_PWM_PERIODn_CDIV__DIV_2    0x1
+#define BV_PWM_PERIODn_CDIV__DIV_4    0x2
+#define BV_PWM_PERIODn_CDIV__DIV_8    0x3
+#define BV_PWM_PERIODn_CDIV__DIV_16   0x4
+#define BV_PWM_PERIODn_CDIV__DIV_64   0x5
+#define BV_PWM_PERIODn_CDIV__DIV_256  0x6
+#define BV_PWM_PERIODn_CDIV__DIV_1024 0x7
+#define BP_PWM_PERIODn_INACTIVE_STATE	18
+#define BM_PWM_PERIODn_INACTIVE_STATE	0x000C0000
+#define BF_PWM_PERIODn_INACTIVE_STATE(v)  \
+		(((v) << 18) & BM_PWM_PERIODn_INACTIVE_STATE)
+#define BV_PWM_PERIODn_INACTIVE_STATE__HI_Z 0x0
+#define BV_PWM_PERIODn_INACTIVE_STATE__0    0x2
+#define BV_PWM_PERIODn_INACTIVE_STATE__1    0x3
+#define BP_PWM_PERIODn_ACTIVE_STATE	16
+#define BM_PWM_PERIODn_ACTIVE_STATE	0x00030000
+#define BF_PWM_PERIODn_ACTIVE_STATE(v)  \
+		(((v) << 16) & BM_PWM_PERIODn_ACTIVE_STATE)
+#define BV_PWM_PERIODn_ACTIVE_STATE__HI_Z 0x0
+#define BV_PWM_PERIODn_ACTIVE_STATE__0    0x2
+#define BV_PWM_PERIODn_ACTIVE_STATE__1    0x3
+#define BP_PWM_PERIODn_PERIOD	0
+#define BM_PWM_PERIODn_PERIOD	0x0000FFFF
+#define BF_PWM_PERIODn_PERIOD(v)  \
+		(((v) << 0) & BM_PWM_PERIODn_PERIOD)
+
+#define HW_PWM_VERSION	(0x00000110)
+
+#define BP_PWM_VERSION_MAJOR	24
+#define BM_PWM_VERSION_MAJOR	0xFF000000
+#define BF_PWM_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_PWM_VERSION_MAJOR)
+#define BP_PWM_VERSION_MINOR	16
+#define BM_PWM_VERSION_MINOR	0x00FF0000
+#define BF_PWM_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_PWM_VERSION_MINOR)
+#define BP_PWM_VERSION_STEP	0
+#define BM_PWM_VERSION_STEP	0x0000FFFF
+#define BF_PWM_VERSION_STEP(v)  \
+		(((v) << 0) & BM_PWM_VERSION_STEP)
+#endif /* __ARCH_ARM___PWM_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-pxp.h b/arch/arm/mach-mx28/include/mach/regs-pxp.h
new file mode 100644
index 0000000..2feb8f8
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-pxp.h
@@ -0,0 +1,518 @@
+/*
+ * Freescale PXP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.57
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PXP_H
+#define __ARCH_ARM___PXP_H
+
+
+#define HW_PXP_CTRL	(0x00000000)
+#define HW_PXP_CTRL_SET	(0x00000004)
+#define HW_PXP_CTRL_CLR	(0x00000008)
+#define HW_PXP_CTRL_TOG	(0x0000000c)
+
+#define BM_PXP_CTRL_SFTRST	0x80000000
+#define BM_PXP_CTRL_CLKGATE	0x40000000
+#define BP_PXP_CTRL_RSVD2	28
+#define BM_PXP_CTRL_RSVD2	0x30000000
+#define BF_PXP_CTRL_RSVD2(v)  \
+		(((v) << 28) & BM_PXP_CTRL_RSVD2)
+#define BP_PXP_CTRL_INTERLACED_OUTPUT	26
+#define BM_PXP_CTRL_INTERLACED_OUTPUT	0x0C000000
+#define BF_PXP_CTRL_INTERLACED_OUTPUT(v)  \
+		(((v) << 26) & BM_PXP_CTRL_INTERLACED_OUTPUT)
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD0      0x1
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__FIELD1      0x2
+#define BV_PXP_CTRL_INTERLACED_OUTPUT__INTERLACED  0x3
+#define BP_PXP_CTRL_INTERLACED_INPUT	24
+#define BM_PXP_CTRL_INTERLACED_INPUT	0x03000000
+#define BF_PXP_CTRL_INTERLACED_INPUT(v)  \
+		(((v) << 24) & BM_PXP_CTRL_INTERLACED_INPUT)
+#define BV_PXP_CTRL_INTERLACED_INPUT__PROGRESSIVE 0x0
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD0      0x2
+#define BV_PXP_CTRL_INTERLACED_INPUT__FIELD1      0x3
+#define BM_PXP_CTRL_BLOCK_SIZE	0x00800000
+#define BV_PXP_CTRL_BLOCK_SIZE__8X8   0x0
+#define BV_PXP_CTRL_BLOCK_SIZE__16X16 0x1
+#define BM_PXP_CTRL_ALPHA_OUTPUT	0x00400000
+#define BM_PXP_CTRL_IN_PLACE	0x00200000
+#define BM_PXP_CTRL_DELTA	0x00100000
+#define BM_PXP_CTRL_CROP	0x00080000
+#define BM_PXP_CTRL_SCALE	0x00040000
+#define BM_PXP_CTRL_UPSAMPLE	0x00020000
+#define BM_PXP_CTRL_SUBSAMPLE	0x00010000
+#define BP_PXP_CTRL_S0_FORMAT	12
+#define BM_PXP_CTRL_S0_FORMAT	0x0000F000
+#define BF_PXP_CTRL_S0_FORMAT(v)  \
+		(((v) << 12) & BM_PXP_CTRL_S0_FORMAT)
+#define BV_PXP_CTRL_S0_FORMAT__ARGB8888  0x0
+#define BV_PXP_CTRL_S0_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_S0_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_S0_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_S0_FORMAT__YUV422    0x8
+#define BV_PXP_CTRL_S0_FORMAT__YUV420    0x9
+#define BV_PXP_CTRL_S0_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_S0_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_S0_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_S0_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_VFLIP	0x00000800
+#define BM_PXP_CTRL_HFLIP	0x00000400
+#define BP_PXP_CTRL_ROTATE	8
+#define BM_PXP_CTRL_ROTATE	0x00000300
+#define BF_PXP_CTRL_ROTATE(v)  \
+		(((v) << 8) & BM_PXP_CTRL_ROTATE)
+#define BV_PXP_CTRL_ROTATE__ROT_0   0x0
+#define BV_PXP_CTRL_ROTATE__ROT_90  0x1
+#define BV_PXP_CTRL_ROTATE__ROT_180 0x2
+#define BV_PXP_CTRL_ROTATE__ROT_270 0x3
+#define BP_PXP_CTRL_OUTBUF_FORMAT	4
+#define BM_PXP_CTRL_OUTBUF_FORMAT	0x000000F0
+#define BF_PXP_CTRL_OUTBUF_FORMAT(v)  \
+		(((v) << 4) & BM_PXP_CTRL_OUTBUF_FORMAT)
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB8888  0x0
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888    0x1
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB888P   0x2
+#define BV_PXP_CTRL_OUTBUF_FORMAT__ARGB1555  0x3
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB565    0x4
+#define BV_PXP_CTRL_OUTBUF_FORMAT__RGB555    0x5
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV444    0x7
+#define BV_PXP_CTRL_OUTBUF_FORMAT__UYVY1P422 0xA
+#define BV_PXP_CTRL_OUTBUF_FORMAT__VYUY1P422 0xB
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P422  0xC
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YUV2P420  0xD
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P422  0xE
+#define BV_PXP_CTRL_OUTBUF_FORMAT__YVU2P420  0xF
+#define BM_PXP_CTRL_ENABLE_LCD_HANDSHAKE	0x00000008
+#define BM_PXP_CTRL_NEXT_IRQ_ENABLE	0x00000004
+#define BM_PXP_CTRL_IRQ_ENABLE	0x00000002
+#define BM_PXP_CTRL_ENABLE	0x00000001
+
+#define HW_PXP_STAT	(0x00000010)
+#define HW_PXP_STAT_SET	(0x00000014)
+#define HW_PXP_STAT_CLR	(0x00000018)
+#define HW_PXP_STAT_TOG	(0x0000001c)
+
+#define BP_PXP_STAT_BLOCKX	24
+#define BM_PXP_STAT_BLOCKX	0xFF000000
+#define BF_PXP_STAT_BLOCKX(v) \
+		(((v) << 24) & BM_PXP_STAT_BLOCKX)
+#define BP_PXP_STAT_BLOCKY	16
+#define BM_PXP_STAT_BLOCKY	0x00FF0000
+#define BF_PXP_STAT_BLOCKY(v)  \
+		(((v) << 16) & BM_PXP_STAT_BLOCKY)
+#define BP_PXP_STAT_RSVD2	8
+#define BM_PXP_STAT_RSVD2	0x0000FF00
+#define BF_PXP_STAT_RSVD2(v)  \
+		(((v) << 8) & BM_PXP_STAT_RSVD2)
+#define BP_PXP_STAT_AXI_ERROR_ID	4
+#define BM_PXP_STAT_AXI_ERROR_ID	0x000000F0
+#define BF_PXP_STAT_AXI_ERROR_ID(v)  \
+		(((v) << 4) & BM_PXP_STAT_AXI_ERROR_ID)
+#define BM_PXP_STAT_NEXT_IRQ	0x00000008
+#define BM_PXP_STAT_AXI_READ_ERROR	0x00000004
+#define BM_PXP_STAT_AXI_WRITE_ERROR	0x00000002
+#define BM_PXP_STAT_IRQ	0x00000001
+
+#define HW_PXP_OUTBUF	(0x00000020)
+
+#define BP_PXP_OUTBUF_ADDR	0
+#define BM_PXP_OUTBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_OUTBUF_ADDR(v)	(v)
+
+#define HW_PXP_OUTBUF2	(0x00000030)
+
+#define BP_PXP_OUTBUF2_ADDR	0
+#define BM_PXP_OUTBUF2_ADDR	0xFFFFFFFF
+#define BF_PXP_OUTBUF2_ADDR(v)	(v)
+
+#define HW_PXP_OUTSIZE	(0x00000040)
+
+#define BP_PXP_OUTSIZE_ALPHA	24
+#define BM_PXP_OUTSIZE_ALPHA	0xFF000000
+#define BF_PXP_OUTSIZE_ALPHA(v) \
+		(((v) << 24) & BM_PXP_OUTSIZE_ALPHA)
+#define BP_PXP_OUTSIZE_WIDTH	12
+#define BM_PXP_OUTSIZE_WIDTH	0x00FFF000
+#define BF_PXP_OUTSIZE_WIDTH(v)  \
+		(((v) << 12) & BM_PXP_OUTSIZE_WIDTH)
+#define BP_PXP_OUTSIZE_HEIGHT	0
+#define BM_PXP_OUTSIZE_HEIGHT	0x00000FFF
+#define BF_PXP_OUTSIZE_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_OUTSIZE_HEIGHT)
+
+#define HW_PXP_S0BUF	(0x00000050)
+
+#define BP_PXP_S0BUF_ADDR	0
+#define BM_PXP_S0BUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0BUF_ADDR(v)	(v)
+
+#define HW_PXP_S0UBUF	(0x00000060)
+
+#define BP_PXP_S0UBUF_ADDR	0
+#define BM_PXP_S0UBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0UBUF_ADDR(v)	(v)
+
+#define HW_PXP_S0VBUF	(0x00000070)
+
+#define BP_PXP_S0VBUF_ADDR	0
+#define BM_PXP_S0VBUF_ADDR	0xFFFFFFFF
+#define BF_PXP_S0VBUF_ADDR(v)	(v)
+
+#define HW_PXP_S0PARAM	(0x00000080)
+
+#define BP_PXP_S0PARAM_XBASE	24
+#define BM_PXP_S0PARAM_XBASE	0xFF000000
+#define BF_PXP_S0PARAM_XBASE(v) \
+		(((v) << 24) & BM_PXP_S0PARAM_XBASE)
+#define BP_PXP_S0PARAM_YBASE	16
+#define BM_PXP_S0PARAM_YBASE	0x00FF0000
+#define BF_PXP_S0PARAM_YBASE(v)  \
+		(((v) << 16) & BM_PXP_S0PARAM_YBASE)
+#define BP_PXP_S0PARAM_WIDTH	8
+#define BM_PXP_S0PARAM_WIDTH	0x0000FF00
+#define BF_PXP_S0PARAM_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_S0PARAM_WIDTH)
+#define BP_PXP_S0PARAM_HEIGHT	0
+#define BM_PXP_S0PARAM_HEIGHT	0x000000FF
+#define BF_PXP_S0PARAM_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_S0PARAM_HEIGHT)
+
+#define HW_PXP_S0BACKGROUND	(0x00000090)
+
+#define BP_PXP_S0BACKGROUND_COLOR	0
+#define BM_PXP_S0BACKGROUND_COLOR	0xFFFFFFFF
+#define BF_PXP_S0BACKGROUND_COLOR(v)	(v)
+
+#define HW_PXP_S0CROP	(0x000000a0)
+
+#define BP_PXP_S0CROP_XBASE	24
+#define BM_PXP_S0CROP_XBASE	0xFF000000
+#define BF_PXP_S0CROP_XBASE(v) \
+		(((v) << 24) & BM_PXP_S0CROP_XBASE)
+#define BP_PXP_S0CROP_YBASE	16
+#define BM_PXP_S0CROP_YBASE	0x00FF0000
+#define BF_PXP_S0CROP_YBASE(v)  \
+		(((v) << 16) & BM_PXP_S0CROP_YBASE)
+#define BP_PXP_S0CROP_WIDTH	8
+#define BM_PXP_S0CROP_WIDTH	0x0000FF00
+#define BF_PXP_S0CROP_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_S0CROP_WIDTH)
+#define BP_PXP_S0CROP_HEIGHT	0
+#define BM_PXP_S0CROP_HEIGHT	0x000000FF
+#define BF_PXP_S0CROP_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_S0CROP_HEIGHT)
+
+#define HW_PXP_S0SCALE	(0x000000b0)
+
+#define BM_PXP_S0SCALE_RSVD2	0x80000000
+#define BP_PXP_S0SCALE_YSCALE	16
+#define BM_PXP_S0SCALE_YSCALE	0x7FFF0000
+#define BF_PXP_S0SCALE_YSCALE(v)  \
+		(((v) << 16) & BM_PXP_S0SCALE_YSCALE)
+#define BM_PXP_S0SCALE_RSVD1	0x00008000
+#define BP_PXP_S0SCALE_XSCALE	0
+#define BM_PXP_S0SCALE_XSCALE	0x00007FFF
+#define BF_PXP_S0SCALE_XSCALE(v)  \
+		(((v) << 0) & BM_PXP_S0SCALE_XSCALE)
+
+#define HW_PXP_S0OFFSET	(0x000000c0)
+
+#define BP_PXP_S0OFFSET_RSVD2	28
+#define BM_PXP_S0OFFSET_RSVD2	0xF0000000
+#define BF_PXP_S0OFFSET_RSVD2(v) \
+		(((v) << 28) & BM_PXP_S0OFFSET_RSVD2)
+#define BP_PXP_S0OFFSET_YOFFSET	16
+#define BM_PXP_S0OFFSET_YOFFSET	0x0FFF0000
+#define BF_PXP_S0OFFSET_YOFFSET(v)  \
+		(((v) << 16) & BM_PXP_S0OFFSET_YOFFSET)
+#define BP_PXP_S0OFFSET_RSVD1	12
+#define BM_PXP_S0OFFSET_RSVD1	0x0000F000
+#define BF_PXP_S0OFFSET_RSVD1(v)  \
+		(((v) << 12) & BM_PXP_S0OFFSET_RSVD1)
+#define BP_PXP_S0OFFSET_XOFFSET	0
+#define BM_PXP_S0OFFSET_XOFFSET	0x00000FFF
+#define BF_PXP_S0OFFSET_XOFFSET(v)  \
+		(((v) << 0) & BM_PXP_S0OFFSET_XOFFSET)
+
+#define HW_PXP_CSCCOEFF0	(0x000000d0)
+
+#define BM_PXP_CSCCOEFF0_YCBCR_MODE	0x80000000
+#define BP_PXP_CSCCOEFF0_RSVD1	29
+#define BM_PXP_CSCCOEFF0_RSVD1	0x60000000
+#define BF_PXP_CSCCOEFF0_RSVD1(v)  \
+		(((v) << 29) & BM_PXP_CSCCOEFF0_RSVD1)
+#define BP_PXP_CSCCOEFF0_C0	18
+#define BM_PXP_CSCCOEFF0_C0	0x1FFC0000
+#define BF_PXP_CSCCOEFF0_C0(v)  \
+		(((v) << 18) & BM_PXP_CSCCOEFF0_C0)
+#define BP_PXP_CSCCOEFF0_UV_OFFSET	9
+#define BM_PXP_CSCCOEFF0_UV_OFFSET	0x0003FE00
+#define BF_PXP_CSCCOEFF0_UV_OFFSET(v)  \
+		(((v) << 9) & BM_PXP_CSCCOEFF0_UV_OFFSET)
+#define BP_PXP_CSCCOEFF0_Y_OFFSET	0
+#define BM_PXP_CSCCOEFF0_Y_OFFSET	0x000001FF
+#define BF_PXP_CSCCOEFF0_Y_OFFSET(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF0_Y_OFFSET)
+
+#define HW_PXP_CSCCOEFF1	(0x000000e0)
+
+#define BP_PXP_CSCCOEFF1_RSVD1	27
+#define BM_PXP_CSCCOEFF1_RSVD1	0xF8000000
+#define BF_PXP_CSCCOEFF1_RSVD1(v) \
+		(((v) << 27) & BM_PXP_CSCCOEFF1_RSVD1)
+#define BP_PXP_CSCCOEFF1_C1	16
+#define BM_PXP_CSCCOEFF1_C1	0x07FF0000
+#define BF_PXP_CSCCOEFF1_C1(v)  \
+		(((v) << 16) & BM_PXP_CSCCOEFF1_C1)
+#define BP_PXP_CSCCOEFF1_RSVD0	11
+#define BM_PXP_CSCCOEFF1_RSVD0	0x0000F800
+#define BF_PXP_CSCCOEFF1_RSVD0(v)  \
+		(((v) << 11) & BM_PXP_CSCCOEFF1_RSVD0)
+#define BP_PXP_CSCCOEFF1_C4	0
+#define BM_PXP_CSCCOEFF1_C4	0x000007FF
+#define BF_PXP_CSCCOEFF1_C4(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF1_C4)
+
+#define HW_PXP_CSCCOEFF2	(0x000000f0)
+
+#define BP_PXP_CSCCOEFF2_RSVD1	27
+#define BM_PXP_CSCCOEFF2_RSVD1	0xF8000000
+#define BF_PXP_CSCCOEFF2_RSVD1(v) \
+		(((v) << 27) & BM_PXP_CSCCOEFF2_RSVD1)
+#define BP_PXP_CSCCOEFF2_C2	16
+#define BM_PXP_CSCCOEFF2_C2	0x07FF0000
+#define BF_PXP_CSCCOEFF2_C2(v)  \
+		(((v) << 16) & BM_PXP_CSCCOEFF2_C2)
+#define BP_PXP_CSCCOEFF2_RSVD0	11
+#define BM_PXP_CSCCOEFF2_RSVD0	0x0000F800
+#define BF_PXP_CSCCOEFF2_RSVD0(v)  \
+		(((v) << 11) & BM_PXP_CSCCOEFF2_RSVD0)
+#define BP_PXP_CSCCOEFF2_C3	0
+#define BM_PXP_CSCCOEFF2_C3	0x000007FF
+#define BF_PXP_CSCCOEFF2_C3(v)  \
+		(((v) << 0) & BM_PXP_CSCCOEFF2_C3)
+
+#define HW_PXP_NEXT	(0x00000100)
+#define HW_PXP_NEXT_SET	(0x00000104)
+#define HW_PXP_NEXT_CLR	(0x00000108)
+#define HW_PXP_NEXT_TOG	(0x0000010c)
+
+#define BP_PXP_NEXT_POINTER	2
+#define BM_PXP_NEXT_POINTER	0xFFFFFFFC
+#define BF_PXP_NEXT_POINTER(v) \
+		(((v) << 2) & BM_PXP_NEXT_POINTER)
+#define BM_PXP_NEXT_RSVD	0x00000002
+#define BM_PXP_NEXT_ENABLED	0x00000001
+
+#define HW_PXP_S0COLORKEYLOW	(0x00000180)
+
+#define BP_PXP_S0COLORKEYLOW_RSVD1	24
+#define BM_PXP_S0COLORKEYLOW_RSVD1	0xFF000000
+#define BF_PXP_S0COLORKEYLOW_RSVD1(v) \
+		(((v) << 24) & BM_PXP_S0COLORKEYLOW_RSVD1)
+#define BP_PXP_S0COLORKEYLOW_PIXEL	0
+#define BM_PXP_S0COLORKEYLOW_PIXEL	0x00FFFFFF
+#define BF_PXP_S0COLORKEYLOW_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_S0COLORKEYLOW_PIXEL)
+
+#define HW_PXP_S0COLORKEYHIGH	(0x00000190)
+
+#define BP_PXP_S0COLORKEYHIGH_RSVD1	24
+#define BM_PXP_S0COLORKEYHIGH_RSVD1	0xFF000000
+#define BF_PXP_S0COLORKEYHIGH_RSVD1(v) \
+		(((v) << 24) & BM_PXP_S0COLORKEYHIGH_RSVD1)
+#define BP_PXP_S0COLORKEYHIGH_PIXEL	0
+#define BM_PXP_S0COLORKEYHIGH_PIXEL	0x00FFFFFF
+#define BF_PXP_S0COLORKEYHIGH_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_S0COLORKEYHIGH_PIXEL)
+
+#define HW_PXP_OLCOLORKEYLOW	(0x000001a0)
+
+#define BP_PXP_OLCOLORKEYLOW_RSVD1	24
+#define BM_PXP_OLCOLORKEYLOW_RSVD1	0xFF000000
+#define BF_PXP_OLCOLORKEYLOW_RSVD1(v) \
+		(((v) << 24) & BM_PXP_OLCOLORKEYLOW_RSVD1)
+#define BP_PXP_OLCOLORKEYLOW_PIXEL	0
+#define BM_PXP_OLCOLORKEYLOW_PIXEL	0x00FFFFFF
+#define BF_PXP_OLCOLORKEYLOW_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_OLCOLORKEYLOW_PIXEL)
+
+#define HW_PXP_OLCOLORKEYHIGH	(0x000001b0)
+
+#define BP_PXP_OLCOLORKEYHIGH_RSVD1	24
+#define BM_PXP_OLCOLORKEYHIGH_RSVD1	0xFF000000
+#define BF_PXP_OLCOLORKEYHIGH_RSVD1(v) \
+		(((v) << 24) & BM_PXP_OLCOLORKEYHIGH_RSVD1)
+#define BP_PXP_OLCOLORKEYHIGH_PIXEL	0
+#define BM_PXP_OLCOLORKEYHIGH_PIXEL	0x00FFFFFF
+#define BF_PXP_OLCOLORKEYHIGH_PIXEL(v)  \
+		(((v) << 0) & BM_PXP_OLCOLORKEYHIGH_PIXEL)
+
+#define HW_PXP_DEBUGCTRL	(0x000001d0)
+
+#define BP_PXP_DEBUGCTRL_RSVD	9
+#define BM_PXP_DEBUGCTRL_RSVD	0xFFFFFE00
+#define BF_PXP_DEBUGCTRL_RSVD(v) \
+		(((v) << 9) & BM_PXP_DEBUGCTRL_RSVD)
+#define BM_PXP_DEBUGCTRL_RESET_TLB_STATS	0x00000100
+#define BP_PXP_DEBUGCTRL_SELECT	0
+#define BM_PXP_DEBUGCTRL_SELECT	0x000000FF
+#define BF_PXP_DEBUGCTRL_SELECT(v)  \
+		(((v) << 0) & BM_PXP_DEBUGCTRL_SELECT)
+#define BV_PXP_DEBUGCTRL_SELECT__NONE     0x0
+#define BV_PXP_DEBUGCTRL_SELECT__CTRL     0x1
+#define BV_PXP_DEBUGCTRL_SELECT__S0REGS   0x2
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAX    0x3
+#define BV_PXP_DEBUGCTRL_SELECT__S0BAY    0x4
+#define BV_PXP_DEBUGCTRL_SELECT__PXBUF    0x5
+#define BV_PXP_DEBUGCTRL_SELECT__ROTATION 0x6
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF0  0x7
+#define BV_PXP_DEBUGCTRL_SELECT__ROTBUF1  0x8
+#define BV_PXP_DEBUGCTRL_SELECT__TLBCOUNT 0xF0
+#define BV_PXP_DEBUGCTRL_SELECT__TLBHIT   0xF1
+#define BV_PXP_DEBUGCTRL_SELECT__TLBMISS  0xF2
+#define BV_PXP_DEBUGCTRL_SELECT__TLBLAT   0xF3
+#define BV_PXP_DEBUGCTRL_SELECT__TLBSTATE 0xF8
+
+#define HW_PXP_DEBUG	(0x000001e0)
+
+#define BP_PXP_DEBUG_DATA	0
+#define BM_PXP_DEBUG_DATA	0xFFFFFFFF
+#define BF_PXP_DEBUG_DATA(v)	(v)
+
+#define HW_PXP_VERSION	(0x000001f0)
+
+#define BP_PXP_VERSION_MAJOR	24
+#define BM_PXP_VERSION_MAJOR	0xFF000000
+#define BF_PXP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_PXP_VERSION_MAJOR)
+#define BP_PXP_VERSION_MINOR	16
+#define BM_PXP_VERSION_MINOR	0x00FF0000
+#define BF_PXP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_PXP_VERSION_MINOR)
+#define BP_PXP_VERSION_STEP	0
+#define BM_PXP_VERSION_STEP	0x0000FFFF
+#define BF_PXP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_PXP_VERSION_STEP)
+
+/*
+ *  multi-register-define name HW_PXP_OLn
+ *              base 0x00000200
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLn(n)	(0x00000200 + (n) * 0x40)
+#define BP_PXP_OLn_ADDR	0
+#define BM_PXP_OLn_ADDR	0xFFFFFFFF
+#define BF_PXP_OLn_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_PXP_OLnSIZE
+ *              base 0x00000210
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnSIZE(n)	(0x00000210 + (n) * 0x40)
+#define BP_PXP_OLnSIZE_XBASE	24
+#define BM_PXP_OLnSIZE_XBASE	0xFF000000
+#define BF_PXP_OLnSIZE_XBASE(v) \
+		(((v) << 24) & BM_PXP_OLnSIZE_XBASE)
+#define BP_PXP_OLnSIZE_YBASE	16
+#define BM_PXP_OLnSIZE_YBASE	0x00FF0000
+#define BF_PXP_OLnSIZE_YBASE(v)  \
+		(((v) << 16) & BM_PXP_OLnSIZE_YBASE)
+#define BP_PXP_OLnSIZE_WIDTH	8
+#define BM_PXP_OLnSIZE_WIDTH	0x0000FF00
+#define BF_PXP_OLnSIZE_WIDTH(v)  \
+		(((v) << 8) & BM_PXP_OLnSIZE_WIDTH)
+#define BP_PXP_OLnSIZE_HEIGHT	0
+#define BM_PXP_OLnSIZE_HEIGHT	0x000000FF
+#define BF_PXP_OLnSIZE_HEIGHT(v)  \
+		(((v) << 0) & BM_PXP_OLnSIZE_HEIGHT)
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM
+ *              base 0x00000220
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM(n)	(0x00000220 + (n) * 0x40)
+#define BP_PXP_OLnPARAM_RSVD1	20
+#define BM_PXP_OLnPARAM_RSVD1	0xFFF00000
+#define BF_PXP_OLnPARAM_RSVD1(v) \
+		(((v) << 20) & BM_PXP_OLnPARAM_RSVD1)
+#define BP_PXP_OLnPARAM_ROP	16
+#define BM_PXP_OLnPARAM_ROP	0x000F0000
+#define BF_PXP_OLnPARAM_ROP(v)  \
+		(((v) << 16) & BM_PXP_OLnPARAM_ROP)
+#define BV_PXP_OLnPARAM_ROP__MASKOL     0x0
+#define BV_PXP_OLnPARAM_ROP__MASKNOTOL  0x1
+#define BV_PXP_OLnPARAM_ROP__MASKOLNOT  0x2
+#define BV_PXP_OLnPARAM_ROP__MERGEOL    0x3
+#define BV_PXP_OLnPARAM_ROP__MERGENOTOL 0x4
+#define BV_PXP_OLnPARAM_ROP__MERGEOLNOT 0x5
+#define BV_PXP_OLnPARAM_ROP__NOTCOPYOL  0x6
+#define BV_PXP_OLnPARAM_ROP__NOT        0x7
+#define BV_PXP_OLnPARAM_ROP__NOTMASKOL  0x8
+#define BV_PXP_OLnPARAM_ROP__NOTMERGEOL 0x9
+#define BV_PXP_OLnPARAM_ROP__XOROL      0xA
+#define BV_PXP_OLnPARAM_ROP__NOTXOROL   0xB
+#define BP_PXP_OLnPARAM_ALPHA	8
+#define BM_PXP_OLnPARAM_ALPHA	0x0000FF00
+#define BF_PXP_OLnPARAM_ALPHA(v)  \
+		(((v) << 8) & BM_PXP_OLnPARAM_ALPHA)
+#define BP_PXP_OLnPARAM_FORMAT	4
+#define BM_PXP_OLnPARAM_FORMAT	0x000000F0
+#define BF_PXP_OLnPARAM_FORMAT(v)  \
+		(((v) << 4) & BM_PXP_OLnPARAM_FORMAT)
+#define BV_PXP_OLnPARAM_FORMAT__ARGB8888 0x0
+#define BV_PXP_OLnPARAM_FORMAT__RGB888   0x1
+#define BV_PXP_OLnPARAM_FORMAT__ARGB1555 0x3
+#define BV_PXP_OLnPARAM_FORMAT__RGB565   0x4
+#define BV_PXP_OLnPARAM_FORMAT__RGB555   0x5
+#define BM_PXP_OLnPARAM_ENABLE_COLORKEY	0x00000008
+#define BP_PXP_OLnPARAM_ALPHA_CNTL	1
+#define BM_PXP_OLnPARAM_ALPHA_CNTL	0x00000006
+#define BF_PXP_OLnPARAM_ALPHA_CNTL(v)  \
+		(((v) << 1) & BM_PXP_OLnPARAM_ALPHA_CNTL)
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Embedded 0x0
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Override 0x1
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__Multiply 0x2
+#define BV_PXP_OLnPARAM_ALPHA_CNTL__ROPs     0x3
+#define BM_PXP_OLnPARAM_ENABLE	0x00000001
+
+/*
+ *  multi-register-define name HW_PXP_OLnPARAM2
+ *              base 0x00000230
+ *              count 8
+ *              offset 0x40
+ */
+#define HW_PXP_OLnPARAM2(n)	(0x00000230 + (n) * 0x40)
+#define BP_PXP_OLnPARAM2_RSVD	0
+#define BM_PXP_OLnPARAM2_RSVD	0xFFFFFFFF
+#define BF_PXP_OLnPARAM2_RSVD(v)	(v)
+#endif /* __ARCH_ARM___PXP_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-rtc.h b/arch/arm/mach-mx28/include/mach/regs-rtc.h
new file mode 100644
index 0000000..bdb3ac2
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-rtc.h
@@ -0,0 +1,226 @@
+/*
+ * Freescale RTC Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.75
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___RTC_H
+#define __ARCH_ARM___RTC_H
+
+
+#define HW_RTC_CTRL	(0x00000000)
+#define HW_RTC_CTRL_SET	(0x00000004)
+#define HW_RTC_CTRL_CLR	(0x00000008)
+#define HW_RTC_CTRL_TOG	(0x0000000c)
+
+#define BM_RTC_CTRL_SFTRST	0x80000000
+#define BM_RTC_CTRL_CLKGATE	0x40000000
+#define BP_RTC_CTRL_RSVD0	7
+#define BM_RTC_CTRL_RSVD0	0x3FFFFF80
+#define BF_RTC_CTRL_RSVD0(v)  \
+		(((v) << 7) & BM_RTC_CTRL_RSVD0)
+#define BM_RTC_CTRL_SUPPRESS_COPY2ANALOG	0x00000040
+#define BM_RTC_CTRL_FORCE_UPDATE	0x00000020
+#define BM_RTC_CTRL_WATCHDOGEN	0x00000010
+#define BM_RTC_CTRL_ONEMSEC_IRQ	0x00000008
+#define BM_RTC_CTRL_ALARM_IRQ	0x00000004
+#define BM_RTC_CTRL_ONEMSEC_IRQ_EN	0x00000002
+#define BM_RTC_CTRL_ALARM_IRQ_EN	0x00000001
+
+#define HW_RTC_STAT	(0x00000010)
+#define HW_RTC_STAT_SET	(0x00000014)
+#define HW_RTC_STAT_CLR	(0x00000018)
+#define HW_RTC_STAT_TOG	(0x0000001c)
+
+#define BM_RTC_STAT_RTC_PRESENT	0x80000000
+#define BM_RTC_STAT_ALARM_PRESENT	0x40000000
+#define BM_RTC_STAT_WATCHDOG_PRESENT	0x20000000
+#define BM_RTC_STAT_XTAL32000_PRESENT	0x10000000
+#define BM_RTC_STAT_XTAL32768_PRESENT	0x08000000
+#define BP_RTC_STAT_RSVD1	24
+#define BM_RTC_STAT_RSVD1	0x07000000
+#define BF_RTC_STAT_RSVD1(v)  \
+		(((v) << 24) & BM_RTC_STAT_RSVD1)
+#define BP_RTC_STAT_STALE_REGS	16
+#define BM_RTC_STAT_STALE_REGS	0x00FF0000
+#define BF_RTC_STAT_STALE_REGS(v)  \
+		(((v) << 16) & BM_RTC_STAT_STALE_REGS)
+#define BP_RTC_STAT_NEW_REGS	8
+#define BM_RTC_STAT_NEW_REGS	0x0000FF00
+#define BF_RTC_STAT_NEW_REGS(v)  \
+		(((v) << 8) & BM_RTC_STAT_NEW_REGS)
+#define BP_RTC_STAT_RSVD0	0
+#define BM_RTC_STAT_RSVD0	0x000000FF
+#define BF_RTC_STAT_RSVD0(v)  \
+		(((v) << 0) & BM_RTC_STAT_RSVD0)
+
+#define HW_RTC_MILLISECONDS	(0x00000020)
+#define HW_RTC_MILLISECONDS_SET	(0x00000024)
+#define HW_RTC_MILLISECONDS_CLR	(0x00000028)
+#define HW_RTC_MILLISECONDS_TOG	(0x0000002c)
+
+#define BP_RTC_MILLISECONDS_COUNT	0
+#define BM_RTC_MILLISECONDS_COUNT	0xFFFFFFFF
+#define BF_RTC_MILLISECONDS_COUNT(v)	(v)
+
+#define HW_RTC_SECONDS	(0x00000030)
+#define HW_RTC_SECONDS_SET	(0x00000034)
+#define HW_RTC_SECONDS_CLR	(0x00000038)
+#define HW_RTC_SECONDS_TOG	(0x0000003c)
+
+#define BP_RTC_SECONDS_COUNT	0
+#define BM_RTC_SECONDS_COUNT	0xFFFFFFFF
+#define BF_RTC_SECONDS_COUNT(v)	(v)
+
+#define HW_RTC_ALARM	(0x00000040)
+#define HW_RTC_ALARM_SET	(0x00000044)
+#define HW_RTC_ALARM_CLR	(0x00000048)
+#define HW_RTC_ALARM_TOG	(0x0000004c)
+
+#define BP_RTC_ALARM_VALUE	0
+#define BM_RTC_ALARM_VALUE	0xFFFFFFFF
+#define BF_RTC_ALARM_VALUE(v)	(v)
+
+#define HW_RTC_WATCHDOG	(0x00000050)
+#define HW_RTC_WATCHDOG_SET	(0x00000054)
+#define HW_RTC_WATCHDOG_CLR	(0x00000058)
+#define HW_RTC_WATCHDOG_TOG	(0x0000005c)
+
+#define BP_RTC_WATCHDOG_COUNT	0
+#define BM_RTC_WATCHDOG_COUNT	0xFFFFFFFF
+#define BF_RTC_WATCHDOG_COUNT(v)	(v)
+
+#define HW_RTC_PERSISTENT0	(0x00000060)
+#define HW_RTC_PERSISTENT0_SET	(0x00000064)
+#define HW_RTC_PERSISTENT0_CLR	(0x00000068)
+#define HW_RTC_PERSISTENT0_TOG	(0x0000006c)
+
+#define BP_RTC_PERSISTENT0_ADJ_POSLIMITBUCK	28
+#define BM_RTC_PERSISTENT0_ADJ_POSLIMITBUCK	0xF0000000
+#define BF_RTC_PERSISTENT0_ADJ_POSLIMITBUCK(v) \
+		(((v) << 28) & BM_RTC_PERSISTENT0_ADJ_POSLIMITBUCK)
+#define BP_RTC_PERSISTENT0_SPARE_ANALOG	22
+#define BM_RTC_PERSISTENT0_SPARE_ANALOG	0x0FC00000
+#define BF_RTC_PERSISTENT0_SPARE_ANALOG(v)  \
+		(((v) << 22) & BM_RTC_PERSISTENT0_SPARE_ANALOG)
+#define BM_RTC_PERSISTENT0_EXTERNAL_RESET	0x00200000
+#define BM_RTC_PERSISTENT0_THERMAL_RESET	0x00100000
+#define BM_RTC_PERSISTENT0_RELEASE_GND	0x00080000
+#define BM_RTC_PERSISTENT0_ENABLE_LRADC_PWRUP	0x00040000
+#define BM_RTC_PERSISTENT0_AUTO_RESTART	0x00020000
+#define BM_RTC_PERSISTENT0_DISABLE_PSWITCH	0x00010000
+#define BP_RTC_PERSISTENT0_LOWERBIAS	14
+#define BM_RTC_PERSISTENT0_LOWERBIAS	0x0000C000
+#define BF_RTC_PERSISTENT0_LOWERBIAS(v)  \
+		(((v) << 14) & BM_RTC_PERSISTENT0_LOWERBIAS)
+#define BM_RTC_PERSISTENT0_DISABLE_XTALOK	0x00002000
+#define BP_RTC_PERSISTENT0_MSEC_RES	8
+#define BM_RTC_PERSISTENT0_MSEC_RES	0x00001F00
+#define BF_RTC_PERSISTENT0_MSEC_RES(v)  \
+		(((v) << 8) & BM_RTC_PERSISTENT0_MSEC_RES)
+#define BM_RTC_PERSISTENT0_ALARM_WAKE	0x00000080
+#define BM_RTC_PERSISTENT0_XTAL32_FREQ	0x00000040
+#define BM_RTC_PERSISTENT0_XTAL32KHZ_PWRUP	0x00000020
+#define BM_RTC_PERSISTENT0_XTAL24MHZ_PWRUP	0x00000010
+#define BM_RTC_PERSISTENT0_LCK_SECS	0x00000008
+#define BM_RTC_PERSISTENT0_ALARM_EN	0x00000004
+#define BM_RTC_PERSISTENT0_ALARM_WAKE_EN	0x00000002
+#define BM_RTC_PERSISTENT0_CLOCKSOURCE	0x00000001
+
+#define HW_RTC_PERSISTENT1	(0x00000070)
+#define HW_RTC_PERSISTENT1_SET	(0x00000074)
+#define HW_RTC_PERSISTENT1_CLR	(0x00000078)
+#define HW_RTC_PERSISTENT1_TOG	(0x0000007c)
+
+#define BP_RTC_PERSISTENT1_GENERAL	0
+#define BM_RTC_PERSISTENT1_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT1_GENERAL(v)	(v)
+#define BV_RTC_PERSISTENT1_GENERAL__ENUMERATE_500MA_TWICE 0x1000
+#define BV_RTC_PERSISTENT1_GENERAL__USB_BOOT_PLAYER_MODE  0x0800
+#define BV_RTC_PERSISTENT1_GENERAL__SKIP_CHECKDISK        0x0400
+#define BV_RTC_PERSISTENT1_GENERAL__USB_LOW_POWER_MODE    0x0200
+#define BV_RTC_PERSISTENT1_GENERAL__OTG_HNP_BIT           0x0100
+#define BV_RTC_PERSISTENT1_GENERAL__OTG_ATL_ROLE_BIT      0x0080
+
+#define HW_RTC_PERSISTENT2	(0x00000080)
+#define HW_RTC_PERSISTENT2_SET	(0x00000084)
+#define HW_RTC_PERSISTENT2_CLR	(0x00000088)
+#define HW_RTC_PERSISTENT2_TOG	(0x0000008c)
+
+#define BP_RTC_PERSISTENT2_GENERAL	0
+#define BM_RTC_PERSISTENT2_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT2_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT3	(0x00000090)
+#define HW_RTC_PERSISTENT3_SET	(0x00000094)
+#define HW_RTC_PERSISTENT3_CLR	(0x00000098)
+#define HW_RTC_PERSISTENT3_TOG	(0x0000009c)
+
+#define BP_RTC_PERSISTENT3_GENERAL	0
+#define BM_RTC_PERSISTENT3_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT3_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT4	(0x000000a0)
+#define HW_RTC_PERSISTENT4_SET	(0x000000a4)
+#define HW_RTC_PERSISTENT4_CLR	(0x000000a8)
+#define HW_RTC_PERSISTENT4_TOG	(0x000000ac)
+
+#define BP_RTC_PERSISTENT4_GENERAL	0
+#define BM_RTC_PERSISTENT4_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT4_GENERAL(v)	(v)
+
+#define HW_RTC_PERSISTENT5	(0x000000b0)
+#define HW_RTC_PERSISTENT5_SET	(0x000000b4)
+#define HW_RTC_PERSISTENT5_CLR	(0x000000b8)
+#define HW_RTC_PERSISTENT5_TOG	(0x000000bc)
+
+#define BP_RTC_PERSISTENT5_GENERAL	0
+#define BM_RTC_PERSISTENT5_GENERAL	0xFFFFFFFF
+#define BF_RTC_PERSISTENT5_GENERAL(v)	(v)
+
+#define HW_RTC_DEBUG	(0x000000c0)
+#define HW_RTC_DEBUG_SET	(0x000000c4)
+#define HW_RTC_DEBUG_CLR	(0x000000c8)
+#define HW_RTC_DEBUG_TOG	(0x000000cc)
+
+#define BP_RTC_DEBUG_RSVD0	2
+#define BM_RTC_DEBUG_RSVD0	0xFFFFFFFC
+#define BF_RTC_DEBUG_RSVD0(v) \
+		(((v) << 2) & BM_RTC_DEBUG_RSVD0)
+#define BM_RTC_DEBUG_WATCHDOG_RESET_MASK	0x00000002
+#define BM_RTC_DEBUG_WATCHDOG_RESET	0x00000001
+
+#define HW_RTC_VERSION	(0x000000d0)
+
+#define BP_RTC_VERSION_MAJOR	24
+#define BM_RTC_VERSION_MAJOR	0xFF000000
+#define BF_RTC_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_RTC_VERSION_MAJOR)
+#define BP_RTC_VERSION_MINOR	16
+#define BM_RTC_VERSION_MINOR	0x00FF0000
+#define BF_RTC_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_RTC_VERSION_MINOR)
+#define BP_RTC_VERSION_STEP	0
+#define BM_RTC_VERSION_STEP	0x0000FFFF
+#define BF_RTC_VERSION_STEP(v)  \
+		(((v) << 0) & BM_RTC_VERSION_STEP)
+#endif /* __ARCH_ARM___RTC_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-ssp.h b/arch/arm/mach-mx28/include/mach/regs-ssp.h
new file mode 100644
index 0000000..1d4793b
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-ssp.h
@@ -0,0 +1,474 @@
+/*
+ * Freescale SSP Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 4.0
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___SSP_H
+#define __ARCH_ARM___SSP_H
+
+#ifndef BF
+#define BF(value, field) (((value) << BP_##field) & BM_##field)
+#endif
+
+#define HW_SSP_CTRL0	(0x00000000)
+#define HW_SSP_CTRL0_SET	(0x00000004)
+#define HW_SSP_CTRL0_CLR	(0x00000008)
+#define HW_SSP_CTRL0_TOG	(0x0000000c)
+
+#define BM_SSP_CTRL0_SFTRST	0x80000000
+#define BM_SSP_CTRL0_CLKGATE	0x40000000
+#define BM_SSP_CTRL0_RUN	0x20000000
+#define BM_SSP_CTRL0_SDIO_IRQ_CHECK	0x10000000
+#define BM_SSP_CTRL0_LOCK_CS	0x08000000
+#define BM_SSP_CTRL0_IGNORE_CRC	0x04000000
+#define BM_SSP_CTRL0_READ	0x02000000
+#define BM_SSP_CTRL0_DATA_XFER	0x01000000
+#define BP_SSP_CTRL0_BUS_WIDTH	22
+#define BM_SSP_CTRL0_BUS_WIDTH	0x00C00000
+#define BF_SSP_CTRL0_BUS_WIDTH(v)  \
+		(((v) << 22) & BM_SSP_CTRL0_BUS_WIDTH)
+#define BV_SSP_CTRL0_BUS_WIDTH__ONE_BIT   0x0
+#define BV_SSP_CTRL0_BUS_WIDTH__FOUR_BIT  0x1
+#define BV_SSP_CTRL0_BUS_WIDTH__EIGHT_BIT 0x2
+#define BM_SSP_CTRL0_WAIT_FOR_IRQ	0x00200000
+#define BM_SSP_CTRL0_WAIT_FOR_CMD	0x00100000
+#define BM_SSP_CTRL0_LONG_RESP	0x00080000
+#define BM_SSP_CTRL0_CHECK_RESP	0x00040000
+#define BM_SSP_CTRL0_GET_RESP	0x00020000
+#define BM_SSP_CTRL0_ENABLE	0x00010000
+#define BP_SSP_CTRL0_RSVD0	0
+#define BM_SSP_CTRL0_RSVD0	0x0000FFFF
+#define BF_SSP_CTRL0_RSVD0(v)  \
+		(((v) << 0) & BM_SSP_CTRL0_RSVD0)
+
+#define HW_SSP_CMD0	(0x00000010)
+#define HW_SSP_CMD0_SET	(0x00000014)
+#define HW_SSP_CMD0_CLR	(0x00000018)
+#define HW_SSP_CMD0_TOG	(0x0000001c)
+
+#define BP_SSP_CMD0_RSVD0	27
+#define BM_SSP_CMD0_RSVD0	0xF8000000
+#define BF_SSP_CMD0_RSVD0(v) \
+		(((v) << 27) & BM_SSP_CMD0_RSVD0)
+#define BM_SSP_CMD0_SOFT_TERMINATE	0x04000000
+#define BM_SSP_CMD0_DBL_DATA_RATE_EN	0x02000000
+#define BM_SSP_CMD0_PRIM_BOOT_OP_EN	0x01000000
+#define BM_SSP_CMD0_BOOT_ACK_EN	0x00800000
+#define BM_SSP_CMD0_SLOW_CLKING_EN	0x00400000
+#define BM_SSP_CMD0_CONT_CLKING_EN	0x00200000
+#define BM_SSP_CMD0_APPEND_8CYC	0x00100000
+#define BP_SSP_CMD0_RSVD1	8
+#define BM_SSP_CMD0_RSVD1	0x000FFF00
+#define BF_SSP_CMD0_RSVD1(v)  \
+		(((v) << 8) & BM_SSP_CMD0_RSVD1)
+#define BP_SSP_CMD0_CMD	0
+#define BM_SSP_CMD0_CMD	0x000000FF
+#define BF_SSP_CMD0_CMD(v)  \
+		(((v) << 0) & BM_SSP_CMD0_CMD)
+#define BV_SSP_CMD0_CMD__MMC_GO_IDLE_STATE        0x00
+#define BV_SSP_CMD0_CMD__MMC_SEND_OP_COND         0x01
+#define BV_SSP_CMD0_CMD__MMC_ALL_SEND_CID         0x02
+#define BV_SSP_CMD0_CMD__MMC_SET_RELATIVE_ADDR    0x03
+#define BV_SSP_CMD0_CMD__MMC_SET_DSR              0x04
+#define BV_SSP_CMD0_CMD__MMC_RESERVED_5           0x05
+#define BV_SSP_CMD0_CMD__MMC_SWITCH               0x06
+#define BV_SSP_CMD0_CMD__MMC_SELECT_DESELECT_CARD 0x07
+#define BV_SSP_CMD0_CMD__MMC_SEND_EXT_CSD         0x08
+#define BV_SSP_CMD0_CMD__MMC_SEND_CSD             0x09
+#define BV_SSP_CMD0_CMD__MMC_SEND_CID             0x0A
+#define BV_SSP_CMD0_CMD__MMC_READ_DAT_UNTIL_STOP  0x0B
+#define BV_SSP_CMD0_CMD__MMC_STOP_TRANSMISSION    0x0C
+#define BV_SSP_CMD0_CMD__MMC_SEND_STATUS          0x0D
+#define BV_SSP_CMD0_CMD__MMC_BUSTEST_R            0x0E
+#define BV_SSP_CMD0_CMD__MMC_GO_INACTIVE_STATE    0x0F
+#define BV_SSP_CMD0_CMD__MMC_SET_BLOCKLEN         0x10
+#define BV_SSP_CMD0_CMD__MMC_READ_SINGLE_BLOCK    0x11
+#define BV_SSP_CMD0_CMD__MMC_READ_MULTIPLE_BLOCK  0x12
+#define BV_SSP_CMD0_CMD__MMC_BUSTEST_W            0x13
+#define BV_SSP_CMD0_CMD__MMC_WRITE_DAT_UNTIL_STOP 0x14
+#define BV_SSP_CMD0_CMD__MMC_SET_BLOCK_COUNT      0x17
+#define BV_SSP_CMD0_CMD__MMC_WRITE_BLOCK          0x18
+#define BV_SSP_CMD0_CMD__MMC_WRITE_MULTIPLE_BLOCK 0x19
+#define BV_SSP_CMD0_CMD__MMC_PROGRAM_CID          0x1A
+#define BV_SSP_CMD0_CMD__MMC_PROGRAM_CSD          0x1B
+#define BV_SSP_CMD0_CMD__MMC_SET_WRITE_PROT       0x1C
+#define BV_SSP_CMD0_CMD__MMC_CLR_WRITE_PROT       0x1D
+#define BV_SSP_CMD0_CMD__MMC_SEND_WRITE_PROT      0x1E
+#define BV_SSP_CMD0_CMD__MMC_ERASE_GROUP_START    0x23
+#define BV_SSP_CMD0_CMD__MMC_ERASE_GROUP_END      0x24
+#define BV_SSP_CMD0_CMD__MMC_ERASE                0x26
+#define BV_SSP_CMD0_CMD__MMC_FAST_IO              0x27
+#define BV_SSP_CMD0_CMD__MMC_GO_IRQ_STATE         0x28
+#define BV_SSP_CMD0_CMD__MMC_LOCK_UNLOCK          0x2A
+#define BV_SSP_CMD0_CMD__MMC_APP_CMD              0x37
+#define BV_SSP_CMD0_CMD__MMC_GEN_CMD              0x38
+#define BV_SSP_CMD0_CMD__SD_GO_IDLE_STATE         0x00
+#define BV_SSP_CMD0_CMD__SD_ALL_SEND_CID          0x02
+#define BV_SSP_CMD0_CMD__SD_SEND_RELATIVE_ADDR    0x03
+#define BV_SSP_CMD0_CMD__SD_SET_DSR               0x04
+#define BV_SSP_CMD0_CMD__SD_IO_SEND_OP_COND       0x05
+#define BV_SSP_CMD0_CMD__SD_SELECT_DESELECT_CARD  0x07
+#define BV_SSP_CMD0_CMD__SD_SEND_CSD              0x09
+#define BV_SSP_CMD0_CMD__SD_SEND_CID              0x0A
+#define BV_SSP_CMD0_CMD__SD_STOP_TRANSMISSION     0x0C
+#define BV_SSP_CMD0_CMD__SD_SEND_STATUS           0x0D
+#define BV_SSP_CMD0_CMD__SD_GO_INACTIVE_STATE     0x0F
+#define BV_SSP_CMD0_CMD__SD_SET_BLOCKLEN          0x10
+#define BV_SSP_CMD0_CMD__SD_READ_SINGLE_BLOCK     0x11
+#define BV_SSP_CMD0_CMD__SD_READ_MULTIPLE_BLOCK   0x12
+#define BV_SSP_CMD0_CMD__SD_WRITE_BLOCK           0x18
+#define BV_SSP_CMD0_CMD__SD_WRITE_MULTIPLE_BLOCK  0x19
+#define BV_SSP_CMD0_CMD__SD_PROGRAM_CSD           0x1B
+#define BV_SSP_CMD0_CMD__SD_SET_WRITE_PROT        0x1C
+#define BV_SSP_CMD0_CMD__SD_CLR_WRITE_PROT        0x1D
+#define BV_SSP_CMD0_CMD__SD_SEND_WRITE_PROT       0x1E
+#define BV_SSP_CMD0_CMD__SD_ERASE_WR_BLK_START    0x20
+#define BV_SSP_CMD0_CMD__SD_ERASE_WR_BLK_END      0x21
+#define BV_SSP_CMD0_CMD__SD_ERASE_GROUP_START     0x23
+#define BV_SSP_CMD0_CMD__SD_ERASE_GROUP_END       0x24
+#define BV_SSP_CMD0_CMD__SD_ERASE                 0x26
+#define BV_SSP_CMD0_CMD__SD_LOCK_UNLOCK           0x2A
+#define BV_SSP_CMD0_CMD__SD_IO_RW_DIRECT          0x34
+#define BV_SSP_CMD0_CMD__SD_IO_RW_EXTENDED        0x35
+#define BV_SSP_CMD0_CMD__SD_APP_CMD               0x37
+#define BV_SSP_CMD0_CMD__SD_GEN_CMD               0x38
+
+#define HW_SSP_CMD1	(0x00000020)
+
+#define BP_SSP_CMD1_CMD_ARG	0
+#define BM_SSP_CMD1_CMD_ARG	0xFFFFFFFF
+#define BF_SSP_CMD1_CMD_ARG(v)	(v)
+
+#define HW_SSP_XFER_SIZE	(0x00000030)
+
+#define BP_SSP_XFER_SIZE_XFER_COUNT	0
+#define BM_SSP_XFER_SIZE_XFER_COUNT	0xFFFFFFFF
+#define BF_SSP_XFER_SIZE_XFER_COUNT(v)	(v)
+
+#define HW_SSP_BLOCK_SIZE	(0x00000040)
+
+#define BP_SSP_BLOCK_SIZE_RSVD0	28
+#define BM_SSP_BLOCK_SIZE_RSVD0	0xF0000000
+#define BF_SSP_BLOCK_SIZE_RSVD0(v) \
+		(((v) << 28) & BM_SSP_BLOCK_SIZE_RSVD0)
+#define BP_SSP_BLOCK_SIZE_BLOCK_COUNT	4
+#define BM_SSP_BLOCK_SIZE_BLOCK_COUNT	0x0FFFFFF0
+#define BF_SSP_BLOCK_SIZE_BLOCK_COUNT(v)  \
+		(((v) << 4) & BM_SSP_BLOCK_SIZE_BLOCK_COUNT)
+#define BP_SSP_BLOCK_SIZE_BLOCK_SIZE	0
+#define BM_SSP_BLOCK_SIZE_BLOCK_SIZE	0x0000000F
+#define BF_SSP_BLOCK_SIZE_BLOCK_SIZE(v)  \
+		(((v) << 0) & BM_SSP_BLOCK_SIZE_BLOCK_SIZE)
+
+#define HW_SSP_COMPREF	(0x00000050)
+
+#define BP_SSP_COMPREF_REFERENCE	0
+#define BM_SSP_COMPREF_REFERENCE	0xFFFFFFFF
+#define BF_SSP_COMPREF_REFERENCE(v)	(v)
+
+#define HW_SSP_COMPMASK	(0x00000060)
+
+#define BP_SSP_COMPMASK_MASK	0
+#define BM_SSP_COMPMASK_MASK	0xFFFFFFFF
+#define BF_SSP_COMPMASK_MASK(v)	(v)
+
+#define HW_SSP_TIMING	(0x00000070)
+
+#define BP_SSP_TIMING_TIMEOUT	16
+#define BM_SSP_TIMING_TIMEOUT	0xFFFF0000
+#define BF_SSP_TIMING_TIMEOUT(v) \
+		(((v) << 16) & BM_SSP_TIMING_TIMEOUT)
+#define BP_SSP_TIMING_CLOCK_DIVIDE	8
+#define BM_SSP_TIMING_CLOCK_DIVIDE	0x0000FF00
+#define BF_SSP_TIMING_CLOCK_DIVIDE(v)  \
+		(((v) << 8) & BM_SSP_TIMING_CLOCK_DIVIDE)
+#define BP_SSP_TIMING_CLOCK_RATE	0
+#define BM_SSP_TIMING_CLOCK_RATE	0x000000FF
+#define BF_SSP_TIMING_CLOCK_RATE(v)  \
+		(((v) << 0) & BM_SSP_TIMING_CLOCK_RATE)
+
+#define HW_SSP_CTRL1	(0x00000080)
+#define HW_SSP_CTRL1_SET	(0x00000084)
+#define HW_SSP_CTRL1_CLR	(0x00000088)
+#define HW_SSP_CTRL1_TOG	(0x0000008c)
+
+#define BM_SSP_CTRL1_SDIO_IRQ	0x80000000
+#define BM_SSP_CTRL1_SDIO_IRQ_EN	0x40000000
+#define BM_SSP_CTRL1_RESP_ERR_IRQ	0x20000000
+#define BM_SSP_CTRL1_RESP_ERR_IRQ_EN	0x10000000
+#define BM_SSP_CTRL1_RESP_TIMEOUT_IRQ	0x08000000
+#define BM_SSP_CTRL1_RESP_TIMEOUT_IRQ_EN	0x04000000
+#define BM_SSP_CTRL1_DATA_TIMEOUT_IRQ	0x02000000
+#define BM_SSP_CTRL1_DATA_TIMEOUT_IRQ_EN	0x01000000
+#define BM_SSP_CTRL1_DATA_CRC_IRQ	0x00800000
+#define BM_SSP_CTRL1_DATA_CRC_IRQ_EN	0x00400000
+#define BM_SSP_CTRL1_FIFO_UNDERRUN_IRQ	0x00200000
+#define BM_SSP_CTRL1_FIFO_UNDERRUN_EN	0x00100000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_IRQ	0x00080000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_IRQ_EN	0x00040000
+#define BM_SSP_CTRL1_RECV_TIMEOUT_IRQ	0x00020000
+#define BM_SSP_CTRL1_RECV_TIMEOUT_IRQ_EN	0x00010000
+#define BM_SSP_CTRL1_FIFO_OVERRUN_IRQ	0x00008000
+#define BM_SSP_CTRL1_FIFO_OVERRUN_IRQ_EN	0x00004000
+#define BM_SSP_CTRL1_DMA_ENABLE	0x00002000
+#define BM_SSP_CTRL1_CEATA_CCS_ERR_EN	0x00001000
+#define BM_SSP_CTRL1_SLAVE_OUT_DISABLE	0x00000800
+#define BM_SSP_CTRL1_PHASE	0x00000400
+#define BM_SSP_CTRL1_POLARITY	0x00000200
+#define BM_SSP_CTRL1_SLAVE_MODE	0x00000100
+#define BP_SSP_CTRL1_WORD_LENGTH	4
+#define BM_SSP_CTRL1_WORD_LENGTH	0x000000F0
+#define BF_SSP_CTRL1_WORD_LENGTH(v)  \
+		(((v) << 4) & BM_SSP_CTRL1_WORD_LENGTH)
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED0    0x0
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED1    0x1
+#define BV_SSP_CTRL1_WORD_LENGTH__RESERVED2    0x2
+#define BV_SSP_CTRL1_WORD_LENGTH__FOUR_BITS    0x3
+#define BV_SSP_CTRL1_WORD_LENGTH__EIGHT_BITS   0x7
+#define BV_SSP_CTRL1_WORD_LENGTH__SIXTEEN_BITS 0xF
+#define BP_SSP_CTRL1_SSP_MODE	0
+#define BM_SSP_CTRL1_SSP_MODE	0x0000000F
+#define BF_SSP_CTRL1_SSP_MODE(v)  \
+		(((v) << 0) & BM_SSP_CTRL1_SSP_MODE)
+#define BV_SSP_CTRL1_SSP_MODE__SPI    0x0
+#define BV_SSP_CTRL1_SSP_MODE__SSI    0x1
+#define BV_SSP_CTRL1_SSP_MODE__SD_MMC 0x3
+#define BV_SSP_CTRL1_SSP_MODE__MS     0x4
+
+#define HW_SSP_DATA	(0x00000090)
+
+#define BP_SSP_DATA_DATA	0
+#define BM_SSP_DATA_DATA	0xFFFFFFFF
+#define BF_SSP_DATA_DATA(v)	(v)
+
+#define HW_SSP_SDRESP0	(0x000000a0)
+
+#define BP_SSP_SDRESP0_RESP0	0
+#define BM_SSP_SDRESP0_RESP0	0xFFFFFFFF
+#define BF_SSP_SDRESP0_RESP0(v)	(v)
+
+#define HW_SSP_SDRESP1	(0x000000b0)
+
+#define BP_SSP_SDRESP1_RESP1	0
+#define BM_SSP_SDRESP1_RESP1	0xFFFFFFFF
+#define BF_SSP_SDRESP1_RESP1(v)	(v)
+
+#define HW_SSP_SDRESP2	(0x000000c0)
+
+#define BP_SSP_SDRESP2_RESP2	0
+#define BM_SSP_SDRESP2_RESP2	0xFFFFFFFF
+#define BF_SSP_SDRESP2_RESP2(v)	(v)
+
+#define HW_SSP_SDRESP3	(0x000000d0)
+
+#define BP_SSP_SDRESP3_RESP3	0
+#define BM_SSP_SDRESP3_RESP3	0xFFFFFFFF
+#define BF_SSP_SDRESP3_RESP3(v)	(v)
+
+#define HW_SSP_DDR_CTRL	(0x000000e0)
+
+#define BP_SSP_DDR_CTRL_DMA_BURST_TYPE	30
+#define BM_SSP_DDR_CTRL_DMA_BURST_TYPE	0xC0000000
+#define BF_SSP_DDR_CTRL_DMA_BURST_TYPE(v) \
+		(((v) << 30) & BM_SSP_DDR_CTRL_DMA_BURST_TYPE)
+#define BP_SSP_DDR_CTRL_RSVD0	2
+#define BM_SSP_DDR_CTRL_RSVD0	0x3FFFFFFC
+#define BF_SSP_DDR_CTRL_RSVD0(v)  \
+		(((v) << 2) & BM_SSP_DDR_CTRL_RSVD0)
+#define BM_SSP_DDR_CTRL_NIBBLE_POS	0x00000002
+#define BM_SSP_DDR_CTRL_TXCLK_DELAY_TYPE	0x00000001
+
+#define HW_SSP_DLL_CTRL	(0x000000f0)
+
+#define BP_SSP_DLL_CTRL_REF_UPDATE_INT	28
+#define BM_SSP_DLL_CTRL_REF_UPDATE_INT	0xF0000000
+#define BF_SSP_DLL_CTRL_REF_UPDATE_INT(v) \
+		(((v) << 28) & BM_SSP_DLL_CTRL_REF_UPDATE_INT)
+#define BP_SSP_DLL_CTRL_SLV_UPDATE_INT	20
+#define BM_SSP_DLL_CTRL_SLV_UPDATE_INT	0x0FF00000
+#define BF_SSP_DLL_CTRL_SLV_UPDATE_INT(v)  \
+		(((v) << 20) & BM_SSP_DLL_CTRL_SLV_UPDATE_INT)
+#define BP_SSP_DLL_CTRL_RSVD1	16
+#define BM_SSP_DLL_CTRL_RSVD1	0x000F0000
+#define BF_SSP_DLL_CTRL_RSVD1(v)  \
+		(((v) << 16) & BM_SSP_DLL_CTRL_RSVD1)
+#define BP_SSP_DLL_CTRL_SLV_OVERRIDE_VAL	10
+#define BM_SSP_DLL_CTRL_SLV_OVERRIDE_VAL	0x0000FC00
+#define BF_SSP_DLL_CTRL_SLV_OVERRIDE_VAL(v)  \
+		(((v) << 10) & BM_SSP_DLL_CTRL_SLV_OVERRIDE_VAL)
+#define BM_SSP_DLL_CTRL_SLV_OVERRIDE	0x00000200
+#define BM_SSP_DLL_CTRL_RSVD0	0x00000100
+#define BM_SSP_DLL_CTRL_GATE_UPDATE	0x00000080
+#define BP_SSP_DLL_CTRL_SLV_DLY_TARGET	3
+#define BM_SSP_DLL_CTRL_SLV_DLY_TARGET	0x00000078
+#define BF_SSP_DLL_CTRL_SLV_DLY_TARGET(v)  \
+		(((v) << 3) & BM_SSP_DLL_CTRL_SLV_DLY_TARGET)
+#define BM_SSP_DLL_CTRL_SLV_FORCE_UPD	0x00000004
+#define BM_SSP_DLL_CTRL_RESET	0x00000002
+#define BM_SSP_DLL_CTRL_ENABLE	0x00000001
+
+#define HW_SSP_STATUS	(0x00000100)
+
+#define BM_SSP_STATUS_PRESENT	0x80000000
+#define BM_SSP_STATUS_MS_PRESENT	0x40000000
+#define BM_SSP_STATUS_SD_PRESENT	0x20000000
+#define BM_SSP_STATUS_CARD_DETECT	0x10000000
+#define BP_SSP_STATUS_RSVD3	23
+#define BM_SSP_STATUS_RSVD3	0x0F800000
+#define BF_SSP_STATUS_RSVD3(v)  \
+		(((v) << 23) & BM_SSP_STATUS_RSVD3)
+#define BM_SSP_STATUS_DMABURST	0x00400000
+#define BM_SSP_STATUS_DMASENSE	0x00200000
+#define BM_SSP_STATUS_DMATERM	0x00100000
+#define BM_SSP_STATUS_DMAREQ	0x00080000
+#define BM_SSP_STATUS_DMAEND	0x00040000
+#define BM_SSP_STATUS_SDIO_IRQ	0x00020000
+#define BM_SSP_STATUS_RESP_CRC_ERR	0x00010000
+#define BM_SSP_STATUS_RESP_ERR	0x00008000
+#define BM_SSP_STATUS_RESP_TIMEOUT	0x00004000
+#define BM_SSP_STATUS_DATA_CRC_ERR	0x00002000
+#define BM_SSP_STATUS_TIMEOUT	0x00001000
+#define BM_SSP_STATUS_RECV_TIMEOUT_STAT	0x00000800
+#define BM_SSP_STATUS_CEATA_CCS_ERR	0x00000400
+#define BM_SSP_STATUS_FIFO_OVRFLW	0x00000200
+#define BM_SSP_STATUS_FIFO_FULL	0x00000100
+#define BP_SSP_STATUS_RSVD1	6
+#define BM_SSP_STATUS_RSVD1	0x000000C0
+#define BF_SSP_STATUS_RSVD1(v)  \
+		(((v) << 6) & BM_SSP_STATUS_RSVD1)
+#define BM_SSP_STATUS_FIFO_EMPTY	0x00000020
+#define BM_SSP_STATUS_FIFO_UNDRFLW	0x00000010
+#define BM_SSP_STATUS_CMD_BUSY	0x00000008
+#define BM_SSP_STATUS_DATA_BUSY	0x00000004
+#define BM_SSP_STATUS_RSVD0	0x00000002
+#define BM_SSP_STATUS_BUSY	0x00000001
+
+#define HW_SSP_DLL_STS	(0x00000110)
+
+#define BP_SSP_DLL_STS_RSVD0	14
+#define BM_SSP_DLL_STS_RSVD0	0xFFFFC000
+#define BF_SSP_DLL_STS_RSVD0(v) \
+		(((v) << 14) & BM_SSP_DLL_STS_RSVD0)
+#define BP_SSP_DLL_STS_REF_SEL	8
+#define BM_SSP_DLL_STS_REF_SEL	0x00003F00
+#define BF_SSP_DLL_STS_REF_SEL(v)  \
+		(((v) << 8) & BM_SSP_DLL_STS_REF_SEL)
+#define BP_SSP_DLL_STS_SLV_SEL	2
+#define BM_SSP_DLL_STS_SLV_SEL	0x000000FC
+#define BF_SSP_DLL_STS_SLV_SEL(v)  \
+		(((v) << 2) & BM_SSP_DLL_STS_SLV_SEL)
+#define BM_SSP_DLL_STS_REF_LOCK	0x00000002
+#define BM_SSP_DLL_STS_SLV_LOCK	0x00000001
+
+#define HW_SSP_DEBUG	(0x00000120)
+
+#define BP_SSP_DEBUG_DATACRC_ERR	28
+#define BM_SSP_DEBUG_DATACRC_ERR	0xF0000000
+#define BF_SSP_DEBUG_DATACRC_ERR(v) \
+		(((v) << 28) & BM_SSP_DEBUG_DATACRC_ERR)
+#define BM_SSP_DEBUG_DATA_STALL	0x08000000
+#define BP_SSP_DEBUG_DAT_SM	24
+#define BM_SSP_DEBUG_DAT_SM	0x07000000
+#define BF_SSP_DEBUG_DAT_SM(v)  \
+		(((v) << 24) & BM_SSP_DEBUG_DAT_SM)
+#define BV_SSP_DEBUG_DAT_SM__DSM_IDLE 0x0
+#define BV_SSP_DEBUG_DAT_SM__DSM_WORD 0x2
+#define BV_SSP_DEBUG_DAT_SM__DSM_CRC1 0x3
+#define BV_SSP_DEBUG_DAT_SM__DSM_CRC2 0x4
+#define BV_SSP_DEBUG_DAT_SM__DSM_END  0x5
+#define BP_SSP_DEBUG_MSTK_SM	20
+#define BM_SSP_DEBUG_MSTK_SM	0x00F00000
+#define BF_SSP_DEBUG_MSTK_SM(v)  \
+		(((v) << 20) & BM_SSP_DEBUG_MSTK_SM)
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_IDLE  0x0
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CKON  0x1
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS1   0x2
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_TPC   0x3
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS2   0x4
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_HDSHK 0x5
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS3   0x6
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_RW    0x7
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CRC1  0x8
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_CRC2  0x9
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_BS0   0xA
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END1  0xB
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END2W 0xC
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_END2R 0xD
+#define BV_SSP_DEBUG_MSTK_SM__MSTK_DONE  0xE
+#define BM_SSP_DEBUG_CMD_OE	0x00080000
+#define BP_SSP_DEBUG_DMA_SM	16
+#define BM_SSP_DEBUG_DMA_SM	0x00070000
+#define BF_SSP_DEBUG_DMA_SM(v)  \
+		(((v) << 16) & BM_SSP_DEBUG_DMA_SM)
+#define BV_SSP_DEBUG_DMA_SM__DMA_IDLE   0x0
+#define BV_SSP_DEBUG_DMA_SM__DMA_DMAREQ 0x1
+#define BV_SSP_DEBUG_DMA_SM__DMA_DMAACK 0x2
+#define BV_SSP_DEBUG_DMA_SM__DMA_STALL  0x3
+#define BV_SSP_DEBUG_DMA_SM__DMA_BUSY   0x4
+#define BV_SSP_DEBUG_DMA_SM__DMA_DONE   0x5
+#define BV_SSP_DEBUG_DMA_SM__DMA_COUNT  0x6
+#define BP_SSP_DEBUG_MMC_SM	12
+#define BM_SSP_DEBUG_MMC_SM	0x0000F000
+#define BF_SSP_DEBUG_MMC_SM(v)  \
+		(((v) << 12) & BM_SSP_DEBUG_MMC_SM)
+#define BV_SSP_DEBUG_MMC_SM__MMC_IDLE 0x0
+#define BV_SSP_DEBUG_MMC_SM__MMC_CMD  0x1
+#define BV_SSP_DEBUG_MMC_SM__MMC_TRC  0x2
+#define BV_SSP_DEBUG_MMC_SM__MMC_RESP 0x3
+#define BV_SSP_DEBUG_MMC_SM__MMC_RPRX 0x4
+#define BV_SSP_DEBUG_MMC_SM__MMC_TX   0x5
+#define BV_SSP_DEBUG_MMC_SM__MMC_CTOK 0x6
+#define BV_SSP_DEBUG_MMC_SM__MMC_RX   0x7
+#define BV_SSP_DEBUG_MMC_SM__MMC_CCS  0x8
+#define BV_SSP_DEBUG_MMC_SM__MMC_PUP  0x9
+#define BV_SSP_DEBUG_MMC_SM__MMC_WAIT 0xA
+#define BP_SSP_DEBUG_CMD_SM	10
+#define BM_SSP_DEBUG_CMD_SM	0x00000C00
+#define BF_SSP_DEBUG_CMD_SM(v)  \
+		(((v) << 10) & BM_SSP_DEBUG_CMD_SM)
+#define BV_SSP_DEBUG_CMD_SM__CSM_IDLE  0x0
+#define BV_SSP_DEBUG_CMD_SM__CSM_INDEX 0x1
+#define BV_SSP_DEBUG_CMD_SM__CSM_ARG   0x2
+#define BV_SSP_DEBUG_CMD_SM__CSM_CRC   0x3
+#define BM_SSP_DEBUG_SSP_CMD	0x00000200
+#define BM_SSP_DEBUG_SSP_RESP	0x00000100
+#define BP_SSP_DEBUG_SSP_RXD	0
+#define BM_SSP_DEBUG_SSP_RXD	0x000000FF
+#define BF_SSP_DEBUG_SSP_RXD(v)  \
+		(((v) << 0) & BM_SSP_DEBUG_SSP_RXD)
+
+#define HW_SSP_VERSION	(0x00000130)
+
+#define BP_SSP_VERSION_MAJOR	24
+#define BM_SSP_VERSION_MAJOR	0xFF000000
+#define BF_SSP_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_SSP_VERSION_MAJOR)
+#define BP_SSP_VERSION_MINOR	16
+#define BM_SSP_VERSION_MINOR	0x00FF0000
+#define BF_SSP_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_SSP_VERSION_MINOR)
+#define BP_SSP_VERSION_STEP	0
+#define BM_SSP_VERSION_STEP	0x0000FFFF
+#define BF_SSP_VERSION_STEP(v)  \
+		(((v) << 0) & BM_SSP_VERSION_STEP)
+#endif /* __ARCH_ARM___SSP_H */
diff --git a/arch/arm/mach-mx28/include/mach/regs-timrot.h b/arch/arm/mach-mx28/include/mach/regs-timrot.h
new file mode 100644
index 0000000..125b835
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regs-timrot.h
@@ -0,0 +1,293 @@
+/*
+ * Freescale TIMROT Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.40
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___TIMROT_H
+#define __ARCH_ARM___TIMROT_H
+
+
+#define HW_TIMROT_ROTCTRL	(0x00000000)
+#define HW_TIMROT_ROTCTRL_SET	(0x00000004)
+#define HW_TIMROT_ROTCTRL_CLR	(0x00000008)
+#define HW_TIMROT_ROTCTRL_TOG	(0x0000000c)
+
+#define BM_TIMROT_ROTCTRL_SFTRST	0x80000000
+#define BM_TIMROT_ROTCTRL_CLKGATE	0x40000000
+#define BM_TIMROT_ROTCTRL_ROTARY_PRESENT	0x20000000
+#define BM_TIMROT_ROTCTRL_TIM3_PRESENT	0x10000000
+#define BM_TIMROT_ROTCTRL_TIM2_PRESENT	0x08000000
+#define BM_TIMROT_ROTCTRL_TIM1_PRESENT	0x04000000
+#define BM_TIMROT_ROTCTRL_TIM0_PRESENT	0x02000000
+#define BP_TIMROT_ROTCTRL_STATE	22
+#define BM_TIMROT_ROTCTRL_STATE	0x01C00000
+#define BF_TIMROT_ROTCTRL_STATE(v)  \
+		(((v) << 22) & BM_TIMROT_ROTCTRL_STATE)
+#define BP_TIMROT_ROTCTRL_DIVIDER	16
+#define BM_TIMROT_ROTCTRL_DIVIDER	0x003F0000
+#define BF_TIMROT_ROTCTRL_DIVIDER(v)  \
+		(((v) << 16) & BM_TIMROT_ROTCTRL_DIVIDER)
+#define BP_TIMROT_ROTCTRL_RSRVD3	13
+#define BM_TIMROT_ROTCTRL_RSRVD3	0x0000E000
+#define BF_TIMROT_ROTCTRL_RSRVD3(v)  \
+		(((v) << 13) & BM_TIMROT_ROTCTRL_RSRVD3)
+#define BM_TIMROT_ROTCTRL_RELATIVE	0x00001000
+#define BP_TIMROT_ROTCTRL_OVERSAMPLE	10
+#define BM_TIMROT_ROTCTRL_OVERSAMPLE	0x00000C00
+#define BF_TIMROT_ROTCTRL_OVERSAMPLE(v)  \
+		(((v) << 10) & BM_TIMROT_ROTCTRL_OVERSAMPLE)
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__8X 0x0
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__4X 0x1
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__2X 0x2
+#define BV_TIMROT_ROTCTRL_OVERSAMPLE__1X 0x3
+#define BM_TIMROT_ROTCTRL_POLARITY_B	0x00000200
+#define BM_TIMROT_ROTCTRL_POLARITY_A	0x00000100
+#define BP_TIMROT_ROTCTRL_SELECT_B	4
+#define BM_TIMROT_ROTCTRL_SELECT_B	0x000000F0
+#define BF_TIMROT_ROTCTRL_SELECT_B(v)  \
+		(((v) << 4) & BM_TIMROT_ROTCTRL_SELECT_B)
+#define BV_TIMROT_ROTCTRL_SELECT_B__NEVER_TICK 0x0
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM0       0x1
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM1       0x2
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM2       0x3
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM3       0x4
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM4       0x5
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM5       0x6
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM6       0x7
+#define BV_TIMROT_ROTCTRL_SELECT_B__PWM7       0x8
+#define BV_TIMROT_ROTCTRL_SELECT_B__ROTARYA    0x9
+#define BV_TIMROT_ROTCTRL_SELECT_B__ROTARYB    0xA
+#define BP_TIMROT_ROTCTRL_SELECT_A	0
+#define BM_TIMROT_ROTCTRL_SELECT_A	0x0000000F
+#define BF_TIMROT_ROTCTRL_SELECT_A(v)  \
+		(((v) << 0) & BM_TIMROT_ROTCTRL_SELECT_A)
+#define BV_TIMROT_ROTCTRL_SELECT_A__NEVER_TICK 0x0
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM0       0x1
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM1       0x2
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM2       0x3
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM3       0x4
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM4       0x5
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM5       0x6
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM6       0x7
+#define BV_TIMROT_ROTCTRL_SELECT_A__PWM7       0x8
+#define BV_TIMROT_ROTCTRL_SELECT_A__ROTARYA    0x9
+#define BV_TIMROT_ROTCTRL_SELECT_A__ROTARYB    0xA
+
+#define HW_TIMROT_ROTCOUNT	(0x00000010)
+
+#define BP_TIMROT_ROTCOUNT_RSRVD1	16
+#define BM_TIMROT_ROTCOUNT_RSRVD1	0xFFFF0000
+#define BF_TIMROT_ROTCOUNT_RSRVD1(v) \
+		(((v) << 16) & BM_TIMROT_ROTCOUNT_RSRVD1)
+#define BP_TIMROT_ROTCOUNT_UPDOWN	0
+#define BM_TIMROT_ROTCOUNT_UPDOWN	0x0000FFFF
+#define BF_TIMROT_ROTCOUNT_UPDOWN(v)  \
+		(((v) << 0) & BM_TIMROT_ROTCOUNT_UPDOWN)
+
+/*
+ *  multi-register-define name HW_TIMROT_TIMCTRLn
+ *              base 0x00000020
+ *              count 3
+ *              offset 0x40
+ */
+#define HW_TIMROT_TIMCTRLn(n)	(0x00000020 + (n) * 0x40)
+#define HW_TIMROT_TIMCTRLn_SET(n)	(0x00000024 + (n) * 0x40)
+#define HW_TIMROT_TIMCTRLn_CLR(n)	(0x00000028 + (n) * 0x40)
+#define HW_TIMROT_TIMCTRLn_TOG(n)	(0x0000002c + (n) * 0x40)
+#define BP_TIMROT_TIMCTRLn_RSRVD3	16
+#define BM_TIMROT_TIMCTRLn_RSRVD3	0xFFFF0000
+#define BF_TIMROT_TIMCTRLn_RSRVD3(v) \
+		(((v) << 16) & BM_TIMROT_TIMCTRLn_RSRVD3)
+#define BM_TIMROT_TIMCTRLn_IRQ	0x00008000
+#define BM_TIMROT_TIMCTRLn_IRQ_EN	0x00004000
+#define BP_TIMROT_TIMCTRLn_RSRVD2	12
+#define BM_TIMROT_TIMCTRLn_RSRVD2	0x00003000
+#define BF_TIMROT_TIMCTRLn_RSRVD2(v)  \
+		(((v) << 12) & BM_TIMROT_TIMCTRLn_RSRVD2)
+#define BM_TIMROT_TIMCTRLn_MATCH_MODE	0x00000800
+#define BP_TIMROT_TIMCTRLn_RSRVD1	9
+#define BM_TIMROT_TIMCTRLn_RSRVD1	0x00000600
+#define BF_TIMROT_TIMCTRLn_RSRVD1(v)  \
+		(((v) << 9) & BM_TIMROT_TIMCTRLn_RSRVD1)
+#define BM_TIMROT_TIMCTRLn_POLARITY	0x00000100
+#define BM_TIMROT_TIMCTRLn_UPDATE	0x00000080
+#define BM_TIMROT_TIMCTRLn_RELOAD	0x00000040
+#define BP_TIMROT_TIMCTRLn_PRESCALE	4
+#define BM_TIMROT_TIMCTRLn_PRESCALE	0x00000030
+#define BF_TIMROT_TIMCTRLn_PRESCALE(v)  \
+		(((v) << 4) & BM_TIMROT_TIMCTRLn_PRESCALE)
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_1 0x0
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_2 0x1
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_4 0x2
+#define BV_TIMROT_TIMCTRLn_PRESCALE__DIV_BY_8 0x3
+#define BP_TIMROT_TIMCTRLn_SELECT	0
+#define BM_TIMROT_TIMCTRLn_SELECT	0x0000000F
+#define BF_TIMROT_TIMCTRLn_SELECT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCTRLn_SELECT)
+#define BV_TIMROT_TIMCTRLn_SELECT__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM0        0x1
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM1        0x2
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM2        0x3
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM3        0x4
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM4        0x5
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM5        0x6
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM6        0x7
+#define BV_TIMROT_TIMCTRLn_SELECT__PWM7        0x8
+#define BV_TIMROT_TIMCTRLn_SELECT__ROTARYA     0x9
+#define BV_TIMROT_TIMCTRLn_SELECT__ROTARYB     0xA
+#define BV_TIMROT_TIMCTRLn_SELECT__32KHZ_XTAL  0xB
+#define BV_TIMROT_TIMCTRLn_SELECT__8KHZ_XTAL   0xC
+#define BV_TIMROT_TIMCTRLn_SELECT__4KHZ_XTAL   0xD
+#define BV_TIMROT_TIMCTRLn_SELECT__1KHZ_XTAL   0xE
+#define BV_TIMROT_TIMCTRLn_SELECT__TICK_ALWAYS 0xF
+
+/*
+ *  multi-register-define name HW_TIMROT_RUNNING_COUNTn
+ *              base 0x00000030
+ *              count 3
+ *              offset 0x40
+ */
+#define HW_TIMROT_RUNNING_COUNTn(n)	(0x00000030 + (n) * 0x40)
+#define BP_TIMROT_RUNNING_COUNTn_RUNNING_COUNT	0
+#define BM_TIMROT_RUNNING_COUNTn_RUNNING_COUNT	0xFFFFFFFF
+#define BF_TIMROT_RUNNING_COUNTn_RUNNING_COUNT(v)	(v)
+
+/*
+ *  multi-register-define name HW_TIMROT_FIXED_COUNTn
+ *              base 0x00000040
+ *              count 3
+ *              offset 0x40
+ */
+#define HW_TIMROT_FIXED_COUNTn(n)	(0x00000040 + (n) * 0x40)
+#define BP_TIMROT_FIXED_COUNTn_FIXED_COUNT	0
+#define BM_TIMROT_FIXED_COUNTn_FIXED_COUNT	0xFFFFFFFF
+#define BF_TIMROT_FIXED_COUNTn_FIXED_COUNT(v)	(v)
+
+/*
+ *  multi-register-define name HW_TIMROT_MATCH_COUNTn
+ *              base 0x00000050
+ *              count 4
+ *              offset 0x40
+ */
+#define HW_TIMROT_MATCH_COUNTn(n)	(0x00000050 + (n) * 0x40)
+#define BP_TIMROT_MATCH_COUNTn_MATCH_COUNT	0
+#define BM_TIMROT_MATCH_COUNTn_MATCH_COUNT	0xFFFFFFFF
+#define BF_TIMROT_MATCH_COUNTn_MATCH_COUNT(v)	(v)
+
+#define HW_TIMROT_TIMCTRL3	(0x000000e0)
+#define HW_TIMROT_TIMCTRL3_SET	(0x000000e4)
+#define HW_TIMROT_TIMCTRL3_CLR	(0x000000e8)
+#define HW_TIMROT_TIMCTRL3_TOG	(0x000000ec)
+
+#define BP_TIMROT_TIMCTRL3_RSRVD2	20
+#define BM_TIMROT_TIMCTRL3_RSRVD2	0xFFF00000
+#define BF_TIMROT_TIMCTRL3_RSRVD2(v) \
+		(((v) << 20) & BM_TIMROT_TIMCTRL3_RSRVD2)
+#define BP_TIMROT_TIMCTRL3_TEST_SIGNAL	16
+#define BM_TIMROT_TIMCTRL3_TEST_SIGNAL	0x000F0000
+#define BF_TIMROT_TIMCTRL3_TEST_SIGNAL(v)  \
+		(((v) << 16) & BM_TIMROT_TIMCTRL3_TEST_SIGNAL)
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM0        0x1
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM1        0x2
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM2        0x3
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM3        0x4
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM4        0x5
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM5        0x6
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM6        0x7
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__PWM7        0x8
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__ROTARYA     0x9
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__ROTARYB     0xA
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__32KHZ_XTAL  0xB
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__8KHZ_XTAL   0xC
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__4KHZ_XTAL   0xD
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__1KHZ_XTAL   0xE
+#define BV_TIMROT_TIMCTRL3_TEST_SIGNAL__TICK_ALWAYS 0xF
+#define BM_TIMROT_TIMCTRL3_IRQ	0x00008000
+#define BM_TIMROT_TIMCTRL3_IRQ_EN	0x00004000
+#define BP_TIMROT_TIMCTRL3_RSRVD1	12
+#define BM_TIMROT_TIMCTRL3_RSRVD1	0x00003000
+#define BF_TIMROT_TIMCTRL3_RSRVD1(v)  \
+		(((v) << 12) & BM_TIMROT_TIMCTRL3_RSRVD1)
+#define BM_TIMROT_TIMCTRL3_MATCH_MODE	0x00000800
+#define BM_TIMROT_TIMCTRL3_DUTY_VALID	0x00000400
+#define BM_TIMROT_TIMCTRL3_DUTY_CYCLE	0x00000200
+#define BM_TIMROT_TIMCTRL3_POLARITY	0x00000100
+#define BM_TIMROT_TIMCTRL3_UPDATE	0x00000080
+#define BM_TIMROT_TIMCTRL3_RELOAD	0x00000040
+#define BP_TIMROT_TIMCTRL3_PRESCALE	4
+#define BM_TIMROT_TIMCTRL3_PRESCALE	0x00000030
+#define BF_TIMROT_TIMCTRL3_PRESCALE(v)  \
+		(((v) << 4) & BM_TIMROT_TIMCTRL3_PRESCALE)
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_1 0x0
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_2 0x1
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_4 0x2
+#define BV_TIMROT_TIMCTRL3_PRESCALE__DIV_BY_8 0x3
+#define BP_TIMROT_TIMCTRL3_SELECT	0
+#define BM_TIMROT_TIMCTRL3_SELECT	0x0000000F
+#define BF_TIMROT_TIMCTRL3_SELECT(v)  \
+		(((v) << 0) & BM_TIMROT_TIMCTRL3_SELECT)
+#define BV_TIMROT_TIMCTRL3_SELECT__NEVER_TICK  0x0
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM0        0x1
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM1        0x2
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM2        0x3
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM3        0x4
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM4        0x5
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM5        0x6
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM6        0x7
+#define BV_TIMROT_TIMCTRL3_SELECT__PWM7        0x8
+#define BV_TIMROT_TIMCTRL3_SELECT__ROTARYA     0x9
+#define BV_TIMROT_TIMCTRL3_SELECT__ROTARYB     0xA
+#define BV_TIMROT_TIMCTRL3_SELECT__32KHZ_XTAL  0xB
+#define BV_TIMROT_TIMCTRL3_SELECT__8KHZ_XTAL   0xC
+#define BV_TIMROT_TIMCTRL3_SELECT__4KHZ_XTAL   0xD
+#define BV_TIMROT_TIMCTRL3_SELECT__1KHZ_XTAL   0xE
+#define BV_TIMROT_TIMCTRL3_SELECT__TICK_ALWAYS 0xF
+
+#define HW_TIMROT_RUNNING_COUNT3	(0x000000f0)
+
+#define BP_TIMROT_RUNNING_COUNT3_LOW_RUNNING_COUNT	0
+#define BM_TIMROT_RUNNING_COUNT3_LOW_RUNNING_COUNT	0xFFFFFFFF
+#define BF_TIMROT_RUNNING_COUNT3_LOW_RUNNING_COUNT(v)	(v)
+
+#define HW_TIMROT_FIXED_COUNT3	(0x00000100)
+
+#define BP_TIMROT_FIXED_COUNT3_HIGH_FIXED_COUNT	0
+#define BM_TIMROT_FIXED_COUNT3_HIGH_FIXED_COUNT	0xFFFFFFFF
+#define BF_TIMROT_FIXED_COUNT3_HIGH_FIXED_COUNT(v)	(v)
+
+#define HW_TIMROT_VERSION	(0x00000120)
+
+#define BP_TIMROT_VERSION_MAJOR	24
+#define BM_TIMROT_VERSION_MAJOR	0xFF000000
+#define BF_TIMROT_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_TIMROT_VERSION_MAJOR)
+#define BP_TIMROT_VERSION_MINOR	16
+#define BM_TIMROT_VERSION_MINOR	0x00FF0000
+#define BF_TIMROT_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_TIMROT_VERSION_MINOR)
+#define BP_TIMROT_VERSION_STEP	0
+#define BM_TIMROT_VERSION_STEP	0x0000FFFF
+#define BF_TIMROT_VERSION_STEP(v)  \
+		(((v) << 0) & BM_TIMROT_VERSION_STEP)
+#endif /* __ARCH_ARM___TIMROT_H */
diff --git a/arch/arm/mach-mx28/include/mach/regulator.h b/arch/arm/mach-mx28/include/mach/regulator.h
new file mode 100644
index 0000000..1b07358
--- /dev/null
+++ b/arch/arm/mach-mx28/include/mach/regulator.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __PLAT_REGULATOR_H_
+#define __PLAT_REGULATOR_H_
+
+#define MXS_REG5V_NOT_USB 0
+#define MXS_REG5V_IS_USB 1
+#define MXS_VDDD 0
+#define MXS_VDDA 1
+#define MXS_VDDIO 2
+#define MXS_VDDDBO 3
+#define MXS_OVERALL_CUR 4
+
+#endif
diff --git a/arch/arm/mach-mx28/mx28_pins.h b/arch/arm/mach-mx28/mx28_pins.h
new file mode 100644
index 0000000..a87ab9d
--- /dev/null
+++ b/arch/arm/mach-mx28/mx28_pins.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_PINS_H
+#define __ASM_ARCH_PINS_H
+
+#include <mach/pinctrl.h>
+
+/*
+ * Define MX28 pins, the pin name corresponds to MX28 hardware
+ * interface this pin belongs to.
+ */
+
+/* Bank 0 */
+#define PINID_GPMI_D00		MXS_PIN_ENCODE(0, 0)
+#define PINID_GPMI_D01		MXS_PIN_ENCODE(0, 1)
+#define PINID_GPMI_D02		MXS_PIN_ENCODE(0, 2)
+#define PINID_GPMI_D03		MXS_PIN_ENCODE(0, 3)
+#define PINID_GPMI_D04		MXS_PIN_ENCODE(0, 4)
+#define PINID_GPMI_D05		MXS_PIN_ENCODE(0, 5)
+#define PINID_GPMI_D06		MXS_PIN_ENCODE(0, 6)
+#define PINID_GPMI_D07		MXS_PIN_ENCODE(0, 7)
+#define PINID_GPMI_CE0N		MXS_PIN_ENCODE(0, 16)
+#define PINID_GPMI_CE1N		MXS_PIN_ENCODE(0, 17)
+#define PINID_GPMI_CE2N		MXS_PIN_ENCODE(0, 18)
+#define PINID_GPMI_CE3N		MXS_PIN_ENCODE(0, 19)
+#define PINID_GPMI_RDY0		MXS_PIN_ENCODE(0, 20)
+#define PINID_GPMI_RDY1		MXS_PIN_ENCODE(0, 21)
+#define PINID_GPMI_RDY2		MXS_PIN_ENCODE(0, 22)
+#define PINID_GPMI_RDY3		MXS_PIN_ENCODE(0, 23)
+#define PINID_GPMI_RDN		MXS_PIN_ENCODE(0, 24)
+#define PINID_GPMI_WRN		MXS_PIN_ENCODE(0, 25)
+#define PINID_GPMI_ALE		MXS_PIN_ENCODE(0, 26)
+#define PINID_GPMI_CLE		MXS_PIN_ENCODE(0, 27)
+#define PINID_GPMI_RESETN	MXS_PIN_ENCODE(0, 28)
+
+/* Bank 1 */
+#define PINID_LCD_D00		MXS_PIN_ENCODE(1, 0)
+#define PINID_LCD_D01		MXS_PIN_ENCODE(1, 1)
+#define PINID_LCD_D02		MXS_PIN_ENCODE(1, 2)
+#define PINID_LCD_D03		MXS_PIN_ENCODE(1, 3)
+#define PINID_LCD_D04		MXS_PIN_ENCODE(1, 4)
+#define PINID_LCD_D05		MXS_PIN_ENCODE(1, 5)
+#define PINID_LCD_D06		MXS_PIN_ENCODE(1, 6)
+#define PINID_LCD_D07		MXS_PIN_ENCODE(1, 7)
+#define PINID_LCD_D08		MXS_PIN_ENCODE(1, 8)
+#define PINID_LCD_D09		MXS_PIN_ENCODE(1, 9)
+#define PINID_LCD_D10		MXS_PIN_ENCODE(1, 10)
+#define PINID_LCD_D11		MXS_PIN_ENCODE(1, 11)
+#define PINID_LCD_D12		MXS_PIN_ENCODE(1, 12)
+#define PINID_LCD_D13		MXS_PIN_ENCODE(1, 13)
+#define PINID_LCD_D14		MXS_PIN_ENCODE(1, 14)
+#define PINID_LCD_D15		MXS_PIN_ENCODE(1, 15)
+#define PINID_LCD_D16		MXS_PIN_ENCODE(1, 16)
+#define PINID_LCD_D17		MXS_PIN_ENCODE(1, 17)
+#define PINID_LCD_D18		MXS_PIN_ENCODE(1, 18)
+#define PINID_LCD_D19		MXS_PIN_ENCODE(1, 19)
+#define PINID_LCD_D20		MXS_PIN_ENCODE(1, 20)
+#define PINID_LCD_D21		MXS_PIN_ENCODE(1, 21)
+#define PINID_LCD_D22		MXS_PIN_ENCODE(1, 22)
+#define PINID_LCD_D23		MXS_PIN_ENCODE(1, 23)
+#define PINID_LCD_RD_E		MXS_PIN_ENCODE(1, 24)
+#define PINID_LCD_WR_RWN	MXS_PIN_ENCODE(1, 25)
+#define PINID_LCD_RS		MXS_PIN_ENCODE(1, 26)
+#define PINID_LCD_CS		MXS_PIN_ENCODE(1, 27)
+#define PINID_LCD_VSYNC		MXS_PIN_ENCODE(1, 28)
+#define PINID_LCD_HSYNC		MXS_PIN_ENCODE(1, 29)
+#define PINID_LCD_DOTCK		MXS_PIN_ENCODE(1, 30)
+#define PINID_LCD_ENABLE	MXS_PIN_ENCODE(1, 31)
+
+/* Bank 2 */
+#define PINID_SSP0_DATA0	MXS_PIN_ENCODE(2, 0)
+#define PINID_SSP0_DATA1	MXS_PIN_ENCODE(2, 1)
+#define PINID_SSP0_DATA2	MXS_PIN_ENCODE(2, 2)
+#define PINID_SSP0_DATA3	MXS_PIN_ENCODE(2, 3)
+#define PINID_SSP0_DATA4	MXS_PIN_ENCODE(2, 4)
+#define PINID_SSP0_DATA5	MXS_PIN_ENCODE(2, 5)
+#define PINID_SSP0_DATA6	MXS_PIN_ENCODE(2, 6)
+#define PINID_SSP0_DATA7	MXS_PIN_ENCODE(2, 7)
+#define PINID_SSP0_CMD		MXS_PIN_ENCODE(2, 8)
+#define PINID_SSP0_DETECT	MXS_PIN_ENCODE(2, 9)
+#define PINID_SSP0_SCK		MXS_PIN_ENCODE(2, 10)
+#define PINID_SSP1_SCK		MXS_PIN_ENCODE(2, 12)
+#define PINID_SSP1_CMD		MXS_PIN_ENCODE(2, 13)
+#define PINID_SSP1_DATA0	MXS_PIN_ENCODE(2, 14)
+#define PINID_SSP1_DATA3	MXS_PIN_ENCODE(2, 15)
+#define PINID_SSP2_SCK		MXS_PIN_ENCODE(2, 16)
+#define PINID_SSP2_MOSI		MXS_PIN_ENCODE(2, 17)
+#define PINID_SSP2_MISO		MXS_PIN_ENCODE(2, 18)
+#define PINID_SSP2_SS0		MXS_PIN_ENCODE(2, 19)
+#define PINID_SSP2_SS1		MXS_PIN_ENCODE(2, 20)
+#define PINID_SSP2_SS2		MXS_PIN_ENCODE(2, 21)
+#define PINID_SSP3_SCK		MXS_PIN_ENCODE(2, 24)
+#define PINID_SSP3_MOSI		MXS_PIN_ENCODE(2, 25)
+#define PINID_SSP3_MISO		MXS_PIN_ENCODE(2, 26)
+#define PINID_SSP3_SS0		MXS_PIN_ENCODE(2, 27)
+
+/* Bank 3 */
+#define PINID_AUART0_RX		MXS_PIN_ENCODE(3, 0)
+#define PINID_AUART0_TX		MXS_PIN_ENCODE(3, 1)
+#define PINID_AUART0_CTS	MXS_PIN_ENCODE(3, 2)
+#define PINID_AUART0_RTS	MXS_PIN_ENCODE(3, 3)
+#define PINID_AUART1_RX		MXS_PIN_ENCODE(3, 4)
+#define PINID_AUART1_TX		MXS_PIN_ENCODE(3, 5)
+#define PINID_AUART1_CTS	MXS_PIN_ENCODE(3, 6)
+#define PINID_AUART1_RTS	MXS_PIN_ENCODE(3, 7)
+#define PINID_AUART2_RX		MXS_PIN_ENCODE(3, 8)
+#define PINID_AUART2_TX		MXS_PIN_ENCODE(3, 9)
+#define PINID_AUART2_CTS	MXS_PIN_ENCODE(3, 10)
+#define PINID_AUART2_RTS	MXS_PIN_ENCODE(3, 11)
+#define PINID_AUART3_RX		MXS_PIN_ENCODE(3, 12)
+#define PINID_AUART3_TX		MXS_PIN_ENCODE(3, 13)
+#define PINID_AUART3_CTS	MXS_PIN_ENCODE(3, 14)
+#define PINID_AUART3_RTS	MXS_PIN_ENCODE(3, 15)
+#define PINID_PWM0		MXS_PIN_ENCODE(3, 16)
+#define PINID_PWM1		MXS_PIN_ENCODE(3, 17)
+#define PINID_PWM2		MXS_PIN_ENCODE(3, 18)
+#define PINID_SAIF0_MCLK	MXS_PIN_ENCODE(3, 20)
+#define PINID_SAIF0_LRCLK	MXS_PIN_ENCODE(3, 21)
+#define PINID_SAIF0_BITCLK	MXS_PIN_ENCODE(3, 22)
+#define PINID_SAIF0_SDATA0	MXS_PIN_ENCODE(3, 23)
+#define PINID_I2C0_SCL		MXS_PIN_ENCODE(3, 24)
+#define PINID_I2C0_SDA		MXS_PIN_ENCODE(3, 25)
+#define PINID_SAIF1_SDATA0	MXS_PIN_ENCODE(3, 26)
+#define PINID_SPDIF		MXS_PIN_ENCODE(3, 27)
+#define PINID_PWM3		MXS_PIN_ENCODE(3, 28)
+#define PINID_PWM4		MXS_PIN_ENCODE(3, 29)
+#define PINID_LCD_RESET		MXS_PIN_ENCODE(3, 30)
+
+/* Bank 4 */
+#define PINID_ENET0_MDC		MXS_PIN_ENCODE(4, 0)
+#define PINID_ENET0_MDIO	MXS_PIN_ENCODE(4, 1)
+#define PINID_ENET0_RX_EN	MXS_PIN_ENCODE(4, 2)
+#define PINID_ENET0_RXD0	MXS_PIN_ENCODE(4, 3)
+#define PINID_ENET0_RXD1	MXS_PIN_ENCODE(4, 4)
+#define PINID_ENET0_TX_CLK	MXS_PIN_ENCODE(4, 5)
+#define PINID_ENET0_TX_EN	MXS_PIN_ENCODE(4, 6)
+#define PINID_ENET0_TXD0	MXS_PIN_ENCODE(4, 7)
+#define PINID_ENET0_TXD1	MXS_PIN_ENCODE(4, 8)
+#define PINID_ENET0_RXD2	MXS_PIN_ENCODE(4, 9)
+#define PINID_ENET0_RXD3	MXS_PIN_ENCODE(4, 10)
+#define PINID_ENET0_TXD2	MXS_PIN_ENCODE(4, 11)
+#define PINID_ENET0_TXD3	MXS_PIN_ENCODE(4, 12)
+#define PINID_ENET0_RX_CLK	MXS_PIN_ENCODE(4, 13)
+#define PINID_ENET0_COL		MXS_PIN_ENCODE(4, 14)
+#define PINID_ENET0_CRS		MXS_PIN_ENCODE(4, 15)
+#define PINID_ENET_CLK		MXS_PIN_ENCODE(4, 16)
+#define PINID_JTAG_RTCK		MXS_PIN_ENCODE(4, 20)
+#endif /* __ASM_ARCH_PINS_H */
diff --git a/arch/arm/mach-mx28/mx28evk.c b/arch/arm/mach-mx28/mx28evk.c
new file mode 100644
index 0000000..768b21a
--- /dev/null
+++ b/arch/arm/mach-mx28/mx28evk.c
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/pinctrl.h>
+
+#include "device.h"
+#include "mx28evk.h"
+
+static struct i2c_board_info __initdata mxs_i2c_device[] = {
+	{ I2C_BOARD_INFO("sgtl5000-i2c", 0x14), .flags = I2C_M_TEN }
+};
+
+static void i2c_device_init(void)
+{
+	i2c_register_board_info(0, mxs_i2c_device, ARRAY_SIZE(mxs_i2c_device));
+}
+
+static void __init fixup_board(struct machine_desc *desc, struct tag *tags,
+			       char **cmdline, struct meminfo *mi)
+{
+	mx28_set_input_clk(24000000, 24000000, 32000, 50000000);
+}
+
+#if defined(CONFIG_LEDS_MXS) || defined(CONFIG_LEDS_MXS_MODULE)
+static struct mxs_pwm_led  mx28evk_led_pwm[2] = {
+	[0] = {
+		.name = "led-pwm0",
+		.pwm = 0,
+		},
+	[1] = {
+		.name = "led-pwm1",
+		.pwm = 1,
+		},
+};
+
+struct mxs_pwm_leds_plat_data mx28evk_led_data = {
+	.num = ARRAY_SIZE(mx28evk_led_pwm),
+	.leds = mx28evk_led_pwm,
+};
+
+static struct resource mx28evk_led_res = {
+	.flags = IORESOURCE_MEM,
+	.start = PWM_PHYS_ADDR,
+	.end   = PWM_PHYS_ADDR + 0x3FFF,
+};
+
+static void __init mx28evk_init_leds(void)
+{
+	struct platform_device *pdev;
+
+	pdev = mxs_get_device("mxs-leds", 0);
+	if (pdev == NULL || IS_ERR(pdev))
+		return;
+
+	pdev->resource = &mx28evk_led_res;
+	pdev->num_resources = 1;
+	pdev->dev.platform_data = &mx28evk_led_data;
+	mxs_add_device(pdev, 3);
+}
+#else
+static void __init mx28evk_init_leds(void)
+{
+	;
+}
+#endif
+
+static void __init mx28evk_device_init(void)
+{
+	/* Add mx28evk special code */
+	i2c_device_init();
+	mx28evk_init_leds();
+}
+
+static void __init mx28evk_init_machine(void)
+{
+	mx28_pinctrl_init();
+	/* Init iram allocate */
+#ifdef CONFIG_VECTORS_PHY_ADDR
+	/* reserve the first page for irq vector table*/
+	iram_init(MX28_OCRAM_PHBASE + PAGE_SIZE, MX28_OCRAM_SIZE - PAGE_SIZE);
+#else
+	iram_init(MX28_OCRAM_PHBASE, MX28_OCRAM_SIZE);
+#endif
+
+	mx28_gpio_init();
+	mx28evk_pins_init();
+	mx28_device_init();
+	mx28evk_device_init();
+}
+
+MACHINE_START(MX28EVK, "Freescale MX28EVK board")
+	.phys_io	= 0x80000000,
+	.io_pg_offst	= ((0xf0000000) >> 18) & 0xfffc,
+	.boot_params	= 0x40000100,
+	.fixup		= fixup_board,
+	.map_io		= mx28_map_io,
+	.init_irq	= mx28_irq_init,
+	.init_machine	= mx28evk_init_machine,
+	.timer		= &mx28_timer.timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx28/mx28evk.h b/arch/arm/mach-mx28/mx28evk.h
new file mode 100644
index 0000000..5891027
--- /dev/null
+++ b/arch/arm/mach-mx28/mx28evk.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_MACH_MX28EVK_H
+#define __ASM_ARM_MACH_MX28EVK_H
+
+extern void __init mx28evk_pins_init(void);
+extern int mx28evk_enet_gpio_init(void);
+
+#endif /* __ASM_ARM_MACH_MX28EVK_H */
diff --git a/arch/arm/mach-mx28/mx28evk_pins.c b/arch/arm/mach-mx28/mx28evk_pins.c
new file mode 100644
index 0000000..a7c81b3
--- /dev/null
+++ b/arch/arm/mach-mx28/mx28evk_pins.c
@@ -0,0 +1,1139 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include <mach/pinctrl.h>
+
+#include "mx28_pins.h"
+
+static struct pin_desc mx28evk_fixed_pins[] = {
+	{
+	 .name = "DUART.RX",
+	 .id = PINID_PWM0,
+	 .fun = PIN_FUN3,
+	 },
+	{
+	 .name = "DUART.TX",
+	 .id = PINID_PWM1,
+	 .fun = PIN_FUN3,
+	 },
+#ifdef CONFIG_MXS_AUART0_DEVICE_ENABLE
+	{
+	 .name  = "AUART0.RX",
+	 .id    = PINID_AUART0_RX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART0.TX",
+	 .id    = PINID_AUART0_TX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART0.CTS",
+	 .id    = PINID_AUART0_CTS,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART0.RTS",
+	 .id    = PINID_AUART0_RTS,
+	 .fun   = PIN_FUN1,
+	 },
+#endif
+#ifdef CONFIG_MXS_AUART3_DEVICE_ENABLE
+	{
+	 .name  = "AUART3.RX",
+	 .id    = PINID_AUART3_RX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART3.TX",
+	 .id    = PINID_AUART3_TX,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART3.CTS",
+	 .id    = PINID_AUART3_CTS,
+	 .fun   = PIN_FUN1,
+	 },
+	{
+	 .name  = "AUART3.RTS",
+	 .id    = PINID_AUART3_RTS,
+	 .fun   = PIN_FUN1,
+	 },
+#endif
+	{
+	 .name = "usb0",
+	 .id = PINID_AUART2_TX, /* Power enable pin*/
+	 .fun = PIN_GPIO,
+	 .data = 0,
+	 .output = 1,
+	 },
+	 {
+	 .name  = "usb1",
+	 .id    = PINID_AUART2_RX,
+	 .fun   = PIN_GPIO,
+	 .data  = 1,
+	 .output = 1,
+	 },
+
+#if defined(CONFIG_USB_OTG)
+	 {
+	 .name 	= "usb0_id",
+	 .id 	= PINID_AUART1_RTS,
+	 .fun	= PIN_FUN2,
+	 .data 	= 1,
+	 .pull 	= 1,
+	 .pullup = 1,
+	 },
+#endif
+
+#if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
+	{
+	 .name	= "CAN1_TX",
+	 .id	= PINID_GPMI_CE2N,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "CAN1_RX",
+	 .id	= PINID_GPMI_CE3N,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "CAN0_TX",
+	 .id	= PINID_GPMI_RDY2,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "CAN0_RX",
+	 .id	= PINID_GPMI_RDY3,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "CAN_PWDN",
+	 .id	= PINID_SSP1_CMD,
+	 .fun	= PIN_GPIO,
+	 .strength	= PAD_4MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 .data		= 0,
+	 .output	= 1,
+	 },
+
+#endif
+
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+	{
+	 .name = "I2C0_SCL",
+	 .id = PINID_I2C0_SCL,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "I2C0_SDA",
+	 .id = PINID_I2C0_SDA,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+	{
+	 .name  = "LCD_D00",
+	 .id	= PINID_LCD_D00,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D01",
+	 .id	= PINID_LCD_D01,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D02",
+	 .id	= PINID_LCD_D02,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D03",
+	 .id	= PINID_LCD_D03,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D04",
+	 .id	= PINID_LCD_D04,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D05",
+	 .id	= PINID_LCD_D05,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D06",
+	 .id	= PINID_LCD_D06,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D07",
+	 .id	= PINID_LCD_D07,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D08",
+	 .id	= PINID_LCD_D08,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D09",
+	 .id	= PINID_LCD_D09,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D10",
+	 .id	= PINID_LCD_D10,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D11",
+	 .id	= PINID_LCD_D11,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D12",
+	 .id	= PINID_LCD_D12,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D13",
+	 .id	= PINID_LCD_D13,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D14",
+	 .id	= PINID_LCD_D14,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D15",
+	 .id	= PINID_LCD_D15,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D16",
+	 .id	= PINID_LCD_D16,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D17",
+	 .id	= PINID_LCD_D17,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D18",
+	 .id	= PINID_LCD_D18,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D19",
+	 .id	= PINID_LCD_D19,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D20",
+	 .id	= PINID_LCD_D20,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D21",
+	 .id	= PINID_LCD_D21,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D22",
+	 .id	= PINID_LCD_D22,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name  = "LCD_D23",
+	 .id	= PINID_LCD_D23,
+	 .fun	= PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_RESET",
+	 .id = PINID_LCD_RESET,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_VSYNC",
+	 .id   = PINID_LCD_RD_E,
+	 .fun  = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_HSYNC",
+	 .id = PINID_LCD_WR_RWN,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_ENABLE",
+	 .id = PINID_LCD_CS,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_DOTCLK",
+	 .id = PINID_LCD_RS,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "LCD_BACKLIGHT",
+	 .id = PINID_PWM2,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+#if defined(CONFIG_MMC_MXS) || defined(CONFIG_MMC_MXS_MODULE)
+	/* Configurations of SSP0 SD/MMC port pins */
+	{
+	 .name	= "SSP0_DATA0",
+	 .id	= PINID_SSP0_DATA0,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA1",
+	 .id	= PINID_SSP0_DATA1,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA2",
+	 .id	= PINID_SSP0_DATA2,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA3",
+	 .id	= PINID_SSP0_DATA3,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA4",
+	 .id	= PINID_SSP0_DATA4,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA5",
+	 .id	= PINID_SSP0_DATA5,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA6",
+	 .id	= PINID_SSP0_DATA6,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DATA7",
+	 .id	= PINID_SSP0_DATA7,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_CMD",
+	 .id	= PINID_SSP0_CMD,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP0_DETECT",
+	 .id	= PINID_SSP0_DETECT,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "SSP0_SCK",
+	 .id	= PINID_SSP0_SCK,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)\
+	|| defined(CONFIG_FEC_L2SWITCH)
+	{
+	 .name = "ENET0_MDC",
+	 .id = PINID_ENET0_MDC,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_MDIO",
+	 .id = PINID_ENET0_MDIO,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RX_EN",
+	 .id = PINID_ENET0_RX_EN,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RXD0",
+	 .id = PINID_ENET0_RXD0,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_RXD1",
+	 .id = PINID_ENET0_RXD1,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TX_EN",
+	 .id = PINID_ENET0_TX_EN,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TXD0",
+	 .id = PINID_ENET0_TXD0,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET0_TXD1",
+	 .id = PINID_ENET0_TXD1,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+	{
+	 .name = "ENET1_RX_EN",
+	 .id = PINID_ENET0_CRS,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET1_RXD0",
+	 .id = PINID_ENET0_RXD2,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET1_RXD1",
+	 .id = PINID_ENET0_RXD3,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET1_TX_EN",
+	 .id = PINID_ENET0_COL,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET1_TXD0",
+	 .id = PINID_ENET0_TXD2,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET1_TXD1",
+	 .id = PINID_ENET0_TXD3,
+	 .fun = PIN_FUN2,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive = 1,
+	 },
+	{
+	 .name = "ENET_CLK",
+	 .id = PINID_ENET_CLK,
+	 .fun = PIN_FUN1,
+	 .strength = PAD_8MA,
+	 .pull = 1,
+	 .pullup = 1,
+	 .voltage = PAD_3_3V,
+	 .drive	= 1,
+	 },
+#endif
+#if defined(CONFIG_LEDS_MXS) || defined(CONFIG_LEDS_MXS_MODULE)
+	{
+	 .name = "LEDS_PWM0",
+	 .id = PINID_AUART1_RX,
+	 .fun           = PIN_FUN3,
+	 .strength      = PAD_8MA,
+	 .voltage       = PAD_3_3V,
+	 .pullup        = 1,
+	 .drive         = 1,
+	 .pull          = 1,
+	 },
+	{
+	 .name = "LEDS_PWM1",
+	 .id = PINID_AUART1_TX,
+	 .fun           = PIN_FUN3,
+	 .strength      = PAD_8MA,
+	 .voltage       = PAD_3_3V,
+	 .pullup        = 1,
+	 .drive         = 1,
+	 .pull          = 1,
+	 },
+#endif
+#if defined(CONFIG_SND_MXS_SOC_DAI) || defined(CONFIG_SND_MXS_SOC_DAI_MODULE)
+	/* Configurations of SAIF0 port pins */
+	{
+	 .name	= "SAIF0_MCLK",
+	 .id	= PINID_SAIF0_MCLK,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SAIF0_LRCLK",
+	 .id	= PINID_SAIF0_LRCLK,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SAIF0_BITCLK",
+	 .id	= PINID_SAIF0_BITCLK,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SAIF0_SDATA0",
+	 .id	= PINID_SAIF0_SDATA0,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SAIF1_SDATA0",
+	 .id	= PINID_SAIF1_SDATA0,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+#endif
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+       defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+	{
+	 .name	= "SPDIF",
+	 .id	= PINID_SPDIF,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_12MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	},
+#endif
+};
+
+
+static int __initdata enable_ssp1 = { 0 };
+static int __init ssp1_setup(char *__unused)
+{
+	enable_ssp1 = 1;
+	return 1;
+}
+
+__setup("ssp1", ssp1_setup);
+
+static struct pin_desc mx28evk_ssp1_pins[] = {
+	{
+	 .name	= "SSP1_DATA0",
+	 .id	= PINID_GPMI_D00,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA1",
+	 .id	= PINID_GPMI_D01,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA2",
+	 .id	= PINID_GPMI_D02,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA3",
+	 .id	= PINID_GPMI_D03,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA4",
+	 .id	= PINID_GPMI_D04,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA5",
+	 .id	= PINID_GPMI_D05,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA6",
+	 .id	= PINID_GPMI_D06,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DATA7",
+	 .id	= PINID_GPMI_D07,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_CMD",
+	 .id	= PINID_GPMI_RDY1,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 1,
+	 .drive 	= 1,
+	 .pull 		= 1,
+	 },
+	{
+	 .name	= "SSP1_DETECT",
+	 .id	= PINID_GPMI_RDY0,
+	 .fun	= PIN_FUN1,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+	{
+	 .name	= "SSP1_SCK",
+	 .id	= PINID_GPMI_WRN,
+	 .fun	= PIN_FUN2,
+	 .strength	= PAD_8MA,
+	 .voltage	= PAD_3_3V,
+	 .pullup	= 0,
+	 .drive 	= 1,
+	 .pull 		= 0,
+	 },
+};
+
+
+int enable_gpmi = { 0 };
+static int __init gpmi_setup(char *__unused)
+{
+	enable_gpmi = 1;
+	return 1;
+}
+
+__setup("gpmi", gpmi_setup);
+
+static struct pin_desc mx28evk_gpmi_pins[] = {
+	{
+	 .name     = "GPMI D0",
+	 .id       = PINID_GPMI_D00,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	.name     = "GPMI D1",
+	.id       = PINID_GPMI_D01,
+	.fun      = PIN_FUN1,
+	.strength = PAD_4MA,
+	.voltage  = PAD_3_3V,
+	.pullup   = 0,
+	.drive    = !0
+	 },
+	{
+	 .name     = "GPMI D2",
+	 .id       = PINID_GPMI_D02,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D3",
+	 .id       = PINID_GPMI_D03,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D4",
+	 .id       = PINID_GPMI_D04,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D5",
+	 .id       = PINID_GPMI_D05,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D6",
+	 .id       = PINID_GPMI_D06,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI D7",
+	 .id       = PINID_GPMI_D07,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CE0-",
+	 .id       = PINID_GPMI_CE0N,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CE1-",
+	 .id       = PINID_GPMI_CE1N,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RDY0",
+	 .id       = PINID_GPMI_RDY0,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RDY1",
+	 .id       = PINID_GPMI_RDY1,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RD-",
+	 .id       = PINID_GPMI_RDN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI WR-",
+	 .id       = PINID_GPMI_WRN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI ALE",
+	 .id       = PINID_GPMI_ALE,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI CLE",
+	 .id       = PINID_GPMI_CLE,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_4MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+	{
+	 .name     = "GPMI RST-",
+	 .id       = PINID_GPMI_RESETN,
+	 .fun      = PIN_FUN1,
+	 .strength = PAD_12MA,
+	 .voltage  = PAD_3_3V,
+	 .pullup   = 0,
+	 .drive    = !0
+	 },
+};
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)\
+	|| defined(CONFIG_FEC_L2SWITCH)
+int mx28evk_enet_gpio_init(void)
+{
+	/* pwr */
+	gpio_request(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), "ENET_PWR");
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_SSP1_DATA3), 0);
+
+	/* reset phy */
+	gpio_request(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), "PHY_RESET");
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), 0);
+	mdelay(10);
+	gpio_direction_output(MXS_PIN_TO_GPIO(PINID_ENET0_RX_CLK), 1);
+
+	return 0;
+}
+#else
+int mx28evk_enet_gpio_init(void)
+{
+	return 0;
+}
+#endif
+
+void __init mx28evk_init_pin_group(struct pin_desc *pins, unsigned count)
+{
+	int i;
+	struct pin_desc *pin;
+	for (i = 0; i < count; i++) {
+		pin = pins + i;
+		if (pin->fun == PIN_GPIO)
+			gpio_request(MXS_PIN_TO_GPIO(pin->id), pin->name);
+		else
+			mxs_request_pin(pin->id, pin->fun, pin->name);
+		if (pin->drive) {
+			mxs_set_strength(pin->id, pin->strength, pin->name);
+			mxs_set_voltage(pin->id, pin->voltage, pin->name);
+		}
+		if (pin->pull)
+			mxs_set_pullup(pin->id, pin->pullup, pin->name);
+		if (pin->fun == PIN_GPIO) {
+			if (pin->output)
+				gpio_direction_output(MXS_PIN_TO_GPIO(pin->id),
+							pin->data);
+			else
+				gpio_direction_input(MXS_PIN_TO_GPIO(pin->id));
+		}
+	}
+}
+
+void __init mx28evk_pins_init(void)
+{
+
+	mx28evk_init_pin_group(mx28evk_fixed_pins,
+						ARRAY_SIZE(mx28evk_fixed_pins));
+
+	if (enable_ssp1) {
+		pr_info("Initializing SSP1 pins\n");
+		mx28evk_init_pin_group(mx28evk_ssp1_pins,
+						ARRAY_SIZE(mx28evk_ssp1_pins));
+	} else if (enable_gpmi) {
+		pr_info("Initializing GPMI pins\n");
+		mx28evk_init_pin_group(mx28evk_gpmi_pins,
+						ARRAY_SIZE(mx28evk_gpmi_pins));
+	}
+
+}
diff --git a/arch/arm/mach-mx28/pinctrl.c b/arch/arm/mach-mx28/pinctrl.c
new file mode 100644
index 0000000..296f403
--- /dev/null
+++ b/arch/arm/mach-mx28/pinctrl.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/pinctrl.h>
+
+#include "regs-pinctrl.h"
+
+#define PINCTRL_BASE_ADDR IO_ADDRESS(PINCTRL_PHYS_ADDR)
+
+static int
+mx28_pin2id(struct pinctrl_chip *chip, unsigned int pin, unsigned int *id)
+{
+	int bank;
+	bank = MXS_PIN_TO_BANK(pin & MXS_GPIO_MASK);
+	if (bank == MXS_PIN_BANK_MAX)
+		return -EINVAL;
+	*id = MXS_PIN_TO_PINID(pin & MXS_GPIO_MASK);
+	return bank;
+}
+
+static unsigned int mx28_get_gpio(struct pin_bank *bank, unsigned int id)
+{
+	if (bank->gpio_port >= MXS_NON_GPIO)
+		return -EINVAL;
+	return bank->gpio_port * PINS_PER_BANK + id;
+}
+
+static void mx28_set_strength(struct pin_bank *bank,
+			      unsigned int id, enum pad_strength strength)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_DRIVE0;
+	addr += 0x40 * bank->id + 0x10 * (id >> 3);
+	id &= 0x7;
+	id *= 4;
+	__raw_writel(PAD_CLEAR << id, addr + CLR_REGISTER);
+	__raw_writel(strength << id, addr + SET_REGISTER);
+}
+
+static void mx28_set_voltage(struct pin_bank *bank,
+			     unsigned int id, enum pad_voltage volt)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_DRIVE0;
+	addr += 0x40 * bank->id + 0x10 * (id >> 3);
+	id &= 0x7;
+	id = id * 4 + 2;
+	if (volt == PAD_1_8V)
+		__raw_writel(1 << id, addr + CLR_REGISTER);
+	else
+		__raw_writel(1 << id, addr + SET_REGISTER);
+}
+
+static void mx28_set_pullup(struct pin_bank *bank, unsigned int id, int pullup)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_PULL0;
+	addr += 0x10 * bank->id;
+	if (pullup)
+		__raw_writel(1 << id, addr + SET_REGISTER);
+	else
+		__raw_writel(1 << id, addr + CLR_REGISTER);
+}
+
+static void mx28_set_type(struct pin_bank *bank,
+			  unsigned int id, enum pin_fun cfg)
+{
+	void __iomem *addr;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_MUXSEL0;
+	addr += 0x20 * bank->id + 0x10 * (id >> 4);
+	id &= 0xF;
+	id *= 2;
+	__raw_writel(0x3 << id, addr + CLR_REGISTER);
+	__raw_writel(cfg << id, addr + SET_REGISTER);
+}
+
+static int mx28_get_type(struct pin_bank *bank,
+			  unsigned int id)
+{
+	void __iomem *addr;
+	int ret;
+	addr = PINCTRL_BASE_ADDR + HW_PINCTRL_MUXSEL0;
+	addr += 0x20 * bank->id + 0x10 * (id >> 4);
+	id &= 0xF;
+	id *= 2;
+	ret = (__raw_readl(addr) >> id) & 0x3;
+	return ret;
+}
+
+static struct pin_bank mx28_pin_banks[6] = {
+	[0] = {
+	       .id = 0,
+	       .gpio_port = 0,
+	       },
+	[1] = {
+	       .id = 1,
+	       .gpio_port = 1,
+	       },
+	[2] = {
+	       .id = 2,
+	       .gpio_port = 2,
+	       },
+	[3] = {
+	       .id = 3,
+	       .gpio_port = 3,
+	       },
+	[4] = {
+	       .id = 4,
+	       .gpio_port = 4,
+	       },
+	[5] = {
+	       .id = 5,
+	       .gpio_port = MXS_NON_GPIO,
+	       }
+};
+
+static struct pinctrl_chip mx28_pinctrl = {
+	.name = "pinctrl",
+	.banks = mx28_pin_banks,
+	.pin2id = mx28_pin2id,
+	.get_gpio = mx28_get_gpio,
+	.set_strength = mx28_set_strength,
+	.set_voltage = mx28_set_voltage,
+	.set_pullup = mx28_set_pullup,
+	.set_type = mx28_set_type,
+	.get_type = mx28_get_type,
+};
+
+int __init mx28_pinctrl_init(void)
+{
+	int i;
+	if (__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR) &
+	    BM_PINCTRL_CTRL_SFTRST) {
+		__raw_writel(BM_PINCTRL_CTRL_SFTRST,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+		for (i = 0; i < 10000; i++) {
+			if (!(__raw_readl(PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL) &
+			      BM_PINCTRL_CTRL_SFTRST))
+				break;
+			udelay(2);
+		}
+		if (i >= 10000)
+			return -EFAULT;
+
+		__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+			     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	}
+
+	__raw_writel(BM_PINCTRL_CTRL_CLKGATE,
+		     PINCTRL_BASE_ADDR + HW_PINCTRL_CTRL_CLR);
+	mx28_pinctrl.bank_size = ARRAY_SIZE(mx28_pin_banks);
+	return mxs_set_pinctrl_chip(&mx28_pinctrl);
+}
diff --git a/arch/arm/mach-mx28/pm.c b/arch/arm/mach-mx28/pm.c
new file mode 100644
index 0000000..830f57b
--- /dev/null
+++ b/arch/arm/mach-mx28/pm.c
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#include <linux/suspend.h>
+#include <linux/rtc.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+
+#include <asm/cacheflush.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/dma.h>
+#include <mach/regs-rtc.h>
+#include "regs-clkctrl.h"
+#include "regs-pinctrl.h"
+#include <mach/regs-power.h>
+#include <mach/regs-pwm.h>
+#include <mach/regs-rtc.h>
+#include <mach/../../regs-icoll.h>
+#include "regs-dram.h"
+
+#include "sleep.h"
+
+#define PENDING_IRQ_RETRY 100
+static void *saved_sram;
+static int saved_sleep_state;
+
+#define WAIT_DC_OK_CYCLES 24000
+#define WAIT_CYCLE(n) for (i = 0; i < n; i++);
+#define LOWER_VDDIO 10
+#define LOWER_VDDA 9
+#define LOWER_VDDD 0xa
+#define MAX_POWEROFF_CODE_SIZE (6 * 1024)
+#define REGS_CLKCTRL_BASE IO_ADDRESS(CLKCTRL_PHYS_ADDR)
+#define dbgc(ch) __raw_writel(ch, IO_ADDRESS(0x80074000));
+inline void dbgnum(u32 num)
+{
+	dbgc((num / 1000) + '0');
+	dbgc(((num%1000) / 100) + '0');
+	dbgc(((num%100) / 10) + '0');
+	dbgc((num%10) + '0');
+	dbgc('\n');
+}
+
+static inline void do_standby(void)
+{
+	void (*mx28_cpu_standby_ptr) (void);
+	struct clk *cpu_clk;
+	struct clk *osc_clk;
+	struct clk *pll_clk;
+	struct clk *hbus_clk;
+	struct clk *cpu_parent = NULL;
+	int cpu_rate = 0;
+	int hbus_rate = 0;
+	u32 reg_clkctrl_clkseq, reg_clkctrl_xtal;
+	unsigned long iram_phy_addr;
+	void *iram_virtual_addr;
+
+	/*
+	 * 1) switch clock domains from PLL to 24MHz
+	 * 2) lower voltage (TODO)
+	 * 3) switch EMI to 24MHz and turn PLL off (done in sleep.S)
+	 */
+
+
+	/* make sure SRAM copy gets physically written into SDRAM.
+	 * SDRAM will be placed into self-refresh during power down
+	 */
+	flush_cache_all();
+	iram_virtual_addr = iram_alloc(MAX_POWEROFF_CODE_SIZE, &iram_phy_addr);
+	if (iram_virtual_addr == NULL) {
+		pr_info("can not get iram for suspend\n");
+		return;
+	}
+	/* copy suspend function into SRAM */
+	memcpy(iram_virtual_addr, mx28_cpu_standby, mx28_standby_alloc_sz);
+
+	/* now switch the CPU to ref_xtal */
+	cpu_clk = clk_get(NULL, "cpu");
+	osc_clk = clk_get(NULL, "ref_xtal");
+	pll_clk = clk_get(NULL, "pll.0");
+	hbus_clk = clk_get(NULL, "h");
+
+	if (!IS_ERR(cpu_clk) && !IS_ERR(osc_clk)) {
+		cpu_rate = clk_get_rate(cpu_clk);
+		cpu_parent = clk_get_parent(cpu_clk);
+		hbus_rate = clk_get_rate(hbus_clk);
+		clk_set_parent(cpu_clk, osc_clk);
+	}
+
+	local_fiq_disable();
+
+	__raw_writel(BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_SET);
+
+	reg_clkctrl_clkseq = __raw_readl(REGS_CLKCTRL_BASE +
+		HW_CLKCTRL_CLKSEQ);
+
+	reg_clkctrl_xtal = __raw_readl(REGS_CLKCTRL_BASE + HW_CLKCTRL_XTAL);
+
+	/* do suspend */
+	mx28_cpu_standby_ptr = iram_virtual_addr;
+
+	mx28_cpu_standby_ptr();
+
+
+	__raw_writel(reg_clkctrl_clkseq, REGS_CLKCTRL_BASE + HW_CLKCTRL_CLKSEQ);
+	__raw_writel(reg_clkctrl_xtal, REGS_CLKCTRL_BASE + HW_CLKCTRL_XTAL);
+
+	saved_sleep_state = 0;  /* waking from standby */
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+
+	local_fiq_enable();
+
+	if (cpu_parent) {
+		clk_set_parent(cpu_clk, cpu_parent);
+		clk_set_rate(cpu_clk, cpu_rate);
+		clk_set_rate(hbus_clk, hbus_rate);
+	}
+
+	clk_put(hbus_clk);
+	clk_put(pll_clk);
+	clk_put(osc_clk);
+	clk_put(cpu_clk);
+
+	iram_free(iram_phy_addr, MAX_POWEROFF_CODE_SIZE);
+}
+
+static noinline void do_mem(void)
+{
+	/* TODO */
+}
+
+static int mx28_pm_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		do_standby();
+		break;
+	case PM_SUSPEND_MEM:
+		do_mem();
+		break;
+	}
+	return 0;
+}
+
+static int mx28_pm_valid(suspend_state_t state)
+{
+	return (state == PM_SUSPEND_STANDBY) ||
+	       (state == PM_SUSPEND_MEM);
+}
+
+static suspend_state_t saved_state;
+
+static int mx28_pm_begin(suspend_state_t state)
+{
+	saved_state = state;
+	return 0;
+}
+
+static void mx28_pm_end(void)
+{
+	/*XXX: Nothing to do */
+}
+
+suspend_state_t mx28_pm_get_target(void)
+{
+	return saved_state;
+}
+EXPORT_SYMBOL(mx28_pm_get_target);
+
+/**
+ * mx28_pm_get_sleep_state - get sleep state we waking from
+ *
+ * returns boolean: 0 if waking up from standby, 1 otherwise
+ */
+int mx28_pm_sleep_was_deep(void)
+{
+	return saved_sleep_state;
+}
+EXPORT_SYMBOL(mx28_pm_sleep_was_deep);
+
+static struct platform_suspend_ops mx28_suspend_ops = {
+	.enter	= mx28_pm_enter,
+	.valid	= mx28_pm_valid,
+	.begin	= mx28_pm_begin,
+	.end	= mx28_pm_end,
+};
+
+void mx28_pm_idle(void)
+{
+	local_irq_disable();
+	local_fiq_disable();
+	if (need_resched()) {
+		local_fiq_enable();
+		local_irq_enable();
+		return;
+	}
+
+	__raw_writel(BM_CLKCTRL_CPU_INTERRUPT_WAIT,
+		REGS_CLKCTRL_BASE + HW_CLKCTRL_CPU_SET);
+	__asm__ __volatile__ ("mcr	p15, 0, r0, c7, c0, 4");
+
+	local_fiq_enable();
+	local_irq_enable();
+}
+
+static void mx28_pm_power_off(void)
+{
+	__raw_writel(BF_POWER_RESET_UNLOCK(0x3e77) | BM_POWER_RESET_PWD,
+		REGS_POWER_BASE + HW_POWER_RESET);
+}
+
+struct mx28_pswitch_state {
+	int dev_running;
+};
+
+static DECLARE_COMPLETION(suspend_request);
+
+static int suspend_thread_fn(void *data)
+{
+	while (1) {
+		wait_for_completion_interruptible(&suspend_request);
+		pm_suspend(PM_SUSPEND_STANDBY);
+	}
+	return 0;
+}
+
+static struct mx28_pswitch_state pswitch_state = {
+	.dev_running = 0,
+};
+
+#define PSWITCH_POWER_DOWN_DELAY 30
+static 	struct delayed_work pswitch_work;
+static void pswitch_check_work(struct work_struct *work)
+{
+	int pin_value, i;
+	for (i = 0; i < PSWITCH_POWER_DOWN_DELAY; i++) {
+		pin_value = __raw_readl(REGS_POWER_BASE + HW_POWER_STS) &
+			BF_POWER_STS_PSWITCH(0x1);
+		if (pin_value == 0)
+			break;
+		msleep(100);
+	}
+	if (i < PSWITCH_POWER_DOWN_DELAY) {
+		pr_info("pswitch goto suspend\n");
+		complete(&suspend_request);
+	} else {
+		pr_info("release pswitch to power down\n");
+		for (i = 0; i < 500; i++) {
+			pin_value = __raw_readl(REGS_POWER_BASE + HW_POWER_STS)
+				& BF_POWER_STS_PSWITCH(0x1);
+			if (pin_value == 0)
+				break;
+			msleep(10);
+		}
+		pr_info("pswitch power down\n");
+		mx28_pm_power_off();
+	}
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	__raw_writel(BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_SET);
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+}
+
+
+static irqreturn_t pswitch_interrupt(int irq, void *dev)
+{
+
+	/* check if irq by pswitch */
+	if (!(__raw_readl(REGS_POWER_BASE + HW_POWER_CTRL) &
+		BM_POWER_CTRL_PSWITCH_IRQ))
+		return IRQ_HANDLED;
+	__raw_writel(BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	schedule_delayed_work(&pswitch_work, 1);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction pswitch_irq = {
+	.name		= "pswitch",
+	.flags		= IRQF_DISABLED | IRQF_SHARED,
+	.handler	= pswitch_interrupt,
+	.dev_id		= &pswitch_state,
+};
+
+static void init_pswitch(void)
+{
+	INIT_DELAYED_WORK(&pswitch_work, pswitch_check_work);
+	kthread_run(suspend_thread_fn, NULL, "pswitch");
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	__raw_writel(BM_POWER_CTRL_POLARITY_PSWITCH |
+		BM_POWER_CTRL_ENIRQ_PSWITCH,
+		REGS_POWER_BASE + HW_POWER_CTRL_SET);
+	__raw_writel(BM_POWER_CTRL_PSWITCH_IRQ,
+		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	setup_irq(IRQ_VDD5V, &pswitch_irq);
+}
+
+static int __init mx28_pm_init(void)
+{
+	saved_sram = kmalloc(0x4000, GFP_ATOMIC);
+	if (!saved_sram) {
+		printk(KERN_ERR
+		 "PM Suspend: can't allocate memory to save portion of SRAM\n");
+		return -ENOMEM;
+	}
+
+	pm_power_off = mx28_pm_power_off;
+	pm_idle = mx28_pm_idle;
+	suspend_set_ops(&mx28_suspend_ops);
+	init_pswitch();
+	return 0;
+}
+
+late_initcall(mx28_pm_init);
diff --git a/arch/arm/mach-mx28/power.c b/arch/arm/mach-mx28/power.c
new file mode 100644
index 0000000..c1dde20
--- /dev/null
+++ b/arch/arm/mach-mx28/power.c
@@ -0,0 +1,536 @@
+/*
+ * Freescale STMP378X voltage regulator low-level driver
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/* #define DEBUG */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/io.h>
+#include <mach/power.h>
+#include <mach/regulator.h>
+#include <mach/regs-power.h>
+
+static int get_voltage(struct mxs_regulator *sreg)
+{
+	int uv;
+	struct mxs_platform_regulator_data *rdata = sreg->rdata;
+	u32 val = __raw_readl(rdata->control_reg) & 0x1f;
+	if (sreg->rdata->control_reg ==
+		(u32)(REGS_POWER_BASE + HW_POWER_VDDIOCTRL)) {
+		if (val > 0x10)
+			val = 0x10;
+		uv = rdata->min_voltage + val * 50000;
+		pr_info("vddio = %d, val=%u\n", uv, val);
+	} else
+		uv = rdata->min_voltage + val *
+		  (rdata->max_voltage - rdata->min_voltage) / 0x1f;
+	return uv;
+}
+
+static int get_bo_voltage(struct mxs_regulator *sreg)
+{
+	int uv;
+	int offs;
+
+	if (!sreg->parent)
+		return -EINVAL;
+
+	uv = get_voltage(sreg->parent);
+	offs = (__raw_readl(sreg->parent->rdata->control_reg) & ~0x700) >> 8;
+	return uv - 25000*offs;
+}
+
+static int set_voltage(struct mxs_regulator *sreg, int uv)
+{
+	u32 val, reg, i;
+
+	pr_debug("%s: uv %d, min %d, max %d\n", __func__,
+		uv, sreg->rdata->min_voltage, sreg->rdata->max_voltage);
+
+	if (uv < sreg->rdata->min_voltage || uv > sreg->rdata->max_voltage)
+		return -EINVAL;
+
+	if (sreg->rdata->control_reg ==
+		(u32)(REGS_POWER_BASE + HW_POWER_VDDIOCTRL))
+		val = (uv - sreg->rdata->min_voltage) / 50000;
+	else
+		val = (uv - sreg->rdata->min_voltage) * 0x1f /
+			(sreg->rdata->max_voltage - sreg->rdata->min_voltage);
+	reg = (__raw_readl(sreg->rdata->control_reg) & ~0x1f);
+	pr_debug("%s: calculated val %d\n", __func__, val);
+	__raw_writel(val | reg, sreg->rdata->control_reg);
+	for (i = 20; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	__raw_writel(val | reg, sreg->rdata->control_reg);
+	for (i = 40000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	for (i = 40000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+out:
+	return !i;
+}
+
+static int set_bo_voltage(struct mxs_regulator *sreg, int bo_uv)
+{
+	int uv;
+	int offs;
+	u32 reg;
+	int i;
+
+	if (!sreg->parent)
+		return -EINVAL;
+
+	uv = get_voltage(sreg->parent);
+	offs = (uv - bo_uv) / 25000;
+	if (offs < 0 || offs > 7)
+		return -EINVAL;
+
+	reg = (__raw_readl(sreg->parent->rdata->control_reg) & ~0x700);
+	pr_debug("%s: calculated offs %d\n", __func__, offs);
+	__raw_writel((offs << 8) | reg, sreg->parent->rdata->control_reg);
+
+	for (i = 10000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+	if (i)
+		goto out;
+
+	for (i = 10000; i; i--) {
+		if (__raw_readl(REGS_POWER_BASE + HW_POWER_STS) & BM_POWER_STS_DC_OK)
+			break;
+		udelay(1);
+	}
+
+out:
+	return !i;
+}
+
+static int enable(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int disable(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int is_enabled(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 1;
+}
+
+static int set_mode(struct mxs_regulator *sreg, int mode)
+{
+	int ret = 0;
+	u32 val;
+
+	switch (mode) {
+	case REGULATOR_MODE_FAST:
+		val = __raw_readl(sreg->rdata->control_reg);
+		__raw_writel(val | (1 << 17), sreg->rdata->control_reg);
+		break;
+
+	case REGULATOR_MODE_NORMAL:
+		val = __raw_readl(sreg->rdata->control_reg);
+		__raw_writel(val & ~(1<<17), sreg->rdata->control_reg);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int get_mode(struct mxs_regulator *sreg)
+{
+	u32 val = __raw_readl(sreg->rdata->control_reg) & (1 << 17);
+
+	return val ? REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;
+}
+
+static struct mxs_platform_regulator_data vddd_data = {
+	.name		= "vddd",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDDCTRL),
+	.min_voltage	= 800000,
+	.max_voltage	= 1575000,
+};
+
+static struct mxs_platform_regulator_data vdddbo_data = {
+	.name		= "vddd_bo",
+	.parent_name	= "vddd",
+	.set_voltage	= set_bo_voltage,
+	.get_voltage	= get_bo_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.min_voltage	= 800000,
+	.max_voltage	= 1575000,
+};
+
+static struct mxs_platform_regulator_data vdda_data = {
+	.name		= "vdda",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDACTRL),
+	.min_voltage	= 1500000,
+	.max_voltage	= 2275000,
+};
+
+#define MX28EVK_VDDIO_OFFSET 80000
+static struct mxs_platform_regulator_data vddio_data = {
+	.name		= "vddio",
+	.set_voltage	= set_voltage,
+	.get_voltage	= get_voltage,
+	.enable		= enable,
+	.disable	= disable,
+	.is_enabled	= is_enabled,
+	.set_mode	= set_mode,
+	.get_mode	= get_mode,
+	.control_reg	= (u32)(REGS_POWER_BASE + HW_POWER_VDDIOCTRL),
+	.min_voltage	= 2800000 + MX28EVK_VDDIO_OFFSET,
+	.max_voltage	= 3600000 + MX28EVK_VDDIO_OFFSET,
+};
+
+static struct regulator_init_data vddd_init = {
+	.constraints = {
+		.name			= "vddd",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+static struct regulator_init_data vdddbo_init = {
+	.constraints = {
+		.name			= "vdddbo",
+		.min_uV			= 800000,
+		.max_uV			= 1575000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+
+static struct regulator_init_data vdda_init = {
+	.constraints = {
+		.name			= "vdda",
+		.min_uV			= 1500000,
+		.max_uV			= 2275000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+
+static struct regulator_init_data vddio_init = {
+	.constraints = {
+		.name			= "vddio",
+		.min_uV			= 2800000 + MX28EVK_VDDIO_OFFSET,
+		.max_uV			= 3600000 + MX28EVK_VDDIO_OFFSET,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	}
+};
+
+/* now the current regulators */
+/* Restriction: .... no set_current call on root regulator */
+static int main_add_current(struct mxs_regulator *sreg,
+			    int uA)
+{
+
+	pr_debug("%s: enter reg %s, uA=%d\n",
+		 __func__, sreg->regulator.name, uA);
+	if (uA > 0 && (sreg->cur_current + uA > sreg->rdata->max_current))
+		return -EINVAL;
+	else
+		sreg->cur_current += uA;
+	return 0;
+}
+
+static int cur_reg_set_current(struct mxs_regulator *sreg, int uA)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	pr_debug("%s: enter reg %s, uA=%d\n",
+		 __func__, sreg->regulator.name, uA);
+
+	if (sreg->parent) {
+		spin_lock_irqsave(&sreg->parent->lock, flags);
+		ret = main_add_current(sreg->parent, uA - sreg->cur_current);
+		spin_unlock_irqrestore(&sreg->parent->lock, flags);
+	}
+
+
+	if ((!ret) || (!sreg->parent))
+		goto out;
+
+	if (sreg->mode == REGULATOR_MODE_FAST)
+		return ret;
+
+	while (ret) {
+		wait_event(sreg->parent->wait_q ,
+			   (uA - sreg->cur_current <
+			    sreg->parent->rdata->max_current -
+			    sreg->parent->cur_current));
+		spin_lock_irqsave(&sreg->parent->lock, flags);
+		ret = main_add_current(sreg->parent, uA - sreg->cur_current);
+		spin_unlock_irqrestore(&sreg->parent->lock, flags);
+	}
+out:
+	if (sreg->parent && (uA - sreg->cur_current < 0))
+		wake_up_all(&sreg->parent->wait_q);
+	sreg->cur_current = uA;
+	return 0;
+
+}
+
+static int cur_reg_get_current(struct mxs_regulator *sreg)
+{
+	return sreg->cur_current;
+}
+
+static int enable_cur_reg(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int disable_cur_reg(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 0;
+}
+
+static int cur_reg_is_enabled(struct mxs_regulator *sreg)
+{
+	/* XXX: TODO */
+	return 1;
+}
+
+static int cur_reg_set_mode(struct mxs_regulator *sreg, int mode)
+{
+	int ret = 0;
+
+	switch (mode) {
+	case REGULATOR_MODE_NORMAL:
+	case REGULATOR_MODE_FAST:
+		sreg->mode = mode;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int cur_reg_get_mode(struct mxs_regulator *sreg)
+{
+	return sreg->mode;
+}
+
+static struct mxs_platform_regulator_data overall_cur_data = {
+	.name		= "overall_current",
+	.set_current	= cur_reg_set_current,
+	.get_current	= cur_reg_get_current,
+	.enable		= enable_cur_reg,
+	.disable	= disable_cur_reg,
+	.is_enabled	= cur_reg_is_enabled,
+	.set_mode	= cur_reg_set_mode,
+	.get_mode	= cur_reg_get_mode,
+	.max_current	= 0x7fffffff,
+};
+
+static struct regulator_init_data overall_cur_init = {
+	.constraints = {
+		.name			= "overall_current",
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL |
+					  REGULATOR_MODE_FAST,
+		.valid_ops_mask		= REGULATOR_CHANGE_CURRENT |
+					  REGULATOR_CHANGE_MODE,
+		.max_uA                 = 0x7fffffff,
+		.min_uA                 = 0x0,
+		.always_on		= 1,
+	}
+};
+
+static struct mxs_platform_regulator_data sibling_cur_data = {
+	.parent_name	= "overall_current",
+	.set_current	= cur_reg_set_current,
+	.get_current	= cur_reg_get_current,
+	.enable		= enable_cur_reg,
+	.disable	= disable_cur_reg,
+	.is_enabled	= cur_reg_is_enabled,
+	.set_mode	= cur_reg_set_mode,
+	.get_mode	= cur_reg_get_mode,
+};
+
+
+static const char *device_names[] = {
+	"mxs-duart", "mxs-bl", "mxs-i2c"
+};
+
+static int sibling_current_devices_num;
+
+int mxs_platform_add_regulator(const char *name, int count)
+{
+	int i;
+	pr_debug("%s: name %s, count %d\n", __func__, name, count);
+	for (i = sibling_current_devices_num;
+	     i < sibling_current_devices_num + count;
+	     i++) {
+		struct regulator_init_data *sibling_init =
+			kzalloc(sizeof(struct regulator_init_data),
+			GFP_KERNEL);
+		struct mxs_regulator *curr_reg =
+			kzalloc(sizeof(struct mxs_regulator),
+			GFP_KERNEL);
+		struct mxs_platform_regulator_data *d =
+			kzalloc(sizeof(struct mxs_platform_regulator_data),
+			GFP_KERNEL);
+		if (!d || !curr_reg || !sibling_init)
+			return -ENOMEM;
+
+		sibling_init->constraints.valid_modes_mask =
+			REGULATOR_MODE_NORMAL | REGULATOR_MODE_FAST;
+		sibling_init->constraints.valid_ops_mask =
+			REGULATOR_CHANGE_CURRENT | REGULATOR_CHANGE_MODE;
+		sibling_init->constraints.max_uA = 0x7fffffff;
+		sibling_init->constraints.min_uA = 0x0;
+
+		memcpy(d, &sibling_cur_data, sizeof(sibling_cur_data));
+		d->parent_name = kstrdup(sibling_cur_data.parent_name,
+					 GFP_KERNEL);
+		snprintf(d->name, 80, "%s-%d",
+			 name, i - sibling_current_devices_num + 1);
+		sibling_init->constraints.name = kstrdup(d->name, GFP_KERNEL);
+		sibling_init->constraints.always_on = 1;
+		curr_reg->rdata = d;
+		mxs_register_regulator(curr_reg, 101 + i, sibling_init);
+	}
+	sibling_current_devices_num += count;
+	return 0;
+}
+
+static struct mxs_regulator vddd_reg = {
+		.rdata = &vddd_data,
+};
+
+static struct mxs_regulator vdda_reg = {
+		.rdata = &vdda_data,
+};
+
+static struct mxs_regulator vddio_reg = {
+		.rdata = &vddio_data,
+};
+
+static struct mxs_regulator vdddbo_reg = {
+		.rdata = &vdddbo_data,
+};
+
+static struct mxs_regulator overall_cur_reg = {
+		.rdata = &overall_cur_data,
+};
+
+
+static int __init regulators_init(void)
+{
+	int i;
+	int retval = 0;
+	u32 vddio = __raw_readl(REGS_POWER_BASE + HW_POWER_VDDIOCTRL) & ~0x1f;
+	pr_debug("regulators_init \n");
+	__raw_writel(vddio | 0xA, REGS_POWER_BASE + HW_POWER_VDDIOCTRL);
+	vdddbo_reg.parent = &vddd_reg;
+	mxs_register_regulator(&vddd_reg, MXS_VDDD, &vddd_init);
+	mxs_register_regulator(&vdddbo_reg, MXS_VDDDBO, &vdddbo_init);
+	mxs_register_regulator(&vdda_reg, MXS_VDDA, &vdda_init);
+	mxs_register_regulator(&vddio_reg, MXS_VDDIO, &vddio_init);
+	mxs_register_regulator(&overall_cur_reg,
+		MXS_OVERALL_CUR, &overall_cur_init);
+
+	for (i = 0; i < ARRAY_SIZE(device_names); i++) {
+		retval = mxs_platform_add_regulator(device_names[i], 1);
+		if (retval)
+			return retval;
+	}
+	mxs_platform_add_regulator("mmc_ssp", 2);
+	mxs_platform_add_regulator("charger", 1);
+	mxs_platform_add_regulator("power-test", 1);
+	mxs_platform_add_regulator("cpufreq", 1);
+	return 0;
+}
+postcore_initcall(regulators_init);
diff --git a/arch/arm/mach-mx28/regs-clkctrl.h b/arch/arm/mach-mx28/regs-clkctrl.h
new file mode 100644
index 0000000..9de1927
--- /dev/null
+++ b/arch/arm/mach-mx28/regs-clkctrl.h
@@ -0,0 +1,635 @@
+/*
+ * Freescale CLKCTRL Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.48
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___CLKCTRL_H
+#define __ARCH_ARM___CLKCTRL_H
+
+#define HW_CLKCTRL_PLL0CTRL0	(0x00000000)
+#define HW_CLKCTRL_PLL0CTRL0_SET	(0x00000004)
+#define HW_CLKCTRL_PLL0CTRL0_CLR	(0x00000008)
+#define HW_CLKCTRL_PLL0CTRL0_TOG	(0x0000000c)
+
+#define BP_CLKCTRL_PLL0CTRL0_RSRVD6	30
+#define BM_CLKCTRL_PLL0CTRL0_RSRVD6	0xC0000000
+#define BF_CLKCTRL_PLL0CTRL0_RSRVD6(v) \
+		(((v) << 30) & BM_CLKCTRL_PLL0CTRL0_RSRVD6)
+#define BP_CLKCTRL_PLL0CTRL0_LFR_SEL	28
+#define BM_CLKCTRL_PLL0CTRL0_LFR_SEL	0x30000000
+#define BF_CLKCTRL_PLL0CTRL0_LFR_SEL(v)  \
+		(((v) << 28) & BM_CLKCTRL_PLL0CTRL0_LFR_SEL)
+#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLL0CTRL0_LFR_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLL0CTRL0_RSRVD5	26
+#define BM_CLKCTRL_PLL0CTRL0_RSRVD5	0x0C000000
+#define BF_CLKCTRL_PLL0CTRL0_RSRVD5(v)  \
+		(((v) << 26) & BM_CLKCTRL_PLL0CTRL0_RSRVD5)
+#define BP_CLKCTRL_PLL0CTRL0_CP_SEL	24
+#define BM_CLKCTRL_PLL0CTRL0_CP_SEL	0x03000000
+#define BF_CLKCTRL_PLL0CTRL0_CP_SEL(v)  \
+		(((v) << 24) & BM_CLKCTRL_PLL0CTRL0_CP_SEL)
+#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLL0CTRL0_CP_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLL0CTRL0_RSRVD4	22
+#define BM_CLKCTRL_PLL0CTRL0_RSRVD4	0x00C00000
+#define BF_CLKCTRL_PLL0CTRL0_RSRVD4(v)  \
+		(((v) << 22) & BM_CLKCTRL_PLL0CTRL0_RSRVD4)
+#define BP_CLKCTRL_PLL0CTRL0_DIV_SEL	20
+#define BM_CLKCTRL_PLL0CTRL0_DIV_SEL	0x00300000
+#define BF_CLKCTRL_PLL0CTRL0_DIV_SEL(v)  \
+		(((v) << 20) & BM_CLKCTRL_PLL0CTRL0_DIV_SEL)
+#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWER     0x1
+#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWEST    0x2
+#define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__UNDEFINED 0x3
+#define BM_CLKCTRL_PLL0CTRL0_RSRVD3	0x00080000
+#define BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS	0x00040000
+#define BM_CLKCTRL_PLL0CTRL0_POWER	0x00020000
+#define BP_CLKCTRL_PLL0CTRL0_RSRVD1	0
+#define BM_CLKCTRL_PLL0CTRL0_RSRVD1	0x0001FFFF
+#define BF_CLKCTRL_PLL0CTRL0_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLL0CTRL0_RSRVD1)
+
+#define HW_CLKCTRL_PLL0CTRL1	(0x00000010)
+
+#define BM_CLKCTRL_PLL0CTRL1_LOCK	0x80000000
+#define BM_CLKCTRL_PLL0CTRL1_FORCE_LOCK	0x40000000
+#define BP_CLKCTRL_PLL0CTRL1_RSRVD1	16
+#define BM_CLKCTRL_PLL0CTRL1_RSRVD1	0x3FFF0000
+#define BF_CLKCTRL_PLL0CTRL1_RSRVD1(v)  \
+		(((v) << 16) & BM_CLKCTRL_PLL0CTRL1_RSRVD1)
+#define BP_CLKCTRL_PLL0CTRL1_LOCK_COUNT	0
+#define BM_CLKCTRL_PLL0CTRL1_LOCK_COUNT	0x0000FFFF
+#define BF_CLKCTRL_PLL0CTRL1_LOCK_COUNT(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLL0CTRL1_LOCK_COUNT)
+
+#define HW_CLKCTRL_PLL1CTRL0	(0x00000020)
+#define HW_CLKCTRL_PLL1CTRL0_SET	(0x00000024)
+#define HW_CLKCTRL_PLL1CTRL0_CLR	(0x00000028)
+#define HW_CLKCTRL_PLL1CTRL0_TOG	(0x0000002c)
+
+#define BM_CLKCTRL_PLL1CTRL0_CLKGATEEMI	0x80000000
+#define BM_CLKCTRL_PLL1CTRL0_RSRVD6	0x40000000
+#define BP_CLKCTRL_PLL1CTRL0_LFR_SEL	28
+#define BM_CLKCTRL_PLL1CTRL0_LFR_SEL	0x30000000
+#define BF_CLKCTRL_PLL1CTRL0_LFR_SEL(v)  \
+		(((v) << 28) & BM_CLKCTRL_PLL1CTRL0_LFR_SEL)
+#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLL1CTRL0_LFR_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLL1CTRL0_RSRVD5	26
+#define BM_CLKCTRL_PLL1CTRL0_RSRVD5	0x0C000000
+#define BF_CLKCTRL_PLL1CTRL0_RSRVD5(v)  \
+		(((v) << 26) & BM_CLKCTRL_PLL1CTRL0_RSRVD5)
+#define BP_CLKCTRL_PLL1CTRL0_CP_SEL	24
+#define BM_CLKCTRL_PLL1CTRL0_CP_SEL	0x03000000
+#define BF_CLKCTRL_PLL1CTRL0_CP_SEL(v)  \
+		(((v) << 24) & BM_CLKCTRL_PLL1CTRL0_CP_SEL)
+#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__TIMES_2   0x1
+#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__TIMES_05  0x2
+#define BV_CLKCTRL_PLL1CTRL0_CP_SEL__UNDEFINED 0x3
+#define BP_CLKCTRL_PLL1CTRL0_RSRVD4	22
+#define BM_CLKCTRL_PLL1CTRL0_RSRVD4	0x00C00000
+#define BF_CLKCTRL_PLL1CTRL0_RSRVD4(v)  \
+		(((v) << 22) & BM_CLKCTRL_PLL1CTRL0_RSRVD4)
+#define BP_CLKCTRL_PLL1CTRL0_DIV_SEL	20
+#define BM_CLKCTRL_PLL1CTRL0_DIV_SEL	0x00300000
+#define BF_CLKCTRL_PLL1CTRL0_DIV_SEL(v)  \
+		(((v) << 20) & BM_CLKCTRL_PLL1CTRL0_DIV_SEL)
+#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__DEFAULT   0x0
+#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWER     0x1
+#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWEST    0x2
+#define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__UNDEFINED 0x3
+#define BM_CLKCTRL_PLL1CTRL0_RSRVD3	0x00080000
+#define BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS	0x00040000
+#define BM_CLKCTRL_PLL1CTRL0_POWER	0x00020000
+#define BP_CLKCTRL_PLL1CTRL0_RSRVD1	0
+#define BM_CLKCTRL_PLL1CTRL0_RSRVD1	0x0001FFFF
+#define BF_CLKCTRL_PLL1CTRL0_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLL1CTRL0_RSRVD1)
+
+#define HW_CLKCTRL_PLL1CTRL1	(0x00000030)
+
+#define BM_CLKCTRL_PLL1CTRL1_LOCK	0x80000000
+#define BM_CLKCTRL_PLL1CTRL1_FORCE_LOCK	0x40000000
+#define BP_CLKCTRL_PLL1CTRL1_RSRVD1	16
+#define BM_CLKCTRL_PLL1CTRL1_RSRVD1	0x3FFF0000
+#define BF_CLKCTRL_PLL1CTRL1_RSRVD1(v)  \
+		(((v) << 16) & BM_CLKCTRL_PLL1CTRL1_RSRVD1)
+#define BP_CLKCTRL_PLL1CTRL1_LOCK_COUNT	0
+#define BM_CLKCTRL_PLL1CTRL1_LOCK_COUNT	0x0000FFFF
+#define BF_CLKCTRL_PLL1CTRL1_LOCK_COUNT(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLL1CTRL1_LOCK_COUNT)
+
+#define HW_CLKCTRL_PLL2CTRL0	(0x00000040)
+#define HW_CLKCTRL_PLL2CTRL0_SET	(0x00000044)
+#define HW_CLKCTRL_PLL2CTRL0_CLR	(0x00000048)
+#define HW_CLKCTRL_PLL2CTRL0_TOG	(0x0000004c)
+
+#define BM_CLKCTRL_PLL2CTRL0_CLKGATE	0x80000000
+#define BM_CLKCTRL_PLL2CTRL0_RSRVD3	0x40000000
+#define BP_CLKCTRL_PLL2CTRL0_LFR_SEL	28
+#define BM_CLKCTRL_PLL2CTRL0_LFR_SEL	0x30000000
+#define BF_CLKCTRL_PLL2CTRL0_LFR_SEL(v)  \
+		(((v) << 28) & BM_CLKCTRL_PLL2CTRL0_LFR_SEL)
+#define BM_CLKCTRL_PLL2CTRL0_RSRVD2	0x08000000
+#define BM_CLKCTRL_PLL2CTRL0_HOLD_RING_OFF_B	0x04000000
+#define BP_CLKCTRL_PLL2CTRL0_CP_SEL	24
+#define BM_CLKCTRL_PLL2CTRL0_CP_SEL	0x03000000
+#define BF_CLKCTRL_PLL2CTRL0_CP_SEL(v)  \
+		(((v) << 24) & BM_CLKCTRL_PLL2CTRL0_CP_SEL)
+#define BM_CLKCTRL_PLL2CTRL0_POWER	0x00800000
+#define BP_CLKCTRL_PLL2CTRL0_RSRVD1	0
+#define BM_CLKCTRL_PLL2CTRL0_RSRVD1	0x007FFFFF
+#define BF_CLKCTRL_PLL2CTRL0_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_PLL2CTRL0_RSRVD1)
+
+#define HW_CLKCTRL_CPU	(0x00000050)
+#define HW_CLKCTRL_CPU_SET	(0x00000054)
+#define HW_CLKCTRL_CPU_CLR	(0x00000058)
+#define HW_CLKCTRL_CPU_TOG	(0x0000005c)
+
+#define BP_CLKCTRL_CPU_RSRVD5	30
+#define BM_CLKCTRL_CPU_RSRVD5	0xC0000000
+#define BF_CLKCTRL_CPU_RSRVD5(v) \
+		(((v) << 30) & BM_CLKCTRL_CPU_RSRVD5)
+#define BM_CLKCTRL_CPU_BUSY_REF_XTAL	0x20000000
+#define BM_CLKCTRL_CPU_BUSY_REF_CPU	0x10000000
+#define BM_CLKCTRL_CPU_RSRVD4	0x08000000
+#define BM_CLKCTRL_CPU_DIV_XTAL_FRAC_EN	0x04000000
+#define BP_CLKCTRL_CPU_DIV_XTAL	16
+#define BM_CLKCTRL_CPU_DIV_XTAL	0x03FF0000
+#define BF_CLKCTRL_CPU_DIV_XTAL(v)  \
+		(((v) << 16) & BM_CLKCTRL_CPU_DIV_XTAL)
+#define BP_CLKCTRL_CPU_RSRVD3	13
+#define BM_CLKCTRL_CPU_RSRVD3	0x0000E000
+#define BF_CLKCTRL_CPU_RSRVD3(v)  \
+		(((v) << 13) & BM_CLKCTRL_CPU_RSRVD3)
+#define BM_CLKCTRL_CPU_INTERRUPT_WAIT	0x00001000
+#define BM_CLKCTRL_CPU_RSRVD2	0x00000800
+#define BM_CLKCTRL_CPU_DIV_CPU_FRAC_EN	0x00000400
+#define BP_CLKCTRL_CPU_RSRVD1	6
+#define BM_CLKCTRL_CPU_RSRVD1	0x000003C0
+#define BF_CLKCTRL_CPU_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_CPU_RSRVD1)
+#define BP_CLKCTRL_CPU_DIV_CPU	0
+#define BM_CLKCTRL_CPU_DIV_CPU	0x0000003F
+#define BF_CLKCTRL_CPU_DIV_CPU(v)  \
+		(((v) << 0) & BM_CLKCTRL_CPU_DIV_CPU)
+
+#define HW_CLKCTRL_HBUS	(0x00000060)
+#define HW_CLKCTRL_HBUS_SET	(0x00000064)
+#define HW_CLKCTRL_HBUS_CLR	(0x00000068)
+#define HW_CLKCTRL_HBUS_TOG	(0x0000006c)
+
+#define BM_CLKCTRL_HBUS_ASM_BUSY	0x80000000
+#define BM_CLKCTRL_HBUS_DCP_AS_ENABLE	0x40000000
+#define BM_CLKCTRL_HBUS_PXP_AS_ENABLE	0x20000000
+#define BM_CLKCTRL_HBUS_RSRVD2	0x10000000
+#define BM_CLKCTRL_HBUS_ASM_EMIPORT_AS_ENABLE	0x08000000
+#define BM_CLKCTRL_HBUS_APBHDMA_AS_ENABLE	0x04000000
+#define BM_CLKCTRL_HBUS_APBXDMA_AS_ENABLE	0x02000000
+#define BM_CLKCTRL_HBUS_TRAFFIC_JAM_AS_ENABLE	0x01000000
+#define BM_CLKCTRL_HBUS_TRAFFIC_AS_ENABLE	0x00800000
+#define BM_CLKCTRL_HBUS_CPU_DATA_AS_ENABLE	0x00400000
+#define BM_CLKCTRL_HBUS_CPU_INSTR_AS_ENABLE	0x00200000
+#define BM_CLKCTRL_HBUS_ASM_ENABLE	0x00100000
+#define BM_CLKCTRL_HBUS_AUTO_CLEAR_DIV_ENABLE	0x00080000
+#define BP_CLKCTRL_HBUS_SLOW_DIV	16
+#define BM_CLKCTRL_HBUS_SLOW_DIV	0x00070000
+#define BF_CLKCTRL_HBUS_SLOW_DIV(v)  \
+		(((v) << 16) & BM_CLKCTRL_HBUS_SLOW_DIV)
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY1  0x0
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY2  0x1
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY4  0x2
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY8  0x3
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY16 0x4
+#define BV_CLKCTRL_HBUS_SLOW_DIV__BY32 0x5
+#define BP_CLKCTRL_HBUS_RSRVD1	6
+#define BM_CLKCTRL_HBUS_RSRVD1	0x0000FFC0
+#define BF_CLKCTRL_HBUS_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_HBUS_RSRVD1)
+#define BM_CLKCTRL_HBUS_DIV_FRAC_EN	0x00000020
+#define BP_CLKCTRL_HBUS_DIV	0
+#define BM_CLKCTRL_HBUS_DIV	0x0000001F
+#define BF_CLKCTRL_HBUS_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_HBUS_DIV)
+
+#define HW_CLKCTRL_XBUS	(0x00000070)
+
+#define BM_CLKCTRL_XBUS_BUSY	0x80000000
+#define BP_CLKCTRL_XBUS_RSRVD1	12
+#define BM_CLKCTRL_XBUS_RSRVD1	0x7FFFF000
+#define BF_CLKCTRL_XBUS_RSRVD1(v)  \
+		(((v) << 12) & BM_CLKCTRL_XBUS_RSRVD1)
+#define BM_CLKCTRL_XBUS_AUTO_CLEAR_DIV_ENABLE	0x00000800
+#define BM_CLKCTRL_XBUS_DIV_FRAC_EN	0x00000400
+#define BP_CLKCTRL_XBUS_DIV	0
+#define BM_CLKCTRL_XBUS_DIV	0x000003FF
+#define BF_CLKCTRL_XBUS_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_XBUS_DIV)
+
+#define HW_CLKCTRL_XTAL	(0x00000080)
+#define HW_CLKCTRL_XTAL_SET	(0x00000084)
+#define HW_CLKCTRL_XTAL_CLR	(0x00000088)
+#define HW_CLKCTRL_XTAL_TOG	(0x0000008c)
+
+#define BM_CLKCTRL_XTAL_UART_CLK_GATE	0x80000000
+#define BM_CLKCTRL_XTAL_RSRVD3	0x40000000
+#define BM_CLKCTRL_XTAL_PWM_CLK24M_GATE	0x20000000
+#define BP_CLKCTRL_XTAL_RSRVD2	27
+#define BM_CLKCTRL_XTAL_RSRVD2	0x18000000
+#define BF_CLKCTRL_XTAL_RSRVD2(v)  \
+		(((v) << 27) & BM_CLKCTRL_XTAL_RSRVD2)
+#define BM_CLKCTRL_XTAL_TIMROT_CLK32K_GATE	0x04000000
+#define BP_CLKCTRL_XTAL_RSRVD1	2
+#define BM_CLKCTRL_XTAL_RSRVD1	0x03FFFFFC
+#define BF_CLKCTRL_XTAL_RSRVD1(v)  \
+		(((v) << 2) & BM_CLKCTRL_XTAL_RSRVD1)
+#define BP_CLKCTRL_XTAL_DIV_UART	0
+#define BM_CLKCTRL_XTAL_DIV_UART	0x00000003
+#define BF_CLKCTRL_XTAL_DIV_UART(v)  \
+		(((v) << 0) & BM_CLKCTRL_XTAL_DIV_UART)
+
+#define HW_CLKCTRL_SSP0	(0x00000090)
+
+#define BM_CLKCTRL_SSP0_CLKGATE	0x80000000
+#define BM_CLKCTRL_SSP0_RSRVD2	0x40000000
+#define BM_CLKCTRL_SSP0_BUSY	0x20000000
+#define BP_CLKCTRL_SSP0_RSRVD1	10
+#define BM_CLKCTRL_SSP0_RSRVD1	0x1FFFFC00
+#define BF_CLKCTRL_SSP0_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_SSP0_RSRVD1)
+#define BM_CLKCTRL_SSP0_DIV_FRAC_EN	0x00000200
+#define BP_CLKCTRL_SSP0_DIV	0
+#define BM_CLKCTRL_SSP0_DIV	0x000001FF
+#define BF_CLKCTRL_SSP0_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SSP0_DIV)
+
+#define HW_CLKCTRL_SSP1	(0x000000a0)
+
+#define BM_CLKCTRL_SSP1_CLKGATE	0x80000000
+#define BM_CLKCTRL_SSP1_RSRVD2	0x40000000
+#define BM_CLKCTRL_SSP1_BUSY	0x20000000
+#define BP_CLKCTRL_SSP1_RSRVD1	10
+#define BM_CLKCTRL_SSP1_RSRVD1	0x1FFFFC00
+#define BF_CLKCTRL_SSP1_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_SSP1_RSRVD1)
+#define BM_CLKCTRL_SSP1_DIV_FRAC_EN	0x00000200
+#define BP_CLKCTRL_SSP1_DIV	0
+#define BM_CLKCTRL_SSP1_DIV	0x000001FF
+#define BF_CLKCTRL_SSP1_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SSP1_DIV)
+
+#define HW_CLKCTRL_SSP2	(0x000000b0)
+
+#define BM_CLKCTRL_SSP2_CLKGATE	0x80000000
+#define BM_CLKCTRL_SSP2_RSRVD2	0x40000000
+#define BM_CLKCTRL_SSP2_BUSY	0x20000000
+#define BP_CLKCTRL_SSP2_RSRVD1	10
+#define BM_CLKCTRL_SSP2_RSRVD1	0x1FFFFC00
+#define BF_CLKCTRL_SSP2_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_SSP2_RSRVD1)
+#define BM_CLKCTRL_SSP2_DIV_FRAC_EN	0x00000200
+#define BP_CLKCTRL_SSP2_DIV	0
+#define BM_CLKCTRL_SSP2_DIV	0x000001FF
+#define BF_CLKCTRL_SSP2_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SSP2_DIV)
+
+#define HW_CLKCTRL_SSP3	(0x000000c0)
+
+#define BM_CLKCTRL_SSP3_CLKGATE	0x80000000
+#define BM_CLKCTRL_SSP3_RSRVD2	0x40000000
+#define BM_CLKCTRL_SSP3_BUSY	0x20000000
+#define BP_CLKCTRL_SSP3_RSRVD1	10
+#define BM_CLKCTRL_SSP3_RSRVD1	0x1FFFFC00
+#define BF_CLKCTRL_SSP3_RSRVD1(v)  \
+		(((v) << 10) & BM_CLKCTRL_SSP3_RSRVD1)
+#define BM_CLKCTRL_SSP3_DIV_FRAC_EN	0x00000200
+#define BP_CLKCTRL_SSP3_DIV	0
+#define BM_CLKCTRL_SSP3_DIV	0x000001FF
+#define BF_CLKCTRL_SSP3_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SSP3_DIV)
+
+#define HW_CLKCTRL_GPMI	(0x000000d0)
+
+#define BM_CLKCTRL_GPMI_CLKGATE	0x80000000
+#define BM_CLKCTRL_GPMI_RSRVD2	0x40000000
+#define BM_CLKCTRL_GPMI_BUSY	0x20000000
+#define BP_CLKCTRL_GPMI_RSRVD1	11
+#define BM_CLKCTRL_GPMI_RSRVD1	0x1FFFF800
+#define BF_CLKCTRL_GPMI_RSRVD1(v)  \
+		(((v) << 11) & BM_CLKCTRL_GPMI_RSRVD1)
+#define BM_CLKCTRL_GPMI_DIV_FRAC_EN	0x00000400
+#define BP_CLKCTRL_GPMI_DIV	0
+#define BM_CLKCTRL_GPMI_DIV	0x000003FF
+#define BF_CLKCTRL_GPMI_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_GPMI_DIV)
+
+#define HW_CLKCTRL_SPDIF	(0x000000e0)
+
+#define BM_CLKCTRL_SPDIF_CLKGATE	0x80000000
+#define BP_CLKCTRL_SPDIF_RSRVD	0
+#define BM_CLKCTRL_SPDIF_RSRVD	0x7FFFFFFF
+#define BF_CLKCTRL_SPDIF_RSRVD(v)  \
+		(((v) << 0) & BM_CLKCTRL_SPDIF_RSRVD)
+
+#define HW_CLKCTRL_EMI	(0x000000f0)
+
+#define BM_CLKCTRL_EMI_CLKGATE	0x80000000
+#define BM_CLKCTRL_EMI_SYNC_MODE_EN	0x40000000
+#define BM_CLKCTRL_EMI_BUSY_REF_XTAL	0x20000000
+#define BM_CLKCTRL_EMI_BUSY_REF_EMI	0x10000000
+#define BM_CLKCTRL_EMI_BUSY_REF_CPU	0x08000000
+#define BM_CLKCTRL_EMI_BUSY_SYNC_MODE	0x04000000
+#define BP_CLKCTRL_EMI_RSRVD3	18
+#define BM_CLKCTRL_EMI_RSRVD3	0x03FC0000
+#define BF_CLKCTRL_EMI_RSRVD3(v)  \
+		(((v) << 18) & BM_CLKCTRL_EMI_RSRVD3)
+#define BM_CLKCTRL_EMI_BUSY_DCC_RESYNC	0x00020000
+#define BM_CLKCTRL_EMI_DCC_RESYNC_ENABLE	0x00010000
+#define BP_CLKCTRL_EMI_RSRVD2	12
+#define BM_CLKCTRL_EMI_RSRVD2	0x0000F000
+#define BF_CLKCTRL_EMI_RSRVD2(v)  \
+		(((v) << 12) & BM_CLKCTRL_EMI_RSRVD2)
+#define BP_CLKCTRL_EMI_DIV_XTAL	8
+#define BM_CLKCTRL_EMI_DIV_XTAL	0x00000F00
+#define BF_CLKCTRL_EMI_DIV_XTAL(v)  \
+		(((v) << 8) & BM_CLKCTRL_EMI_DIV_XTAL)
+#define BP_CLKCTRL_EMI_RSRVD1	6
+#define BM_CLKCTRL_EMI_RSRVD1	0x000000C0
+#define BF_CLKCTRL_EMI_RSRVD1(v)  \
+		(((v) << 6) & BM_CLKCTRL_EMI_RSRVD1)
+#define BP_CLKCTRL_EMI_DIV_EMI	0
+#define BM_CLKCTRL_EMI_DIV_EMI	0x0000003F
+#define BF_CLKCTRL_EMI_DIV_EMI(v)  \
+		(((v) << 0) & BM_CLKCTRL_EMI_DIV_EMI)
+
+#define HW_CLKCTRL_SAIF0	(0x00000100)
+
+#define BM_CLKCTRL_SAIF0_CLKGATE	0x80000000
+#define BM_CLKCTRL_SAIF0_RSRVD2	0x40000000
+#define BM_CLKCTRL_SAIF0_BUSY	0x20000000
+#define BP_CLKCTRL_SAIF0_RSRVD1	17
+#define BM_CLKCTRL_SAIF0_RSRVD1	0x1FFE0000
+#define BF_CLKCTRL_SAIF0_RSRVD1(v)  \
+		(((v) << 17) & BM_CLKCTRL_SAIF0_RSRVD1)
+#define BM_CLKCTRL_SAIF0_DIV_FRAC_EN	0x00010000
+#define BP_CLKCTRL_SAIF0_DIV	0
+#define BM_CLKCTRL_SAIF0_DIV	0x0000FFFF
+#define BF_CLKCTRL_SAIF0_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SAIF0_DIV)
+
+#define HW_CLKCTRL_SAIF1	(0x00000110)
+
+#define BM_CLKCTRL_SAIF1_CLKGATE	0x80000000
+#define BM_CLKCTRL_SAIF1_RSRVD2	0x40000000
+#define BM_CLKCTRL_SAIF1_BUSY	0x20000000
+#define BP_CLKCTRL_SAIF1_RSRVD1	17
+#define BM_CLKCTRL_SAIF1_RSRVD1	0x1FFE0000
+#define BF_CLKCTRL_SAIF1_RSRVD1(v)  \
+		(((v) << 17) & BM_CLKCTRL_SAIF1_RSRVD1)
+#define BM_CLKCTRL_SAIF1_DIV_FRAC_EN	0x00010000
+#define BP_CLKCTRL_SAIF1_DIV	0
+#define BM_CLKCTRL_SAIF1_DIV	0x0000FFFF
+#define BF_CLKCTRL_SAIF1_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_SAIF1_DIV)
+
+#define HW_CLKCTRL_DIS_LCDIF	(0x00000120)
+
+#define BM_CLKCTRL_DIS_LCDIF_CLKGATE	0x80000000
+#define BM_CLKCTRL_DIS_LCDIF_RSRVD2	0x40000000
+#define BM_CLKCTRL_DIS_LCDIF_BUSY	0x20000000
+#define BP_CLKCTRL_DIS_LCDIF_RSRVD1	14
+#define BM_CLKCTRL_DIS_LCDIF_RSRVD1	0x1FFFC000
+#define BF_CLKCTRL_DIS_LCDIF_RSRVD1(v)  \
+		(((v) << 14) & BM_CLKCTRL_DIS_LCDIF_RSRVD1)
+#define BM_CLKCTRL_DIS_LCDIF_DIV_FRAC_EN	0x00002000
+#define BP_CLKCTRL_DIS_LCDIF_DIV	0
+#define BM_CLKCTRL_DIS_LCDIF_DIV	0x00001FFF
+#define BF_CLKCTRL_DIS_LCDIF_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_DIS_LCDIF_DIV)
+
+#define HW_CLKCTRL_ETM	(0x00000130)
+
+#define BM_CLKCTRL_ETM_CLKGATE	0x80000000
+#define BM_CLKCTRL_ETM_RSRVD2	0x40000000
+#define BM_CLKCTRL_ETM_BUSY	0x20000000
+#define BP_CLKCTRL_ETM_RSRVD1	8
+#define BM_CLKCTRL_ETM_RSRVD1	0x1FFFFF00
+#define BF_CLKCTRL_ETM_RSRVD1(v)  \
+		(((v) << 8) & BM_CLKCTRL_ETM_RSRVD1)
+#define BM_CLKCTRL_ETM_DIV_FRAC_EN	0x00000080
+#define BP_CLKCTRL_ETM_DIV	0
+#define BM_CLKCTRL_ETM_DIV	0x0000007F
+#define BF_CLKCTRL_ETM_DIV(v)  \
+		(((v) << 0) & BM_CLKCTRL_ETM_DIV)
+
+#define HW_CLKCTRL_ENET	(0x00000140)
+
+#define BM_CLKCTRL_ENET_SLEEP	0x80000000
+#define BM_CLKCTRL_ENET_DISABLE	0x40000000
+#define BM_CLKCTRL_ENET_STATUS	0x20000000
+#define BM_CLKCTRL_ENET_RSRVD1	0x10000000
+#define BM_CLKCTRL_ENET_BUSY_TIME	0x08000000
+#define BP_CLKCTRL_ENET_DIV_TIME	21
+#define BM_CLKCTRL_ENET_DIV_TIME	0x07E00000
+#define BF_CLKCTRL_ENET_DIV_TIME(v)  \
+		(((v) << 21) & BM_CLKCTRL_ENET_DIV_TIME)
+#define BP_CLKCTRL_ENET_TIME_SEL	19
+#define BM_CLKCTRL_ENET_TIME_SEL	0x00180000
+#define BF_CLKCTRL_ENET_TIME_SEL(v)  \
+		(((v) << 19) & BM_CLKCTRL_ENET_TIME_SEL)
+#define BV_CLKCTRL_ENET_TIME_SEL__XTAL      0x0
+#define BV_CLKCTRL_ENET_TIME_SEL__PLL       0x1
+#define BV_CLKCTRL_ENET_TIME_SEL__RMII_CLK  0x2
+#define BV_CLKCTRL_ENET_TIME_SEL__UNDEFINED 0x3
+#define BM_CLKCTRL_ENET_CLK_OUT_EN	0x00040000
+#define BM_CLKCTRL_ENET_RESET_BY_SW_CHIP	0x00020000
+#define BM_CLKCTRL_ENET_RESET_BY_SW	0x00010000
+#define BP_CLKCTRL_ENET_RSRVD0	0
+#define BM_CLKCTRL_ENET_RSRVD0	0x0000FFFF
+#define BF_CLKCTRL_ENET_RSRVD0(v)  \
+		(((v) << 0) & BM_CLKCTRL_ENET_RSRVD0)
+#define BM_CLKCTRL_ENET_1588_40MHZ	0x01880000
+
+#define HW_CLKCTRL_HSADC	(0x00000150)
+
+#define BM_CLKCTRL_HSADC_RSRVD2	0x80000000
+#define BM_CLKCTRL_HSADC_RESETB	0x40000000
+#define BP_CLKCTRL_HSADC_FREQDIV	28
+#define BM_CLKCTRL_HSADC_FREQDIV	0x30000000
+#define BF_CLKCTRL_HSADC_FREQDIV(v)  \
+		(((v) << 28) & BM_CLKCTRL_HSADC_FREQDIV)
+#define BP_CLKCTRL_HSADC_RSRVD1	0
+#define BM_CLKCTRL_HSADC_RSRVD1	0x0FFFFFFF
+#define BF_CLKCTRL_HSADC_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_HSADC_RSRVD1)
+
+#define HW_CLKCTRL_FLEXCAN	(0x00000160)
+
+#define BM_CLKCTRL_FLEXCAN_RSRVD2	0x80000000
+#define BM_CLKCTRL_FLEXCAN_STOP_CAN0	0x40000000
+#define BM_CLKCTRL_FLEXCAN_CAN0_STATUS	0x20000000
+#define BM_CLKCTRL_FLEXCAN_STOP_CAN1	0x10000000
+#define BM_CLKCTRL_FLEXCAN_CAN1_STATUS	0x08000000
+#define BP_CLKCTRL_FLEXCAN_RSRVD1	0
+#define BM_CLKCTRL_FLEXCAN_RSRVD1	0x07FFFFFF
+#define BF_CLKCTRL_FLEXCAN_RSRVD1(v)  \
+		(((v) << 0) & BM_CLKCTRL_FLEXCAN_RSRVD1)
+
+#define HW_CLKCTRL_FRAC0	(0x000001b0)
+#define HW_CLKCTRL_FRAC0_SET	(0x000001b4)
+#define HW_CLKCTRL_FRAC0_CLR	(0x000001b8)
+#define HW_CLKCTRL_FRAC0_TOG	(0x000001bc)
+
+#define BM_CLKCTRL_FRAC0_CLKGATEIO0	0x80000000
+#define BM_CLKCTRL_FRAC0_IO0_STABLE	0x40000000
+#define BP_CLKCTRL_FRAC0_IO0FRAC	24
+#define BM_CLKCTRL_FRAC0_IO0FRAC	0x3F000000
+#define BF_CLKCTRL_FRAC0_IO0FRAC(v)  \
+		(((v) << 24) & BM_CLKCTRL_FRAC0_IO0FRAC)
+#define BM_CLKCTRL_FRAC0_CLKGATEIO1	0x00800000
+#define BM_CLKCTRL_FRAC0_IO1_STABLE	0x00400000
+#define BP_CLKCTRL_FRAC0_IO1FRAC	16
+#define BM_CLKCTRL_FRAC0_IO1FRAC	0x003F0000
+#define BF_CLKCTRL_FRAC0_IO1FRAC(v)  \
+		(((v) << 16) & BM_CLKCTRL_FRAC0_IO1FRAC)
+#define BM_CLKCTRL_FRAC0_CLKGATEEMI	0x00008000
+#define BM_CLKCTRL_FRAC0_EMI_STABLE	0x00004000
+#define BP_CLKCTRL_FRAC0_EMIFRAC	8
+#define BM_CLKCTRL_FRAC0_EMIFRAC	0x00003F00
+#define BF_CLKCTRL_FRAC0_EMIFRAC(v)  \
+		(((v) << 8) & BM_CLKCTRL_FRAC0_EMIFRAC)
+#define BM_CLKCTRL_FRAC0_CLKGATECPU	0x00000080
+#define BM_CLKCTRL_FRAC0_CPU_STABLE	0x00000040
+#define BP_CLKCTRL_FRAC0_CPUFRAC	0
+#define BM_CLKCTRL_FRAC0_CPUFRAC	0x0000003F
+#define BF_CLKCTRL_FRAC0_CPUFRAC(v)  \
+		(((v) << 0) & BM_CLKCTRL_FRAC0_CPUFRAC)
+
+#define HW_CLKCTRL_FRAC1	(0x000001c0)
+#define HW_CLKCTRL_FRAC1_SET	(0x000001c4)
+#define HW_CLKCTRL_FRAC1_CLR	(0x000001c8)
+#define HW_CLKCTRL_FRAC1_TOG	(0x000001cc)
+
+#define BP_CLKCTRL_FRAC1_RSRVD2	24
+#define BM_CLKCTRL_FRAC1_RSRVD2	0xFF000000
+#define BF_CLKCTRL_FRAC1_RSRVD2(v) \
+		(((v) << 24) & BM_CLKCTRL_FRAC1_RSRVD2)
+#define BM_CLKCTRL_FRAC1_CLKGATEGPMI	0x00800000
+#define BM_CLKCTRL_FRAC1_GPMI_STABLE	0x00400000
+#define BP_CLKCTRL_FRAC1_GPMIFRAC	16
+#define BM_CLKCTRL_FRAC1_GPMIFRAC	0x003F0000
+#define BF_CLKCTRL_FRAC1_GPMIFRAC(v)  \
+		(((v) << 16) & BM_CLKCTRL_FRAC1_GPMIFRAC)
+#define BM_CLKCTRL_FRAC1_CLKGATEHSADC	0x00008000
+#define BM_CLKCTRL_FRAC1_HSADC_STABLE	0x00004000
+#define BP_CLKCTRL_FRAC1_HSADCFRAC	8
+#define BM_CLKCTRL_FRAC1_HSADCFRAC	0x00003F00
+#define BF_CLKCTRL_FRAC1_HSADCFRAC(v)  \
+		(((v) << 8) & BM_CLKCTRL_FRAC1_HSADCFRAC)
+#define BM_CLKCTRL_FRAC1_CLKGATEPIX	0x00000080
+#define BM_CLKCTRL_FRAC1_PIX_STABLE	0x00000040
+#define BP_CLKCTRL_FRAC1_PIXFRAC	0
+#define BM_CLKCTRL_FRAC1_PIXFRAC	0x0000003F
+#define BF_CLKCTRL_FRAC1_PIXFRAC(v)  \
+		(((v) << 0) & BM_CLKCTRL_FRAC1_PIXFRAC)
+
+#define HW_CLKCTRL_CLKSEQ	(0x000001d0)
+#define HW_CLKCTRL_CLKSEQ_SET	(0x000001d4)
+#define HW_CLKCTRL_CLKSEQ_CLR	(0x000001d8)
+#define HW_CLKCTRL_CLKSEQ_TOG	(0x000001dc)
+
+#define BP_CLKCTRL_CLKSEQ_RSRVD0	19
+#define BM_CLKCTRL_CLKSEQ_RSRVD0	0xFFF80000
+#define BF_CLKCTRL_CLKSEQ_RSRVD0(v) \
+		(((v) << 19) & BM_CLKCTRL_CLKSEQ_RSRVD0)
+#define BM_CLKCTRL_CLKSEQ_BYPASS_CPU	0x00040000
+#define BP_CLKCTRL_CLKSEQ_RSRVD1	15
+#define BM_CLKCTRL_CLKSEQ_RSRVD1	0x00038000
+#define BF_CLKCTRL_CLKSEQ_RSRVD1(v)  \
+		(((v) << 15) & BM_CLKCTRL_CLKSEQ_RSRVD1)
+#define BM_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF	0x00004000
+#define BV_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF__BYPASS 0x1
+#define BV_CLKCTRL_CLKSEQ_BYPASS_DIS_LCDIF__PFD    0x0
+#define BP_CLKCTRL_CLKSEQ_RSRVD2	9
+#define BM_CLKCTRL_CLKSEQ_RSRVD2	0x00003E00
+#define BF_CLKCTRL_CLKSEQ_RSRVD2(v)  \
+		(((v) << 9) & BM_CLKCTRL_CLKSEQ_RSRVD2)
+#define BM_CLKCTRL_CLKSEQ_BYPASS_ETM	0x00000100
+#define BM_CLKCTRL_CLKSEQ_BYPASS_EMI	0x00000080
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP3	0x00000040
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP2	0x00000020
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP1	0x00000010
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SSP0	0x00000008
+#define BM_CLKCTRL_CLKSEQ_BYPASS_GPMI	0x00000004
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF1	0x00000002
+#define BM_CLKCTRL_CLKSEQ_BYPASS_SAIF0	0x00000001
+
+#define HW_CLKCTRL_RESET	(0x000001e0)
+
+#define BP_CLKCTRL_RESET_RSRVD	6
+#define BM_CLKCTRL_RESET_RSRVD	0xFFFFFFC0
+#define BF_CLKCTRL_RESET_RSRVD(v) \
+		(((v) << 6) & BM_CLKCTRL_RESET_RSRVD)
+#define BM_CLKCTRL_RESET_WDOG_POR_DISABLE	0x00000020
+#define BM_CLKCTRL_RESET_EXTERNAL_RESET_ENABLE	0x00000010
+#define BM_CLKCTRL_RESET_THERMAL_RESET_ENABLE	0x00000008
+#define BM_CLKCTRL_RESET_THERMAL_RESET_DEFAULT	0x00000004
+#define BM_CLKCTRL_RESET_CHIP	0x00000002
+#define BM_CLKCTRL_RESET_DIG	0x00000001
+
+#define HW_CLKCTRL_STATUS	(0x000001f0)
+
+#define BP_CLKCTRL_STATUS_CPU_LIMIT	30
+#define BM_CLKCTRL_STATUS_CPU_LIMIT	0xC0000000
+#define BF_CLKCTRL_STATUS_CPU_LIMIT(v) \
+		(((v) << 30) & BM_CLKCTRL_STATUS_CPU_LIMIT)
+#define BP_CLKCTRL_STATUS_RSRVD	0
+#define BM_CLKCTRL_STATUS_RSRVD	0x3FFFFFFF
+#define BF_CLKCTRL_STATUS_RSRVD(v)  \
+		(((v) << 0) & BM_CLKCTRL_STATUS_RSRVD)
+
+#define HW_CLKCTRL_VERSION	(0x00000200)
+
+#define BP_CLKCTRL_VERSION_MAJOR	24
+#define BM_CLKCTRL_VERSION_MAJOR	0xFF000000
+#define BF_CLKCTRL_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_CLKCTRL_VERSION_MAJOR)
+#define BP_CLKCTRL_VERSION_MINOR	16
+#define BM_CLKCTRL_VERSION_MINOR	0x00FF0000
+#define BF_CLKCTRL_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_CLKCTRL_VERSION_MINOR)
+#define BP_CLKCTRL_VERSION_STEP	0
+#define BM_CLKCTRL_VERSION_STEP	0x0000FFFF
+#define BF_CLKCTRL_VERSION_STEP(v)  \
+		(((v) << 0) & BM_CLKCTRL_VERSION_STEP)
+#endif /* __ARCH_ARM___CLKCTRL_H */
diff --git a/arch/arm/mach-mx28/regs-digctl.h b/arch/arm/mach-mx28/regs-digctl.h
new file mode 100644
index 0000000..6ebda07
--- /dev/null
+++ b/arch/arm/mach-mx28/regs-digctl.h
@@ -0,0 +1,1022 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ARCH_ARM___DIGCTL_H
+#define __ARCH_ARM___DIGCTL_H
+
+
+#define HW_DIGCTL_CTRL	(0x00000000)
+#define HW_DIGCTL_CTRL_SET	(0x00000004)
+#define HW_DIGCTL_CTRL_CLR	(0x00000008)
+#define HW_DIGCTL_CTRL_TOG	(0x0000000c)
+
+#define BM_DIGCTL_CTRL_RSVD3	0x80000000
+#define BM_DIGCTL_CTRL_XTAL24M_GATE	0x40000000
+#define BP_DIGCTL_CTRL_RSVD2	25
+#define BM_DIGCTL_CTRL_RSVD2	0x3E000000
+#define BF_DIGCTL_CTRL_RSVD2(v)  \
+		(((v) << 25) & BM_DIGCTL_CTRL_RSVD2)
+#define BM_DIGCTL_CTRL_USB1_OVERCURRENT_ENABLE	0x01000000
+#define BM_DIGCTL_CTRL_USB0_OVERCURRENT_ENABLE	0x00800000
+#define BM_DIGCTL_CTRL_USB1_OVERCURRENT_POL	0x00400000
+#define BM_DIGCTL_CTRL_USB0_OVERCURRENT_POL	0x00200000
+#define BM_DIGCTL_CTRL_USB1_TESTMODE	0x00100000
+#define BM_DIGCTL_CTRL_USB0_TESTMODE	0x00080000
+#define BM_DIGCTL_CTRL_ANALOG_TESTMODE	0x00040000
+#define BM_DIGCTL_CTRL_DIGITAL_TESTMODE	0x00020000
+#define BM_DIGCTL_CTRL_USB1_CLKGATE	0x00010000
+#define BV_DIGCTL_CTRL_USB1_CLKGATE__RUN     0x0
+#define BV_DIGCTL_CTRL_USB1_CLKGATE__NO_CLKS 0x1
+#define BM_DIGCTL_CTRL_SAIF_LOOPBACK	0x00008000
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_SAIF_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_DUART_LOOPBACK	0x00004000
+#define BV_DIGCTL_CTRL_DUART_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_DUART_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_AUART01_LOOPBACK	0x00002000
+#define BV_DIGCTL_CTRL_AUART01_LOOPBACK__NORMAL 0x0
+#define BV_DIGCTL_CTRL_AUART01_LOOPBACK__LOOPIT 0x1
+#define BM_DIGCTL_CTRL_RSVD1	0x00001000
+#define BP_DIGCTL_CTRL_SAIF_CLKMUX_SEL	10
+#define BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL	0x00000C00
+#define BF_DIGCTL_CTRL_SAIF_CLKMUX_SEL(v)  \
+		(((v) << 10) & BM_DIGCTL_CTRL_SAIF_CLKMUX_SEL)
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__DIRECT         0x0
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CROSSINPUT     0x1
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CLKSRCSAIF0PIN 0x2
+#define BV_DIGCTL_CTRL_SAIF_CLKMUX_SEL__CLKSRCSAIF1PIN 0x3
+#define BP_DIGCTL_CTRL_RSVD0	4
+#define BM_DIGCTL_CTRL_RSVD0	0x000003F0
+#define BF_DIGCTL_CTRL_RSVD0(v)  \
+		(((v) << 4) & BM_DIGCTL_CTRL_RSVD0)
+#define BM_DIGCTL_CTRL_DEBUG_DISABLE	0x00000008
+#define BM_DIGCTL_CTRL_USB0_CLKGATE	0x00000004
+#define BV_DIGCTL_CTRL_USB0_CLKGATE__RUN     0x0
+#define BV_DIGCTL_CTRL_USB0_CLKGATE__NO_CLKS 0x1
+#define BM_DIGCTL_CTRL_JTAG_SHIELD	0x00000002
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__NORMAL     0x0
+#define BV_DIGCTL_CTRL_JTAG_SHIELD__SHIELDS_UP 0x1
+#define BM_DIGCTL_CTRL_LATCH_ENTROPY	0x00000001
+
+#define HW_DIGCTL_STATUS	(0x00000010)
+#define HW_DIGCTL_STATUS_SET	(0x00000014)
+#define HW_DIGCTL_STATUS_CLR	(0x00000018)
+#define HW_DIGCTL_STATUS_TOG	(0x0000001c)
+
+#define BM_DIGCTL_STATUS_USB0_HS_PRESENT	0x80000000
+#define BM_DIGCTL_STATUS_USB0_OTG_PRESENT	0x40000000
+#define BM_DIGCTL_STATUS_USB0_HOST_PRESENT	0x20000000
+#define BM_DIGCTL_STATUS_USB0_DEVICE_PRESENT	0x10000000
+#define BM_DIGCTL_STATUS_USB1_HS_PRESENT	0x08000000
+#define BM_DIGCTL_STATUS_USB1_OTG_PRESENT	0x04000000
+#define BM_DIGCTL_STATUS_USB1_HOST_PRESENT	0x02000000
+#define BM_DIGCTL_STATUS_USB1_DEVICE_PRESENT	0x01000000
+#define BP_DIGCTL_STATUS_RSVD0	5
+#define BM_DIGCTL_STATUS_RSVD0	0x00FFFFE0
+#define BF_DIGCTL_STATUS_RSVD0(v)  \
+		(((v) << 5) & BM_DIGCTL_STATUS_RSVD0)
+#define BM_DIGCTL_STATUS_JTAG_IN_USE	0x00000010
+#define BP_DIGCTL_STATUS_PACKAGE_TYPE	1
+#define BM_DIGCTL_STATUS_PACKAGE_TYPE	0x0000000E
+#define BF_DIGCTL_STATUS_PACKAGE_TYPE(v)  \
+		(((v) << 1) & BM_DIGCTL_STATUS_PACKAGE_TYPE)
+#define BM_DIGCTL_STATUS_WRITTEN	0x00000001
+
+#define HW_DIGCTL_HCLKCOUNT	(0x00000020)
+#define HW_DIGCTL_HCLKCOUNT_SET	(0x00000024)
+#define HW_DIGCTL_HCLKCOUNT_CLR	(0x00000028)
+#define HW_DIGCTL_HCLKCOUNT_TOG	(0x0000002c)
+
+#define BP_DIGCTL_HCLKCOUNT_COUNT	0
+#define BM_DIGCTL_HCLKCOUNT_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_HCLKCOUNT_COUNT(v)	(v)
+
+#define HW_DIGCTL_RAMCTRL	(0x00000030)
+#define HW_DIGCTL_RAMCTRL_SET	(0x00000034)
+#define HW_DIGCTL_RAMCTRL_CLR	(0x00000038)
+#define HW_DIGCTL_RAMCTRL_TOG	(0x0000003c)
+
+#define BP_DIGCTL_RAMCTRL_RSVD1	15
+#define BM_DIGCTL_RAMCTRL_RSVD1	0xFFFF8000
+#define BF_DIGCTL_RAMCTRL_RSVD1(v) \
+		(((v) << 15) & BM_DIGCTL_RAMCTRL_RSVD1)
+#define BM_DIGCTL_RAMCTRL_TBYPASS	0x00004000
+#define BM_DIGCTL_RAMCTRL_DEBUG_ENABLE	0x00002000
+#define BP_DIGCTL_RAMCTRL_DEBUG_CODE	8
+#define BM_DIGCTL_RAMCTRL_DEBUG_CODE	0x00001F00
+#define BF_DIGCTL_RAMCTRL_DEBUG_CODE(v)  \
+		(((v) << 8) & BM_DIGCTL_RAMCTRL_DEBUG_CODE)
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__NORMAL 0x0
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY1 0x4
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY2 0x5
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY3 0x6
+#define BV_DIGCTL_RAMCTRL_DEBUG_CODE__DELAY4 0x7
+#define BP_DIGCTL_RAMCTRL_RSVD0	0
+#define BM_DIGCTL_RAMCTRL_RSVD0	0x000000FF
+#define BF_DIGCTL_RAMCTRL_RSVD0(v)  \
+		(((v) << 0) & BM_DIGCTL_RAMCTRL_RSVD0)
+
+#define HW_DIGCTL_EMI_STATUS	(0x00000040)
+#define HW_DIGCTL_EMI_STATUS_SET	(0x00000044)
+#define HW_DIGCTL_EMI_STATUS_CLR	(0x00000048)
+#define HW_DIGCTL_EMI_STATUS_TOG	(0x0000004c)
+
+#define BP_DIGCTL_EMI_STATUS_RSVD0	5
+#define BM_DIGCTL_EMI_STATUS_RSVD0	0xFFFFFFE0
+#define BF_DIGCTL_EMI_STATUS_RSVD0(v) \
+		(((v) << 5) & BM_DIGCTL_EMI_STATUS_RSVD0)
+#define BP_DIGCTL_EMI_STATUS_POWER_MODE	0
+#define BM_DIGCTL_EMI_STATUS_POWER_MODE	0x0000001F
+#define BF_DIGCTL_EMI_STATUS_POWER_MODE(v)  \
+		(((v) << 0) & BM_DIGCTL_EMI_STATUS_POWER_MODE)
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM5    0x1
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM4    0x2
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM3    0x4
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM2    0x8
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__PM1    0x10
+#define BV_DIGCTL_EMI_STATUS_POWER_MODE__NORMAL 0x0
+
+#define HW_DIGCTL_READ_MARGIN	(0x00000050)
+#define HW_DIGCTL_READ_MARGIN_SET	(0x00000054)
+#define HW_DIGCTL_READ_MARGIN_CLR	(0x00000058)
+#define HW_DIGCTL_READ_MARGIN_TOG	(0x0000005c)
+
+#define BP_DIGCTL_READ_MARGIN_RSVD0	4
+#define BM_DIGCTL_READ_MARGIN_RSVD0	0xFFFFFFF0
+#define BF_DIGCTL_READ_MARGIN_RSVD0(v) \
+		(((v) << 4) & BM_DIGCTL_READ_MARGIN_RSVD0)
+#define BP_DIGCTL_READ_MARGIN_ROM	0
+#define BM_DIGCTL_READ_MARGIN_ROM	0x0000000F
+#define BF_DIGCTL_READ_MARGIN_ROM(v)  \
+		(((v) << 0) & BM_DIGCTL_READ_MARGIN_ROM)
+
+#define HW_DIGCTL_WRITEONCE	(0x00000060)
+
+#define BP_DIGCTL_WRITEONCE_BITS	0
+#define BM_DIGCTL_WRITEONCE_BITS	0xFFFFFFFF
+#define BF_DIGCTL_WRITEONCE_BITS(v)	(v)
+
+#define HW_DIGCTL_BIST_CTL	(0x00000070)
+#define HW_DIGCTL_BIST_CTL_SET	(0x00000074)
+#define HW_DIGCTL_BIST_CTL_CLR	(0x00000078)
+#define HW_DIGCTL_BIST_CTL_TOG	(0x0000007c)
+
+#define BM_DIGCTL_BIST_CTL_BIST_TESTMODE	0x80000000
+#define BM_DIGCTL_BIST_CTL_BIST_RESETN	0x40000000
+#define BM_DIGCTL_BIST_CTL_BIST_DEBUGZ	0x20000000
+#define BM_DIGCTL_BIST_CTL_BIST_CHECKB	0x10000000
+#define BM_DIGCTL_BIST_CTL_BIST_RESUME	0x08000000
+#define BP_DIGCTL_BIST_CTL_RSVD0	15
+#define BM_DIGCTL_BIST_CTL_RSVD0	0x07FF8000
+#define BF_DIGCTL_BIST_CTL_RSVD0(v)  \
+		(((v) << 15) & BM_DIGCTL_BIST_CTL_RSVD0)
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_RETENTION	0x00004000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_PASS	0x00002000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_FAIL	0x00001000
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_DONE	0x00000800
+#define BM_DIGCTL_BIST_CTL_OCRAM_BIST_START	0x00000400
+#define BM_DIGCTL_BIST_CTL_PXP_BIST_START	0x00000200
+#define BM_DIGCTL_BIST_CTL_LCDIF_BIST_START	0x00000100
+#define BM_DIGCTL_BIST_CTL_DCP_BIST_START	0x00000080
+#define BM_DIGCTL_BIST_CTL_ENET_BIST_START	0x00000040
+#define BM_DIGCTL_BIST_CTL_USB1_BIST_START	0x00000020
+#define BM_DIGCTL_BIST_CTL_USB0_BIST_START	0x00000010
+#define BM_DIGCTL_BIST_CTL_DMA1_BIST_START	0x00000008
+#define BM_DIGCTL_BIST_CTL_DMA0_BIST_START	0x00000004
+#define BM_DIGCTL_BIST_CTL_CACHE_BIST_START	0x00000002
+#define BM_DIGCTL_BIST_CTL_CAN_BIST_START	0x00000001
+
+#define HW_DIGCTL_BIST_STATUS	(0x00000080)
+#define HW_DIGCTL_BIST_STATUS_SET	(0x00000084)
+#define HW_DIGCTL_BIST_STATUS_CLR	(0x00000088)
+#define HW_DIGCTL_BIST_STATUS_TOG	(0x0000008c)
+
+#define BP_DIGCTL_BIST_STATUS_RSVD0	30
+#define BM_DIGCTL_BIST_STATUS_RSVD0	0xC0000000
+#define BF_DIGCTL_BIST_STATUS_RSVD0(v) \
+		(((v) << 30) & BM_DIGCTL_BIST_STATUS_RSVD0)
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_RETENTION	0x20000000
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_RETENTION	0x10000000
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_RETENTION	0x08000000
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_RETENTION	0x04000000
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_RETENTION	0x02000000
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_RETENTION	0x01000000
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_RETENTION	0x00800000
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_RETENTION	0x00400000
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_RETENTION	0x00200000
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_RETENTION	0x00100000
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_FAIL	0x00080000
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_FAIL	0x00040000
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_FAIL	0x00020000
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_FAIL	0x00010000
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_FAIL	0x00008000
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_FAIL	0x00004000
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_FAIL	0x00002000
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_FAIL	0x00001000
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_FAIL	0x00000800
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_FAIL	0x00000400
+#define BM_DIGCTL_BIST_STATUS_PXP_BIST_DONE	0x00000200
+#define BM_DIGCTL_BIST_STATUS_LCDIF_BIST_DONE	0x00000100
+#define BM_DIGCTL_BIST_STATUS_DCP_BIST_DONE	0x00000080
+#define BM_DIGCTL_BIST_STATUS_ENET_BIST_DONE	0x00000040
+#define BM_DIGCTL_BIST_STATUS_USB1_BIST_DONE	0x00000020
+#define BM_DIGCTL_BIST_STATUS_USB0_BIST_DONE	0x00000010
+#define BM_DIGCTL_BIST_STATUS_DMA1_BIST_DONE	0x00000008
+#define BM_DIGCTL_BIST_STATUS_DMA0_BIST_DONE	0x00000004
+#define BM_DIGCTL_BIST_STATUS_CACHE_BIST_DONE	0x00000002
+#define BM_DIGCTL_BIST_STATUS_CAN_BIST_DONE	0x00000001
+
+#define HW_DIGCTL_ENTROPY	(0x00000090)
+
+#define BP_DIGCTL_ENTROPY_VALUE	0
+#define BM_DIGCTL_ENTROPY_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_VALUE(v)	(v)
+
+#define HW_DIGCTL_ENTROPY_LATCHED	(0x000000a0)
+
+#define BP_DIGCTL_ENTROPY_LATCHED_VALUE	0
+#define BM_DIGCTL_ENTROPY_LATCHED_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_ENTROPY_LATCHED_VALUE(v)	(v)
+
+#define HW_DIGCTL_MICROSECONDS	(0x000000c0)
+#define HW_DIGCTL_MICROSECONDS_SET	(0x000000c4)
+#define HW_DIGCTL_MICROSECONDS_CLR	(0x000000c8)
+#define HW_DIGCTL_MICROSECONDS_TOG	(0x000000cc)
+
+#define BP_DIGCTL_MICROSECONDS_VALUE	0
+#define BM_DIGCTL_MICROSECONDS_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_MICROSECONDS_VALUE(v)	(v)
+
+#define HW_DIGCTL_DBGRD	(0x000000d0)
+
+#define BP_DIGCTL_DBGRD_COMPLEMENT	0
+#define BM_DIGCTL_DBGRD_COMPLEMENT	0xFFFFFFFF
+#define BF_DIGCTL_DBGRD_COMPLEMENT(v)	(v)
+
+#define HW_DIGCTL_DBG	(0x000000e0)
+
+#define BP_DIGCTL_DBG_VALUE	0
+#define BM_DIGCTL_DBG_VALUE	0xFFFFFFFF
+#define BF_DIGCTL_DBG_VALUE(v)	(v)
+
+#define HW_DIGCTL_USB_LOOPBACK	(0x00000100)
+#define HW_DIGCTL_USB_LOOPBACK_SET	(0x00000104)
+#define HW_DIGCTL_USB_LOOPBACK_CLR	(0x00000108)
+#define HW_DIGCTL_USB_LOOPBACK_TOG	(0x0000010c)
+
+#define BP_DIGCTL_USB_LOOPBACK_RSVD0	18
+#define BM_DIGCTL_USB_LOOPBACK_RSVD0	0xFFFC0000
+#define BF_DIGCTL_USB_LOOPBACK_RSVD0(v) \
+		(((v) << 18) & BM_DIGCTL_USB_LOOPBACK_RSVD0)
+#define BM_DIGCTL_USB_LOOPBACK_USB1_TST_START	0x00020000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_LS	0x00010000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_HS	0x00008000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_EN	0x00004000
+#define BM_DIGCTL_USB_LOOPBACK_TSTI1_TX_HIZ	0x00002000
+#define BM_DIGCTL_USB_LOOPBACK_UTMI1_DIG_TST1	0x00001000
+#define BM_DIGCTL_USB_LOOPBACK_UTMI1_DIG_TST0	0x00000800
+#define BM_DIGCTL_USB_LOOPBACK_USB0_TST_START	0x00000400
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_LS	0x00000200
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_HS	0x00000100
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_EN	0x00000080
+#define BM_DIGCTL_USB_LOOPBACK_TSTI0_TX_HIZ	0x00000040
+#define BM_DIGCTL_USB_LOOPBACK_UTMI0_DIG_TST1	0x00000020
+#define BM_DIGCTL_USB_LOOPBACK_UTMI0_DIG_TST0	0x00000010
+#define BM_DIGCTL_USB_LOOPBACK_UTMO1_DIG_TST1	0x00000008
+#define BM_DIGCTL_USB_LOOPBACK_UTMO1_DIG_TST0	0x00000004
+#define BM_DIGCTL_USB_LOOPBACK_UTMO0_DIG_TST1	0x00000002
+#define BM_DIGCTL_USB_LOOPBACK_UTMO0_DIG_TST0	0x00000001
+
+#define HW_DIGCTL_OCRAM_STATUS0	(0x00000110)
+#define HW_DIGCTL_OCRAM_STATUS0_SET	(0x00000114)
+#define HW_DIGCTL_OCRAM_STATUS0_CLR	(0x00000118)
+#define HW_DIGCTL_OCRAM_STATUS0_TOG	(0x0000011c)
+
+#define BP_DIGCTL_OCRAM_STATUS0_FAILDATA00	0
+#define BM_DIGCTL_OCRAM_STATUS0_FAILDATA00	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS0_FAILDATA00(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS1	(0x00000120)
+#define HW_DIGCTL_OCRAM_STATUS1_SET	(0x00000124)
+#define HW_DIGCTL_OCRAM_STATUS1_CLR	(0x00000128)
+#define HW_DIGCTL_OCRAM_STATUS1_TOG	(0x0000012c)
+
+#define BP_DIGCTL_OCRAM_STATUS1_FAILDATA01	0
+#define BM_DIGCTL_OCRAM_STATUS1_FAILDATA01	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS1_FAILDATA01(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS2	(0x00000130)
+#define HW_DIGCTL_OCRAM_STATUS2_SET	(0x00000134)
+#define HW_DIGCTL_OCRAM_STATUS2_CLR	(0x00000138)
+#define HW_DIGCTL_OCRAM_STATUS2_TOG	(0x0000013c)
+
+#define BP_DIGCTL_OCRAM_STATUS2_FAILDATA10	0
+#define BM_DIGCTL_OCRAM_STATUS2_FAILDATA10	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS2_FAILDATA10(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS3	(0x00000140)
+#define HW_DIGCTL_OCRAM_STATUS3_SET	(0x00000144)
+#define HW_DIGCTL_OCRAM_STATUS3_CLR	(0x00000148)
+#define HW_DIGCTL_OCRAM_STATUS3_TOG	(0x0000014c)
+
+#define BP_DIGCTL_OCRAM_STATUS3_FAILDATA11	0
+#define BM_DIGCTL_OCRAM_STATUS3_FAILDATA11	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS3_FAILDATA11(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS4	(0x00000150)
+#define HW_DIGCTL_OCRAM_STATUS4_SET	(0x00000154)
+#define HW_DIGCTL_OCRAM_STATUS4_CLR	(0x00000158)
+#define HW_DIGCTL_OCRAM_STATUS4_TOG	(0x0000015c)
+
+#define BP_DIGCTL_OCRAM_STATUS4_FAILDATA20	0
+#define BM_DIGCTL_OCRAM_STATUS4_FAILDATA20	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS4_FAILDATA20(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS5	(0x00000160)
+#define HW_DIGCTL_OCRAM_STATUS5_SET	(0x00000164)
+#define HW_DIGCTL_OCRAM_STATUS5_CLR	(0x00000168)
+#define HW_DIGCTL_OCRAM_STATUS5_TOG	(0x0000016c)
+
+#define BP_DIGCTL_OCRAM_STATUS5_FAILDATA21	0
+#define BM_DIGCTL_OCRAM_STATUS5_FAILDATA21	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS5_FAILDATA21(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS6	(0x00000170)
+#define HW_DIGCTL_OCRAM_STATUS6_SET	(0x00000174)
+#define HW_DIGCTL_OCRAM_STATUS6_CLR	(0x00000178)
+#define HW_DIGCTL_OCRAM_STATUS6_TOG	(0x0000017c)
+
+#define BP_DIGCTL_OCRAM_STATUS6_FAILDATA30	0
+#define BM_DIGCTL_OCRAM_STATUS6_FAILDATA30	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS6_FAILDATA30(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS7	(0x00000180)
+#define HW_DIGCTL_OCRAM_STATUS7_SET	(0x00000184)
+#define HW_DIGCTL_OCRAM_STATUS7_CLR	(0x00000188)
+#define HW_DIGCTL_OCRAM_STATUS7_TOG	(0x0000018c)
+
+#define BP_DIGCTL_OCRAM_STATUS7_FAILDATA31	0
+#define BM_DIGCTL_OCRAM_STATUS7_FAILDATA31	0xFFFFFFFF
+#define BF_DIGCTL_OCRAM_STATUS7_FAILDATA31(v)	(v)
+
+#define HW_DIGCTL_OCRAM_STATUS8	(0x00000190)
+#define HW_DIGCTL_OCRAM_STATUS8_SET	(0x00000194)
+#define HW_DIGCTL_OCRAM_STATUS8_CLR	(0x00000198)
+#define HW_DIGCTL_OCRAM_STATUS8_TOG	(0x0000019c)
+
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR01	16
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR01	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR01(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR01)
+#define BP_DIGCTL_OCRAM_STATUS8_FAILADDR00	0
+#define BM_DIGCTL_OCRAM_STATUS8_FAILADDR00	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS8_FAILADDR00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS8_FAILADDR00)
+
+#define HW_DIGCTL_OCRAM_STATUS9	(0x000001a0)
+#define HW_DIGCTL_OCRAM_STATUS9_SET	(0x000001a4)
+#define HW_DIGCTL_OCRAM_STATUS9_CLR	(0x000001a8)
+#define HW_DIGCTL_OCRAM_STATUS9_TOG	(0x000001ac)
+
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR11	16
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR11	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR11(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR11)
+#define BP_DIGCTL_OCRAM_STATUS9_FAILADDR10	0
+#define BM_DIGCTL_OCRAM_STATUS9_FAILADDR10	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS9_FAILADDR10(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS9_FAILADDR10)
+
+#define HW_DIGCTL_OCRAM_STATUS10	(0x000001b0)
+#define HW_DIGCTL_OCRAM_STATUS10_SET	(0x000001b4)
+#define HW_DIGCTL_OCRAM_STATUS10_CLR	(0x000001b8)
+#define HW_DIGCTL_OCRAM_STATUS10_TOG	(0x000001bc)
+
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR21	16
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR21	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR21(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR21)
+#define BP_DIGCTL_OCRAM_STATUS10_FAILADDR20	0
+#define BM_DIGCTL_OCRAM_STATUS10_FAILADDR20	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS10_FAILADDR20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS10_FAILADDR20)
+
+#define HW_DIGCTL_OCRAM_STATUS11	(0x000001c0)
+#define HW_DIGCTL_OCRAM_STATUS11_SET	(0x000001c4)
+#define HW_DIGCTL_OCRAM_STATUS11_CLR	(0x000001c8)
+#define HW_DIGCTL_OCRAM_STATUS11_TOG	(0x000001cc)
+
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR31	16
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR31	0xFFFF0000
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR31(v) \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR31)
+#define BP_DIGCTL_OCRAM_STATUS11_FAILADDR30	0
+#define BM_DIGCTL_OCRAM_STATUS11_FAILADDR30	0x0000FFFF
+#define BF_DIGCTL_OCRAM_STATUS11_FAILADDR30(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS11_FAILADDR30)
+
+#define HW_DIGCTL_OCRAM_STATUS12	(0x000001d0)
+#define HW_DIGCTL_OCRAM_STATUS12_SET	(0x000001d4)
+#define HW_DIGCTL_OCRAM_STATUS12_CLR	(0x000001d8)
+#define HW_DIGCTL_OCRAM_STATUS12_TOG	(0x000001dc)
+
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD3	0x80000000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE11	24
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11	0x7F000000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE11(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE11)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD2	0x00800000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE10	16
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10	0x007F0000
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE10(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE10)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD1	0x00008000
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE01	8
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01	0x00007F00
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE01(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE01)
+#define BM_DIGCTL_OCRAM_STATUS12_RSVD0	0x00000080
+#define BP_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0
+#define BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00	0x0000007F
+#define BF_DIGCTL_OCRAM_STATUS12_FAILSTATE00(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS12_FAILSTATE00)
+
+#define HW_DIGCTL_OCRAM_STATUS13	(0x000001e0)
+#define HW_DIGCTL_OCRAM_STATUS13_SET	(0x000001e4)
+#define HW_DIGCTL_OCRAM_STATUS13_CLR	(0x000001e8)
+#define HW_DIGCTL_OCRAM_STATUS13_TOG	(0x000001ec)
+
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD3	0x80000000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE31	24
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31	0x7F000000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE31(v)  \
+		(((v) << 24) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE31)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD2	0x00800000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE30	16
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30	0x007F0000
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE30(v)  \
+		(((v) << 16) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE30)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD1	0x00008000
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE21	8
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21	0x00007F00
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE21(v)  \
+		(((v) << 8) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE21)
+#define BM_DIGCTL_OCRAM_STATUS13_RSVD0	0x00000080
+#define BP_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0
+#define BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20	0x0000007F
+#define BF_DIGCTL_OCRAM_STATUS13_FAILSTATE20(v)  \
+		(((v) << 0) & BM_DIGCTL_OCRAM_STATUS13_FAILSTATE20)
+
+#define HW_DIGCTL_SCRATCH0	(0x00000280)
+
+#define BP_DIGCTL_SCRATCH0_PTR	0
+#define BM_DIGCTL_SCRATCH0_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH0_PTR(v)	(v)
+
+#define HW_DIGCTL_SCRATCH1	(0x00000290)
+
+#define BP_DIGCTL_SCRATCH1_PTR	0
+#define BM_DIGCTL_SCRATCH1_PTR	0xFFFFFFFF
+#define BF_DIGCTL_SCRATCH1_PTR(v)	(v)
+
+#define HW_DIGCTL_ARMCACHE	(0x000002a0)
+
+#define BP_DIGCTL_ARMCACHE_RSVD4	18
+#define BM_DIGCTL_ARMCACHE_RSVD4	0xFFFC0000
+#define BF_DIGCTL_ARMCACHE_RSVD4(v) \
+		(((v) << 18) & BM_DIGCTL_ARMCACHE_RSVD4)
+#define BP_DIGCTL_ARMCACHE_VALID_SS	16
+#define BM_DIGCTL_ARMCACHE_VALID_SS	0x00030000
+#define BF_DIGCTL_ARMCACHE_VALID_SS(v)  \
+		(((v) << 16) & BM_DIGCTL_ARMCACHE_VALID_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD3	14
+#define BM_DIGCTL_ARMCACHE_RSVD3	0x0000C000
+#define BF_DIGCTL_ARMCACHE_RSVD3(v)  \
+		(((v) << 14) & BM_DIGCTL_ARMCACHE_RSVD3)
+#define BP_DIGCTL_ARMCACHE_DRTY_SS	12
+#define BM_DIGCTL_ARMCACHE_DRTY_SS	0x00003000
+#define BF_DIGCTL_ARMCACHE_DRTY_SS(v)  \
+		(((v) << 12) & BM_DIGCTL_ARMCACHE_DRTY_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD2	10
+#define BM_DIGCTL_ARMCACHE_RSVD2	0x00000C00
+#define BF_DIGCTL_ARMCACHE_RSVD2(v)  \
+		(((v) << 10) & BM_DIGCTL_ARMCACHE_RSVD2)
+#define BP_DIGCTL_ARMCACHE_CACHE_SS	8
+#define BM_DIGCTL_ARMCACHE_CACHE_SS	0x00000300
+#define BF_DIGCTL_ARMCACHE_CACHE_SS(v)  \
+		(((v) << 8) & BM_DIGCTL_ARMCACHE_CACHE_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD1	6
+#define BM_DIGCTL_ARMCACHE_RSVD1	0x000000C0
+#define BF_DIGCTL_ARMCACHE_RSVD1(v)  \
+		(((v) << 6) & BM_DIGCTL_ARMCACHE_RSVD1)
+#define BP_DIGCTL_ARMCACHE_DTAG_SS	4
+#define BM_DIGCTL_ARMCACHE_DTAG_SS	0x00000030
+#define BF_DIGCTL_ARMCACHE_DTAG_SS(v)  \
+		(((v) << 4) & BM_DIGCTL_ARMCACHE_DTAG_SS)
+#define BP_DIGCTL_ARMCACHE_RSVD0	2
+#define BM_DIGCTL_ARMCACHE_RSVD0	0x0000000C
+#define BF_DIGCTL_ARMCACHE_RSVD0(v)  \
+		(((v) << 2) & BM_DIGCTL_ARMCACHE_RSVD0)
+#define BP_DIGCTL_ARMCACHE_ITAG_SS	0
+#define BM_DIGCTL_ARMCACHE_ITAG_SS	0x00000003
+#define BF_DIGCTL_ARMCACHE_ITAG_SS(v)  \
+		(((v) << 0) & BM_DIGCTL_ARMCACHE_ITAG_SS)
+
+#define HW_DIGCTL_DEBUG_TRAP	(0x000002b0)
+#define HW_DIGCTL_DEBUG_TRAP_SET	(0x000002b4)
+#define HW_DIGCTL_DEBUG_TRAP_CLR	(0x000002b8)
+#define HW_DIGCTL_DEBUG_TRAP_TOG	(0x000002bc)
+
+#define BP_DIGCTL_DEBUG_TRAP_RSVD2	12
+#define BM_DIGCTL_DEBUG_TRAP_RSVD2	0xFFFFF000
+#define BF_DIGCTL_DEBUG_TRAP_RSVD2(v) \
+		(((v) << 12) & BM_DIGCTL_DEBUG_TRAP_RSVD2)
+#define BP_DIGCTL_DEBUG_TRAP_RSVD1	10
+#define BM_DIGCTL_DEBUG_TRAP_RSVD1	0x00000C00
+#define BF_DIGCTL_DEBUG_TRAP_RSVD1(v)  \
+		(((v) << 10) & BM_DIGCTL_DEBUG_TRAP_RSVD1)
+#define BP_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID	8
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID	0x00000300
+#define BF_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID(v)  \
+		(((v) << 8) & BM_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID)
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__PXP   0x0
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__LCDIF 0x1
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__BCH   0x2
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L0_MASTER_ID__DCP   0x3
+#define BM_DIGCTL_DEBUG_TRAP_RSVD0	0x00000080
+#define BP_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID	4
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID	0x00000070
+#define BF_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID(v)  \
+		(((v) << 4) & BM_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID)
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__APBH_BRIDE_DMA 0x0
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__APBX_BRIDE_DMA 0x1
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__USB0           0x2
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__USB1           0x3
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__ENET_M0        0x4
+#define BV_DIGCTL_DEBUG_TRAP_TRAP_L3_MASTER_ID__ENET_M1        0x5
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L3_IRQ	0x00000008
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_L0_IRQ	0x00000004
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_IN_RANGE	0x00000002
+#define BM_DIGCTL_DEBUG_TRAP_TRAP_ENABLE	0x00000001
+
+#define HW_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW	(0x000002c0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L0_ADDR_LOW_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH	(0x000002d0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L0_ADDR_HIGH_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW	(0x000002e0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L3_ADDR_LOW_ADDR(v)	(v)
+
+#define HW_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH	(0x000002f0)
+
+#define BP_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR	0
+#define BM_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR	0xFFFFFFFF
+#define BF_DIGCTL_DEBUG_TRAP_L3_ADDR_HIGH_ADDR(v)	(v)
+
+#define HW_DIGCTL_FSL	(0x00000300)
+
+#define BP_DIGCTL_FSL_COPYRIGHT	0
+#define BM_DIGCTL_FSL_COPYRIGHT	0xFFFFFFFF
+#define BF_DIGCTL_FSL_COPYRIGHT(v)	(v)
+
+#define HW_DIGCTL_CHIPID	(0x00000310)
+
+#define BP_DIGCTL_CHIPID_PRODUCT_CODE	16
+#define BM_DIGCTL_CHIPID_PRODUCT_CODE	0xFFFF0000
+#define BF_DIGCTL_CHIPID_PRODUCT_CODE(v) \
+		(((v) << 16) & BM_DIGCTL_CHIPID_PRODUCT_CODE)
+#define BP_DIGCTL_CHIPID_RSVD0	8
+#define BM_DIGCTL_CHIPID_RSVD0	0x0000FF00
+#define BF_DIGCTL_CHIPID_RSVD0(v)  \
+		(((v) << 8) & BM_DIGCTL_CHIPID_RSVD0)
+#define BP_DIGCTL_CHIPID_REVISION	0
+#define BM_DIGCTL_CHIPID_REVISION	0x000000FF
+#define BF_DIGCTL_CHIPID_REVISION(v)  \
+		(((v) << 0) & BM_DIGCTL_CHIPID_REVISION)
+
+#define HW_DIGCTL_AHB_STATS_SELECT	(0x00000330)
+
+#define BP_DIGCTL_AHB_STATS_SELECT_RSVD0	24
+#define BM_DIGCTL_AHB_STATS_SELECT_RSVD0	0xFF000000
+#define BF_DIGCTL_AHB_STATS_SELECT_RSVD0(v) \
+		(((v) << 24) & BM_DIGCTL_AHB_STATS_SELECT_RSVD0)
+#define BP_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	16
+#define BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT	0x00FF0000
+#define BF_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT(v)  \
+		(((v) << 16) & BM_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBHDMA 0x1
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__APBXDMA 0x2
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__USB0    0x4
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__USB1    0x8
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__UDMA0   0x10
+#define BV_DIGCTL_AHB_STATS_SELECT_L3_MASTER_SELECT__UDMA1   0x20
+#define BP_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	8
+#define BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT	0x0000FF00
+#define BF_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT(v)  \
+		(((v) << 8) & BM_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L2_MASTER_SELECT__ARMD 0x1
+#define BP_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	0
+#define BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT	0x000000FF
+#define BF_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT(v)  \
+		(((v) << 0) & BM_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT)
+#define BV_DIGCTL_AHB_STATS_SELECT_L1_MASTER_SELECT__ARMI 0x1
+
+#define HW_DIGCTL_L1_AHB_ACTIVE_CYCLES	(0x00000370)
+
+#define BP_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_STALLED	(0x00000380)
+
+#define BP_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L1_AHB_DATA_CYCLES	(0x00000390)
+
+#define BP_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L1_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L1_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_ACTIVE_CYCLES	(0x000003a0)
+
+#define BP_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_STALLED	(0x000003b0)
+
+#define BP_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L2_AHB_DATA_CYCLES	(0x000003c0)
+
+#define BP_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L2_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L2_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_ACTIVE_CYCLES	(0x000003d0)
+
+#define BP_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_ACTIVE_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_STALLED	(0x000003e0)
+
+#define BP_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_STALLED_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_STALLED_COUNT(v)	(v)
+
+#define HW_DIGCTL_L3_AHB_DATA_CYCLES	(0x000003f0)
+
+#define BP_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0
+#define BM_DIGCTL_L3_AHB_DATA_CYCLES_COUNT	0xFFFFFFFF
+#define BF_DIGCTL_L3_AHB_DATA_CYCLES_COUNT(v)	(v)
+
+#define HW_DIGCTL_MPTE0_LOC	(0x00000500)
+
+#define BM_DIGCTL_MPTE0_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE0_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE0_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE0_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE0_LOC_RSVD1)
+#define BP_DIGCTL_MPTE0_LOC_SPAN	24
+#define BM_DIGCTL_MPTE0_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE0_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE0_LOC_SPAN)
+#define BP_DIGCTL_MPTE0_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE0_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE0_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE0_LOC_RSVD0)
+#define BP_DIGCTL_MPTE0_LOC_LOC	0
+#define BM_DIGCTL_MPTE0_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE0_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE0_LOC_LOC)
+
+#define HW_DIGCTL_MPTE1_LOC	(0x00000510)
+
+#define BM_DIGCTL_MPTE1_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE1_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE1_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE1_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE1_LOC_RSVD1)
+#define BP_DIGCTL_MPTE1_LOC_SPAN	24
+#define BM_DIGCTL_MPTE1_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE1_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE1_LOC_SPAN)
+#define BP_DIGCTL_MPTE1_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE1_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE1_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE1_LOC_RSVD0)
+#define BP_DIGCTL_MPTE1_LOC_LOC	0
+#define BM_DIGCTL_MPTE1_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE1_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE1_LOC_LOC)
+
+#define HW_DIGCTL_MPTE2_LOC	(0x00000520)
+
+#define BM_DIGCTL_MPTE2_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE2_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE2_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE2_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE2_LOC_RSVD1)
+#define BP_DIGCTL_MPTE2_LOC_SPAN	24
+#define BM_DIGCTL_MPTE2_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE2_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE2_LOC_SPAN)
+#define BP_DIGCTL_MPTE2_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE2_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE2_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE2_LOC_RSVD0)
+#define BP_DIGCTL_MPTE2_LOC_LOC	0
+#define BM_DIGCTL_MPTE2_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE2_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE2_LOC_LOC)
+
+#define HW_DIGCTL_MPTE3_LOC	(0x00000530)
+
+#define BM_DIGCTL_MPTE3_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE3_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE3_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE3_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE3_LOC_RSVD1)
+#define BP_DIGCTL_MPTE3_LOC_SPAN	24
+#define BM_DIGCTL_MPTE3_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE3_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE3_LOC_SPAN)
+#define BP_DIGCTL_MPTE3_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE3_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE3_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE3_LOC_RSVD0)
+#define BP_DIGCTL_MPTE3_LOC_LOC	0
+#define BM_DIGCTL_MPTE3_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE3_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE3_LOC_LOC)
+
+#define HW_DIGCTL_MPTE4_LOC	(0x00000540)
+
+#define BM_DIGCTL_MPTE4_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE4_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE4_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE4_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE4_LOC_RSVD1)
+#define BP_DIGCTL_MPTE4_LOC_SPAN	24
+#define BM_DIGCTL_MPTE4_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE4_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE4_LOC_SPAN)
+#define BP_DIGCTL_MPTE4_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE4_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE4_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE4_LOC_RSVD0)
+#define BP_DIGCTL_MPTE4_LOC_LOC	0
+#define BM_DIGCTL_MPTE4_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE4_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE4_LOC_LOC)
+
+#define HW_DIGCTL_MPTE5_LOC	(0x00000550)
+
+#define BM_DIGCTL_MPTE5_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE5_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE5_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE5_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE5_LOC_RSVD1)
+#define BP_DIGCTL_MPTE5_LOC_SPAN	24
+#define BM_DIGCTL_MPTE5_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE5_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE5_LOC_SPAN)
+#define BP_DIGCTL_MPTE5_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE5_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE5_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE5_LOC_RSVD0)
+#define BP_DIGCTL_MPTE5_LOC_LOC	0
+#define BM_DIGCTL_MPTE5_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE5_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE5_LOC_LOC)
+
+#define HW_DIGCTL_MPTE6_LOC	(0x00000560)
+
+#define BM_DIGCTL_MPTE6_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE6_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE6_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE6_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE6_LOC_RSVD1)
+#define BP_DIGCTL_MPTE6_LOC_SPAN	24
+#define BM_DIGCTL_MPTE6_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE6_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE6_LOC_SPAN)
+#define BP_DIGCTL_MPTE6_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE6_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE6_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE6_LOC_RSVD0)
+#define BP_DIGCTL_MPTE6_LOC_LOC	0
+#define BM_DIGCTL_MPTE6_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE6_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE6_LOC_LOC)
+
+#define HW_DIGCTL_MPTE7_LOC	(0x00000570)
+
+#define BM_DIGCTL_MPTE7_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE7_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE7_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE7_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE7_LOC_RSVD1)
+#define BP_DIGCTL_MPTE7_LOC_SPAN	24
+#define BM_DIGCTL_MPTE7_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE7_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE7_LOC_SPAN)
+#define BP_DIGCTL_MPTE7_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE7_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE7_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE7_LOC_RSVD0)
+#define BP_DIGCTL_MPTE7_LOC_LOC	0
+#define BM_DIGCTL_MPTE7_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE7_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE7_LOC_LOC)
+
+#define HW_DIGCTL_MPTE8_LOC	(0x00000580)
+
+#define BM_DIGCTL_MPTE8_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE8_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE8_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE8_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE8_LOC_RSVD1)
+#define BP_DIGCTL_MPTE8_LOC_SPAN	24
+#define BM_DIGCTL_MPTE8_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE8_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE8_LOC_SPAN)
+#define BP_DIGCTL_MPTE8_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE8_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE8_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE8_LOC_RSVD0)
+#define BP_DIGCTL_MPTE8_LOC_LOC	0
+#define BM_DIGCTL_MPTE8_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE8_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE8_LOC_LOC)
+
+#define HW_DIGCTL_MPTE9_LOC	(0x00000590)
+
+#define BM_DIGCTL_MPTE9_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE9_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE9_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE9_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE9_LOC_RSVD1)
+#define BP_DIGCTL_MPTE9_LOC_SPAN	24
+#define BM_DIGCTL_MPTE9_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE9_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE9_LOC_SPAN)
+#define BP_DIGCTL_MPTE9_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE9_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE9_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE9_LOC_RSVD0)
+#define BP_DIGCTL_MPTE9_LOC_LOC	0
+#define BM_DIGCTL_MPTE9_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE9_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE9_LOC_LOC)
+
+#define HW_DIGCTL_MPTE10_LOC	(0x000005a0)
+
+#define BM_DIGCTL_MPTE10_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE10_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE10_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE10_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE10_LOC_RSVD1)
+#define BP_DIGCTL_MPTE10_LOC_SPAN	24
+#define BM_DIGCTL_MPTE10_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE10_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE10_LOC_SPAN)
+#define BP_DIGCTL_MPTE10_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE10_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE10_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE10_LOC_RSVD0)
+#define BP_DIGCTL_MPTE10_LOC_LOC	0
+#define BM_DIGCTL_MPTE10_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE10_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE10_LOC_LOC)
+
+#define HW_DIGCTL_MPTE11_LOC	(0x000005b0)
+
+#define BM_DIGCTL_MPTE11_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE11_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE11_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE11_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE11_LOC_RSVD1)
+#define BP_DIGCTL_MPTE11_LOC_SPAN	24
+#define BM_DIGCTL_MPTE11_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE11_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE11_LOC_SPAN)
+#define BP_DIGCTL_MPTE11_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE11_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE11_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE11_LOC_RSVD0)
+#define BP_DIGCTL_MPTE11_LOC_LOC	0
+#define BM_DIGCTL_MPTE11_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE11_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE11_LOC_LOC)
+
+#define HW_DIGCTL_MPTE12_LOC	(0x000005c0)
+
+#define BM_DIGCTL_MPTE12_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE12_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE12_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE12_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE12_LOC_RSVD1)
+#define BP_DIGCTL_MPTE12_LOC_SPAN	24
+#define BM_DIGCTL_MPTE12_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE12_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE12_LOC_SPAN)
+#define BP_DIGCTL_MPTE12_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE12_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE12_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE12_LOC_RSVD0)
+#define BP_DIGCTL_MPTE12_LOC_LOC	0
+#define BM_DIGCTL_MPTE12_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE12_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE12_LOC_LOC)
+
+#define HW_DIGCTL_MPTE13_LOC	(0x000005d0)
+
+#define BM_DIGCTL_MPTE13_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE13_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE13_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE13_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE13_LOC_RSVD1)
+#define BP_DIGCTL_MPTE13_LOC_SPAN	24
+#define BM_DIGCTL_MPTE13_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE13_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE13_LOC_SPAN)
+#define BP_DIGCTL_MPTE13_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE13_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE13_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE13_LOC_RSVD0)
+#define BP_DIGCTL_MPTE13_LOC_LOC	0
+#define BM_DIGCTL_MPTE13_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE13_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE13_LOC_LOC)
+
+#define HW_DIGCTL_MPTE14_LOC	(0x000005e0)
+
+#define BM_DIGCTL_MPTE14_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE14_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE14_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE14_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE14_LOC_RSVD1)
+#define BP_DIGCTL_MPTE14_LOC_SPAN	24
+#define BM_DIGCTL_MPTE14_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE14_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE14_LOC_SPAN)
+#define BP_DIGCTL_MPTE14_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE14_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE14_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE14_LOC_RSVD0)
+#define BP_DIGCTL_MPTE14_LOC_LOC	0
+#define BM_DIGCTL_MPTE14_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE14_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE14_LOC_LOC)
+
+#define HW_DIGCTL_MPTE15_LOC	(0x000005f0)
+
+#define BM_DIGCTL_MPTE15_LOC_DIS	0x80000000
+#define BP_DIGCTL_MPTE15_LOC_RSVD1	27
+#define BM_DIGCTL_MPTE15_LOC_RSVD1	0x78000000
+#define BF_DIGCTL_MPTE15_LOC_RSVD1(v)  \
+		(((v) << 27) & BM_DIGCTL_MPTE15_LOC_RSVD1)
+#define BP_DIGCTL_MPTE15_LOC_SPAN	24
+#define BM_DIGCTL_MPTE15_LOC_SPAN	0x07000000
+#define BF_DIGCTL_MPTE15_LOC_SPAN(v)  \
+		(((v) << 24) & BM_DIGCTL_MPTE15_LOC_SPAN)
+#define BP_DIGCTL_MPTE15_LOC_RSVD0	12
+#define BM_DIGCTL_MPTE15_LOC_RSVD0	0x00FFF000
+#define BF_DIGCTL_MPTE15_LOC_RSVD0(v)  \
+		(((v) << 12) & BM_DIGCTL_MPTE15_LOC_RSVD0)
+#define BP_DIGCTL_MPTE15_LOC_LOC	0
+#define BM_DIGCTL_MPTE15_LOC_LOC	0x00000FFF
+#define BF_DIGCTL_MPTE15_LOC_LOC(v)  \
+		(((v) << 0) & BM_DIGCTL_MPTE15_LOC_LOC)
+#endif /* __ARCH_ARM___DIGCTL_H */
diff --git a/arch/arm/mach-mx28/regs-dram.h b/arch/arm/mach-mx28/regs-dram.h
new file mode 100644
index 0000000..ed962a6
--- /dev/null
+++ b/arch/arm/mach-mx28/regs-dram.h
@@ -0,0 +1,2505 @@
+/*
+ * Freescale DRAM Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.50
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___DRAM_H
+#define __ARCH_ARM___DRAM_H
+
+
+#define HW_DRAM_CTL00	(0x00000000)
+
+#define BP_DRAM_CTL00_USER_DEF_REG_0_1	3
+#define BM_DRAM_CTL00_USER_DEF_REG_0_1	0xFFFFFFF8
+#define BF_DRAM_CTL00_USER_DEF_REG_0_1(v) \
+		(((v) << 3) & BM_DRAM_CTL00_USER_DEF_REG_0_1)
+#define BM_DRAM_CTL00_CKE_SELECT	0x00000004
+#define BV_DRAM_CTL00_CKE_SELECT__DDR2  0x0
+#define BV_DRAM_CTL00_CKE_SELECT__LPDDR 0x1
+#define BM_DRAM_CTL00_SREFRESH_ENTER	0x00000002
+#define BM_DRAM_CTL00_BRESP_TIMING	0x00000001
+#define BV_DRAM_CTL00_BRESP_TIMING__BUFFERABLE      0x0
+#define BV_DRAM_CTL00_BRESP_TIMING__SEMI_BUFFERABLE 0x1
+
+#define HW_DRAM_CTL01	(0x00000004)
+
+#define BP_DRAM_CTL01_USER_DEF_REG_1	9
+#define BM_DRAM_CTL01_USER_DEF_REG_1	0xFFFFFE00
+#define BF_DRAM_CTL01_USER_DEF_REG_1(v) \
+		(((v) << 9) & BM_DRAM_CTL01_USER_DEF_REG_1)
+#define BM_DRAM_CTL01_MON_DBG_STB	0x00000100
+#define BP_DRAM_CTL01_SLVERR	4
+#define BM_DRAM_CTL01_SLVERR	0x000000F0
+#define BF_DRAM_CTL01_SLVERR(v)  \
+		(((v) << 4) & BM_DRAM_CTL01_SLVERR)
+#define BP_DRAM_CTL01_MON_DISABLE	0
+#define BM_DRAM_CTL01_MON_DISABLE	0x0000000F
+#define BF_DRAM_CTL01_MON_DISABLE(v)  \
+		(((v) << 0) & BM_DRAM_CTL01_MON_DISABLE)
+
+#define HW_DRAM_CTL02	(0x00000008)
+
+#define BP_DRAM_CTL02_USER_DEF_REG_2	0
+#define BM_DRAM_CTL02_USER_DEF_REG_2	0xFFFFFFFF
+#define BF_DRAM_CTL02_USER_DEF_REG_2(v)	(v)
+
+#define HW_DRAM_CTL03	(0x0000000c)
+
+#define BP_DRAM_CTL03_USER_DEF_REG_3	0
+#define BM_DRAM_CTL03_USER_DEF_REG_3	0xFFFFFFFF
+#define BF_DRAM_CTL03_USER_DEF_REG_3(v)	(v)
+
+#define HW_DRAM_CTL04	(0x00000010)
+
+#define BP_DRAM_CTL04_USER_DEF_REG_4	0
+#define BM_DRAM_CTL04_USER_DEF_REG_4	0xFFFFFFFF
+#define BF_DRAM_CTL04_USER_DEF_REG_4(v)	(v)
+
+#define HW_DRAM_CTL05	(0x00000014)
+
+#define BP_DRAM_CTL05_USER_DEF_REG_5	0
+#define BM_DRAM_CTL05_USER_DEF_REG_5	0xFFFFFFFF
+#define BF_DRAM_CTL05_USER_DEF_REG_5(v)	(v)
+
+#define HW_DRAM_CTL06	(0x00000018)
+
+#define BP_DRAM_CTL06_USER_DEF_REG_6	0
+#define BM_DRAM_CTL06_USER_DEF_REG_6	0xFFFFFFFF
+#define BF_DRAM_CTL06_USER_DEF_REG_6(v)	(v)
+
+#define HW_DRAM_CTL07	(0x0000001c)
+
+#define BP_DRAM_CTL07_USER_DEF_REG_7	0
+#define BM_DRAM_CTL07_USER_DEF_REG_7	0xFFFFFFFF
+#define BF_DRAM_CTL07_USER_DEF_REG_7(v)	(v)
+
+#define HW_DRAM_CTL08	(0x00000020)
+
+#define BP_DRAM_CTL08_USER_DEF_REG_RO_0	9
+#define BM_DRAM_CTL08_USER_DEF_REG_RO_0	0xFFFFFE00
+#define BF_DRAM_CTL08_USER_DEF_REG_RO_0(v) \
+		(((v) << 9) & BM_DRAM_CTL08_USER_DEF_REG_RO_0)
+#define BM_DRAM_CTL08_CONTROLLER_BUSY	0x00000100
+#define BM_DRAM_CTL08_REFRESH_IN_PROCESS	0x00000080
+#define BM_DRAM_CTL08_Q_ALMOST_FULL	0x00000040
+#define BM_DRAM_CTL08_SREFRESH_ACK	0x00000020
+#define BM_DRAM_CTL08_CKE_STATUS	0x00000010
+#define BP_DRAM_CTL08_COMMAND_ACCEPTED	0
+#define BM_DRAM_CTL08_COMMAND_ACCEPTED	0x0000000F
+#define BF_DRAM_CTL08_COMMAND_ACCEPTED(v)  \
+		(((v) << 0) & BM_DRAM_CTL08_COMMAND_ACCEPTED)
+
+#define HW_DRAM_CTL09	(0x00000024)
+
+#define BP_DRAM_CTL09_USER_DEF_REG_RO_1	0
+#define BM_DRAM_CTL09_USER_DEF_REG_RO_1	0xFFFFFFFF
+#define BF_DRAM_CTL09_USER_DEF_REG_RO_1(v)	(v)
+
+#define HW_DRAM_CTL10	(0x00000028)
+
+#define BP_DRAM_CTL10_RSVD	24
+#define BM_DRAM_CTL10_RSVD	0xFF000000
+#define BF_DRAM_CTL10_RSVD(v) \
+		(((v) << 24) & BM_DRAM_CTL10_RSVD)
+#define BP_DRAM_CTL10_READ_CNT	16
+#define BM_DRAM_CTL10_READ_CNT	0x00FF0000
+#define BF_DRAM_CTL10_READ_CNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL10_READ_CNT)
+#define BP_DRAM_CTL10_WRESP_CNT	8
+#define BM_DRAM_CTL10_WRESP_CNT	0x0000FF00
+#define BF_DRAM_CTL10_WRESP_CNT(v)  \
+		(((v) << 8) & BM_DRAM_CTL10_WRESP_CNT)
+#define BP_DRAM_CTL10_WDATA_CNT	0
+#define BM_DRAM_CTL10_WDATA_CNT	0x000000FF
+#define BF_DRAM_CTL10_WDATA_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL10_WDATA_CNT)
+
+#define HW_DRAM_CTL11	(0x0000002c)
+
+#define BP_DRAM_CTL11_WSTATE	24
+#define BM_DRAM_CTL11_WSTATE	0xFF000000
+#define BF_DRAM_CTL11_WSTATE(v) \
+		(((v) << 24) & BM_DRAM_CTL11_WSTATE)
+#define BP_DRAM_CTL11_RSTATE	16
+#define BM_DRAM_CTL11_RSTATE	0x00FF0000
+#define BF_DRAM_CTL11_RSTATE(v)  \
+		(((v) << 16) & BM_DRAM_CTL11_RSTATE)
+#define BP_DRAM_CTL11_RLEN	8
+#define BM_DRAM_CTL11_RLEN	0x0000FF00
+#define BF_DRAM_CTL11_RLEN(v)  \
+		(((v) << 8) & BM_DRAM_CTL11_RLEN)
+#define BP_DRAM_CTL11_WLEN	0
+#define BM_DRAM_CTL11_WLEN	0x000000FF
+#define BF_DRAM_CTL11_WLEN(v)  \
+		(((v) << 0) & BM_DRAM_CTL11_WLEN)
+
+#define HW_DRAM_CTL12	(0x00000030)
+
+#define BP_DRAM_CTL12_RSVD	24
+#define BM_DRAM_CTL12_RSVD	0xFF000000
+#define BF_DRAM_CTL12_RSVD(v) \
+		(((v) << 24) & BM_DRAM_CTL12_RSVD)
+#define BP_DRAM_CTL12_READ_CNT	16
+#define BM_DRAM_CTL12_READ_CNT	0x00FF0000
+#define BF_DRAM_CTL12_READ_CNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL12_READ_CNT)
+#define BP_DRAM_CTL12_WRESP_CNT	8
+#define BM_DRAM_CTL12_WRESP_CNT	0x0000FF00
+#define BF_DRAM_CTL12_WRESP_CNT(v)  \
+		(((v) << 8) & BM_DRAM_CTL12_WRESP_CNT)
+#define BP_DRAM_CTL12_WDATA_CNT	0
+#define BM_DRAM_CTL12_WDATA_CNT	0x000000FF
+#define BF_DRAM_CTL12_WDATA_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL12_WDATA_CNT)
+
+#define HW_DRAM_CTL13	(0x00000034)
+
+#define BP_DRAM_CTL13_WSTATE	24
+#define BM_DRAM_CTL13_WSTATE	0xFF000000
+#define BF_DRAM_CTL13_WSTATE(v) \
+		(((v) << 24) & BM_DRAM_CTL13_WSTATE)
+#define BP_DRAM_CTL13_RSTATE	16
+#define BM_DRAM_CTL13_RSTATE	0x00FF0000
+#define BF_DRAM_CTL13_RSTATE(v)  \
+		(((v) << 16) & BM_DRAM_CTL13_RSTATE)
+#define BP_DRAM_CTL13_RLEN	8
+#define BM_DRAM_CTL13_RLEN	0x0000FF00
+#define BF_DRAM_CTL13_RLEN(v)  \
+		(((v) << 8) & BM_DRAM_CTL13_RLEN)
+#define BP_DRAM_CTL13_WLEN	0
+#define BM_DRAM_CTL13_WLEN	0x000000FF
+#define BF_DRAM_CTL13_WLEN(v)  \
+		(((v) << 0) & BM_DRAM_CTL13_WLEN)
+
+#define HW_DRAM_CTL14	(0x00000038)
+
+#define BP_DRAM_CTL14_RSVD	24
+#define BM_DRAM_CTL14_RSVD	0xFF000000
+#define BF_DRAM_CTL14_RSVD(v) \
+		(((v) << 24) & BM_DRAM_CTL14_RSVD)
+#define BP_DRAM_CTL14_READ_CNT	16
+#define BM_DRAM_CTL14_READ_CNT	0x00FF0000
+#define BF_DRAM_CTL14_READ_CNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL14_READ_CNT)
+#define BP_DRAM_CTL14_WRESP_CNT	8
+#define BM_DRAM_CTL14_WRESP_CNT	0x0000FF00
+#define BF_DRAM_CTL14_WRESP_CNT(v)  \
+		(((v) << 8) & BM_DRAM_CTL14_WRESP_CNT)
+#define BP_DRAM_CTL14_WDATA_CNT	0
+#define BM_DRAM_CTL14_WDATA_CNT	0x000000FF
+#define BF_DRAM_CTL14_WDATA_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL14_WDATA_CNT)
+
+#define HW_DRAM_CTL15	(0x0000003c)
+
+#define BP_DRAM_CTL15_WSTATE	24
+#define BM_DRAM_CTL15_WSTATE	0xFF000000
+#define BF_DRAM_CTL15_WSTATE(v) \
+		(((v) << 24) & BM_DRAM_CTL15_WSTATE)
+#define BP_DRAM_CTL15_RSTATE	16
+#define BM_DRAM_CTL15_RSTATE	0x00FF0000
+#define BF_DRAM_CTL15_RSTATE(v)  \
+		(((v) << 16) & BM_DRAM_CTL15_RSTATE)
+#define BP_DRAM_CTL15_RLEN	8
+#define BM_DRAM_CTL15_RLEN	0x0000FF00
+#define BF_DRAM_CTL15_RLEN(v)  \
+		(((v) << 8) & BM_DRAM_CTL15_RLEN)
+#define BP_DRAM_CTL15_WLEN	0
+#define BM_DRAM_CTL15_WLEN	0x000000FF
+#define BF_DRAM_CTL15_WLEN(v)  \
+		(((v) << 0) & BM_DRAM_CTL15_WLEN)
+
+#define HW_DRAM_CTL16	(0x00000040)
+
+#define BP_DRAM_CTL16_RSVD3	25
+#define BM_DRAM_CTL16_RSVD3	0xFE000000
+#define BF_DRAM_CTL16_RSVD3(v) \
+		(((v) << 25) & BM_DRAM_CTL16_RSVD3)
+#define BM_DRAM_CTL16_WRITE_MODEREG	0x01000000
+#define BP_DRAM_CTL16_RSVD2	17
+#define BM_DRAM_CTL16_RSVD2	0x00FE0000
+#define BF_DRAM_CTL16_RSVD2(v)  \
+		(((v) << 17) & BM_DRAM_CTL16_RSVD2)
+#define BM_DRAM_CTL16_POWER_DOWN	0x00010000
+#define BP_DRAM_CTL16_OBSOLETE	8
+#define BM_DRAM_CTL16_OBSOLETE	0x0000FF00
+#define BF_DRAM_CTL16_OBSOLETE(v)  \
+		(((v) << 8) & BM_DRAM_CTL16_OBSOLETE)
+#define BP_DRAM_CTL16_RSVD1	1
+#define BM_DRAM_CTL16_RSVD1	0x000000FE
+#define BF_DRAM_CTL16_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL16_RSVD1)
+#define BM_DRAM_CTL16_START	0x00000001
+
+#define HW_DRAM_CTL17	(0x00000044)
+
+#define BP_DRAM_CTL17_RSVD4	25
+#define BM_DRAM_CTL17_RSVD4	0xFE000000
+#define BF_DRAM_CTL17_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL17_RSVD4)
+#define BM_DRAM_CTL17_AUTO_REFRESH_MODE	0x01000000
+#define BP_DRAM_CTL17_RSVD3	17
+#define BM_DRAM_CTL17_RSVD3	0x00FE0000
+#define BF_DRAM_CTL17_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL17_RSVD3)
+#define BM_DRAM_CTL17_AREFRESH	0x00010000
+#define BP_DRAM_CTL17_RSVD2	9
+#define BM_DRAM_CTL17_RSVD2	0x0000FE00
+#define BF_DRAM_CTL17_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL17_RSVD2)
+#define BM_DRAM_CTL17_ENABLE_QUICK_SREFRESH	0x00000100
+#define BP_DRAM_CTL17_RSVD1	1
+#define BM_DRAM_CTL17_RSVD1	0x000000FE
+#define BF_DRAM_CTL17_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL17_RSVD1)
+#define BM_DRAM_CTL17_SREFRESH	0x00000001
+
+#define HW_DRAM_CTL21	(0x00000054)
+
+#define BP_DRAM_CTL21_RSVD3	27
+#define BM_DRAM_CTL21_RSVD3	0xF8000000
+#define BF_DRAM_CTL21_RSVD3(v) \
+		(((v) << 27) & BM_DRAM_CTL21_RSVD3)
+#define BP_DRAM_CTL21_CKE_DELAY	24
+#define BM_DRAM_CTL21_CKE_DELAY	0x07000000
+#define BF_DRAM_CTL21_CKE_DELAY(v)  \
+		(((v) << 24) & BM_DRAM_CTL21_CKE_DELAY)
+#define BP_DRAM_CTL21_DLL_LOCK	16
+#define BM_DRAM_CTL21_DLL_LOCK	0x00FF0000
+#define BF_DRAM_CTL21_DLL_LOCK(v)  \
+		(((v) << 16) & BM_DRAM_CTL21_DLL_LOCK)
+#define BP_DRAM_CTL21_RSVD2	9
+#define BM_DRAM_CTL21_RSVD2	0x0000FE00
+#define BF_DRAM_CTL21_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL21_RSVD2)
+#define BM_DRAM_CTL21_DLLLOCKREG	0x00000100
+#define BP_DRAM_CTL21_RSVD1	1
+#define BM_DRAM_CTL21_RSVD1	0x000000FE
+#define BF_DRAM_CTL21_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL21_RSVD1)
+#define BM_DRAM_CTL21_DLL_BYPASS_MODE	0x00000001
+
+#define HW_DRAM_CTL22	(0x00000058)
+
+#define BP_DRAM_CTL22_OBSOLETE	24
+#define BM_DRAM_CTL22_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL22_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL22_OBSOLETE)
+#define BP_DRAM_CTL22_RSVD3	20
+#define BM_DRAM_CTL22_RSVD3	0x00F00000
+#define BF_DRAM_CTL22_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL22_RSVD3)
+#define BP_DRAM_CTL22_LOWPOWER_REFRESH_ENABLE	16
+#define BM_DRAM_CTL22_LOWPOWER_REFRESH_ENABLE	0x000F0000
+#define BF_DRAM_CTL22_LOWPOWER_REFRESH_ENABLE(v)  \
+		(((v) << 16) & BM_DRAM_CTL22_LOWPOWER_REFRESH_ENABLE)
+#define BP_DRAM_CTL22_RSVD2	13
+#define BM_DRAM_CTL22_RSVD2	0x0000E000
+#define BF_DRAM_CTL22_RSVD2(v)  \
+		(((v) << 13) & BM_DRAM_CTL22_RSVD2)
+#define BP_DRAM_CTL22_LOWPOWER_CONTROL	8
+#define BM_DRAM_CTL22_LOWPOWER_CONTROL	0x00001F00
+#define BF_DRAM_CTL22_LOWPOWER_CONTROL(v)  \
+		(((v) << 8) & BM_DRAM_CTL22_LOWPOWER_CONTROL)
+#define BP_DRAM_CTL22_RSVD1	5
+#define BM_DRAM_CTL22_RSVD1	0x000000E0
+#define BF_DRAM_CTL22_RSVD1(v)  \
+		(((v) << 5) & BM_DRAM_CTL22_RSVD1)
+#define BP_DRAM_CTL22_LOWPOWER_AUTO_ENABLE	0
+#define BM_DRAM_CTL22_LOWPOWER_AUTO_ENABLE	0x0000001F
+#define BF_DRAM_CTL22_LOWPOWER_AUTO_ENABLE(v)  \
+		(((v) << 0) & BM_DRAM_CTL22_LOWPOWER_AUTO_ENABLE)
+
+#define HW_DRAM_CTL23	(0x0000005c)
+
+#define BP_DRAM_CTL23_LOWPOWER_INTERNAL_CNT	16
+#define BM_DRAM_CTL23_LOWPOWER_INTERNAL_CNT	0xFFFF0000
+#define BF_DRAM_CTL23_LOWPOWER_INTERNAL_CNT(v) \
+		(((v) << 16) & BM_DRAM_CTL23_LOWPOWER_INTERNAL_CNT)
+#define BP_DRAM_CTL23_LOWPOWER_EXTERNAL_CNT	0
+#define BM_DRAM_CTL23_LOWPOWER_EXTERNAL_CNT	0x0000FFFF
+#define BF_DRAM_CTL23_LOWPOWER_EXTERNAL_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL23_LOWPOWER_EXTERNAL_CNT)
+
+#define HW_DRAM_CTL24	(0x00000060)
+
+#define BP_DRAM_CTL24_LOWPOWER_SELF_REFRESH_CNT	16
+#define BM_DRAM_CTL24_LOWPOWER_SELF_REFRESH_CNT	0xFFFF0000
+#define BF_DRAM_CTL24_LOWPOWER_SELF_REFRESH_CNT(v) \
+		(((v) << 16) & BM_DRAM_CTL24_LOWPOWER_SELF_REFRESH_CNT)
+#define BP_DRAM_CTL24_LOWPOWER_REFRESH_HOLD	0
+#define BM_DRAM_CTL24_LOWPOWER_REFRESH_HOLD	0x0000FFFF
+#define BF_DRAM_CTL24_LOWPOWER_REFRESH_HOLD(v)  \
+		(((v) << 0) & BM_DRAM_CTL24_LOWPOWER_REFRESH_HOLD)
+
+#define HW_DRAM_CTL25	(0x00000064)
+
+#define BP_DRAM_CTL25_OBSOLETE	16
+#define BM_DRAM_CTL25_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL25_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL25_OBSOLETE)
+#define BP_DRAM_CTL25_LOWPOWER_POWER_DOWN_CNT	0
+#define BM_DRAM_CTL25_LOWPOWER_POWER_DOWN_CNT	0x0000FFFF
+#define BF_DRAM_CTL25_LOWPOWER_POWER_DOWN_CNT(v)  \
+		(((v) << 0) & BM_DRAM_CTL25_LOWPOWER_POWER_DOWN_CNT)
+
+#define HW_DRAM_CTL26	(0x00000068)
+
+#define BP_DRAM_CTL26_OBSOLETE	24
+#define BM_DRAM_CTL26_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL26_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL26_OBSOLETE)
+#define BP_DRAM_CTL26_RSVD3	17
+#define BM_DRAM_CTL26_RSVD3	0x00FE0000
+#define BF_DRAM_CTL26_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL26_RSVD3)
+#define BM_DRAM_CTL26_PRIORITY_EN	0x00010000
+#define BP_DRAM_CTL26_RSVD2	9
+#define BM_DRAM_CTL26_RSVD2	0x0000FE00
+#define BF_DRAM_CTL26_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL26_RSVD2)
+#define BM_DRAM_CTL26_ADDR_CMP_EN	0x00000100
+#define BP_DRAM_CTL26_RSVD1	1
+#define BM_DRAM_CTL26_RSVD1	0x000000FE
+#define BF_DRAM_CTL26_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL26_RSVD1)
+#define BM_DRAM_CTL26_PLACEMENT_EN	0x00000001
+
+#define HW_DRAM_CTL27	(0x0000006c)
+
+#define BP_DRAM_CTL27_RSVD4	25
+#define BM_DRAM_CTL27_RSVD4	0xFE000000
+#define BF_DRAM_CTL27_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL27_RSVD4)
+#define BM_DRAM_CTL27_SWAP_PORT_RW_SAME_EN	0x01000000
+#define BP_DRAM_CTL27_RSVD3	17
+#define BM_DRAM_CTL27_RSVD3	0x00FE0000
+#define BF_DRAM_CTL27_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL27_RSVD3)
+#define BM_DRAM_CTL27_SWAP_EN	0x00010000
+#define BP_DRAM_CTL27_RSVD2	9
+#define BM_DRAM_CTL27_RSVD2	0x0000FE00
+#define BF_DRAM_CTL27_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL27_RSVD2)
+#define BM_DRAM_CTL27_BANK_SPLIT_EN	0x00000100
+#define BP_DRAM_CTL27_RSVD1	1
+#define BM_DRAM_CTL27_RSVD1	0x000000FE
+#define BF_DRAM_CTL27_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL27_RSVD1)
+#define BM_DRAM_CTL27_RW_SAME_EN	0x00000001
+
+#define HW_DRAM_CTL28	(0x00000070)
+
+#define BP_DRAM_CTL28_RSVD4	27
+#define BM_DRAM_CTL28_RSVD4	0xF8000000
+#define BF_DRAM_CTL28_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL28_RSVD4)
+#define BP_DRAM_CTL28_Q_FULLNESS	24
+#define BM_DRAM_CTL28_Q_FULLNESS	0x07000000
+#define BF_DRAM_CTL28_Q_FULLNESS(v)  \
+		(((v) << 24) & BM_DRAM_CTL28_Q_FULLNESS)
+#define BP_DRAM_CTL28_RSVD3	20
+#define BM_DRAM_CTL28_RSVD3	0x00F00000
+#define BF_DRAM_CTL28_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL28_RSVD3)
+#define BP_DRAM_CTL28_AGE_COUNT	16
+#define BM_DRAM_CTL28_AGE_COUNT	0x000F0000
+#define BF_DRAM_CTL28_AGE_COUNT(v)  \
+		(((v) << 16) & BM_DRAM_CTL28_AGE_COUNT)
+#define BP_DRAM_CTL28_RSVD2	12
+#define BM_DRAM_CTL28_RSVD2	0x0000F000
+#define BF_DRAM_CTL28_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL28_RSVD2)
+#define BP_DRAM_CTL28_COMMAND_AGE_COUNT	8
+#define BM_DRAM_CTL28_COMMAND_AGE_COUNT	0x00000F00
+#define BF_DRAM_CTL28_COMMAND_AGE_COUNT(v)  \
+		(((v) << 8) & BM_DRAM_CTL28_COMMAND_AGE_COUNT)
+#define BP_DRAM_CTL28_RSVD1	1
+#define BM_DRAM_CTL28_RSVD1	0x000000FE
+#define BF_DRAM_CTL28_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL28_RSVD1)
+#define BM_DRAM_CTL28_ACTIVE_AGING	0x00000001
+
+#define HW_DRAM_CTL29	(0x00000074)
+
+#define BP_DRAM_CTL29_RSVD4	28
+#define BM_DRAM_CTL29_RSVD4	0xF0000000
+#define BF_DRAM_CTL29_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL29_RSVD4)
+#define BP_DRAM_CTL29_CS_MAP	24
+#define BM_DRAM_CTL29_CS_MAP	0x0F000000
+#define BF_DRAM_CTL29_CS_MAP(v)  \
+		(((v) << 24) & BM_DRAM_CTL29_CS_MAP)
+#define BP_DRAM_CTL29_RSVD3	19
+#define BM_DRAM_CTL29_RSVD3	0x00F80000
+#define BF_DRAM_CTL29_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL29_RSVD3)
+#define BP_DRAM_CTL29_COLUMN_SIZE	16
+#define BM_DRAM_CTL29_COLUMN_SIZE	0x00070000
+#define BF_DRAM_CTL29_COLUMN_SIZE(v)  \
+		(((v) << 16) & BM_DRAM_CTL29_COLUMN_SIZE)
+#define BP_DRAM_CTL29_RSVD2	11
+#define BM_DRAM_CTL29_RSVD2	0x0000F800
+#define BF_DRAM_CTL29_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL29_RSVD2)
+#define BP_DRAM_CTL29_ADDR_PINS	8
+#define BM_DRAM_CTL29_ADDR_PINS	0x00000700
+#define BF_DRAM_CTL29_ADDR_PINS(v)  \
+		(((v) << 8) & BM_DRAM_CTL29_ADDR_PINS)
+#define BP_DRAM_CTL29_RSVD1	4
+#define BM_DRAM_CTL29_RSVD1	0x000000F0
+#define BF_DRAM_CTL29_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL29_RSVD1)
+#define BP_DRAM_CTL29_APREBIT	0
+#define BM_DRAM_CTL29_APREBIT	0x0000000F
+#define BF_DRAM_CTL29_APREBIT(v)  \
+		(((v) << 0) & BM_DRAM_CTL29_APREBIT)
+
+#define HW_DRAM_CTL30	(0x00000078)
+
+#define BP_DRAM_CTL30_OBSOLETE	24
+#define BM_DRAM_CTL30_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL30_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL30_OBSOLETE)
+#define BP_DRAM_CTL30_RSVD3	19
+#define BM_DRAM_CTL30_RSVD3	0x00F80000
+#define BF_DRAM_CTL30_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL30_RSVD3)
+#define BP_DRAM_CTL30_MAX_CS_REG	16
+#define BM_DRAM_CTL30_MAX_CS_REG	0x00070000
+#define BF_DRAM_CTL30_MAX_CS_REG(v)  \
+		(((v) << 16) & BM_DRAM_CTL30_MAX_CS_REG)
+#define BP_DRAM_CTL30_RSVD2	12
+#define BM_DRAM_CTL30_RSVD2	0x0000F000
+#define BF_DRAM_CTL30_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL30_RSVD2)
+#define BP_DRAM_CTL30_MAX_ROW_REG	8
+#define BM_DRAM_CTL30_MAX_ROW_REG	0x00000F00
+#define BF_DRAM_CTL30_MAX_ROW_REG(v)  \
+		(((v) << 8) & BM_DRAM_CTL30_MAX_ROW_REG)
+#define BP_DRAM_CTL30_RSVD1	4
+#define BM_DRAM_CTL30_RSVD1	0x000000F0
+#define BF_DRAM_CTL30_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL30_RSVD1)
+#define BP_DRAM_CTL30_MAX_COL_REG	0
+#define BM_DRAM_CTL30_MAX_COL_REG	0x0000000F
+#define BF_DRAM_CTL30_MAX_COL_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL30_MAX_COL_REG)
+
+#define HW_DRAM_CTL31	(0x0000007c)
+
+#define BP_DRAM_CTL31_OBSOLETE	24
+#define BM_DRAM_CTL31_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL31_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL31_OBSOLETE)
+#define BP_DRAM_CTL31_RSVD3	17
+#define BM_DRAM_CTL31_RSVD3	0x00FE0000
+#define BF_DRAM_CTL31_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL31_RSVD3)
+#define BM_DRAM_CTL31_EIGHT_BANK_MODE	0x00010000
+#define BP_DRAM_CTL31_RSVD2	9
+#define BM_DRAM_CTL31_RSVD2	0x0000FE00
+#define BF_DRAM_CTL31_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL31_RSVD2)
+#define BM_DRAM_CTL31_DRIVE_DQ_DQS	0x00000100
+#define BP_DRAM_CTL31_RSVD1	1
+#define BM_DRAM_CTL31_RSVD1	0x000000FE
+#define BF_DRAM_CTL31_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL31_RSVD1)
+#define BM_DRAM_CTL31_DQS_N_EN	0x00000001
+
+#define HW_DRAM_CTL32	(0x00000080)
+
+#define BP_DRAM_CTL32_OBSOLETE	16
+#define BM_DRAM_CTL32_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL32_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL32_OBSOLETE)
+#define BP_DRAM_CTL32_RSVD2	9
+#define BM_DRAM_CTL32_RSVD2	0x0000FE00
+#define BF_DRAM_CTL32_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL32_RSVD2)
+#define BM_DRAM_CTL32_REDUC	0x00000100
+#define BP_DRAM_CTL32_RSVD1	1
+#define BM_DRAM_CTL32_RSVD1	0x000000FE
+#define BF_DRAM_CTL32_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL32_RSVD1)
+#define BM_DRAM_CTL32_REG_DIMM_ENABLE	0x00000001
+
+#define HW_DRAM_CTL33	(0x00000084)
+
+#define BP_DRAM_CTL33_OBSOLETE	16
+#define BM_DRAM_CTL33_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL33_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL33_OBSOLETE)
+#define BP_DRAM_CTL33_RSVD2	9
+#define BM_DRAM_CTL33_RSVD2	0x0000FE00
+#define BF_DRAM_CTL33_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL33_RSVD2)
+#define BM_DRAM_CTL33_CONCURRENTAP	0x00000100
+#define BP_DRAM_CTL33_RSVD1	1
+#define BM_DRAM_CTL33_RSVD1	0x000000FE
+#define BF_DRAM_CTL33_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL33_RSVD1)
+#define BM_DRAM_CTL33_AP	0x00000001
+
+#define HW_DRAM_CTL34	(0x00000088)
+
+#define BP_DRAM_CTL34_RSVD4	25
+#define BM_DRAM_CTL34_RSVD4	0xFE000000
+#define BF_DRAM_CTL34_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL34_RSVD4)
+#define BM_DRAM_CTL34_WRITEINTERP	0x01000000
+#define BP_DRAM_CTL34_RSVD3	17
+#define BM_DRAM_CTL34_RSVD3	0x00FE0000
+#define BF_DRAM_CTL34_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL34_RSVD3)
+#define BM_DRAM_CTL34_INTRPTWRITEA	0x00010000
+#define BP_DRAM_CTL34_RSVD2	9
+#define BM_DRAM_CTL34_RSVD2	0x0000FE00
+#define BF_DRAM_CTL34_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL34_RSVD2)
+#define BM_DRAM_CTL34_INTRPTREADA	0x00000100
+#define BP_DRAM_CTL34_RSVD1	1
+#define BM_DRAM_CTL34_RSVD1	0x000000FE
+#define BF_DRAM_CTL34_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL34_RSVD1)
+#define BM_DRAM_CTL34_INTRPTAPBURST	0x00000001
+
+#define HW_DRAM_CTL35	(0x0000008c)
+
+#define BP_DRAM_CTL35_OBSOLETE	24
+#define BM_DRAM_CTL35_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL35_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL35_OBSOLETE)
+#define BP_DRAM_CTL35_RSVD3	17
+#define BM_DRAM_CTL35_RSVD3	0x00FE0000
+#define BF_DRAM_CTL35_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL35_RSVD3)
+#define BM_DRAM_CTL35_PWRUP_SREFRESH_EXIT	0x00010000
+#define BP_DRAM_CTL35_RSVD2	9
+#define BM_DRAM_CTL35_RSVD2	0x0000FE00
+#define BF_DRAM_CTL35_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL35_RSVD2)
+#define BM_DRAM_CTL35_NO_CMD_INIT	0x00000100
+#define BP_DRAM_CTL35_RSVD1	4
+#define BM_DRAM_CTL35_RSVD1	0x000000F0
+#define BF_DRAM_CTL35_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL35_RSVD1)
+#define BP_DRAM_CTL35_INITAREF	0
+#define BM_DRAM_CTL35_INITAREF	0x0000000F
+#define BF_DRAM_CTL35_INITAREF(v)  \
+		(((v) << 0) & BM_DRAM_CTL35_INITAREF)
+
+#define HW_DRAM_CTL36	(0x00000090)
+
+#define BP_DRAM_CTL36_RSVD3	25
+#define BM_DRAM_CTL36_RSVD3	0xFE000000
+#define BF_DRAM_CTL36_RSVD3(v) \
+		(((v) << 25) & BM_DRAM_CTL36_RSVD3)
+#define BM_DRAM_CTL36_TREF_ENABLE	0x01000000
+#define BP_DRAM_CTL36_RSVD2	17
+#define BM_DRAM_CTL36_RSVD2	0x00FE0000
+#define BF_DRAM_CTL36_RSVD2(v)  \
+		(((v) << 17) & BM_DRAM_CTL36_RSVD2)
+#define BM_DRAM_CTL36_TRAS_LOCKOUT	0x00010000
+#define BP_DRAM_CTL36_OBSOLETE	8
+#define BM_DRAM_CTL36_OBSOLETE	0x0000FF00
+#define BF_DRAM_CTL36_OBSOLETE(v)  \
+		(((v) << 8) & BM_DRAM_CTL36_OBSOLETE)
+#define BP_DRAM_CTL36_RSVD1	1
+#define BM_DRAM_CTL36_RSVD1	0x000000FE
+#define BF_DRAM_CTL36_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL36_RSVD1)
+#define BM_DRAM_CTL36_FAST_WRITE	0x00000001
+
+#define HW_DRAM_CTL37	(0x00000094)
+
+#define BP_DRAM_CTL37_RSVD4	28
+#define BM_DRAM_CTL37_RSVD4	0xF0000000
+#define BF_DRAM_CTL37_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL37_RSVD4)
+#define BP_DRAM_CTL37_CASLAT_LIN_GATE	24
+#define BM_DRAM_CTL37_CASLAT_LIN_GATE	0x0F000000
+#define BF_DRAM_CTL37_CASLAT_LIN_GATE(v)  \
+		(((v) << 24) & BM_DRAM_CTL37_CASLAT_LIN_GATE)
+#define BP_DRAM_CTL37_RSVD3	20
+#define BM_DRAM_CTL37_RSVD3	0x00F00000
+#define BF_DRAM_CTL37_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL37_RSVD3)
+#define BP_DRAM_CTL37_CASLAT_LIN	16
+#define BM_DRAM_CTL37_CASLAT_LIN	0x000F0000
+#define BF_DRAM_CTL37_CASLAT_LIN(v)  \
+		(((v) << 16) & BM_DRAM_CTL37_CASLAT_LIN)
+#define BP_DRAM_CTL37_RSVD2	11
+#define BM_DRAM_CTL37_RSVD2	0x0000F800
+#define BF_DRAM_CTL37_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL37_RSVD2)
+#define BP_DRAM_CTL37_CASLAT	8
+#define BM_DRAM_CTL37_CASLAT	0x00000700
+#define BF_DRAM_CTL37_CASLAT(v)  \
+		(((v) << 8) & BM_DRAM_CTL37_CASLAT)
+#define BP_DRAM_CTL37_RSVD1	4
+#define BM_DRAM_CTL37_RSVD1	0x000000F0
+#define BF_DRAM_CTL37_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL37_RSVD1)
+#define BP_DRAM_CTL37_WRLAT	0
+#define BM_DRAM_CTL37_WRLAT	0x0000000F
+#define BF_DRAM_CTL37_WRLAT(v)  \
+		(((v) << 0) & BM_DRAM_CTL37_WRLAT)
+
+#define HW_DRAM_CTL38	(0x00000098)
+
+#define BP_DRAM_CTL38_RSVD2	29
+#define BM_DRAM_CTL38_RSVD2	0xE0000000
+#define BF_DRAM_CTL38_RSVD2(v) \
+		(((v) << 29) & BM_DRAM_CTL38_RSVD2)
+#define BP_DRAM_CTL38_TDAL	24
+#define BM_DRAM_CTL38_TDAL	0x1F000000
+#define BF_DRAM_CTL38_TDAL(v)  \
+		(((v) << 24) & BM_DRAM_CTL38_TDAL)
+#define BP_DRAM_CTL38_TCPD	8
+#define BM_DRAM_CTL38_TCPD	0x00FFFF00
+#define BF_DRAM_CTL38_TCPD(v)  \
+		(((v) << 8) & BM_DRAM_CTL38_TCPD)
+#define BP_DRAM_CTL38_RSVD1	3
+#define BM_DRAM_CTL38_RSVD1	0x000000F8
+#define BF_DRAM_CTL38_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL38_RSVD1)
+#define BP_DRAM_CTL38_TCKE	0
+#define BM_DRAM_CTL38_TCKE	0x00000007
+#define BF_DRAM_CTL38_TCKE(v)  \
+		(((v) << 0) & BM_DRAM_CTL38_TCKE)
+
+#define HW_DRAM_CTL39	(0x0000009c)
+
+#define BP_DRAM_CTL39_RSVD1	30
+#define BM_DRAM_CTL39_RSVD1	0xC0000000
+#define BF_DRAM_CTL39_RSVD1(v) \
+		(((v) << 30) & BM_DRAM_CTL39_RSVD1)
+#define BP_DRAM_CTL39_TFAW	24
+#define BM_DRAM_CTL39_TFAW	0x3F000000
+#define BF_DRAM_CTL39_TFAW(v)  \
+		(((v) << 24) & BM_DRAM_CTL39_TFAW)
+#define BP_DRAM_CTL39_OBSOLETE	16
+#define BM_DRAM_CTL39_OBSOLETE	0x00FF0000
+#define BF_DRAM_CTL39_OBSOLETE(v)  \
+		(((v) << 16) & BM_DRAM_CTL39_OBSOLETE)
+#define BP_DRAM_CTL39_TDLL	0
+#define BM_DRAM_CTL39_TDLL	0x0000FFFF
+#define BF_DRAM_CTL39_TDLL(v)  \
+		(((v) << 0) & BM_DRAM_CTL39_TDLL)
+
+#define HW_DRAM_CTL40	(0x000000a0)
+
+#define BP_DRAM_CTL40_RSVD1	29
+#define BM_DRAM_CTL40_RSVD1	0xE0000000
+#define BF_DRAM_CTL40_RSVD1(v) \
+		(((v) << 29) & BM_DRAM_CTL40_RSVD1)
+#define BP_DRAM_CTL40_TMRD	24
+#define BM_DRAM_CTL40_TMRD	0x1F000000
+#define BF_DRAM_CTL40_TMRD(v)  \
+		(((v) << 24) & BM_DRAM_CTL40_TMRD)
+#define BP_DRAM_CTL40_TINIT	0
+#define BM_DRAM_CTL40_TINIT	0x00FFFFFF
+#define BF_DRAM_CTL40_TINIT(v)  \
+		(((v) << 0) & BM_DRAM_CTL40_TINIT)
+
+#define HW_DRAM_CTL41	(0x000000a4)
+
+#define BP_DRAM_CTL41_TPDEX	16
+#define BM_DRAM_CTL41_TPDEX	0xFFFF0000
+#define BF_DRAM_CTL41_TPDEX(v) \
+		(((v) << 16) & BM_DRAM_CTL41_TPDEX)
+#define BP_DRAM_CTL41_TRCD_INT	8
+#define BM_DRAM_CTL41_TRCD_INT	0x0000FF00
+#define BF_DRAM_CTL41_TRCD_INT(v)  \
+		(((v) << 8) & BM_DRAM_CTL41_TRCD_INT)
+#define BP_DRAM_CTL41_RSVD1	6
+#define BM_DRAM_CTL41_RSVD1	0x000000C0
+#define BF_DRAM_CTL41_RSVD1(v)  \
+		(((v) << 6) & BM_DRAM_CTL41_RSVD1)
+#define BP_DRAM_CTL41_TRC	0
+#define BM_DRAM_CTL41_TRC	0x0000003F
+#define BF_DRAM_CTL41_TRC(v)  \
+		(((v) << 0) & BM_DRAM_CTL41_TRC)
+
+#define HW_DRAM_CTL42	(0x000000a8)
+
+#define BP_DRAM_CTL42_OBSOLETE	24
+#define BM_DRAM_CTL42_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL42_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL42_OBSOLETE)
+#define BP_DRAM_CTL42_TRAS_MAX	8
+#define BM_DRAM_CTL42_TRAS_MAX	0x00FFFF00
+#define BF_DRAM_CTL42_TRAS_MAX(v)  \
+		(((v) << 8) & BM_DRAM_CTL42_TRAS_MAX)
+#define BP_DRAM_CTL42_TRAS_MIN	0
+#define BM_DRAM_CTL42_TRAS_MIN	0x000000FF
+#define BF_DRAM_CTL42_TRAS_MIN(v)  \
+		(((v) << 0) & BM_DRAM_CTL42_TRAS_MIN)
+
+#define HW_DRAM_CTL43	(0x000000ac)
+
+#define BP_DRAM_CTL43_RSVD2	28
+#define BM_DRAM_CTL43_RSVD2	0xF0000000
+#define BF_DRAM_CTL43_RSVD2(v) \
+		(((v) << 28) & BM_DRAM_CTL43_RSVD2)
+#define BP_DRAM_CTL43_TRP	24
+#define BM_DRAM_CTL43_TRP	0x0F000000
+#define BF_DRAM_CTL43_TRP(v)  \
+		(((v) << 24) & BM_DRAM_CTL43_TRP)
+#define BP_DRAM_CTL43_TRFC	16
+#define BM_DRAM_CTL43_TRFC	0x00FF0000
+#define BF_DRAM_CTL43_TRFC(v)  \
+		(((v) << 16) & BM_DRAM_CTL43_TRFC)
+#define BP_DRAM_CTL43_RSVD1	14
+#define BM_DRAM_CTL43_RSVD1	0x0000C000
+#define BF_DRAM_CTL43_RSVD1(v)  \
+		(((v) << 14) & BM_DRAM_CTL43_RSVD1)
+#define BP_DRAM_CTL43_TREF	0
+#define BM_DRAM_CTL43_TREF	0x00003FFF
+#define BF_DRAM_CTL43_TREF(v)  \
+		(((v) << 0) & BM_DRAM_CTL43_TREF)
+
+#define HW_DRAM_CTL44	(0x000000b0)
+
+#define BP_DRAM_CTL44_RSVD4	28
+#define BM_DRAM_CTL44_RSVD4	0xF0000000
+#define BF_DRAM_CTL44_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL44_RSVD4)
+#define BP_DRAM_CTL44_TWTR	24
+#define BM_DRAM_CTL44_TWTR	0x0F000000
+#define BF_DRAM_CTL44_TWTR(v)  \
+		(((v) << 24) & BM_DRAM_CTL44_TWTR)
+#define BP_DRAM_CTL44_RSVD3	21
+#define BM_DRAM_CTL44_RSVD3	0x00E00000
+#define BF_DRAM_CTL44_RSVD3(v)  \
+		(((v) << 21) & BM_DRAM_CTL44_RSVD3)
+#define BP_DRAM_CTL44_TWR_INT	16
+#define BM_DRAM_CTL44_TWR_INT	0x001F0000
+#define BF_DRAM_CTL44_TWR_INT(v)  \
+		(((v) << 16) & BM_DRAM_CTL44_TWR_INT)
+#define BP_DRAM_CTL44_RSVD2	11
+#define BM_DRAM_CTL44_RSVD2	0x0000F800
+#define BF_DRAM_CTL44_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL44_RSVD2)
+#define BP_DRAM_CTL44_TRTP	8
+#define BM_DRAM_CTL44_TRTP	0x00000700
+#define BF_DRAM_CTL44_TRTP(v)  \
+		(((v) << 8) & BM_DRAM_CTL44_TRTP)
+#define BP_DRAM_CTL44_RSVD1	3
+#define BM_DRAM_CTL44_RSVD1	0x000000F8
+#define BF_DRAM_CTL44_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL44_RSVD1)
+#define BP_DRAM_CTL44_TRRD	0
+#define BM_DRAM_CTL44_TRRD	0x00000007
+#define BF_DRAM_CTL44_TRRD(v)  \
+		(((v) << 0) & BM_DRAM_CTL44_TRRD)
+
+#define HW_DRAM_CTL45	(0x000000b4)
+
+#define BP_DRAM_CTL45_TXSR	16
+#define BM_DRAM_CTL45_TXSR	0xFFFF0000
+#define BF_DRAM_CTL45_TXSR(v) \
+		(((v) << 16) & BM_DRAM_CTL45_TXSR)
+#define BP_DRAM_CTL45_TXSNR	0
+#define BM_DRAM_CTL45_TXSNR	0x0000FFFF
+#define BF_DRAM_CTL45_TXSNR(v)  \
+		(((v) << 0) & BM_DRAM_CTL45_TXSNR)
+
+#define HW_DRAM_CTL48	(0x000000c0)
+
+#define BM_DRAM_CTL48_RSVD4	0x80000000
+#define BP_DRAM_CTL48_AXI0_CURRENT_BDW	24
+#define BM_DRAM_CTL48_AXI0_CURRENT_BDW	0x7F000000
+#define BF_DRAM_CTL48_AXI0_CURRENT_BDW(v)  \
+		(((v) << 24) & BM_DRAM_CTL48_AXI0_CURRENT_BDW)
+#define BP_DRAM_CTL48_RSVD3	17
+#define BM_DRAM_CTL48_RSVD3	0x00FE0000
+#define BF_DRAM_CTL48_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL48_RSVD3)
+#define BM_DRAM_CTL48_AXI0_BDW_OVFLOW	0x00010000
+#define BM_DRAM_CTL48_RSVD2	0x00008000
+#define BP_DRAM_CTL48_AXI0_BDW	8
+#define BM_DRAM_CTL48_AXI0_BDW	0x00007F00
+#define BF_DRAM_CTL48_AXI0_BDW(v)  \
+		(((v) << 8) & BM_DRAM_CTL48_AXI0_BDW)
+#define BP_DRAM_CTL48_RSVD1	2
+#define BM_DRAM_CTL48_RSVD1	0x000000FC
+#define BF_DRAM_CTL48_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL48_RSVD1)
+#define BP_DRAM_CTL48_AXI0_FIFO_TYPE_REG	0
+#define BM_DRAM_CTL48_AXI0_FIFO_TYPE_REG	0x00000003
+#define BF_DRAM_CTL48_AXI0_FIFO_TYPE_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL48_AXI0_FIFO_TYPE_REG)
+
+#define HW_DRAM_CTL49	(0x000000c4)
+
+#define BP_DRAM_CTL49_AXI0_EN_SIZE_LT_WIDTH_INSTR	16
+#define BM_DRAM_CTL49_AXI0_EN_SIZE_LT_WIDTH_INSTR	0xFFFF0000
+#define BF_DRAM_CTL49_AXI0_EN_SIZE_LT_WIDTH_INSTR(v) \
+		(((v) << 16) & BM_DRAM_CTL49_AXI0_EN_SIZE_LT_WIDTH_INSTR)
+#define BP_DRAM_CTL49_RSVD2	11
+#define BM_DRAM_CTL49_RSVD2	0x0000F800
+#define BF_DRAM_CTL49_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL49_RSVD2)
+#define BP_DRAM_CTL49_AXI0_W_PRIORITY	8
+#define BM_DRAM_CTL49_AXI0_W_PRIORITY	0x00000700
+#define BF_DRAM_CTL49_AXI0_W_PRIORITY(v)  \
+		(((v) << 8) & BM_DRAM_CTL49_AXI0_W_PRIORITY)
+#define BP_DRAM_CTL49_RSVD1	3
+#define BM_DRAM_CTL49_RSVD1	0x000000F8
+#define BF_DRAM_CTL49_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL49_RSVD1)
+#define BP_DRAM_CTL49_AXI0_R_PRIORITY	0
+#define BM_DRAM_CTL49_AXI0_R_PRIORITY	0x00000007
+#define BF_DRAM_CTL49_AXI0_R_PRIORITY(v)  \
+		(((v) << 0) & BM_DRAM_CTL49_AXI0_R_PRIORITY)
+
+#define HW_DRAM_CTL50	(0x000000c8)
+
+#define BM_DRAM_CTL50_RSVD4	0x80000000
+#define BP_DRAM_CTL50_AXI1_CURRENT_BDW	24
+#define BM_DRAM_CTL50_AXI1_CURRENT_BDW	0x7F000000
+#define BF_DRAM_CTL50_AXI1_CURRENT_BDW(v)  \
+		(((v) << 24) & BM_DRAM_CTL50_AXI1_CURRENT_BDW)
+#define BP_DRAM_CTL50_RSVD3	17
+#define BM_DRAM_CTL50_RSVD3	0x00FE0000
+#define BF_DRAM_CTL50_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL50_RSVD3)
+#define BM_DRAM_CTL50_AXI1_BDW_OVFLOW	0x00010000
+#define BM_DRAM_CTL50_RSVD2	0x00008000
+#define BP_DRAM_CTL50_AXI1_BDW	8
+#define BM_DRAM_CTL50_AXI1_BDW	0x00007F00
+#define BF_DRAM_CTL50_AXI1_BDW(v)  \
+		(((v) << 8) & BM_DRAM_CTL50_AXI1_BDW)
+#define BP_DRAM_CTL50_RSVD1	2
+#define BM_DRAM_CTL50_RSVD1	0x000000FC
+#define BF_DRAM_CTL50_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL50_RSVD1)
+#define BP_DRAM_CTL50_AXI1_FIFO_TYPE_REG	0
+#define BM_DRAM_CTL50_AXI1_FIFO_TYPE_REG	0x00000003
+#define BF_DRAM_CTL50_AXI1_FIFO_TYPE_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL50_AXI1_FIFO_TYPE_REG)
+
+#define HW_DRAM_CTL51	(0x000000cc)
+
+#define BP_DRAM_CTL51_AXI1_EN_SIZE_LT_WIDTH_INSTR	16
+#define BM_DRAM_CTL51_AXI1_EN_SIZE_LT_WIDTH_INSTR	0xFFFF0000
+#define BF_DRAM_CTL51_AXI1_EN_SIZE_LT_WIDTH_INSTR(v) \
+		(((v) << 16) & BM_DRAM_CTL51_AXI1_EN_SIZE_LT_WIDTH_INSTR)
+#define BP_DRAM_CTL51_RSVD2	11
+#define BM_DRAM_CTL51_RSVD2	0x0000F800
+#define BF_DRAM_CTL51_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL51_RSVD2)
+#define BP_DRAM_CTL51_AXI1_W_PRIORITY	8
+#define BM_DRAM_CTL51_AXI1_W_PRIORITY	0x00000700
+#define BF_DRAM_CTL51_AXI1_W_PRIORITY(v)  \
+		(((v) << 8) & BM_DRAM_CTL51_AXI1_W_PRIORITY)
+#define BP_DRAM_CTL51_RSVD1	3
+#define BM_DRAM_CTL51_RSVD1	0x000000F8
+#define BF_DRAM_CTL51_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL51_RSVD1)
+#define BP_DRAM_CTL51_AXI1_R_PRIORITY	0
+#define BM_DRAM_CTL51_AXI1_R_PRIORITY	0x00000007
+#define BF_DRAM_CTL51_AXI1_R_PRIORITY(v)  \
+		(((v) << 0) & BM_DRAM_CTL51_AXI1_R_PRIORITY)
+
+#define HW_DRAM_CTL52	(0x000000d0)
+
+#define BM_DRAM_CTL52_RSVD4	0x80000000
+#define BP_DRAM_CTL52_AXI2_CURRENT_BDW	24
+#define BM_DRAM_CTL52_AXI2_CURRENT_BDW	0x7F000000
+#define BF_DRAM_CTL52_AXI2_CURRENT_BDW(v)  \
+		(((v) << 24) & BM_DRAM_CTL52_AXI2_CURRENT_BDW)
+#define BP_DRAM_CTL52_RSVD3	17
+#define BM_DRAM_CTL52_RSVD3	0x00FE0000
+#define BF_DRAM_CTL52_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL52_RSVD3)
+#define BM_DRAM_CTL52_AXI2_BDW_OVFLOW	0x00010000
+#define BM_DRAM_CTL52_RSVD2	0x00008000
+#define BP_DRAM_CTL52_AXI2_BDW	8
+#define BM_DRAM_CTL52_AXI2_BDW	0x00007F00
+#define BF_DRAM_CTL52_AXI2_BDW(v)  \
+		(((v) << 8) & BM_DRAM_CTL52_AXI2_BDW)
+#define BP_DRAM_CTL52_RSVD1	2
+#define BM_DRAM_CTL52_RSVD1	0x000000FC
+#define BF_DRAM_CTL52_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL52_RSVD1)
+#define BP_DRAM_CTL52_AXI2_FIFO_TYPE_REG	0
+#define BM_DRAM_CTL52_AXI2_FIFO_TYPE_REG	0x00000003
+#define BF_DRAM_CTL52_AXI2_FIFO_TYPE_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL52_AXI2_FIFO_TYPE_REG)
+
+#define HW_DRAM_CTL53	(0x000000d4)
+
+#define BP_DRAM_CTL53_AXI2_EN_SIZE_LT_WIDTH_INSTR	16
+#define BM_DRAM_CTL53_AXI2_EN_SIZE_LT_WIDTH_INSTR	0xFFFF0000
+#define BF_DRAM_CTL53_AXI2_EN_SIZE_LT_WIDTH_INSTR(v) \
+		(((v) << 16) & BM_DRAM_CTL53_AXI2_EN_SIZE_LT_WIDTH_INSTR)
+#define BP_DRAM_CTL53_RSVD2	11
+#define BM_DRAM_CTL53_RSVD2	0x0000F800
+#define BF_DRAM_CTL53_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL53_RSVD2)
+#define BP_DRAM_CTL53_AXI2_W_PRIORITY	8
+#define BM_DRAM_CTL53_AXI2_W_PRIORITY	0x00000700
+#define BF_DRAM_CTL53_AXI2_W_PRIORITY(v)  \
+		(((v) << 8) & BM_DRAM_CTL53_AXI2_W_PRIORITY)
+#define BP_DRAM_CTL53_RSVD1	3
+#define BM_DRAM_CTL53_RSVD1	0x000000F8
+#define BF_DRAM_CTL53_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL53_RSVD1)
+#define BP_DRAM_CTL53_AXI2_R_PRIORITY	0
+#define BM_DRAM_CTL53_AXI2_R_PRIORITY	0x00000007
+#define BF_DRAM_CTL53_AXI2_R_PRIORITY(v)  \
+		(((v) << 0) & BM_DRAM_CTL53_AXI2_R_PRIORITY)
+
+#define HW_DRAM_CTL54	(0x000000d8)
+
+#define BM_DRAM_CTL54_RSVD4	0x80000000
+#define BP_DRAM_CTL54_AXI3_CURRENT_BDW	24
+#define BM_DRAM_CTL54_AXI3_CURRENT_BDW	0x7F000000
+#define BF_DRAM_CTL54_AXI3_CURRENT_BDW(v)  \
+		(((v) << 24) & BM_DRAM_CTL54_AXI3_CURRENT_BDW)
+#define BP_DRAM_CTL54_RSVD3	17
+#define BM_DRAM_CTL54_RSVD3	0x00FE0000
+#define BF_DRAM_CTL54_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL54_RSVD3)
+#define BM_DRAM_CTL54_AXI3_BDW_OVFLOW	0x00010000
+#define BM_DRAM_CTL54_RSVD2	0x00008000
+#define BP_DRAM_CTL54_AXI3_BDW	8
+#define BM_DRAM_CTL54_AXI3_BDW	0x00007F00
+#define BF_DRAM_CTL54_AXI3_BDW(v)  \
+		(((v) << 8) & BM_DRAM_CTL54_AXI3_BDW)
+#define BP_DRAM_CTL54_RSVD1	2
+#define BM_DRAM_CTL54_RSVD1	0x000000FC
+#define BF_DRAM_CTL54_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL54_RSVD1)
+#define BP_DRAM_CTL54_AXI3_FIFO_TYPE_REG	0
+#define BM_DRAM_CTL54_AXI3_FIFO_TYPE_REG	0x00000003
+#define BF_DRAM_CTL54_AXI3_FIFO_TYPE_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL54_AXI3_FIFO_TYPE_REG)
+
+#define HW_DRAM_CTL55	(0x000000dc)
+
+#define BP_DRAM_CTL55_AXI3_EN_SIZE_LT_WIDTH_INSTR	16
+#define BM_DRAM_CTL55_AXI3_EN_SIZE_LT_WIDTH_INSTR	0xFFFF0000
+#define BF_DRAM_CTL55_AXI3_EN_SIZE_LT_WIDTH_INSTR(v) \
+		(((v) << 16) & BM_DRAM_CTL55_AXI3_EN_SIZE_LT_WIDTH_INSTR)
+#define BP_DRAM_CTL55_RSVD2	11
+#define BM_DRAM_CTL55_RSVD2	0x0000F800
+#define BF_DRAM_CTL55_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL55_RSVD2)
+#define BP_DRAM_CTL55_AXI3_W_PRIORITY	8
+#define BM_DRAM_CTL55_AXI3_W_PRIORITY	0x00000700
+#define BF_DRAM_CTL55_AXI3_W_PRIORITY(v)  \
+		(((v) << 8) & BM_DRAM_CTL55_AXI3_W_PRIORITY)
+#define BP_DRAM_CTL55_RSVD1	3
+#define BM_DRAM_CTL55_RSVD1	0x000000F8
+#define BF_DRAM_CTL55_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL55_RSVD1)
+#define BP_DRAM_CTL55_AXI3_R_PRIORITY	0
+#define BM_DRAM_CTL55_AXI3_R_PRIORITY	0x00000007
+#define BF_DRAM_CTL55_AXI3_R_PRIORITY(v)  \
+		(((v) << 0) & BM_DRAM_CTL55_AXI3_R_PRIORITY)
+
+#define HW_DRAM_CTL56	(0x000000e0)
+
+#define BP_DRAM_CTL56_OBSOLETE	8
+#define BM_DRAM_CTL56_OBSOLETE	0xFFFFFF00
+#define BF_DRAM_CTL56_OBSOLETE(v) \
+		(((v) << 8) & BM_DRAM_CTL56_OBSOLETE)
+#define BP_DRAM_CTL56_RSVD1	3
+#define BM_DRAM_CTL56_RSVD1	0x000000F8
+#define BF_DRAM_CTL56_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL56_RSVD1)
+#define BP_DRAM_CTL56_ARB_CMD_Q_THRESHOLD	0
+#define BM_DRAM_CTL56_ARB_CMD_Q_THRESHOLD	0x00000007
+#define BF_DRAM_CTL56_ARB_CMD_Q_THRESHOLD(v)  \
+		(((v) << 0) & BM_DRAM_CTL56_ARB_CMD_Q_THRESHOLD)
+
+#define HW_DRAM_CTL58	(0x000000e8)
+
+#define BP_DRAM_CTL58_RSVD2	27
+#define BM_DRAM_CTL58_RSVD2	0xF8000000
+#define BF_DRAM_CTL58_RSVD2(v) \
+		(((v) << 27) & BM_DRAM_CTL58_RSVD2)
+#define BP_DRAM_CTL58_INT_STATUS	16
+#define BM_DRAM_CTL58_INT_STATUS	0x07FF0000
+#define BF_DRAM_CTL58_INT_STATUS(v)  \
+		(((v) << 16) & BM_DRAM_CTL58_INT_STATUS)
+#define BP_DRAM_CTL58_RSVD1	11
+#define BM_DRAM_CTL58_RSVD1	0x0000F800
+#define BF_DRAM_CTL58_RSVD1(v)  \
+		(((v) << 11) & BM_DRAM_CTL58_RSVD1)
+#define BP_DRAM_CTL58_INT_MASK	0
+#define BM_DRAM_CTL58_INT_MASK	0x000007FF
+#define BF_DRAM_CTL58_INT_MASK(v)  \
+		(((v) << 0) & BM_DRAM_CTL58_INT_MASK)
+
+#define HW_DRAM_CTL59	(0x000000ec)
+
+#define BP_DRAM_CTL59_OUT_OF_RANGE_ADDR	0
+#define BM_DRAM_CTL59_OUT_OF_RANGE_ADDR	0xFFFFFFFF
+#define BF_DRAM_CTL59_OUT_OF_RANGE_ADDR(v)	(v)
+
+#define HW_DRAM_CTL60	(0x000000f0)
+
+#define BP_DRAM_CTL60_OBSOLETE	8
+#define BM_DRAM_CTL60_OBSOLETE	0xFFFFFF00
+#define BF_DRAM_CTL60_OBSOLETE(v) \
+		(((v) << 8) & BM_DRAM_CTL60_OBSOLETE)
+#define BP_DRAM_CTL60_RSVD1	2
+#define BM_DRAM_CTL60_RSVD1	0x000000FC
+#define BF_DRAM_CTL60_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL60_RSVD1)
+#define BP_DRAM_CTL60_OUT_OF_RANGE_ADDR	0
+#define BM_DRAM_CTL60_OUT_OF_RANGE_ADDR	0x00000003
+#define BF_DRAM_CTL60_OUT_OF_RANGE_ADDR(v)  \
+		(((v) << 0) & BM_DRAM_CTL60_OUT_OF_RANGE_ADDR)
+
+#define HW_DRAM_CTL61	(0x000000f4)
+
+#define BP_DRAM_CTL61_RSVD3	30
+#define BM_DRAM_CTL61_RSVD3	0xC0000000
+#define BF_DRAM_CTL61_RSVD3(v) \
+		(((v) << 30) & BM_DRAM_CTL61_RSVD3)
+#define BP_DRAM_CTL61_OUT_OF_RANGE_TYPE	24
+#define BM_DRAM_CTL61_OUT_OF_RANGE_TYPE	0x3F000000
+#define BF_DRAM_CTL61_OUT_OF_RANGE_TYPE(v)  \
+		(((v) << 24) & BM_DRAM_CTL61_OUT_OF_RANGE_TYPE)
+#define BM_DRAM_CTL61_RSVD2	0x00800000
+#define BP_DRAM_CTL61_OUT_OF_RANGE_LENGTH	16
+#define BM_DRAM_CTL61_OUT_OF_RANGE_LENGTH	0x007F0000
+#define BF_DRAM_CTL61_OUT_OF_RANGE_LENGTH(v)  \
+		(((v) << 16) & BM_DRAM_CTL61_OUT_OF_RANGE_LENGTH)
+#define BP_DRAM_CTL61_RSVD1	13
+#define BM_DRAM_CTL61_RSVD1	0x0000E000
+#define BF_DRAM_CTL61_RSVD1(v)  \
+		(((v) << 13) & BM_DRAM_CTL61_RSVD1)
+#define BP_DRAM_CTL61_OUT_OF_RANGE_SOURCE_ID	0
+#define BM_DRAM_CTL61_OUT_OF_RANGE_SOURCE_ID	0x00001FFF
+#define BF_DRAM_CTL61_OUT_OF_RANGE_SOURCE_ID(v)  \
+		(((v) << 0) & BM_DRAM_CTL61_OUT_OF_RANGE_SOURCE_ID)
+
+#define HW_DRAM_CTL62	(0x000000f8)
+
+#define BP_DRAM_CTL62_PORT_CMD_ERROR_ADDR	0
+#define BM_DRAM_CTL62_PORT_CMD_ERROR_ADDR	0xFFFFFFFF
+#define BF_DRAM_CTL62_PORT_CMD_ERROR_ADDR(v)	(v)
+
+#define HW_DRAM_CTL63	(0x000000fc)
+
+#define BP_DRAM_CTL63_OBSOLETE	8
+#define BM_DRAM_CTL63_OBSOLETE	0xFFFFFF00
+#define BF_DRAM_CTL63_OBSOLETE(v) \
+		(((v) << 8) & BM_DRAM_CTL63_OBSOLETE)
+#define BP_DRAM_CTL63_RSVD1	2
+#define BM_DRAM_CTL63_RSVD1	0x000000FC
+#define BF_DRAM_CTL63_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL63_RSVD1)
+#define BP_DRAM_CTL63_PORT_CMD_ERROR_ADDR	0
+#define BM_DRAM_CTL63_PORT_CMD_ERROR_ADDR	0x00000003
+#define BF_DRAM_CTL63_PORT_CMD_ERROR_ADDR(v)  \
+		(((v) << 0) & BM_DRAM_CTL63_PORT_CMD_ERROR_ADDR)
+
+#define HW_DRAM_CTL64	(0x00000100)
+
+#define BP_DRAM_CTL64_OBSOLETE	24
+#define BM_DRAM_CTL64_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL64_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL64_OBSOLETE)
+#define BP_DRAM_CTL64_RSVD2	21
+#define BM_DRAM_CTL64_RSVD2	0x00E00000
+#define BF_DRAM_CTL64_RSVD2(v)  \
+		(((v) << 21) & BM_DRAM_CTL64_RSVD2)
+#define BP_DRAM_CTL64_PORT_CMD_ERROR_ID	8
+#define BM_DRAM_CTL64_PORT_CMD_ERROR_ID	0x001FFF00
+#define BF_DRAM_CTL64_PORT_CMD_ERROR_ID(v)  \
+		(((v) << 8) & BM_DRAM_CTL64_PORT_CMD_ERROR_ID)
+#define BP_DRAM_CTL64_RSVD1	4
+#define BM_DRAM_CTL64_RSVD1	0x000000F0
+#define BF_DRAM_CTL64_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL64_RSVD1)
+#define BP_DRAM_CTL64_PORT_CMD_ERROR_TYPE	0
+#define BM_DRAM_CTL64_PORT_CMD_ERROR_TYPE	0x0000000F
+#define BF_DRAM_CTL64_PORT_CMD_ERROR_TYPE(v)  \
+		(((v) << 0) & BM_DRAM_CTL64_PORT_CMD_ERROR_TYPE)
+
+#define HW_DRAM_CTL65	(0x00000104)
+
+#define BP_DRAM_CTL65_OBSOLETE	24
+#define BM_DRAM_CTL65_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL65_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL65_OBSOLETE)
+#define BP_DRAM_CTL65_RSVD2	21
+#define BM_DRAM_CTL65_RSVD2	0x00E00000
+#define BF_DRAM_CTL65_RSVD2(v)  \
+		(((v) << 21) & BM_DRAM_CTL65_RSVD2)
+#define BP_DRAM_CTL65_PORT_DATA_ERROR_ID	8
+#define BM_DRAM_CTL65_PORT_DATA_ERROR_ID	0x001FFF00
+#define BF_DRAM_CTL65_PORT_DATA_ERROR_ID(v)  \
+		(((v) << 8) & BM_DRAM_CTL65_PORT_DATA_ERROR_ID)
+#define BP_DRAM_CTL65_RSVD1	3
+#define BM_DRAM_CTL65_RSVD1	0x000000F8
+#define BF_DRAM_CTL65_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL65_RSVD1)
+#define BP_DRAM_CTL65_PORT_DATA_ERROR_TYPE	0
+#define BM_DRAM_CTL65_PORT_DATA_ERROR_TYPE	0x00000007
+#define BF_DRAM_CTL65_PORT_DATA_ERROR_TYPE(v)  \
+		(((v) << 0) & BM_DRAM_CTL65_PORT_DATA_ERROR_TYPE)
+
+#define HW_DRAM_CTL66	(0x00000108)
+
+#define BP_DRAM_CTL66_OBSOLETE	24
+#define BM_DRAM_CTL66_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL66_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL66_OBSOLETE)
+#define BP_DRAM_CTL66_RSVD2	20
+#define BM_DRAM_CTL66_RSVD2	0x00F00000
+#define BF_DRAM_CTL66_RSVD2(v)  \
+		(((v) << 20) & BM_DRAM_CTL66_RSVD2)
+#define BP_DRAM_CTL66_TDFI_CTRLUPD_MIN	16
+#define BM_DRAM_CTL66_TDFI_CTRLUPD_MIN	0x000F0000
+#define BF_DRAM_CTL66_TDFI_CTRLUPD_MIN(v)  \
+		(((v) << 16) & BM_DRAM_CTL66_TDFI_CTRLUPD_MIN)
+#define BP_DRAM_CTL66_RSVD1	14
+#define BM_DRAM_CTL66_RSVD1	0x0000C000
+#define BF_DRAM_CTL66_RSVD1(v)  \
+		(((v) << 14) & BM_DRAM_CTL66_RSVD1)
+#define BP_DRAM_CTL66_TDFI_CTRLUPD_MAX	0
+#define BM_DRAM_CTL66_TDFI_CTRLUPD_MAX	0x00003FFF
+#define BF_DRAM_CTL66_TDFI_CTRLUPD_MAX(v)  \
+		(((v) << 0) & BM_DRAM_CTL66_TDFI_CTRLUPD_MAX)
+
+#define HW_DRAM_CTL67	(0x0000010c)
+
+#define BP_DRAM_CTL67_RSVD4	28
+#define BM_DRAM_CTL67_RSVD4	0xF0000000
+#define BF_DRAM_CTL67_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL67_RSVD4)
+#define BP_DRAM_CTL67_TDFI_DRAM_CLK_ENABLE	24
+#define BM_DRAM_CTL67_TDFI_DRAM_CLK_ENABLE	0x0F000000
+#define BF_DRAM_CTL67_TDFI_DRAM_CLK_ENABLE(v)  \
+		(((v) << 24) & BM_DRAM_CTL67_TDFI_DRAM_CLK_ENABLE)
+#define BP_DRAM_CTL67_RSVD3	19
+#define BM_DRAM_CTL67_RSVD3	0x00F80000
+#define BF_DRAM_CTL67_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL67_RSVD3)
+#define BP_DRAM_CTL67_TDFI_DRAM_CLK_DISABLE	16
+#define BM_DRAM_CTL67_TDFI_DRAM_CLK_DISABLE	0x00070000
+#define BF_DRAM_CTL67_TDFI_DRAM_CLK_DISABLE(v)  \
+		(((v) << 16) & BM_DRAM_CTL67_TDFI_DRAM_CLK_DISABLE)
+#define BP_DRAM_CTL67_RSVD2	12
+#define BM_DRAM_CTL67_RSVD2	0x0000F000
+#define BF_DRAM_CTL67_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL67_RSVD2)
+#define BP_DRAM_CTL67_DRAM_CLK_ENABLE	8
+#define BM_DRAM_CTL67_DRAM_CLK_ENABLE	0x00000F00
+#define BF_DRAM_CTL67_DRAM_CLK_ENABLE(v)  \
+		(((v) << 8) & BM_DRAM_CTL67_DRAM_CLK_ENABLE)
+#define BP_DRAM_CTL67_RSVD1	4
+#define BM_DRAM_CTL67_RSVD1	0x000000F0
+#define BF_DRAM_CTL67_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL67_RSVD1)
+#define BP_DRAM_CTL67_TDFI_CTRL_DELAY	0
+#define BM_DRAM_CTL67_TDFI_CTRL_DELAY	0x0000000F
+#define BF_DRAM_CTL67_TDFI_CTRL_DELAY(v)  \
+		(((v) << 0) & BM_DRAM_CTL67_TDFI_CTRL_DELAY)
+
+#define HW_DRAM_CTL68	(0x00000110)
+
+#define BP_DRAM_CTL68_RSVD2	30
+#define BM_DRAM_CTL68_RSVD2	0xC0000000
+#define BF_DRAM_CTL68_RSVD2(v) \
+		(((v) << 30) & BM_DRAM_CTL68_RSVD2)
+#define BP_DRAM_CTL68_TDFI_PHYUPD_TYPE0	16
+#define BM_DRAM_CTL68_TDFI_PHYUPD_TYPE0	0x3FFF0000
+#define BF_DRAM_CTL68_TDFI_PHYUPD_TYPE0(v)  \
+		(((v) << 16) & BM_DRAM_CTL68_TDFI_PHYUPD_TYPE0)
+#define BP_DRAM_CTL68_RSVD1	14
+#define BM_DRAM_CTL68_RSVD1	0x0000C000
+#define BF_DRAM_CTL68_RSVD1(v)  \
+		(((v) << 14) & BM_DRAM_CTL68_RSVD1)
+#define BP_DRAM_CTL68_TDFI_PHYUPD_RESP	0
+#define BM_DRAM_CTL68_TDFI_PHYUPD_RESP	0x00003FFF
+#define BF_DRAM_CTL68_TDFI_PHYUPD_RESP(v)  \
+		(((v) << 0) & BM_DRAM_CTL68_TDFI_PHYUPD_RESP)
+
+#define HW_DRAM_CTL69	(0x00000114)
+
+#define BP_DRAM_CTL69_OBSOLETE	16
+#define BM_DRAM_CTL69_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL69_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL69_OBSOLETE)
+#define BP_DRAM_CTL69_RSVD2	12
+#define BM_DRAM_CTL69_RSVD2	0x0000F000
+#define BF_DRAM_CTL69_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL69_RSVD2)
+#define BP_DRAM_CTL69_TDFI_PHY_WRLAT_BASE	8
+#define BM_DRAM_CTL69_TDFI_PHY_WRLAT_BASE	0x00000F00
+#define BF_DRAM_CTL69_TDFI_PHY_WRLAT_BASE(v)  \
+		(((v) << 8) & BM_DRAM_CTL69_TDFI_PHY_WRLAT_BASE)
+#define BP_DRAM_CTL69_RSVD1	4
+#define BM_DRAM_CTL69_RSVD1	0x000000F0
+#define BF_DRAM_CTL69_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL69_RSVD1)
+#define BP_DRAM_CTL69_TDFI_PHY_WRLAT	0
+#define BM_DRAM_CTL69_TDFI_PHY_WRLAT	0x0000000F
+#define BF_DRAM_CTL69_TDFI_PHY_WRLAT(v)  \
+		(((v) << 0) & BM_DRAM_CTL69_TDFI_PHY_WRLAT)
+
+#define HW_DRAM_CTL70	(0x00000118)
+
+#define BP_DRAM_CTL70_OBSOLETE	24
+#define BM_DRAM_CTL70_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL70_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL70_OBSOLETE)
+#define BP_DRAM_CTL70_RSVD3	20
+#define BM_DRAM_CTL70_RSVD3	0x00F00000
+#define BF_DRAM_CTL70_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL70_RSVD3)
+#define BP_DRAM_CTL70_TDFI_RDDATA_EN_BASE	16
+#define BM_DRAM_CTL70_TDFI_RDDATA_EN_BASE	0x000F0000
+#define BF_DRAM_CTL70_TDFI_RDDATA_EN_BASE(v)  \
+		(((v) << 16) & BM_DRAM_CTL70_TDFI_RDDATA_EN_BASE)
+#define BP_DRAM_CTL70_RSVD2	12
+#define BM_DRAM_CTL70_RSVD2	0x0000F000
+#define BF_DRAM_CTL70_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL70_RSVD2)
+#define BP_DRAM_CTL70_TDFI_RDDATA_EN	8
+#define BM_DRAM_CTL70_TDFI_RDDATA_EN	0x00000F00
+#define BF_DRAM_CTL70_TDFI_RDDATA_EN(v)  \
+		(((v) << 8) & BM_DRAM_CTL70_TDFI_RDDATA_EN)
+#define BP_DRAM_CTL70_RSVD1	4
+#define BM_DRAM_CTL70_RSVD1	0x000000F0
+#define BF_DRAM_CTL70_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL70_RSVD1)
+#define BP_DRAM_CTL70_TDFI_PHY_RDLAT	0
+#define BM_DRAM_CTL70_TDFI_PHY_RDLAT	0x0000000F
+#define BF_DRAM_CTL70_TDFI_PHY_RDLAT(v)  \
+		(((v) << 0) & BM_DRAM_CTL70_TDFI_PHY_RDLAT)
+
+#define HW_DRAM_CTL71	(0x0000011c)
+
+#define BP_DRAM_CTL71_PHY_CTRL_REG_0_0	0
+#define BM_DRAM_CTL71_PHY_CTRL_REG_0_0	0xFFFFFFFF
+#define BF_DRAM_CTL71_PHY_CTRL_REG_0_0(v)	(v)
+
+#define HW_DRAM_CTL72	(0x00000120)
+
+#define BP_DRAM_CTL72_PHY_CTRL_REG_0_1	0
+#define BM_DRAM_CTL72_PHY_CTRL_REG_0_1	0xFFFFFFFF
+#define BF_DRAM_CTL72_PHY_CTRL_REG_0_1(v)	(v)
+
+#define HW_DRAM_CTL73	(0x00000124)
+
+#define BP_DRAM_CTL73_PHY_CTRL_REG_0_2	0
+#define BM_DRAM_CTL73_PHY_CTRL_REG_0_2	0xFFFFFFFF
+#define BF_DRAM_CTL73_PHY_CTRL_REG_0_2(v)	(v)
+
+#define HW_DRAM_CTL74	(0x00000128)
+
+#define BP_DRAM_CTL74_PHY_CTRL_REG_0_3	0
+#define BM_DRAM_CTL74_PHY_CTRL_REG_0_3	0xFFFFFFFF
+#define BF_DRAM_CTL74_PHY_CTRL_REG_0_3(v)	(v)
+
+#define HW_DRAM_CTL75	(0x0000012c)
+
+#define BP_DRAM_CTL75_PHY_CTRL_REG_1_0	0
+#define BM_DRAM_CTL75_PHY_CTRL_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL75_PHY_CTRL_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL76	(0x00000130)
+
+#define BP_DRAM_CTL76_PHY_CTRL_REG_1_1	0
+#define BM_DRAM_CTL76_PHY_CTRL_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL76_PHY_CTRL_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL77	(0x00000134)
+
+#define BP_DRAM_CTL77_PHY_CTRL_REG_1_2	0
+#define BM_DRAM_CTL77_PHY_CTRL_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL77_PHY_CTRL_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL78	(0x00000138)
+
+#define BP_DRAM_CTL78_PHY_CTRL_REG_1_3	0
+#define BM_DRAM_CTL78_PHY_CTRL_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL78_PHY_CTRL_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL79	(0x0000013c)
+
+#define BP_DRAM_CTL79_PHY_CTRL_REG_2	0
+#define BM_DRAM_CTL79_PHY_CTRL_REG_2	0xFFFFFFFF
+#define BF_DRAM_CTL79_PHY_CTRL_REG_2(v)	(v)
+
+#define HW_DRAM_CTL80	(0x00000140)
+
+#define BP_DRAM_CTL80_DFT_CTRL_REG	0
+#define BM_DRAM_CTL80_DFT_CTRL_REG	0xFFFFFFFF
+#define BF_DRAM_CTL80_DFT_CTRL_REG(v)	(v)
+
+#define HW_DRAM_CTL81	(0x00000144)
+
+#define BP_DRAM_CTL81_OBSOLETE	16
+#define BM_DRAM_CTL81_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL81_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL81_OBSOLETE)
+#define BP_DRAM_CTL81_RSVD2	13
+#define BM_DRAM_CTL81_RSVD2	0x0000E000
+#define BF_DRAM_CTL81_RSVD2(v)  \
+		(((v) << 13) & BM_DRAM_CTL81_RSVD2)
+#define BP_DRAM_CTL81_OCD_ADJUST_PUP_CS_0	8
+#define BM_DRAM_CTL81_OCD_ADJUST_PUP_CS_0	0x00001F00
+#define BF_DRAM_CTL81_OCD_ADJUST_PUP_CS_0(v)  \
+		(((v) << 8) & BM_DRAM_CTL81_OCD_ADJUST_PUP_CS_0)
+#define BP_DRAM_CTL81_RSVD1	5
+#define BM_DRAM_CTL81_RSVD1	0x000000E0
+#define BF_DRAM_CTL81_RSVD1(v)  \
+		(((v) << 5) & BM_DRAM_CTL81_RSVD1)
+#define BP_DRAM_CTL81_OCD_ADJUST_PDN_CS_0	0
+#define BM_DRAM_CTL81_OCD_ADJUST_PDN_CS_0	0x0000001F
+#define BF_DRAM_CTL81_OCD_ADJUST_PDN_CS_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL81_OCD_ADJUST_PDN_CS_0)
+
+#define HW_DRAM_CTL82	(0x00000148)
+
+#define BP_DRAM_CTL82_RSVD1	25
+#define BM_DRAM_CTL82_RSVD1	0xFE000000
+#define BF_DRAM_CTL82_RSVD1(v) \
+		(((v) << 25) & BM_DRAM_CTL82_RSVD1)
+#define BM_DRAM_CTL82_ODT_ALT_EN	0x01000000
+#define BP_DRAM_CTL82_OBSOLETE	0
+#define BM_DRAM_CTL82_OBSOLETE	0x00FFFFFF
+#define BF_DRAM_CTL82_OBSOLETE(v)  \
+		(((v) << 0) & BM_DRAM_CTL82_OBSOLETE)
+
+#define HW_DRAM_CTL83	(0x0000014c)
+
+#define BP_DRAM_CTL83_RSVD4	28
+#define BM_DRAM_CTL83_RSVD4	0xF0000000
+#define BF_DRAM_CTL83_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL83_RSVD4)
+#define BP_DRAM_CTL83_ODT_RD_MAP_CS3	24
+#define BM_DRAM_CTL83_ODT_RD_MAP_CS3	0x0F000000
+#define BF_DRAM_CTL83_ODT_RD_MAP_CS3(v)  \
+		(((v) << 24) & BM_DRAM_CTL83_ODT_RD_MAP_CS3)
+#define BP_DRAM_CTL83_RSVD3	20
+#define BM_DRAM_CTL83_RSVD3	0x00F00000
+#define BF_DRAM_CTL83_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL83_RSVD3)
+#define BP_DRAM_CTL83_ODT_RD_MAP_CS2	16
+#define BM_DRAM_CTL83_ODT_RD_MAP_CS2	0x000F0000
+#define BF_DRAM_CTL83_ODT_RD_MAP_CS2(v)  \
+		(((v) << 16) & BM_DRAM_CTL83_ODT_RD_MAP_CS2)
+#define BP_DRAM_CTL83_RSVD2	12
+#define BM_DRAM_CTL83_RSVD2	0x0000F000
+#define BF_DRAM_CTL83_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL83_RSVD2)
+#define BP_DRAM_CTL83_ODT_RD_MAP_CS1	8
+#define BM_DRAM_CTL83_ODT_RD_MAP_CS1	0x00000F00
+#define BF_DRAM_CTL83_ODT_RD_MAP_CS1(v)  \
+		(((v) << 8) & BM_DRAM_CTL83_ODT_RD_MAP_CS1)
+#define BP_DRAM_CTL83_RSVD1	4
+#define BM_DRAM_CTL83_RSVD1	0x000000F0
+#define BF_DRAM_CTL83_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL83_RSVD1)
+#define BP_DRAM_CTL83_ODT_RD_MAP_CS0	0
+#define BM_DRAM_CTL83_ODT_RD_MAP_CS0	0x0000000F
+#define BF_DRAM_CTL83_ODT_RD_MAP_CS0(v)  \
+		(((v) << 0) & BM_DRAM_CTL83_ODT_RD_MAP_CS0)
+
+#define HW_DRAM_CTL84	(0x00000150)
+
+#define BP_DRAM_CTL84_RSVD4	28
+#define BM_DRAM_CTL84_RSVD4	0xF0000000
+#define BF_DRAM_CTL84_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL84_RSVD4)
+#define BP_DRAM_CTL84_ODT_WR_MAP_CS3	24
+#define BM_DRAM_CTL84_ODT_WR_MAP_CS3	0x0F000000
+#define BF_DRAM_CTL84_ODT_WR_MAP_CS3(v)  \
+		(((v) << 24) & BM_DRAM_CTL84_ODT_WR_MAP_CS3)
+#define BP_DRAM_CTL84_RSVD3	20
+#define BM_DRAM_CTL84_RSVD3	0x00F00000
+#define BF_DRAM_CTL84_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL84_RSVD3)
+#define BP_DRAM_CTL84_ODT_WR_MAP_CS2	16
+#define BM_DRAM_CTL84_ODT_WR_MAP_CS2	0x000F0000
+#define BF_DRAM_CTL84_ODT_WR_MAP_CS2(v)  \
+		(((v) << 16) & BM_DRAM_CTL84_ODT_WR_MAP_CS2)
+#define BP_DRAM_CTL84_RSVD2	12
+#define BM_DRAM_CTL84_RSVD2	0x0000F000
+#define BF_DRAM_CTL84_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL84_RSVD2)
+#define BP_DRAM_CTL84_ODT_WR_MAP_CS1	8
+#define BM_DRAM_CTL84_ODT_WR_MAP_CS1	0x00000F00
+#define BF_DRAM_CTL84_ODT_WR_MAP_CS1(v)  \
+		(((v) << 8) & BM_DRAM_CTL84_ODT_WR_MAP_CS1)
+#define BP_DRAM_CTL84_RSVD1	4
+#define BM_DRAM_CTL84_RSVD1	0x000000F0
+#define BF_DRAM_CTL84_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL84_RSVD1)
+#define BP_DRAM_CTL84_ODT_WR_MAP_CS0	0
+#define BM_DRAM_CTL84_ODT_WR_MAP_CS0	0x0000000F
+#define BF_DRAM_CTL84_ODT_WR_MAP_CS0(v)  \
+		(((v) << 0) & BM_DRAM_CTL84_ODT_WR_MAP_CS0)
+
+#define HW_DRAM_CTL85	(0x00000154)
+
+#define BP_DRAM_CTL85_PAD_CTRL_REG_0	0
+#define BM_DRAM_CTL85_PAD_CTRL_REG_0	0xFFFFFFFF
+#define BF_DRAM_CTL85_PAD_CTRL_REG_0(v)	(v)
+
+#define HW_DRAM_CTL86	(0x00000158)
+
+#define BP_DRAM_CTL86_OBSOLETE	16
+#define BM_DRAM_CTL86_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL86_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL86_OBSOLETE)
+#define BP_DRAM_CTL86_VERSION	0
+#define BM_DRAM_CTL86_VERSION	0x0000FFFF
+#define BF_DRAM_CTL86_VERSION(v)  \
+		(((v) << 0) & BM_DRAM_CTL86_VERSION)
+
+#define HW_DRAM_CTL87	(0x0000015c)
+
+#define BP_DRAM_CTL87_DLL_CTRL_REG_0_0	0
+#define BM_DRAM_CTL87_DLL_CTRL_REG_0_0	0xFFFFFFFF
+#define BF_DRAM_CTL87_DLL_CTRL_REG_0_0(v)	(v)
+
+#define HW_DRAM_CTL88	(0x00000160)
+
+#define BP_DRAM_CTL88_DLL_CTRL_REG_0_1	0
+#define BM_DRAM_CTL88_DLL_CTRL_REG_0_1	0xFFFFFFFF
+#define BF_DRAM_CTL88_DLL_CTRL_REG_0_1(v)	(v)
+
+#define HW_DRAM_CTL89	(0x00000164)
+
+#define BP_DRAM_CTL89_DLL_CTRL_REG_0_2	0
+#define BM_DRAM_CTL89_DLL_CTRL_REG_0_2	0xFFFFFFFF
+#define BF_DRAM_CTL89_DLL_CTRL_REG_0_2(v)	(v)
+
+#define HW_DRAM_CTL90	(0x00000168)
+
+#define BP_DRAM_CTL90_DLL_CTRL_REG_0_3	0
+#define BM_DRAM_CTL90_DLL_CTRL_REG_0_3	0xFFFFFFFF
+#define BF_DRAM_CTL90_DLL_CTRL_REG_0_3(v)	(v)
+
+#define HW_DRAM_CTL91	(0x0000016c)
+
+#define BP_DRAM_CTL91_DLL_CTRL_REG_1_0	0
+#define BM_DRAM_CTL91_DLL_CTRL_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL91_DLL_CTRL_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL92	(0x00000170)
+
+#define BP_DRAM_CTL92_DLL_CTRL_REG_1_1	0
+#define BM_DRAM_CTL92_DLL_CTRL_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL92_DLL_CTRL_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL93	(0x00000174)
+
+#define BP_DRAM_CTL93_DLL_CTRL_REG_1_2	0
+#define BM_DRAM_CTL93_DLL_CTRL_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL93_DLL_CTRL_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL94	(0x00000178)
+
+#define BP_DRAM_CTL94_DLL_CTRL_REG_1_3	0
+#define BM_DRAM_CTL94_DLL_CTRL_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL94_DLL_CTRL_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL95	(0x0000017c)
+
+#define BP_DRAM_CTL95_DLL_OBS_REG_0_0	0
+#define BM_DRAM_CTL95_DLL_OBS_REG_0_0	0xFFFFFFFF
+#define BF_DRAM_CTL95_DLL_OBS_REG_0_0(v)	(v)
+
+#define HW_DRAM_CTL96	(0x00000180)
+
+#define BP_DRAM_CTL96_DLL_OBS_REG_0_1	0
+#define BM_DRAM_CTL96_DLL_OBS_REG_0_1	0xFFFFFFFF
+#define BF_DRAM_CTL96_DLL_OBS_REG_0_1(v)	(v)
+
+#define HW_DRAM_CTL97	(0x00000184)
+
+#define BP_DRAM_CTL97_DLL_OBS_REG_0_2	0
+#define BM_DRAM_CTL97_DLL_OBS_REG_0_2	0xFFFFFFFF
+#define BF_DRAM_CTL97_DLL_OBS_REG_0_2(v)	(v)
+
+#define HW_DRAM_CTL98	(0x00000188)
+
+#define BP_DRAM_CTL98_DLL_OBS_REG_0_3	0
+#define BM_DRAM_CTL98_DLL_OBS_REG_0_3	0xFFFFFFFF
+#define BF_DRAM_CTL98_DLL_OBS_REG_0_3(v)	(v)
+
+#define HW_DRAM_CTL99	(0x0000018c)
+
+#define BP_DRAM_CTL99_PHY_OBS_REG_0_0	0
+#define BM_DRAM_CTL99_PHY_OBS_REG_0_0	0xFFFFFFFF
+#define BF_DRAM_CTL99_PHY_OBS_REG_0_0(v)	(v)
+
+#define HW_DRAM_CTL100	(0x00000190)
+
+#define BP_DRAM_CTL100_PHY_OBS_REG_0_1	0
+#define BM_DRAM_CTL100_PHY_OBS_REG_0_1	0xFFFFFFFF
+#define BF_DRAM_CTL100_PHY_OBS_REG_0_1(v)	(v)
+
+#define HW_DRAM_CTL101	(0x00000194)
+
+#define BP_DRAM_CTL101_PHY_OBS_REG_0_2	0
+#define BM_DRAM_CTL101_PHY_OBS_REG_0_2	0xFFFFFFFF
+#define BF_DRAM_CTL101_PHY_OBS_REG_0_2(v)	(v)
+
+#define HW_DRAM_CTL102	(0x00000198)
+
+#define BP_DRAM_CTL102_PHY_OBS_REG_0_3	0
+#define BM_DRAM_CTL102_PHY_OBS_REG_0_3	0xFFFFFFFF
+#define BF_DRAM_CTL102_PHY_OBS_REG_0_3(v)	(v)
+
+#define HW_DRAM_CTL103	(0x0000019c)
+
+#define BP_DRAM_CTL103_DLL_OBS_REG_1_0	0
+#define BM_DRAM_CTL103_DLL_OBS_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL103_DLL_OBS_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL104	(0x000001a0)
+
+#define BP_DRAM_CTL104_DLL_OBS_REG_1_0	0
+#define BM_DRAM_CTL104_DLL_OBS_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL104_DLL_OBS_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL105	(0x000001a4)
+
+#define BP_DRAM_CTL105_DLL_OBS_REG_1_0	0
+#define BM_DRAM_CTL105_DLL_OBS_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL105_DLL_OBS_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL106	(0x000001a8)
+
+#define BP_DRAM_CTL106_DLL_OBS_REG_1_0	0
+#define BM_DRAM_CTL106_DLL_OBS_REG_1_0	0xFFFFFFFF
+#define BF_DRAM_CTL106_DLL_OBS_REG_1_0(v)	(v)
+
+#define HW_DRAM_CTL107	(0x000001ac)
+
+#define BP_DRAM_CTL107_OBSOLETE	16
+#define BM_DRAM_CTL107_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL107_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL107_OBSOLETE)
+#define BP_DRAM_CTL107_RSVD1	9
+#define BM_DRAM_CTL107_RSVD1	0x0000FE00
+#define BF_DRAM_CTL107_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL107_RSVD1)
+#define BP_DRAM_CTL107_DLL_OBS_REG_1_0	0
+#define BM_DRAM_CTL107_DLL_OBS_REG_1_0	0x000001FF
+#define BF_DRAM_CTL107_DLL_OBS_REG_1_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL107_DLL_OBS_REG_1_0)
+
+#define HW_DRAM_CTL108	(0x000001b0)
+
+#define BP_DRAM_CTL108_DLL_OBS_REG_1_1	0
+#define BM_DRAM_CTL108_DLL_OBS_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL108_DLL_OBS_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL109	(0x000001b4)
+
+#define BP_DRAM_CTL109_DLL_OBS_REG_1_1	0
+#define BM_DRAM_CTL109_DLL_OBS_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL109_DLL_OBS_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL110	(0x000001b8)
+
+#define BP_DRAM_CTL110_DLL_OBS_REG_1_1	0
+#define BM_DRAM_CTL110_DLL_OBS_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL110_DLL_OBS_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL111	(0x000001bc)
+
+#define BP_DRAM_CTL111_DLL_OBS_REG_1_1	0
+#define BM_DRAM_CTL111_DLL_OBS_REG_1_1	0xFFFFFFFF
+#define BF_DRAM_CTL111_DLL_OBS_REG_1_1(v)	(v)
+
+#define HW_DRAM_CTL112	(0x000001c0)
+
+#define BP_DRAM_CTL112_OBSOLETE	16
+#define BM_DRAM_CTL112_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL112_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL112_OBSOLETE)
+#define BP_DRAM_CTL112_RSVD1	9
+#define BM_DRAM_CTL112_RSVD1	0x0000FE00
+#define BF_DRAM_CTL112_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL112_RSVD1)
+#define BP_DRAM_CTL112_DLL_OBS_REG_1_1	0
+#define BM_DRAM_CTL112_DLL_OBS_REG_1_1	0x000001FF
+#define BF_DRAM_CTL112_DLL_OBS_REG_1_1(v)  \
+		(((v) << 0) & BM_DRAM_CTL112_DLL_OBS_REG_1_1)
+
+#define HW_DRAM_CTL113	(0x000001c4)
+
+#define BP_DRAM_CTL113_DLL_OBS_REG_1_2	0
+#define BM_DRAM_CTL113_DLL_OBS_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL113_DLL_OBS_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL114	(0x000001c8)
+
+#define BP_DRAM_CTL114_DLL_OBS_REG_1_2	0
+#define BM_DRAM_CTL114_DLL_OBS_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL114_DLL_OBS_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL115	(0x000001cc)
+
+#define BP_DRAM_CTL115_DLL_OBS_REG_1_2	0
+#define BM_DRAM_CTL115_DLL_OBS_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL115_DLL_OBS_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL116	(0x000001d0)
+
+#define BP_DRAM_CTL116_DLL_OBS_REG_1_2	0
+#define BM_DRAM_CTL116_DLL_OBS_REG_1_2	0xFFFFFFFF
+#define BF_DRAM_CTL116_DLL_OBS_REG_1_2(v)	(v)
+
+#define HW_DRAM_CTL117	(0x000001d4)
+
+#define BP_DRAM_CTL117_OBSOLETE	16
+#define BM_DRAM_CTL117_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL117_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL117_OBSOLETE)
+#define BP_DRAM_CTL117_RSVD1	9
+#define BM_DRAM_CTL117_RSVD1	0x0000FE00
+#define BF_DRAM_CTL117_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL117_RSVD1)
+#define BP_DRAM_CTL117_DLL_OBS_REG_1_2	0
+#define BM_DRAM_CTL117_DLL_OBS_REG_1_2	0x000001FF
+#define BF_DRAM_CTL117_DLL_OBS_REG_1_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL117_DLL_OBS_REG_1_2)
+
+#define HW_DRAM_CTL118	(0x000001d8)
+
+#define BP_DRAM_CTL118_DLL_OBS_REG_1_3	0
+#define BM_DRAM_CTL118_DLL_OBS_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL118_DLL_OBS_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL119	(0x000001dc)
+
+#define BP_DRAM_CTL119_DLL_OBS_REG_1_3	0
+#define BM_DRAM_CTL119_DLL_OBS_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL119_DLL_OBS_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL120	(0x000001e0)
+
+#define BP_DRAM_CTL120_DLL_OBS_REG_1_3	0
+#define BM_DRAM_CTL120_DLL_OBS_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL120_DLL_OBS_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL121	(0x000001e4)
+
+#define BP_DRAM_CTL121_DLL_OBS_REG_1_3	0
+#define BM_DRAM_CTL121_DLL_OBS_REG_1_3	0xFFFFFFFF
+#define BF_DRAM_CTL121_DLL_OBS_REG_1_3(v)	(v)
+
+#define HW_DRAM_CTL122	(0x000001e8)
+
+#define BP_DRAM_CTL122_OBSOLETE	16
+#define BM_DRAM_CTL122_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL122_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL122_OBSOLETE)
+#define BP_DRAM_CTL122_RSVD1	9
+#define BM_DRAM_CTL122_RSVD1	0x0000FE00
+#define BF_DRAM_CTL122_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL122_RSVD1)
+#define BP_DRAM_CTL122_DLL_OBS_REG_1_3	0
+#define BM_DRAM_CTL122_DLL_OBS_REG_1_3	0x000001FF
+#define BF_DRAM_CTL122_DLL_OBS_REG_1_3(v)  \
+		(((v) << 0) & BM_DRAM_CTL122_DLL_OBS_REG_1_3)
+
+#define HW_DRAM_CTL123	(0x000001ec)
+
+#define BP_DRAM_CTL123_DLL_OBS_REG_2_0	0
+#define BM_DRAM_CTL123_DLL_OBS_REG_2_0	0xFFFFFFFF
+#define BF_DRAM_CTL123_DLL_OBS_REG_2_0(v)	(v)
+
+#define HW_DRAM_CTL124	(0x000001f0)
+
+#define BP_DRAM_CTL124_DLL_OBS_REG_2_0	0
+#define BM_DRAM_CTL124_DLL_OBS_REG_2_0	0xFFFFFFFF
+#define BF_DRAM_CTL124_DLL_OBS_REG_2_0(v)	(v)
+
+#define HW_DRAM_CTL125	(0x000001f4)
+
+#define BP_DRAM_CTL125_DLL_OBS_REG_2_0	0
+#define BM_DRAM_CTL125_DLL_OBS_REG_2_0	0xFFFFFFFF
+#define BF_DRAM_CTL125_DLL_OBS_REG_2_0(v)	(v)
+
+#define HW_DRAM_CTL126	(0x000001f8)
+
+#define BP_DRAM_CTL126_DLL_OBS_REG_2_0	0
+#define BM_DRAM_CTL126_DLL_OBS_REG_2_0	0xFFFFFFFF
+#define BF_DRAM_CTL126_DLL_OBS_REG_2_0(v)	(v)
+
+#define HW_DRAM_CTL127	(0x000001fc)
+
+#define BP_DRAM_CTL127_OBSOLETE	16
+#define BM_DRAM_CTL127_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL127_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL127_OBSOLETE)
+#define BP_DRAM_CTL127_RSVD1	9
+#define BM_DRAM_CTL127_RSVD1	0x0000FE00
+#define BF_DRAM_CTL127_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL127_RSVD1)
+#define BP_DRAM_CTL127_DLL_OBS_REG_2_0	0
+#define BM_DRAM_CTL127_DLL_OBS_REG_2_0	0x000001FF
+#define BF_DRAM_CTL127_DLL_OBS_REG_2_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL127_DLL_OBS_REG_2_0)
+
+#define HW_DRAM_CTL128	(0x00000200)
+
+#define BP_DRAM_CTL128_DLL_OBS_REG_2_1	0
+#define BM_DRAM_CTL128_DLL_OBS_REG_2_1	0xFFFFFFFF
+#define BF_DRAM_CTL128_DLL_OBS_REG_2_1(v)	(v)
+
+#define HW_DRAM_CTL129	(0x00000204)
+
+#define BP_DRAM_CTL129_DLL_OBS_REG_2_1	0
+#define BM_DRAM_CTL129_DLL_OBS_REG_2_1	0xFFFFFFFF
+#define BF_DRAM_CTL129_DLL_OBS_REG_2_1(v)	(v)
+
+#define HW_DRAM_CTL130	(0x00000208)
+
+#define BP_DRAM_CTL130_DLL_OBS_REG_2_1	0
+#define BM_DRAM_CTL130_DLL_OBS_REG_2_1	0xFFFFFFFF
+#define BF_DRAM_CTL130_DLL_OBS_REG_2_1(v)	(v)
+
+#define HW_DRAM_CTL131	(0x0000020c)
+
+#define BP_DRAM_CTL131_DLL_OBS_REG_2_1	0
+#define BM_DRAM_CTL131_DLL_OBS_REG_2_1	0xFFFFFFFF
+#define BF_DRAM_CTL131_DLL_OBS_REG_2_1(v)	(v)
+
+#define HW_DRAM_CTL132	(0x00000210)
+
+#define BP_DRAM_CTL132_OBSOLETE	16
+#define BM_DRAM_CTL132_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL132_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL132_OBSOLETE)
+#define BP_DRAM_CTL132_RSVD1	9
+#define BM_DRAM_CTL132_RSVD1	0x0000FE00
+#define BF_DRAM_CTL132_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL132_RSVD1)
+#define BP_DRAM_CTL132_DLL_OBS_REG_2_1	0
+#define BM_DRAM_CTL132_DLL_OBS_REG_2_1	0x000001FF
+#define BF_DRAM_CTL132_DLL_OBS_REG_2_1(v)  \
+		(((v) << 0) & BM_DRAM_CTL132_DLL_OBS_REG_2_1)
+
+#define HW_DRAM_CTL133	(0x00000214)
+
+#define BP_DRAM_CTL133_DLL_OBS_REG_2_2	0
+#define BM_DRAM_CTL133_DLL_OBS_REG_2_2	0xFFFFFFFF
+#define BF_DRAM_CTL133_DLL_OBS_REG_2_2(v)	(v)
+
+#define HW_DRAM_CTL134	(0x00000218)
+
+#define BP_DRAM_CTL134_DLL_OBS_REG_2_2	0
+#define BM_DRAM_CTL134_DLL_OBS_REG_2_2	0xFFFFFFFF
+#define BF_DRAM_CTL134_DLL_OBS_REG_2_2(v)	(v)
+
+#define HW_DRAM_CTL135	(0x0000021c)
+
+#define BP_DRAM_CTL135_DLL_OBS_REG_2_2	0
+#define BM_DRAM_CTL135_DLL_OBS_REG_2_2	0xFFFFFFFF
+#define BF_DRAM_CTL135_DLL_OBS_REG_2_2(v)	(v)
+
+#define HW_DRAM_CTL136	(0x00000220)
+
+#define BP_DRAM_CTL136_DLL_OBS_REG_2_2	0
+#define BM_DRAM_CTL136_DLL_OBS_REG_2_2	0xFFFFFFFF
+#define BF_DRAM_CTL136_DLL_OBS_REG_2_2(v)	(v)
+
+#define HW_DRAM_CTL137	(0x00000224)
+
+#define BP_DRAM_CTL137_OBSOLETE	16
+#define BM_DRAM_CTL137_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL137_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL137_OBSOLETE)
+#define BP_DRAM_CTL137_RSVD1	9
+#define BM_DRAM_CTL137_RSVD1	0x0000FE00
+#define BF_DRAM_CTL137_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL137_RSVD1)
+#define BP_DRAM_CTL137_DLL_OBS_REG_2_2	0
+#define BM_DRAM_CTL137_DLL_OBS_REG_2_2	0x000001FF
+#define BF_DRAM_CTL137_DLL_OBS_REG_2_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL137_DLL_OBS_REG_2_2)
+
+#define HW_DRAM_CTL138	(0x00000228)
+
+#define BP_DRAM_CTL138_DLL_OBS_REG_2_3	0
+#define BM_DRAM_CTL138_DLL_OBS_REG_2_3	0xFFFFFFFF
+#define BF_DRAM_CTL138_DLL_OBS_REG_2_3(v)	(v)
+
+#define HW_DRAM_CTL139	(0x0000022c)
+
+#define BP_DRAM_CTL139_DLL_OBS_REG_2_3	0
+#define BM_DRAM_CTL139_DLL_OBS_REG_2_3	0xFFFFFFFF
+#define BF_DRAM_CTL139_DLL_OBS_REG_2_3(v)	(v)
+
+#define HW_DRAM_CTL140	(0x00000230)
+
+#define BP_DRAM_CTL140_DLL_OBS_REG_2_3	0
+#define BM_DRAM_CTL140_DLL_OBS_REG_2_3	0xFFFFFFFF
+#define BF_DRAM_CTL140_DLL_OBS_REG_2_3(v)	(v)
+
+#define HW_DRAM_CTL141	(0x00000234)
+
+#define BP_DRAM_CTL141_DLL_OBS_REG_2_3	0
+#define BM_DRAM_CTL141_DLL_OBS_REG_2_3	0xFFFFFFFF
+#define BF_DRAM_CTL141_DLL_OBS_REG_2_3(v)	(v)
+
+#define HW_DRAM_CTL142	(0x00000238)
+
+#define BP_DRAM_CTL142_OBSOLETE	16
+#define BM_DRAM_CTL142_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL142_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL142_OBSOLETE)
+#define BP_DRAM_CTL142_RSVD1	9
+#define BM_DRAM_CTL142_RSVD1	0x0000FE00
+#define BF_DRAM_CTL142_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL142_RSVD1)
+#define BP_DRAM_CTL142_DLL_OBS_REG_2_3	0
+#define BM_DRAM_CTL142_DLL_OBS_REG_2_3	0x000001FF
+#define BF_DRAM_CTL142_DLL_OBS_REG_2_3(v)  \
+		(((v) << 0) & BM_DRAM_CTL142_DLL_OBS_REG_2_3)
+
+#define HW_DRAM_CTL143	(0x0000023c)
+
+#define BP_DRAM_CTL143_DLL_OBS_REG_3_0	0
+#define BM_DRAM_CTL143_DLL_OBS_REG_3_0	0xFFFFFFFF
+#define BF_DRAM_CTL143_DLL_OBS_REG_3_0(v)	(v)
+
+#define HW_DRAM_CTL144	(0x00000240)
+
+#define BP_DRAM_CTL144_DLL_OBS_REG_3_0	0
+#define BM_DRAM_CTL144_DLL_OBS_REG_3_0	0xFFFFFFFF
+#define BF_DRAM_CTL144_DLL_OBS_REG_3_0(v)	(v)
+
+#define HW_DRAM_CTL145	(0x00000244)
+
+#define BP_DRAM_CTL145_DLL_OBS_REG_3_0	0
+#define BM_DRAM_CTL145_DLL_OBS_REG_3_0	0xFFFFFFFF
+#define BF_DRAM_CTL145_DLL_OBS_REG_3_0(v)	(v)
+
+#define HW_DRAM_CTL146	(0x00000248)
+
+#define BP_DRAM_CTL146_DLL_OBS_REG_3_0	0
+#define BM_DRAM_CTL146_DLL_OBS_REG_3_0	0xFFFFFFFF
+#define BF_DRAM_CTL146_DLL_OBS_REG_3_0(v)	(v)
+
+#define HW_DRAM_CTL147	(0x0000024c)
+
+#define BP_DRAM_CTL147_OBSOLETE	16
+#define BM_DRAM_CTL147_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL147_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL147_OBSOLETE)
+#define BP_DRAM_CTL147_RSVD1	9
+#define BM_DRAM_CTL147_RSVD1	0x0000FE00
+#define BF_DRAM_CTL147_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL147_RSVD1)
+#define BP_DRAM_CTL147_DLL_OBS_REG_3_0	0
+#define BM_DRAM_CTL147_DLL_OBS_REG_3_0	0x000001FF
+#define BF_DRAM_CTL147_DLL_OBS_REG_3_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL147_DLL_OBS_REG_3_0)
+
+#define HW_DRAM_CTL148	(0x00000250)
+
+#define BP_DRAM_CTL148_DLL_OBS_REG_3_1	0
+#define BM_DRAM_CTL148_DLL_OBS_REG_3_1	0xFFFFFFFF
+#define BF_DRAM_CTL148_DLL_OBS_REG_3_1(v)	(v)
+
+#define HW_DRAM_CTL149	(0x00000254)
+
+#define BP_DRAM_CTL149_DLL_OBS_REG_3_1	0
+#define BM_DRAM_CTL149_DLL_OBS_REG_3_1	0xFFFFFFFF
+#define BF_DRAM_CTL149_DLL_OBS_REG_3_1(v)	(v)
+
+#define HW_DRAM_CTL150	(0x00000258)
+
+#define BP_DRAM_CTL150_DLL_OBS_REG_3_1	0
+#define BM_DRAM_CTL150_DLL_OBS_REG_3_1	0xFFFFFFFF
+#define BF_DRAM_CTL150_DLL_OBS_REG_3_1(v)	(v)
+
+#define HW_DRAM_CTL151	(0x0000025c)
+
+#define BP_DRAM_CTL151_DLL_OBS_REG_3_1	0
+#define BM_DRAM_CTL151_DLL_OBS_REG_3_1	0xFFFFFFFF
+#define BF_DRAM_CTL151_DLL_OBS_REG_3_1(v)	(v)
+
+#define HW_DRAM_CTL152	(0x00000260)
+
+#define BP_DRAM_CTL152_OBSOLETE	16
+#define BM_DRAM_CTL152_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL152_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL152_OBSOLETE)
+#define BP_DRAM_CTL152_RSVD1	9
+#define BM_DRAM_CTL152_RSVD1	0x0000FE00
+#define BF_DRAM_CTL152_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL152_RSVD1)
+#define BP_DRAM_CTL152_DLL_OBS_REG_3_1	0
+#define BM_DRAM_CTL152_DLL_OBS_REG_3_1	0x000001FF
+#define BF_DRAM_CTL152_DLL_OBS_REG_3_1(v)  \
+		(((v) << 0) & BM_DRAM_CTL152_DLL_OBS_REG_3_1)
+
+#define HW_DRAM_CTL153	(0x00000264)
+
+#define BP_DRAM_CTL153_DLL_OBS_REG_3_2	0
+#define BM_DRAM_CTL153_DLL_OBS_REG_3_2	0xFFFFFFFF
+#define BF_DRAM_CTL153_DLL_OBS_REG_3_2(v)	(v)
+
+#define HW_DRAM_CTL154	(0x00000268)
+
+#define BP_DRAM_CTL154_DLL_OBS_REG_3_2	0
+#define BM_DRAM_CTL154_DLL_OBS_REG_3_2	0xFFFFFFFF
+#define BF_DRAM_CTL154_DLL_OBS_REG_3_2(v)	(v)
+
+#define HW_DRAM_CTL155	(0x0000026c)
+
+#define BP_DRAM_CTL155_DLL_OBS_REG_3_2	0
+#define BM_DRAM_CTL155_DLL_OBS_REG_3_2	0xFFFFFFFF
+#define BF_DRAM_CTL155_DLL_OBS_REG_3_2(v)	(v)
+
+#define HW_DRAM_CTL156	(0x00000270)
+
+#define BP_DRAM_CTL156_DLL_OBS_REG_3_2	0
+#define BM_DRAM_CTL156_DLL_OBS_REG_3_2	0xFFFFFFFF
+#define BF_DRAM_CTL156_DLL_OBS_REG_3_2(v)	(v)
+
+#define HW_DRAM_CTL157	(0x00000274)
+
+#define BP_DRAM_CTL157_OBSOLETE	16
+#define BM_DRAM_CTL157_OBSOLETE	0xFFFF0000
+#define BF_DRAM_CTL157_OBSOLETE(v) \
+		(((v) << 16) & BM_DRAM_CTL157_OBSOLETE)
+#define BP_DRAM_CTL157_RSVD1	9
+#define BM_DRAM_CTL157_RSVD1	0x0000FE00
+#define BF_DRAM_CTL157_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL157_RSVD1)
+#define BP_DRAM_CTL157_DLL_OBS_REG_3_2	0
+#define BM_DRAM_CTL157_DLL_OBS_REG_3_2	0x000001FF
+#define BF_DRAM_CTL157_DLL_OBS_REG_3_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL157_DLL_OBS_REG_3_2)
+
+#define HW_DRAM_CTL158	(0x00000278)
+
+#define BP_DRAM_CTL158_DLL_OBS_REG_3_3	0
+#define BM_DRAM_CTL158_DLL_OBS_REG_3_3	0xFFFFFFFF
+#define BF_DRAM_CTL158_DLL_OBS_REG_3_3(v)	(v)
+
+#define HW_DRAM_CTL159	(0x0000027c)
+
+#define BP_DRAM_CTL159_DLL_OBS_REG_3_3	0
+#define BM_DRAM_CTL159_DLL_OBS_REG_3_3	0xFFFFFFFF
+#define BF_DRAM_CTL159_DLL_OBS_REG_3_3(v)	(v)
+
+#define HW_DRAM_CTL160	(0x00000280)
+
+#define BP_DRAM_CTL160_DLL_OBS_REG_3_3	0
+#define BM_DRAM_CTL160_DLL_OBS_REG_3_3	0xFFFFFFFF
+#define BF_DRAM_CTL160_DLL_OBS_REG_3_3(v)	(v)
+
+#define HW_DRAM_CTL161	(0x00000284)
+
+#define BP_DRAM_CTL161_DLL_OBS_REG_3_3	0
+#define BM_DRAM_CTL161_DLL_OBS_REG_3_3	0xFFFFFFFF
+#define BF_DRAM_CTL161_DLL_OBS_REG_3_3(v)	(v)
+
+#define HW_DRAM_CTL162	(0x00000288)
+
+#define BP_DRAM_CTL162_RSVD3	27
+#define BM_DRAM_CTL162_RSVD3	0xF8000000
+#define BF_DRAM_CTL162_RSVD3(v) \
+		(((v) << 27) & BM_DRAM_CTL162_RSVD3)
+#define BP_DRAM_CTL162_W2R_SAMECS_DLY	24
+#define BM_DRAM_CTL162_W2R_SAMECS_DLY	0x07000000
+#define BF_DRAM_CTL162_W2R_SAMECS_DLY(v)  \
+		(((v) << 24) & BM_DRAM_CTL162_W2R_SAMECS_DLY)
+#define BP_DRAM_CTL162_RSVD2	19
+#define BM_DRAM_CTL162_RSVD2	0x00F80000
+#define BF_DRAM_CTL162_RSVD2(v)  \
+		(((v) << 19) & BM_DRAM_CTL162_RSVD2)
+#define BP_DRAM_CTL162_W2R_DIFFCS_DLY	16
+#define BM_DRAM_CTL162_W2R_DIFFCS_DLY	0x00070000
+#define BF_DRAM_CTL162_W2R_DIFFCS_DLY(v)  \
+		(((v) << 16) & BM_DRAM_CTL162_W2R_DIFFCS_DLY)
+#define BP_DRAM_CTL162_RSVD1	9
+#define BM_DRAM_CTL162_RSVD1	0x0000FE00
+#define BF_DRAM_CTL162_RSVD1(v)  \
+		(((v) << 9) & BM_DRAM_CTL162_RSVD1)
+#define BP_DRAM_CTL162_DLL_OBS_REG_3_3	0
+#define BM_DRAM_CTL162_DLL_OBS_REG_3_3	0x000001FF
+#define BF_DRAM_CTL162_DLL_OBS_REG_3_3(v)  \
+		(((v) << 0) & BM_DRAM_CTL162_DLL_OBS_REG_3_3)
+
+#define HW_DRAM_CTL163	(0x0000028c)
+
+#define BP_DRAM_CTL163_DLL_RST_ADJ_DLY	24
+#define BM_DRAM_CTL163_DLL_RST_ADJ_DLY	0xFF000000
+#define BF_DRAM_CTL163_DLL_RST_ADJ_DLY(v) \
+		(((v) << 24) & BM_DRAM_CTL163_DLL_RST_ADJ_DLY)
+#define BP_DRAM_CTL163_RSVD3	20
+#define BM_DRAM_CTL163_RSVD3	0x00F00000
+#define BF_DRAM_CTL163_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL163_RSVD3)
+#define BP_DRAM_CTL163_WRLAT_ADJ	16
+#define BM_DRAM_CTL163_WRLAT_ADJ	0x000F0000
+#define BF_DRAM_CTL163_WRLAT_ADJ(v)  \
+		(((v) << 16) & BM_DRAM_CTL163_WRLAT_ADJ)
+#define BP_DRAM_CTL163_RSVD2	12
+#define BM_DRAM_CTL163_RSVD2	0x0000F000
+#define BF_DRAM_CTL163_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL163_RSVD2)
+#define BP_DRAM_CTL163_RDLAT_ADJ	8
+#define BM_DRAM_CTL163_RDLAT_ADJ	0x00000F00
+#define BF_DRAM_CTL163_RDLAT_ADJ(v)  \
+		(((v) << 8) & BM_DRAM_CTL163_RDLAT_ADJ)
+#define BP_DRAM_CTL163_RSVD1	4
+#define BM_DRAM_CTL163_RSVD1	0x000000F0
+#define BF_DRAM_CTL163_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL163_RSVD1)
+#define BP_DRAM_CTL163_DRAM_CLASS	0
+#define BM_DRAM_CTL163_DRAM_CLASS	0x0000000F
+#define BF_DRAM_CTL163_DRAM_CLASS(v)  \
+		(((v) << 0) & BM_DRAM_CTL163_DRAM_CLASS)
+
+#define HW_DRAM_CTL164	(0x00000290)
+
+#define BP_DRAM_CTL164_OBSOLETE	24
+#define BM_DRAM_CTL164_OBSOLETE	0xFF000000
+#define BF_DRAM_CTL164_OBSOLETE(v) \
+		(((v) << 24) & BM_DRAM_CTL164_OBSOLETE)
+#define BP_DRAM_CTL164_RSVD1	18
+#define BM_DRAM_CTL164_RSVD1	0x00FC0000
+#define BF_DRAM_CTL164_RSVD1(v)  \
+		(((v) << 18) & BM_DRAM_CTL164_RSVD1)
+#define BP_DRAM_CTL164_INT_ACK	8
+#define BM_DRAM_CTL164_INT_ACK	0x0003FF00
+#define BF_DRAM_CTL164_INT_ACK(v)  \
+		(((v) << 8) & BM_DRAM_CTL164_INT_ACK)
+#define BP_DRAM_CTL164_TMOD	0
+#define BM_DRAM_CTL164_TMOD	0x000000FF
+#define BF_DRAM_CTL164_TMOD(v)  \
+		(((v) << 0) & BM_DRAM_CTL164_TMOD)
+
+#define HW_DRAM_CTL171	(0x000002ac)
+
+#define BP_DRAM_CTL171_RSVD2	25
+#define BM_DRAM_CTL171_RSVD2	0xFE000000
+#define BF_DRAM_CTL171_RSVD2(v) \
+		(((v) << 25) & BM_DRAM_CTL171_RSVD2)
+#define BM_DRAM_CTL171_AXI5_BDW_OVFLOW	0x01000000
+#define BP_DRAM_CTL171_RSVD1	17
+#define BM_DRAM_CTL171_RSVD1	0x00FE0000
+#define BF_DRAM_CTL171_RSVD1(v)  \
+		(((v) << 17) & BM_DRAM_CTL171_RSVD1)
+#define BM_DRAM_CTL171_AXI4_BDW_OVFLOW	0x00010000
+#define BP_DRAM_CTL171_DLL_RST_DELAY	0
+#define BM_DRAM_CTL171_DLL_RST_DELAY	0x0000FFFF
+#define BF_DRAM_CTL171_DLL_RST_DELAY(v)  \
+		(((v) << 0) & BM_DRAM_CTL171_DLL_RST_DELAY)
+
+#define HW_DRAM_CTL172	(0x000002b0)
+
+#define BP_DRAM_CTL172_RSVD4	25
+#define BM_DRAM_CTL172_RSVD4	0xFE000000
+#define BF_DRAM_CTL172_RSVD4(v) \
+		(((v) << 25) & BM_DRAM_CTL172_RSVD4)
+#define BM_DRAM_CTL172_RESYNC_DLL_PER_AREF_EN	0x01000000
+#define BP_DRAM_CTL172_RSVD3	17
+#define BM_DRAM_CTL172_RSVD3	0x00FE0000
+#define BF_DRAM_CTL172_RSVD3(v)  \
+		(((v) << 17) & BM_DRAM_CTL172_RSVD3)
+#define BM_DRAM_CTL172_RESYNC_DLL	0x00010000
+#define BP_DRAM_CTL172_RSVD2	9
+#define BM_DRAM_CTL172_RSVD2	0x0000FE00
+#define BF_DRAM_CTL172_RSVD2(v)  \
+		(((v) << 9) & BM_DRAM_CTL172_RSVD2)
+#define BM_DRAM_CTL172_CONCURRENTAP_WR_ONLY	0x00000100
+#define BP_DRAM_CTL172_RSVD1	1
+#define BM_DRAM_CTL172_RSVD1	0x000000FE
+#define BF_DRAM_CTL172_RSVD1(v)  \
+		(((v) << 1) & BM_DRAM_CTL172_RSVD1)
+#define BM_DRAM_CTL172_CKE_STATUS	0x00000001
+
+#define HW_DRAM_CTL173	(0x000002b4)
+
+#define BP_DRAM_CTL173_RSVD4	27
+#define BM_DRAM_CTL173_RSVD4	0xF8000000
+#define BF_DRAM_CTL173_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL173_RSVD4)
+#define BP_DRAM_CTL173_AXI4_W_PRIORITY	24
+#define BM_DRAM_CTL173_AXI4_W_PRIORITY	0x07000000
+#define BF_DRAM_CTL173_AXI4_W_PRIORITY(v)  \
+		(((v) << 24) & BM_DRAM_CTL173_AXI4_W_PRIORITY)
+#define BP_DRAM_CTL173_RSVD3	19
+#define BM_DRAM_CTL173_RSVD3	0x00F80000
+#define BF_DRAM_CTL173_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL173_RSVD3)
+#define BP_DRAM_CTL173_AXI4_R_PRIORITY	16
+#define BM_DRAM_CTL173_AXI4_R_PRIORITY	0x00070000
+#define BF_DRAM_CTL173_AXI4_R_PRIORITY(v)  \
+		(((v) << 16) & BM_DRAM_CTL173_AXI4_R_PRIORITY)
+#define BP_DRAM_CTL173_RSVD2	10
+#define BM_DRAM_CTL173_RSVD2	0x0000FC00
+#define BF_DRAM_CTL173_RSVD2(v)  \
+		(((v) << 10) & BM_DRAM_CTL173_RSVD2)
+#define BP_DRAM_CTL173_AXI5_FIFO_TYPE_REG	8
+#define BM_DRAM_CTL173_AXI5_FIFO_TYPE_REG	0x00000300
+#define BF_DRAM_CTL173_AXI5_FIFO_TYPE_REG(v)  \
+		(((v) << 8) & BM_DRAM_CTL173_AXI5_FIFO_TYPE_REG)
+#define BP_DRAM_CTL173_RSVD1	2
+#define BM_DRAM_CTL173_RSVD1	0x000000FC
+#define BF_DRAM_CTL173_RSVD1(v)  \
+		(((v) << 2) & BM_DRAM_CTL173_RSVD1)
+#define BP_DRAM_CTL173_AXI4_FIFO_TYPE_REG	0
+#define BM_DRAM_CTL173_AXI4_FIFO_TYPE_REG	0x00000003
+#define BF_DRAM_CTL173_AXI4_FIFO_TYPE_REG(v)  \
+		(((v) << 0) & BM_DRAM_CTL173_AXI4_FIFO_TYPE_REG)
+
+#define HW_DRAM_CTL174	(0x000002b8)
+
+#define BP_DRAM_CTL174_RSVD4	27
+#define BM_DRAM_CTL174_RSVD4	0xF8000000
+#define BF_DRAM_CTL174_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL174_RSVD4)
+#define BP_DRAM_CTL174_R2R_SAMECS_DLY	24
+#define BM_DRAM_CTL174_R2R_SAMECS_DLY	0x07000000
+#define BF_DRAM_CTL174_R2R_SAMECS_DLY(v)  \
+		(((v) << 24) & BM_DRAM_CTL174_R2R_SAMECS_DLY)
+#define BP_DRAM_CTL174_RSVD3	19
+#define BM_DRAM_CTL174_RSVD3	0x00F80000
+#define BF_DRAM_CTL174_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL174_RSVD3)
+#define BP_DRAM_CTL174_R2R_DIFFCS_DLY	16
+#define BM_DRAM_CTL174_R2R_DIFFCS_DLY	0x00070000
+#define BF_DRAM_CTL174_R2R_DIFFCS_DLY(v)  \
+		(((v) << 16) & BM_DRAM_CTL174_R2R_DIFFCS_DLY)
+#define BP_DRAM_CTL174_RSVD2	11
+#define BM_DRAM_CTL174_RSVD2	0x0000F800
+#define BF_DRAM_CTL174_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL174_RSVD2)
+#define BP_DRAM_CTL174_AXI5_W_PRIORITY	8
+#define BM_DRAM_CTL174_AXI5_W_PRIORITY	0x00000700
+#define BF_DRAM_CTL174_AXI5_W_PRIORITY(v)  \
+		(((v) << 8) & BM_DRAM_CTL174_AXI5_W_PRIORITY)
+#define BP_DRAM_CTL174_RSVD1	3
+#define BM_DRAM_CTL174_RSVD1	0x000000F8
+#define BF_DRAM_CTL174_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL174_RSVD1)
+#define BP_DRAM_CTL174_AXI5_R_PRIORITY	0
+#define BM_DRAM_CTL174_AXI5_R_PRIORITY	0x00000007
+#define BF_DRAM_CTL174_AXI5_R_PRIORITY(v)  \
+		(((v) << 0) & BM_DRAM_CTL174_AXI5_R_PRIORITY)
+
+#define HW_DRAM_CTL175	(0x000002bc)
+
+#define BP_DRAM_CTL175_RSVD4	27
+#define BM_DRAM_CTL175_RSVD4	0xF8000000
+#define BF_DRAM_CTL175_RSVD4(v) \
+		(((v) << 27) & BM_DRAM_CTL175_RSVD4)
+#define BP_DRAM_CTL175_W2W_DIFFCS_DLY	24
+#define BM_DRAM_CTL175_W2W_DIFFCS_DLY	0x07000000
+#define BF_DRAM_CTL175_W2W_DIFFCS_DLY(v)  \
+		(((v) << 24) & BM_DRAM_CTL175_W2W_DIFFCS_DLY)
+#define BP_DRAM_CTL175_RSVD3	19
+#define BM_DRAM_CTL175_RSVD3	0x00F80000
+#define BF_DRAM_CTL175_RSVD3(v)  \
+		(((v) << 19) & BM_DRAM_CTL175_RSVD3)
+#define BP_DRAM_CTL175_TBST_INT_INTERVAL	16
+#define BM_DRAM_CTL175_TBST_INT_INTERVAL	0x00070000
+#define BF_DRAM_CTL175_TBST_INT_INTERVAL(v)  \
+		(((v) << 16) & BM_DRAM_CTL175_TBST_INT_INTERVAL)
+#define BP_DRAM_CTL175_RSVD2	11
+#define BM_DRAM_CTL175_RSVD2	0x0000F800
+#define BF_DRAM_CTL175_RSVD2(v)  \
+		(((v) << 11) & BM_DRAM_CTL175_RSVD2)
+#define BP_DRAM_CTL175_R2W_SAMECS_DLY	8
+#define BM_DRAM_CTL175_R2W_SAMECS_DLY	0x00000700
+#define BF_DRAM_CTL175_R2W_SAMECS_DLY(v)  \
+		(((v) << 8) & BM_DRAM_CTL175_R2W_SAMECS_DLY)
+#define BP_DRAM_CTL175_RSVD1	3
+#define BM_DRAM_CTL175_RSVD1	0x000000F8
+#define BF_DRAM_CTL175_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL175_RSVD1)
+#define BP_DRAM_CTL175_R2W_DIFFCS_DLY	0
+#define BM_DRAM_CTL175_R2W_DIFFCS_DLY	0x00000007
+#define BF_DRAM_CTL175_R2W_DIFFCS_DLY(v)  \
+		(((v) << 0) & BM_DRAM_CTL175_R2W_DIFFCS_DLY)
+
+#define HW_DRAM_CTL176	(0x000002c0)
+
+#define BP_DRAM_CTL176_RSVD4	28
+#define BM_DRAM_CTL176_RSVD4	0xF0000000
+#define BF_DRAM_CTL176_RSVD4(v) \
+		(((v) << 28) & BM_DRAM_CTL176_RSVD4)
+#define BP_DRAM_CTL176_ADD_ODT_CLK_SAMETYPE_DIFFCS	24
+#define BM_DRAM_CTL176_ADD_ODT_CLK_SAMETYPE_DIFFCS	0x0F000000
+#define BF_DRAM_CTL176_ADD_ODT_CLK_SAMETYPE_DIFFCS(v)  \
+		(((v) << 24) & BM_DRAM_CTL176_ADD_ODT_CLK_SAMETYPE_DIFFCS)
+#define BP_DRAM_CTL176_RSVD3	20
+#define BM_DRAM_CTL176_RSVD3	0x00F00000
+#define BF_DRAM_CTL176_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL176_RSVD3)
+#define BP_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_SAMECS	16
+#define BM_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_SAMECS	0x000F0000
+#define BF_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_SAMECS(v)  \
+		(((v) << 16) & BM_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_SAMECS)
+#define BP_DRAM_CTL176_RSVD2	12
+#define BM_DRAM_CTL176_RSVD2	0x0000F000
+#define BF_DRAM_CTL176_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL176_RSVD2)
+#define BP_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_DIFFCS	8
+#define BM_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_DIFFCS	0x00000F00
+#define BF_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_DIFFCS(v)  \
+		(((v) << 8) & BM_DRAM_CTL176_ADD_ODT_CLK_DIFFTYPE_DIFFCS)
+#define BP_DRAM_CTL176_RSVD1	3
+#define BM_DRAM_CTL176_RSVD1	0x000000F8
+#define BF_DRAM_CTL176_RSVD1(v)  \
+		(((v) << 3) & BM_DRAM_CTL176_RSVD1)
+#define BP_DRAM_CTL176_W2W_SAMECS_DLY	0
+#define BM_DRAM_CTL176_W2W_SAMECS_DLY	0x00000007
+#define BF_DRAM_CTL176_W2W_SAMECS_DLY(v)  \
+		(((v) << 0) & BM_DRAM_CTL176_W2W_SAMECS_DLY)
+
+#define HW_DRAM_CTL177	(0x000002c4)
+
+#define BP_DRAM_CTL177_RSVD4	29
+#define BM_DRAM_CTL177_RSVD4	0xE0000000
+#define BF_DRAM_CTL177_RSVD4(v) \
+		(((v) << 29) & BM_DRAM_CTL177_RSVD4)
+#define BP_DRAM_CTL177_TCCD	24
+#define BM_DRAM_CTL177_TCCD	0x1F000000
+#define BF_DRAM_CTL177_TCCD(v)  \
+		(((v) << 24) & BM_DRAM_CTL177_TCCD)
+#define BP_DRAM_CTL177_RSVD3	20
+#define BM_DRAM_CTL177_RSVD3	0x00F00000
+#define BF_DRAM_CTL177_RSVD3(v)  \
+		(((v) << 20) & BM_DRAM_CTL177_RSVD3)
+#define BP_DRAM_CTL177_TRP_AB	16
+#define BM_DRAM_CTL177_TRP_AB	0x000F0000
+#define BF_DRAM_CTL177_TRP_AB(v)  \
+		(((v) << 16) & BM_DRAM_CTL177_TRP_AB)
+#define BP_DRAM_CTL177_RSVD2	12
+#define BM_DRAM_CTL177_RSVD2	0x0000F000
+#define BF_DRAM_CTL177_RSVD2(v)  \
+		(((v) << 12) & BM_DRAM_CTL177_RSVD2)
+#define BP_DRAM_CTL177_CKSRX	8
+#define BM_DRAM_CTL177_CKSRX	0x00000F00
+#define BF_DRAM_CTL177_CKSRX(v)  \
+		(((v) << 8) & BM_DRAM_CTL177_CKSRX)
+#define BP_DRAM_CTL177_RSVD1	4
+#define BM_DRAM_CTL177_RSVD1	0x000000F0
+#define BF_DRAM_CTL177_RSVD1(v)  \
+		(((v) << 4) & BM_DRAM_CTL177_RSVD1)
+#define BP_DRAM_CTL177_CKSRE	0
+#define BM_DRAM_CTL177_CKSRE	0x0000000F
+#define BF_DRAM_CTL177_CKSRE(v)  \
+		(((v) << 0) & BM_DRAM_CTL177_CKSRE)
+
+#define HW_DRAM_CTL178	(0x000002c8)
+
+#define BM_DRAM_CTL178_RSVD4	0x80000000
+#define BP_DRAM_CTL178_AXI5_BDW	24
+#define BM_DRAM_CTL178_AXI5_BDW	0x7F000000
+#define BF_DRAM_CTL178_AXI5_BDW(v)  \
+		(((v) << 24) & BM_DRAM_CTL178_AXI5_BDW)
+#define BM_DRAM_CTL178_RSVD3	0x00800000
+#define BP_DRAM_CTL178_AXI4_CURRENT_BDW	16
+#define BM_DRAM_CTL178_AXI4_CURRENT_BDW	0x007F0000
+#define BF_DRAM_CTL178_AXI4_CURRENT_BDW(v)  \
+		(((v) << 16) & BM_DRAM_CTL178_AXI4_CURRENT_BDW)
+#define BM_DRAM_CTL178_RSVD2	0x00008000
+#define BP_DRAM_CTL178_AXI4_BDW	8
+#define BM_DRAM_CTL178_AXI4_BDW	0x00007F00
+#define BF_DRAM_CTL178_AXI4_BDW(v)  \
+		(((v) << 8) & BM_DRAM_CTL178_AXI4_BDW)
+#define BP_DRAM_CTL178_RSVD1	5
+#define BM_DRAM_CTL178_RSVD1	0x000000E0
+#define BF_DRAM_CTL178_RSVD1(v)  \
+		(((v) << 5) & BM_DRAM_CTL178_RSVD1)
+#define BP_DRAM_CTL178_TCKESR	0
+#define BM_DRAM_CTL178_TCKESR	0x0000001F
+#define BF_DRAM_CTL178_TCKESR(v)  \
+		(((v) << 0) & BM_DRAM_CTL178_TCKESR)
+
+#define HW_DRAM_CTL179	(0x000002cc)
+
+#define BP_DRAM_CTL179_RSVD3	24
+#define BM_DRAM_CTL179_RSVD3	0xFF000000
+#define BF_DRAM_CTL179_RSVD3(v) \
+		(((v) << 24) & BM_DRAM_CTL179_RSVD3)
+#define BP_DRAM_CTL179_RSVD2	22
+#define BM_DRAM_CTL179_RSVD2	0x00C00000
+#define BF_DRAM_CTL179_RSVD2(v)  \
+		(((v) << 22) & BM_DRAM_CTL179_RSVD2)
+#define BP_DRAM_CTL179_TDFI_PHYUPD_TYPE1	8
+#define BM_DRAM_CTL179_TDFI_PHYUPD_TYPE1	0x003FFF00
+#define BF_DRAM_CTL179_TDFI_PHYUPD_TYPE1(v)  \
+		(((v) << 8) & BM_DRAM_CTL179_TDFI_PHYUPD_TYPE1)
+#define BM_DRAM_CTL179_RSVD1	0x00000080
+#define BP_DRAM_CTL179_AXI5_CURRENT_BDW	0
+#define BM_DRAM_CTL179_AXI5_CURRENT_BDW	0x0000007F
+#define BF_DRAM_CTL179_AXI5_CURRENT_BDW(v)  \
+		(((v) << 0) & BM_DRAM_CTL179_AXI5_CURRENT_BDW)
+
+#define HW_DRAM_CTL180	(0x000002d0)
+
+#define BP_DRAM_CTL180_RSVD2	30
+#define BM_DRAM_CTL180_RSVD2	0xC0000000
+#define BF_DRAM_CTL180_RSVD2(v) \
+		(((v) << 30) & BM_DRAM_CTL180_RSVD2)
+#define BP_DRAM_CTL180_TDFI_PHYUPD_TYPE3	16
+#define BM_DRAM_CTL180_TDFI_PHYUPD_TYPE3	0x3FFF0000
+#define BF_DRAM_CTL180_TDFI_PHYUPD_TYPE3(v)  \
+		(((v) << 16) & BM_DRAM_CTL180_TDFI_PHYUPD_TYPE3)
+#define BP_DRAM_CTL180_RSVD1	14
+#define BM_DRAM_CTL180_RSVD1	0x0000C000
+#define BF_DRAM_CTL180_RSVD1(v)  \
+		(((v) << 14) & BM_DRAM_CTL180_RSVD1)
+#define BP_DRAM_CTL180_TDFI_PHYUPD_TYPE2	0
+#define BM_DRAM_CTL180_TDFI_PHYUPD_TYPE2	0x00003FFF
+#define BF_DRAM_CTL180_TDFI_PHYUPD_TYPE2(v)  \
+		(((v) << 0) & BM_DRAM_CTL180_TDFI_PHYUPD_TYPE2)
+
+#define HW_DRAM_CTL181	(0x000002d4)
+
+#define BM_DRAM_CTL181_RSVD2	0x80000000
+#define BP_DRAM_CTL181_MR0_DATA_1	16
+#define BM_DRAM_CTL181_MR0_DATA_1	0x7FFF0000
+#define BF_DRAM_CTL181_MR0_DATA_1(v)  \
+		(((v) << 16) & BM_DRAM_CTL181_MR0_DATA_1)
+#define BM_DRAM_CTL181_RSVD1	0x00008000
+#define BP_DRAM_CTL181_MR0_DATA_0	0
+#define BM_DRAM_CTL181_MR0_DATA_0	0x00007FFF
+#define BF_DRAM_CTL181_MR0_DATA_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL181_MR0_DATA_0)
+
+#define HW_DRAM_CTL182	(0x000002d8)
+
+#define BM_DRAM_CTL182_RSVD2	0x80000000
+#define BP_DRAM_CTL182_MR0_DATA_3	16
+#define BM_DRAM_CTL182_MR0_DATA_3	0x7FFF0000
+#define BF_DRAM_CTL182_MR0_DATA_3(v)  \
+		(((v) << 16) & BM_DRAM_CTL182_MR0_DATA_3)
+#define BM_DRAM_CTL182_RSVD1	0x00008000
+#define BP_DRAM_CTL182_MR0_DATA_2	0
+#define BM_DRAM_CTL182_MR0_DATA_2	0x00007FFF
+#define BF_DRAM_CTL182_MR0_DATA_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL182_MR0_DATA_2)
+
+#define HW_DRAM_CTL183	(0x000002dc)
+
+#define BM_DRAM_CTL183_RSVD2	0x80000000
+#define BP_DRAM_CTL183_MR1_DATA_1	16
+#define BM_DRAM_CTL183_MR1_DATA_1	0x7FFF0000
+#define BF_DRAM_CTL183_MR1_DATA_1(v)  \
+		(((v) << 16) & BM_DRAM_CTL183_MR1_DATA_1)
+#define BM_DRAM_CTL183_RSVD1	0x00008000
+#define BP_DRAM_CTL183_MR1_DATA_0	0
+#define BM_DRAM_CTL183_MR1_DATA_0	0x00007FFF
+#define BF_DRAM_CTL183_MR1_DATA_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL183_MR1_DATA_0)
+
+#define HW_DRAM_CTL184	(0x000002e0)
+
+#define BM_DRAM_CTL184_RSVD2	0x80000000
+#define BP_DRAM_CTL184_MR1_DATA_3	16
+#define BM_DRAM_CTL184_MR1_DATA_3	0x7FFF0000
+#define BF_DRAM_CTL184_MR1_DATA_3(v)  \
+		(((v) << 16) & BM_DRAM_CTL184_MR1_DATA_3)
+#define BM_DRAM_CTL184_RSVD1	0x00008000
+#define BP_DRAM_CTL184_MR1_DATA_2	0
+#define BM_DRAM_CTL184_MR1_DATA_2	0x00007FFF
+#define BF_DRAM_CTL184_MR1_DATA_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL184_MR1_DATA_2)
+
+#define HW_DRAM_CTL185	(0x000002e4)
+
+#define BM_DRAM_CTL185_RSVD2	0x80000000
+#define BP_DRAM_CTL185_MR2_DATA_1	16
+#define BM_DRAM_CTL185_MR2_DATA_1	0x7FFF0000
+#define BF_DRAM_CTL185_MR2_DATA_1(v)  \
+		(((v) << 16) & BM_DRAM_CTL185_MR2_DATA_1)
+#define BM_DRAM_CTL185_RSVD1	0x00008000
+#define BP_DRAM_CTL185_MR2_DATA_0	0
+#define BM_DRAM_CTL185_MR2_DATA_0	0x00007FFF
+#define BF_DRAM_CTL185_MR2_DATA_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL185_MR2_DATA_0)
+
+#define HW_DRAM_CTL186	(0x000002e8)
+
+#define BM_DRAM_CTL186_RSVD2	0x80000000
+#define BP_DRAM_CTL186_MR2_DATA_3	16
+#define BM_DRAM_CTL186_MR2_DATA_3	0x7FFF0000
+#define BF_DRAM_CTL186_MR2_DATA_3(v)  \
+		(((v) << 16) & BM_DRAM_CTL186_MR2_DATA_3)
+#define BM_DRAM_CTL186_RSVD1	0x00008000
+#define BP_DRAM_CTL186_MR2_DATA_2	0
+#define BM_DRAM_CTL186_MR2_DATA_2	0x00007FFF
+#define BF_DRAM_CTL186_MR2_DATA_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL186_MR2_DATA_2)
+
+#define HW_DRAM_CTL187	(0x000002ec)
+
+#define BM_DRAM_CTL187_RSVD2	0x80000000
+#define BP_DRAM_CTL187_MR3_DATA_1	16
+#define BM_DRAM_CTL187_MR3_DATA_1	0x7FFF0000
+#define BF_DRAM_CTL187_MR3_DATA_1(v)  \
+		(((v) << 16) & BM_DRAM_CTL187_MR3_DATA_1)
+#define BM_DRAM_CTL187_RSVD1	0x00008000
+#define BP_DRAM_CTL187_MR3_DATA_0	0
+#define BM_DRAM_CTL187_MR3_DATA_0	0x00007FFF
+#define BF_DRAM_CTL187_MR3_DATA_0(v)  \
+		(((v) << 0) & BM_DRAM_CTL187_MR3_DATA_0)
+
+#define HW_DRAM_CTL188	(0x000002f0)
+
+#define BM_DRAM_CTL188_RSVD2	0x80000000
+#define BP_DRAM_CTL188_MR3_DATA_3	16
+#define BM_DRAM_CTL188_MR3_DATA_3	0x7FFF0000
+#define BF_DRAM_CTL188_MR3_DATA_3(v)  \
+		(((v) << 16) & BM_DRAM_CTL188_MR3_DATA_3)
+#define BM_DRAM_CTL188_RSVD1	0x00008000
+#define BP_DRAM_CTL188_MR3_DATA_2	0
+#define BM_DRAM_CTL188_MR3_DATA_2	0x00007FFF
+#define BF_DRAM_CTL188_MR3_DATA_2(v)  \
+		(((v) << 0) & BM_DRAM_CTL188_MR3_DATA_2)
+
+#define HW_DRAM_CTL189	(0x000002f4)
+
+#define BP_DRAM_CTL189_AXI5_EN_SIZE_LT_WIDTH_INSTR	16
+#define BM_DRAM_CTL189_AXI5_EN_SIZE_LT_WIDTH_INSTR	0xFFFF0000
+#define BF_DRAM_CTL189_AXI5_EN_SIZE_LT_WIDTH_INSTR(v) \
+		(((v) << 16) & BM_DRAM_CTL189_AXI5_EN_SIZE_LT_WIDTH_INSTR)
+#define BP_DRAM_CTL189_AXI4_EN_SIZE_LT_WIDTH_INSTR	0
+#define BM_DRAM_CTL189_AXI4_EN_SIZE_LT_WIDTH_INSTR	0x0000FFFF
+#define BF_DRAM_CTL189_AXI4_EN_SIZE_LT_WIDTH_INSTR(v)  \
+		(((v) << 0) & BM_DRAM_CTL189_AXI4_EN_SIZE_LT_WIDTH_INSTR)
+#endif /* __ARCH_ARM___DRAM_H */
diff --git a/arch/arm/mach-mx28/regs-pinctrl.h b/arch/arm/mach-mx28/regs-pinctrl.h
new file mode 100644
index 0000000..03c7f15
--- /dev/null
+++ b/arch/arm/mach-mx28/regs-pinctrl.h
@@ -0,0 +1,2673 @@
+/*
+ * Freescale PINCTRL Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.19
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___PINCTRL_H
+#define __ARCH_ARM___PINCTRL_H
+
+#define HW_PINCTRL_CTRL	(0x00000000)
+#define HW_PINCTRL_CTRL_SET	(0x00000004)
+#define HW_PINCTRL_CTRL_CLR	(0x00000008)
+#define HW_PINCTRL_CTRL_TOG	(0x0000000c)
+
+#define BM_PINCTRL_CTRL_SFTRST	0x80000000
+#define BM_PINCTRL_CTRL_CLKGATE	0x40000000
+#define BP_PINCTRL_CTRL_RSRVD2	25
+#define BM_PINCTRL_CTRL_RSRVD2	0x3E000000
+#define BF_PINCTRL_CTRL_RSRVD2(v)  \
+		(((v) << 25) & BM_PINCTRL_CTRL_RSRVD2)
+#define BM_PINCTRL_CTRL_PRESENT4	0x01000000
+#define BM_PINCTRL_CTRL_PRESENT3	0x00800000
+#define BM_PINCTRL_CTRL_PRESENT2	0x00400000
+#define BM_PINCTRL_CTRL_PRESENT1	0x00200000
+#define BM_PINCTRL_CTRL_PRESENT0	0x00100000
+#define BP_PINCTRL_CTRL_RSRVD1	5
+#define BM_PINCTRL_CTRL_RSRVD1	0x000FFFE0
+#define BF_PINCTRL_CTRL_RSRVD1(v)  \
+		(((v) << 5) & BM_PINCTRL_CTRL_RSRVD1)
+#define BM_PINCTRL_CTRL_IRQOUT4	0x00000010
+#define BM_PINCTRL_CTRL_IRQOUT3	0x00000008
+#define BM_PINCTRL_CTRL_IRQOUT2	0x00000004
+#define BM_PINCTRL_CTRL_IRQOUT1	0x00000002
+#define BM_PINCTRL_CTRL_IRQOUT0	0x00000001
+
+#define HW_PINCTRL_MUXSEL0	(0x00000100)
+#define HW_PINCTRL_MUXSEL0_SET	(0x00000104)
+#define HW_PINCTRL_MUXSEL0_CLR	(0x00000108)
+#define HW_PINCTRL_MUXSEL0_TOG	(0x0000010c)
+
+#define BP_PINCTRL_MUXSEL0_RSRVD0	16
+#define BM_PINCTRL_MUXSEL0_RSRVD0	0xFFFF0000
+#define BF_PINCTRL_MUXSEL0_RSRVD0(v) \
+		(((v) << 16) & BM_PINCTRL_MUXSEL0_RSRVD0)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN07	14
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL0_BANK0_PIN07)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN06	12
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL0_BANK0_PIN06)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN05	10
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL0_BANK0_PIN05)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN04	8
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL0_BANK0_PIN04)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN03	6
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL0_BANK0_PIN03)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN02	4
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL0_BANK0_PIN02)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN01	2
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL0_BANK0_PIN01)
+#define BP_PINCTRL_MUXSEL0_BANK0_PIN00	0
+#define BM_PINCTRL_MUXSEL0_BANK0_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL0_BANK0_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL0_BANK0_PIN00)
+
+#define HW_PINCTRL_MUXSEL1	(0x00000110)
+#define HW_PINCTRL_MUXSEL1_SET	(0x00000114)
+#define HW_PINCTRL_MUXSEL1_CLR	(0x00000118)
+#define HW_PINCTRL_MUXSEL1_TOG	(0x0000011c)
+
+#define BP_PINCTRL_MUXSEL1_RSRVD0	26
+#define BM_PINCTRL_MUXSEL1_RSRVD0	0xFC000000
+#define BF_PINCTRL_MUXSEL1_RSRVD0(v) \
+		(((v) << 26) & BM_PINCTRL_MUXSEL1_RSRVD0)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN28	24
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL1_BANK0_PIN28)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN27	22
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL1_BANK0_PIN27)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN26	20
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL1_BANK0_PIN26)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN25	18
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL1_BANK0_PIN25)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN24	16
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL1_BANK0_PIN24)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN23	14
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL1_BANK0_PIN23)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN22	12
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL1_BANK0_PIN22)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN21	10
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL1_BANK0_PIN21)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN20	8
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL1_BANK0_PIN20)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN19	6
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL1_BANK0_PIN19)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN18	4
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL1_BANK0_PIN18)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN17	2
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL1_BANK0_PIN17)
+#define BP_PINCTRL_MUXSEL1_BANK0_PIN16	0
+#define BM_PINCTRL_MUXSEL1_BANK0_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL1_BANK0_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL1_BANK0_PIN16)
+
+#define HW_PINCTRL_MUXSEL2	(0x00000120)
+#define HW_PINCTRL_MUXSEL2_SET	(0x00000124)
+#define HW_PINCTRL_MUXSEL2_CLR	(0x00000128)
+#define HW_PINCTRL_MUXSEL2_TOG	(0x0000012c)
+
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN15	30
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL2_BANK1_PIN15)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN14	28
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL2_BANK1_PIN14)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN13	26
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL2_BANK1_PIN13)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN12	24
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL2_BANK1_PIN12)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN11	22
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL2_BANK1_PIN11)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN10	20
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL2_BANK1_PIN10)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN09	18
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL2_BANK1_PIN09)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN08	16
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL2_BANK1_PIN08)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN07	14
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL2_BANK1_PIN07)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN06	12
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL2_BANK1_PIN06)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN05	10
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL2_BANK1_PIN05)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN04	8
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL2_BANK1_PIN04)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN03	6
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL2_BANK1_PIN03)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN02	4
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL2_BANK1_PIN02)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN01	2
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL2_BANK1_PIN01)
+#define BP_PINCTRL_MUXSEL2_BANK1_PIN00	0
+#define BM_PINCTRL_MUXSEL2_BANK1_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL2_BANK1_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL2_BANK1_PIN00)
+
+#define HW_PINCTRL_MUXSEL3	(0x00000130)
+#define HW_PINCTRL_MUXSEL3_SET	(0x00000134)
+#define HW_PINCTRL_MUXSEL3_CLR	(0x00000138)
+#define HW_PINCTRL_MUXSEL3_TOG	(0x0000013c)
+
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN31	30
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN31	0xC0000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN31(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL3_BANK1_PIN31)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN30	28
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN30	0x30000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN30(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL3_BANK1_PIN30)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN29	26
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN29	0x0C000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN29(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL3_BANK1_PIN29)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN28	24
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL3_BANK1_PIN28)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN27	22
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL3_BANK1_PIN27)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN26	20
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL3_BANK1_PIN26)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN25	18
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL3_BANK1_PIN25)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN24	16
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL3_BANK1_PIN24)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN23	14
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL3_BANK1_PIN23)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN22	12
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL3_BANK1_PIN22)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN21	10
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL3_BANK1_PIN21)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN20	8
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL3_BANK1_PIN20)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN19	6
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL3_BANK1_PIN19)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN18	4
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL3_BANK1_PIN18)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN17	2
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL3_BANK1_PIN17)
+#define BP_PINCTRL_MUXSEL3_BANK1_PIN16	0
+#define BM_PINCTRL_MUXSEL3_BANK1_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL3_BANK1_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL3_BANK1_PIN16)
+
+#define HW_PINCTRL_MUXSEL4	(0x00000140)
+#define HW_PINCTRL_MUXSEL4_SET	(0x00000144)
+#define HW_PINCTRL_MUXSEL4_CLR	(0x00000148)
+#define HW_PINCTRL_MUXSEL4_TOG	(0x0000014c)
+
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN15	30
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL4_BANK2_PIN15)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN14	28
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL4_BANK2_PIN14)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN13	26
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL4_BANK2_PIN13)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN12	24
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL4_BANK2_PIN12)
+#define BP_PINCTRL_MUXSEL4_RSRVD0	22
+#define BM_PINCTRL_MUXSEL4_RSRVD0	0x00C00000
+#define BF_PINCTRL_MUXSEL4_RSRVD0(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL4_RSRVD0)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN10	20
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL4_BANK2_PIN10)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN09	18
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL4_BANK2_PIN09)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN08	16
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL4_BANK2_PIN08)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN07	14
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL4_BANK2_PIN07)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN06	12
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL4_BANK2_PIN06)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN05	10
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL4_BANK2_PIN05)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN04	8
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL4_BANK2_PIN04)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN03	6
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL4_BANK2_PIN03)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN02	4
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL4_BANK2_PIN02)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN01	2
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL4_BANK2_PIN01)
+#define BP_PINCTRL_MUXSEL4_BANK2_PIN00	0
+#define BM_PINCTRL_MUXSEL4_BANK2_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL4_BANK2_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL4_BANK2_PIN00)
+
+#define HW_PINCTRL_MUXSEL5	(0x00000150)
+#define HW_PINCTRL_MUXSEL5_SET	(0x00000154)
+#define HW_PINCTRL_MUXSEL5_CLR	(0x00000158)
+#define HW_PINCTRL_MUXSEL5_TOG	(0x0000015c)
+
+#define BP_PINCTRL_MUXSEL5_RSRVD1	24
+#define BM_PINCTRL_MUXSEL5_RSRVD1	0xFF000000
+#define BF_PINCTRL_MUXSEL5_RSRVD1(v) \
+		(((v) << 24) & BM_PINCTRL_MUXSEL5_RSRVD1)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN27	22
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL5_BANK2_PIN27)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN26	20
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL5_BANK2_PIN26)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN25	18
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL5_BANK2_PIN25)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN24	16
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL5_BANK2_PIN24)
+#define BP_PINCTRL_MUXSEL5_RSRVD0	12
+#define BM_PINCTRL_MUXSEL5_RSRVD0	0x0000F000
+#define BF_PINCTRL_MUXSEL5_RSRVD0(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL5_RSRVD0)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN21	10
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL5_BANK2_PIN21)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN20	8
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL5_BANK2_PIN20)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN19	6
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL5_BANK2_PIN19)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN18	4
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL5_BANK2_PIN18)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN17	2
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL5_BANK2_PIN17)
+#define BP_PINCTRL_MUXSEL5_BANK2_PIN16	0
+#define BM_PINCTRL_MUXSEL5_BANK2_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL5_BANK2_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL5_BANK2_PIN16)
+
+#define HW_PINCTRL_MUXSEL6	(0x00000160)
+#define HW_PINCTRL_MUXSEL6_SET	(0x00000164)
+#define HW_PINCTRL_MUXSEL6_CLR	(0x00000168)
+#define HW_PINCTRL_MUXSEL6_TOG	(0x0000016c)
+
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN15	30
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL6_BANK3_PIN15)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN14	28
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL6_BANK3_PIN14)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN13	26
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL6_BANK3_PIN13)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN12	24
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL6_BANK3_PIN12)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN11	22
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL6_BANK3_PIN11)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN10	20
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL6_BANK3_PIN10)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN09	18
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL6_BANK3_PIN09)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN08	16
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL6_BANK3_PIN08)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN07	14
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL6_BANK3_PIN07)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN06	12
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL6_BANK3_PIN06)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN05	10
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL6_BANK3_PIN05)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN04	8
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL6_BANK3_PIN04)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN03	6
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL6_BANK3_PIN03)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN02	4
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL6_BANK3_PIN02)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN01	2
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL6_BANK3_PIN01)
+#define BP_PINCTRL_MUXSEL6_BANK3_PIN00	0
+#define BM_PINCTRL_MUXSEL6_BANK3_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL6_BANK3_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL6_BANK3_PIN00)
+
+#define HW_PINCTRL_MUXSEL7	(0x00000170)
+#define HW_PINCTRL_MUXSEL7_SET	(0x00000174)
+#define HW_PINCTRL_MUXSEL7_CLR	(0x00000178)
+#define HW_PINCTRL_MUXSEL7_TOG	(0x0000017c)
+
+#define BP_PINCTRL_MUXSEL7_RSRVD1	30
+#define BM_PINCTRL_MUXSEL7_RSRVD1	0xC0000000
+#define BF_PINCTRL_MUXSEL7_RSRVD1(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL7_RSRVD1)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN30	28
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN30	0x30000000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN30(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL7_BANK3_PIN30)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN29	26
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN29	0x0C000000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN29(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL7_BANK3_PIN29)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN28	24
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN28	0x03000000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN28(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL7_BANK3_PIN28)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN27	22
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN27	0x00C00000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN27(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL7_BANK3_PIN27)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN26	20
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL7_BANK3_PIN26)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN25	18
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN25	0x000C0000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN25(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL7_BANK3_PIN25)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN24	16
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL7_BANK3_PIN24)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN23	14
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL7_BANK3_PIN23)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN22	12
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL7_BANK3_PIN22)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN21	10
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL7_BANK3_PIN21)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN20	8
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL7_BANK3_PIN20)
+#define BP_PINCTRL_MUXSEL7_RSRVD0	6
+#define BM_PINCTRL_MUXSEL7_RSRVD0	0x000000C0
+#define BF_PINCTRL_MUXSEL7_RSRVD0(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL7_RSRVD0)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN18	4
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL7_BANK3_PIN18)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN17	2
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL7_BANK3_PIN17)
+#define BP_PINCTRL_MUXSEL7_BANK3_PIN16	0
+#define BM_PINCTRL_MUXSEL7_BANK3_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL7_BANK3_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL7_BANK3_PIN16)
+
+#define HW_PINCTRL_MUXSEL8	(0x00000180)
+#define HW_PINCTRL_MUXSEL8_SET	(0x00000184)
+#define HW_PINCTRL_MUXSEL8_CLR	(0x00000188)
+#define HW_PINCTRL_MUXSEL8_TOG	(0x0000018c)
+
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN15	30
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL8_BANK4_PIN15)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN14	28
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL8_BANK4_PIN14)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN13	26
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL8_BANK4_PIN13)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN12	24
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL8_BANK4_PIN12)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN11	22
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL8_BANK4_PIN11)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN10	20
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL8_BANK4_PIN10)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN09	18
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL8_BANK4_PIN09)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN08	16
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL8_BANK4_PIN08)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN07	14
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL8_BANK4_PIN07)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN06	12
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL8_BANK4_PIN06)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN05	10
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL8_BANK4_PIN05)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN04	8
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL8_BANK4_PIN04)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN03	6
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL8_BANK4_PIN03)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN02	4
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL8_BANK4_PIN02)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN01	2
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL8_BANK4_PIN01)
+#define BP_PINCTRL_MUXSEL8_BANK4_PIN00	0
+#define BM_PINCTRL_MUXSEL8_BANK4_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL8_BANK4_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL8_BANK4_PIN00)
+
+#define HW_PINCTRL_MUXSEL9	(0x00000190)
+#define HW_PINCTRL_MUXSEL9_SET	(0x00000194)
+#define HW_PINCTRL_MUXSEL9_CLR	(0x00000198)
+#define HW_PINCTRL_MUXSEL9_TOG	(0x0000019c)
+
+#define BP_PINCTRL_MUXSEL9_RSRVD1	10
+#define BM_PINCTRL_MUXSEL9_RSRVD1	0xFFFFFC00
+#define BF_PINCTRL_MUXSEL9_RSRVD1(v) \
+		(((v) << 10) & BM_PINCTRL_MUXSEL9_RSRVD1)
+#define BP_PINCTRL_MUXSEL9_BANK4_PIN20	8
+#define BM_PINCTRL_MUXSEL9_BANK4_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL9_BANK4_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL9_BANK4_PIN20)
+#define BP_PINCTRL_MUXSEL9_RSRVD0	2
+#define BM_PINCTRL_MUXSEL9_RSRVD0	0x000000FC
+#define BF_PINCTRL_MUXSEL9_RSRVD0(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL9_RSRVD0)
+#define BP_PINCTRL_MUXSEL9_BANK4_PIN16	0
+#define BM_PINCTRL_MUXSEL9_BANK4_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL9_BANK4_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL9_BANK4_PIN16)
+
+#define HW_PINCTRL_MUXSEL10	(0x000001a0)
+#define HW_PINCTRL_MUXSEL10_SET	(0x000001a4)
+#define HW_PINCTRL_MUXSEL10_CLR	(0x000001a8)
+#define HW_PINCTRL_MUXSEL10_TOG	(0x000001ac)
+
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN15	30
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN15	0xC0000000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN15(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL10_BANK5_PIN15)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN14	28
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL10_BANK5_PIN14)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN13	26
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL10_BANK5_PIN13)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN12	24
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL10_BANK5_PIN12)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN11	22
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL10_BANK5_PIN11)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN10	20
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL10_BANK5_PIN10)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN09	18
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL10_BANK5_PIN09)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN08	16
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL10_BANK5_PIN08)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN07	14
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL10_BANK5_PIN07)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN06	12
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL10_BANK5_PIN06)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN05	10
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL10_BANK5_PIN05)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN04	8
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL10_BANK5_PIN04)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN03	6
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL10_BANK5_PIN03)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN02	4
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL10_BANK5_PIN02)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN01	2
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL10_BANK5_PIN01)
+#define BP_PINCTRL_MUXSEL10_BANK5_PIN00	0
+#define BM_PINCTRL_MUXSEL10_BANK5_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL10_BANK5_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL10_BANK5_PIN00)
+
+#define HW_PINCTRL_MUXSEL11	(0x000001b0)
+#define HW_PINCTRL_MUXSEL11_SET	(0x000001b4)
+#define HW_PINCTRL_MUXSEL11_CLR	(0x000001b8)
+#define HW_PINCTRL_MUXSEL11_TOG	(0x000001bc)
+
+#define BP_PINCTRL_MUXSEL11_RSRVD1	22
+#define BM_PINCTRL_MUXSEL11_RSRVD1	0xFFC00000
+#define BF_PINCTRL_MUXSEL11_RSRVD1(v) \
+		(((v) << 22) & BM_PINCTRL_MUXSEL11_RSRVD1)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN26	20
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN26	0x00300000
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN26(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL11_BANK5_PIN26)
+#define BP_PINCTRL_MUXSEL11_RSRVD0	16
+#define BM_PINCTRL_MUXSEL11_RSRVD0	0x000F0000
+#define BF_PINCTRL_MUXSEL11_RSRVD0(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL11_RSRVD0)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN23	14
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL11_BANK5_PIN23)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN22	12
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL11_BANK5_PIN22)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN21	10
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL11_BANK5_PIN21)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN20	8
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL11_BANK5_PIN20)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN19	6
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL11_BANK5_PIN19)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN18	4
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL11_BANK5_PIN18)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN17	2
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL11_BANK5_PIN17)
+#define BP_PINCTRL_MUXSEL11_BANK5_PIN16	0
+#define BM_PINCTRL_MUXSEL11_BANK5_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL11_BANK5_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL11_BANK5_PIN16)
+
+#define HW_PINCTRL_MUXSEL12	(0x000001c0)
+#define HW_PINCTRL_MUXSEL12_SET	(0x000001c4)
+#define HW_PINCTRL_MUXSEL12_CLR	(0x000001c8)
+#define HW_PINCTRL_MUXSEL12_TOG	(0x000001cc)
+
+#define BP_PINCTRL_MUXSEL12_RSRVD0	30
+#define BM_PINCTRL_MUXSEL12_RSRVD0	0xC0000000
+#define BF_PINCTRL_MUXSEL12_RSRVD0(v) \
+		(((v) << 30) & BM_PINCTRL_MUXSEL12_RSRVD0)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN14	28
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN14	0x30000000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN14(v)  \
+		(((v) << 28) & BM_PINCTRL_MUXSEL12_BANK6_PIN14)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN13	26
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN13	0x0C000000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN13(v)  \
+		(((v) << 26) & BM_PINCTRL_MUXSEL12_BANK6_PIN13)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN12	24
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN12	0x03000000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN12(v)  \
+		(((v) << 24) & BM_PINCTRL_MUXSEL12_BANK6_PIN12)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN11	22
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN11	0x00C00000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN11(v)  \
+		(((v) << 22) & BM_PINCTRL_MUXSEL12_BANK6_PIN11)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN10	20
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN10	0x00300000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN10(v)  \
+		(((v) << 20) & BM_PINCTRL_MUXSEL12_BANK6_PIN10)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN09	18
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN09	0x000C0000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN09(v)  \
+		(((v) << 18) & BM_PINCTRL_MUXSEL12_BANK6_PIN09)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN08	16
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN08	0x00030000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN08(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL12_BANK6_PIN08)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN07	14
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN07	0x0000C000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN07(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL12_BANK6_PIN07)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN06	12
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN06	0x00003000
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN06(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL12_BANK6_PIN06)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN05	10
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN05	0x00000C00
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN05(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL12_BANK6_PIN05)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN04	8
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN04	0x00000300
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN04(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL12_BANK6_PIN04)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN03	6
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN03	0x000000C0
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN03(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL12_BANK6_PIN03)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN02	4
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN02	0x00000030
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN02(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL12_BANK6_PIN02)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN01	2
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN01	0x0000000C
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN01(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL12_BANK6_PIN01)
+#define BP_PINCTRL_MUXSEL12_BANK6_PIN00	0
+#define BM_PINCTRL_MUXSEL12_BANK6_PIN00	0x00000003
+#define BF_PINCTRL_MUXSEL12_BANK6_PIN00(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL12_BANK6_PIN00)
+
+#define HW_PINCTRL_MUXSEL13	(0x000001d0)
+#define HW_PINCTRL_MUXSEL13_SET	(0x000001d4)
+#define HW_PINCTRL_MUXSEL13_CLR	(0x000001d8)
+#define HW_PINCTRL_MUXSEL13_TOG	(0x000001dc)
+
+#define BP_PINCTRL_MUXSEL13_RSRVD0	18
+#define BM_PINCTRL_MUXSEL13_RSRVD0	0xFFFC0000
+#define BF_PINCTRL_MUXSEL13_RSRVD0(v) \
+		(((v) << 18) & BM_PINCTRL_MUXSEL13_RSRVD0)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN24	16
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN24	0x00030000
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN24(v)  \
+		(((v) << 16) & BM_PINCTRL_MUXSEL13_BANK6_PIN24)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN23	14
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN23	0x0000C000
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN23(v)  \
+		(((v) << 14) & BM_PINCTRL_MUXSEL13_BANK6_PIN23)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN22	12
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN22	0x00003000
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN22(v)  \
+		(((v) << 12) & BM_PINCTRL_MUXSEL13_BANK6_PIN22)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN21	10
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN21	0x00000C00
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN21(v)  \
+		(((v) << 10) & BM_PINCTRL_MUXSEL13_BANK6_PIN21)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN20	8
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN20	0x00000300
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN20(v)  \
+		(((v) << 8) & BM_PINCTRL_MUXSEL13_BANK6_PIN20)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN19	6
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN19	0x000000C0
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN19(v)  \
+		(((v) << 6) & BM_PINCTRL_MUXSEL13_BANK6_PIN19)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN18	4
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN18	0x00000030
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN18(v)  \
+		(((v) << 4) & BM_PINCTRL_MUXSEL13_BANK6_PIN18)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN17	2
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN17	0x0000000C
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN17(v)  \
+		(((v) << 2) & BM_PINCTRL_MUXSEL13_BANK6_PIN17)
+#define BP_PINCTRL_MUXSEL13_BANK6_PIN16	0
+#define BM_PINCTRL_MUXSEL13_BANK6_PIN16	0x00000003
+#define BF_PINCTRL_MUXSEL13_BANK6_PIN16(v)  \
+		(((v) << 0) & BM_PINCTRL_MUXSEL13_BANK6_PIN16)
+
+#define HW_PINCTRL_DRIVE0	(0x00000300)
+#define HW_PINCTRL_DRIVE0_SET	(0x00000304)
+#define HW_PINCTRL_DRIVE0_CLR	(0x00000308)
+#define HW_PINCTRL_DRIVE0_TOG	(0x0000030c)
+
+#define BM_PINCTRL_DRIVE0_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE0_BANK0_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE0_BANK0_PIN07_MA	28
+#define BM_PINCTRL_DRIVE0_BANK0_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE0_BANK0_PIN07_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE0_BANK0_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE0_BANK0_PIN06_MA	24
+#define BM_PINCTRL_DRIVE0_BANK0_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE0_BANK0_PIN06_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE0_BANK0_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE0_BANK0_PIN05_MA	20
+#define BM_PINCTRL_DRIVE0_BANK0_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE0_BANK0_PIN05_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE0_BANK0_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE0_BANK0_PIN04_MA	16
+#define BM_PINCTRL_DRIVE0_BANK0_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE0_BANK0_PIN04_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE0_BANK0_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE0_BANK0_PIN03_MA	12
+#define BM_PINCTRL_DRIVE0_BANK0_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE0_BANK0_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE0_BANK0_PIN03_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE0_BANK0_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE0_BANK0_PIN02_MA	8
+#define BM_PINCTRL_DRIVE0_BANK0_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE0_BANK0_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE0_BANK0_PIN02_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE0_BANK0_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE0_BANK0_PIN01_MA	4
+#define BM_PINCTRL_DRIVE0_BANK0_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE0_BANK0_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE0_BANK0_PIN01_MA)
+#define BM_PINCTRL_DRIVE0_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE0_BANK0_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE0_BANK0_PIN00_MA	0
+#define BM_PINCTRL_DRIVE0_BANK0_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE0_BANK0_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE0_BANK0_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE1	(0x00000310)
+#define HW_PINCTRL_DRIVE1_SET	(0x00000314)
+#define HW_PINCTRL_DRIVE1_CLR	(0x00000318)
+#define HW_PINCTRL_DRIVE1_TOG	(0x0000031c)
+
+#define BP_PINCTRL_DRIVE1_RSRVD0	0
+#define BM_PINCTRL_DRIVE1_RSRVD0	0xFFFFFFFF
+#define BF_PINCTRL_DRIVE1_RSRVD0(v)	(v)
+
+#define HW_PINCTRL_DRIVE2	(0x00000320)
+#define HW_PINCTRL_DRIVE2_SET	(0x00000324)
+#define HW_PINCTRL_DRIVE2_CLR	(0x00000328)
+#define HW_PINCTRL_DRIVE2_TOG	(0x0000032c)
+
+#define BM_PINCTRL_DRIVE2_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE2_BANK0_PIN23_V	0x40000000
+#define BP_PINCTRL_DRIVE2_BANK0_PIN23_MA	28
+#define BM_PINCTRL_DRIVE2_BANK0_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE2_BANK0_PIN23_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE2_BANK0_PIN22_V	0x04000000
+#define BP_PINCTRL_DRIVE2_BANK0_PIN22_MA	24
+#define BM_PINCTRL_DRIVE2_BANK0_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE2_BANK0_PIN22_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE2_BANK0_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE2_BANK0_PIN21_MA	20
+#define BM_PINCTRL_DRIVE2_BANK0_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE2_BANK0_PIN21_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE2_BANK0_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE2_BANK0_PIN20_MA	16
+#define BM_PINCTRL_DRIVE2_BANK0_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE2_BANK0_PIN20_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE2_BANK0_PIN19_V	0x00004000
+#define BP_PINCTRL_DRIVE2_BANK0_PIN19_MA	12
+#define BM_PINCTRL_DRIVE2_BANK0_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE2_BANK0_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE2_BANK0_PIN19_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE2_BANK0_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE2_BANK0_PIN18_MA	8
+#define BM_PINCTRL_DRIVE2_BANK0_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE2_BANK0_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE2_BANK0_PIN18_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE2_BANK0_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE2_BANK0_PIN17_MA	4
+#define BM_PINCTRL_DRIVE2_BANK0_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE2_BANK0_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE2_BANK0_PIN17_MA)
+#define BM_PINCTRL_DRIVE2_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE2_BANK0_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE2_BANK0_PIN16_MA	0
+#define BM_PINCTRL_DRIVE2_BANK0_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE2_BANK0_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE2_BANK0_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE3	(0x00000330)
+#define HW_PINCTRL_DRIVE3_SET	(0x00000334)
+#define HW_PINCTRL_DRIVE3_CLR	(0x00000338)
+#define HW_PINCTRL_DRIVE3_TOG	(0x0000033c)
+
+#define BP_PINCTRL_DRIVE3_RSRVD5	20
+#define BM_PINCTRL_DRIVE3_RSRVD5	0xFFF00000
+#define BF_PINCTRL_DRIVE3_RSRVD5(v) \
+		(((v) << 20) & BM_PINCTRL_DRIVE3_RSRVD5)
+#define BM_PINCTRL_DRIVE3_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE3_BANK0_PIN28_V	0x00040000
+#define BP_PINCTRL_DRIVE3_BANK0_PIN28_MA	16
+#define BM_PINCTRL_DRIVE3_BANK0_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE3_BANK0_PIN28_MA)
+#define BM_PINCTRL_DRIVE3_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE3_BANK0_PIN27_V	0x00004000
+#define BP_PINCTRL_DRIVE3_BANK0_PIN27_MA	12
+#define BM_PINCTRL_DRIVE3_BANK0_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE3_BANK0_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE3_BANK0_PIN27_MA)
+#define BM_PINCTRL_DRIVE3_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE3_BANK0_PIN26_V	0x00000400
+#define BP_PINCTRL_DRIVE3_BANK0_PIN26_MA	8
+#define BM_PINCTRL_DRIVE3_BANK0_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE3_BANK0_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE3_BANK0_PIN26_MA)
+#define BM_PINCTRL_DRIVE3_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE3_BANK0_PIN25_V	0x00000040
+#define BP_PINCTRL_DRIVE3_BANK0_PIN25_MA	4
+#define BM_PINCTRL_DRIVE3_BANK0_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE3_BANK0_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE3_BANK0_PIN25_MA)
+#define BM_PINCTRL_DRIVE3_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE3_BANK0_PIN24_V	0x00000004
+#define BP_PINCTRL_DRIVE3_BANK0_PIN24_MA	0
+#define BM_PINCTRL_DRIVE3_BANK0_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE3_BANK0_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE3_BANK0_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE4	(0x00000340)
+#define HW_PINCTRL_DRIVE4_SET	(0x00000344)
+#define HW_PINCTRL_DRIVE4_CLR	(0x00000348)
+#define HW_PINCTRL_DRIVE4_TOG	(0x0000034c)
+
+#define BM_PINCTRL_DRIVE4_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE4_BANK1_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE4_BANK1_PIN07_MA	28
+#define BM_PINCTRL_DRIVE4_BANK1_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE4_BANK1_PIN07_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE4_BANK1_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE4_BANK1_PIN06_MA	24
+#define BM_PINCTRL_DRIVE4_BANK1_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE4_BANK1_PIN06_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE4_BANK1_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE4_BANK1_PIN05_MA	20
+#define BM_PINCTRL_DRIVE4_BANK1_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE4_BANK1_PIN05_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE4_BANK1_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE4_BANK1_PIN04_MA	16
+#define BM_PINCTRL_DRIVE4_BANK1_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE4_BANK1_PIN04_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE4_BANK1_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE4_BANK1_PIN03_MA	12
+#define BM_PINCTRL_DRIVE4_BANK1_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE4_BANK1_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE4_BANK1_PIN03_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE4_BANK1_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE4_BANK1_PIN02_MA	8
+#define BM_PINCTRL_DRIVE4_BANK1_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE4_BANK1_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE4_BANK1_PIN02_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE4_BANK1_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE4_BANK1_PIN01_MA	4
+#define BM_PINCTRL_DRIVE4_BANK1_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE4_BANK1_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE4_BANK1_PIN01_MA)
+#define BM_PINCTRL_DRIVE4_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE4_BANK1_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE4_BANK1_PIN00_MA	0
+#define BM_PINCTRL_DRIVE4_BANK1_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE4_BANK1_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE4_BANK1_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE5	(0x00000350)
+#define HW_PINCTRL_DRIVE5_SET	(0x00000354)
+#define HW_PINCTRL_DRIVE5_CLR	(0x00000358)
+#define HW_PINCTRL_DRIVE5_TOG	(0x0000035c)
+
+#define BM_PINCTRL_DRIVE5_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE5_BANK1_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE5_BANK1_PIN15_MA	28
+#define BM_PINCTRL_DRIVE5_BANK1_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE5_BANK1_PIN15_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE5_BANK1_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE5_BANK1_PIN14_MA	24
+#define BM_PINCTRL_DRIVE5_BANK1_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE5_BANK1_PIN14_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE5_BANK1_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE5_BANK1_PIN13_MA	20
+#define BM_PINCTRL_DRIVE5_BANK1_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE5_BANK1_PIN13_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE5_BANK1_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE5_BANK1_PIN12_MA	16
+#define BM_PINCTRL_DRIVE5_BANK1_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE5_BANK1_PIN12_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE5_BANK1_PIN11_V	0x00004000
+#define BP_PINCTRL_DRIVE5_BANK1_PIN11_MA	12
+#define BM_PINCTRL_DRIVE5_BANK1_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE5_BANK1_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE5_BANK1_PIN11_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE5_BANK1_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE5_BANK1_PIN10_MA	8
+#define BM_PINCTRL_DRIVE5_BANK1_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE5_BANK1_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE5_BANK1_PIN10_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE5_BANK1_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE5_BANK1_PIN09_MA	4
+#define BM_PINCTRL_DRIVE5_BANK1_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE5_BANK1_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE5_BANK1_PIN09_MA)
+#define BM_PINCTRL_DRIVE5_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE5_BANK1_PIN08_V	0x00000004
+#define BP_PINCTRL_DRIVE5_BANK1_PIN08_MA	0
+#define BM_PINCTRL_DRIVE5_BANK1_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE5_BANK1_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE5_BANK1_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE6	(0x00000360)
+#define HW_PINCTRL_DRIVE6_SET	(0x00000364)
+#define HW_PINCTRL_DRIVE6_CLR	(0x00000368)
+#define HW_PINCTRL_DRIVE6_TOG	(0x0000036c)
+
+#define BM_PINCTRL_DRIVE6_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE6_BANK1_PIN23_V	0x40000000
+#define BP_PINCTRL_DRIVE6_BANK1_PIN23_MA	28
+#define BM_PINCTRL_DRIVE6_BANK1_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE6_BANK1_PIN23_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE6_BANK1_PIN22_V	0x04000000
+#define BP_PINCTRL_DRIVE6_BANK1_PIN22_MA	24
+#define BM_PINCTRL_DRIVE6_BANK1_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE6_BANK1_PIN22_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE6_BANK1_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE6_BANK1_PIN21_MA	20
+#define BM_PINCTRL_DRIVE6_BANK1_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE6_BANK1_PIN21_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE6_BANK1_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE6_BANK1_PIN20_MA	16
+#define BM_PINCTRL_DRIVE6_BANK1_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE6_BANK1_PIN20_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE6_BANK1_PIN19_V	0x00004000
+#define BP_PINCTRL_DRIVE6_BANK1_PIN19_MA	12
+#define BM_PINCTRL_DRIVE6_BANK1_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE6_BANK1_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE6_BANK1_PIN19_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE6_BANK1_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE6_BANK1_PIN18_MA	8
+#define BM_PINCTRL_DRIVE6_BANK1_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE6_BANK1_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE6_BANK1_PIN18_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE6_BANK1_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE6_BANK1_PIN17_MA	4
+#define BM_PINCTRL_DRIVE6_BANK1_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE6_BANK1_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE6_BANK1_PIN17_MA)
+#define BM_PINCTRL_DRIVE6_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE6_BANK1_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE6_BANK1_PIN16_MA	0
+#define BM_PINCTRL_DRIVE6_BANK1_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE6_BANK1_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE6_BANK1_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE7	(0x00000370)
+#define HW_PINCTRL_DRIVE7_SET	(0x00000374)
+#define HW_PINCTRL_DRIVE7_CLR	(0x00000378)
+#define HW_PINCTRL_DRIVE7_TOG	(0x0000037c)
+
+#define BM_PINCTRL_DRIVE7_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE7_BANK1_PIN31_V	0x40000000
+#define BP_PINCTRL_DRIVE7_BANK1_PIN31_MA	28
+#define BM_PINCTRL_DRIVE7_BANK1_PIN31_MA	0x30000000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN31_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE7_BANK1_PIN31_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE7_BANK1_PIN30_V	0x04000000
+#define BP_PINCTRL_DRIVE7_BANK1_PIN30_MA	24
+#define BM_PINCTRL_DRIVE7_BANK1_PIN30_MA	0x03000000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN30_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE7_BANK1_PIN30_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE7_BANK1_PIN29_V	0x00400000
+#define BP_PINCTRL_DRIVE7_BANK1_PIN29_MA	20
+#define BM_PINCTRL_DRIVE7_BANK1_PIN29_MA	0x00300000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN29_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE7_BANK1_PIN29_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE7_BANK1_PIN28_V	0x00040000
+#define BP_PINCTRL_DRIVE7_BANK1_PIN28_MA	16
+#define BM_PINCTRL_DRIVE7_BANK1_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE7_BANK1_PIN28_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE7_BANK1_PIN27_V	0x00004000
+#define BP_PINCTRL_DRIVE7_BANK1_PIN27_MA	12
+#define BM_PINCTRL_DRIVE7_BANK1_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE7_BANK1_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE7_BANK1_PIN27_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE7_BANK1_PIN26_V	0x00000400
+#define BP_PINCTRL_DRIVE7_BANK1_PIN26_MA	8
+#define BM_PINCTRL_DRIVE7_BANK1_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE7_BANK1_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE7_BANK1_PIN26_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE7_BANK1_PIN25_V	0x00000040
+#define BP_PINCTRL_DRIVE7_BANK1_PIN25_MA	4
+#define BM_PINCTRL_DRIVE7_BANK1_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE7_BANK1_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE7_BANK1_PIN25_MA)
+#define BM_PINCTRL_DRIVE7_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE7_BANK1_PIN24_V	0x00000004
+#define BP_PINCTRL_DRIVE7_BANK1_PIN24_MA	0
+#define BM_PINCTRL_DRIVE7_BANK1_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE7_BANK1_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE7_BANK1_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE8	(0x00000380)
+#define HW_PINCTRL_DRIVE8_SET	(0x00000384)
+#define HW_PINCTRL_DRIVE8_CLR	(0x00000388)
+#define HW_PINCTRL_DRIVE8_TOG	(0x0000038c)
+
+#define BM_PINCTRL_DRIVE8_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE8_BANK2_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE8_BANK2_PIN07_MA	28
+#define BM_PINCTRL_DRIVE8_BANK2_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE8_BANK2_PIN07_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE8_BANK2_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE8_BANK2_PIN06_MA	24
+#define BM_PINCTRL_DRIVE8_BANK2_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE8_BANK2_PIN06_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE8_BANK2_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE8_BANK2_PIN05_MA	20
+#define BM_PINCTRL_DRIVE8_BANK2_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE8_BANK2_PIN05_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE8_BANK2_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE8_BANK2_PIN04_MA	16
+#define BM_PINCTRL_DRIVE8_BANK2_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE8_BANK2_PIN04_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE8_BANK2_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE8_BANK2_PIN03_MA	12
+#define BM_PINCTRL_DRIVE8_BANK2_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE8_BANK2_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE8_BANK2_PIN03_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE8_BANK2_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE8_BANK2_PIN02_MA	8
+#define BM_PINCTRL_DRIVE8_BANK2_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE8_BANK2_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE8_BANK2_PIN02_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE8_BANK2_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE8_BANK2_PIN01_MA	4
+#define BM_PINCTRL_DRIVE8_BANK2_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE8_BANK2_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE8_BANK2_PIN01_MA)
+#define BM_PINCTRL_DRIVE8_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE8_BANK2_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE8_BANK2_PIN00_MA	0
+#define BM_PINCTRL_DRIVE8_BANK2_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE8_BANK2_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE8_BANK2_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE9	(0x00000390)
+#define HW_PINCTRL_DRIVE9_SET	(0x00000394)
+#define HW_PINCTRL_DRIVE9_CLR	(0x00000398)
+#define HW_PINCTRL_DRIVE9_TOG	(0x0000039c)
+
+#define BM_PINCTRL_DRIVE9_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN15_MA	28
+#define BM_PINCTRL_DRIVE9_BANK2_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE9_BANK2_PIN15_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN14_MA	24
+#define BM_PINCTRL_DRIVE9_BANK2_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE9_BANK2_PIN14_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN13_MA	20
+#define BM_PINCTRL_DRIVE9_BANK2_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE9_BANK2_PIN13_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE9_BANK2_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE9_BANK2_PIN12_MA	16
+#define BM_PINCTRL_DRIVE9_BANK2_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE9_BANK2_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE9_BANK2_PIN12_MA)
+#define BP_PINCTRL_DRIVE9_RSRVD3	12
+#define BM_PINCTRL_DRIVE9_RSRVD3	0x0000F000
+#define BF_PINCTRL_DRIVE9_RSRVD3(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE9_RSRVD3)
+#define BM_PINCTRL_DRIVE9_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE9_BANK2_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE9_BANK2_PIN10_MA	8
+#define BM_PINCTRL_DRIVE9_BANK2_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE9_BANK2_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE9_BANK2_PIN10_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE9_BANK2_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE9_BANK2_PIN09_MA	4
+#define BM_PINCTRL_DRIVE9_BANK2_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE9_BANK2_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE9_BANK2_PIN09_MA)
+#define BM_PINCTRL_DRIVE9_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE9_BANK2_PIN08_V	0x00000004
+#define BP_PINCTRL_DRIVE9_BANK2_PIN08_MA	0
+#define BM_PINCTRL_DRIVE9_BANK2_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE9_BANK2_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE9_BANK2_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE10	(0x000003a0)
+#define HW_PINCTRL_DRIVE10_SET	(0x000003a4)
+#define HW_PINCTRL_DRIVE10_CLR	(0x000003a8)
+#define HW_PINCTRL_DRIVE10_TOG	(0x000003ac)
+
+#define BP_PINCTRL_DRIVE10_RSRVD6	24
+#define BM_PINCTRL_DRIVE10_RSRVD6	0xFF000000
+#define BF_PINCTRL_DRIVE10_RSRVD6(v) \
+		(((v) << 24) & BM_PINCTRL_DRIVE10_RSRVD6)
+#define BM_PINCTRL_DRIVE10_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN21_MA	20
+#define BM_PINCTRL_DRIVE10_BANK2_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE10_BANK2_PIN21_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN20_MA	16
+#define BM_PINCTRL_DRIVE10_BANK2_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE10_BANK2_PIN20_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE10_BANK2_PIN19_V	0x00004000
+#define BP_PINCTRL_DRIVE10_BANK2_PIN19_MA	12
+#define BM_PINCTRL_DRIVE10_BANK2_PIN19_MA	0x00003000
+#define BF_PINCTRL_DRIVE10_BANK2_PIN19_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE10_BANK2_PIN19_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE10_BANK2_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE10_BANK2_PIN18_MA	8
+#define BM_PINCTRL_DRIVE10_BANK2_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE10_BANK2_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE10_BANK2_PIN18_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE10_BANK2_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE10_BANK2_PIN17_MA	4
+#define BM_PINCTRL_DRIVE10_BANK2_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE10_BANK2_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE10_BANK2_PIN17_MA)
+#define BM_PINCTRL_DRIVE10_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE10_BANK2_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE10_BANK2_PIN16_MA	0
+#define BM_PINCTRL_DRIVE10_BANK2_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE10_BANK2_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE10_BANK2_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE11	(0x000003b0)
+#define HW_PINCTRL_DRIVE11_SET	(0x000003b4)
+#define HW_PINCTRL_DRIVE11_CLR	(0x000003b8)
+#define HW_PINCTRL_DRIVE11_TOG	(0x000003bc)
+
+#define BP_PINCTRL_DRIVE11_RSRVD4	16
+#define BM_PINCTRL_DRIVE11_RSRVD4	0xFFFF0000
+#define BF_PINCTRL_DRIVE11_RSRVD4(v) \
+		(((v) << 16) & BM_PINCTRL_DRIVE11_RSRVD4)
+#define BM_PINCTRL_DRIVE11_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE11_BANK2_PIN27_V	0x00004000
+#define BP_PINCTRL_DRIVE11_BANK2_PIN27_MA	12
+#define BM_PINCTRL_DRIVE11_BANK2_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE11_BANK2_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE11_BANK2_PIN27_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE11_BANK2_PIN26_V	0x00000400
+#define BP_PINCTRL_DRIVE11_BANK2_PIN26_MA	8
+#define BM_PINCTRL_DRIVE11_BANK2_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE11_BANK2_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE11_BANK2_PIN26_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE11_BANK2_PIN25_V	0x00000040
+#define BP_PINCTRL_DRIVE11_BANK2_PIN25_MA	4
+#define BM_PINCTRL_DRIVE11_BANK2_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE11_BANK2_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE11_BANK2_PIN25_MA)
+#define BM_PINCTRL_DRIVE11_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE11_BANK2_PIN24_V	0x00000004
+#define BP_PINCTRL_DRIVE11_BANK2_PIN24_MA	0
+#define BM_PINCTRL_DRIVE11_BANK2_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE11_BANK2_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE11_BANK2_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE12	(0x000003c0)
+#define HW_PINCTRL_DRIVE12_SET	(0x000003c4)
+#define HW_PINCTRL_DRIVE12_CLR	(0x000003c8)
+#define HW_PINCTRL_DRIVE12_TOG	(0x000003cc)
+
+#define BM_PINCTRL_DRIVE12_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN07_MA	28
+#define BM_PINCTRL_DRIVE12_BANK3_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE12_BANK3_PIN07_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN06_MA	24
+#define BM_PINCTRL_DRIVE12_BANK3_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE12_BANK3_PIN06_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN05_MA	20
+#define BM_PINCTRL_DRIVE12_BANK3_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE12_BANK3_PIN05_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN04_MA	16
+#define BM_PINCTRL_DRIVE12_BANK3_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE12_BANK3_PIN04_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE12_BANK3_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE12_BANK3_PIN03_MA	12
+#define BM_PINCTRL_DRIVE12_BANK3_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE12_BANK3_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE12_BANK3_PIN03_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE12_BANK3_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE12_BANK3_PIN02_MA	8
+#define BM_PINCTRL_DRIVE12_BANK3_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE12_BANK3_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE12_BANK3_PIN02_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE12_BANK3_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE12_BANK3_PIN01_MA	4
+#define BM_PINCTRL_DRIVE12_BANK3_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE12_BANK3_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE12_BANK3_PIN01_MA)
+#define BM_PINCTRL_DRIVE12_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE12_BANK3_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE12_BANK3_PIN00_MA	0
+#define BM_PINCTRL_DRIVE12_BANK3_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE12_BANK3_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE12_BANK3_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE13	(0x000003d0)
+#define HW_PINCTRL_DRIVE13_SET	(0x000003d4)
+#define HW_PINCTRL_DRIVE13_CLR	(0x000003d8)
+#define HW_PINCTRL_DRIVE13_TOG	(0x000003dc)
+
+#define BM_PINCTRL_DRIVE13_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN15_MA	28
+#define BM_PINCTRL_DRIVE13_BANK3_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE13_BANK3_PIN15_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN14_MA	24
+#define BM_PINCTRL_DRIVE13_BANK3_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE13_BANK3_PIN14_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN13_MA	20
+#define BM_PINCTRL_DRIVE13_BANK3_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE13_BANK3_PIN13_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN12_MA	16
+#define BM_PINCTRL_DRIVE13_BANK3_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE13_BANK3_PIN12_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE13_BANK3_PIN11_V	0x00004000
+#define BP_PINCTRL_DRIVE13_BANK3_PIN11_MA	12
+#define BM_PINCTRL_DRIVE13_BANK3_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE13_BANK3_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE13_BANK3_PIN11_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE13_BANK3_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE13_BANK3_PIN10_MA	8
+#define BM_PINCTRL_DRIVE13_BANK3_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE13_BANK3_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE13_BANK3_PIN10_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE13_BANK3_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE13_BANK3_PIN09_MA	4
+#define BM_PINCTRL_DRIVE13_BANK3_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE13_BANK3_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE13_BANK3_PIN09_MA)
+#define BM_PINCTRL_DRIVE13_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE13_BANK3_PIN08_V	0x00000004
+#define BP_PINCTRL_DRIVE13_BANK3_PIN08_MA	0
+#define BM_PINCTRL_DRIVE13_BANK3_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE13_BANK3_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE13_BANK3_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE14	(0x000003e0)
+#define HW_PINCTRL_DRIVE14_SET	(0x000003e4)
+#define HW_PINCTRL_DRIVE14_CLR	(0x000003e8)
+#define HW_PINCTRL_DRIVE14_TOG	(0x000003ec)
+
+#define BM_PINCTRL_DRIVE14_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN23_V	0x40000000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN23_MA	28
+#define BM_PINCTRL_DRIVE14_BANK3_PIN23_MA	0x30000000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN23_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE14_BANK3_PIN23_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN22_V	0x04000000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN22_MA	24
+#define BM_PINCTRL_DRIVE14_BANK3_PIN22_MA	0x03000000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN22_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE14_BANK3_PIN22_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN21_V	0x00400000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN21_MA	20
+#define BM_PINCTRL_DRIVE14_BANK3_PIN21_MA	0x00300000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN21_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE14_BANK3_PIN21_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE14_BANK3_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE14_BANK3_PIN20_MA	16
+#define BM_PINCTRL_DRIVE14_BANK3_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE14_BANK3_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE14_BANK3_PIN20_MA)
+#define BP_PINCTRL_DRIVE14_RSRVD3	12
+#define BM_PINCTRL_DRIVE14_RSRVD3	0x0000F000
+#define BF_PINCTRL_DRIVE14_RSRVD3(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE14_RSRVD3)
+#define BM_PINCTRL_DRIVE14_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE14_BANK3_PIN18_V	0x00000400
+#define BP_PINCTRL_DRIVE14_BANK3_PIN18_MA	8
+#define BM_PINCTRL_DRIVE14_BANK3_PIN18_MA	0x00000300
+#define BF_PINCTRL_DRIVE14_BANK3_PIN18_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE14_BANK3_PIN18_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE14_BANK3_PIN17_V	0x00000040
+#define BP_PINCTRL_DRIVE14_BANK3_PIN17_MA	4
+#define BM_PINCTRL_DRIVE14_BANK3_PIN17_MA	0x00000030
+#define BF_PINCTRL_DRIVE14_BANK3_PIN17_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE14_BANK3_PIN17_MA)
+#define BM_PINCTRL_DRIVE14_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE14_BANK3_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE14_BANK3_PIN16_MA	0
+#define BM_PINCTRL_DRIVE14_BANK3_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE14_BANK3_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE14_BANK3_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE15	(0x000003f0)
+#define HW_PINCTRL_DRIVE15_SET	(0x000003f4)
+#define HW_PINCTRL_DRIVE15_CLR	(0x000003f8)
+#define HW_PINCTRL_DRIVE15_TOG	(0x000003fc)
+
+#define BP_PINCTRL_DRIVE15_RSRVD7	28
+#define BM_PINCTRL_DRIVE15_RSRVD7	0xF0000000
+#define BF_PINCTRL_DRIVE15_RSRVD7(v) \
+		(((v) << 28) & BM_PINCTRL_DRIVE15_RSRVD7)
+#define BM_PINCTRL_DRIVE15_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE15_BANK3_PIN30_V	0x04000000
+#define BP_PINCTRL_DRIVE15_BANK3_PIN30_MA	24
+#define BM_PINCTRL_DRIVE15_BANK3_PIN30_MA	0x03000000
+#define BF_PINCTRL_DRIVE15_BANK3_PIN30_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE15_BANK3_PIN30_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE15_BANK3_PIN29_V	0x00400000
+#define BP_PINCTRL_DRIVE15_BANK3_PIN29_MA	20
+#define BM_PINCTRL_DRIVE15_BANK3_PIN29_MA	0x00300000
+#define BF_PINCTRL_DRIVE15_BANK3_PIN29_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE15_BANK3_PIN29_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE15_BANK3_PIN28_V	0x00040000
+#define BP_PINCTRL_DRIVE15_BANK3_PIN28_MA	16
+#define BM_PINCTRL_DRIVE15_BANK3_PIN28_MA	0x00030000
+#define BF_PINCTRL_DRIVE15_BANK3_PIN28_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE15_BANK3_PIN28_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE15_BANK3_PIN27_V	0x00004000
+#define BP_PINCTRL_DRIVE15_BANK3_PIN27_MA	12
+#define BM_PINCTRL_DRIVE15_BANK3_PIN27_MA	0x00003000
+#define BF_PINCTRL_DRIVE15_BANK3_PIN27_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE15_BANK3_PIN27_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE15_BANK3_PIN26_V	0x00000400
+#define BP_PINCTRL_DRIVE15_BANK3_PIN26_MA	8
+#define BM_PINCTRL_DRIVE15_BANK3_PIN26_MA	0x00000300
+#define BF_PINCTRL_DRIVE15_BANK3_PIN26_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE15_BANK3_PIN26_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE15_BANK3_PIN25_V	0x00000040
+#define BP_PINCTRL_DRIVE15_BANK3_PIN25_MA	4
+#define BM_PINCTRL_DRIVE15_BANK3_PIN25_MA	0x00000030
+#define BF_PINCTRL_DRIVE15_BANK3_PIN25_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE15_BANK3_PIN25_MA)
+#define BM_PINCTRL_DRIVE15_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE15_BANK3_PIN24_V	0x00000004
+#define BP_PINCTRL_DRIVE15_BANK3_PIN24_MA	0
+#define BM_PINCTRL_DRIVE15_BANK3_PIN24_MA	0x00000003
+#define BF_PINCTRL_DRIVE15_BANK3_PIN24_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE15_BANK3_PIN24_MA)
+
+#define HW_PINCTRL_DRIVE16	(0x00000400)
+#define HW_PINCTRL_DRIVE16_SET	(0x00000404)
+#define HW_PINCTRL_DRIVE16_CLR	(0x00000408)
+#define HW_PINCTRL_DRIVE16_TOG	(0x0000040c)
+
+#define BM_PINCTRL_DRIVE16_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE16_BANK4_PIN07_V	0x40000000
+#define BP_PINCTRL_DRIVE16_BANK4_PIN07_MA	28
+#define BM_PINCTRL_DRIVE16_BANK4_PIN07_MA	0x30000000
+#define BF_PINCTRL_DRIVE16_BANK4_PIN07_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE16_BANK4_PIN07_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE16_BANK4_PIN06_V	0x04000000
+#define BP_PINCTRL_DRIVE16_BANK4_PIN06_MA	24
+#define BM_PINCTRL_DRIVE16_BANK4_PIN06_MA	0x03000000
+#define BF_PINCTRL_DRIVE16_BANK4_PIN06_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE16_BANK4_PIN06_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE16_BANK4_PIN05_V	0x00400000
+#define BP_PINCTRL_DRIVE16_BANK4_PIN05_MA	20
+#define BM_PINCTRL_DRIVE16_BANK4_PIN05_MA	0x00300000
+#define BF_PINCTRL_DRIVE16_BANK4_PIN05_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE16_BANK4_PIN05_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE16_BANK4_PIN04_V	0x00040000
+#define BP_PINCTRL_DRIVE16_BANK4_PIN04_MA	16
+#define BM_PINCTRL_DRIVE16_BANK4_PIN04_MA	0x00030000
+#define BF_PINCTRL_DRIVE16_BANK4_PIN04_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE16_BANK4_PIN04_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE16_BANK4_PIN03_V	0x00004000
+#define BP_PINCTRL_DRIVE16_BANK4_PIN03_MA	12
+#define BM_PINCTRL_DRIVE16_BANK4_PIN03_MA	0x00003000
+#define BF_PINCTRL_DRIVE16_BANK4_PIN03_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE16_BANK4_PIN03_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE16_BANK4_PIN02_V	0x00000400
+#define BP_PINCTRL_DRIVE16_BANK4_PIN02_MA	8
+#define BM_PINCTRL_DRIVE16_BANK4_PIN02_MA	0x00000300
+#define BF_PINCTRL_DRIVE16_BANK4_PIN02_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE16_BANK4_PIN02_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE16_BANK4_PIN01_V	0x00000040
+#define BP_PINCTRL_DRIVE16_BANK4_PIN01_MA	4
+#define BM_PINCTRL_DRIVE16_BANK4_PIN01_MA	0x00000030
+#define BF_PINCTRL_DRIVE16_BANK4_PIN01_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE16_BANK4_PIN01_MA)
+#define BM_PINCTRL_DRIVE16_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE16_BANK4_PIN00_V	0x00000004
+#define BP_PINCTRL_DRIVE16_BANK4_PIN00_MA	0
+#define BM_PINCTRL_DRIVE16_BANK4_PIN00_MA	0x00000003
+#define BF_PINCTRL_DRIVE16_BANK4_PIN00_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE16_BANK4_PIN00_MA)
+
+#define HW_PINCTRL_DRIVE17	(0x00000410)
+#define HW_PINCTRL_DRIVE17_SET	(0x00000414)
+#define HW_PINCTRL_DRIVE17_CLR	(0x00000418)
+#define HW_PINCTRL_DRIVE17_TOG	(0x0000041c)
+
+#define BM_PINCTRL_DRIVE17_RSRVD7	0x80000000
+#define BM_PINCTRL_DRIVE17_BANK4_PIN15_V	0x40000000
+#define BP_PINCTRL_DRIVE17_BANK4_PIN15_MA	28
+#define BM_PINCTRL_DRIVE17_BANK4_PIN15_MA	0x30000000
+#define BF_PINCTRL_DRIVE17_BANK4_PIN15_MA(v)  \
+		(((v) << 28) & BM_PINCTRL_DRIVE17_BANK4_PIN15_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD6	0x08000000
+#define BM_PINCTRL_DRIVE17_BANK4_PIN14_V	0x04000000
+#define BP_PINCTRL_DRIVE17_BANK4_PIN14_MA	24
+#define BM_PINCTRL_DRIVE17_BANK4_PIN14_MA	0x03000000
+#define BF_PINCTRL_DRIVE17_BANK4_PIN14_MA(v)  \
+		(((v) << 24) & BM_PINCTRL_DRIVE17_BANK4_PIN14_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD5	0x00800000
+#define BM_PINCTRL_DRIVE17_BANK4_PIN13_V	0x00400000
+#define BP_PINCTRL_DRIVE17_BANK4_PIN13_MA	20
+#define BM_PINCTRL_DRIVE17_BANK4_PIN13_MA	0x00300000
+#define BF_PINCTRL_DRIVE17_BANK4_PIN13_MA(v)  \
+		(((v) << 20) & BM_PINCTRL_DRIVE17_BANK4_PIN13_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD4	0x00080000
+#define BM_PINCTRL_DRIVE17_BANK4_PIN12_V	0x00040000
+#define BP_PINCTRL_DRIVE17_BANK4_PIN12_MA	16
+#define BM_PINCTRL_DRIVE17_BANK4_PIN12_MA	0x00030000
+#define BF_PINCTRL_DRIVE17_BANK4_PIN12_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE17_BANK4_PIN12_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD3	0x00008000
+#define BM_PINCTRL_DRIVE17_BANK4_PIN11_V	0x00004000
+#define BP_PINCTRL_DRIVE17_BANK4_PIN11_MA	12
+#define BM_PINCTRL_DRIVE17_BANK4_PIN11_MA	0x00003000
+#define BF_PINCTRL_DRIVE17_BANK4_PIN11_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_DRIVE17_BANK4_PIN11_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD2	0x00000800
+#define BM_PINCTRL_DRIVE17_BANK4_PIN10_V	0x00000400
+#define BP_PINCTRL_DRIVE17_BANK4_PIN10_MA	8
+#define BM_PINCTRL_DRIVE17_BANK4_PIN10_MA	0x00000300
+#define BF_PINCTRL_DRIVE17_BANK4_PIN10_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_DRIVE17_BANK4_PIN10_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD1	0x00000080
+#define BM_PINCTRL_DRIVE17_BANK4_PIN09_V	0x00000040
+#define BP_PINCTRL_DRIVE17_BANK4_PIN09_MA	4
+#define BM_PINCTRL_DRIVE17_BANK4_PIN09_MA	0x00000030
+#define BF_PINCTRL_DRIVE17_BANK4_PIN09_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE17_BANK4_PIN09_MA)
+#define BM_PINCTRL_DRIVE17_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE17_BANK4_PIN08_V	0x00000004
+#define BP_PINCTRL_DRIVE17_BANK4_PIN08_MA	0
+#define BM_PINCTRL_DRIVE17_BANK4_PIN08_MA	0x00000003
+#define BF_PINCTRL_DRIVE17_BANK4_PIN08_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE17_BANK4_PIN08_MA)
+
+#define HW_PINCTRL_DRIVE18	(0x00000420)
+#define HW_PINCTRL_DRIVE18_SET	(0x00000424)
+#define HW_PINCTRL_DRIVE18_CLR	(0x00000428)
+#define HW_PINCTRL_DRIVE18_TOG	(0x0000042c)
+
+#define BP_PINCTRL_DRIVE18_RSRVD3	20
+#define BM_PINCTRL_DRIVE18_RSRVD3	0xFFF00000
+#define BF_PINCTRL_DRIVE18_RSRVD3(v) \
+		(((v) << 20) & BM_PINCTRL_DRIVE18_RSRVD3)
+#define BM_PINCTRL_DRIVE18_RSRVD2	0x00080000
+#define BM_PINCTRL_DRIVE18_BANK4_PIN20_V	0x00040000
+#define BP_PINCTRL_DRIVE18_BANK4_PIN20_MA	16
+#define BM_PINCTRL_DRIVE18_BANK4_PIN20_MA	0x00030000
+#define BF_PINCTRL_DRIVE18_BANK4_PIN20_MA(v)  \
+		(((v) << 16) & BM_PINCTRL_DRIVE18_BANK4_PIN20_MA)
+#define BP_PINCTRL_DRIVE18_RSRVD1	4
+#define BM_PINCTRL_DRIVE18_RSRVD1	0x0000FFF0
+#define BF_PINCTRL_DRIVE18_RSRVD1(v)  \
+		(((v) << 4) & BM_PINCTRL_DRIVE18_RSRVD1)
+#define BM_PINCTRL_DRIVE18_RSRVD0	0x00000008
+#define BM_PINCTRL_DRIVE18_BANK4_PIN16_V	0x00000004
+#define BP_PINCTRL_DRIVE18_BANK4_PIN16_MA	0
+#define BM_PINCTRL_DRIVE18_BANK4_PIN16_MA	0x00000003
+#define BF_PINCTRL_DRIVE18_BANK4_PIN16_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_DRIVE18_BANK4_PIN16_MA)
+
+#define HW_PINCTRL_DRIVE19	(0x00000430)
+#define HW_PINCTRL_DRIVE19_SET	(0x00000434)
+#define HW_PINCTRL_DRIVE19_CLR	(0x00000438)
+#define HW_PINCTRL_DRIVE19_TOG	(0x0000043c)
+
+#define BP_PINCTRL_DRIVE19_RSRVD0	0
+#define BM_PINCTRL_DRIVE19_RSRVD0	0xFFFFFFFF
+#define BF_PINCTRL_DRIVE19_RSRVD0(v)	(v)
+
+#define HW_PINCTRL_PULL0	(0x00000600)
+#define HW_PINCTRL_PULL0_SET	(0x00000604)
+#define HW_PINCTRL_PULL0_CLR	(0x00000608)
+#define HW_PINCTRL_PULL0_TOG	(0x0000060c)
+
+#define BP_PINCTRL_PULL0_RSRVD1	29
+#define BM_PINCTRL_PULL0_RSRVD1	0xE0000000
+#define BF_PINCTRL_PULL0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_PULL0_RSRVD1)
+#define BM_PINCTRL_PULL0_BANK0_PIN28	0x10000000
+#define BM_PINCTRL_PULL0_BANK0_PIN27	0x08000000
+#define BM_PINCTRL_PULL0_BANK0_PIN26	0x04000000
+#define BM_PINCTRL_PULL0_BANK0_PIN25	0x02000000
+#define BM_PINCTRL_PULL0_BANK0_PIN24	0x01000000
+#define BM_PINCTRL_PULL0_BANK0_PIN23	0x00800000
+#define BM_PINCTRL_PULL0_BANK0_PIN22	0x00400000
+#define BM_PINCTRL_PULL0_BANK0_PIN21	0x00200000
+#define BM_PINCTRL_PULL0_BANK0_PIN20	0x00100000
+#define BM_PINCTRL_PULL0_BANK0_PIN19	0x00080000
+#define BM_PINCTRL_PULL0_BANK0_PIN18	0x00040000
+#define BM_PINCTRL_PULL0_BANK0_PIN17	0x00020000
+#define BM_PINCTRL_PULL0_BANK0_PIN16	0x00010000
+#define BP_PINCTRL_PULL0_RSRVD0	8
+#define BM_PINCTRL_PULL0_RSRVD0	0x0000FF00
+#define BF_PINCTRL_PULL0_RSRVD0(v)  \
+		(((v) << 8) & BM_PINCTRL_PULL0_RSRVD0)
+#define BM_PINCTRL_PULL0_BANK0_PIN07	0x00000080
+#define BM_PINCTRL_PULL0_BANK0_PIN06	0x00000040
+#define BM_PINCTRL_PULL0_BANK0_PIN05	0x00000020
+#define BM_PINCTRL_PULL0_BANK0_PIN04	0x00000010
+#define BM_PINCTRL_PULL0_BANK0_PIN03	0x00000008
+#define BM_PINCTRL_PULL0_BANK0_PIN02	0x00000004
+#define BM_PINCTRL_PULL0_BANK0_PIN01	0x00000002
+#define BM_PINCTRL_PULL0_BANK0_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL1	(0x00000610)
+#define HW_PINCTRL_PULL1_SET	(0x00000614)
+#define HW_PINCTRL_PULL1_CLR	(0x00000618)
+#define HW_PINCTRL_PULL1_TOG	(0x0000061c)
+
+#define BM_PINCTRL_PULL1_BANK1_PIN31	0x80000000
+#define BM_PINCTRL_PULL1_BANK1_PIN30	0x40000000
+#define BM_PINCTRL_PULL1_BANK1_PIN29	0x20000000
+#define BM_PINCTRL_PULL1_BANK1_PIN28	0x10000000
+#define BM_PINCTRL_PULL1_BANK1_PIN27	0x08000000
+#define BM_PINCTRL_PULL1_BANK1_PIN26	0x04000000
+#define BM_PINCTRL_PULL1_BANK1_PIN25	0x02000000
+#define BM_PINCTRL_PULL1_BANK1_PIN24	0x01000000
+#define BM_PINCTRL_PULL1_BANK1_PIN23	0x00800000
+#define BM_PINCTRL_PULL1_BANK1_PIN22	0x00400000
+#define BM_PINCTRL_PULL1_BANK1_PIN21	0x00200000
+#define BM_PINCTRL_PULL1_BANK1_PIN20	0x00100000
+#define BM_PINCTRL_PULL1_BANK1_PIN19	0x00080000
+#define BM_PINCTRL_PULL1_BANK1_PIN18	0x00040000
+#define BM_PINCTRL_PULL1_BANK1_PIN17	0x00020000
+#define BM_PINCTRL_PULL1_BANK1_PIN16	0x00010000
+#define BM_PINCTRL_PULL1_BANK1_PIN15	0x00008000
+#define BM_PINCTRL_PULL1_BANK1_PIN14	0x00004000
+#define BM_PINCTRL_PULL1_BANK1_PIN13	0x00002000
+#define BM_PINCTRL_PULL1_BANK1_PIN12	0x00001000
+#define BM_PINCTRL_PULL1_BANK1_PIN11	0x00000800
+#define BM_PINCTRL_PULL1_BANK1_PIN10	0x00000400
+#define BM_PINCTRL_PULL1_BANK1_PIN09	0x00000200
+#define BM_PINCTRL_PULL1_BANK1_PIN08	0x00000100
+#define BM_PINCTRL_PULL1_BANK1_PIN07	0x00000080
+#define BM_PINCTRL_PULL1_BANK1_PIN06	0x00000040
+#define BM_PINCTRL_PULL1_BANK1_PIN05	0x00000020
+#define BM_PINCTRL_PULL1_BANK1_PIN04	0x00000010
+#define BM_PINCTRL_PULL1_BANK1_PIN03	0x00000008
+#define BM_PINCTRL_PULL1_BANK1_PIN02	0x00000004
+#define BM_PINCTRL_PULL1_BANK1_PIN01	0x00000002
+#define BM_PINCTRL_PULL1_BANK1_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL2	(0x00000620)
+#define HW_PINCTRL_PULL2_SET	(0x00000624)
+#define HW_PINCTRL_PULL2_CLR	(0x00000628)
+#define HW_PINCTRL_PULL2_TOG	(0x0000062c)
+
+#define BP_PINCTRL_PULL2_RSRVD2	28
+#define BM_PINCTRL_PULL2_RSRVD2	0xF0000000
+#define BF_PINCTRL_PULL2_RSRVD2(v) \
+		(((v) << 28) & BM_PINCTRL_PULL2_RSRVD2)
+#define BM_PINCTRL_PULL2_BANK2_PIN27	0x08000000
+#define BM_PINCTRL_PULL2_BANK2_PIN26	0x04000000
+#define BM_PINCTRL_PULL2_BANK2_PIN25	0x02000000
+#define BM_PINCTRL_PULL2_BANK2_PIN24	0x01000000
+#define BP_PINCTRL_PULL2_RSRVD1	22
+#define BM_PINCTRL_PULL2_RSRVD1	0x00C00000
+#define BF_PINCTRL_PULL2_RSRVD1(v)  \
+		(((v) << 22) & BM_PINCTRL_PULL2_RSRVD1)
+#define BM_PINCTRL_PULL2_BANK2_PIN21	0x00200000
+#define BM_PINCTRL_PULL2_BANK2_PIN20	0x00100000
+#define BM_PINCTRL_PULL2_BANK2_PIN19	0x00080000
+#define BM_PINCTRL_PULL2_BANK2_PIN18	0x00040000
+#define BM_PINCTRL_PULL2_BANK2_PIN17	0x00020000
+#define BM_PINCTRL_PULL2_BANK2_PIN16	0x00010000
+#define BM_PINCTRL_PULL2_BANK2_PIN15	0x00008000
+#define BM_PINCTRL_PULL2_BANK2_PIN14	0x00004000
+#define BM_PINCTRL_PULL2_BANK2_PIN13	0x00002000
+#define BM_PINCTRL_PULL2_BANK2_PIN12	0x00001000
+#define BM_PINCTRL_PULL2_RSRVD0	0x00000800
+#define BM_PINCTRL_PULL2_BANK2_PIN10	0x00000400
+#define BM_PINCTRL_PULL2_BANK2_PIN09	0x00000200
+#define BM_PINCTRL_PULL2_BANK2_PIN08	0x00000100
+#define BM_PINCTRL_PULL2_BANK2_PIN07	0x00000080
+#define BM_PINCTRL_PULL2_BANK2_PIN06	0x00000040
+#define BM_PINCTRL_PULL2_BANK2_PIN05	0x00000020
+#define BM_PINCTRL_PULL2_BANK2_PIN04	0x00000010
+#define BM_PINCTRL_PULL2_BANK2_PIN03	0x00000008
+#define BM_PINCTRL_PULL2_BANK2_PIN02	0x00000004
+#define BM_PINCTRL_PULL2_BANK2_PIN01	0x00000002
+#define BM_PINCTRL_PULL2_BANK2_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL3	(0x00000630)
+#define HW_PINCTRL_PULL3_SET	(0x00000634)
+#define HW_PINCTRL_PULL3_CLR	(0x00000638)
+#define HW_PINCTRL_PULL3_TOG	(0x0000063c)
+
+#define BM_PINCTRL_PULL3_RSRVD1	0x80000000
+#define BM_PINCTRL_PULL3_BANK3_PIN30	0x40000000
+#define BM_PINCTRL_PULL3_BANK3_PIN29	0x20000000
+#define BM_PINCTRL_PULL3_BANK3_PIN28	0x10000000
+#define BM_PINCTRL_PULL3_BANK3_PIN27	0x08000000
+#define BM_PINCTRL_PULL3_BANK3_PIN26	0x04000000
+#define BM_PINCTRL_PULL3_BANK3_PIN25	0x02000000
+#define BM_PINCTRL_PULL3_BANK3_PIN24	0x01000000
+#define BM_PINCTRL_PULL3_BANK3_PIN23	0x00800000
+#define BM_PINCTRL_PULL3_BANK3_PIN22	0x00400000
+#define BM_PINCTRL_PULL3_BANK3_PIN21	0x00200000
+#define BM_PINCTRL_PULL3_BANK3_PIN20	0x00100000
+#define BM_PINCTRL_PULL3_RSRVD0	0x00080000
+#define BM_PINCTRL_PULL3_BANK3_PIN18	0x00040000
+#define BM_PINCTRL_PULL3_BANK3_PIN17	0x00020000
+#define BM_PINCTRL_PULL3_BANK3_PIN16	0x00010000
+#define BM_PINCTRL_PULL3_BANK3_PIN15	0x00008000
+#define BM_PINCTRL_PULL3_BANK3_PIN14	0x00004000
+#define BM_PINCTRL_PULL3_BANK3_PIN13	0x00002000
+#define BM_PINCTRL_PULL3_BANK3_PIN12	0x00001000
+#define BM_PINCTRL_PULL3_BANK3_PIN11	0x00000800
+#define BM_PINCTRL_PULL3_BANK3_PIN10	0x00000400
+#define BM_PINCTRL_PULL3_BANK3_PIN09	0x00000200
+#define BM_PINCTRL_PULL3_BANK3_PIN08	0x00000100
+#define BM_PINCTRL_PULL3_BANK3_PIN07	0x00000080
+#define BM_PINCTRL_PULL3_BANK3_PIN06	0x00000040
+#define BM_PINCTRL_PULL3_BANK3_PIN05	0x00000020
+#define BM_PINCTRL_PULL3_BANK3_PIN04	0x00000010
+#define BM_PINCTRL_PULL3_BANK3_PIN03	0x00000008
+#define BM_PINCTRL_PULL3_BANK3_PIN02	0x00000004
+#define BM_PINCTRL_PULL3_BANK3_PIN01	0x00000002
+#define BM_PINCTRL_PULL3_BANK3_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL4	(0x00000640)
+#define HW_PINCTRL_PULL4_SET	(0x00000644)
+#define HW_PINCTRL_PULL4_CLR	(0x00000648)
+#define HW_PINCTRL_PULL4_TOG	(0x0000064c)
+
+#define BP_PINCTRL_PULL4_RSRVD1	21
+#define BM_PINCTRL_PULL4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_PULL4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_PULL4_RSRVD1)
+#define BM_PINCTRL_PULL4_BANK4_PIN20	0x00100000
+#define BP_PINCTRL_PULL4_RSRVD0	17
+#define BM_PINCTRL_PULL4_RSRVD0	0x000E0000
+#define BF_PINCTRL_PULL4_RSRVD0(v)  \
+		(((v) << 17) & BM_PINCTRL_PULL4_RSRVD0)
+#define BM_PINCTRL_PULL4_BANK4_PIN16	0x00010000
+#define BM_PINCTRL_PULL4_BANK4_PIN15	0x00008000
+#define BM_PINCTRL_PULL4_BANK4_PIN14	0x00004000
+#define BM_PINCTRL_PULL4_BANK4_PIN13	0x00002000
+#define BM_PINCTRL_PULL4_BANK4_PIN12	0x00001000
+#define BM_PINCTRL_PULL4_BANK4_PIN11	0x00000800
+#define BM_PINCTRL_PULL4_BANK4_PIN10	0x00000400
+#define BM_PINCTRL_PULL4_BANK4_PIN09	0x00000200
+#define BM_PINCTRL_PULL4_BANK4_PIN08	0x00000100
+#define BM_PINCTRL_PULL4_BANK4_PIN07	0x00000080
+#define BM_PINCTRL_PULL4_BANK4_PIN06	0x00000040
+#define BM_PINCTRL_PULL4_BANK4_PIN05	0x00000020
+#define BM_PINCTRL_PULL4_BANK4_PIN04	0x00000010
+#define BM_PINCTRL_PULL4_BANK4_PIN03	0x00000008
+#define BM_PINCTRL_PULL4_BANK4_PIN02	0x00000004
+#define BM_PINCTRL_PULL4_BANK4_PIN01	0x00000002
+#define BM_PINCTRL_PULL4_BANK4_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL5	(0x00000650)
+#define HW_PINCTRL_PULL5_SET	(0x00000654)
+#define HW_PINCTRL_PULL5_CLR	(0x00000658)
+#define HW_PINCTRL_PULL5_TOG	(0x0000065c)
+
+#define BP_PINCTRL_PULL5_RSRVD1	27
+#define BM_PINCTRL_PULL5_RSRVD1	0xF8000000
+#define BF_PINCTRL_PULL5_RSRVD1(v) \
+		(((v) << 27) & BM_PINCTRL_PULL5_RSRVD1)
+#define BM_PINCTRL_PULL5_BANK5_PIN26	0x04000000
+#define BP_PINCTRL_PULL5_RSRVD0	24
+#define BM_PINCTRL_PULL5_RSRVD0	0x03000000
+#define BF_PINCTRL_PULL5_RSRVD0(v)  \
+		(((v) << 24) & BM_PINCTRL_PULL5_RSRVD0)
+#define BM_PINCTRL_PULL5_BANK5_PIN23	0x00800000
+#define BM_PINCTRL_PULL5_BANK5_PIN22	0x00400000
+#define BM_PINCTRL_PULL5_BANK5_PIN21	0x00200000
+#define BM_PINCTRL_PULL5_BANK5_PIN20	0x00100000
+#define BM_PINCTRL_PULL5_BANK5_PIN19	0x00080000
+#define BM_PINCTRL_PULL5_BANK5_PIN18	0x00040000
+#define BM_PINCTRL_PULL5_BANK5_PIN17	0x00020000
+#define BM_PINCTRL_PULL5_BANK5_PIN16	0x00010000
+#define BM_PINCTRL_PULL5_BANK5_PIN15	0x00008000
+#define BM_PINCTRL_PULL5_BANK5_PIN14	0x00004000
+#define BM_PINCTRL_PULL5_BANK5_PIN13	0x00002000
+#define BM_PINCTRL_PULL5_BANK5_PIN12	0x00001000
+#define BM_PINCTRL_PULL5_BANK5_PIN11	0x00000800
+#define BM_PINCTRL_PULL5_BANK5_PIN10	0x00000400
+#define BM_PINCTRL_PULL5_BANK5_PIN09	0x00000200
+#define BM_PINCTRL_PULL5_BANK5_PIN08	0x00000100
+#define BM_PINCTRL_PULL5_BANK5_PIN07	0x00000080
+#define BM_PINCTRL_PULL5_BANK5_PIN06	0x00000040
+#define BM_PINCTRL_PULL5_BANK5_PIN05	0x00000020
+#define BM_PINCTRL_PULL5_BANK5_PIN04	0x00000010
+#define BM_PINCTRL_PULL5_BANK5_PIN03	0x00000008
+#define BM_PINCTRL_PULL5_BANK5_PIN02	0x00000004
+#define BM_PINCTRL_PULL5_BANK5_PIN01	0x00000002
+#define BM_PINCTRL_PULL5_BANK5_PIN00	0x00000001
+
+#define HW_PINCTRL_PULL6	(0x00000660)
+#define HW_PINCTRL_PULL6_SET	(0x00000664)
+#define HW_PINCTRL_PULL6_CLR	(0x00000668)
+#define HW_PINCTRL_PULL6_TOG	(0x0000066c)
+
+#define BP_PINCTRL_PULL6_RSRVD1	25
+#define BM_PINCTRL_PULL6_RSRVD1	0xFE000000
+#define BF_PINCTRL_PULL6_RSRVD1(v) \
+		(((v) << 25) & BM_PINCTRL_PULL6_RSRVD1)
+#define BM_PINCTRL_PULL6_BANK6_PIN24	0x01000000
+#define BM_PINCTRL_PULL6_BANK6_PIN23	0x00800000
+#define BM_PINCTRL_PULL6_BANK6_PIN22	0x00400000
+#define BM_PINCTRL_PULL6_BANK6_PIN21	0x00200000
+#define BM_PINCTRL_PULL6_BANK6_PIN20	0x00100000
+#define BM_PINCTRL_PULL6_BANK6_PIN19	0x00080000
+#define BM_PINCTRL_PULL6_BANK6_PIN18	0x00040000
+#define BM_PINCTRL_PULL6_BANK6_PIN17	0x00020000
+#define BM_PINCTRL_PULL6_BANK6_PIN16	0x00010000
+#define BM_PINCTRL_PULL6_RSRVD0	0x00008000
+#define BM_PINCTRL_PULL6_BANK6_PIN14	0x00004000
+#define BM_PINCTRL_PULL6_BANK6_PIN13	0x00002000
+#define BM_PINCTRL_PULL6_BANK6_PIN12	0x00001000
+#define BM_PINCTRL_PULL6_BANK6_PIN11	0x00000800
+#define BM_PINCTRL_PULL6_BANK6_PIN10	0x00000400
+#define BM_PINCTRL_PULL6_BANK6_PIN09	0x00000200
+#define BM_PINCTRL_PULL6_BANK6_PIN08	0x00000100
+#define BM_PINCTRL_PULL6_BANK6_PIN07	0x00000080
+#define BM_PINCTRL_PULL6_BANK6_PIN06	0x00000040
+#define BM_PINCTRL_PULL6_BANK6_PIN05	0x00000020
+#define BM_PINCTRL_PULL6_BANK6_PIN04	0x00000010
+#define BM_PINCTRL_PULL6_BANK6_PIN03	0x00000008
+#define BM_PINCTRL_PULL6_BANK6_PIN02	0x00000004
+#define BM_PINCTRL_PULL6_BANK6_PIN01	0x00000002
+#define BM_PINCTRL_PULL6_BANK6_PIN00	0x00000001
+
+#define HW_PINCTRL_DOUT0	(0x00000700)
+#define HW_PINCTRL_DOUT0_SET	(0x00000704)
+#define HW_PINCTRL_DOUT0_CLR	(0x00000708)
+#define HW_PINCTRL_DOUT0_TOG	(0x0000070c)
+
+#define BP_PINCTRL_DOUT0_RSRVD1	29
+#define BM_PINCTRL_DOUT0_RSRVD1	0xE0000000
+#define BF_PINCTRL_DOUT0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_DOUT0_RSRVD1)
+#define BP_PINCTRL_DOUT0_DOUT	0
+#define BM_PINCTRL_DOUT0_DOUT	0x1FFFFFFF
+#define BF_PINCTRL_DOUT0_DOUT(v)  \
+		(((v) << 0) & BM_PINCTRL_DOUT0_DOUT)
+
+#define HW_PINCTRL_DOUT1	(0x00000710)
+#define HW_PINCTRL_DOUT1_SET	(0x00000714)
+#define HW_PINCTRL_DOUT1_CLR	(0x00000718)
+#define HW_PINCTRL_DOUT1_TOG	(0x0000071c)
+
+#define BP_PINCTRL_DOUT1_DOUT	0
+#define BM_PINCTRL_DOUT1_DOUT	0xFFFFFFFF
+#define BF_PINCTRL_DOUT1_DOUT(v)	(v)
+
+#define HW_PINCTRL_DOUT2	(0x00000720)
+#define HW_PINCTRL_DOUT2_SET	(0x00000724)
+#define HW_PINCTRL_DOUT2_CLR	(0x00000728)
+#define HW_PINCTRL_DOUT2_TOG	(0x0000072c)
+
+#define BP_PINCTRL_DOUT2_RSRVD1	28
+#define BM_PINCTRL_DOUT2_RSRVD1	0xF0000000
+#define BF_PINCTRL_DOUT2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_DOUT2_RSRVD1)
+#define BP_PINCTRL_DOUT2_DOUT	0
+#define BM_PINCTRL_DOUT2_DOUT	0x0FFFFFFF
+#define BF_PINCTRL_DOUT2_DOUT(v)  \
+		(((v) << 0) & BM_PINCTRL_DOUT2_DOUT)
+
+#define HW_PINCTRL_DOUT3	(0x00000730)
+#define HW_PINCTRL_DOUT3_SET	(0x00000734)
+#define HW_PINCTRL_DOUT3_CLR	(0x00000738)
+#define HW_PINCTRL_DOUT3_TOG	(0x0000073c)
+
+#define BM_PINCTRL_DOUT3_RSRVD1	0x80000000
+#define BP_PINCTRL_DOUT3_DOUT	0
+#define BM_PINCTRL_DOUT3_DOUT	0x7FFFFFFF
+#define BF_PINCTRL_DOUT3_DOUT(v)  \
+		(((v) << 0) & BM_PINCTRL_DOUT3_DOUT)
+
+#define HW_PINCTRL_DOUT4	(0x00000740)
+#define HW_PINCTRL_DOUT4_SET	(0x00000744)
+#define HW_PINCTRL_DOUT4_CLR	(0x00000748)
+#define HW_PINCTRL_DOUT4_TOG	(0x0000074c)
+
+#define BP_PINCTRL_DOUT4_RSRVD1	21
+#define BM_PINCTRL_DOUT4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_DOUT4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_DOUT4_RSRVD1)
+#define BP_PINCTRL_DOUT4_DOUT	0
+#define BM_PINCTRL_DOUT4_DOUT	0x001FFFFF
+#define BF_PINCTRL_DOUT4_DOUT(v)  \
+		(((v) << 0) & BM_PINCTRL_DOUT4_DOUT)
+
+#define HW_PINCTRL_DIN0	(0x00000900)
+#define HW_PINCTRL_DIN0_SET	(0x00000904)
+#define HW_PINCTRL_DIN0_CLR	(0x00000908)
+#define HW_PINCTRL_DIN0_TOG	(0x0000090c)
+
+#define BP_PINCTRL_DIN0_RSRVD1	29
+#define BM_PINCTRL_DIN0_RSRVD1	0xE0000000
+#define BF_PINCTRL_DIN0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_DIN0_RSRVD1)
+#define BP_PINCTRL_DIN0_DIN	0
+#define BM_PINCTRL_DIN0_DIN	0x1FFFFFFF
+#define BF_PINCTRL_DIN0_DIN(v)  \
+		(((v) << 0) & BM_PINCTRL_DIN0_DIN)
+
+#define HW_PINCTRL_DIN1	(0x00000910)
+#define HW_PINCTRL_DIN1_SET	(0x00000914)
+#define HW_PINCTRL_DIN1_CLR	(0x00000918)
+#define HW_PINCTRL_DIN1_TOG	(0x0000091c)
+
+#define BP_PINCTRL_DIN1_DIN	0
+#define BM_PINCTRL_DIN1_DIN	0xFFFFFFFF
+#define BF_PINCTRL_DIN1_DIN(v)	(v)
+
+#define HW_PINCTRL_DIN2	(0x00000920)
+#define HW_PINCTRL_DIN2_SET	(0x00000924)
+#define HW_PINCTRL_DIN2_CLR	(0x00000928)
+#define HW_PINCTRL_DIN2_TOG	(0x0000092c)
+
+#define BP_PINCTRL_DIN2_RSRVD1	28
+#define BM_PINCTRL_DIN2_RSRVD1	0xF0000000
+#define BF_PINCTRL_DIN2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_DIN2_RSRVD1)
+#define BP_PINCTRL_DIN2_DIN	0
+#define BM_PINCTRL_DIN2_DIN	0x0FFFFFFF
+#define BF_PINCTRL_DIN2_DIN(v)  \
+		(((v) << 0) & BM_PINCTRL_DIN2_DIN)
+
+#define HW_PINCTRL_DIN3	(0x00000930)
+#define HW_PINCTRL_DIN3_SET	(0x00000934)
+#define HW_PINCTRL_DIN3_CLR	(0x00000938)
+#define HW_PINCTRL_DIN3_TOG	(0x0000093c)
+
+#define BM_PINCTRL_DIN3_RSRVD1	0x80000000
+#define BP_PINCTRL_DIN3_DIN	0
+#define BM_PINCTRL_DIN3_DIN	0x7FFFFFFF
+#define BF_PINCTRL_DIN3_DIN(v)  \
+		(((v) << 0) & BM_PINCTRL_DIN3_DIN)
+
+#define HW_PINCTRL_DIN4	(0x00000940)
+#define HW_PINCTRL_DIN4_SET	(0x00000944)
+#define HW_PINCTRL_DIN4_CLR	(0x00000948)
+#define HW_PINCTRL_DIN4_TOG	(0x0000094c)
+
+#define BP_PINCTRL_DIN4_RSRVD1	21
+#define BM_PINCTRL_DIN4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_DIN4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_DIN4_RSRVD1)
+#define BP_PINCTRL_DIN4_DIN	0
+#define BM_PINCTRL_DIN4_DIN	0x001FFFFF
+#define BF_PINCTRL_DIN4_DIN(v)  \
+		(((v) << 0) & BM_PINCTRL_DIN4_DIN)
+
+#define HW_PINCTRL_DOE0	(0x00000b00)
+#define HW_PINCTRL_DOE0_SET	(0x00000b04)
+#define HW_PINCTRL_DOE0_CLR	(0x00000b08)
+#define HW_PINCTRL_DOE0_TOG	(0x00000b0c)
+
+#define BP_PINCTRL_DOE0_RSRVD1	29
+#define BM_PINCTRL_DOE0_RSRVD1	0xE0000000
+#define BF_PINCTRL_DOE0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_DOE0_RSRVD1)
+#define BP_PINCTRL_DOE0_DOE	0
+#define BM_PINCTRL_DOE0_DOE	0x1FFFFFFF
+#define BF_PINCTRL_DOE0_DOE(v)  \
+		(((v) << 0) & BM_PINCTRL_DOE0_DOE)
+
+#define HW_PINCTRL_DOE1	(0x00000b10)
+#define HW_PINCTRL_DOE1_SET	(0x00000b14)
+#define HW_PINCTRL_DOE1_CLR	(0x00000b18)
+#define HW_PINCTRL_DOE1_TOG	(0x00000b1c)
+
+#define BP_PINCTRL_DOE1_DOE	0
+#define BM_PINCTRL_DOE1_DOE	0xFFFFFFFF
+#define BF_PINCTRL_DOE1_DOE(v)	(v)
+
+#define HW_PINCTRL_DOE2	(0x00000b20)
+#define HW_PINCTRL_DOE2_SET	(0x00000b24)
+#define HW_PINCTRL_DOE2_CLR	(0x00000b28)
+#define HW_PINCTRL_DOE2_TOG	(0x00000b2c)
+
+#define BP_PINCTRL_DOE2_RSRVD1	28
+#define BM_PINCTRL_DOE2_RSRVD1	0xF0000000
+#define BF_PINCTRL_DOE2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_DOE2_RSRVD1)
+#define BP_PINCTRL_DOE2_DOE	0
+#define BM_PINCTRL_DOE2_DOE	0x0FFFFFFF
+#define BF_PINCTRL_DOE2_DOE(v)  \
+		(((v) << 0) & BM_PINCTRL_DOE2_DOE)
+
+#define HW_PINCTRL_DOE3	(0x00000b30)
+#define HW_PINCTRL_DOE3_SET	(0x00000b34)
+#define HW_PINCTRL_DOE3_CLR	(0x00000b38)
+#define HW_PINCTRL_DOE3_TOG	(0x00000b3c)
+
+#define BM_PINCTRL_DOE3_RSRVD1	0x80000000
+#define BP_PINCTRL_DOE3_DOE	0
+#define BM_PINCTRL_DOE3_DOE	0x7FFFFFFF
+#define BF_PINCTRL_DOE3_DOE(v)  \
+		(((v) << 0) & BM_PINCTRL_DOE3_DOE)
+
+#define HW_PINCTRL_DOE4	(0x00000b40)
+#define HW_PINCTRL_DOE4_SET	(0x00000b44)
+#define HW_PINCTRL_DOE4_CLR	(0x00000b48)
+#define HW_PINCTRL_DOE4_TOG	(0x00000b4c)
+
+#define BP_PINCTRL_DOE4_RSRVD1	21
+#define BM_PINCTRL_DOE4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_DOE4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_DOE4_RSRVD1)
+#define BP_PINCTRL_DOE4_DOE	0
+#define BM_PINCTRL_DOE4_DOE	0x001FFFFF
+#define BF_PINCTRL_DOE4_DOE(v)  \
+		(((v) << 0) & BM_PINCTRL_DOE4_DOE)
+
+#define HW_PINCTRL_PIN2IRQ0	(0x00001000)
+#define HW_PINCTRL_PIN2IRQ0_SET	(0x00001004)
+#define HW_PINCTRL_PIN2IRQ0_CLR	(0x00001008)
+#define HW_PINCTRL_PIN2IRQ0_TOG	(0x0000100c)
+
+#define BP_PINCTRL_PIN2IRQ0_RSRVD1	29
+#define BM_PINCTRL_PIN2IRQ0_RSRVD1	0xE0000000
+#define BF_PINCTRL_PIN2IRQ0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_PIN2IRQ0_RSRVD1)
+#define BP_PINCTRL_PIN2IRQ0_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ0_PIN2IRQ	0x1FFFFFFF
+#define BF_PINCTRL_PIN2IRQ0_PIN2IRQ(v)  \
+		(((v) << 0) & BM_PINCTRL_PIN2IRQ0_PIN2IRQ)
+
+#define HW_PINCTRL_PIN2IRQ1	(0x00001010)
+#define HW_PINCTRL_PIN2IRQ1_SET	(0x00001014)
+#define HW_PINCTRL_PIN2IRQ1_CLR	(0x00001018)
+#define HW_PINCTRL_PIN2IRQ1_TOG	(0x0000101c)
+
+#define BP_PINCTRL_PIN2IRQ1_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ1_PIN2IRQ	0xFFFFFFFF
+#define BF_PINCTRL_PIN2IRQ1_PIN2IRQ(v)	(v)
+
+#define HW_PINCTRL_PIN2IRQ2	(0x00001020)
+#define HW_PINCTRL_PIN2IRQ2_SET	(0x00001024)
+#define HW_PINCTRL_PIN2IRQ2_CLR	(0x00001028)
+#define HW_PINCTRL_PIN2IRQ2_TOG	(0x0000102c)
+
+#define BP_PINCTRL_PIN2IRQ2_RSRVD1	28
+#define BM_PINCTRL_PIN2IRQ2_RSRVD1	0xF0000000
+#define BF_PINCTRL_PIN2IRQ2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_PIN2IRQ2_RSRVD1)
+#define BP_PINCTRL_PIN2IRQ2_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ2_PIN2IRQ	0x0FFFFFFF
+#define BF_PINCTRL_PIN2IRQ2_PIN2IRQ(v)  \
+		(((v) << 0) & BM_PINCTRL_PIN2IRQ2_PIN2IRQ)
+
+#define HW_PINCTRL_PIN2IRQ3	(0x00001030)
+#define HW_PINCTRL_PIN2IRQ3_SET	(0x00001034)
+#define HW_PINCTRL_PIN2IRQ3_CLR	(0x00001038)
+#define HW_PINCTRL_PIN2IRQ3_TOG	(0x0000103c)
+
+#define BM_PINCTRL_PIN2IRQ3_RSRVD1	0x80000000
+#define BP_PINCTRL_PIN2IRQ3_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ3_PIN2IRQ	0x7FFFFFFF
+#define BF_PINCTRL_PIN2IRQ3_PIN2IRQ(v)  \
+		(((v) << 0) & BM_PINCTRL_PIN2IRQ3_PIN2IRQ)
+
+#define HW_PINCTRL_PIN2IRQ4	(0x00001040)
+#define HW_PINCTRL_PIN2IRQ4_SET	(0x00001044)
+#define HW_PINCTRL_PIN2IRQ4_CLR	(0x00001048)
+#define HW_PINCTRL_PIN2IRQ4_TOG	(0x0000104c)
+
+#define BP_PINCTRL_PIN2IRQ4_RSRVD1	21
+#define BM_PINCTRL_PIN2IRQ4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_PIN2IRQ4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_PIN2IRQ4_RSRVD1)
+#define BP_PINCTRL_PIN2IRQ4_PIN2IRQ	0
+#define BM_PINCTRL_PIN2IRQ4_PIN2IRQ	0x001FFFFF
+#define BF_PINCTRL_PIN2IRQ4_PIN2IRQ(v)  \
+		(((v) << 0) & BM_PINCTRL_PIN2IRQ4_PIN2IRQ)
+
+#define HW_PINCTRL_IRQEN0	(0x00001100)
+#define HW_PINCTRL_IRQEN0_SET	(0x00001104)
+#define HW_PINCTRL_IRQEN0_CLR	(0x00001108)
+#define HW_PINCTRL_IRQEN0_TOG	(0x0000110c)
+
+#define BP_PINCTRL_IRQEN0_RSRVD1	29
+#define BM_PINCTRL_IRQEN0_RSRVD1	0xE0000000
+#define BF_PINCTRL_IRQEN0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_IRQEN0_RSRVD1)
+#define BP_PINCTRL_IRQEN0_IRQEN	0
+#define BM_PINCTRL_IRQEN0_IRQEN	0x1FFFFFFF
+#define BF_PINCTRL_IRQEN0_IRQEN(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQEN0_IRQEN)
+
+#define HW_PINCTRL_IRQEN1	(0x00001110)
+#define HW_PINCTRL_IRQEN1_SET	(0x00001114)
+#define HW_PINCTRL_IRQEN1_CLR	(0x00001118)
+#define HW_PINCTRL_IRQEN1_TOG	(0x0000111c)
+
+#define BP_PINCTRL_IRQEN1_IRQEN	0
+#define BM_PINCTRL_IRQEN1_IRQEN	0xFFFFFFFF
+#define BF_PINCTRL_IRQEN1_IRQEN(v)	(v)
+
+#define HW_PINCTRL_IRQEN2	(0x00001120)
+#define HW_PINCTRL_IRQEN2_SET	(0x00001124)
+#define HW_PINCTRL_IRQEN2_CLR	(0x00001128)
+#define HW_PINCTRL_IRQEN2_TOG	(0x0000112c)
+
+#define BP_PINCTRL_IRQEN2_RSRVD1	28
+#define BM_PINCTRL_IRQEN2_RSRVD1	0xF0000000
+#define BF_PINCTRL_IRQEN2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_IRQEN2_RSRVD1)
+#define BP_PINCTRL_IRQEN2_IRQEN	0
+#define BM_PINCTRL_IRQEN2_IRQEN	0x0FFFFFFF
+#define BF_PINCTRL_IRQEN2_IRQEN(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQEN2_IRQEN)
+
+#define HW_PINCTRL_IRQEN3	(0x00001130)
+#define HW_PINCTRL_IRQEN3_SET	(0x00001134)
+#define HW_PINCTRL_IRQEN3_CLR	(0x00001138)
+#define HW_PINCTRL_IRQEN3_TOG	(0x0000113c)
+
+#define BM_PINCTRL_IRQEN3_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQEN3_IRQEN	0
+#define BM_PINCTRL_IRQEN3_IRQEN	0x7FFFFFFF
+#define BF_PINCTRL_IRQEN3_IRQEN(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQEN3_IRQEN)
+
+#define HW_PINCTRL_IRQEN4	(0x00001140)
+#define HW_PINCTRL_IRQEN4_SET	(0x00001144)
+#define HW_PINCTRL_IRQEN4_CLR	(0x00001148)
+#define HW_PINCTRL_IRQEN4_TOG	(0x0000114c)
+
+#define BP_PINCTRL_IRQEN4_RSRVD1	21
+#define BM_PINCTRL_IRQEN4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_IRQEN4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_IRQEN4_RSRVD1)
+#define BP_PINCTRL_IRQEN4_IRQEN	0
+#define BM_PINCTRL_IRQEN4_IRQEN	0x001FFFFF
+#define BF_PINCTRL_IRQEN4_IRQEN(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQEN4_IRQEN)
+
+#define HW_PINCTRL_IRQLEVEL0	(0x00001200)
+#define HW_PINCTRL_IRQLEVEL0_SET	(0x00001204)
+#define HW_PINCTRL_IRQLEVEL0_CLR	(0x00001208)
+#define HW_PINCTRL_IRQLEVEL0_TOG	(0x0000120c)
+
+#define BP_PINCTRL_IRQLEVEL0_RSRVD1	29
+#define BM_PINCTRL_IRQLEVEL0_RSRVD1	0xE0000000
+#define BF_PINCTRL_IRQLEVEL0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_IRQLEVEL0_RSRVD1)
+#define BP_PINCTRL_IRQLEVEL0_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL0_IRQLEVEL	0x1FFFFFFF
+#define BF_PINCTRL_IRQLEVEL0_IRQLEVEL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQLEVEL0_IRQLEVEL)
+
+#define HW_PINCTRL_IRQLEVEL1	(0x00001210)
+#define HW_PINCTRL_IRQLEVEL1_SET	(0x00001214)
+#define HW_PINCTRL_IRQLEVEL1_CLR	(0x00001218)
+#define HW_PINCTRL_IRQLEVEL1_TOG	(0x0000121c)
+
+#define BP_PINCTRL_IRQLEVEL1_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL1_IRQLEVEL	0xFFFFFFFF
+#define BF_PINCTRL_IRQLEVEL1_IRQLEVEL(v)	(v)
+
+#define HW_PINCTRL_IRQLEVEL2	(0x00001220)
+#define HW_PINCTRL_IRQLEVEL2_SET	(0x00001224)
+#define HW_PINCTRL_IRQLEVEL2_CLR	(0x00001228)
+#define HW_PINCTRL_IRQLEVEL2_TOG	(0x0000122c)
+
+#define BP_PINCTRL_IRQLEVEL2_RSRVD1	28
+#define BM_PINCTRL_IRQLEVEL2_RSRVD1	0xF0000000
+#define BF_PINCTRL_IRQLEVEL2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_IRQLEVEL2_RSRVD1)
+#define BP_PINCTRL_IRQLEVEL2_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL2_IRQLEVEL	0x0FFFFFFF
+#define BF_PINCTRL_IRQLEVEL2_IRQLEVEL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQLEVEL2_IRQLEVEL)
+
+#define HW_PINCTRL_IRQLEVEL3	(0x00001230)
+#define HW_PINCTRL_IRQLEVEL3_SET	(0x00001234)
+#define HW_PINCTRL_IRQLEVEL3_CLR	(0x00001238)
+#define HW_PINCTRL_IRQLEVEL3_TOG	(0x0000123c)
+
+#define BM_PINCTRL_IRQLEVEL3_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQLEVEL3_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL3_IRQLEVEL	0x7FFFFFFF
+#define BF_PINCTRL_IRQLEVEL3_IRQLEVEL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQLEVEL3_IRQLEVEL)
+
+#define HW_PINCTRL_IRQLEVEL4	(0x00001240)
+#define HW_PINCTRL_IRQLEVEL4_SET	(0x00001244)
+#define HW_PINCTRL_IRQLEVEL4_CLR	(0x00001248)
+#define HW_PINCTRL_IRQLEVEL4_TOG	(0x0000124c)
+
+#define BP_PINCTRL_IRQLEVEL4_RSRVD1	21
+#define BM_PINCTRL_IRQLEVEL4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_IRQLEVEL4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_IRQLEVEL4_RSRVD1)
+#define BP_PINCTRL_IRQLEVEL4_IRQLEVEL	0
+#define BM_PINCTRL_IRQLEVEL4_IRQLEVEL	0x001FFFFF
+#define BF_PINCTRL_IRQLEVEL4_IRQLEVEL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQLEVEL4_IRQLEVEL)
+
+#define HW_PINCTRL_IRQPOL0	(0x00001300)
+#define HW_PINCTRL_IRQPOL0_SET	(0x00001304)
+#define HW_PINCTRL_IRQPOL0_CLR	(0x00001308)
+#define HW_PINCTRL_IRQPOL0_TOG	(0x0000130c)
+
+#define BP_PINCTRL_IRQPOL0_RSRVD1	29
+#define BM_PINCTRL_IRQPOL0_RSRVD1	0xE0000000
+#define BF_PINCTRL_IRQPOL0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_IRQPOL0_RSRVD1)
+#define BP_PINCTRL_IRQPOL0_IRQPOL	0
+#define BM_PINCTRL_IRQPOL0_IRQPOL	0x1FFFFFFF
+#define BF_PINCTRL_IRQPOL0_IRQPOL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQPOL0_IRQPOL)
+
+#define HW_PINCTRL_IRQPOL1	(0x00001310)
+#define HW_PINCTRL_IRQPOL1_SET	(0x00001314)
+#define HW_PINCTRL_IRQPOL1_CLR	(0x00001318)
+#define HW_PINCTRL_IRQPOL1_TOG	(0x0000131c)
+
+#define BP_PINCTRL_IRQPOL1_IRQPOL	0
+#define BM_PINCTRL_IRQPOL1_IRQPOL	0xFFFFFFFF
+#define BF_PINCTRL_IRQPOL1_IRQPOL(v)	(v)
+
+#define HW_PINCTRL_IRQPOL2	(0x00001320)
+#define HW_PINCTRL_IRQPOL2_SET	(0x00001324)
+#define HW_PINCTRL_IRQPOL2_CLR	(0x00001328)
+#define HW_PINCTRL_IRQPOL2_TOG	(0x0000132c)
+
+#define BP_PINCTRL_IRQPOL2_RSRVD1	28
+#define BM_PINCTRL_IRQPOL2_RSRVD1	0xF0000000
+#define BF_PINCTRL_IRQPOL2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_IRQPOL2_RSRVD1)
+#define BP_PINCTRL_IRQPOL2_IRQPOL	0
+#define BM_PINCTRL_IRQPOL2_IRQPOL	0x0FFFFFFF
+#define BF_PINCTRL_IRQPOL2_IRQPOL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQPOL2_IRQPOL)
+
+#define HW_PINCTRL_IRQPOL3	(0x00001330)
+#define HW_PINCTRL_IRQPOL3_SET	(0x00001334)
+#define HW_PINCTRL_IRQPOL3_CLR	(0x00001338)
+#define HW_PINCTRL_IRQPOL3_TOG	(0x0000133c)
+
+#define BM_PINCTRL_IRQPOL3_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQPOL3_IRQPOL	0
+#define BM_PINCTRL_IRQPOL3_IRQPOL	0x7FFFFFFF
+#define BF_PINCTRL_IRQPOL3_IRQPOL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQPOL3_IRQPOL)
+
+#define HW_PINCTRL_IRQPOL4	(0x00001340)
+#define HW_PINCTRL_IRQPOL4_SET	(0x00001344)
+#define HW_PINCTRL_IRQPOL4_CLR	(0x00001348)
+#define HW_PINCTRL_IRQPOL4_TOG	(0x0000134c)
+
+#define BP_PINCTRL_IRQPOL4_RSRVD1	21
+#define BM_PINCTRL_IRQPOL4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_IRQPOL4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_IRQPOL4_RSRVD1)
+#define BP_PINCTRL_IRQPOL4_IRQPOL	0
+#define BM_PINCTRL_IRQPOL4_IRQPOL	0x001FFFFF
+#define BF_PINCTRL_IRQPOL4_IRQPOL(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQPOL4_IRQPOL)
+
+#define HW_PINCTRL_IRQSTAT0	(0x00001400)
+#define HW_PINCTRL_IRQSTAT0_SET	(0x00001404)
+#define HW_PINCTRL_IRQSTAT0_CLR	(0x00001408)
+#define HW_PINCTRL_IRQSTAT0_TOG	(0x0000140c)
+
+#define BP_PINCTRL_IRQSTAT0_RSRVD1	29
+#define BM_PINCTRL_IRQSTAT0_RSRVD1	0xE0000000
+#define BF_PINCTRL_IRQSTAT0_RSRVD1(v) \
+		(((v) << 29) & BM_PINCTRL_IRQSTAT0_RSRVD1)
+#define BP_PINCTRL_IRQSTAT0_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT0_IRQSTAT	0x1FFFFFFF
+#define BF_PINCTRL_IRQSTAT0_IRQSTAT(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQSTAT0_IRQSTAT)
+
+#define HW_PINCTRL_IRQSTAT1	(0x00001410)
+#define HW_PINCTRL_IRQSTAT1_SET	(0x00001414)
+#define HW_PINCTRL_IRQSTAT1_CLR	(0x00001418)
+#define HW_PINCTRL_IRQSTAT1_TOG	(0x0000141c)
+
+#define BP_PINCTRL_IRQSTAT1_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT1_IRQSTAT	0xFFFFFFFF
+#define BF_PINCTRL_IRQSTAT1_IRQSTAT(v)	(v)
+
+#define HW_PINCTRL_IRQSTAT2	(0x00001420)
+#define HW_PINCTRL_IRQSTAT2_SET	(0x00001424)
+#define HW_PINCTRL_IRQSTAT2_CLR	(0x00001428)
+#define HW_PINCTRL_IRQSTAT2_TOG	(0x0000142c)
+
+#define BP_PINCTRL_IRQSTAT2_RSRVD1	28
+#define BM_PINCTRL_IRQSTAT2_RSRVD1	0xF0000000
+#define BF_PINCTRL_IRQSTAT2_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_IRQSTAT2_RSRVD1)
+#define BP_PINCTRL_IRQSTAT2_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT2_IRQSTAT	0x0FFFFFFF
+#define BF_PINCTRL_IRQSTAT2_IRQSTAT(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQSTAT2_IRQSTAT)
+
+#define HW_PINCTRL_IRQSTAT3	(0x00001430)
+#define HW_PINCTRL_IRQSTAT3_SET	(0x00001434)
+#define HW_PINCTRL_IRQSTAT3_CLR	(0x00001438)
+#define HW_PINCTRL_IRQSTAT3_TOG	(0x0000143c)
+
+#define BM_PINCTRL_IRQSTAT3_RSRVD1	0x80000000
+#define BP_PINCTRL_IRQSTAT3_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT3_IRQSTAT	0x7FFFFFFF
+#define BF_PINCTRL_IRQSTAT3_IRQSTAT(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQSTAT3_IRQSTAT)
+
+#define HW_PINCTRL_IRQSTAT4	(0x00001440)
+#define HW_PINCTRL_IRQSTAT4_SET	(0x00001444)
+#define HW_PINCTRL_IRQSTAT4_CLR	(0x00001448)
+#define HW_PINCTRL_IRQSTAT4_TOG	(0x0000144c)
+
+#define BP_PINCTRL_IRQSTAT4_RSRVD1	21
+#define BM_PINCTRL_IRQSTAT4_RSRVD1	0xFFE00000
+#define BF_PINCTRL_IRQSTAT4_RSRVD1(v) \
+		(((v) << 21) & BM_PINCTRL_IRQSTAT4_RSRVD1)
+#define BP_PINCTRL_IRQSTAT4_IRQSTAT	0
+#define BM_PINCTRL_IRQSTAT4_IRQSTAT	0x001FFFFF
+#define BF_PINCTRL_IRQSTAT4_IRQSTAT(v)  \
+		(((v) << 0) & BM_PINCTRL_IRQSTAT4_IRQSTAT)
+
+#define HW_PINCTRL_EMI_ODT_CTRL	(0x00001a40)
+#define HW_PINCTRL_EMI_ODT_CTRL_SET	(0x00001a44)
+#define HW_PINCTRL_EMI_ODT_CTRL_CLR	(0x00001a48)
+#define HW_PINCTRL_EMI_ODT_CTRL_TOG	(0x00001a4c)
+
+#define BP_PINCTRL_EMI_ODT_CTRL_RSRVD1	28
+#define BM_PINCTRL_EMI_ODT_CTRL_RSRVD1	0xF0000000
+#define BF_PINCTRL_EMI_ODT_CTRL_RSRVD1(v) \
+		(((v) << 28) & BM_PINCTRL_EMI_ODT_CTRL_RSRVD1)
+#define BP_PINCTRL_EMI_ODT_CTRL_ADDRESS_CALIB	26
+#define BM_PINCTRL_EMI_ODT_CTRL_ADDRESS_CALIB	0x0C000000
+#define BF_PINCTRL_EMI_ODT_CTRL_ADDRESS_CALIB(v)  \
+		(((v) << 26) & BM_PINCTRL_EMI_ODT_CTRL_ADDRESS_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_ADDRESS_TLOAD	24
+#define BM_PINCTRL_EMI_ODT_CTRL_ADDRESS_TLOAD	0x03000000
+#define BF_PINCTRL_EMI_ODT_CTRL_ADDRESS_TLOAD(v)  \
+		(((v) << 24) & BM_PINCTRL_EMI_ODT_CTRL_ADDRESS_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_CONTROL_CALIB	22
+#define BM_PINCTRL_EMI_ODT_CTRL_CONTROL_CALIB	0x00C00000
+#define BF_PINCTRL_EMI_ODT_CTRL_CONTROL_CALIB(v)  \
+		(((v) << 22) & BM_PINCTRL_EMI_ODT_CTRL_CONTROL_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_CONTROL_TLOAD	20
+#define BM_PINCTRL_EMI_ODT_CTRL_CONTROL_TLOAD	0x00300000
+#define BF_PINCTRL_EMI_ODT_CTRL_CONTROL_TLOAD(v)  \
+		(((v) << 20) & BM_PINCTRL_EMI_ODT_CTRL_CONTROL_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_DUALPAD_CALIB	18
+#define BM_PINCTRL_EMI_ODT_CTRL_DUALPAD_CALIB	0x000C0000
+#define BF_PINCTRL_EMI_ODT_CTRL_DUALPAD_CALIB(v)  \
+		(((v) << 18) & BM_PINCTRL_EMI_ODT_CTRL_DUALPAD_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_DUALPAD_TLOAD	16
+#define BM_PINCTRL_EMI_ODT_CTRL_DUALPAD_TLOAD	0x00030000
+#define BF_PINCTRL_EMI_ODT_CTRL_DUALPAD_TLOAD(v)  \
+		(((v) << 16) & BM_PINCTRL_EMI_ODT_CTRL_DUALPAD_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE3_CALIB	14
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE3_CALIB	0x0000C000
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE3_CALIB(v)  \
+		(((v) << 14) & BM_PINCTRL_EMI_ODT_CTRL_SLICE3_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE3_TLOAD	12
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE3_TLOAD	0x00003000
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE3_TLOAD(v)  \
+		(((v) << 12) & BM_PINCTRL_EMI_ODT_CTRL_SLICE3_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE2_CALIB	10
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE2_CALIB	0x00000C00
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE2_CALIB(v)  \
+		(((v) << 10) & BM_PINCTRL_EMI_ODT_CTRL_SLICE2_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE2_TLOAD	8
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE2_TLOAD	0x00000300
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE2_TLOAD(v)  \
+		(((v) << 8) & BM_PINCTRL_EMI_ODT_CTRL_SLICE2_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE1_CALIB	6
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE1_CALIB	0x000000C0
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE1_CALIB(v)  \
+		(((v) << 6) & BM_PINCTRL_EMI_ODT_CTRL_SLICE1_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE1_TLOAD	4
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE1_TLOAD	0x00000030
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE1_TLOAD(v)  \
+		(((v) << 4) & BM_PINCTRL_EMI_ODT_CTRL_SLICE1_TLOAD)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE0_CALIB	2
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE0_CALIB	0x0000000C
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE0_CALIB(v)  \
+		(((v) << 2) & BM_PINCTRL_EMI_ODT_CTRL_SLICE0_CALIB)
+#define BP_PINCTRL_EMI_ODT_CTRL_SLICE0_TLOAD	0
+#define BM_PINCTRL_EMI_ODT_CTRL_SLICE0_TLOAD	0x00000003
+#define BF_PINCTRL_EMI_ODT_CTRL_SLICE0_TLOAD(v)  \
+		(((v) << 0) & BM_PINCTRL_EMI_ODT_CTRL_SLICE0_TLOAD)
+
+#define HW_PINCTRL_EMI_DS_CTRL	(0x00001b80)
+#define HW_PINCTRL_EMI_DS_CTRL_SET	(0x00001b84)
+#define HW_PINCTRL_EMI_DS_CTRL_CLR	(0x00001b88)
+#define HW_PINCTRL_EMI_DS_CTRL_TOG	(0x00001b8c)
+
+#define BP_PINCTRL_EMI_DS_CTRL_RSRVD1	18
+#define BM_PINCTRL_EMI_DS_CTRL_RSRVD1	0xFFFC0000
+#define BF_PINCTRL_EMI_DS_CTRL_RSRVD1(v) \
+		(((v) << 18) & BM_PINCTRL_EMI_DS_CTRL_RSRVD1)
+#define BP_PINCTRL_EMI_DS_CTRL_DDR_MODE	16
+#define BM_PINCTRL_EMI_DS_CTRL_DDR_MODE	0x00030000
+#define BF_PINCTRL_EMI_DS_CTRL_DDR_MODE(v)  \
+		(((v) << 16) & BM_PINCTRL_EMI_DS_CTRL_DDR_MODE)
+#define BV_PINCTRL_EMI_DS_CTRL_DDR_MODE__mDDR   00
+#define BV_PINCTRL_EMI_DS_CTRL_DDR_MODE__GPIO   01
+#define BV_PINCTRL_EMI_DS_CTRL_DDR_MODE__LVDDR2 10
+#define BV_PINCTRL_EMI_DS_CTRL_DDR_MODE__DDR2   11
+#define BP_PINCTRL_EMI_DS_CTRL_RSRVD0	14
+#define BM_PINCTRL_EMI_DS_CTRL_RSRVD0	0x0000C000
+#define BF_PINCTRL_EMI_DS_CTRL_RSRVD0(v)  \
+		(((v) << 14) & BM_PINCTRL_EMI_DS_CTRL_RSRVD0)
+#define BP_PINCTRL_EMI_DS_CTRL_ADDRESS_MA	12
+#define BM_PINCTRL_EMI_DS_CTRL_ADDRESS_MA	0x00003000
+#define BF_PINCTRL_EMI_DS_CTRL_ADDRESS_MA(v)  \
+		(((v) << 12) & BM_PINCTRL_EMI_DS_CTRL_ADDRESS_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_CONTROL_MA	10
+#define BM_PINCTRL_EMI_DS_CTRL_CONTROL_MA	0x00000C00
+#define BF_PINCTRL_EMI_DS_CTRL_CONTROL_MA(v)  \
+		(((v) << 10) & BM_PINCTRL_EMI_DS_CTRL_CONTROL_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_DUALPAD_MA	8
+#define BM_PINCTRL_EMI_DS_CTRL_DUALPAD_MA	0x00000300
+#define BF_PINCTRL_EMI_DS_CTRL_DUALPAD_MA(v)  \
+		(((v) << 8) & BM_PINCTRL_EMI_DS_CTRL_DUALPAD_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_SLICE3_MA	6
+#define BM_PINCTRL_EMI_DS_CTRL_SLICE3_MA	0x000000C0
+#define BF_PINCTRL_EMI_DS_CTRL_SLICE3_MA(v)  \
+		(((v) << 6) & BM_PINCTRL_EMI_DS_CTRL_SLICE3_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_SLICE2_MA	4
+#define BM_PINCTRL_EMI_DS_CTRL_SLICE2_MA	0x00000030
+#define BF_PINCTRL_EMI_DS_CTRL_SLICE2_MA(v)  \
+		(((v) << 4) & BM_PINCTRL_EMI_DS_CTRL_SLICE2_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_SLICE1_MA	2
+#define BM_PINCTRL_EMI_DS_CTRL_SLICE1_MA	0x0000000C
+#define BF_PINCTRL_EMI_DS_CTRL_SLICE1_MA(v)  \
+		(((v) << 2) & BM_PINCTRL_EMI_DS_CTRL_SLICE1_MA)
+#define BP_PINCTRL_EMI_DS_CTRL_SLICE0_MA	0
+#define BM_PINCTRL_EMI_DS_CTRL_SLICE0_MA	0x00000003
+#define BF_PINCTRL_EMI_DS_CTRL_SLICE0_MA(v)  \
+		(((v) << 0) & BM_PINCTRL_EMI_DS_CTRL_SLICE0_MA)
+#endif /* __ARCH_ARM___PINCTRL_H */
diff --git a/arch/arm/mach-mx28/serial.c b/arch/arm/mach-mx28/serial.c
new file mode 100644
index 0000000..a7297d1
--- /dev/null
+++ b/arch/arm/mach-mx28/serial.c
@@ -0,0 +1,309 @@
+/*
+  * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License along
+  * with this program; if not, write to the Free Software Foundation, Inc.,
+  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+  */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/dma.h>
+#include "device.h"
+
+#if defined(CONFIG_SERIAL_MXS_AUART) || \
+	defined(CONFIG_SERIAL_MXS_AUART_MODULE)
+
+#ifdef CONFIG_MXS_AUART0_DEVICE_ENABLE
+static struct resource auart0_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART0_PHYS_ADDR,
+	 .end	= AUART0_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART0_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART0_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART0_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART0_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART0,
+	 .end	= IRQ_AUART0,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART0_RX_DMA,
+	 .end	= IRQ_AUART0_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART0_TX_DMA,
+	 .end	= IRQ_AUART0_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart0_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART0_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = PAGE_SIZE,
+	.timeout = HZ,
+};
+#endif
+
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+static struct resource auart1_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART1_PHYS_ADDR,
+	 .end	= AUART1_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART1_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART1_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART1,
+	 .end	= IRQ_AUART1,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART1_RX_DMA,
+	 .end	= IRQ_AUART1_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART1_TX_DMA,
+	 .end	= IRQ_AUART1_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart1_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART1_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = PAGE_SIZE,
+	.timeout = HZ,
+};
+#endif
+
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+static struct resource auart2_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART2_PHYS_ADDR,
+	 .end	= AUART2_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART2_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART2_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART2,
+	 .end	= IRQ_AUART2,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART2_RX_DMA,
+	 .end	= IRQ_AUART2_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART2_TX_DMA,
+	 .end	= IRQ_AUART2_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart2_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART2_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = PAGE_SIZE,
+	.timeout = HZ,
+};
+#endif
+
+#ifdef CONFIG_MXS_AUART3_DEVICE_ENABLE
+static struct resource auart3_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART3_PHYS_ADDR,
+	 .end	= AUART3_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART3_RX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART3_RX,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART3_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART3_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART3,
+	 .end	= IRQ_AUART3,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART3_RX_DMA,
+	 .end	= IRQ_AUART3_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART3_TX_DMA,
+	 .end	= IRQ_AUART3_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart3_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART3_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = PAGE_SIZE,
+	.timeout = HZ,
+};
+#endif
+
+#ifdef CONFIG_MXS_AUART4_DEVICE_ENABLE
+static struct resource auart4_resource[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 .start = AUART4_PHYS_ADDR,
+	 .end	= AUART4_PHYS_ADDR + 0xFFF,
+	 },
+	{
+	 .flags = IORESOURCE_DMA,
+	 .start = MXS_DMA_CHANNEL_AHB_APBX_UART4_TX,
+	 .end = MXS_DMA_CHANNEL_AHB_APBX_UART4_TX,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART4,
+	 .end	= IRQ_AUART4,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART4_RX_DMA,
+	 .end	= IRQ_AUART4_RX_DMA,
+	 },
+	{
+	 .flags = IORESOURCE_IRQ,
+	 .start = IRQ_AUART4_TX_DMA,
+	 .end	= IRQ_AUART4_TX_DMA,
+	 },
+};
+
+static struct mxs_auart_plat_data mxs_auart4_platdata = {
+	.fifo_size = 16,
+#ifdef CONFIG_MXS_AUART4_DMA_ENABLE
+	.dma_mode = 1,
+#endif
+	.dma_rx_buffer_size = PAGE_SIZE,
+	.timeout = HZ,
+};
+#endif
+
+void __init mx28_init_auart(void)
+{
+	int i;
+	struct mxs_dev_lookup *plookup;
+	struct platform_device *pdev;
+
+	plookup = mxs_get_devices("mxs-auart");
+	if (plookup == NULL || IS_ERR(plookup))
+		return;
+	for (i = 0; i < plookup->size; i++) {
+		pdev = plookup->pdev + i;
+		switch (pdev->id) {
+#ifdef CONFIG_MXS_AUART0_DEVICE_ENABLE
+		case 0:
+			pdev->resource = auart0_resource;
+			pdev->num_resources = ARRAY_SIZE(auart0_resource);
+			pdev->dev.platform_data = &mxs_auart0_platdata;
+			break;
+#endif
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+		case 1:
+			pdev->resource = auart1_resource;
+			pdev->num_resources = ARRAY_SIZE(auart1_resource);
+			pdev->dev.platform_data = &mxs_auart1_platdata;
+			break;
+#endif
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+		case 2:
+			pdev->resource = auart2_resource;
+			pdev->num_resources = ARRAY_SIZE(auart2_resource);
+			pdev->dev.platform_data = &mxs_auart2_platdata;
+			break;
+#endif
+#ifdef CONFIG_MXS_AUART3_DEVICE_ENABLE
+		case 3:
+			pdev->resource = auart3_resource;
+			pdev->num_resources = ARRAY_SIZE(auart3_resource);
+			pdev->dev.platform_data = &mxs_auart3_platdata;
+			break;
+#endif
+#ifdef CONFIG_MXS_AUART4_DEVICE_ENABLE
+		case 4:
+			pdev->resource = auart4_resource;
+			pdev->num_resources = ARRAY_SIZE(auart4_resource);
+			pdev->dev.platform_data = &mxs_auart4_platdata;
+			break;
+#endif
+		default:
+			break;
+		}
+		mxs_add_device(pdev, 3);
+	}
+}
+#else
+void __init mx28_init_auart(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx28/sleep.S b/arch/arm/mach-mx28/sleep.S
new file mode 100644
index 0000000..438f588
--- /dev/null
+++ b/arch/arm/mach-mx28/sleep.S
@@ -0,0 +1,420 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/hardware.h>
+#include <asm/system.h>
+#include <asm/pgtable-hwdef.h>
+#include <mach/hardware.h>
+#include <mach/regs-power.h>
+#include <mach/regs-rtc.h>
+#include "regs-clkctrl.h"
+#include "regs-dram.h"
+#include "sleep.h"
+
+#define BM_DRAM_CTL17_SREFRESH	0x00000001
+#define HW_CLKCTRL_CPU_ADDR \
+	(MX28_SOC_IO_ADDRESS(CLKCTRL_PHYS_ADDR) + HW_CLKCTRL_CPU)
+#define HW_POWER_MINPWR_ADDR \
+	(MX28_SOC_IO_ADDRESS(POWER_PHYS_ADDR) + HW_POWER_MINPWR)
+#define HW_POWER_RESET_ADDR \
+	(MX28_SOC_IO_ADDRESS(POWER_PHYS_ADDR) + HW_POWER_RESET)
+
+#define HW_DRAM_CTL17_ADDR \
+	(MX28_SOC_IO_ADDRESS(DRAM_PHYS_ADDR) + HW_DRAM_CTL17)
+#define HW_RTC_PERSISTENT0_ADDR \
+	(MX28_SOC_IO_ADDRESS(RTC_PHYS_ADDR) + HW_RTC_PERSISTENT0)
+
+#define PHYS_RAM_START		0x40000000
+
+.global cpu_arm926_switch_mm
+
+		.text
+
+.align 8
+ENTRY(mx28_cpu_standby)
+	@ save registers on stack
+	stmfd	sp!, {r0 - r9, lr}
+
+	adr	r9, __mx28_temp_stack
+
+	@ clean cache
+	ldr	r1, __mx28_flush_cache_addr
+	mov	lr, pc
+	mov	pc, r1
+
+	@ put DRAM into self refresh
+	mov	r0, #(HW_DRAM_CTL17_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(BM_DRAM_CTL17_SREFRESH)
+	str	r1, [r0]
+	@ wait for it to actually happen
+
+	@ do enter standby
+	mov	r0, #(HW_CLKCTRL_CPU_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_CLKCTRL_CPU_ADDR & 0xFF000000)
+	mov	r1, #(1<<12)
+	str	r1, [r0, #4]
+	mov	r2, #0
+	mcr	p15, 0, r2, c7, c0, 4
+	nop
+
+	@ sleeping now...
+
+	@ remove INTERRUPT_WAIT bit
+	str	r1, [r0, #8]
+	nop
+	nop
+	nop
+
+	@ restore normal DRAM mode
+	mov	r0, #(HW_DRAM_CTL17_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	bic	r1, r1, #BM_DRAM_CTL17_SREFRESH
+	str	r1, [r0]
+	@ wait for it to actually happen
+
+	nop
+	nop
+	nop
+
+	@ restore regs and return
+	ldmfd   sp!, {r0 - r9, pc}
+
+	.space	0x100
+__mx28_temp_stack:
+	.word	0
+
+#ifdef CONFIG_STMP378X_RAM_FREQ_SCALING
+#include "emi.inc"
+#endif
+
+__mx28_flush_cache_addr:
+	.word	arm926_flush_kern_cache_all
+
+ENTRY(mx28_standby_alloc_sz)
+	.word	. - mx28_cpu_standby
+
+ENTRY(mx28_cpu_suspend)
+	@ save registers on stack
+	stmfd	sp!, {r1 - r12, lr}
+
+	@ save context
+	mov	r0, #0xd3	@ SVC, Interrupts disabled
+	msr	cpsr, r0
+	mov	r1, #0xC0000000
+	ldr	r1, [r1]
+	mrc	p15, 0, r0, c1, c0, 0
+	str	r0, [r1, #MMUCTL_OFFS]
+	mrc	p15, 0, r0, c15, c1, 0
+	str	r0, [r1, #MMUCPACCESS_OFS]
+	mrc	p15, 0, r0, c2, c0, 0
+	str	r0, [r1, #MMUTTB_OFFS]
+	mrc	p15, 0, r0, c3, c0, 0
+	str	r0, [r1, #MMUDOMAIN_OFFS]
+	mrc	p15, 0, r0, c13, c0, 0
+	str	r0, [r1, #MMUPID_OFFS]
+
+	str	sp, [r1, #SVC_SP_OFFS]
+	mrs	r0, spsr
+	str	r0, [r1, #SVC_SPSR_OFFS]
+
+	add	r2, r1, #FIQ_SPSR_OFFS
+	mov	r0, #0xd1	@ FIQ, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, r8-r12, sp, lr}
+
+	add	r2, r1, #ABT_SPSR_OFFS
+	mov	r0, #0xd7	@ ABT, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #IRQ_SPSR_OFFS
+	mov	r0, #0xd2	@ IRQ, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #UND_SPSR_OFFS
+	mov	r0, #0xdb	@ UND, Interrupts disabled
+	msr	cpsr, r0
+	mrs	r3, spsr
+	stmia	r2!, {r3, sp, lr}
+
+	add	r2, r1, #SYS_SP_OFFS
+	mov	r0, #0xdf	@ SYS, Interrupts disabled
+	msr	cpsr, r0
+	stmia	r2!, {sp, lr}
+
+	add	r2, r1, #SVC_R8_OFFS
+	mov	r0, #0xd3	@ Back to SVC, Interrupts disabled
+	msr	cpsr, r0
+
+	@ save entry point
+	sub	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	mov	r0, #0xC0000000
+	str	r1, [r0]
+	ldr	r1, __mx28_resume_point
+	sub	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	str	r1, [r0, #4]
+	mov	r0, #0
+
+	@ clean cache
+	ldr	r1, __mx28_flush_cache_addr2
+	mov	lr, pc
+	mov	pc, r1
+
+	@ enable internal xtal
+	mov	r2, #(HW_POWER_MINPWR_ADDR & 0x000000FF)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0x0000FF00)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0x00FF0000)
+	orr	r2, r2, #(HW_POWER_MINPWR_ADDR & 0xFF000000)
+	ldr	r1, [r2]
+	orr	r1, r1, #(1<<9)
+	str	r1, [r2]
+	orr	r1, r1, #(1<<8)
+	str	r1, [r2]
+
+	@ enable RTC/RAM clocks
+	mov	r0, #(HW_RTC_PERSISTENT0_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_RTC_PERSISTENT0_ADDR & 0xFF000000)
+	mov	r1, #((1<<4)|(1<<5)|1)
+	str	r1, [r0, #4]
+
+	@ put DRAM into self refresh
+	mov	r0, #(HW_DRAM_CTL17_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(BM_DRAM_CTL17_SREFRESH)
+	str	r1, [r0]
+
+	@ wait for it to actually happen
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	@ power off RAM
+	mov	r0, #(HW_DRAM_CTL17_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_DRAM_CTL17_ADDR & 0xFF000000)
+	ldr	r1, [r0]
+	orr	r1, r1, #(1<<24)
+	str	r1, [r0]
+	nop
+	nop
+	nop
+	nop
+
+	@ do enter sleep
+	mov	r0, #(HW_POWER_RESET_ADDR & 0x000000FF)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0x0000FF00)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0x00FF0000)
+	orr	r0, r0, #(HW_POWER_RESET_ADDR & 0xFF000000)
+	mov	r1, #0xFF000000
+	orr	r1, r1, #0x00FF0000
+	str	r1, [r0, #8]
+	mov	r1, #0x3E000000
+	orr	r1, r1, #0x00770000
+	str	r1, [r0, #4]
+	mov	r1, #2
+	str	r1, [r0, #8]
+	mov	r1, #1
+	str	r1, [r0, #4]
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	@ sleeping now...
+
+__restore_context:
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c10, 4	@ Drain write buffer
+	mcr	p15, 0, r0, c8, c7, 0	@ Invalidate TLBs
+	mcr	p15, 0, r0, c7, c7, 0	@ Invalidate I & D cache
+	nop
+	nop
+
+	mov	r0, #0xd3
+	msr	cpsr, r0
+
+	bl	__create_temp_page_tables
+	mov	r3, r4
+
+	mov	r1, #PHYS_RAM_START
+	ldr	r1, [r1]
+	ldr	r2, [r1, #MMUDOMAIN_OFFS]
+	ldr	r4, [r1, #MMUCPACCESS_OFS]
+	ldr	r5, [r1, #MMUPID_OFFS]
+	ldr	r6, =__resume_after_mmu
+	ldr	r7, [r1, #MMUCTL_OFFS]
+	ldr	r8, [r1, #MMUTTB_OFFS]
+	add	r1, r1, #(0xC0000000 - PHYS_RAM_START)
+	mov	r0, #0
+@	mcr	p15, 0, r4, c15, c1, 0	@ cpaccess
+	mcr	p15, 0, r5, c13, c0, 0	@ pid
+	mcr	p15, 0, r2, c3, c0, 0	@ domain
+	mcr	p15, 0, r3, c2, c0, 0	@ ttb
+	b	1f
+	.align 5
+1:	mov	r0, r0
+	mcr     p15, 0, r7, c1, c0, 0	@ mmuctl
+	nop
+	mrc	p15, 0, r0, c3, c0, 0	@ read id
+	mov	r0, r0
+	mov	r0, r0
+	sub	pc, r6, r5, lsr #32
+	nop
+	nop
+	nop
+__resume_after_mmu:
+	mov	r0, #0
+	mcr	p15, 0, r0, c8, c7, 0	@ Invalidate TLBs
+	mcr	p15, 0, r0, c7, c7, 0	@ Invalidate I & D cache
+
+	mov	r0, r8
+	bl	cpu_arm926_switch_mm
+
+	mov	r0, #0xd1 @FIQ, Interrupts disabled
+	ldr	r2, [r1, #FIQ_SPSR_OFFS]
+	add	r3, r1, #FIQ_R8_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {r8-r12, sp, lr}
+
+	mov	r0, #0xd7 @ABT, Interrupts disabled
+	ldr	r2, [r1, #ABT_SPSR_OFFS]
+	add	r3, r1, #ABT_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xd2 @IRQ, Interrupts disabled
+	ldr	r2, [r1, #IRQ_SPSR_OFFS]
+	add	r3, r1, #IRQ_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xdb @UND, Interrupts disabled
+	ldr	r2, [r1, #UND_SPSR_OFFS]
+	add	r3, r1, #UND_SP_OFFS
+	msr	cpsr, r0
+	msr	spsr, r2
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xdf @SYS, Interrupts disabled
+	add	r3, r1, #SYS_SP_OFFS
+	msr	cpsr, r0
+	ldmia	r3!, {sp, lr}
+
+	mov	r0, #0xd3 @SVC, interrupts disabled
+	ldr	r2, [r1, #SVC_SPSR_OFFS]
+	ldr	r3, [r1, #SVC_SP_OFFS]
+	msr	cpsr, r0
+	msr	spsr, r2
+	mov	sp, r3
+
+#if 0
+	@ select CPU bypass, will be cleared afterwards
+	ldr	r0, =HW_CLKCTRL_CLKSEQ_ADDR
+	ldr	r2, =HW_CLKCTRL_HBUS_ADDR
+	ldr	r4, =HW_CLKCTRL_CPU_ADDR
+	mov	r1, #(1<<7)
+	ldr	r3, [r2]
+	bic	r3, r3, #BM_CLKCTRL_HBUS_DIV
+	orr	r3, r3, #1
+	ldr	r5, [r4]
+	bic	r5, r5, #BM_CLKCTRL_CPU_DIV_CPU
+	orr	r5, r5, #1
+	str	r1, [r0, #4]
+	str	r3, [r2]
+	str	r5, [r4]
+#endif
+	@ restore regs and return
+	ldmfd   sp!, {r1 - r12, lr}
+	mov	pc, lr
+
+__mx28_flush_cache_addr2:
+	.word	arm926_flush_kern_cache_all
+__mx28_resume_point:
+	.word	__restore_context
+ENTRY(mx28_s2ram_alloc_sz)
+	.word	. - mx28_cpu_suspend
+
+__create_temp_page_tables:
+	ldr	r4, =(__temp_ttb - 0xC0000000 + PHYS_RAM_START)
+
+	/*
+	 * Clear the 16K level 1 swapper page table
+	 */
+	mov	r0, r4
+	mov	r3, #0
+	add	r6, r0, #0x4000
+1:	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	str	r3, [r0], #4
+	teq	r0, r6
+	bne	1b
+
+	/*
+	 * Create identity mapping for the area close to where we are to
+	 * cater for the MMU enable.
+	 */
+	mov	r6, pc, lsr #20			@ kind of where we are
+	ldr	r7, =\
+	(PMD_TYPE_SECT | PMD_SECT_BUFFERABLE | PMD_SECT_CACHEABLE\
+	| PMD_BIT4 | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ)
+
+	orr	r3, r7, r6, lsl #20		@ flags + kernel base
+	str	r3, [r4, r6, lsl #2]		@ identity mapping
+
+	mov	r6, r6, lsl #20
+	add	r6, r6, #(0xC0000000-PHYS_RAM_START)
+	str	r3, [r4, r6, lsr #18]
+
+	mov	pc, lr
+	.ltorg
+
+	.section ".sdata", "a"
+	.align 14
+__temp_ttb:
+	.space 0x8000
diff --git a/arch/arm/mach-mx28/sleep.h b/arch/arm/mach-mx28/sleep.h
new file mode 100644
index 0000000..678d552
--- /dev/null
+++ b/arch/arm/mach-mx28/sleep.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+#ifndef __PM_H__
+#define __PM_H__
+
+#include "regs-clkctrl.h"
+
+#define MMUTTB1_MASK		0x00003FE0
+#define MMUTTBC_MASK		0xFFFFFFFC
+
+#define LINK_OFFS	0x08
+#define MMUCTL_OFFS	0x0C
+#define MMUAUXCTL_OFFS	0x10
+#define MMUCPACCESS_OFS	0x14
+#define MMUTTB_OFFS	0x18
+#define MMUPID_OFFS	0x1C
+#define MMUDOMAIN_OFFS	0x20
+#define SVC_R8_OFFS	0x2C
+#define SVC_SP_OFFS	0x40
+#define SVC_SPSR_OFFS	0x44
+#define FIQ_SPSR_OFFS	0x48
+#define FIQ_R8_OFFS	0x4C
+#define FIQ_SP_OFFS	0x60
+#define ABT_R8_OFFS	0x68
+#define ABT_SPSR_OFFS	0x7C
+#define ABT_SP_OFFS	0x80
+#define IRQ_R8_OFFS	0x88
+#define IRQ_SPSR_OFFS	0x9C
+#define IRQ_SP_OFFS	0xA0
+#define UND_SPSR_OFFS	0xA8
+#define UND_SP_OFFS	0xAC
+#define SYS_SPSR_OFFS	0xB4
+#define SYS_SP_OFFS	0xB8
+
+#ifndef __ASSEMBLER__
+#define SLEEP_DATA_FINGERPRINT 0xdeadbeef
+struct sleep_data {
+	u32		fingerprint;
+	u32		wake_addr;
+	u32		link_addr;
+	u32		mmuctl;
+	u32		mmuauxctl;
+	u32		mmucpaccess;
+	u32		mmuttb;
+	u32		mmupid;
+	u32		mmudomain;
+	u32		svc_r6;
+	u32		svc_r7;
+	u32		svc_r8;
+	u32		svc_r9;
+	u32		svc_r10;
+	u32		svc_r11;
+	u32		svc_r12;
+	u32		svc_sp;
+	u32		svc_spsr;
+	u32		fiq_spsr;
+	u32		fiq_r8;
+	u32		fiq_r9;
+	u32		fiq_r10;
+	u32		fiq_r11;
+	u32		fiq_r12;
+	u32		fiq_sp;
+	u32		fiq_lr;
+	u32		abt_r8;
+	u32		abt_r9;
+	u32		abt_r10;
+	u32		abt_r11;
+	u32		abt_r12;
+	u32		abt_spsr;
+	u32		abt_sp;
+	u32		abt_lr;
+	u32		irq_r8;
+	u32		irq_r9;
+	u32		irq_r10;
+	u32		irq_r11;
+	u32		irq_r12;
+	u32		irq_spsr;
+	u32		irq_sp;
+	u32		irq_lr;
+	u32		und_spsr;
+	u32		und_sp;
+	u32		und_lr;
+	u32		sys_spsr;
+	u32		sys_sp;
+	u32		sys_lr;
+	u32		pinmux[0x100];
+	u32		icoll_ctrl;
+	union {
+		u32		prio[0x10];
+		u32		intr[0x80];
+	} icoll;
+	u32		clks[16];
+	u32		old_c00;
+	u32		old_c04;
+};
+
+extern int mx2_s2ram_alloc_sz;
+void mx28_cpu_suspend(void);
+extern int mx28_standby_alloc_sz;
+void mx28_cpu_standby(void);
+void mxs_suspend_timer(void);
+void mxs_resume_timer(void);
+
+void *iram_alloc(unsigned int size, unsigned long *dma_addr);
+void iram_free(unsigned long addr, unsigned int size);
+#endif /* __ASSEMBLER__ */
+#endif /* __PM_H__ */
diff --git a/arch/arm/mach-mx28/usb.h b/arch/arm/mach-mx28/usb.h
new file mode 100644
index 0000000..689603d
--- /dev/null
+++ b/arch/arm/mach-mx28/usb.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+extern void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+					 bool enable);
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx28/usb_dr.c b/arch/arm/mach-mx28/usb_dr.c
new file mode 100644
index 0000000..13344ef
--- /dev/null
+++ b/arch/arm/mach-mx28/usb_dr.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+
+#include <mach/irqs.h>
+#include "usb.h"
+#include "mx28_pins.h"
+
+#define USB_POWER_ENABLE MXS_PIN_TO_GPIO(PINID_AUART2_TX)
+
+static void usb_host_phy_resume(struct fsl_usb2_platform_data *plat)
+{
+	fsl_platform_set_usb_phy_dis(plat, 0);
+}
+
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_clk0");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	return usbotg_init(pdev);
+}
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,	/* 500 mA max power */
+	.platform_resume = usb_host_phy_resume,
+	.transceiver       = "utmi",
+	.phy_regs          = USBPHY0_PHYS_ADDR,
+};
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+		.start	= (u32)USBCTRL0_PHYS_ADDR,
+		.end	= (u32)(USBCTRL0_PHYS_ADDR + 0x1ff),
+		.flags	= IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start	= IRQ_USB0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ * 	dev.platform_data field plugged at run time
+ */
+static struct platform_device dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{}
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev  = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	PDATA->change_ahb_burst = 1;
+	PDATA->ahb_burst_mode = 0;
+	return 0;
+}
+
+void fsl_phy_usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+}
+
+void fsl_phy_usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+void fsl_phy_set_power(struct fsl_xcvr_ops *this,
+			struct fsl_usb2_platform_data *pdata, int on)
+{
+	/* USB_POWER_ENABLE_PIN have request at pin init*/
+	if (pdata->phy_regs != USBPHY1_PHYS_ADDR) {
+		gpio_direction_output(USB_POWER_ENABLE, on);
+		gpio_set_value(USB_POWER_ENABLE, on);
+	}
+}
+
+#ifdef CONFIG_MXS_VBUS_CURRENT_DRAW
+	fs_initcall(usb_dr_init);
+#else
+	module_init(usb_dr_init);
+#endif
diff --git a/arch/arm/mach-mx28/usb_h1.c b/arch/arm/mach-mx28/usb_h1.c
new file mode 100644
index 0000000..4ee6378
--- /dev/null
+++ b/arch/arm/mach-mx28/usb_h1.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/irqs.h>
+#include "usb.h"
+
+static void usb_host_phy_resume(struct fsl_usb2_platform_data *plat)
+{
+	fsl_platform_set_usb_phy_dis(plat, 0);
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_clk1");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	return fsl_usb_host_init(pdev);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.platform_init = fsl_usb_host_init_ext,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.platform_resume = usb_host_phy_resume,
+	.transceiver = "utmi",
+	.phy_regs = USBPHY1_PHYS_ADDR,
+};
+
+static struct resource usbh1_resources[] = {
+	[0] = {
+	       .start = (u32) (USBCTRL1_PHYS_ADDR),
+	       .end = (u32) (USBCTRL1_PHYS_ADDR + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_USB1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static int __init usbh1_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh1_resources,
+			ARRAY_SIZE(usbh1_resources), &usbh1_config);
+
+	return 0;
+}
+
+module_init(usbh1_init);
diff --git a/arch/arm/plat-mxs/Kconfig b/arch/arm/plat-mxs/Kconfig
new file mode 100644
index 0000000..63768f8
--- /dev/null
+++ b/arch/arm/plat-mxs/Kconfig
@@ -0,0 +1,177 @@
+if ARCH_MXS
+
+menu "Freescale i.MXS implementations"
+
+choice
+	prompt "Select i.MXS chip family"
+
+config ARCH_MX28
+	bool "Freescale MX28"
+	select CPU_ARM926T
+	select FIQ
+	select ZONE_DMA
+	select MXS_ICOLL
+	select MXS_DMA_ENGINE
+	select MXS_AUART_DMA_SUPPORT
+	---help---
+	 Support Freescale MX28 chips
+
+config ARCH_MX23
+	bool "Freescale MX23"
+	select CPU_ARM926T
+	select FIQ
+	select ZONE_DMA
+	select MXS_ICOLL
+	select MXS_DMA_ENGINE
+	select MXS_AUART_DMA_SUPPORT
+	---help---
+	Support Freescale MX23 chips
+
+endchoice
+
+if ARCH_MX28
+source arch/arm/mach-mx28/Kconfig
+endif
+
+if ARCH_MX23
+source arch/arm/mach-mx23/Kconfig
+endif
+
+config DMA_ZONE_SIZE
+	int "DMA memory zone size"
+	range 0 32
+	default 16
+	help
+	    This is the size in MB for the DMA zone. The DMA zone is used for
+	    dedicated memory for large contiguous video buffers
+endmenu
+
+config MXS_ICOLL
+	bool
+
+config MXS_EARLY_CONSOLE
+	bool "Enable console early"
+	default y
+	help
+	  Enable console early for kernel debug.
+
+config MXS_DMA_ENGINE
+	bool "Enable DMA ENGINE support"
+	default y
+	help
+	  Support DMA controller on AHB-APBH and AHB-APBX Bridge
+
+config MXS_LRADC
+	bool "Low Resolution ADC support"
+	default y
+	depends on ARCH_MXS
+	help
+	  Enable LRADC support
+
+config MXS_PWM_CHANNELS
+	int
+	default 8
+	help
+	  The number of pwm channel on Freescale MXS platform.
+
+menu "Freescale Application UART:"
+
+config MXS_AUART_DMA_SUPPORT
+	bool
+	depends on MXS_DMA_ENGINE
+	default y
+
+config MXS_AUART_PORTS
+	int
+	default 5
+
+config MXS_AUART0_DEVICE_ENABLE
+	bool "Application uart 0 enabled"
+	default y
+	help
+	  Enable applicatoin uart 0
+
+config MXS_AUART0_DMA_ENABLE
+	bool "Set application uart 0 to dma mode"
+	default n
+	depends on MXS_AUART_DMA_SUPPORT
+	help
+	  Set application uart 0 to dma mode
+
+config MXS_AUART1_DEVICE_ENABLE
+	bool "Application uart 1 enabled"
+	default y
+	help
+	  Enable applicatoin uart 1
+
+config MXS_AUART1_DMA_ENABLE
+	bool "Set application uart 1 to dma mode"
+	default n
+	depends on MXS_AUART_DMA_SUPPORT
+	help
+	  Set application uart 1 to dma mode
+
+config MXS_AUART2_DEVICE_ENABLE
+	bool "Application uart 2 enabled"
+	default y
+	help
+	  Enable applicatoin uart 2
+
+config MXS_AUART2_DMA_ENABLE
+	bool "Set application uart 2 to dma mode"
+	default n
+	depends on MXS_AUART_DMA_SUPPORT
+	help
+	  Set application uart 2 to dma mode
+
+config MXS_AUART3_DEVICE_ENABLE
+	bool "Application uart 3 enabled"
+	default y
+	help
+	  Enable applicatoin uart 3
+
+config MXS_AUART3_DMA_ENABLE
+	bool "Set application uart 3 to dma mode"
+	default n
+	depends on MXS_AUART_DMA_SUPPORT
+	help
+	  Set application uart 3 to dma mode
+
+config MXS_AUART4_DEVICE_ENABLE
+	bool "Application uart 4 enabled"
+	default y
+	help
+	  Enable applicatoin uart 4
+
+config MXS_AUART4_DMA_ENABLE
+	bool "Set application uart 4 to dma mode"
+	default n
+	depends on MXS_AUART_DMA_SUPPORT
+	help
+	  Set application uart 4 to dma mode
+
+config MXS_RAM_FREQ_SCALING
+        bool "RAM frequency scaling support"
+        depends on ARCH_MXS
+        default y
+
+choice
+	prompt "Select MXS RAM chip"
+	depends on MXS_RAM_FREQ_SCALING
+
+config MXS_RAM_MDDR
+	bool "mDDR SDRAM"
+	depends on ARCH_MX23
+config MXS_RAM_DDR
+	bool "DDR SDRAM"
+	depends on ARCH_MX23
+
+endchoice
+
+config IRAM_ALLOC
+        bool
+        default y
+        select GENERIC_ALLOCATOR
+endmenu
+
+endif
diff --git a/arch/arm/plat-mxs/Makefile b/arch/arm/plat-mxs/Makefile
new file mode 100644
index 0000000..e252630
--- /dev/null
+++ b/arch/arm/plat-mxs/Makefile
@@ -0,0 +1,24 @@
+#
+# Makefile for the linux kernel.
+#
+# Object file lists.
+obj-y += core.o clock.o pinctrl.o device.o timer-nomatch.o usb_common.o
+
+obj-$(CONFIG_MXS_TIMER_WITH_MACH) += timer-match.o
+obj-$(CONFIG_IRAM_ALLOC) += iram.o
+obj-$(CONFIG_GENERIC_GPIO) += gpio.o
+
+obj-$(CONFIG_MXS_UNIQUE_ID)        += unique-id.o
+
+obj-$(CONFIG_MXS_ICOLL) += icoll.o
+
+obj-$(CONFIG_MXS_DMA_ENGINE) += dmaengine.o dma-apbh.o dma-apbx.o
+
+obj-$(CONFIG_USB_SUPPORT) += utmixc.o
+
+obj-$(CONFIG_MXS_LRADC) += lradc.o
+# Power Management
+obj-$(CONFIG_CPU_FREQ) += cpufreq.o
+
+# charging/current limitation testing
+
diff --git a/arch/arm/plat-mxs/clock.c b/arch/arm/plat-mxs/clock.c
new file mode 100644
index 0000000..1b98b1e
--- /dev/null
+++ b/arch/arm/plat-mxs/clock.c
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/cpufreq.h>
+
+#include <mach/clock.h>
+
+extern int cpufreq_trig_needed;
+static bool (*mxs_enable_h_autoslow)(bool enable);
+static void (*mxs_set_h_autoslow_flags)(u16 flags);
+
+static DEFINE_SPINLOCK(clockfw_lock);
+
+/*
+ *-------------------------------------------------------------------------
+ * Standard clock functions defined in include/linux/clk.h
+ *-------------------------------------------------------------------------
+ */
+int __clk_get(struct clk *clk)
+{
+	if (clk->ref < CLK_REF_LIMIT)
+		clk->ref += CLK_REF_UNIT;
+	return clk->ref < CLK_REF_LIMIT;
+}
+
+void __clk_put(struct clk *clk)
+{
+	if (clk->ref & CLK_REF_LIMIT)
+		clk->ref -= CLK_REF_UNIT;
+}
+
+static void default_clk_disable(struct clk *clk)
+{
+	if (clk->enable_reg)
+		__raw_writel(clk->enable_bits, clk->enable_reg + SET_REGISTER);
+}
+
+static int default_clk_enable(struct clk *clk)
+{
+	if (clk->enable_reg)
+		__raw_writel(clk->enable_bits, clk->enable_reg + CLR_REGISTER);
+	return 0;
+}
+
+static unsigned long default_get_rate(struct clk *clk)
+{
+	if (clk->parent && clk->parent->get_rate)
+		return clk->parent->get_rate(clk->parent);
+	return 0L;
+}
+
+static void __clk_disable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->ref)
+		return;
+
+	if ((--clk->ref) & CLK_EN_MASK)
+		return;
+
+	if (clk->disable)
+		clk->disable(clk);
+	__clk_disable(clk->secondary);
+	__clk_disable(clk->parent);
+}
+
+static int __clk_enable(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	if ((clk->ref++) & CLK_EN_MASK)
+		return 0;
+	if (clk->parent)
+		__clk_enable(clk->parent);
+	if (clk->secondary)
+		__clk_enable(clk->secondary);
+	if (clk->enable)
+		clk->enable(clk);
+	return 0;
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = 0;
+	int pre_usage;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	pre_usage = (clk->ref & CLK_EN_MASK);
+
+	if (clk->set_sys_dependent_parent)
+		clk->set_sys_dependent_parent(clk);
+
+	ret = __clk_enable(clk);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+	if ((clk->flags & CPU_FREQ_TRIG_UPDATE)
+	    && (pre_usage == 0)) {
+		cpufreq_trig_needed = 1;
+		cpufreq_update_policy(0);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+	if (clk->flags & ALWAYS_ENABLED)
+		return;
+	spin_lock_irqsave(&clockfw_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+	if ((clk->flags & CPU_FREQ_TRIG_UPDATE)
+			&& ((clk->ref & CLK_EN_MASK) == 0)) {
+		cpufreq_trig_needed = 1;
+		cpufreq_update_policy(0);
+	}
+}
+EXPORT_SYMBOL(clk_disable);
+
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->ref & CLK_EN_MASK;
+}
+EXPORT_SYMBOL(clk_get_usecount);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long flags, rate;
+	if (clk == NULL || IS_ERR(clk) || clk->get_rate == NULL)
+		return 0UL;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	rate = clk->get_rate(clk);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->round_rate)
+		return 0;
+
+	if (clk->flags & RATE_FIXED)
+		return 0;
+
+	if (clk->round_rate)
+		return clk->round_rate(clk, rate);
+	return 0;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
+		return ret;
+
+	if (clk->flags & RATE_FIXED)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	ret = clk->set_rate(clk, rate);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+	struct clk *prev_parent;
+
+	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
+	    IS_ERR(parent) || clk->set_parent == NULL ||
+	    parent->get_rate == NULL)
+		return ret;
+
+	if (clk->ref & CLK_EN_MASK)
+		clk_enable(parent);
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	prev_parent = clk->parent;
+	ret = clk->set_parent(clk, parent);
+	if (ret) {
+		spin_unlock_irqrestore(&clockfw_lock, flags);
+		if (clk->ref & CLK_EN_MASK)
+			clk_disable(parent);
+		return ret;
+	}
+
+	clk->parent = parent;
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	if (clk->ref & CLK_EN_MASK)
+		clk_disable(prev_parent);
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	struct clk *ret = NULL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	return clk->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+int clk_register(struct clk_lookup *lookup)
+{
+	if (lookup == NULL || IS_ERR(lookup) ||
+	    lookup->clk == NULL || IS_ERR(lookup->clk))
+		return -EINVAL;
+
+	if (lookup->clk->ref & CLK_REF_LIMIT)
+		return -EEXIST;
+
+	if (!(lookup->clk->enable))
+		lookup->clk->enable = default_clk_enable;
+	if (!(lookup->clk->disable))
+		lookup->clk->disable = default_clk_disable;
+	if (!(lookup->clk->get_rate))
+		lookup->clk->get_rate = default_get_rate;
+
+	clkdev_add(lookup);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk_lookup *lookup)
+{
+	if (lookup == NULL || IS_ERR(lookup) ||
+	    lookup->clk == NULL || IS_ERR(lookup->clk))
+		return;
+
+	if (lookup->clk->ref & CLK_REF_LIMIT)
+		return;
+
+	clkdev_drop(lookup);
+	if (lookup->clk->enable == default_clk_enable)
+		lookup->clk->enable = NULL;
+	if (lookup->clk->disable == default_clk_disable)
+		lookup->clk->disable = NULL;
+	if (lookup->clk->get_rate == default_get_rate)
+		lookup->clk->get_rate = NULL;
+}
+EXPORT_SYMBOL(clk_unregister);
+
+bool clk_enable_h_autoslow(bool enable)
+{
+	unsigned long flags;
+	bool ret = false;
+
+	if (mxs_enable_h_autoslow == NULL)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	ret = mxs_enable_h_autoslow(enable);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable_h_autoslow);
+
+void clk_set_h_autoslow_flags(u16 mask)
+{
+	unsigned long flags;
+
+	if (mxs_set_h_autoslow_flags == NULL)
+		return;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	mxs_set_h_autoslow_flags(mask);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+EXPORT_SYMBOL(clk_set_h_autoslow_flags);
+
+void clk_en_public_h_asm_ctrl(bool (*enable_func)(bool),
+	void (*set_func)(u16))
+{
+	mxs_enable_h_autoslow = enable_func;
+	mxs_set_h_autoslow_flags = set_func;
+}
+EXPORT_SYMBOL(clk_en_public_h_asm_ctrl);
diff --git a/arch/arm/plat-mxs/core.c b/arch/arm/plat-mxs/core.c
new file mode 100644
index 0000000..b804a57
--- /dev/null
+++ b/arch/arm/plat-mxs/core.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/err.h>
+
+#include <asm/proc-fns.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-rtc.h>
+
+void (*machine_arch_reset) (char mode, const char *cmd);
+
+void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+void arch_reset(char mode, const char *cmd)
+{
+	if (machine_arch_reset)
+		machine_arch_reset(mode, cmd);
+	else {
+		void *base = IO_ADDRESS(RTC_PHYS_ADDR);
+
+		__raw_writel(1, base + HW_RTC_WATCHDOG);
+		__raw_writel(0x80000000, base + HW_RTC_PERSISTENT1_SET);
+		__raw_writel(BM_RTC_CTRL_WATCHDOGEN, base + HW_RTC_CTRL_SET);
+	}
+	cpu_reset(0);
+}
+
+static int __mxs_reset_block(void __iomem *hwreg, int just_enable)
+{
+	u32 c;
+	int timeout;
+
+	/* the process of software reset of IP block is done
+	   in several steps:
+
+	   - clear SFTRST and wait for block is enabled;
+	   - clear clock gating (CLKGATE bit);
+	   - set the SFTRST again and wait for block is in reset;
+	   - clear SFTRST and wait for reset completion.
+	 */
+	c = __raw_readl(hwreg);
+	c &= ~(1 << 31);	/* clear SFTRST */
+	__raw_writel(c, hwreg);
+	for (timeout = 1000000; timeout > 0; timeout--)
+		/* still in SFTRST state ? */
+		if ((__raw_readl(hwreg) & (1 << 31)) == 0)
+			break;
+	if (timeout <= 0) {
+		printk(KERN_ERR "%s(%p): timeout when enabling\n",
+		       __func__, hwreg);
+		return -ETIME;
+	}
+
+	c = __raw_readl(hwreg);
+	c &= ~(1 << 30);	/* clear CLKGATE */
+	__raw_writel(c, hwreg);
+
+	if (!just_enable) {
+		c = __raw_readl(hwreg);
+		c |= (1 << 31);	/* now again set SFTRST */
+		__raw_writel(c, hwreg);
+		for (timeout = 1000000; timeout > 0; timeout--)
+			/* poll until CLKGATE set */
+			if (__raw_readl(hwreg) & (1 << 30))
+				break;
+		if (timeout <= 0) {
+			printk(KERN_ERR "%s(%p): timeout when resetting\n",
+			       __func__, hwreg);
+			return -ETIME;
+		}
+
+		c = __raw_readl(hwreg);
+		c &= ~(1 << 31);	/* clear SFTRST */
+		__raw_writel(c, hwreg);
+		for (timeout = 1000000; timeout > 0; timeout--)
+			/* still in SFTRST state ? */
+			if ((__raw_readl(hwreg) & (1 << 31)) == 0)
+				break;
+		if (timeout <= 0) {
+			printk(KERN_ERR "%s(%p): timeout when enabling "
+			       "after reset\n", __func__, hwreg);
+			return -ETIME;
+		}
+
+		c = __raw_readl(hwreg);
+		c &= ~(1 << 30);	/* clear CLKGATE */
+		__raw_writel(c, hwreg);
+	}
+	for (timeout = 1000000; timeout > 0; timeout--)
+		/* still in SFTRST state ? */
+		if ((__raw_readl(hwreg) & (1 << 30)) == 0)
+			break;
+
+	if (timeout <= 0) {
+		printk(KERN_ERR "%s(%p): timeout when unclockgating\n",
+		       __func__, hwreg);
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+int mxs_reset_block(void __iomem *hwreg, int just_enable)
+{
+	int try = 10;
+	int r;
+
+	while (try--) {
+		r = __mxs_reset_block(hwreg, just_enable);
+		if (!r)
+			break;
+		pr_debug("%s: try %d failed\n", __func__, 10 - try);
+	}
+	return r;
+}
diff --git a/arch/arm/plat-mxs/cpufreq.c b/arch/arm/plat-mxs/cpufreq.c
new file mode 100644
index 0000000..a188b21
--- /dev/null
+++ b/arch/arm/plat-mxs/cpufreq.c
@@ -0,0 +1,527 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/notifier.h>
+
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include <asm/system.h>
+#include <mach/regulator.h>
+#include <mach/power.h>
+#include <mach/clock.h>
+#include <mach/bus_freq.h>
+
+static struct regulator *cpu_regulator;
+static struct clk *cpu_clk;
+static struct clk *ahb_clk;
+static struct clk *x_clk;
+static struct clk *emi_clk;
+static struct regulator *vddd;
+static struct regulator *vdddbo;
+static struct regulator *vddio;
+static struct regulator *vdda;
+static struct cpufreq_frequency_table imx_freq_table[7];
+int cpu_freq_khz_min;
+int cpu_freq_khz_max;
+int cpufreq_trig_needed;
+int cur_freq_table_size;
+int lcd_on_freq_table_size;
+int lcd_off_freq_table_size;
+int high_freq_needed;
+
+extern char *ahb_clk_id;
+extern struct profile profiles[OPERATION_WP_SUPPORTED];
+extern int low_freq_used(void);
+
+static int set_freq_table(struct cpufreq_policy *policy, int end_index)
+{
+	int ret = 0;
+	int i;
+	int zero_no = 0;
+
+	for (i = 0; i < end_index; i++) {
+		if (profiles[i].cpu == 0)
+			zero_no++;
+	}
+
+	end_index -= zero_no;
+
+	cpu_freq_khz_min = profiles[0].cpu;
+	cpu_freq_khz_max = profiles[0].cpu;
+	for (i = 0; i < end_index; i++) {
+		imx_freq_table[end_index - 1 - i].index = end_index - i;
+		imx_freq_table[end_index - 1 - i].frequency =
+						profiles[i].cpu;
+
+		if ((profiles[i].cpu) < cpu_freq_khz_min)
+			cpu_freq_khz_min = profiles[i].cpu;
+
+		if ((profiles[i].cpu) > cpu_freq_khz_max)
+			cpu_freq_khz_max = profiles[i].cpu;
+	}
+
+	imx_freq_table[i].index = 0;
+	imx_freq_table[i].frequency = CPUFREQ_TABLE_END;
+
+	policy->cur = clk_get_rate(cpu_clk) / 1000;
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->min = policy->cpuinfo.min_freq = cpu_freq_khz_min;
+	policy->max = policy->cpuinfo.max_freq = cpu_freq_khz_max;
+
+	/* Manual states, that PLL stabilizes in two CLK32 periods */
+	policy->cpuinfo.transition_latency = 1000;
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, imx_freq_table);
+
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed to register i.MXC CPUfreq\n",
+		       __func__);
+		return ret;
+	}
+
+	cpufreq_frequency_table_get_attr(imx_freq_table, policy->cpu);
+
+	return ret;
+}
+
+static int set_op(struct cpufreq_policy *policy, unsigned int target_freq)
+{
+	struct cpufreq_freqs freqs;
+	int ret = 0, i;
+
+	freqs.old = clk_get_rate(cpu_clk) / 1000;
+	freqs.cpu = 0;
+
+/* work around usb problem when in updater firmare  mode*/
+#ifdef CONFIG_MXS_UTP
+	return 0;
+#endif
+	for (i = cur_freq_table_size - 1; i > 0; i--) {
+		if (profiles[i].cpu <= target_freq &&
+		    target_freq < profiles[i - 1].cpu) {
+			freqs.new = profiles[i].cpu;
+			break;
+		}
+
+		if (!vddd && profiles[i].cpu > freqs.old) {
+			/* can't safely set more than now */
+			freqs.new = profiles[i + 1].cpu;
+			break;
+		}
+	}
+
+	if (i == 0)
+		freqs.new = profiles[i].cpu;
+
+	if ((freqs.old / 1000) == (freqs.new / 1000)) {
+		if (regulator_get_voltage(vddd) == profiles[i].vddd)
+			return 0;
+	}
+
+	if (cpu_regulator && (freqs.old < freqs.new)) {
+		ret = regulator_set_current_limit(cpu_regulator,
+			profiles[i].cur, profiles[i].cur);
+		if (ret)
+			return ret;
+	}
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	if (freqs.old > freqs.new) {
+		int ss = profiles[i].ss;
+
+		/* change emi while cpu is fastest to minimize
+		 * time spent changing emiclk
+		 */
+		clk_set_rate(emi_clk, (profiles[i].emi) * 1000);
+		clk_set_rate(cpu_clk, (profiles[i].cpu) * 1000);
+		clk_set_rate(ahb_clk, (profiles[i].ahb) * 1000);
+		/* x_clk order doesn't really matter */
+		clk_set_rate(x_clk, (profiles[i].xbus) * 1000);
+		timing_ctrl_rams(ss);
+
+		if (vddd && vdddbo && vddio && vdda) {
+			ret = regulator_set_voltage(vddd,
+						    profiles[i].vddd,
+						    profiles[i].vddd);
+			if (ret)
+				ret = regulator_set_voltage(vddd,
+							    profiles[i].vddd,
+							    profiles[i].vddd);
+			regulator_set_voltage(vdddbo,
+					      profiles[i].vddd_bo,
+					      profiles[i].vddd_bo);
+
+			ret = regulator_set_voltage(vddio,
+						    profiles[i].vddio,
+						    profiles[i].vddio);
+			if (ret)
+				ret = regulator_set_voltage(vddio,
+							    profiles[i].vddio,
+							    profiles[i].vddio);
+			ret = regulator_set_voltage(vdda,
+						    profiles[i].vdda,
+						    profiles[i].vdda);
+			if (ret)
+				ret = regulator_set_voltage(vdda,
+							    profiles[i].vdda,
+							    profiles[i].vdda);
+		}
+	} else {
+		int ss = profiles[i].ss;
+		if (vddd && vdddbo && vddio && vdda) {
+			ret = regulator_set_voltage(vddd,
+						    profiles[i].vddd,
+						    profiles[i].vddd);
+			if (ret)
+				ret = regulator_set_voltage(vddd,
+							    profiles[i].vddd,
+							    profiles[i].vddd);
+			regulator_set_voltage(vdddbo,
+					      profiles[i].vddd_bo,
+					      profiles[i].vddd_bo);
+			ret = regulator_set_voltage(vddio,
+						    profiles[i].vddio,
+						    profiles[i].vddio);
+			if (ret)
+				ret = regulator_set_voltage(vddio,
+							    profiles[i].vddio,
+							    profiles[i].vddio);
+			ret = regulator_set_voltage(vdda,
+						    profiles[i].vdda,
+						    profiles[i].vdda);
+			if (ret)
+				ret = regulator_set_voltage(vdda,
+							    profiles[i].vdda,
+							    profiles[i].vdda);
+		}
+		/* x_clk order doesn't really matter */
+		clk_set_rate(x_clk, (profiles[i].xbus) * 1000);
+		timing_ctrl_rams(ss);
+		clk_set_rate(cpu_clk, (profiles[i].cpu) * 1000);
+		clk_set_rate(ahb_clk, (profiles[i].ahb) * 1000);
+		clk_set_rate(emi_clk, (profiles[i].emi) * 1000);
+	}
+
+	if (is_hclk_autoslow_ok())
+		clk_set_h_autoslow_flags(profiles[i].h_autoslow_flags);
+	else
+		clk_enable_h_autoslow(false);
+
+	if (high_freq_needed == 0)
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	if (cpu_regulator && (freqs.old > freqs.new))   /* will not fail */
+		regulator_set_current_limit(cpu_regulator,
+					    profiles[i].cur,
+					    profiles[i].cur);
+
+	if (high_freq_needed == 1) {
+		high_freq_needed = 0;
+		cur_freq_table_size = lcd_on_freq_table_size;
+		set_freq_table(policy, cur_freq_table_size);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+
+	return ret;
+}
+
+static int calc_frequency_khz(int target, unsigned int relation)
+{
+	int i;
+
+	if (target * 1000 == clk_get_rate(cpu_clk))
+		return target;
+
+	if (relation == CPUFREQ_RELATION_H) {
+		for (i = cur_freq_table_size - 1; i >= 0; i--) {
+			if (imx_freq_table[i].frequency <= target)
+				return imx_freq_table[i].frequency;
+		}
+	} else if (relation == CPUFREQ_RELATION_L) {
+		for (i = 0; i < cur_freq_table_size; i++) {
+			if (imx_freq_table[i].frequency >= target)
+				return imx_freq_table[i].frequency;
+		}
+}
+
+	printk(KERN_ERR "Error: No valid cpufreq relation\n");
+	return cpu_freq_khz_max;
+}
+
+static int mxs_target(struct cpufreq_policy *policy,
+			  unsigned int target_freq,
+			  unsigned int relation)
+{
+	int freq_KHz;
+	struct cpufreq_freqs freqs;
+	int low_freq_bus_ready = 0;
+
+	if (cpufreq_trig_needed  == 1) {
+		/* Set the current working point. */
+		cpufreq_trig_needed = 0;
+		target_freq = clk_get_rate(cpu_clk) / 1000;
+		low_freq_bus_ready = low_freq_used();
+
+		if ((target_freq < LCD_ON_CPU_FREQ_KHZ) &&
+		    (low_freq_bus_ready == 0)) {
+			high_freq_needed = 1;
+			target_freq = LCD_ON_CPU_FREQ_KHZ;
+			goto change_freq;
+		}
+
+		target_freq = clk_get_rate(cpu_clk) / 1000;
+		freq_KHz = calc_frequency_khz(target_freq, relation);
+
+		freqs.old = target_freq;
+		freqs.new = freq_KHz;
+		freqs.cpu = 0;
+		freqs.flags = 0;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		low_freq_bus_ready = low_freq_used();
+		if (low_freq_bus_ready) {
+			int i;
+			cur_freq_table_size = lcd_off_freq_table_size;
+			/* find current table index to get
+			 * hbus autoslow flags and enable hbus autoslow.
+			 */
+			for (i = cur_freq_table_size - 1; i > 0; i--) {
+				if (profiles[i].cpu <= target_freq &&
+					target_freq < profiles[i - 1].cpu) {
+					clk_set_h_autoslow_flags(
+					profiles[i].h_autoslow_flags);
+					break;
+				}
+			}
+		} else {
+			cur_freq_table_size = lcd_on_freq_table_size;
+			clk_enable_h_autoslow(false);
+		}
+
+		set_freq_table(policy, cur_freq_table_size);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+		return 0;
+}
+
+	/*
+	 * Some governors do not respects CPU and policy lower limits
+	 * which leads to bad things (division by zero etc), ensure
+	 * that such things do not happen.
+	 */
+change_freq:	if (target_freq < policy->cpuinfo.min_freq)
+		target_freq = policy->cpuinfo.min_freq;
+
+	if (target_freq < policy->min)
+		target_freq = policy->min;
+
+	freq_KHz = calc_frequency_khz(target_freq, relation);
+	return set_op(policy, freq_KHz);
+	}
+
+static unsigned int mxs_getspeed(unsigned int cpu)
+{
+	if (cpu)
+		return 0;
+
+	return clk_get_rate(cpu_clk) / 1000;
+}
+
+
+static int mxs_verify_speed(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	return cpufreq_frequency_table_verify(policy, imx_freq_table);
+}
+
+static int __init mxs_cpu_init(struct cpufreq_policy *policy)
+{
+	int ret = 0;
+	int i;
+
+	cpu_clk = clk_get(NULL, "cpu");
+	if (IS_ERR(cpu_clk)) {
+		ret = PTR_ERR(cpu_clk);
+		goto out_cpu;
+	}
+
+	ahb_clk = clk_get(NULL, "h");
+	if (IS_ERR(ahb_clk)) {
+		ret = PTR_ERR(ahb_clk);
+		goto out_ahb;
+	}
+
+	x_clk = clk_get(NULL, "x");
+	if (IS_ERR(ahb_clk)) {
+		ret = PTR_ERR(x_clk);
+		goto out_x;
+	}
+
+	emi_clk = clk_get(NULL, "emi");
+	if (IS_ERR(emi_clk)) {
+		ret = PTR_ERR(emi_clk);
+		goto out_emi;
+	}
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	cpu_regulator = regulator_get(NULL, "cpufreq-1");
+	if (IS_ERR(cpu_regulator)) {
+		printk(KERN_ERR "%s: failed to get CPU regulator\n", __func__);
+		cpu_regulator = NULL;
+		ret = PTR_ERR(cpu_regulator);
+		goto out_cur;
+	}
+
+	vddd = regulator_get(NULL, "vddd");
+	if (IS_ERR(vddd)) {
+		printk(KERN_ERR "%s: failed to get vddd regulator\n", __func__);
+		vddd = NULL;
+		ret = PTR_ERR(vddd);
+		goto out_cur;
+	}
+
+	vdddbo = regulator_get(NULL, "vddd_bo");
+	if (IS_ERR(vdddbo)) {
+		vdddbo = NULL;
+		pr_warning("unable to get vdddbo");
+		ret = PTR_ERR(vdddbo);
+		goto out_cur;
+	}
+
+	vddio = regulator_get(NULL, "vddio");
+	if (IS_ERR(vddio)) {
+		vddio = NULL;
+		pr_warning("unable to get vddio");
+		ret = PTR_ERR(vddio);
+		goto out_cur;
+	}
+
+	vdda = regulator_get(NULL, "vdda");
+	if (IS_ERR(vdda)) {
+		vdda = NULL;
+		pr_warning("unable to get vdda");
+		ret = PTR_ERR(vdda);
+		goto out_cur;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(profiles); i++) {
+		if ((profiles[i].cpu) == LCD_ON_CPU_FREQ_KHZ) {
+			lcd_on_freq_table_size = i + 1;
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(profiles)) {
+		pr_warning("unable to find frequency for LCD on");
+		printk(KERN_ERR "lcd_on_freq_table_size=%d\n",
+			lcd_on_freq_table_size);
+		goto out_cur;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(profiles); i++) {
+		if ((profiles[i].cpu) == 0) {
+			lcd_off_freq_table_size = i;
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(profiles))
+		lcd_off_freq_table_size = i;
+
+	/* Set the current working point. */
+	set_freq_table(policy, lcd_on_freq_table_size);
+	cpufreq_trig_needed = 0;
+	high_freq_needed = 0;
+	cur_freq_table_size = lcd_on_freq_table_size;
+
+	printk(KERN_INFO "%s: cpufreq init finished\n", __func__);
+	return 0;
+out_cur:
+	if (cpu_regulator)
+		regulator_put(cpu_regulator);
+	if (vddd)
+		regulator_put(vddd);
+	if (vddio)
+		regulator_put(vddio);
+	if (vdda)
+		regulator_put(vdda);
+
+	clk_put(emi_clk);
+out_emi:
+	clk_put(x_clk);
+out_x:
+	clk_put(ahb_clk);
+out_ahb:
+	clk_put(cpu_clk);
+out_cpu:
+	return ret;
+}
+
+static int mxs_cpu_exit(struct cpufreq_policy *policy)
+{
+	cpufreq_frequency_table_put_attr(policy->cpu);
+
+	/* Reset CPU to 392MHz */
+	set_op(policy, profiles[1].cpu);
+
+	clk_put(cpu_clk);
+	regulator_put(cpu_regulator);
+	return 0;
+}
+
+static struct cpufreq_driver mxs_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= mxs_verify_speed,
+	.target		= mxs_target,
+	.get		= mxs_getspeed,
+	.init		= mxs_cpu_init,
+	.exit		= mxs_cpu_exit,
+	.name		= "mxs",
+};
+
+static int __devinit mxs_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&mxs_driver);
+}
+
+static void mxs_cpufreq_exit(void)
+{
+	cpufreq_unregister_driver(&mxs_driver);
+}
+
+module_init(mxs_cpufreq_init);
+module_exit(mxs_cpufreq_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("CPUfreq driver for i.MX");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/plat-mxs/device.c b/arch/arm/plat-mxs/device.c
new file mode 100644
index 0000000..0274089
--- /dev/null
+++ b/arch/arm/plat-mxs/device.c
@@ -0,0 +1,795 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/gpmi-nfc.h>
+
+#include <mach/device.h>
+
+static int mxs_device_num;
+static int mxs_device_done;
+static DEFINE_MUTEX(device_mutex);
+static struct list_head mxs_device_level[] = {
+	LIST_HEAD_INIT(mxs_device_level[0]),
+	LIST_HEAD_INIT(mxs_device_level[1]),
+	LIST_HEAD_INIT(mxs_device_level[2]),
+	LIST_HEAD_INIT(mxs_device_level[3]),
+};
+
+static u64 common_dmamask = DMA_BIT_MASK(32);
+
+void mxs_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+int mxs_add_devices(struct platform_device *pdev, int num, int level)
+{
+	int i, ret = -ENOMEM;
+	if (pdev == NULL || IS_ERR(pdev) || num <= 0)
+		return -EINVAL;
+
+	if (level < 0)
+		level = 0;
+	else if (level >= ARRAY_SIZE(mxs_device_level))
+		level = ARRAY_SIZE(mxs_device_level) - 1;
+
+	mutex_lock(&device_mutex);
+	if (mxs_device_done) {
+		ret = 0;
+		for (i = 0; i < num; i++)
+			ret |= platform_device_register(pdev + i);
+		goto out;
+	}
+
+	if ((mxs_device_num + num) > MXS_MAX_DEVICES)
+		goto out;
+	mxs_device_num += num;
+	for (i = 0; i < num; i++)
+		list_add_tail(&pdev[i].dev.devres_head,
+			      &mxs_device_level[level]);
+	ret = 0;
+out:
+	mutex_unlock(&device_mutex);
+	return ret;
+}
+
+int mxs_add_device(struct platform_device *pdev, int level)
+{
+	return mxs_add_devices(pdev, 1, level);
+}
+
+#if defined(CONFIG_SERIAL_MXS_DUART) || \
+	defined(CONFIG_SERIAL_MXS_DUART_MODULE)
+static struct platform_device mxs_duart = {
+	.name = "mxs-duart",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_MXS_DMA_ENGINE)
+static struct platform_device mxs_dma[] = {
+	{
+	 .name = "mxs-dma-apbh",
+	 .id = 0,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 },
+	 },
+	{
+	 .name = "mxs-dma-apbx",
+	 .id = 0,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 },
+	 },
+};
+#endif
+
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+static struct platform_device mxs_i2c[] = {
+#if defined(CONFIG_I2C_MXS_SELECT0)
+	{
+	 .name	= "mxs-i2c",
+	 .id	= 0,
+	 .dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+#endif
+#if defined(CONFIG_I2C_MXS_SELECT1)
+	{
+	 .name	= "mxs-i2c",
+	 .id	= 1,
+	 .dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+#endif
+};
+#endif
+
+#if defined(CONFIG_MTD_NAND_GPMI_NFC) || \
+	defined(CONFIG_MTD_NAND_GPMI_NFC_MODULE)
+static struct platform_device gpmi_nfc = {
+	.name = GPMI_NFC_DRIVER_NAME,
+	.id = 0,
+	.dev = {
+		.dma_mask          = &common_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		.release           = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_MMC_MXS) || \
+	defined(CONFIG_MMC_MXS_MODULE)
+static struct platform_device mxs_mmc[] = {
+	{
+	 .name	= "mxs-mmc",
+	 .id	= 0,
+	 .dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+	{
+	 .name	= "mxs-mmc",
+	 .id	= 1,
+	 .dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+};
+#endif
+
+#if defined(CONFIG_SPI_MXS) || defined(CONFIG_SPI_MXS_MODULE)
+static struct platform_device mxs_spi[] = {
+	{
+	 .name	= "mxs-spi",
+	 .id	= 0,
+	 .dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+	 },
+};
+#endif
+
+#if defined(CONFIG_MXS_WATCHDOG) || defined(CONFIG_MXS_WATCHDOG_MODULE)
+static struct platform_device mxs_wdt = {
+	.name = "mxs-wdt",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_FEC) || \
+	defined(CONFIG_FEC_MODULE)
+static struct platform_device mxs_fec[] = {
+	{
+	.name = "fec",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+	},
+	{
+	.name = "fec",
+	.id = 1,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+	},
+};
+#endif
+
+#if defined(CONFIG_FEC_L2SWITCH)
+static struct platform_device mxs_l2switch[] = {
+	{
+	.name = "mxs-l2switch",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+	},
+};
+#endif
+
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+static struct platform_device mxs_fb = {
+	.name	= "mxs-fb",
+	.id	= 0,
+	.dev = {
+		.dma_mask	       = &common_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXS) || \
+	defined(CONFIG_BACKLIGHT_MXS_MODULE)
+struct platform_device mxs_bl = {
+	.name	= "mxs-bl",
+	.id	= 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_VIDEO_MXS_PXP) || \
+	defined(CONFIG_VIDEO_MXS_PXP_MODULE)
+static struct platform_device mxs_pxp = {
+	.name		= "mxs-pxp",
+	.id		= 0,
+	.dev		= {
+		.release = mxs_nop_release,
+		.dma_mask		= &common_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+};
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXS) || defined(CONFIG_RTC_DRV_MXS_MODULE)
+static struct platform_device mxs_rtc = {
+	.name = "mxs-rtc",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#ifdef CONFIG_MXS_LRADC
+static struct platform_device mxs_lradc = {
+	.name = "mxs-lradc",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_KEYBOARD_MXS) || defined(CONFIG_KEYBOARD_MXS_MODULE)
+static struct platform_device mxs_kbd = {
+	.name = "mxs-kbd",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
+static struct platform_device mxs_ts = {
+	.name = "mxs-ts",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_SERIAL_MXS_AUART) || defined(CONFIG_SERIAL_MXS_AUART_MODULE)
+static struct platform_device mxs_auart[] = {
+#ifdef CONFIG_MXS_AUART0_DEVICE_ENABLE
+	{
+	 .name = "mxs-auart",
+	 .id = 0,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 .dma_mask = &common_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+		 },
+	 },
+#endif
+#ifdef CONFIG_MXS_AUART1_DEVICE_ENABLE
+	{
+	 .name = "mxs-auart",
+	 .id = 1,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 .dma_mask = &common_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+		 },
+	 },
+#endif
+#ifdef CONFIG_MXS_AUART2_DEVICE_ENABLE
+	{
+	 .name = "mxs-auart",
+	 .id = 2,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 .dma_mask = &common_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+		 },
+	 },
+#endif
+#ifdef CONFIG_MXS_AUART3_DEVICE_ENABLE
+	{
+	 .name = "mxs-auart",
+	 .id = 3,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 .dma_mask = &common_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+		 },
+	 },
+#endif
+#ifdef CONFIG_MXS_AUART4_DEVICE_ENABLE
+	{
+	 .name = "mxs-auart",
+	 .id = 4,
+	 .dev = {
+		 .release = mxs_nop_release,
+		 .dma_mask = &common_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+		 },
+	},
+#endif
+};
+#endif
+
+#if defined(CONFIG_LEDS_MXS) || defined(CONFIG_LEDS_MXS_MODULE)
+static struct platform_device mxs_led = {
+	.name = "mxs-leds",
+	.id = 0,
+	.dev = {
+		 .release = mxs_nop_release,
+		 },
+};
+#endif
+
+#if defined(CONFIG_CAN_FLEXCAN) || \
+	defined(CONFIG_CAN_FLEXCAN_MODULE)
+static struct platform_device mxs_flexcan[] = {
+	{
+	.name = "FlexCAN",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+	},
+	{
+	.name = "FlexCAN",
+	.id = 1,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+	},
+};
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_DCP)
+static struct platform_device mxs_dcp = {
+	.name = "dcp",
+	.id = 0,
+	.dev	= {
+		.release = mxs_nop_release,
+		.dma_mask	= &common_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+#endif
+
+#if defined(CONFIG_BATTERY_MXS)
+static struct platform_device mxs_battery = {
+	.name   = "mxs-battery",
+	.id = 0,
+	.dev	= {
+		.release = mxs_nop_release,
+		} ,
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_SGTL5000) || \
+	defined(CONFIG_SND_SOC_SGTL5000_MODULE)
+static struct platform_device mxs_sgtl5000[] = {
+	{
+	.name = "mxs-sgtl5000",
+	.id = 0,
+	.dev =	{
+		.release = mxs_nop_release,
+		},
+	},
+};
+#endif
+
+#if defined(CONFIG_MXS_VIIM) || defined(CONFIG_MXS_VIIM_MODULE)
+struct platform_device mxs_viim = {
+	.name   = "mxs_viim",
+	.id     = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+	defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+static struct platform_device mxs_spdif[] = {
+	{
+	.name = "mxs-spdif",
+	.id = 0,
+	.dev =	{
+		.release = mxs_nop_release,
+		},
+	},
+};
+#endif
+
+#if defined(CONFIG_SND_MXS_SOC_ADC) || \
+	defined(CONFIG_SND_MXS_SOC_ADC_MODULE)
+static struct platform_device mxs_adc = {
+	.name = "mxs-adc-audio",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+static struct platform_device busfreq_device = {
+	.name = "busfreq",
+	.id = 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+
+#ifdef CONFIG_MXS_PERSISTENT
+static struct platform_device mxs_persistent = {
+	.name			= "mxs-persistent",
+	.id			= 0,
+	.dev = {
+		.release = mxs_nop_release,
+		},
+};
+#endif
+
+static inline void mxs_init_busfreq(void)
+{
+	(void)platform_device_register(&busfreq_device);
+}
+
+static struct mxs_dev_lookup dev_lookup[] = {
+#if defined(CONFIG_SERIAL_MXS_DUART) || \
+	defined(CONFIG_SERIAL_MXS_DUART_MODULE)
+	{
+	 .name = "mxs-duart",
+	 .size = 1,
+	 .pdev = &mxs_duart,
+	 },
+#endif
+#if defined(CONFIG_MXS_DMA_ENGINE)
+	{
+	 .name = "mxs-dma",
+	 .size = ARRAY_SIZE(mxs_dma),
+	 .pdev = mxs_dma,
+	 },
+#endif
+
+#if defined(CONFIG_I2C_MXS) || \
+	defined(CONFIG_I2C_MXS_MODULE)
+	{
+	 .name	= "mxs-i2c",
+	 .size	= ARRAY_SIZE(mxs_i2c),
+	 .pdev	= mxs_i2c,
+	 },
+#endif
+
+#if defined(CONFIG_MTD_NAND_GPMI_NFC) || \
+	defined(CONFIG_MTD_NAND_GPMI_NFC_MODULE)
+	{
+	.name = GPMI_NFC_DRIVER_NAME,
+	.size = 1,
+	.pdev = &gpmi_nfc,
+	},
+#endif
+
+#if defined(CONFIG_MMC_MXS) || \
+	defined(CONFIG_MMC_MXS_MODULE)
+	{
+	.name = "mxs-mmc",
+	.size = ARRAY_SIZE(mxs_mmc),
+	.pdev = mxs_mmc,
+	},
+#endif
+
+#if defined(CONFIG_SPI_MXS) || defined(CONFIG_SPI_MXS_MODULE)
+	{
+	.name = "mxs-spi",
+	.size = ARRAY_SIZE(mxs_spi),
+	.pdev = mxs_spi,
+	},
+#endif
+
+#if defined(CONFIG_MXS_WATCHDOG) || defined(CONFIG_MXS_WATCHDOG_MODULE)
+	{
+	 .name = "mxs-wdt",
+	 .size = 1,
+	 .pdev = &mxs_wdt,
+	 },
+#endif
+
+#if defined(CONFIG_RTC_DRV_MXS) || defined(CONFIG_RTC_DRV_MXS_MODULE)
+	{
+	 .name = "mxs-rtc",
+	 .size = 1,
+	 .pdev = &mxs_rtc,
+	 },
+#endif
+
+#if defined(CONFIG_MXS_PERSISTENT)
+	{
+	.name = "mxs-persistent",
+	.size = 1,
+	.pdev = &mxs_persistent,
+	},
+#endif
+
+#if defined(CONFIG_FB_MXS) || defined(CONFIG_FB_MXS_MODULE)
+	{
+	 .name	= "mxs-fb",
+	 .size	= 1,
+	 .pdev	= &mxs_fb,
+	 },
+#endif
+#if defined(CONFIG_BACKLIGHT_MXS) || \
+	defined(CONFIG_BACKLIGHT_MXS_MODULE)
+	{
+	 .name	= "mxs-bl",
+	 .size	= 1,
+	 .pdev	= &mxs_bl,
+	 },
+#endif
+
+#if defined(CONFIG_VIDEO_MXS_PXP) || \
+	defined(CONFIG_VIDEO_MXS_PXP_MODULE)
+	{
+	 .name	= "mxs-pxp",
+	 .size	= 1,
+	 .pdev	= &mxs_pxp,
+	 },
+#endif
+
+#if defined(CONFIG_MXS_VIIM) || defined(CONFIG_MXS_VIIM_MODULE)
+	{
+	 .name	= "mxs_viim",
+	 .size	= 1,
+	 .pdev	= &mxs_viim,
+	 },
+#endif
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+	{
+	.name = "mxs-fec",
+	.size = ARRAY_SIZE(mxs_fec),
+	.pdev = mxs_fec,
+	},
+#endif
+
+#if defined(CONFIG_FEC_L2SWITCH)
+	{
+	.name = "mxs-l2switch",
+	.size = ARRAY_SIZE(mxs_l2switch),
+	.pdev = mxs_l2switch,
+	},
+#endif
+
+#ifdef CONFIG_MXS_LRADC
+	{
+	 .name = "mxs-lradc",
+	 .size = 1,
+	 .pdev = &mxs_lradc,
+	 },
+#endif
+
+#if defined(CONFIG_KEYBOARD_MXS) || defined(CONFIG_KEYBOARD_MXS_MODULE)
+	{
+	 .name = "mxs-kbd",
+	 .size = 1,
+	 .pdev = &mxs_kbd,
+	 },
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_MXS) || defined(CONFIG_TOUCHSCREEN_MXS_MODULE)
+	{
+	 .name = "mxs-ts",
+	 .size = 1,
+	 .pdev = &mxs_ts,
+	},
+#endif
+
+#if defined(CONFIG_SERIAL_MXS_AUART) || defined(CONFIG_SERIAL_MXS_AUART_MODULE)
+	{
+	 .name = "mxs-auart",
+	 .size = ARRAY_SIZE(mxs_auart),
+	 .pdev = mxs_auart,
+	 },
+#endif
+
+#if defined(CONFIG_LEDS_MXS) || defined(CONFIG_LEDS_MXS_MODULE)
+	{
+	 .name = "mxs-leds",
+	 .size = 1,
+	 .pdev = &mxs_led,
+	 },
+#endif
+
+#if defined(CONFIG_CAN_FLEXCAN) || \
+	defined(CONFIG_CAN_FLEXCAN_MODULE)
+	{
+	.name = "FlexCAN",
+	.size = ARRAY_SIZE(mxs_flexcan),
+	.pdev = mxs_flexcan,
+	},
+#endif
+
+#if defined(CONFIG_CRYPTO_DEV_DCP)
+	{
+	.name = "dcp",
+	.size = 1,
+	.pdev = &mxs_dcp,
+	},
+#endif
+
+#if defined(CONFIG_BATTERY_MXS)
+	{
+	 .name = "mxs-battery",
+	 .size = 1,
+	 .pdev = &mxs_battery,
+	},
+#endif
+
+#if defined(CONFIG_SND_SOC_SGTL5000) || \
+	defined(CONFIG_SND_SOC_SGTL5000_MODULE)
+	{
+	.name = "mxs-sgtl5000",
+	.size = ARRAY_SIZE(mxs_sgtl5000),
+	.pdev = mxs_sgtl5000,
+	},
+#endif
+
+#if defined(CONFIG_SND_SOC_MXS_SPDIF) || \
+	defined(CONFIG_SND_SOC_MXS_SPDIF_MODULE)
+	{
+	.name = "mxs-spdif",
+	.size = ARRAY_SIZE(mxs_spdif),
+	.pdev = mxs_spdif,
+	},
+#endif
+
+#if defined(CONFIG_SND_MXS_SOC_ADC) || \
+	defined(CONFIG_SND_MXS_SOC_ADC_MODULE)
+	{
+	.name = "mxs-adc",
+	.size = 1,
+	.pdev = &mxs_adc,
+	},
+#endif
+
+};
+
+struct platform_device *mxs_get_device(char *name, int id)
+{
+	int i, j;
+	struct mxs_dev_lookup *lookup;
+	struct platform_device *pdev = (struct platform_device *)-ENODEV;
+	if (name == NULL || id < 0 || IS_ERR(name))
+		return (struct platform_device *)-EINVAL;
+
+	mutex_lock(&device_mutex);
+	for (i = 0; i < ARRAY_SIZE(dev_lookup); i++) {
+		lookup = &dev_lookup[i];
+		if (!strcmp(name, lookup->name)) {
+			if (test_bit(0, &lookup->lock)) {
+				pdev = (struct platform_device *)-EBUSY;
+				break;
+			}
+
+			if (id >= lookup->size)
+				break;
+			for (j = 0; j < lookup->size; j++) {
+				if (id == (lookup->pdev[j]).id) {
+					pdev = &lookup->pdev[j];
+					break;
+				}
+			}
+			break;
+		}
+
+	}
+	mutex_unlock(&device_mutex);
+	return pdev;
+}
+
+struct mxs_dev_lookup *mxs_get_devices(char *name)
+{
+	int i;
+	struct mxs_dev_lookup *lookup;
+	if (name == NULL || IS_ERR(name))
+		return (struct mxs_dev_lookup *)-EINVAL;
+
+	mutex_lock(&device_mutex);
+	for (i = 0; i < ARRAY_SIZE(dev_lookup); i++) {
+		lookup = &dev_lookup[i];
+		if (!strcmp(name, lookup->name)) {
+			if (test_and_set_bit(0, &lookup->lock))
+				lookup = (struct mxs_dev_lookup *)-EBUSY;
+			mutex_unlock(&device_mutex);
+			return lookup;
+		}
+
+	}
+	mutex_unlock(&device_mutex);
+	return (struct mxs_dev_lookup *)-ENODEV;
+}
+
+int mxs_device_init(void)
+{
+	int i, ret = 0;
+	struct list_head *p, *n;
+	struct device *dev;
+	struct platform_device *pdev;
+	mutex_lock(&device_mutex);
+	mxs_device_done = 1;
+	mutex_unlock(&device_mutex);
+
+	for (i = 0; i < ARRAY_SIZE(mxs_device_level); i++) {
+		list_for_each_safe(p, n, mxs_device_level + i) {
+			dev = list_entry(p, struct device, devres_head);
+			list_del(p);
+			pdev = container_of(dev, struct platform_device, dev);
+			ret |= platform_device_register(pdev);
+		}
+	}
+
+#if defined(CONFIG_BACKLIGHT_MXS) || \
+	defined(CONFIG_BACKLIGHT_MXS_MODULE)
+	platform_device_register(&mxs_bl);
+#endif
+
+	mxs_init_busfreq();
+	return ret;
+}
+
+device_initcall(mxs_device_init);
diff --git a/arch/arm/plat-mxs/dma-apbh.c b/arch/arm/plat-mxs/dma-apbh.c
new file mode 100644
index 0000000..e7fb960
--- /dev/null
+++ b/arch/arm/plat-mxs/dma-apbh.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/dmaengine.h>
+
+#include <mach/regs-apbh.h>
+#ifndef BM_APBH_CTRL0_APB_BURST_EN
+#define BM_APBH_CTRL0_APB_BURST_EN BM_APBH_CTRL0_APB_BURST4_EN
+#endif
+
+static int mxs_dma_apbh_enable(struct mxs_dma_chan *pchan, unsigned int chan)
+{
+	unsigned int sem;
+	struct mxs_dma_device *pdev = pchan->dma;
+	struct mxs_dma_desc *pdesc;
+
+	pdesc = list_first_entry(&pchan->active, struct mxs_dma_desc, node);
+	if (pdesc == NULL)
+		return -EFAULT;
+
+	sem = __raw_readl(pdev->base + HW_APBH_CHn_SEMA(chan));
+	sem = (sem & BM_APBH_CHn_SEMA_PHORE) >> BP_APBH_CHn_SEMA_PHORE;
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY) {
+		if (pdesc->cmd.cmd.bits.chain == 0)
+			return 0;
+		if (sem < 2) {
+			if (!sem)
+				return 0;
+			pdesc = list_entry(pdesc->node.next,
+					   struct mxs_dma_desc, node);
+			__raw_writel(mxs_dma_cmd_address(pdesc),
+				     pdev->base + HW_APBH_CHn_NXTCMDAR(chan));
+		}
+		sem = pchan->pending_num;
+		pchan->pending_num = 0;
+		__raw_writel(BF_APBH_CHn_SEMA_INCREMENT_SEMA(sem),
+			     pdev->base + HW_APBH_CHn_SEMA(chan));
+		pchan->active_num += sem;
+		return 0;
+	}
+	pchan->active_num += pchan->pending_num;
+	pchan->pending_num = 0;
+	__raw_writel(mxs_dma_cmd_address(pdesc),
+		     pdev->base + HW_APBH_CHn_NXTCMDAR(chan));
+	__raw_writel(pchan->active_num, pdev->base + HW_APBH_CHn_SEMA(chan));
+	__raw_writel(1 << chan, pdev->base + HW_APBH_CTRL0_CLR);
+	return 0;
+}
+
+static void mxs_dma_apbh_disable(struct mxs_dma_chan *pchan, unsigned int chan)
+{
+	struct mxs_dma_device *pdev = pchan->dma;
+	__raw_writel(1 << (chan + BP_APBH_CTRL0_CLKGATE_CHANNEL),
+		pdev->base + HW_APBH_CTRL0_SET);
+}
+
+static void mxs_dma_apbh_reset(struct mxs_dma_device *pdev, unsigned int chan)
+{
+#ifdef CONFIG_ARCH_MX28
+	__raw_writel(1 << (chan + BP_APBH_CHANNEL_CTRL_RESET_CHANNEL),
+		     pdev->base + HW_APBH_CHANNEL_CTRL_SET);
+#endif
+
+#ifdef CONFIG_ARCH_MX23
+	__raw_writel(1 << (chan + BP_APBH_CTRL0_RESET_CHANNEL),
+				pdev->base + HW_APBH_CTRL0_SET);
+#endif
+}
+
+static void mxs_dma_apbh_freeze(struct mxs_dma_device *pdev, unsigned int chan)
+{
+#ifdef CONFIG_ARCH_MX28
+	__raw_writel(1 << chan, pdev->base + HW_APBH_CHANNEL_CTRL_SET);
+#endif
+
+#ifdef CONFIG_ARCH_MX23
+	__raw_writel(1 << (chan + BP_APBH_CTRL0_FREEZE_CHANNEL),
+				pdev->base + HW_APBH_CTRL0_SET);
+#endif
+}
+
+static void
+mxs_dma_apbh_unfreeze(struct mxs_dma_device *pdev, unsigned int chan)
+{
+#ifdef CONFIG_ARCH_MX28
+	__raw_writel(1 << chan, pdev->base + HW_APBH_CHANNEL_CTRL_CLR);
+#endif
+
+#ifdef CONFIG_ARCH_MX23
+	__raw_writel(1 << (chan + BP_APBH_CTRL0_FREEZE_CHANNEL),
+				pdev->base + HW_APBH_CTRL0_CLR);
+#endif
+
+}
+
+static void mxs_dma_apbh_info(struct mxs_dma_device *pdev,
+		unsigned int chan, struct mxs_dma_info *info)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBH_CTRL2);
+	info->status = reg >> chan;
+	info->buf_addr = __raw_readl(pdev->base + HW_APBH_CHn_BAR(chan));
+}
+
+static int
+mxs_dma_apbh_read_semaphore(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBH_CHn_SEMA(chan));
+	return (reg & BM_APBH_CHn_SEMA_PHORE) >> BP_APBH_CHn_SEMA_PHORE;
+}
+
+static void
+mxs_dma_apbh_enable_irq(struct mxs_dma_device *pdev,
+			unsigned int chan, int enable)
+{
+	if (enable) {
+		__raw_writel(1 << (chan + 16), pdev->base + HW_APBH_CTRL1_SET);
+	} else {
+		__raw_writel(1 << (chan + 16), pdev->base + HW_APBH_CTRL1_CLR);
+	}
+}
+
+static int
+mxs_dma_apbh_irq_is_pending(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBH_CTRL1);
+	reg |= __raw_readl(pdev->base + HW_APBH_CTRL2);
+	return reg & (1 << chan);
+}
+
+static void mxs_dma_apbh_ack_irq(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	__raw_writel(1 << chan, pdev->base + HW_APBH_CTRL1_CLR);
+	__raw_writel(1 << chan, pdev->base + HW_APBH_CTRL2_CLR);
+}
+
+static struct mxs_dma_device mxs_dma_apbh = {
+	.name = "mxs-dma-apbh",
+	.enable = mxs_dma_apbh_enable,
+	.disable = mxs_dma_apbh_disable,
+	.reset = mxs_dma_apbh_reset,
+	.freeze = mxs_dma_apbh_freeze,
+	.unfreeze = mxs_dma_apbh_unfreeze,
+	.info = mxs_dma_apbh_info,
+	.read_semaphore = mxs_dma_apbh_read_semaphore,
+	.enable_irq = mxs_dma_apbh_enable_irq,
+	.irq_is_pending = mxs_dma_apbh_irq_is_pending,
+	.ack_irq = mxs_dma_apbh_ack_irq,
+};
+
+static int __devinit dma_apbh_probe(struct platform_device *pdev)
+{
+	int i;
+	struct resource *res;
+	struct mxs_dma_plat_data *plat;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOMEM;
+	mxs_dma_apbh.base = IO_ADDRESS(res->start);
+	__raw_writel(BM_APBH_CTRL0_SFTRST,
+		     mxs_dma_apbh.base + HW_APBH_CTRL0_CLR);
+	for (i = 0; i < 10000; i++) {
+		if (!(__raw_readl(mxs_dma_apbh.base + HW_APBH_CTRL0_CLR) &
+		      BM_APBH_CTRL0_SFTRST))
+			break;
+		udelay(2);
+	}
+	if (i >= 10000)
+		return -ETIME;
+	__raw_writel(BM_APBH_CTRL0_CLKGATE,
+		     mxs_dma_apbh.base + HW_APBH_CTRL0_CLR);
+
+	plat = (struct mxs_dma_plat_data *)pdev->dev.platform_data;
+	if (!plat)
+		return -ENODEV;
+	if (plat->burst8)
+		__raw_writel(BM_APBH_CTRL0_AHB_BURST8_EN,
+			     mxs_dma_apbh.base + HW_APBH_CTRL0_SET);
+	else
+		__raw_writel(BM_APBH_CTRL0_AHB_BURST8_EN,
+			     mxs_dma_apbh.base + HW_APBH_CTRL0_CLR);
+
+	if (plat->burst)
+		__raw_writel(BM_APBH_CTRL0_APB_BURST_EN,
+			     mxs_dma_apbh.base + HW_APBH_CTRL0_SET);
+	else
+		__raw_writel(BM_APBH_CTRL0_APB_BURST_EN,
+			     mxs_dma_apbh.base + HW_APBH_CTRL0_CLR);
+
+	mxs_dma_apbh.pdev = pdev;
+	mxs_dma_apbh.chan_base = plat->chan_base;
+	mxs_dma_apbh.chan_num = plat->chan_num;
+	platform_set_drvdata(pdev, &mxs_dma_apbh);
+	return mxs_dma_device_register(&mxs_dma_apbh);
+}
+
+static int __devexit dma_apbh_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver dma_apbh_driver = {
+	.probe = dma_apbh_probe,
+	.remove = __devexit_p(dma_apbh_remove),
+	.driver = {
+		   .name = "mxs-dma-apbh"},
+};
+
+static int __init mxs_dma_apbh_init(void)
+{
+	return platform_driver_register(&dma_apbh_driver);
+}
+
+fs_initcall(mxs_dma_apbh_init);
diff --git a/arch/arm/plat-mxs/dma-apbx.c b/arch/arm/plat-mxs/dma-apbx.c
new file mode 100644
index 0000000..c27414f
--- /dev/null
+++ b/arch/arm/plat-mxs/dma-apbx.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/dmapool.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/dmaengine.h>
+
+#include "regs-apbx.h"
+
+static int mxs_dma_apbx_enable(struct mxs_dma_chan *pchan, unsigned int chan)
+{
+	unsigned int sem;
+	struct mxs_dma_device *pdev = pchan->dma;
+	struct mxs_dma_desc *pdesc;
+
+	pdesc = list_first_entry(&pchan->active, struct mxs_dma_desc, node);
+	if (pdesc == NULL)
+		return -EFAULT;
+	sem = __raw_readl(pdev->base + HW_APBX_CHn_SEMA(chan));
+	sem = (sem & BM_APBX_CHn_SEMA_PHORE) >> BP_APBX_CHn_SEMA_PHORE;
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY) {
+		if (pdesc->cmd.cmd.bits.chain == 0)
+			return 0;
+		if (sem < 2) {
+			if (!sem)
+				return 0;
+			pdesc = list_entry(pdesc->node.next,
+					   struct mxs_dma_desc, node);
+			__raw_writel(mxs_dma_cmd_address(pdesc),
+				     pdev->base + HW_APBX_CHn_NXTCMDAR(chan));
+		}
+		sem = pchan->pending_num;
+		pchan->pending_num = 0;
+		__raw_writel(BF_APBX_CHn_SEMA_INCREMENT_SEMA(sem),
+			     pdev->base + HW_APBX_CHn_SEMA(chan));
+		pchan->active_num += sem;
+		return 0;
+	}
+	pchan->active_num += pchan->pending_num;
+	pchan->pending_num = 0;
+	__raw_writel(mxs_dma_cmd_address(pdesc),
+		     pdev->base + HW_APBX_CHn_NXTCMDAR(chan));
+	__raw_writel(pchan->active_num, pdev->base + HW_APBX_CHn_SEMA(chan));
+	return 0;
+}
+
+static void mxs_dma_apbx_disable(struct mxs_dma_chan *pchan, unsigned int chan)
+{
+	struct mxs_dma_device *pdev = pchan->dma;
+	__raw_writel(0, pdev->base + HW_APBX_CHn_SEMA(chan));
+}
+
+static void mxs_dma_apbx_reset(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	__raw_writel(1 << (chan + BP_APBX_CHANNEL_CTRL_RESET_CHANNEL),
+		     pdev->base + HW_APBX_CHANNEL_CTRL_SET);
+}
+
+static void mxs_dma_apbx_freeze(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	__raw_writel(1 << chan, pdev->base + HW_APBX_CHANNEL_CTRL_SET);
+}
+
+static void
+mxs_dma_apbx_unfreeze(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	__raw_writel(1 << chan, pdev->base + HW_APBX_CHANNEL_CTRL_CLR);
+}
+
+static void mxs_dma_apbx_info(struct mxs_dma_device *pdev,
+		unsigned int chan, struct mxs_dma_info *info)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBX_CTRL2);
+	info->status = reg >> chan;
+	info->buf_addr = __raw_readl(pdev->base + HW_APBX_CHn_BAR(chan));
+}
+
+static int
+mxs_dma_apbx_read_semaphore(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBX_CHn_SEMA(chan));
+	return (reg & BM_APBX_CHn_SEMA_PHORE) >> BP_APBX_CHn_SEMA_PHORE;
+}
+
+static void
+mxs_dma_apbx_enable_irq(struct mxs_dma_device *pdev,
+			unsigned int chan, int enable)
+{
+	if (enable) {
+		__raw_writel(1 << (chan + 16), pdev->base + HW_APBX_CTRL1_SET);
+	} else {
+		__raw_writel(1 << (chan + 16), pdev->base + HW_APBX_CTRL1_CLR);
+	}
+}
+
+static int
+mxs_dma_apbx_irq_is_pending(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	unsigned int reg;
+	reg = __raw_readl(pdev->base + HW_APBX_CTRL1);
+	reg |= __raw_readl(pdev->base + HW_APBX_CTRL2);
+	return reg & (1 << chan);
+}
+
+static void mxs_dma_apbx_ack_irq(struct mxs_dma_device *pdev, unsigned int chan)
+{
+	__raw_writel(1 << chan, pdev->base + HW_APBX_CTRL1_CLR);
+	__raw_writel(1 << chan, pdev->base + HW_APBX_CTRL2_CLR);
+}
+
+static struct mxs_dma_device mxs_dma_apbx = {
+	.name = "mxs-dma-apbx",
+	.enable = mxs_dma_apbx_enable,
+	.disable = mxs_dma_apbx_disable,
+	.reset = mxs_dma_apbx_reset,
+	.freeze = mxs_dma_apbx_freeze,
+	.unfreeze = mxs_dma_apbx_unfreeze,
+	.info = mxs_dma_apbx_info,
+	.read_semaphore = mxs_dma_apbx_read_semaphore,
+	.enable_irq = mxs_dma_apbx_enable_irq,
+	.irq_is_pending = mxs_dma_apbx_irq_is_pending,
+	.ack_irq = mxs_dma_apbx_ack_irq,
+};
+
+static int __devinit dma_apbx_probe(struct platform_device *pdev)
+{
+	int i;
+	struct resource *res;
+	struct mxs_dma_plat_data *plat;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOMEM;
+	mxs_dma_apbx.base = IO_ADDRESS(res->start);
+	__raw_writel(BM_APBX_CTRL0_SFTRST,
+		     mxs_dma_apbx.base + HW_APBX_CTRL0_CLR);
+	for (i = 0; i < 10000; i++) {
+		if (!(__raw_readl(mxs_dma_apbx.base + HW_APBX_CTRL0_CLR) &
+		      BM_APBX_CTRL0_SFTRST))
+			break;
+		udelay(2);
+	}
+	if (i >= 10000)
+		return -ETIME;
+	__raw_writel(BM_APBX_CTRL0_CLKGATE,
+		     mxs_dma_apbx.base + HW_APBX_CTRL0_CLR);
+
+	plat = (struct mxs_dma_plat_data *)pdev->dev.platform_data;
+	if (!plat)
+		return -ENODEV;
+
+	mxs_dma_apbx.pdev = pdev;
+	mxs_dma_apbx.chan_base = plat->chan_base;
+	mxs_dma_apbx.chan_num = plat->chan_num;
+	platform_set_drvdata(pdev, &mxs_dma_apbx);
+	return mxs_dma_device_register(&mxs_dma_apbx);
+}
+
+static int __devexit dma_apbx_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver dma_apbx_driver = {
+	.probe = dma_apbx_probe,
+	.remove = __devexit_p(dma_apbx_remove),
+	.driver = {
+		   .name = "mxs-dma-apbx"},
+};
+
+static int __init mxs_dma_apbx_init(void)
+{
+	return platform_driver_register(&dma_apbx_driver);
+}
+
+fs_initcall(mxs_dma_apbx_init);
diff --git a/arch/arm/plat-mxs/dmaengine.c b/arch/arm/plat-mxs/dmaengine.c
new file mode 100644
index 0000000..52330d3
--- /dev/null
+++ b/arch/arm/plat-mxs/dmaengine.c
@@ -0,0 +1,645 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/dmapool.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <mach/dma.h>
+#include <mach/dmaengine.h>
+
+static void *mxs_dma_pool;
+static int mxs_dma_alignment = MXS_DMA_ALIGNMENT;
+
+/*
+ * The mutex that arbitrates access to the array of structures that represent
+ * all the DMA channels in the system (see mxs_dma_channels, below).
+ */
+
+static DEFINE_MUTEX(mxs_dma_mutex);
+
+/*
+ * The list of DMA drivers that manage various DMA channels. A DMA device
+ * driver registers to manage DMA channels by calling mxs_dma_device_register().
+ */
+
+static LIST_HEAD(mxs_dma_devices);
+
+/*
+ * The array of struct mxs_dma_chan that represent every DMA channel in the
+ * system. The index of the structure in the array indicates the specific DMA
+ * hardware it represents (see mach-mx28/include/mach/dma.h).
+ */
+
+static struct mxs_dma_chan mxs_dma_channels[MAX_DMA_CHANNELS];
+
+int mxs_dma_request(int channel, struct device *dev, const char *name)
+{
+	int ret = 0;
+	struct mxs_dma_chan *pchan;
+
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+
+	if (!dev || !name)
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	mutex_lock(&mxs_dma_mutex);
+	if ((pchan->flags & MXS_DMA_FLAGS_VALID) != MXS_DMA_FLAGS_VALID) {
+		ret = -ENODEV;
+		goto out;
+	}
+	if (pchan->flags & MXS_DMA_FLAGS_ALLOCATED) {
+		ret = -EBUSY;
+		goto out;
+	}
+	pchan->flags |= MXS_DMA_FLAGS_ALLOCATED;
+	pchan->name = name;
+	pchan->dev = (unsigned long)dev;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+	spin_lock_init(&pchan->lock);
+	INIT_LIST_HEAD(&pchan->active);
+	INIT_LIST_HEAD(&pchan->done);
+out:
+	mutex_unlock(&mxs_dma_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_request);
+
+void mxs_dma_release(int channel, struct device *dev)
+{
+	struct mxs_dma_chan *pchan;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY)
+		return;
+
+	if (pchan->dev != (unsigned long)dev)
+		return;
+
+	mutex_lock(&mxs_dma_mutex);
+	pchan->dev = 0;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+	pchan->flags &= ~MXS_DMA_FLAGS_ALLOCATED;
+	mutex_unlock(&mxs_dma_mutex);
+}
+EXPORT_SYMBOL(mxs_dma_release);
+
+int mxs_dma_enable(int channel)
+{
+	int ret = 0;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+
+	pdma = pchan->dma;
+	mutex_lock(&mxs_dma_mutex);
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pchan->pending_num && pdma->enable)
+		ret = pdma->enable(pchan, channel - pdma->chan_base);
+	pchan->flags |= MXS_DMA_FLAGS_BUSY;
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	mutex_unlock(&mxs_dma_mutex);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_enable);
+
+void mxs_dma_disable(int channel)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	if (!(pchan->flags & MXS_DMA_FLAGS_BUSY))
+		return;
+	pdma = pchan->dma;
+	mutex_lock(&mxs_dma_mutex);
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->disable)
+		pdma->disable(pchan, channel - pdma->chan_base);
+	pchan->flags &= ~MXS_DMA_FLAGS_BUSY;
+	pchan->active_num = 0;
+	pchan->pending_num = 0;
+	list_splice_init(&pchan->active, &pchan->done);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	mutex_unlock(&mxs_dma_mutex);
+}
+EXPORT_SYMBOL(mxs_dma_disable);
+
+int mxs_dma_get_info(int channel, struct mxs_dma_info *info)
+{
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+
+	if (!info)
+		return -EINVAL;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EFAULT;
+	pdma = pchan->dma;
+	if (pdma->info)
+		pdma->info(pdma, channel - pdma->chan_base, info);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_dma_get_info);
+
+int mxs_dma_cooked(int channel, struct list_head *head)
+{
+	int sem;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct list_head *p, *q;
+	struct mxs_dma_desc *pdesc;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+
+	sem = mxs_dma_read_semaphore(channel);
+	if (sem < 0)
+		return sem;
+	if (sem == pchan->active_num)
+		return 0;
+	BUG_ON(sem > pchan->active_num);
+	spin_lock_irqsave(&pchan->lock, flags);
+	list_for_each_safe(p, q, &pchan->active) {
+		if ((pchan->active_num) <= sem)
+			break;
+		pdesc = list_entry(p, struct mxs_dma_desc, node);
+		pdesc->flags &= ~MXS_DMA_DESC_READY;
+		if (head)
+			list_move_tail(p, head);
+		else
+			list_move_tail(p, &pchan->done);
+		if (pdesc->flags & MXS_DMA_DESC_LAST)
+			pchan->active_num--;
+	}
+	if (sem == 0)
+		pchan->flags &= ~MXS_DMA_FLAGS_BUSY;
+	spin_unlock_irqrestore(&pchan->lock, flags);
+
+	BUG_ON(sem != pchan->active_num);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_dma_cooked);
+
+void mxs_dma_reset(int channel)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->reset)
+		pdma->reset(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_reset);
+
+void mxs_dma_freeze(int channel)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->freeze)
+		pdma->freeze(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_freeze);
+
+void mxs_dma_unfreeze(int channel)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->unfreeze)
+		pdma->unfreeze(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_unfreeze);
+
+int mxs_dma_read_semaphore(int channel)
+{
+	int ret = -EINVAL;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return ret;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return ret;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->read_semaphore)
+		ret = pdma->read_semaphore(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_read_semaphore);
+
+void mxs_dma_enable_irq(int channel, int en)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->enable_irq)
+		pdma->enable_irq(pdma, channel - pdma->chan_base, en);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_enable_irq);
+
+int mxs_dma_irq_is_pending(int channel)
+{
+	int ret = 0;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return ret;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return ret;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->irq_is_pending)
+		ret = pdma->irq_is_pending(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_irq_is_pending);
+
+void mxs_dma_ack_irq(int channel)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->ack_irq)
+		pdma->ack_irq(pdma, channel - pdma->chan_base);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_ack_irq);
+
+void mxs_dma_set_target(int channel, int target)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return;
+	if (pchan->flags & MXS_DMA_FLAGS_BUSY)
+		return;
+	pdma = pchan->dma;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (pdma->set_target)
+		pdma->set_target(pdma, channel - pdma->chan_base, target);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+}
+EXPORT_SYMBOL(mxs_dma_set_target);
+
+/* mxs dma utility function */
+struct mxs_dma_desc *mxs_dma_alloc_desc(void)
+{
+	struct mxs_dma_desc *pdesc;
+	unsigned int address;
+	if (mxs_dma_pool == NULL)
+		return NULL;
+
+	pdesc = dma_pool_alloc(mxs_dma_pool, GFP_KERNEL, &address);
+	if (pdesc == NULL)
+		return NULL;
+	memset(pdesc, 0, sizeof(*pdesc));
+	pdesc->address = address;
+	return pdesc;
+};
+EXPORT_SYMBOL(mxs_dma_alloc_desc);
+
+void mxs_dma_free_desc(struct mxs_dma_desc *pdesc)
+{
+	if (pdesc == NULL)
+		return;
+
+	if (mxs_dma_pool == NULL)
+		return;
+
+	dma_pool_free(mxs_dma_pool, pdesc, pdesc->address);
+}
+EXPORT_SYMBOL(mxs_dma_free_desc);
+
+int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc)
+{
+	int ret = 0;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_desc *last;
+	struct mxs_dma_device *pdma;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+	pdma = pchan->dma;
+	pdesc->cmd.next = mxs_dma_cmd_address(pdesc);
+	pdesc->flags |= MXS_DMA_DESC_FIRST | MXS_DMA_DESC_LAST;
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (!list_empty(&pchan->active)) {
+		last = list_entry(pchan->active.prev,
+				  struct mxs_dma_desc, node);
+		if (pdesc->cmd.cmd.bits.dec_sem != last->cmd.cmd.bits.dec_sem) {
+			ret = -EFAULT;
+			goto out;
+		}
+		if (!pdesc->cmd.cmd.bits.dec_sem) {
+			pdesc->flags &= ~MXS_DMA_DESC_FIRST;
+			last->flags &= ~MXS_DMA_DESC_LAST;
+		}
+		pdesc->cmd.next = last->cmd.next;
+		last->cmd.next = mxs_dma_cmd_address(pdesc);
+		last->cmd.cmd.bits.chain = 1;
+	}
+	pdesc->flags |= MXS_DMA_DESC_READY;
+	if (pdesc->flags & MXS_DMA_DESC_FIRST)
+		pchan->pending_num++;
+	list_add_tail(&pdesc->node, &pchan->active);
+out:
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_desc_append);
+
+int mxs_dma_desc_add_list(int channel, struct list_head *head)
+{
+	int ret = 0, size = 0;
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	struct mxs_dma_device *pdma;
+	struct list_head *p;
+	struct mxs_dma_desc *prev = NULL, *pcur;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+
+	if (list_empty(head))
+		return 0;
+
+	pdma = pchan->dma;
+	list_for_each(p, head) {
+		pcur = list_entry(p, struct mxs_dma_desc, node);
+		if (!(pcur->cmd.cmd.bits.dec_sem || pcur->cmd.cmd.bits.chain))
+			return -EINVAL;
+		if (prev)
+			prev->cmd.next = mxs_dma_cmd_address(pcur);
+		else
+			pcur->flags |= MXS_DMA_DESC_FIRST;
+		pcur->flags |= MXS_DMA_DESC_READY;
+		prev = pcur;
+		size++;
+	}
+	pcur = list_first_entry(head, struct mxs_dma_desc, node);
+	prev->cmd.next = mxs_dma_cmd_address(pcur);
+	prev->flags |= MXS_DMA_DESC_LAST;
+
+	spin_lock_irqsave(&pchan->lock, flags);
+	if (!list_empty(&pchan->active)) {
+		pcur = list_entry(pchan->active.next,
+				  struct mxs_dma_desc, node);
+		if (pcur->cmd.cmd.bits.dec_sem != prev->cmd.cmd.bits.dec_sem) {
+			ret = -EFAULT;
+			goto out;
+		}
+		prev->cmd.next = mxs_dma_cmd_address(pcur);
+		prev = list_entry(pchan->active.prev,
+				  struct mxs_dma_desc, node);
+		pcur = list_first_entry(head, struct mxs_dma_desc, node);
+		pcur->flags &= ~MXS_DMA_DESC_FIRST;
+		prev->flags &= ~MXS_DMA_DESC_LAST;
+		prev->cmd.next = mxs_dma_cmd_address(pcur);
+	}
+	list_splice(head, &pchan->active);
+	pchan->pending_num += size;
+	if (!(pcur->cmd.cmd.bits.dec_sem) && (pcur->flags & MXS_DMA_DESC_FIRST))
+		pchan->pending_num += 1;
+	else
+		pchan->pending_num += size;
+out:
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_dma_desc_add_list);
+
+int mxs_dma_get_cooked(int channel, struct list_head *head)
+{
+	unsigned long flags;
+	struct mxs_dma_chan *pchan;
+	if ((channel < 0) || (channel >= MAX_DMA_CHANNELS))
+		return -EINVAL;
+	pchan = mxs_dma_channels + channel;
+	if (!(pchan->flags & MXS_DMA_FLAGS_ALLOCATED))
+		return -EINVAL;
+
+	if (head == NULL)
+		return 0;
+
+	spin_lock_irqsave(&pchan->lock, flags);
+	list_splice(&pchan->done, head);
+	spin_unlock_irqrestore(&pchan->lock, flags);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_dma_get_cooked);
+
+int mxs_dma_device_register(struct mxs_dma_device *pdev)
+{
+	int i;
+	struct mxs_dma_chan *pchan;
+
+	if (pdev == NULL || !pdev->chan_num)
+		return -EINVAL;
+
+	if ((pdev->chan_base >= MAX_DMA_CHANNELS) ||
+	    ((pdev->chan_base + pdev->chan_num) > MAX_DMA_CHANNELS))
+		return -EINVAL;
+
+	mutex_lock(&mxs_dma_mutex);
+	pchan = mxs_dma_channels + pdev->chan_base;
+	for (i = 0; i < pdev->chan_num; i++, pchan++) {
+		pchan->dma = pdev;
+		pchan->flags = MXS_DMA_FLAGS_VALID;
+	}
+	list_add(&pdev->node, &mxs_dma_devices);
+	mutex_unlock(&mxs_dma_mutex);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_dma_device_register);
+
+static int __init mxs_dma_alignment_setup(char *line)
+{
+	get_option(&line, &mxs_dma_alignment);
+	mxs_dma_alignment = (mxs_dma_alignment + 3) & (~3);
+	mxs_dma_alignment = max(mxs_dma_alignment, MXS_DMA_ALIGNMENT);
+	return 1;
+};
+
+__setup("mxs-dma-alignment=", mxs_dma_alignment_setup);
+
+static int mxs_dmaengine_init(void)
+{
+	mxs_dma_pool = dma_pool_create("mxs_dma", NULL,
+				       sizeof(struct mxs_dma_desc),
+				       mxs_dma_alignment, PAGE_SIZE);
+	if (mxs_dma_pool == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+subsys_initcall(mxs_dmaengine_init);
+
+#ifdef CONFIG_PROC_FS
+
+static void *mxs_dma_proc_seq_start(struct seq_file *file, loff_t * index)
+{
+	if (*index >= MAX_DMA_CHANNELS)
+		return NULL;
+	return mxs_dma_channels + *index;
+}
+
+static void *mxs_dma_proc_seq_next(struct seq_file *file, void *data,
+				   loff_t *index)
+{
+	if (data == NULL)
+		return NULL;
+
+	if (*index >= MAX_DMA_CHANNELS)
+		return NULL;
+
+	return mxs_dma_channels + (*index)++;
+}
+
+static void mxs_dma_proc_seq_stop(struct seq_file *file, void *data)
+{
+}
+
+static int mxs_dma_proc_seq_show(struct seq_file *file, void *data)
+{
+	int result;
+	struct mxs_dma_chan *pchan = (struct mxs_dma_chan *)data;
+	struct mxs_dma_device *pdev = pchan->dma;
+	result = seq_printf(file, "%s-channel%-d	(%s)\n",
+			    pdev->name,
+			    pchan - mxs_dma_channels,
+			    pchan->name ? pchan->name : "idle");
+	return result;
+}
+
+static const struct seq_operations mxc_dma_proc_seq_ops = {
+	.start = mxs_dma_proc_seq_start,
+	.next = mxs_dma_proc_seq_next,
+	.stop = mxs_dma_proc_seq_stop,
+	.show = mxs_dma_proc_seq_show
+};
+
+static int mxs_dma_proc_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mxc_dma_proc_seq_ops);
+}
+
+static const struct file_operations mxs_dma_proc_info_ops = {
+	.open = mxs_dma_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int __init mxs_dmaengine_info_init(void)
+{
+	struct proc_dir_entry *res;
+	res = create_proc_entry("dma-engine", 0, NULL);
+	if (!res) {
+		printk(KERN_ERR "Failed to create dma info file \n");
+		return -ENOMEM;
+	}
+	res->proc_fops = &mxs_dma_proc_info_ops;
+	return 0;
+}
+
+late_initcall(mxs_dmaengine_info_init);
+#endif
diff --git a/arch/arm/plat-mxs/gpio.c b/arch/arm/plat-mxs/gpio.c
new file mode 100644
index 0000000..6c67c2b
--- /dev/null
+++ b/arch/arm/plat-mxs/gpio.c
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/gpio.h>
+#include <linux/list.h>
+#include <linux/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/pinctrl.h>
+
+#if MXS_ARCH_NR_GPIOS % PINS_PER_BANK
+#error "MXS_ARCH_NR_GPIOS must be multipled of PINS_PER_BANK"
+#endif
+
+static struct mxs_gpio_port *mxs_gpios[MXS_ARCH_NR_GPIOS / PINS_PER_BANK];
+
+static inline int mxs_valid_gpio(struct mxs_gpio_port *port)
+{
+	struct mxs_gpio_chip *chip = port->chip;
+
+	if (port->id >= (MXS_ARCH_NR_GPIOS / PINS_PER_BANK))
+		return -EINVAL;
+
+	if (port->irq < 0 && port->child_irq > 0)
+		return -EINVAL;
+	if (chip->get == NULL || chip->set == NULL || chip->set_dir == NULL)
+		return -EINVAL;
+	if (port->child_irq > 0) {
+		if (chip->get_irq_stat == NULL)
+			return -EINVAL;
+		if (chip->mask_irq == NULL || chip->unmask_irq == NULL)
+			return -EINVAL;
+	}
+	return 0;
+}
+
+static int mxs_gpio_request(struct gpio_chip *chip, unsigned int pin)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	return mxs_request_pin(MXS_PIN_ENCODE(port->id, pin),
+			       PIN_GPIO, GPIO_ID_NAME);
+}
+
+static void mxs_gpio_free(struct gpio_chip *chip, unsigned int pin)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	return mxs_release_pin(MXS_PIN_ENCODE(port->id, pin), GPIO_ID_NAME);
+}
+
+static int mxs_gpio_to_irq(struct gpio_chip *chip, unsigned int index)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	if (port->child_irq < 0)
+		return -ENXIO;
+	return port->child_irq + index;
+}
+
+static int mxs_gpio_get(struct gpio_chip *chip, unsigned int index)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	return port->chip->get(port, index);
+}
+
+static void mxs_gpio_set(struct gpio_chip *chip, unsigned int index, int v)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	port->chip->set(port, index, v);
+}
+
+static int mxs_gpio_output(struct gpio_chip *chip, unsigned int index, int v)
+{
+	int ret;
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	ret = port->chip->set_dir(port, index, 0);
+	if (!ret)
+		port->chip->set(port, index, v);
+	return ret;
+}
+
+static int mxs_gpio_input(struct gpio_chip *chip, unsigned int index)
+{
+	struct mxs_gpio_port *port;
+	port = container_of(chip, struct mxs_gpio_port, port);
+	return port->chip->set_dir(port, index, 1);
+}
+
+static void mxs_gpio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	struct mxs_gpio_port *port = get_irq_data(irq);
+	int gpio_irq = port->child_irq;
+	u32 irq_stat = port->chip->get_irq_stat(port);
+
+	desc->chip->mask(irq);
+
+	while (irq_stat) {
+		if (irq_stat & 1)
+			generic_handle_irq(gpio_irq);
+		gpio_irq++;
+		irq_stat >>= 1;
+	}
+
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+static int mxs_gpio_set_irq_type(unsigned int irq, unsigned int type)
+{
+	struct mxs_gpio_port *port;
+	unsigned int gpio = irq_to_gpio(irq);
+	port = mxs_gpios[GPIO_TO_BANK(gpio)];
+	if (port->child_irq < 0)
+		return -ENXIO;
+	if (port->chip->set_irq_type)
+		return port->chip->set_irq_type(port, GPIO_TO_PINS(gpio), type);
+	return -ENODEV;
+}
+
+static void mxs_gpio_ack_irq(unsigned int irq)
+{
+	struct mxs_gpio_port *port;
+	unsigned int gpio = irq_to_gpio(irq);
+	port = mxs_gpios[GPIO_TO_BANK(gpio)];
+	if (port->child_irq < 0)
+		return;
+	if (port->chip->ack_irq)
+		port->chip->ack_irq(port, GPIO_TO_PINS(gpio));
+}
+
+static void mxs_gpio_mask_irq(unsigned int irq)
+{
+	struct mxs_gpio_port *port;
+	unsigned int gpio = irq_to_gpio(irq);
+	port = mxs_gpios[GPIO_TO_BANK(gpio)];
+	if (port->child_irq < 0)
+		return;
+	port->chip->mask_irq(port, GPIO_TO_PINS(gpio));
+}
+
+static void mxs_gpio_unmask_irq(unsigned int irq)
+{
+	struct mxs_gpio_port *port;
+	unsigned int gpio = irq_to_gpio(irq);
+	port = mxs_gpios[GPIO_TO_BANK(gpio)];
+	if (port->child_irq < 0)
+		return;
+	port->chip->unmask_irq(port, GPIO_TO_PINS(gpio));
+}
+
+static struct irq_chip gpio_irq_chip = {
+	.ack = mxs_gpio_ack_irq,
+	.mask = mxs_gpio_mask_irq,
+	.unmask = mxs_gpio_unmask_irq,
+	.enable = mxs_gpio_unmask_irq,
+	.disable = mxs_gpio_mask_irq,
+	.set_type = mxs_gpio_set_irq_type,
+};
+
+int __init mxs_add_gpio_port(struct mxs_gpio_port *port)
+{
+	int i, ret;
+	if (!(port && port->chip))
+		return -EINVAL;
+
+	if (mxs_valid_gpio(port))
+		return -EINVAL;
+
+	if (mxs_gpios[port->id])
+		return -EBUSY;
+
+	mxs_gpios[port->id] = port;
+
+	port->port.base = port->id * PINS_PER_BANK;
+	port->port.ngpio = PINS_PER_BANK;
+	port->port.can_sleep = 1;
+	port->port.exported = 1;
+	port->port.to_irq = mxs_gpio_to_irq;
+	port->port.direction_input = mxs_gpio_input;
+	port->port.direction_output = mxs_gpio_output;
+	port->port.get = mxs_gpio_get;
+	port->port.set = mxs_gpio_set;
+	port->port.request = mxs_gpio_request;
+	port->port.free = mxs_gpio_free;
+	port->port.owner = THIS_MODULE;
+	ret = gpiochip_add(&port->port);
+	if (ret < 0)
+		return ret;
+
+	if (port->child_irq < 0)
+		return 0;
+
+	for (i = 0; i < PINS_PER_BANK; i++) {
+		gpio_irq_chip.mask(port->child_irq + i);
+		set_irq_chip(port->child_irq + i, &gpio_irq_chip);
+		set_irq_handler(port->child_irq + i, handle_level_irq);
+		set_irq_flags(port->child_irq + i, IRQF_VALID);
+	}
+	set_irq_chained_handler(port->irq, mxs_gpio_irq_handler);
+	set_irq_data(port->irq, port);
+	return ret;
+};
diff --git a/arch/arm/plat-mxs/icoll.c b/arch/arm/plat-mxs/icoll.c
new file mode 100644
index 0000000..1e0b55b
--- /dev/null
+++ b/arch/arm/plat-mxs/icoll.c
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/irqs.h>
+
+#include "regs-icoll.h"
+
+void __iomem *g_icoll_base;
+
+/*
+ * IRQ handling
+ */
+static void icoll_ack_irq(unsigned int irq)
+{
+	__raw_writel(0, g_icoll_base + HW_ICOLL_VECTOR);
+
+	/* ACK current interrupt */
+	__raw_writel(BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0,
+		     g_icoll_base + HW_ICOLL_LEVELACK);
+
+	/* Barrier */
+	(void)__raw_readl(g_icoll_base + HW_ICOLL_STAT);
+}
+
+static void icoll_mask_irq(unsigned int irq)
+{
+	__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,
+		     g_icoll_base + HW_ICOLL_INTERRUPTn_CLR(irq));
+}
+
+static void icoll_unmask_irq(unsigned int irq)
+{
+	__raw_writel(BM_ICOLL_INTERRUPTn_ENABLE,
+		     g_icoll_base + HW_ICOLL_INTERRUPTn_SET(irq));
+}
+
+static int icoll_set_wake_irq(unsigned int irq, unsigned int enabled)
+{
+	return 0;
+}
+
+static struct irq_chip icoll_chip = {
+	.ack = icoll_ack_irq,
+	.mask = icoll_mask_irq,
+	.unmask = icoll_unmask_irq,
+	.set_wake = icoll_set_wake_irq,
+};
+
+void __init avic_init_irq(void __iomem *base, int nr_irqs)
+{
+	int i;
+	g_icoll_base = base;
+
+	/* Reset icoll */
+	__raw_writel(BM_ICOLL_CTRL_SFTRST, g_icoll_base + HW_ICOLL_CTRL_CLR);
+
+	for (i = 0; i < 100000; i++) {
+		if (!(__raw_readl(g_icoll_base + HW_ICOLL_CTRL) &
+		      BM_ICOLL_CTRL_SFTRST))
+			break;
+		udelay(2);
+	}
+	if (i >= 100000) {
+		printk(KERN_ERR "%s:%d timeout when enableing\n",
+		       __func__, __LINE__);
+		return;
+	}
+	__raw_writel(BM_ICOLL_CTRL_CLKGATE, g_icoll_base + HW_ICOLL_CTRL_CLR);
+
+	for (i = 0; i < nr_irqs; i++) {
+		__raw_writel(0, g_icoll_base + HW_ICOLL_INTERRUPTn(i));
+		set_irq_chip(i, &icoll_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+	}
+
+	__raw_writel(BF_ICOLL_LEVELACK_IRQLEVELACK
+		     (BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0),
+		     g_icoll_base + HW_ICOLL_LEVELACK);
+	__raw_writel(BF_ICOLL_LEVELACK_IRQLEVELACK
+		     (BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL1),
+		     g_icoll_base + HW_ICOLL_LEVELACK);
+	__raw_writel(BF_ICOLL_LEVELACK_IRQLEVELACK
+		     (BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL2),
+		     g_icoll_base + HW_ICOLL_LEVELACK);
+	__raw_writel(BF_ICOLL_LEVELACK_IRQLEVELACK
+		     (BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL3),
+		     g_icoll_base + HW_ICOLL_LEVELACK);
+
+	__raw_writel(0, g_icoll_base + HW_ICOLL_VECTOR);
+	/* Barrier */
+	(void)__raw_readl(g_icoll_base + HW_ICOLL_STAT);
+}
+
+void mxs_set_irq_fiq(unsigned int irq, unsigned int type)
+{
+	if (type == 0)
+		__raw_writel(BM_ICOLL_INTERRUPTn_ENFIQ,
+			g_icoll_base +
+			HW_ICOLL_INTERRUPTn_CLR(irq));
+	else
+		__raw_writel(BM_ICOLL_INTERRUPTn_ENFIQ,
+			g_icoll_base +
+			HW_ICOLL_INTERRUPTn_SET(irq));
+}
+EXPORT_SYMBOL(mxs_set_irq_fiq);
+
+void mxs_enable_fiq_functionality(int enable)
+{
+	if (enable)
+		__raw_writel(BM_ICOLL_CTRL_FIQ_FINAL_ENABLE,
+			g_icoll_base + HW_ICOLL_CTRL_SET);
+	else
+		__raw_writel(BM_ICOLL_CTRL_FIQ_FINAL_ENABLE,
+			g_icoll_base + HW_ICOLL_CTRL_CLR);
+
+}
+EXPORT_SYMBOL(mxs_enable_fiq_functionality);
+
diff --git a/arch/arm/plat-mxs/include/mach/arc_otg.h b/arch/arm/plat-mxs/include/mach/arc_otg.h
new file mode 100644
index 0000000..7213e27
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/arc_otg.h
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+#define USB_IRAM_SIZE   SZ_8K
+#else
+#define USB_IRAM_SIZE 0
+#endif
+
+#define OTG_BASE_ADDR		USBCTRL0_PHYS_ADDR
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+/*
+ * OTG registers
+ */
+#define UOG_ID			(0x00)	/* Host ID */
+#define UOG_HWGENERAL		(0x04)	/* Host General */
+#define UOG_HWHOST		(0x08)	/* Host h/w params */
+#define UOG_HWTXBUF		(0x10)	/* TX buffer h/w params */
+#define UOG_HWRXBUF		(0x14)	/* RX buffer h/w params */
+#define UOG_CAPLENGTH		(0x100)	/* Capability register length */
+#define UOG_HCIVERSION		(0x102)	/* Host Interface version */
+#define UOG_HCSPARAMS		(0x104)	/* Host control structural params */
+#define UOG_HCCPARAMS		(0x108)	/* control capability params */
+#define UOG_DCIVERSION		(0x120)	/* device interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		(0x140)	/* USB command register */
+#define UOG_USBSTS		(0x144)	/* USB status register */
+#define UOG_USBINTR		(0x148)	/* interrupt enable register */
+#define UOG_FRINDEX		(0x14c)	/* USB frame index */
+/*      segment         (0x150)	   addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	(0x154)	/* host crtlr frame list base addr */
+#define UOG_DEVICEADDR		(0x154)	/* device crtlr device address */
+#define UOG_ASYNCLISTADDR	(0x158)	/* host ctrlr next async addr */
+#define UOG_EPLISTADDR		(0x158)	/* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		(0x160)	/* host ctrlr embedded TT
+					   async buf status */
+#define UOG_TXFILLTUNING	(0x164)	/* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		(0x170)	/* ULPI viewport */
+#define UOG_CFGFLAG		(0x180)	/* configflag (supports HS) */
+#define UOG_PORTSC1		(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		(0x1a4)	/* OTG status and control */
+#define UOG_USBMODE		(0x1a8)	/* USB device mode */
+#define UOG_ENDPTSETUPSTAT	(0x1ac)	/* endpoint setup status */
+#define UOG_ENDPTPRIME		(0x1b0)	/* endpoint initialization */
+#define UOG_ENDPTFLUSH		(0x1b4)	/* endpoint de-initialize */
+#define UOG_ENDPTSTAT		(0x1b8)	/* endpoint status */
+#define UOG_ENDPTCOMPLETE	(0x1bc)	/* endpoint complete */
+#define UOG_EPCTRL0		(0x1c0)	/* endpoint control0 */
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30) /* parallel xcvr mask */
+#define PORTSC_PTS_UTMI			(0 << 30) /* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30) /* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30) /* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30) /* serial */
+#define PORTSC_STS			(1 << 29) /* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28) /* UTMI width */
+#define PORTSC_PHCD                     (1 << 23) /* Low Power Suspend */
+#define PORTSC_PORT_POWER		(1 << 12) /* port power */
+#define PORTSC_LS_MASK			(3 << 10) /* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10) /* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10) /* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10) /* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8) /* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7) /* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6) /* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5) /* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4) /* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3) /* port change */
+#define PORTSC_PORT_ENABLE		(1 <<  2) /* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1) /* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0) /* current connect status */
+
+#define PORTSC_W1C_BITS	\
+	(PORTSC_CONNECT_STATUS_CHANGE |	\
+	PORTSC_PORT_EN_DIS_CHANGE	|	\
+	PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 << 0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 << 1)
+/* controls DM pulldown */
+#define  OTGSC_CTRL_OTG_TERM		(1 << 3)
+#define  OTGSC_CTRL_DATA_PULSING	(1 << 4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 << 5)
+/* current status: (R/O) */
+/* 0=A-device  1=B-device */
+#define  OTGSC_STS_USB_ID		(1 << 8)
+#define  OTGSC_STS_A_VBUS_VALID		(1 << 9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1	/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	(~(0xff << 16))	/* Interrupt Threshold */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+
+extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/bus_freq.h b/arch/arm/plat-mxs/include/mach/bus_freq.h
new file mode 100644
index 0000000..0c41cd2
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/bus_freq.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef BUS_FREQ_H__
+#define BUS_FREQ_H__
+
+#define VERY_HI_RATE		2000000000
+#define LCD_ON_CPU_FREQ_KHZ 261818
+#define OPERATION_WP_SUPPORTED	6
+
+struct profile {
+	int cpu;
+	int ahb;
+	int emi;
+	int ss;
+	int vddd;
+	int vddd_bo;
+	int cur;
+	int vddio;
+	int vdda;
+	u16 xbus;
+	/* map of the upper 16 bits of HW_CLKCTRL_HBUS register */
+	u16 h_autoslow_flags;
+};
+
+/* map of the upper 16 bits of HW_CLKCTRL_HBUS register */
+int is_hclk_autoslow_ok(void);
+
+extern int timing_ctrl_rams(int ss);
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/clkdev.h b/arch/arm/plat-mxs/include/mach/clkdev.h
new file mode 100644
index 0000000..d6a82c8
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/clkdev.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+extern int __clk_get(struct clk *clk);
+extern void __clk_put(struct clk *clk);
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/clock.h b/arch/arm/plat-mxs/include/mach/clock.h
new file mode 100644
index 0000000..b506468
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/clock.h
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_CLOCK_H
+#define __ASM_ARM_ARCH_CLOCK_H
+
+#ifndef __ASSEMBLER__
+
+#include <linux/list.h>
+#include <asm/clkdev.h>
+
+struct clk {
+	int id;
+	struct clk *parent;
+	struct clk *secondary;
+	unsigned long flags;
+
+	int ref;
+	unsigned int scale_bits;
+	unsigned int enable_bits;
+	unsigned int bypass_bits;
+	unsigned int busy_bits;
+	unsigned int xtal_busy_bits;
+
+	unsigned int wait:1;
+	unsigned int invert:1;
+
+	void __iomem *enable_reg;
+	void __iomem *scale_reg;
+	void __iomem *bypass_reg;
+	void __iomem *busy_reg;
+
+	/*
+	 * Function ptr to set the clock to a new rate. The rate must match a
+	 * supported rate returned from round_rate. Leave blank if clock is not
+	 * programmable
+	 */
+	int (*set_rate) (struct clk *, unsigned long);
+	/*
+	 * Function ptr to get the clock rate.
+	 */
+	unsigned long (*get_rate) (struct clk *);
+	/*
+	 * Function ptr to round the requested clock rate to the nearest
+	 * supported rate that is less than or equal to the requested rate.
+	 */
+	unsigned long (*round_rate) (struct clk *, unsigned long);
+	/*
+	 * Function ptr to enable the clock. Leave blank if clock can not
+	 * be gated.
+	 */
+	int (*enable) (struct clk *);
+	/*
+	 * Function ptr to disable the clock. Leave blank if clock can not
+	 * be gated.
+	 */
+	void (*disable) (struct clk *);
+	/* Function ptr to set the parent clock of the clock. */
+	int (*set_parent) (struct clk *, struct clk *);
+
+	/* Function ptr to change the parent clock depending
+	 * the system configuration at that time.  Will only
+	 * change the parent clock if the ref count is 0 (the clock
+	 * is not being used)
+	 */
+	int (*set_sys_dependent_parent) (struct clk *);
+
+};
+
+int clk_get_usecount(struct clk *clk);
+extern int clk_register(struct clk_lookup *lookup);
+extern void clk_unregister(struct clk_lookup *lookup);
+
+bool clk_enable_h_autoslow(bool enable);
+void clk_set_h_autoslow_flags(u16 mask);
+void clk_en_public_h_asm_ctrl(bool (*enable_func)(bool),
+	void (*set_func)(u16));
+
+struct mxs_emi_scaling_data {
+	u32 emi_div;
+	u32 frac_div;
+	u32 cur_freq;
+	u32 new_freq;
+};
+
+
+
+#ifdef CONFIG_MXS_RAM_FREQ_SCALING
+extern int mxs_ram_freq_scale(struct mxs_emi_scaling_data *);
+extern u32 mxs_ram_funcs_sz;
+#else
+static inline int mxs_ram_freq_scale(struct mxs_emi_scaling_data *p)
+{
+}
+static u32 mxs_ram_funcs_sz;
+#endif
+
+/* Clock flags */
+/* 0 ~ 16 attribute flags */
+#define ALWAYS_ENABLED		(1 << 0)	/* Clock cannot be disabled */
+#define RATE_FIXED		(1 << 1)	/* Fixed clock rate */
+#define CPU_FREQ_TRIG_UPDATE	(1 << 2)	/* CPUFREQ trig update */
+
+/* 16 ~ 23 reservied */
+/* 24 ~ 31 run time flags */
+
+#define CLK_REF_UNIT		0x00010000
+#define CLK_REF_LIMIT		0xFFFF0000
+#define CLK_EN_MASK		0x0000FFFF
+#endif /* __ASSEMBLER__ */
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/ddi_bc.h b/arch/arm/plat-mxs/include/mach/ddi_bc.h
new file mode 100644
index 0000000..21ca921
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/ddi_bc.h
@@ -0,0 +1,715 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _DDI_BC_H
+#define _DDI_BC_H
+
+#include <linux/types.h>
+
+#define DDI_BC_MAX_RESTART_CYCLES 100
+
+#define DDI_BC_LIION_CHARGING_VOLTAGE  4200
+#define DDI_BC_ALKALINE_NIMH_CHARGING_VOLTAGE 1750
+
+/* brief Defines battery charger states. */
+typedef enum _ddi_bc_State {
+	/* brief TBD */
+	DDI_BC_STATE_UNINITIALIZED = 0,
+	/* brief TBD */
+	DDI_BC_STATE_BROKEN = 1,
+	/* brief TBD */
+	DDI_BC_STATE_DISABLED = 2,
+	/* brief TBD */
+	DDI_BC_STATE_WAITING_TO_CHARGE = 3,
+	/* brief TBD */
+	DDI_BC_STATE_CONDITIONING = 4,
+	/* brief TBD */
+	DDI_BC_STATE_CHARGING = 5,
+	/* brief TBD */
+	DDI_BC_STATE_TOPPING_OFF = 6,
+	/* brief TBD */
+	DDI_BC_STATE_DCDC_MODE_WAITING_TO_CHARGE = 7,
+
+} ddi_bc_State_t;
+
+typedef enum _ddi_bc_BrokenReason {
+	/* brief TBD */
+	DDI_BC_BROKEN_UNINITIALIZED = 0,
+	/* brief TBD */
+	DDI_BC_BROKEN_CHARGING_TIMEOUT = 1,
+	/* brief TBD */
+	DDI_BC_BROKEN_FORCED_BY_APPLICATION = 2,
+	/* brief TBD */
+	DDI_BC_BROKEN_EXTERNAL_BATTERY_VOLTAGE_DETECTED = 3,
+	/* brief TBD */
+	DDI_BC_BROKEN_NO_BATTERY_DETECTED = 4,
+
+} ddi_bc_BrokenReason_t;
+
+/* brief Defines the battery charger configuration. */
+typedef struct _ddi_bc_Cfg {
+	/* brief Units in milliseconds. */
+	/*  */
+	/*  This field configures the expected period between calls to */
+	/*  ddi_bc_StateMachine. If die temperature monitoring is */
+	/*  enabled, then the data sheet recommends the period be around */
+	/*  100ms or less. */
+	/*  */
+	/*  Note that this period defines the minimum time resolution of */
+	/*  the battery charger. */
+
+	uint32_t u32StateMachinePeriod;
+
+	/* brief Units in mA/s. */
+	/*  */
+	/*  This field configures the slope of the current ramp. Any */
+	/*  time the battery charger increases its current draw, it will */
+	/*  ramp up the current no faster than this rate. */
+	/*  */
+	/*  Note that the minimum time resolution of the battery charger */
+	/*  is the configured period between calls to advance the state */
+	/*  machine. Also, the hardware has a minimum current resolution */
+	/*  of 10mA. If the given ramp slope cannot be expressed */
+	/*  exactly, then the largest expressible smaller slope will be */
+	/*  the result. If the actual period between calls to */
+	/*  ddi_bc_StateMachine is irregular, the current may ramp faster */
+	/*  than indicated. */
+
+	uint16_t u16CurrentRampSlope;
+
+	/* brief Units in millivolts. */
+	/*  */
+	/*  This field configures the threshold conditioning voltage. If */
+	/*  the battery's voltage is below this value, it will be */
+	/*  conditioned until its voltage rises above the maximum */
+	/*  conditioning voltage.  After that, the battery will be */
+	/*  charged normally. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 8mV. If */
+	/*  the given voltage cannot be expressed exactly, then the */
+	/*  smallest expressible larger value will be used. */
+
+	uint16_t u16ConditioningThresholdVoltage;
+
+	/* brief Units in millivolts. */
+	/*  */
+	/*  This field configures the maximum conditioning voltage. If */
+	/*  the battery charger is conditioning a battery, normal */
+	/*  charging begins when the voltage rises above this value. */
+	/*  */
+	/*  This value should be slightly higher than the threshold */
+	/*  conditioning voltage because it is measured while a */
+	/*  conditioning current is actually flowing to the battery. */
+	/*  With a conditioning current of 0.1C, reasonable values for */
+	/*  the threshold and maximum conditioning voltages are 2.9V */
+	/*  and 3.0V respectively. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 8mV. If */
+	/*  the given voltage cannot be expressed exactly, then the */
+	/*  smallest expressible larger value will be used. */
+
+	uint16_t u16ConditioningMaxVoltage;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  This field configures the maximum conditioning current. */
+	/*  This is the maximum current that will be offered to a */
+	/*  battery while it is being conditioned. A typical value is */
+	/*  0.1C. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 10mA */
+	/*  (see the data sheet for details). If the given current */
+	/*  cannot be expressed exactly, then the largest expressible */
+	/*  smaller value will be used. */
+
+	uint16_t u16ConditioningCurrent;
+
+	/* brief Units in milliseconds. */
+	/*  */
+	/*  This field configures the conditioning time-out. This is */
+	/*  the maximum amount of time that a battery will be */
+	/*  conditioned before the battery charger declares it to be */
+	/*  broken. */
+	/*  */
+	/*  Note that the minimum time resolution of the battery */
+	/*  charger is the configured period between calls to advance */
+	/*  the state machine. If the given time-out cannot be */
+	/*  expressed exactly, then the shortest expressible longer */
+	/*  value will be used. */
+
+	uint32_t u32ConditioningTimeout;
+
+	/* brief Units in millivolts. */
+	/*  */
+	/*  This field configures the final charging voltage. At this */
+	/*  writing, only two values are permitted: 4100 or 4200. */
+
+	uint16_t u16ChargingVoltage;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  This field configures the maximum current offered to a */
+	/*  charging battery. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 10mA */
+	/*  (see the data sheet for details). If the given current */
+	/*  cannot be expressed exactly, then the largest expressible */
+	/*  smaller value will be used. */
+
+	uint16_t u16ChargingCurrent;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  This field configures the current flow below which a */
+	/*  charging battery is regarded as fully charged (typical */
+	/*  0.1C). At this point, the battery will be topped off. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 10mA */
+	/*  (see the data sheet for details). If the given current */
+	/*  cannot be expressed exactly, then the largest expressible */
+	/*  smaller value will be used. */
+
+	uint16_t u16ChargingThresholdCurrent;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  When charging while the DCDC converter's are enabled, the charger */
+	/*  is suppling current to both the battery and the Vbat input of the */
+	/*  DCDC converter.  Once the total battery charger current falls */
+	/*  below this level, the charger will then stop charging until the */
+	/*  the battery voltage reaches the BC_LOW_DCDCMODE_BATTERY_VOLTAGE */
+	/*  threshold or until the DCDCs are no longer enabled. */
+	/*  */
+	/*  Typically, this value should be left at 180 to avoid the risk */
+	/*  of topping off the battery too long in DCDC mode and avoid */
+	/*  exceeding the BC_CHARGING_TIMEOUT time which would put the charger */
+	/*  driver in the broken state and completely disable charging. */
+	/*  */
+	/*  Note that the hardware has a minimum resolution of 10mA */
+	/*  (see the data sheet for details). If the given current */
+	/*  cannot be expressed exactly, then the largest expressible */
+	/*  smaller value will be used. */
+	uint16_t u16DdcdModeChargingThresholdCurrent;
+
+	/* brief Units in milliseconds. */
+	/*  */
+	/*  This field configures the charging time-out. This is the */
+	/*  maximum amount of time that a battery will be charged */
+	/*  before the battery charger declares it to be broken. */
+	/*  */
+	/*  Note that the minimum time resolution of the battery */
+	/*  charger is the configured period between calls to advance */
+	/*  the state machine. If the given time-out cannot be */
+	/*  expressed exactly, then the shortest expressible longer */
+	/*  value will be used. */
+
+	uint32_t u32ChargingTimeout;
+
+	/* brief Units in milliseconds. */
+	/*  */
+	/*  This field configures the top-off period. This is the */
+	/*  amount of time a battery will be held in the Topping Off */
+	/*  state before it is declared fully charged. */
+	/*  */
+	/*  Note that the minimum time resolution of the battery */
+	/*  charger is the configured period between calls to advance */
+	/*  the state machine. If the given time-out cannot be */
+	/*  expressed exactly, then the shortest expressible longer */
+	/*  value will be used. */
+
+	uint32_t u32TopOffPeriod;
+
+	/* brief Units in milliseconds. */
+	/*  */
+	/*  This field configures the top-off period when the DCDC */
+	/*  converters are enabled. To avoid topping off the LiIon */
+	/*  battery too long and reducing it's long term capacity, */
+	/*  This time should be kept failry short. */
+	/*  */
+	/*  Note that the minimum time resolution of the battery */
+	/*  charger is the configured period between calls to advance */
+	/*  the state machine. If the given time-out cannot be */
+	/*  expressed exactly, then the shortest expressible longer */
+	/*  value will be used. */
+	uint32_t u32DcdcModeTopOffPeriod;
+
+	/* brief Causes the battery charger to use an externally generated bias current */
+	/*  */
+	/*  If cleared, this causes the battery charger to use an */
+	/*  externally generated bias current, which is expected to be */
+	/*  quite precise. Otherwise, the battery charger will */
+	/*  generate a lesser-quality bias current internally. */
+
+	uint8_t useInternalBias:1;
+
+	/* brief Indicates that the battery charger is to monitor the die temperature. */
+	/*  */
+	/*  If set, this field indicates that the battery charger is to */
+	/*  monitor the die temperature. See below for fields that */
+	/*  configure the details. */
+
+	uint8_t monitorDieTemp:1;
+
+	/* brief Indicates that the battery charger is to monitor the battery temperature. */
+	/*  */
+	/*  If set, this field indicates that the battery charger is to */
+	/*  monitor the battery temperature. See below for fields that */
+	/*  configure the details. */
+
+	uint8_t monitorBatteryTemp:1;
+
+	/* brief Units in degrees centigrade. */
+	/*  */
+	/*  Note that the hardware reports die temperature in ranges of */
+	/*  10 degree resolution minimum (see the data sheet for */
+	/*  details). If the battery charger is monitoring the die */
+	/*  temperature, and it rises to a range that includes a */
+	/*  temperature greater than or equal to this value, the */
+	/*  charging current will be clamped to the safe current. */
+
+	int8_t u8DieTempHigh;
+
+	/* brief Units in degrees centigrade. */
+	/*  */
+	/*  Note that the hardware reports die temperature in ranges of */
+	/*  10 degrees minimum (see the data sheet for details). If the */
+	/*  charging current is being clamped because of a high die */
+	/*  temperature, and it falls to a range that doesn't include a */
+	/*  temperatures greater than or equal to this value, the */
+	/*  charging current clamp will be released. */
+
+	int8_t u8DieTempLow;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  If the battery charger detects a high die temperature, it */
+	/*  will clamp the charging current at or below this value. */
+
+	uint16_t u16DieTempSafeCurrent;
+
+	/* brief If the battery charger is monitoring the battery */
+	/*  temperature, this field indicates the LRADC channel to */
+	/*  read. */
+
+	uint8_t u8BatteryTempChannel;
+
+	/* brief If the battery charger is monitoring the battery */
+	/*  temperature, and it rises to a measurement greater than or */
+	/*  equal to this value, the charging current will be clamped */
+	/*  to the corresponding safe current. */
+
+	uint16_t u16BatteryTempHigh;
+
+	/* brief If the charging current is being clamped because of a high */
+	/*  battery temperature, and it falls below this value, the */
+	/*  charging current clamp will be released. */
+
+	uint16_t u16BatteryTempLow;
+
+	/* brief Units in milliamps. */
+	/*  */
+	/*  If the battery charger detects a high battery temperature, */
+	/*  it will clamp the charging current at or below this value. */
+
+	uint16_t u16BatteryTempSafeCurrent;
+
+	/* brief Units in millivolts. */
+	/*  */
+	/*  In the WaitingToCharge state, if we are in DCDC */
+	/*  operating modes, if the battery voltage measurement */
+	/*  is below this value, we immediately proceed with charging. */
+	/*  the low criteria for this value is that it must be high */
+	/*  to not risk the battery voltage getting too low.  The */
+	/*  upper criteria is that you do not want the IR voltage */
+	/*  drop under heavy loads to make you start charging too soon */
+	/*  because the goal in DCDC operating mode is to not be constantly */
+	/*  topping off the battery which can shorten its life */
+
+	uint16_t u16LowDcdcBatteryVoltage_mv;
+
+	uint32_t u32StateMachineNonChargingPeriod;
+} ddi_bc_Cfg_t;
+
+/*  Status returned by Battery Charger functions. */
+
+typedef enum _ddi_bc_Status {
+	/* brief TBD */
+	DDI_BC_STATUS_SUCCESS = 0,
+	/* brief TBD */
+	DDI_BC_STATUS_HARDWARE_DISABLED,
+	/* brief TBD */
+	DDI_BC_STATUS_BAD_BATTERY_MODE,
+	/* brief TBD */
+	DDI_BC_STATUS_CLOCK_GATE_CLOSED,
+	/* brief TBD */
+	DDI_BC_STATUS_NOT_INITIALIZED,
+	/* brief TBD */
+	DDI_BC_STATUS_ALREADY_INITIALIZED,
+	/* brief TBD */
+	DDI_BC_STATUS_BROKEN,
+	/* brief TBD */
+	DDI_BC_STATUS_NOT_BROKEN,
+	/* brief TBD */
+	DDI_BC_STATUS_NOT_DISABLED,
+	/* brief TBD */
+	DDI_BC_STATUS_BAD_ARGUMENT,
+	/* brief TBD */
+	DDI_BC_STATUS_CFG_BAD_BATTERY_TEMP_CHANNEL,
+	/* brief TBD */
+	DDI_BC_STATUS_CFG_BAD_CHARGING_VOLTAGE,
+} ddi_bc_Status_t;
+
+
+/*  BCM Event Codes */
+
+/* These are the codes that might be published to PMI Subscribers. */
+
+
+#define DDI_BC_EVENT_GROUP (11<<10)
+
+/* brief TBD */
+/* todo [PUBS] Add definition(s)... */
+typedef enum {
+	/* Use the error code group value to make events unique for the EOI */
+	/* brief TBD */
+	ddi_bc_MinEventCode = DDI_BC_EVENT_GROUP,
+	/* brief TBD */
+	ddi_bc_WaitingToChargeCode,
+	/* brief TBD */
+	ddi_bc_State_ConditioningCode,
+	/* brief TBD */
+	ddi_bc_State_Topping_OffCode,
+	/* brief TBD */
+	ddi_bc_State_BrokenCode,
+	/* brief TBD */
+	ddi_bc_SettingChargeCode,
+	/* brief TBD */
+	ddi_bc_RaisingDieTempAlarmCode,
+	/* brief TBD */
+	ddi_bc_DroppingDieTempAlarmCode,
+
+	/* brief TBD */
+	ddi_bc_MaxEventCode,
+	/* brief TBD */
+	ddi_bc_DcdcModeWaitingToChargeCode
+} ddi_bc_Event_t;
+
+
+/* Prototypes */
+
+
+
+/* brief Initialize the Battery Charger. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function initializes the Battery Charger. */
+/*  */
+/* param[in]  pCfg  A pointer to the new configuration. */
+/*  */
+/* retval  DDI_BC_STATUS_SUCCESS */
+/*              If the operation succeeded. */
+/* retval  DDI_BC_STATUS_ALREADY_INITIALIZED */
+/*              If the Battery Charger is already initialized. */
+/* retval  DDI_BC_STATUS_HARDWARE_DISABLED */
+/*              If the Battery Charger hardware is disabled by a laser fuse. */
+/* retval  DDI_BC_STATUS_BAD_BATTERY_MODE */
+/*              If the power supply is set up for a non-rechargeable battery. */
+/* retval  DDI_BC_STATUS_CLOCK_GATE_CLOSED */
+/*              If the clock gate for the power supply registers is closed. */
+/* retval  DDI_BC_STATUS_CFG_BAD_CHARGING_VOLTAGE */
+/*              If the charging voltage is not either 4100 or 4200. */
+/* retval  DDI_BC_STATUS_CFG_BAD_BATTERY_TEMP_CHANNEL */
+/*              If the LRADC channel number for monitoring battery temperature */
+/*              is bad. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_init.c. */
+
+extern ddi_bc_Status_t ddi_bc_Init(ddi_bc_Cfg_t *pCfg);
+
+/*  */
+/* brief Report the Battery Charger configuration. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function reports the Battery Charger configuration. */
+/*  */
+/*  Note that, if the Battery Charger has not yet been initialized, the data */
+/*  returned by this function is unknown. */
+/*  */
+/* param[in,out]  pCfg  A pointer to a structure that will receive the data. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern void ddi_bc_QueryCfg(ddi_bc_Cfg_t *pCfg);
+
+/*  */
+/* brief Shut down the Battery Charger. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function immediately shuts down the Battery Charger hardware and */
+/*  returns the state machine to the Uninitialized state. Use this function to */
+/*  safely mummify the battery charger before retiring it from memory. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern void ddi_bc_ShutDown(void);
+
+/*  */
+/* brief Advances the state machine. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function advances the state machine. */
+/*  */
+/* retval DDI_BC_STATUS_SUCCESS          If all goes well */
+/* retval DDI_BC_STATUS_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/* retval DDI_BC_STATUS_BROKEN           If the battery violated a time-out */
+/*                                         and has been declared broken. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_Status_t ddi_bc_StateMachine(void);
+
+/*  */
+/* brief Get the Battery Charger's current state. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function returns the current state. */
+/*  */
+/* retval The current state. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_State_t ddi_bc_GetState(void);
+
+/*  */
+/* brief Disable the Battery Charger. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function forces the Battery Charger into the Disabled state. */
+/*  */
+/* retval DDI_BC_STATUS_SUCCESS          If all goes well */
+/* retval DDI_BC_STATUS_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_Status_t ddi_bc_SetDisable(void);
+
+/*  */
+/* brief Enable the Battery Charger. */
+/*  */
+/* fntype Function */
+/*  */
+/*  If the Battery Charger is in the Disabled state, this function moves it to */
+/*  the Waiting to Charge state. */
+/*  */
+/* retval DDI_BC_STATUS_SUCCESS          If all goes well */
+/* retval DDI_BC_STATUS_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/* retval DDI_BC_STATUS_NOT_DISABLED     If the Battery Charger is not */
+/*                                         disabled. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_Status_t ddi_bc_SetEnable(void);
+
+/*  */
+/* brief Declare the battery to be broken. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function forces the Battery Charger into the Broken state. */
+/*  */
+/* retval DDI_BC_STATUS_SUCCESS          If all goes well */
+/* retval DDI_BC_STATUS_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_Status_t ddi_bc_SetBroken(void);
+
+/*  */
+/* brief Declare the battery to be fixed. */
+/*  */
+/* fntype Function */
+/*  */
+/*  If the Battery Charger is in the Broken state, this function moves it to */
+/*  the Disabled state. */
+/*  */
+/* retval DDI_BC_STATUS_SUCCESS          If all goes well */
+/* retval DDI_BC_STATUS_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/* retval DDI_BC_STATUS_NOT_BROKEN       If the Battery Charger is not broken. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern ddi_bc_Status_t ddi_bc_SetFixed(void);
+
+/*  */
+/* brief Set the current limit. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function applies a limit to the current that the Battery Charger can */
+/*  draw. */
+/*  */
+/* param[in]  u16Limit  The maximum current the Battery Charger can draw */
+/*                        (in mA). */
+/*  */
+/* retval  The expressible version of the limit. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern uint16_t ddi_bc_SetCurrentLimit(uint16_t u16Limit);
+
+
+/*  */
+/* brief Report the current limit. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function reports the limit to the current that the Battery Charger can */
+/*  draw. */
+/*  */
+/* retval  The current limit. */
+/*  */
+/* internal */
+/* see To view the function definition, see ddi_bc_api.c. */
+
+extern uint16_t ddi_bc_GetCurrentLimit(void);
+
+
+/*  */
+/* brief Set the current threshold. */
+/*  */
+/* fntype Function */
+/*  */
+/*  */
+/* param[in]  u16Current Current threshold where charger deactivates (in mA). */
+/*  */
+/*  */
+
+extern uint16_t ddi_bc_SetCurrentThreshold(uint16_t u16Current);
+
+
+/*  */
+/* brief Set the battery charger state machine period. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function sets a new state machine period.  The Period and Slope should */
+/*  be coordinated to achieve the minimal ramp step current which will minimize */
+/*  transients on the system. */
+/*  */
+/* param[in]  u32StateMachinePeriod  (in milliseconds) */
+/* param[in]  u16CurrentRampSlope (in mA/s) */
+/*  */
+/* retval SUCCESS                        If all goes well */
+/* retval ERROR_DDI_BCM_NOT_INITIALIZED  If the Battery Charger is not yet */
+/*                                         initialized. */
+/*  */
+
+extern ddi_bc_Status_t ddi_bc_SetNewPeriodAndSlope(uint32_t
+						   u32StateMachinePeriod,
+						   uint16_t
+						   u16CurrentRampSlope);
+
+
+/*  */
+/* brief Report the state machine period. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function reports the battery charger period. */
+/*  */
+/* retval  The battery charger period (in milliseconds). */
+/*  */
+
+extern uint32_t ddi_bc_GetStateMachinePeriod(void);
+
+
+/*  */
+/* brief Report the current ramp slope. */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function reports the current ramp slope. */
+/*  */
+/* retval  The current ramp slope (in mA/s). */
+/*  */
+
+extern uint32_t ddi_bc_GetCurrentRampSlope(void);
+
+
+/*  */
+/* brief Report the time spent in the present state (milliseconds) */
+/*  */
+/* fntype Function */
+/*  */
+/*  This function reports the time spent in the present charging state.  Note that */
+/*  for the states that actually charge the battery, this time does not include the */
+/*  time spent under alarm conditions such as die termperature alarm or battery */
+/*  temperature alarm. */
+/*  */
+/* retval  The time spent in the current state in milliseconds. */
+/*  */
+
+uint32_t ddi_bc_GetStateTime(void);
+
+
+/*  */
+/* brief Report the reason for being in the broken state */
+/*  */
+/* fntype Function */
+/*  */
+/*  */
+/* retval  ddi_bc_BrokenReason_t enumeration */
+/*  */
+
+ddi_bc_BrokenReason_t ddi_bc_GetBrokenReason(void);
+
+
+/*  */
+/* brief Restart the charge cycle */
+/*  */
+/* fntype Function */
+/*  */
+/* retval  SUCCESS */
+/*  */
+
+ddi_bc_Status_t ddi_bc_ForceChargingToStart(void);
+
+void fsl_enable_usb_plugindetect(void);
+
+int fsl_is_usb_plugged(void);
+
+/* End of file */
+
+#endif				/* _DDI_BC_H */
+/*  @} */
diff --git a/arch/arm/plat-mxs/include/mach/debug-macro.S b/arch/arm/plat-mxs/include/mach/debug-macro.S
new file mode 100644
index 0000000..651bdcd
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/debug-macro.S
@@ -0,0 +1,42 @@
+/*
+ * Debugging macro include header
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <mach/hardware.h>
+
+		.macro	addruart,rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+	 	ldreq   \rx, =MXS_LL_UART_PADDR @ physical
+		ldrne   \rx, =MXS_LL_UART_VADDR @ virtual
+		.endm
+
+		.macro	senduart,rd,rx
+		strb	\rd, [\rx, #0]		@ data register at 0
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 5		@ UARTFLGUTXFF - 1 when full
+		bne	1001b
+		.endm
+
+		.macro	busyuart,rd,rx
+1001:		ldr	\rd, [\rx, #0x18]	@ UARTFLG
+		tst	\rd, #1 << 3		@ UARTFLGUBUSY - 1 when busy
+		bne	1001b
+		.endm
diff --git a/arch/arm/plat-mxs/include/mach/device.h b/arch/arm/plat-mxs/include/mach/device.h
new file mode 100644
index 0000000..9598ccd
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/device.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_DEVICE_H
+#define __ASM_ARM_ARCH_DEVICE_H
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/leds.h>
+
+#include <asm/mach/time.h>
+
+#define MXS_MAX_DEVICES 128
+
+struct mxs_sys_timer {
+	struct sys_timer timer;
+	unsigned char id;
+	unsigned char clk_sel;
+	unsigned char resv[2];
+	int irq;
+	struct clk *clk;
+	void __iomem *base;
+};
+
+struct mxs_dev_lookup {
+	char *name;
+	unsigned long lock;
+	int size;
+	struct platform_device *pdev;
+};
+
+/* Define the Platform special structure for each device type*/
+struct mxs_dma_plat_data {
+	unsigned int burst8:1;
+	unsigned int burst:1;
+	unsigned int chan_base;
+	unsigned int chan_num;
+};
+
+struct mxs_i2c_plat_data {
+	unsigned int pioqueue_mode:1;
+};
+
+struct mxs_lradc_plat_data {
+	unsigned int vddio_voltage;
+	unsigned int battery_voltage;
+};
+
+struct mxskbd_keypair {
+	int raw;
+	int kcode;
+};
+
+struct mxs_kbd_plat_data {
+	struct mxskbd_keypair *keypair;
+	int channel;
+	unsigned int btn_enable; /* detect enable bits */
+	unsigned int btn_irq_stat; /* detect irq status bits */
+	unsigned int btn_irq_ctrl; /* detect irq enable bits */
+};
+
+struct mxs_touchscreen_plat_data {
+	u8 x_plus_chan;
+	u8 x_minus_chan;
+	u8 y_plus_chan;
+	u8 y_minus_chan;
+	unsigned int x_plus_val;
+	unsigned int x_minus_val;
+	unsigned int y_plus_val;
+	unsigned int y_minus_val;
+	unsigned int x_plus_mask;
+	unsigned int x_minus_mask;
+	unsigned int y_plus_mask;
+	unsigned int y_minus_mask;
+};
+
+struct mxs_auart_plat_data {
+	unsigned int fifo_size:6;
+	unsigned int dma_mode:1;
+	unsigned int timeout;
+	unsigned int dma_rx_buffer_size;
+	const char *clk;
+};
+
+struct mxs_pwm_led {
+	struct led_classdev dev;
+	const char *name;
+	unsigned int pwm;
+};
+
+struct mxs_pwm_leds_plat_data {
+	unsigned int num;
+	struct mxs_pwm_led *leds;
+};
+
+struct mxs_mma7450_platform_data {
+	char *reg_dvdd_io;
+	char *reg_avdd;
+	void (*gpio_pin_get) (void);
+	void (*gpio_pin_put) (void);
+	int int1;
+	int int2;
+};
+
+struct mxs_spi_platform_data {
+	int (*hw_pin_init)(void);
+	int (*hw_pin_release)(void);
+};
+
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	void (*xcvr_enable) (int id, int en);
+	void (*active) (int id);
+	void (*inactive) (int id);
+	/* word 1 */
+	unsigned int br_presdiv:8;
+	unsigned int br_rjw:2;
+	unsigned int br_propseg:3;
+	unsigned int br_pseg1:3;
+	unsigned int br_pseg2:3;
+	unsigned int maxmb:6;
+	unsigned int xmit_maxmb:6;
+	unsigned int wd1_resv:1;
+
+	/* word 2 */
+	unsigned int fifo:1;
+	unsigned int wakeup:1;
+	unsigned int srx_dis:1;
+	unsigned int wak_src:1;
+	unsigned int bcc:1;
+	unsigned int lprio:1;
+	unsigned int abort:1;
+	unsigned int br_clksrc:1;
+	unsigned int loopback:1;
+	unsigned int smp:1;
+	unsigned int boff_rec:1;
+	unsigned int tsyn:1;
+	unsigned int listen:1;
+	unsigned int ext_msg:1;
+	unsigned int std_msg:1;
+};
+
+struct mxs_audio_platform_data {
+	int intr_id_hp;
+	int ext_ram;
+	struct clk *saif_mclock;
+
+	int hp_irq;
+	int (*hp_status) (void);
+
+	int sysclk;
+
+	int (*init) (void);	/* board specific init */
+	int (*amp_enable) (int enable);
+	int (*finit) (void);	/* board specific finit */
+	void *priv;		/* used by board specific functions */
+};
+
+struct mxs_persistent_bit_config {
+	int reg;
+	int start;
+	int width;
+	const char *name;
+};
+
+struct mxs_platform_persistent_data {
+	const struct mxs_persistent_bit_config *bit_config_tab;
+	int bit_config_cnt;
+};
+
+extern void mxs_timer_init(struct mxs_sys_timer *timer);
+extern void mxs_nomatch_timer_init(struct mxs_sys_timer *timer);
+
+extern void mxs_nop_release(struct device *dev);
+extern int mxs_add_devices(struct platform_device *, int num, int level);
+extern int mxs_add_device(struct platform_device *, int level);
+extern struct platform_device *mxs_get_device(char *name, int id);
+extern struct mxs_dev_lookup *mxs_get_devices(char *name);
+
+extern int iram_init(unsigned long base, unsigned long size);
+
+/* mxs ssp sd/mmc data definitons */
+struct mxs_mmc_platform_data {
+	int (*hw_init)(void);
+	void (*hw_release)(void);
+	void (*cmd_pullup)(int enable);
+	int (*get_wp)(void);
+	unsigned long (*setclock)(unsigned long hz);
+	unsigned int caps;
+	unsigned int min_clk;
+	unsigned int max_clk;
+	int read_uA;
+	int write_uA;
+	char *power_mmc;
+	char *clock_mmc;
+};
+/* end of mxs ssp sd/mmc data definitions */
+
+#ifdef CONFIG_MXS_ICOLL
+extern void __init avic_init_irq(void __iomem *base, int nr_irqs);
+#endif
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/dmaengine.h b/arch/arm/plat-mxs/include/mach/dmaengine.h
new file mode 100644
index 0000000..eecd260
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/dmaengine.h
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_DMA_H
+#define __ASM_ARM_ARCH_DMA_H
+
+#ifndef ARCH_DMA_PIO_WORDS
+#define DMA_PIO_WORDS	15
+#else
+#define DMA_PIO_WORDS	ARCH_DMA_PIO_WORDS
+#endif
+
+#define MXS_DMA_ALIGNMENT	8
+
+/**
+ * struct mxs_dma_cmd_bits - MXS DMA hardware command bits.
+ *
+ * This structure describes the in-memory layout of the command bits in a DMA
+ * command. See the appropriate reference manual for a detailed description
+ * of what these bits mean to the DMA hardware.
+ */
+struct mxs_dma_cmd_bits {
+	unsigned int command:2;
+#define NO_DMA_XFER	0x00
+#define DMA_WRITE	0x01
+#define DMA_READ	0x02
+#define DMA_SENSE	0x03
+
+	unsigned int chain:1;
+	unsigned int irq:1;
+	unsigned int nand_lock:1;
+	unsigned int nand_wait_4_ready:1;
+	unsigned int dec_sem:1;
+	unsigned int wait4end:1;
+	unsigned int halt_on_terminate:1;
+	unsigned int terminate_flush:1;
+	unsigned int resv2:2;
+	unsigned int pio_words:4;
+	unsigned int bytes:16;
+};
+
+/**
+ * struct mxs_dma_cmd - MXS DMA hardware command.
+ *
+ * This structure describes the in-memory layout of an entire DMA command,
+ * including space for the maximum number of PIO accesses. See the appropriate
+ * reference manual for a detailed description of what these fields mean to the
+ * DMA hardware.
+ */
+struct mxs_dma_cmd {
+	unsigned long next;
+	union {
+		unsigned long data;
+		struct mxs_dma_cmd_bits bits;
+	} cmd;
+	union {
+		dma_addr_t address;
+		unsigned long alternate;
+	};
+	unsigned long pio_words[DMA_PIO_WORDS];
+};
+
+/**
+ * struct mxs_dma_desc - MXS DMA command descriptor.
+ *
+ * This structure incorporates an MXS DMA hardware command structure, along
+ * with metadata.
+ *
+ * @cmd:      The MXS DMA hardware command block.
+ * @flags:    Flags that represent the state of this DMA descriptor.
+ * @address:  The physical address of this descriptor.
+ * @buffer:   A convenient place for software to put the virtual address of the
+ *            associated data buffer (the physical address of the buffer
+ *            appears in the DMA command). The MXS platform DMA software doesn't
+ *            use this field -- it is provided as a convenience.
+ * @node:     Links this structure into a list.
+ */
+struct mxs_dma_desc {
+	struct mxs_dma_cmd cmd;
+	unsigned int flags;
+#define MXS_DMA_DESC_READY 0x80000000
+#define MXS_DMA_DESC_FIRST 0x00000001
+#define MXS_DMA_DESC_LAST  0x00000002
+	dma_addr_t address;
+	void *buffer;
+	struct list_head node;
+};
+
+struct mxs_dma_info {
+	unsigned int status;
+#define MXS_DMA_INFO_ERR       0x00000001
+#define MXS_DMA_INFO_ERR_STAT  0x00010000
+	unsigned int buf_addr;
+};
+
+/**
+ * struct mxs_dma_chan - MXS DMA channel
+ *
+ * This structure represents a single DMA channel. The MXS platform code
+ * maintains an array of these structures to represent every DMA channel in the
+ * system (see mxs_dma_channels).
+ *
+ * @name:         A human-readable string that describes how this channel is
+ *                being used or what software "owns" it. This field is set when
+ *                when the channel is reserved by mxs_dma_request().
+ * @dev:          A pointer to a struct device *, cast to an unsigned long, and
+ *                representing the software that "owns" the channel. This field
+ *                is set when when the channel is reserved by mxs_dma_request().
+ * @lock:         Arbitrates access to this channel.
+ * @dma:          A pointer to a struct mxs_dma_device representing the driver
+ *                code that operates this channel.
+ * @flags:        Flag bits that represent the state of this channel.
+ * @active_num:   If the channel is not busy, this value is zero. If the channel
+ *                is busy, this field contains the number of DMA command
+ *                descriptors at the head of the active list that the hardware
+ *                has been told to process. This value is set at the moment the
+ *                channel is enabled by mxs_dma_enable(). More descriptors may
+ *                arrive after the channel is enabled, so the number of
+ *                descriptors on the active list may be greater than this value.
+ *                In fact, it should always be active_num + pending_num.
+ * @pending_num:  The number of DMA command descriptors at the tail of the
+ *                active list that the hardware has not been told to process.
+ * @active:       The list of DMA command descriptors either currently being
+ *                processed by the hardware or waiting to be processed.
+ *                Descriptors being processed appear at the head of the list,
+ *                while pending descriptors appear at the tail. The total number
+ *                should always be active_num + pending_num.
+ * @done:         The list of DMA command descriptors that have either been
+ *                processed by the DMA hardware or aborted by a call to
+ *                mxs_dma_disable().
+ */
+struct mxs_dma_chan {
+	const char *name;
+	unsigned long dev;
+	spinlock_t lock;
+	struct mxs_dma_device *dma;
+	unsigned int flags;
+#define MXS_DMA_FLAGS_IDLE	0x00000000
+#define MXS_DMA_FLAGS_BUSY	0x00000001
+#define MXS_DMA_FLAGS_FREE	0x00000000
+#define MXS_DMA_FLAGS_ALLOCATED	0x00010000
+#define MXS_DMA_FLAGS_VALID	0x80000000
+	unsigned int active_num;
+	unsigned int pending_num;
+	struct list_head active;
+	struct list_head done;
+};
+
+/**
+ * struct mxs_dma_device - DMA channel driver interface.
+ *
+ * This structure represents the driver that operates a DMA channel. Every
+ * struct mxs_dma_chan contains a pointer to a structure of this type, which is
+ * installed when the driver registers to "own" the channel (see
+ * mxs_dma_device_register()).
+ */
+struct mxs_dma_device {
+	struct list_head node;
+	const char *name;
+	void __iomem *base;
+	unsigned int chan_base;
+	unsigned int chan_num;
+	unsigned int data;
+	struct platform_device *pdev;
+
+	/* operations */
+	int (*enable) (struct mxs_dma_chan *, unsigned int);
+	void (*disable) (struct mxs_dma_chan *, unsigned int);
+	void (*reset) (struct mxs_dma_device *, unsigned int);
+	void (*freeze) (struct mxs_dma_device *, unsigned int);
+	void (*unfreeze) (struct mxs_dma_device *, unsigned int);
+	int (*read_semaphore) (struct mxs_dma_device *, unsigned int);
+	void (*add_semaphore) (struct mxs_dma_device *, unsigned int, unsigned);
+	void (*info)(struct mxs_dma_device *,
+		unsigned int, struct mxs_dma_info *info);
+	void (*enable_irq) (struct mxs_dma_device *, unsigned int, int);
+	int (*irq_is_pending) (struct mxs_dma_device *, unsigned int);
+	void (*ack_irq) (struct mxs_dma_device *, unsigned int);
+
+	void (*set_target) (struct mxs_dma_device *, unsigned int, int);
+};
+
+/**
+ * mxs_dma_device_register - Register a DMA driver.
+ *
+ * This function registers a driver for a contiguous group of DMA channels (the
+ * ordering of DMA channels is specified by the globally unique DMA channel
+ * numbers given in mach/dma.h).
+ *
+ * @pdev:  A pointer to a structure that represents the driver. This structure
+ *         contains fields that specify the first DMA channel number and the
+ *         number of channels.
+ */
+extern int mxs_dma_device_register(struct mxs_dma_device *pdev);
+
+/**
+ * mxs_dma_request - Request to reserve a DMA channel.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @dev:      A pointer to a struct device representing the channel "owner."
+ * @name:     A human-readable string that identifies the channel owner or the
+ *            purpose of the channel.
+ */
+extern int mxs_dma_request(int channel, struct device *dev, const char *name);
+
+/**
+ * mxs_dma_release - Release a DMA channel.
+ *
+ * This function releases a DMA channel from its current owner.
+ *
+ * The channel will NOT be released if it's marked "busy" (see
+ * mxs_dma_enable()).
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @dev:      A pointer to a struct device representing the channel "owner." If
+ *            this doesn't match the owner given to mxs_dma_request(), the
+ *            channel will NOT be released.
+ */
+extern void mxs_dma_release(int channel, struct device *dev);
+
+/**
+ * mxs_dma_enable - Enable a DMA channel.
+ *
+ * If the given channel has any DMA descriptors on its active list, this
+ * function causes the DMA hardware to begin processing them.
+ *
+ * This function marks the DMA channel as "busy," whether or not there are any
+ * descriptors to process.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern int mxs_dma_enable(int channel);
+
+/**
+ * mxs_dma_disable - Disable a DMA channel.
+ *
+ * This function shuts down a DMA channel and marks it as "not busy." Any
+ * descriptors on the active list are immediately moved to the head of the
+ * "done" list, whether or not they have actually been processed by the
+ * hardware. The "ready" flags of these descriptors are NOT cleared, so they
+ * still appear to be active.
+ *
+ * This function immediately shuts down a DMA channel's hardware, aborting any
+ * I/O that may be in progress, potentially leaving I/O hardware in an undefined
+ * state. It is unwise to call this function if there is ANY chance the hardware
+ * is still processing a command.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern void mxs_dma_disable(int channel);
+
+/**
+ * mxs_dma_reset - Resets the DMA channel hardware.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern void mxs_dma_reset(int channel);
+
+/**
+ * mxs_dma_freeze - Freeze a DMA channel.
+ *
+ * This function causes the channel to continuously fail arbitration for bus
+ * access, which halts all forward progress without losing any state. A call to
+ * mxs_dma_unfreeze() will cause the channel to continue its current operation
+ * with no ill effect.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern void mxs_dma_freeze(int channel);
+
+/**
+ * mxs_dma_unfreeze - Unfreeze a DMA channel.
+ *
+ * This function reverses the effect of mxs_dma_freeze(), enabling the DMA
+ * channel to continue from where it was frozen.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+
+extern void mxs_dma_unfreeze(int channel);
+
+/* get dma channel information */
+extern int mxs_dma_get_info(int channel, struct mxs_dma_info *info);
+
+/**
+ * mxs_dma_cooked - Clean up processed DMA descriptors.
+ *
+ * This function removes processed DMA descriptors from the "active" list. Pass
+ * in a non-NULL list head to get the descriptors moved to your list. Pass NULL
+ * to get the descriptors moved to the channel's "done" list. Descriptors on
+ * the "done" list can be retrieved with mxs_dma_get_cooked().
+ *
+ * This function marks the DMA channel as "not busy" if no unprocessed
+ * descriptors remain on the "active" list.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @head:     If this is not NULL, it is the list to which the processed
+ *            descriptors should be moved. If this list is NULL, the descriptors
+ *            will be moved to the "done" list.
+ */
+extern int mxs_dma_cooked(int channel, struct list_head *head);
+
+/**
+ * mxs_dma_read_semaphore - Read a DMA channel's hardware semaphore.
+ *
+ * As used by the MXS platform's DMA software, the DMA channel's hardware
+ * semaphore reflects the number of DMA commands the hardware will process, but
+ * has not yet finished. This is a volatile value read directly from hardware,
+ * so it must be be viewed as immediately stale.
+ *
+ * If the channel is not marked busy, or has finished processing all its
+ * commands, this value should be zero.
+ *
+ * See mxs_dma_append() for details on how DMA command blocks must be configured
+ * to maintain the expected behavior of the semaphore's value.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern int mxs_dma_read_semaphore(int channel);
+
+/**
+ * mxs_dma_irq_is_pending - Check if a DMA interrupt is pending.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern int mxs_dma_irq_is_pending(int channel);
+
+/**
+ * mxs_dma_enable_irq - Enable or disable DMA interrupt.
+ *
+ * This function enables the given DMA channel to interrupt the CPU.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @en:       True if the interrupt for this channel should be enabled. False
+ *            otherwise.
+ */
+extern void mxs_dma_enable_irq(int channel, int en);
+
+/**
+ * mxs_dma_ack_irq - Clear DMA interrupt.
+ *
+ * The software that is using the DMA channel must register to receive its
+ * interrupts and, when they arrive, must call this function to clear them.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ */
+extern void mxs_dma_ack_irq(int channel);
+
+/**
+ * mxs_dma_set_target - Set the target for a DMA channel.
+ *
+ * This function is NOT used on the i.MX28.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @target:   Indicates the target for the channel.
+ */
+extern void mxs_dma_set_target(int channel, int target);
+
+/* mxs dma utility functions */
+extern struct mxs_dma_desc *mxs_dma_alloc_desc(void);
+extern void mxs_dma_free_desc(struct mxs_dma_desc *);
+
+/**
+ * mxs_dma_cmd_address - Return the address of the command within a descriptor.
+ *
+ * @desc:  The DMA descriptor of interest.
+ */
+static inline unsigned int mxs_dma_cmd_address(struct mxs_dma_desc *desc)
+{
+	return desc->address += offsetof(struct mxs_dma_desc, cmd);
+}
+
+/**
+ * mxs_dma_desc_pending - Check if descriptor is on a channel's active list.
+ *
+ * This function returns the state of a descriptor's "ready" flag. This flag is
+ * usually set only if the descriptor appears on a channel's active list. The
+ * descriptor may or may not have already been processed by the hardware.
+ *
+ * The "ready" flag is set when the descriptor is submitted to a channel by a
+ * call to mxs_dma_append() or mxs_dma_append_list(). The "ready" flag is
+ * cleared when a processed descriptor is moved off the active list by a call
+ * to mxs_dma_cooked(). The "ready" flag is NOT cleared if the descriptor is
+ * aborted by a call to mxs_dma_disable().
+ *
+ * @desc:  The DMA descriptor of interest.
+ */
+static inline int mxs_dma_desc_pending(struct mxs_dma_desc *pdesc)
+{
+	return pdesc->flags & MXS_DMA_DESC_READY;
+}
+
+/**
+ * mxs_dma_desc_append - Add a DMA descriptor to a channel.
+ *
+ * If the descriptor list for this channel is not empty, this function sets the
+ * CHAIN bit and the NEXTCMD_ADDR fields in the last descriptor's DMA command so
+ * it will chain to the new descriptor's command.
+ *
+ * Then, this function marks the new descriptor as "ready," adds it to the end
+ * of the active descriptor list, and increments the count of pending
+ * descriptors.
+ *
+ * The MXS platform DMA software imposes some rules on DMA commands to maintain
+ * important invariants. These rules are NOT checked, but they must be carefully
+ * applied by software that uses MXS DMA channels.
+ *
+ * Invariant:
+ *     The DMA channel's hardware semaphore must reflect the number of DMA
+ *     commands the hardware will process, but has not yet finished.
+ *
+ * Explanation:
+ *     A DMA channel begins processing commands when its hardware semaphore is
+ *     written with a value greater than zero, and it stops processing commands
+ *     when the semaphore returns to zero.
+ *
+ *     When a channel finishes a DMA command, it will decrement its semaphore if
+ *     the DECREMENT_SEMAPHORE bit is set in that command's flags bits.
+ *
+ *     In principle, it's not necessary for the DECREMENT_SEMAPHORE to be set,
+ *     unless it suits the purposes of the software. For example, one could
+ *     construct a series of five DMA commands, with the DECREMENT_SEMAPHORE
+ *     bit set only in the last one. Then, setting the DMA channel's hardware
+ *     semaphore to one would cause the entire series of five commands to be
+ *     processed. However, this example would violate the invariant given above.
+ *
+ * Rule:
+ *    ALL DMA commands MUST have the DECREMENT_SEMAPHORE bit set so that the DMA
+ *    channel's hardware semaphore will be decremented EVERY time a command is
+ *    processed.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @pdesc:    A pointer to the new descriptor.
+ */
+extern int mxs_dma_desc_append(int channel, struct mxs_dma_desc *pdesc);
+
+/**
+ * mxs_dma_desc_add_list - Add a list of DMA descriptors to a channel.
+ *
+ * This function marks all the new descriptors as "ready," adds them to the end
+ * of the active descriptor list, and adds the length of the list to the count
+ * of pending descriptors.
+ *
+ * See mxs_dma_desc_append() for important rules that apply to incoming DMA
+ * descriptors.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @head:     A pointer to the head of the list of DMA descriptors to add.
+ */
+extern int mxs_dma_desc_add_list(int channel, struct list_head *head);
+
+/**
+ * mxs_dma_desc_get_cooked - Retrieve processed DMA descriptors.
+ *
+ * This function moves all the descriptors from the DMA channel's "done" list to
+ * the head of the given list.
+ *
+ * @channel:  The channel number. This is one of the globally unique DMA channel
+ *            numbers given in mach/dma.h.
+ * @head:     A pointer to the head of the list that will receive the
+ *            descriptors on the "done" list.
+ */
+extern int mxs_dma_get_cooked(int channel, struct list_head *head);
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/entry-macro.S b/arch/arm/plat-mxs/include/mach/entry-macro.S
new file mode 100644
index 0000000..353a7b2
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/entry-macro.S
@@ -0,0 +1,36 @@
+/*
+ * Low-level IRQ helper macros for Freescale MXS-based
+ *
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr \base, =g_icoll_base
+	ldr \base, [\base]
+	ldr \irqnr, [\base, #0x70]
+	cmp \irqnr, #0x7F
+	moveqs \irqnr, #0
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
diff --git a/arch/arm/plat-mxs/include/mach/fsl_usb.h b/arch/arm/plat-mxs/include/mach/fsl_usb.h
new file mode 100644
index 0000000..f883248
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/fsl_usb.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_MEMORY)
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + UOG_USBMODE);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + UOG_USBMODE);
+}
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, on);
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+}
+
+void fsl_phy_usb_utmi_init(struct fsl_xcvr_ops *this);
+void fsl_phy_usb_utmi_uninit(struct fsl_xcvr_ops *this);
+void fsl_phy_set_power(struct fsl_xcvr_ops *this,
+			struct fsl_usb2_platform_data *pdata, int on);
+
diff --git a/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h b/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h
new file mode 100644
index 0000000..767b344
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/arch/arm/plat-mxs/include/mach/gpio.h b/arch/arm/plat-mxs/include/mach/gpio.h
new file mode 100644
index 0000000..7b63414
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/gpio.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H__
+#define __ASM_ARCH_GPIO_H__
+
+#include <mach/hardware.h>
+#include <asm-generic/gpio.h>
+
+#define	GPIO_ID_NAME		"gpio"
+/* use gpiolib dispatchers */
+#define gpio_get_value          __gpio_get_value
+#define gpio_set_value          __gpio_set_value
+#define gpio_cansleep           __gpio_cansleep
+#define gpio_to_irq		__gpio_to_irq
+#define irq_to_gpio(irq)	((irq) - MXS_GPIO_IRQ_START)
+
+struct mxs_gpio_port;
+struct mxs_gpio_chip {
+	int (*set_dir) (struct mxs_gpio_port *, int, unsigned int);
+	int (*get) (struct mxs_gpio_port *, int);
+	void (*set) (struct mxs_gpio_port *, int, int);
+	unsigned int (*get_irq_stat) (struct mxs_gpio_port *);
+	int (*set_irq_type) (struct mxs_gpio_port *, int, unsigned int);
+	void (*unmask_irq) (struct mxs_gpio_port *, int);
+	void (*mask_irq) (struct mxs_gpio_port *, int);
+	void (*ack_irq) (struct mxs_gpio_port *, int);
+};
+
+struct mxs_gpio_port {
+	int id;
+	int irq;
+	int child_irq;
+	struct mxs_gpio_chip *chip;
+	struct gpio_chip port;
+};
+
+extern int mxs_add_gpio_port(struct mxs_gpio_port *port);
+
+static inline void
+mxs_set_gpio_chip(struct mxs_gpio_port *port, struct mxs_gpio_chip *chip)
+{
+	if (port && chip)
+		port->chip = chip;
+}
+
+#endif /* __ASM_ARCH_GPIO_H__ */
diff --git a/arch/arm/plat-mxs/include/mach/hardware.h b/arch/arm/plat-mxs/include/mach/hardware.h
new file mode 100644
index 0000000..c7dd8fe
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/hardware.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_HARDWARE_H
+#define __ASM_ARM_ARCH_HARDWARE_H
+
+#ifdef CONFIG_ARCH_MX28
+# include <mach/mx28.h>
+# define cpu_is_mx28() 1
+# else
+# define cpu_is_mx28() 0
+#endif
+
+#ifdef CONFIG_ARCH_MX23
+# include <mach/mx23.h>
+# define cpu_is_mx23() 1
+# else
+# define cpu_is_mx23() 0
+#endif
+
+#ifndef MXS_EXTEND_IRQS
+#define MXS_EXTEND_IRQS	0
+#endif
+
+#ifndef MXS_ARCH_NR_GPIOS
+#define MXS_ARCH_NR_GPIOS	160
+#endif
+
+#ifndef MXS_EXTEND_NR_GPIOS
+#define MXS_EXTEND_NR_GPIOS	0
+#endif
+
+#define ARCH_NR_GPIOS	(MXS_ARCH_NR_GPIOS + MXS_EXTEND_NR_GPIOS)
+
+#define MXS_GPIO_IRQ_START	ARCH_NR_IRQS
+#define MXS_EXTEND_IRQ_START	(ARCH_NR_IRQS + ARCH_NR_GPIOS)
+
+#endif /* __ASM_ARM_ARCH_HARDWARE_H */
diff --git a/arch/arm/plat-mxs/include/mach/io.h b/arch/arm/plat-mxs/include/mach/io.h
new file mode 100644
index 0000000..7dff55e
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/io.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a) 	__typesafe_io(a)
+#define __mem_pci(a)	(a)
+#define __mem_isa(a)	(a)
+
+#define SET_REGISTER	0x4
+#define CLR_REGISTER	0x8
+#define TOG_REGISTER	0xC
+
+struct mxs_io_bank {
+	unsigned int raw;
+	unsigned int set;
+	unsigned int clr;
+	unsigned int tog;
+};
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/irqs.h b/arch/arm/plat-mxs/include/mach/irqs.h
new file mode 100644
index 0000000..62165e1
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/irqs.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H__
+#define __ASM_ARCH_IRQS_H__
+
+#include <mach/hardware.h>
+
+#define NR_IRQS	(ARCH_NR_IRQS + ARCH_NR_GPIOS + MXS_EXTEND_IRQS)
+
+#ifndef __ASSEMBLY__
+struct irq_ic_info {
+	unsigned int id_val;
+	unsigned int id_mask;
+	const char *name;
+	unsigned int base;
+};
+
+#define __irq_ic_info_attr __attribute__((__section__(".irq_ic_info.array")))
+
+extern struct irq_ic_info *current_irq_ic_info;
+
+void mxs_set_irq_fiq(unsigned int irq, unsigned int type);
+void mxs_enable_fiq_functionality(int enable);
+
+#endif
+
+#endif /* __ASM_ARCH_SYSTEM_H__ */
diff --git a/arch/arm/plat-mxs/include/mach/lradc.h b/arch/arm/plat-mxs/include/mach/lradc.h
new file mode 100644
index 0000000..c2c0a7d
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/lradc.h
@@ -0,0 +1,61 @@
+/*
+ * Freescale STMP37XX/STMP378X LRADC helper interface
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_PLAT_LRADC_H
+#define __ASM_PLAT_LRADC_H
+
+int hw_lradc_use_channel(int);
+int hw_lradc_unuse_channel(int);
+extern u32 hw_lradc_vddio(void);
+void hw_lradc_set_delay_trigger_kick(int trigger, int value);
+void hw_lradc_configure_channel(int channel, int enable_div2,
+		int enable_acc, int samples);
+int hw_lradc_present(int channel);
+int hw_lradc_init_ladder(int channel, int trigger, unsigned sampling);
+int hw_lradc_stop_ladder(int channel, int trigger);
+void hw_lradc_set_delay_trigger(int trigger, u32 trigger_lradc,
+		u32 delay_triggers, u32 loops, u32 delays);
+void hw_lradc_clear_delay_trigger(int trigger, u32 trigger_lradc,
+		u32 delay_triggers);
+
+
+#define LRADC_CH0		0
+#define LRADC_CH1		1
+#define LRADC_CH2		2
+#define LRADC_CH3		3
+#define LRADC_CH4		4
+#define LRADC_CH5		5
+#define LRADC_CH6		6
+#define LRADC_CH7		7
+#define LRADC_TOUCH_X_PLUS	LRADC_CH2
+#define LRADC_TOUCH_Y_PLUS	LRADC_CH3
+#define LRADC_TOUCH_X_MINUS	LRADC_CH4
+#define LRADC_TOUCH_Y_MINUS	LRADC_CH5
+#define VDDIO_VOLTAGE_CH	LRADC_CH6
+#define BATTERY_VOLTAGE_CH	LRADC_CH7
+
+#define LRADC_CLOCK_6MHZ	0
+#define LRADC_CLOCK_4MHZ	1
+#define LRADC_CLOCK_3MHZ	2
+#define LRADC_CLOCK_2MHZ	3
+
+#define LRADC_DELAY_TRIGGER_BUTTON	0
+#define LRADC_DELAY_TRIGGER_BATTERY	1
+#define LRADC_DELAY_TRIGGER_TOUCHSCREEN	2
+#define LRADC_DELAY_TRIGGER_DIE		3
+
+#endif /* __ASM_PLAT_LRADC_H */
diff --git a/arch/arm/plat-mxs/include/mach/memory.h b/arch/arm/plat-mxs/include/mach/memory.h
new file mode 100644
index 0000000..79c86db
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/memory.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+/*
+ * Physical DRAM offset.
+ */
+#define PHYS_OFFSET	UL(0x40000000)
+
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_DMA_ZONE_SIZE
+#define MXS_DMA_ZONE_SIZE	((CONFIG_DMA_ZONE_SIZE * SZ_1M) >> PAGE_SHIFT)
+#else
+#define MXS_DMA_ZONE_SIZE	((12 * SZ_1M) >> PAGE_SHIFT)
+#endif
+
+static inline void __arch_adjust_zones(int node, unsigned long *zone_size,
+				       unsigned long *zhole_size)
+{
+	if (node != 0)
+		return;
+	/* Create separate zone to reserve memory for DMA */
+	zone_size[1] = zone_size[0] - MXS_DMA_ZONE_SIZE;
+	zone_size[0] = MXS_DMA_ZONE_SIZE;
+	zhole_size[1] = zhole_size[0];
+	zhole_size[0] = 0;
+}
+
+#define arch_adjust_zones(node, size, holes) \
+	__arch_adjust_zones(node, size, holes)
+
+#endif
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *		address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *		to an address that the kernel can use.
+ */
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+#define ISA_DMA_THRESHOLD	(0x0003ffffULL)
+
+#define CONSISTENT_DMA_SIZE	SZ_32M
+
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/pinctrl.h b/arch/arm/plat-mxs/include/mach/pinctrl.h
new file mode 100644
index 0000000..6e02149
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/pinctrl.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARM_ARCH_PINCTRL_H
+#define __ASM_ARM_ARCH_PINCTRL_H
+
+#include <linux/types.h>
+#include <linux/gpio.h>
+
+#define PINS_PER_BANK		32
+#define GPIO_TO_PINS(gpio)	((gpio) % 32)
+#define GPIO_TO_BANK(gpio)	((gpio) / 32)
+
+#define MXS_PIN_TO_GPIO(p)	(((p) & MXS_PIN_PINID_MAX) |\
+				 ((((p) >> MXS_PIN_BANK_BIT) &\
+				 MXS_PIN_BANK_MAX) * PINS_PER_BANK))
+
+#define MXS_PIN_BANK_BIT	24
+#define MXS_PIN_BANK_MAX	(0x7FFFFFFF >> (MXS_PIN_BANK_BIT - 1))
+#define MXS_PIN_PINID_MAX	((1 << MXS_PIN_BANK_BIT) - 1)
+#define MXS_PIN_TO_BANK(p)	(((p) >> MXS_PIN_BANK_BIT) & MXS_PIN_BANK_MAX)
+#define MXS_PIN_TO_PINID(p)	((p) & MXS_PIN_PINID_MAX)
+
+#define MXS_PIN_ENCODE(b, p)	\
+		((((b) & MXS_PIN_BANK_MAX) << MXS_PIN_BANK_BIT) |\
+		 ((p) & MXS_PIN_PINID_MAX))
+
+#define MXS_GPIO_MASK		0x7FFFFFFF
+#define MXS_NON_GPIO		0x80000000
+/*
+ * Each pin may be routed up to four different HW interfaces
+ * including GPIO
+ */
+enum pin_fun {
+	PIN_FUN1 = 0,
+	PIN_FUN2,
+	PIN_FUN3,
+	PIN_GPIO,
+};
+
+/*
+ * Each pin may have different output drive strength in range from
+ * 4mA to 20mA. The most common case is 4, 8 and 12 mA strengths.
+ */
+enum pad_strength {
+	PAD_4MA = 0,
+	PAD_8MA,
+	PAD_12MA,
+	PAD_RESV,
+	PAD_CLEAR = PAD_RESV,
+};
+
+/*
+ * Each pin can be programmed for 1.8V or 3.3V
+ */
+enum pad_voltage {
+	PAD_1_8V = 0,
+	PAD_3_3V,
+};
+
+/**
+ * struct pin_desc - Describes the configuration of a pin.
+ *
+ * @name:      A human-readable name that identifies the pin.
+ * @id:        A number that identifies the pin (use a macro from a chip-
+ *             specific header file -- e.g., "PINID_PWM0").
+ * @fun:       The function for which to configure this pin.
+ * @strength:  The drive strength for this pin. Note that this field should be
+ *             ignored and the driver hardware should *not* be configured if the
+ *             "drive" field is not set.
+ * @voltage:   The voltage rail for this pin. Note that this field should be
+ *             ignored and the driver hardware should *not* be configured if the
+ *             "drive" field is not set.
+ * @pullup:    If set, indicates whether the pullup is enabled. Note that this
+ *             field should be ignored and the pullup should *not* be configured
+ *             if the "pull" field is not set.
+ * @drive:     If set, indicates that the driver hardware for this pin should be
+ *             configured. This field does *not* indicate *how* the driver
+ *             hardware should be configured -- only whether or not it should
+ *             be. See the "strength" and "voltage" fields for information about
+ *             how to configure the driver hardware.
+ * @pull:      If set, indicates that the pullup for this pin should be
+ *             configured. This field does *not* indicate *how* the pullup
+ *             should be configured -- only whether or not it should be. See the
+ *             "pullup" field for information about how to configure the pullup.
+ * @input:     For GPIO pins only, this indicates whether the pin is an input.
+ * @data:      The data field is used when the pin is configured to GPIO output
+ *             mode. When data is 0, the pin's output will be 0.
+ */
+struct pin_desc {
+	char *name;
+	unsigned int id;
+	enum pin_fun fun;
+	enum pad_strength strength;
+	enum pad_voltage voltage;
+	unsigned pullup:1;
+	unsigned drive:1;
+	unsigned pull:1;
+	unsigned output:1;
+	unsigned data:1;
+};
+
+struct pin_bank {
+	const char *label[sizeof(long) * 8];
+	unsigned long id;
+	struct pinctrl_chip *chip;
+	unsigned long bitmap;
+	unsigned long gpio_port;
+};
+
+struct pinctrl_chip {
+	char *name;
+	unsigned int nouse;
+	unsigned int bank_size;
+	struct pin_bank *banks;
+	/* OPS */
+	int (*pin2id) (struct pinctrl_chip *, unsigned int, unsigned int *);
+	unsigned int (*get_gpio) (struct pin_bank *, unsigned int);
+	void (*set_strength) (struct pin_bank *, unsigned int,
+			      enum pad_strength);
+	void (*set_voltage) (struct pin_bank *, unsigned int, enum pad_voltage);
+	void (*set_pullup) (struct pin_bank *, unsigned int, int);
+	void (*set_type) (struct pin_bank *, unsigned int, enum pin_fun);
+	int (*get_type) (struct pin_bank *, unsigned int);
+};
+
+extern int __init mxs_set_pinctrl_chip(struct pinctrl_chip *);
+
+extern unsigned int mxs_pin2gpio(unsigned int);
+extern int mxs_request_pin(unsigned int, enum pin_fun, const char *);
+extern int mxs_set_type(unsigned int, enum pin_fun, const char *);
+extern int mxs_get_type(unsigned int);
+extern int mxs_set_strength(unsigned int, enum pad_strength, const char *);
+extern int mxs_set_voltage(unsigned int, enum pad_voltage, const char *);
+extern int mxs_set_pullup(unsigned int, int, const char *);
+extern void mxs_release_pin(unsigned int, const char *);
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/power.h b/arch/arm/plat-mxs/include/mach/power.h
new file mode 100644
index 0000000..28ee9fa
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/power.h
@@ -0,0 +1,64 @@
+/*
+ * Freescale MXS voltage regulator structure declarations
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __VOLTAGE_H
+#define __VOLTAGE_H
+#include <linux/completion.h>
+#include <linux/regulator/driver.h>
+
+struct mxs_regulator {
+	struct regulator_desc regulator;
+	struct mxs_regulator *parent;
+	struct mxs_platform_regulator_data *rdata;
+	struct completion done;
+
+	spinlock_t         lock;
+	wait_queue_head_t  wait_q;
+	struct notifier_block nb;
+
+	int mode;
+	int cur_voltage;
+	int cur_current;
+	int next_current;
+};
+
+
+struct mxs_platform_regulator_data {
+	char name[80];
+	char *parent_name;
+	int (*reg_register)(struct mxs_regulator *sreg);
+	int (*set_voltage)(struct mxs_regulator *sreg, int uv);
+	int (*get_voltage)(struct mxs_regulator *sreg);
+	int (*set_current)(struct mxs_regulator *sreg, int uA);
+	int (*get_current)(struct mxs_regulator *sreg);
+	int (*enable)(struct mxs_regulator *sreg);
+	int (*disable)(struct mxs_regulator *sreg);
+	int (*is_enabled)(struct mxs_regulator *sreg);
+	int (*set_mode)(struct mxs_regulator *sreg, int mode);
+	int (*get_mode)(struct mxs_regulator *sreg);
+	int (*get_optimum_mode)(struct mxs_regulator *sreg,
+			int input_uV, int output_uV, int load_uA);
+	u32 control_reg;
+	int min_voltage;
+	int max_voltage;
+	int max_current;
+	struct regulation_constraints *cnstraints;
+};
+
+int mxs_register_regulator(
+		struct mxs_regulator *reg_data, int reg,
+		      struct regulator_init_data *initdata);
+
+#endif /* __VOLTAGE_H */
diff --git a/arch/arm/plat-mxs/include/mach/system.h b/arch/arm/plat-mxs/include/mach/system.h
new file mode 100644
index 0000000..faaa2ff
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/system.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_SYSTEM_H__
+#define __ASM_ARCH_SYSTEM_H__
+
+extern void arch_idle(void);
+
+void arch_reset(char mode, const char *cmd);
+extern void (*machine_arch_reset)(char mode, const char *cmd);
+int mxs_reset_block(void __iomem *hwreg, int just_enable);
+int get_evk_board_version(void);
+
+#endif /* __ASM_ARCH_SYSTEM_H__ */
diff --git a/arch/arm/plat-mxs/include/mach/timex.h b/arch/arm/plat-mxs/include/mach/timex.h
new file mode 100644
index 0000000..9db3d68
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/timex.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * System time clock is sourced from the 32k clock
+ */
+#define CLOCK_TICK_RATE		32768
diff --git a/arch/arm/plat-mxs/include/mach/uncompress.h b/arch/arm/plat-mxs/include/mach/uncompress.h
new file mode 100644
index 0000000..fd4e4f8
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/uncompress.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_PLAT_UNCOMPRESS_H
+#define __ASM_PLAT_UNCOMPRESS_H
+
+#include <mach/hardware.h>
+
+/*
+ * Register includes are for when the MMU enabled; we need to define our
+ * own stuff here for pre-MMU use
+ */
+#define UART_PORT_BASE		DUART_PHYS_ADDR
+#define UART(c)			(((volatile unsigned *)UART_PORT_BASE)[c])
+
+/*
+ * This does not append a newline
+ */
+static void putc(char c)
+{
+	/* Wait for TX fifo empty */
+	while ((UART(6) & (1 << 7)) == 0)
+		continue;
+
+	/* Write byte */
+	UART(0) = c;
+
+	/* Wait for last bit to exit the UART */
+	while (UART(6) & (1 << 3))
+		continue;
+}
+
+#define flush()	do { } while (0)
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif /* __ASM_PLAT_UNCOMPRESS_H */
diff --git a/arch/arm/plat-mxs/include/mach/unique-id.h b/arch/arm/plat-mxs/include/mach/unique-id.h
new file mode 100644
index 0000000..de5e043
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/unique-id.h
@@ -0,0 +1,30 @@
+/*
+ * Unique ID interface for ID storage providers
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __UNIQUE_ID_H
+#define __UNIQUE_ID_H
+
+struct uid_ops {
+	ssize_t (*id_show)(void *context, char *page, int ascii);
+	ssize_t (*id_store)(void *context, const char *page,
+			size_t count, int ascii);
+};
+
+struct kobject *uid_provider_init(const char *name,
+		struct uid_ops *ops, void *context);
+void uid_provider_remove(const char *name);
+#endif
diff --git a/arch/arm/plat-mxs/include/mach/vmalloc.h b/arch/arm/plat-mxs/include/mach/vmalloc.h
new file mode 100644
index 0000000..cc6d5cf
--- /dev/null
+++ b/arch/arm/plat-mxs/include/mach/vmalloc.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define VMALLOC_END       (0xF0000000)
diff --git a/arch/arm/plat-mxs/iram.c b/arch/arm/plat-mxs/iram.c
new file mode 100644
index 0000000..c63b0a2
--- /dev/null
+++ b/arch/arm/plat-mxs/iram.c
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/genalloc.h>
+
+static unsigned long iram_phys_base;
+static __iomem void *iram_virt_base;
+static struct gen_pool *iram_pool;
+
+#define iram_phys_to_virt(p) (iram_virt_base + ((p) - iram_phys_base))
+
+void *iram_alloc(unsigned int size, unsigned long *dma_addr)
+{
+	if (!iram_pool)
+		return NULL;
+
+	*dma_addr = gen_pool_alloc(iram_pool, size);
+	pr_debug("iram alloc - %dB@0x%p\n", size, (void *)*dma_addr);
+
+	WARN_ON(!*dma_addr);
+	if (!*dma_addr)
+		return NULL;
+
+	return iram_phys_to_virt(*dma_addr);
+}
+EXPORT_SYMBOL(iram_alloc);
+
+void iram_free(unsigned long addr, unsigned int size)
+{
+	if (!iram_pool)
+		return;
+
+	gen_pool_free(iram_pool, addr, size);
+}
+EXPORT_SYMBOL(iram_free);
+
+int __init iram_init(unsigned long base, unsigned long size)
+{
+	iram_phys_base = base;
+
+	iram_pool = gen_pool_create(12, -1);
+	gen_pool_add(iram_pool, base, size, -1);
+	iram_virt_base = ioremap(iram_phys_base, size);
+
+	pr_info("i.MX IRAM pool: %ld KB@0x%p\n", size / 1024, iram_virt_base);
+	return 0;
+}
diff --git a/arch/arm/plat-mxs/lradc.c b/arch/arm/plat-mxs/lradc.c
new file mode 100644
index 0000000..3d9089e
--- /dev/null
+++ b/arch/arm/plat-mxs/lradc.c
@@ -0,0 +1,385 @@
+/*
+ * Freescale STMP37XX/STMP378X LRADC helper routines
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/platform_device.h>
+#include <linux/bitops.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/regs-lradc.h>
+#include <mach/lradc.h>
+
+struct lradc_device {
+	struct sys_device sys;
+	unsigned int base;
+	unsigned int vddio_voltage;
+	unsigned int battery_voltage;
+};
+
+static int channels[8];
+
+static __refdata struct lradc_device mxs_lradc;
+
+int hw_lradc_use_channel(int channel)
+{
+	if (channel < 0 || channel > 7)
+		return -EINVAL;
+	channels[channel]++;
+	return 0;
+}
+EXPORT_SYMBOL(hw_lradc_use_channel);
+
+int hw_lradc_unuse_channel(int channel)
+{
+	if (channel < 0 || channel > 7)
+		return -EINVAL;
+	channels[channel]--;
+	return 0;
+}
+EXPORT_SYMBOL(hw_lradc_unuse_channel);
+
+void hw_lradc_reinit(int enable_ground_ref, unsigned freq)
+{
+	__raw_writel(BM_LRADC_CTRL0_SFTRST,
+		     mxs_lradc.base + HW_LRADC_CTRL0_SET);
+	udelay(1);
+	__raw_writel(BM_LRADC_CTRL0_SFTRST,
+		     mxs_lradc.base + HW_LRADC_CTRL0_CLR);
+
+	/* Clear the Clock Gate for normal operation */
+	__raw_writel(BM_LRADC_CTRL0_CLKGATE,
+		     mxs_lradc.base + HW_LRADC_CTRL0_CLR);
+
+	if (enable_ground_ref)
+		__raw_writel(BM_LRADC_CTRL0_ONCHIP_GROUNDREF,
+			     mxs_lradc.base + HW_LRADC_CTRL0_SET);
+	else
+		__raw_writel(BM_LRADC_CTRL0_ONCHIP_GROUNDREF,
+			    mxs_lradc.base + HW_LRADC_CTRL0_CLR);
+
+	__raw_writel(BM_LRADC_CTRL3_CYCLE_TIME,
+		     mxs_lradc.base + HW_LRADC_CTRL3_CLR);
+	__raw_writel(BF_LRADC_CTRL3_CYCLE_TIME(freq),
+		     mxs_lradc.base + HW_LRADC_CTRL3_SET);
+
+	__raw_writel(BM_LRADC_CTRL4_LRADC6SELECT | BM_LRADC_CTRL4_LRADC7SELECT,
+		     mxs_lradc.base + HW_LRADC_CTRL4_CLR);
+	__raw_writel(BF_LRADC_CTRL4_LRADC6SELECT(mxs_lradc.vddio_voltage),
+		     mxs_lradc.base + HW_LRADC_CTRL4_SET);
+	__raw_writel(BF_LRADC_CTRL4_LRADC7SELECT(mxs_lradc.battery_voltage),
+		     mxs_lradc.base + HW_LRADC_CTRL4_SET);
+}
+
+int hw_lradc_init_ladder(int channel, int trigger, unsigned sampling)
+{
+	/*
+	 * check if the lradc channel is present in this product
+	 */
+	if (!hw_lradc_present(channel))
+		return -ENODEV;
+
+	hw_lradc_configure_channel(channel, !0 /* div2 */ ,
+				   0 /* acc */ ,
+				   0 /* num_samples */);
+
+	/* Setup the trigger loop forever */
+	hw_lradc_set_delay_trigger(trigger, 1 << channel,
+				   1 << trigger, 0, sampling);
+
+	/* Clear the accumulator & NUM_SAMPLES */
+	__raw_writel(0xFFFFFFFF, mxs_lradc.base + HW_LRADC_CHn_CLR(channel));
+	return 0;
+}
+
+EXPORT_SYMBOL(hw_lradc_init_ladder);
+
+int hw_lradc_stop_ladder(int channel, int trigger)
+{
+	/*
+	 * check if the lradc channel is present in this product
+	 */
+	if (!hw_lradc_present(channel))
+		return -ENODEV;
+	hw_lradc_clear_delay_trigger(trigger, 1 << channel, 1 << trigger);
+	return 0;
+}
+
+EXPORT_SYMBOL(hw_lradc_stop_ladder);
+
+int hw_lradc_present(int channel)
+{
+	if (channel < 0 || channel > 7)
+		return 0;
+	return __raw_readl(mxs_lradc.base + HW_LRADC_STATUS)
+	    & (1 << (16 + channel));
+}
+
+EXPORT_SYMBOL(hw_lradc_present);
+
+void hw_lradc_configure_channel(int channel, int enable_div2,
+				int enable_acc, int samples)
+{
+	if (enable_div2)
+		__raw_writel(BF_LRADC_CTRL2_DIVIDE_BY_TWO(1 << channel),
+			     mxs_lradc.base + HW_LRADC_CTRL2_SET);
+	else
+		__raw_writel(BF_LRADC_CTRL2_DIVIDE_BY_TWO(1 << channel),
+			     mxs_lradc.base + HW_LRADC_CTRL2_CLR);
+
+	/* Clear the accumulator & NUM_SAMPLES */
+	__raw_writel(0xFFFFFFFF, mxs_lradc.base + HW_LRADC_CHn_CLR(channel));
+
+	/* Sets NUM_SAMPLES bitfield of HW_LRADC_CHn register. */
+	__raw_writel(BM_LRADC_CHn_NUM_SAMPLES,
+		     mxs_lradc.base + HW_LRADC_CHn_CLR(channel));
+	__raw_writel(BF_LRADC_CHn_NUM_SAMPLES(samples),
+		     mxs_lradc.base + HW_LRADC_CHn_SET(channel));
+
+	if (enable_acc)
+		__raw_writel(BM_LRADC_CHn_ACCUMULATE,
+			     mxs_lradc.base + HW_LRADC_CHn_SET(channel));
+	else
+		__raw_writel(BM_LRADC_CHn_ACCUMULATE,
+			     mxs_lradc.base + HW_LRADC_CHn_CLR(channel));
+}
+
+EXPORT_SYMBOL(hw_lradc_configure_channel);
+
+void hw_lradc_set_delay_trigger(int trigger, u32 trigger_lradc,
+				u32 delay_triggers, u32 loops, u32 delays)
+{
+	/* set TRIGGER_LRADCS in HW_LRADC_DELAYn */
+	__raw_writel(BF_LRADC_DELAYn_TRIGGER_LRADCS(trigger_lradc),
+		     mxs_lradc.base + HW_LRADC_DELAYn_SET(trigger));
+	__raw_writel(BF_LRADC_DELAYn_TRIGGER_DELAYS(delay_triggers),
+		     mxs_lradc.base + HW_LRADC_DELAYn_SET(trigger));
+
+	__raw_writel(BM_LRADC_DELAYn_LOOP_COUNT | BM_LRADC_DELAYn_DELAY,
+		     mxs_lradc.base + HW_LRADC_DELAYn_CLR(trigger));
+	__raw_writel(BF_LRADC_DELAYn_LOOP_COUNT(loops),
+		     mxs_lradc.base  + HW_LRADC_DELAYn_SET(trigger));
+	__raw_writel(BF_LRADC_DELAYn_DELAY(delays),
+		     mxs_lradc.base + HW_LRADC_DELAYn_SET(trigger));
+}
+
+EXPORT_SYMBOL(hw_lradc_set_delay_trigger);
+
+void hw_lradc_clear_delay_trigger(int trigger, u32 trigger_lradc,
+				  u32 delay_triggers)
+{
+	__raw_writel(BF_LRADC_DELAYn_TRIGGER_LRADCS(trigger_lradc),
+		     mxs_lradc.base + HW_LRADC_DELAYn_CLR(trigger));
+	__raw_writel(BF_LRADC_DELAYn_TRIGGER_DELAYS(delay_triggers),
+		     mxs_lradc.base + HW_LRADC_DELAYn_CLR(trigger));
+}
+
+EXPORT_SYMBOL(hw_lradc_clear_delay_trigger);
+
+void hw_lradc_set_delay_trigger_kick(int trigger, int value)
+{
+	if (value)
+		__raw_writel(BM_LRADC_DELAYn_KICK,
+			     mxs_lradc.base + HW_LRADC_DELAYn_SET(trigger));
+	else
+		__raw_writel(BM_LRADC_DELAYn_KICK,
+			     mxs_lradc.base + HW_LRADC_DELAYn_CLR(trigger));
+}
+
+EXPORT_SYMBOL(hw_lradc_set_delay_trigger_kick);
+
+u32 hw_lradc_vddio(void)
+{
+	/* Clear the Soft Reset and Clock Gate for normal operation */
+	__raw_writel(BM_LRADC_CTRL0_SFTRST | BM_LRADC_CTRL0_CLKGATE,
+		     mxs_lradc.base + HW_LRADC_CTRL0_CLR);
+
+	/*
+	 * Clear the divide by two for channel 6 since
+	 * it has a HW divide-by-two built in.
+	 */
+	__raw_writel(BF_LRADC_CTRL2_DIVIDE_BY_TWO(1 << VDDIO_VOLTAGE_CH),
+		     mxs_lradc.base + HW_LRADC_CTRL2_CLR);
+
+	/* Clear the accumulator & NUM_SAMPLES */
+	__raw_writel(0xFFFFFFFF,
+		     mxs_lradc.base + HW_LRADC_CHn_CLR(VDDIO_VOLTAGE_CH));
+
+	/* Clear the interrupt flag */
+	__raw_writel(BM_LRADC_CTRL1_LRADC6_IRQ,
+		     mxs_lradc.base + HW_LRADC_CTRL1_CLR);
+
+	/*
+	 * Get VddIO; this is the max scale value for the button resistor
+	 * ladder.
+	 * schedule ch 6:
+	 */
+	__raw_writel(BF_LRADC_CTRL0_SCHEDULE(1 << VDDIO_VOLTAGE_CH),
+		     mxs_lradc.base + HW_LRADC_CTRL0_SET);
+
+	/* wait for completion */
+	while ((__raw_readl(mxs_lradc.base + HW_LRADC_CTRL1)
+		& BM_LRADC_CTRL1_LRADC6_IRQ) != BM_LRADC_CTRL1_LRADC6_IRQ)
+		cpu_relax();
+
+	/* Clear the interrupt flag */
+	__raw_writel(BM_LRADC_CTRL1_LRADC6_IRQ,
+		     mxs_lradc.base + HW_LRADC_CTRL1_CLR);
+
+	/* read ch 6 value. */
+	return __raw_readl(mxs_lradc.base + HW_LRADC_CHn(VDDIO_VOLTAGE_CH)) &
+			   BM_LRADC_CHn_VALUE;
+}
+
+EXPORT_SYMBOL(hw_lradc_vddio);
+
+#ifdef CONFIG_PM
+static u32 lradc_registers[0x16];
+static int do_gate;
+
+static int hw_lradc_suspend(struct sys_device *dev, pm_message_t state)
+{
+	int i;
+
+	do_gate = 1;
+	for (i = 0; i < ARRAY_SIZE(channels); i++)
+		if (channels[i] > 0) {
+			do_gate = 0;
+			break;
+		}
+
+	for (i = 0; i < ARRAY_SIZE(lradc_registers); i++)
+		lradc_registers[i] = __raw_readl(mxs_lradc.base + (i << 4));
+
+	if (do_gate)
+		__raw_writel(BM_LRADC_CTRL0_CLKGATE,
+			     mxs_lradc.base + HW_LRADC_CTRL0_SET);
+	return 0;
+}
+
+static int hw_lradc_resume(struct sys_device *dev)
+{
+	int i;
+
+	if (do_gate) {
+		__raw_writel(BM_LRADC_CTRL0_SFTRST,
+			     mxs_lradc.base + HW_LRADC_CTRL0_SET);
+		udelay(10);
+		__raw_writel(BM_LRADC_CTRL0_SFTRST |
+			     BM_LRADC_CTRL0_CLKGATE,
+			     mxs_lradc.base + HW_LRADC_CTRL0_CLR);
+	}
+	for (i = 0; i < ARRAY_SIZE(lradc_registers); i++)
+		__raw_writel(lradc_registers[i], mxs_lradc.base + (i << 4));
+	return 0;
+}
+
+#endif
+
+static struct sysdev_class mxs_lradc_sysclass = {
+	.name = "mxs-lradc",
+#ifdef CONFIG_PM
+	.suspend = hw_lradc_suspend,
+	.resume = hw_lradc_resume,
+#endif
+};
+
+static int lradc_freq = LRADC_CLOCK_6MHZ;
+
+static int __init lradc_freq_setup(char *str)
+{
+	long freq;
+
+	if (strict_strtol(str, 0, &freq) < 0)
+		return 0;
+
+	if (freq < 0)
+		return 0;
+	if (freq >= 6)
+		lradc_freq = LRADC_CLOCK_6MHZ;
+	else if (freq >= 4)
+		lradc_freq = LRADC_CLOCK_4MHZ;
+	else if (freq >= 3)
+		lradc_freq = LRADC_CLOCK_3MHZ;
+	else if (freq >= 2)
+		lradc_freq = LRADC_CLOCK_2MHZ;
+	else
+		return 0;
+	return 1;
+}
+
+__setup("lradc_freq=", lradc_freq_setup);
+
+static int __devinit mxs_lradc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct mxs_lradc_plat_data *plat_data;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -ENODEV;
+
+	plat_data = (struct mxs_lradc_plat_data *)(pdev->dev.platform_data);
+	if (plat_data == NULL)
+		return -EFAULT;
+
+	mxs_lradc.base = (unsigned int)IO_ADDRESS(res->start);
+	mxs_lradc.sys.id = -1;
+	mxs_lradc.sys.cls = &mxs_lradc_sysclass;
+	mxs_lradc.vddio_voltage = plat_data->vddio_voltage;
+	mxs_lradc.battery_voltage = plat_data->battery_voltage;
+	hw_lradc_reinit(0, lradc_freq);
+	return sysdev_register(&mxs_lradc.sys);
+}
+
+static int __devexit mxs_lradc_remove(struct platform_device *pdev)
+{
+	sysdev_unregister(&mxs_lradc.sys);
+	return 0;
+}
+
+static __refdata struct platform_driver mxs_lradc_drv = {
+	.probe = mxs_lradc_probe,
+	.remove = __devexit_p(mxs_lradc_remove),
+	.driver = {
+		.name = "mxs-lradc",
+		.owner = THIS_MODULE,
+	}
+};
+
+static int __init hw_lradc_init(void)
+{
+	sysdev_class_register(&mxs_lradc_sysclass);
+	platform_driver_register(&mxs_lradc_drv);
+	return 0;
+}
+
+static void __exit hw_lradc_exit(void)
+{
+	platform_driver_unregister(&mxs_lradc_drv);
+	sysdev_class_unregister(&mxs_lradc_sysclass);
+}
+
+subsys_initcall(hw_lradc_init);
+module_exit(hw_lradc_exit);
diff --git a/arch/arm/plat-mxs/pinctrl.c b/arch/arm/plat-mxs/pinctrl.c
new file mode 100644
index 0000000..cdef3e0
--- /dev/null
+++ b/arch/arm/plat-mxs/pinctrl.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/bitops.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+
+#include <mach/pinctrl.h>
+
+static struct pinctrl_chip *g_chip;
+
+int mxs_request_pin(unsigned int pin, enum pin_fun fun, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+	if (test_and_set_bit(index, &pb->bitmap))
+		return -EBUSY;
+	pb->label[index] = lab;
+	if (g_chip->set_type)
+		g_chip->set_type(pb, index, fun);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_request_pin);
+
+int mxs_get_type(unsigned int pin)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	int ret = 0;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+	if (g_chip->get_type)
+		ret = g_chip->get_type(pb, index);
+	return ret;
+}
+EXPORT_SYMBOL(mxs_get_type);
+
+int mxs_set_type(unsigned int pin, enum pin_fun fun, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+
+	if (!test_bit(index, &pb->bitmap))
+		return -ENOLCK;
+	if (lab != pb->label[index])	/* label is const string */
+		return -EINVAL;
+	if (g_chip->set_type)
+		g_chip->set_type(pb, index, fun);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_set_type);
+
+int mxs_set_strength(unsigned int pin, enum pad_strength cfg, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+
+	if (!test_bit(index, &pb->bitmap))
+		return -ENOLCK;
+	if (lab != pb->label[index])	/* label is const string */
+		return -EINVAL;
+	if (g_chip->set_strength)
+		g_chip->set_strength(pb, index, cfg);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_set_strength);
+
+int mxs_set_voltage(unsigned int pin, enum pad_voltage cfg, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+
+	if (!test_bit(index, &pb->bitmap))
+		return -ENOLCK;
+	if (lab != pb->label[index])	/* label is const string */
+		return -EINVAL;
+	if (g_chip->set_voltage)
+		g_chip->set_voltage(pb, index, cfg);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_set_voltage);
+
+int mxs_set_pullup(unsigned int pin, int en, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+
+	if (!test_bit(index, &pb->bitmap))
+		return -ENOLCK;
+	if (lab != pb->label[index])	/* label is const string */
+		return -EINVAL;
+	if (g_chip->set_pullup)
+		g_chip->set_pullup(pb, index, en);
+	return 0;
+}
+EXPORT_SYMBOL(mxs_set_pullup);
+
+void mxs_release_pin(unsigned int pin, const char *lab)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return;
+
+	pb = g_chip->banks + bank;
+
+	if (!test_bit(index, &pb->bitmap))
+		return;
+	if (lab != pb->label[index])	/* label is const string */
+		return;
+	pb->label[index] = NULL;
+
+	clear_bit(index, &pb->bitmap);
+}
+EXPORT_SYMBOL(mxs_release_pin);
+
+unsigned int mxs_pin2gpio(unsigned int pin)
+{
+	int bank, index;
+	struct pin_bank *pb;
+	if (g_chip == NULL)
+		return -ENODEV;
+
+	if (!g_chip->get_gpio)
+		return -ENODEV;
+
+	bank = g_chip->pin2id(g_chip, pin, &index);
+	if (bank < 0 || index < 0 || bank >= g_chip->bank_size)
+		return -EFAULT;
+
+	pb = g_chip->banks + bank;
+
+	return g_chip->get_gpio(pb, index);
+}
+
+int __init mxs_set_pinctrl_chip(struct pinctrl_chip *chip)
+{
+	if (!(chip && chip->banks && chip->bank_size &&
+	      chip->get_gpio && chip->pin2id))
+		return -EINVAL;
+
+	if (g_chip)
+		return -EEXIST;
+	g_chip = chip;
+	return 0;
+};
diff --git a/arch/arm/plat-mxs/regs-apbx.h b/arch/arm/plat-mxs/regs-apbx.h
new file mode 100644
index 0000000..f788f13
--- /dev/null
+++ b/arch/arm/plat-mxs/regs-apbx.h
@@ -0,0 +1,433 @@
+/*
+ * Freescale APBX Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.30
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___APBX_H
+#define __ARCH_ARM___APBX_H
+
+#define HW_APBX_CTRL0	(0x00000000)
+#define HW_APBX_CTRL0_SET	(0x00000004)
+#define HW_APBX_CTRL0_CLR	(0x00000008)
+#define HW_APBX_CTRL0_TOG	(0x0000000c)
+
+#define BM_APBX_CTRL0_SFTRST	0x80000000
+#define BM_APBX_CTRL0_CLKGATE	0x40000000
+#define BP_APBX_CTRL0_RSVD0	0
+#define BM_APBX_CTRL0_RSVD0	0x3FFFFFFF
+#define BF_APBX_CTRL0_RSVD0(v)  \
+		(((v) << 0) & BM_APBX_CTRL0_RSVD0)
+
+#define HW_APBX_CTRL1	(0x00000010)
+#define HW_APBX_CTRL1_SET	(0x00000014)
+#define HW_APBX_CTRL1_CLR	(0x00000018)
+#define HW_APBX_CTRL1_TOG	(0x0000001c)
+
+#define BM_APBX_CTRL1_CH15_CMDCMPLT_IRQ_EN	0x80000000
+#define BM_APBX_CTRL1_CH14_CMDCMPLT_IRQ_EN	0x40000000
+#define BM_APBX_CTRL1_CH13_CMDCMPLT_IRQ_EN	0x20000000
+#define BM_APBX_CTRL1_CH12_CMDCMPLT_IRQ_EN	0x10000000
+#define BM_APBX_CTRL1_CH11_CMDCMPLT_IRQ_EN	0x08000000
+#define BM_APBX_CTRL1_CH10_CMDCMPLT_IRQ_EN	0x04000000
+#define BM_APBX_CTRL1_CH9_CMDCMPLT_IRQ_EN	0x02000000
+#define BM_APBX_CTRL1_CH8_CMDCMPLT_IRQ_EN	0x01000000
+#define BM_APBX_CTRL1_CH7_CMDCMPLT_IRQ_EN	0x00800000
+#define BM_APBX_CTRL1_CH6_CMDCMPLT_IRQ_EN	0x00400000
+#define BM_APBX_CTRL1_CH5_CMDCMPLT_IRQ_EN	0x00200000
+#define BM_APBX_CTRL1_CH4_CMDCMPLT_IRQ_EN	0x00100000
+#define BM_APBX_CTRL1_CH3_CMDCMPLT_IRQ_EN	0x00080000
+#define BM_APBX_CTRL1_CH2_CMDCMPLT_IRQ_EN	0x00040000
+#define BM_APBX_CTRL1_CH1_CMDCMPLT_IRQ_EN	0x00020000
+#define BM_APBX_CTRL1_CH0_CMDCMPLT_IRQ_EN	0x00010000
+#define BM_APBX_CTRL1_CH15_CMDCMPLT_IRQ	0x00008000
+#define BM_APBX_CTRL1_CH14_CMDCMPLT_IRQ	0x00004000
+#define BM_APBX_CTRL1_CH13_CMDCMPLT_IRQ	0x00002000
+#define BM_APBX_CTRL1_CH12_CMDCMPLT_IRQ	0x00001000
+#define BM_APBX_CTRL1_CH11_CMDCMPLT_IRQ	0x00000800
+#define BM_APBX_CTRL1_CH10_CMDCMPLT_IRQ	0x00000400
+#define BM_APBX_CTRL1_CH9_CMDCMPLT_IRQ	0x00000200
+#define BM_APBX_CTRL1_CH8_CMDCMPLT_IRQ	0x00000100
+#define BM_APBX_CTRL1_CH7_CMDCMPLT_IRQ	0x00000080
+#define BM_APBX_CTRL1_CH6_CMDCMPLT_IRQ	0x00000040
+#define BM_APBX_CTRL1_CH5_CMDCMPLT_IRQ	0x00000020
+#define BM_APBX_CTRL1_CH4_CMDCMPLT_IRQ	0x00000010
+#define BM_APBX_CTRL1_CH3_CMDCMPLT_IRQ	0x00000008
+#define BM_APBX_CTRL1_CH2_CMDCMPLT_IRQ	0x00000004
+#define BM_APBX_CTRL1_CH1_CMDCMPLT_IRQ	0x00000002
+#define BM_APBX_CTRL1_CH0_CMDCMPLT_IRQ	0x00000001
+
+#define HW_APBX_CTRL2	(0x00000020)
+#define HW_APBX_CTRL2_SET	(0x00000024)
+#define HW_APBX_CTRL2_CLR	(0x00000028)
+#define HW_APBX_CTRL2_TOG	(0x0000002c)
+
+#define BM_APBX_CTRL2_CH15_ERROR_STATUS	0x80000000
+#define BV_APBX_CTRL2_CH15_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH15_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH14_ERROR_STATUS	0x40000000
+#define BV_APBX_CTRL2_CH14_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH14_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH13_ERROR_STATUS	0x20000000
+#define BV_APBX_CTRL2_CH13_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH13_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH12_ERROR_STATUS	0x10000000
+#define BV_APBX_CTRL2_CH12_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH12_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH11_ERROR_STATUS	0x08000000
+#define BV_APBX_CTRL2_CH11_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH11_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH10_ERROR_STATUS	0x04000000
+#define BV_APBX_CTRL2_CH10_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH10_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH9_ERROR_STATUS	0x02000000
+#define BV_APBX_CTRL2_CH9_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH9_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH8_ERROR_STATUS	0x01000000
+#define BV_APBX_CTRL2_CH8_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH8_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH7_ERROR_STATUS	0x00800000
+#define BV_APBX_CTRL2_CH7_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH7_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH6_ERROR_STATUS	0x00400000
+#define BV_APBX_CTRL2_CH6_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH6_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH5_ERROR_STATUS	0x00200000
+#define BV_APBX_CTRL2_CH5_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH5_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH4_ERROR_STATUS	0x00100000
+#define BV_APBX_CTRL2_CH4_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH4_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH3_ERROR_STATUS	0x00080000
+#define BV_APBX_CTRL2_CH3_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH3_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH2_ERROR_STATUS	0x00040000
+#define BV_APBX_CTRL2_CH2_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH2_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH1_ERROR_STATUS	0x00020000
+#define BV_APBX_CTRL2_CH1_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH1_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH0_ERROR_STATUS	0x00010000
+#define BV_APBX_CTRL2_CH0_ERROR_STATUS__TERMINATION 0x0
+#define BV_APBX_CTRL2_CH0_ERROR_STATUS__BUS_ERROR   0x1
+#define BM_APBX_CTRL2_CH15_ERROR_IRQ	0x00008000
+#define BM_APBX_CTRL2_CH14_ERROR_IRQ	0x00004000
+#define BM_APBX_CTRL2_CH13_ERROR_IRQ	0x00002000
+#define BM_APBX_CTRL2_CH12_ERROR_IRQ	0x00001000
+#define BM_APBX_CTRL2_CH11_ERROR_IRQ	0x00000800
+#define BM_APBX_CTRL2_CH10_ERROR_IRQ	0x00000400
+#define BM_APBX_CTRL2_CH9_ERROR_IRQ	0x00000200
+#define BM_APBX_CTRL2_CH8_ERROR_IRQ	0x00000100
+#define BM_APBX_CTRL2_CH7_ERROR_IRQ	0x00000080
+#define BM_APBX_CTRL2_CH6_ERROR_IRQ	0x00000040
+#define BM_APBX_CTRL2_CH5_ERROR_IRQ	0x00000020
+#define BM_APBX_CTRL2_CH4_ERROR_IRQ	0x00000010
+#define BM_APBX_CTRL2_CH3_ERROR_IRQ	0x00000008
+#define BM_APBX_CTRL2_CH2_ERROR_IRQ	0x00000004
+#define BM_APBX_CTRL2_CH1_ERROR_IRQ	0x00000002
+#define BM_APBX_CTRL2_CH0_ERROR_IRQ	0x00000001
+
+#define HW_APBX_CHANNEL_CTRL	(0x00000030)
+#define HW_APBX_CHANNEL_CTRL_SET	(0x00000034)
+#define HW_APBX_CHANNEL_CTRL_CLR	(0x00000038)
+#define HW_APBX_CHANNEL_CTRL_TOG	(0x0000003c)
+
+#define BP_APBX_CHANNEL_CTRL_RESET_CHANNEL	16
+#define BM_APBX_CHANNEL_CTRL_RESET_CHANNEL	0xFFFF0000
+#define BF_APBX_CHANNEL_CTRL_RESET_CHANNEL(v) \
+		(((v) << 16) & BM_APBX_CHANNEL_CTRL_RESET_CHANNEL)
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART4_RX 0x0001
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART4_TX 0x0002
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__SPDIF_TX 0x0004
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__SAIF0    0x0010
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__SAIF1    0x0020
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__I2C0     0x0040
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__I2C1     0x0080
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART0_RX 0x0100
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART0_TX 0x0200
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART1_RX 0x0400
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART1_TX 0x0800
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART2_RX 0x1000
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART2_TX 0x2000
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART3_RX 0x4000
+#define BV_APBX_CHANNEL_CTRL_RESET_CHANNEL__UART3_TX 0x8000
+#define BP_APBX_CHANNEL_CTRL_FREEZE_CHANNEL	0
+#define BM_APBX_CHANNEL_CTRL_FREEZE_CHANNEL	0x0000FFFF
+#define BF_APBX_CHANNEL_CTRL_FREEZE_CHANNEL(v)  \
+		(((v) << 0) & BM_APBX_CHANNEL_CTRL_FREEZE_CHANNEL)
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART4_RX 0x0001
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART4_TX 0x0002
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__SPDIF_TX 0x0004
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__SAIF0    0x0010
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__SAIF1    0x0020
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__I2C0     0x0040
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__I2C1     0x0080
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART0_RX 0x0100
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART0_TX 0x0200
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART1_RX 0x0400
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART1_TX 0x0800
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART2_RX 0x1000
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART2_TX 0x2000
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART3_RX 0x4000
+#define BV_APBX_CHANNEL_CTRL_FREEZE_CHANNEL__UART3_TX 0x8000
+
+#define HW_APBX_DEVSEL	(0x00000040)
+#define HW_APBX_DEVSEL_SET	(0x00000044)
+#define HW_APBX_DEVSEL_CLR	(0x00000048)
+#define HW_APBX_DEVSEL_TOG	(0x0000004c)
+
+#define BP_APBX_DEVSEL_CH15	30
+#define BM_APBX_DEVSEL_CH15	0xC0000000
+#define BF_APBX_DEVSEL_CH15(v) \
+		(((v) << 30) & BM_APBX_DEVSEL_CH15)
+#define BP_APBX_DEVSEL_CH14	28
+#define BM_APBX_DEVSEL_CH14	0x30000000
+#define BF_APBX_DEVSEL_CH14(v)  \
+		(((v) << 28) & BM_APBX_DEVSEL_CH14)
+#define BP_APBX_DEVSEL_CH13	26
+#define BM_APBX_DEVSEL_CH13	0x0C000000
+#define BF_APBX_DEVSEL_CH13(v)  \
+		(((v) << 26) & BM_APBX_DEVSEL_CH13)
+#define BP_APBX_DEVSEL_CH12	24
+#define BM_APBX_DEVSEL_CH12	0x03000000
+#define BF_APBX_DEVSEL_CH12(v)  \
+		(((v) << 24) & BM_APBX_DEVSEL_CH12)
+#define BP_APBX_DEVSEL_CH11	22
+#define BM_APBX_DEVSEL_CH11	0x00C00000
+#define BF_APBX_DEVSEL_CH11(v)  \
+		(((v) << 22) & BM_APBX_DEVSEL_CH11)
+#define BP_APBX_DEVSEL_CH10	20
+#define BM_APBX_DEVSEL_CH10	0x00300000
+#define BF_APBX_DEVSEL_CH10(v)  \
+		(((v) << 20) & BM_APBX_DEVSEL_CH10)
+#define BP_APBX_DEVSEL_CH9	18
+#define BM_APBX_DEVSEL_CH9	0x000C0000
+#define BF_APBX_DEVSEL_CH9(v)  \
+		(((v) << 18) & BM_APBX_DEVSEL_CH9)
+#define BP_APBX_DEVSEL_CH8	16
+#define BM_APBX_DEVSEL_CH8	0x00030000
+#define BF_APBX_DEVSEL_CH8(v)  \
+		(((v) << 16) & BM_APBX_DEVSEL_CH8)
+#define BP_APBX_DEVSEL_CH7	14
+#define BM_APBX_DEVSEL_CH7	0x0000C000
+#define BF_APBX_DEVSEL_CH7(v)  \
+		(((v) << 14) & BM_APBX_DEVSEL_CH7)
+#define BP_APBX_DEVSEL_CH6	12
+#define BM_APBX_DEVSEL_CH6	0x00003000
+#define BF_APBX_DEVSEL_CH6(v)  \
+		(((v) << 12) & BM_APBX_DEVSEL_CH6)
+#define BP_APBX_DEVSEL_CH5	10
+#define BM_APBX_DEVSEL_CH5	0x00000C00
+#define BF_APBX_DEVSEL_CH5(v)  \
+		(((v) << 10) & BM_APBX_DEVSEL_CH5)
+#define BP_APBX_DEVSEL_CH4	8
+#define BM_APBX_DEVSEL_CH4	0x00000300
+#define BF_APBX_DEVSEL_CH4(v)  \
+		(((v) << 8) & BM_APBX_DEVSEL_CH4)
+#define BP_APBX_DEVSEL_CH3	6
+#define BM_APBX_DEVSEL_CH3	0x000000C0
+#define BF_APBX_DEVSEL_CH3(v)  \
+		(((v) << 6) & BM_APBX_DEVSEL_CH3)
+#define BP_APBX_DEVSEL_CH2	4
+#define BM_APBX_DEVSEL_CH2	0x00000030
+#define BF_APBX_DEVSEL_CH2(v)  \
+		(((v) << 4) & BM_APBX_DEVSEL_CH2)
+#define BP_APBX_DEVSEL_CH1	2
+#define BM_APBX_DEVSEL_CH1	0x0000000C
+#define BF_APBX_DEVSEL_CH1(v)  \
+		(((v) << 2) & BM_APBX_DEVSEL_CH1)
+#define BP_APBX_DEVSEL_CH0	0
+#define BM_APBX_DEVSEL_CH0	0x00000003
+#define BF_APBX_DEVSEL_CH0(v)  \
+		(((v) << 0) & BM_APBX_DEVSEL_CH0)
+
+/*
+ *  multi-register-define name HW_APBX_CHn_CURCMDAR
+ *              base 0x00000100
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_CURCMDAR(n)	(0x00000100 + (n) * 0x70)
+#define BP_APBX_CHn_CURCMDAR_CMD_ADDR	0
+#define BM_APBX_CHn_CURCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBX_CHn_CURCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBX_CHn_NXTCMDAR
+ *              base 0x00000110
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_NXTCMDAR(n)	(0x00000110 + (n) * 0x70)
+#define BP_APBX_CHn_NXTCMDAR_CMD_ADDR	0
+#define BM_APBX_CHn_NXTCMDAR_CMD_ADDR	0xFFFFFFFF
+#define BF_APBX_CHn_NXTCMDAR_CMD_ADDR(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBX_CHn_CMD
+ *              base 0x00000120
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_CMD(n)	(0x00000120 + (n) * 0x70)
+#define BP_APBX_CHn_CMD_XFER_COUNT	16
+#define BM_APBX_CHn_CMD_XFER_COUNT	0xFFFF0000
+#define BF_APBX_CHn_CMD_XFER_COUNT(v) \
+		(((v) << 16) & BM_APBX_CHn_CMD_XFER_COUNT)
+#define BP_APBX_CHn_CMD_CMDWORDS	12
+#define BM_APBX_CHn_CMD_CMDWORDS	0x0000F000
+#define BF_APBX_CHn_CMD_CMDWORDS(v)  \
+		(((v) << 12) & BM_APBX_CHn_CMD_CMDWORDS)
+#define BP_APBX_CHn_CMD_RSVD1	10
+#define BM_APBX_CHn_CMD_RSVD1	0x00000C00
+#define BF_APBX_CHn_CMD_RSVD1(v)  \
+		(((v) << 10) & BM_APBX_CHn_CMD_RSVD1)
+#define BM_APBX_CHn_CMD_TERMINATEFLUSH	0x00000200
+#define BM_APBX_CHn_CMD_HALTONTERMINATE	0x00000100
+#define BM_APBX_CHn_CMD_WAIT4ENDCMD	0x00000080
+#define BM_APBX_CHn_CMD_SEMAPHORE	0x00000040
+#define BP_APBX_CHn_CMD_RSVD0	4
+#define BM_APBX_CHn_CMD_RSVD0	0x00000030
+#define BF_APBX_CHn_CMD_RSVD0(v)  \
+		(((v) << 4) & BM_APBX_CHn_CMD_RSVD0)
+#define BM_APBX_CHn_CMD_IRQONCMPLT	0x00000008
+#define BM_APBX_CHn_CMD_CHAIN	0x00000004
+#define BP_APBX_CHn_CMD_COMMAND	0
+#define BM_APBX_CHn_CMD_COMMAND	0x00000003
+#define BF_APBX_CHn_CMD_COMMAND(v)  \
+		(((v) << 0) & BM_APBX_CHn_CMD_COMMAND)
+#define BV_APBX_CHn_CMD_COMMAND__NO_DMA_XFER 0x0
+#define BV_APBX_CHn_CMD_COMMAND__DMA_WRITE   0x1
+#define BV_APBX_CHn_CMD_COMMAND__DMA_READ    0x2
+
+/*
+ *  multi-register-define name HW_APBX_CHn_BAR
+ *              base 0x00000130
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_BAR(n)	(0x00000130 + (n) * 0x70)
+#define BP_APBX_CHn_BAR_ADDRESS	0
+#define BM_APBX_CHn_BAR_ADDRESS	0xFFFFFFFF
+#define BF_APBX_CHn_BAR_ADDRESS(v)	(v)
+
+/*
+ *  multi-register-define name HW_APBX_CHn_SEMA
+ *              base 0x00000140
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_SEMA(n)	(0x00000140 + (n) * 0x70)
+#define BP_APBX_CHn_SEMA_RSVD2	24
+#define BM_APBX_CHn_SEMA_RSVD2	0xFF000000
+#define BF_APBX_CHn_SEMA_RSVD2(v) \
+		(((v) << 24) & BM_APBX_CHn_SEMA_RSVD2)
+#define BP_APBX_CHn_SEMA_PHORE	16
+#define BM_APBX_CHn_SEMA_PHORE	0x00FF0000
+#define BF_APBX_CHn_SEMA_PHORE(v)  \
+		(((v) << 16) & BM_APBX_CHn_SEMA_PHORE)
+#define BP_APBX_CHn_SEMA_RSVD1	8
+#define BM_APBX_CHn_SEMA_RSVD1	0x0000FF00
+#define BF_APBX_CHn_SEMA_RSVD1(v)  \
+		(((v) << 8) & BM_APBX_CHn_SEMA_RSVD1)
+#define BP_APBX_CHn_SEMA_INCREMENT_SEMA	0
+#define BM_APBX_CHn_SEMA_INCREMENT_SEMA	0x000000FF
+#define BF_APBX_CHn_SEMA_INCREMENT_SEMA(v)  \
+		(((v) << 0) & BM_APBX_CHn_SEMA_INCREMENT_SEMA)
+
+/*
+ *  multi-register-define name HW_APBX_CHn_DEBUG1
+ *              base 0x00000150
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_DEBUG1(n)	(0x00000150 + (n) * 0x70)
+#define BM_APBX_CHn_DEBUG1_REQ	0x80000000
+#define BM_APBX_CHn_DEBUG1_BURST	0x40000000
+#define BM_APBX_CHn_DEBUG1_KICK	0x20000000
+#define BM_APBX_CHn_DEBUG1_END	0x10000000
+#define BP_APBX_CHn_DEBUG1_RSVD2	25
+#define BM_APBX_CHn_DEBUG1_RSVD2	0x0E000000
+#define BF_APBX_CHn_DEBUG1_RSVD2(v)  \
+		(((v) << 25) & BM_APBX_CHn_DEBUG1_RSVD2)
+#define BM_APBX_CHn_DEBUG1_NEXTCMDADDRVALID	0x01000000
+#define BM_APBX_CHn_DEBUG1_RD_FIFO_EMPTY	0x00800000
+#define BM_APBX_CHn_DEBUG1_RD_FIFO_FULL	0x00400000
+#define BM_APBX_CHn_DEBUG1_WR_FIFO_EMPTY	0x00200000
+#define BM_APBX_CHn_DEBUG1_WR_FIFO_FULL	0x00100000
+#define BP_APBX_CHn_DEBUG1_RSVD1	5
+#define BM_APBX_CHn_DEBUG1_RSVD1	0x000FFFE0
+#define BF_APBX_CHn_DEBUG1_RSVD1(v)  \
+		(((v) << 5) & BM_APBX_CHn_DEBUG1_RSVD1)
+#define BP_APBX_CHn_DEBUG1_STATEMACHINE	0
+#define BM_APBX_CHn_DEBUG1_STATEMACHINE	0x0000001F
+#define BF_APBX_CHn_DEBUG1_STATEMACHINE(v)  \
+		(((v) << 0) & BM_APBX_CHn_DEBUG1_STATEMACHINE)
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__IDLE          0x00
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__REQ_CMD1      0x01
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__REQ_CMD3      0x02
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__REQ_CMD2      0x03
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__XFER_DECODE   0x04
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__REQ_WAIT      0x05
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__REQ_CMD4      0x06
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__PIO_REQ       0x07
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__READ_FLUSH    0x08
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__READ_WAIT     0x09
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__WRITE         0x0C
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__READ_REQ      0x0D
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__CHECK_CHAIN   0x0E
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__XFER_COMPLETE 0x0F
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__WAIT_END      0x15
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__WRITE_WAIT    0x1C
+#define BV_APBX_CHn_DEBUG1_STATEMACHINE__CHECK_WAIT    0x1E
+
+/*
+ *  multi-register-define name HW_APBX_CHn_DEBUG2
+ *              base 0x00000160
+ *              count 16
+ *              offset 0x70
+ */
+#define HW_APBX_CHn_DEBUG2(n)	(0x00000160 + (n) * 0x70)
+#define BP_APBX_CHn_DEBUG2_APB_BYTES	16
+#define BM_APBX_CHn_DEBUG2_APB_BYTES	0xFFFF0000
+#define BF_APBX_CHn_DEBUG2_APB_BYTES(v) \
+		(((v) << 16) & BM_APBX_CHn_DEBUG2_APB_BYTES)
+#define BP_APBX_CHn_DEBUG2_AHB_BYTES	0
+#define BM_APBX_CHn_DEBUG2_AHB_BYTES	0x0000FFFF
+#define BF_APBX_CHn_DEBUG2_AHB_BYTES(v)  \
+		(((v) << 0) & BM_APBX_CHn_DEBUG2_AHB_BYTES)
+
+#define HW_APBX_VERSION	(0x00000800)
+
+#define BP_APBX_VERSION_MAJOR	24
+#define BM_APBX_VERSION_MAJOR	0xFF000000
+#define BF_APBX_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_APBX_VERSION_MAJOR)
+#define BP_APBX_VERSION_MINOR	16
+#define BM_APBX_VERSION_MINOR	0x00FF0000
+#define BF_APBX_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_APBX_VERSION_MINOR)
+#define BP_APBX_VERSION_STEP	0
+#define BM_APBX_VERSION_STEP	0x0000FFFF
+#define BF_APBX_VERSION_STEP(v)  \
+		(((v) << 0) & BM_APBX_VERSION_STEP)
+#endif /* __ARCH_ARM___APBX_H */
diff --git a/arch/arm/plat-mxs/regs-icoll.h b/arch/arm/plat-mxs/regs-icoll.h
new file mode 100644
index 0000000..f06ac0d
--- /dev/null
+++ b/arch/arm/plat-mxs/regs-icoll.h
@@ -0,0 +1,293 @@
+/*
+ * Freescale ICOLL Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.50
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___ICOLL_H
+#define __ARCH_ARM___ICOLL_H
+
+#define HW_ICOLL_VECTOR	(0x00000000)
+#define HW_ICOLL_VECTOR_SET	(0x00000004)
+#define HW_ICOLL_VECTOR_CLR	(0x00000008)
+#define HW_ICOLL_VECTOR_TOG	(0x0000000c)
+
+#define BP_ICOLL_VECTOR_IRQVECTOR	2
+#define BM_ICOLL_VECTOR_IRQVECTOR	0xFFFFFFFC
+#define BF_ICOLL_VECTOR_IRQVECTOR(v) \
+		(((v) << 2) & BM_ICOLL_VECTOR_IRQVECTOR)
+#define BP_ICOLL_VECTOR_RSRVD1	0
+#define BM_ICOLL_VECTOR_RSRVD1	0x00000003
+#define BF_ICOLL_VECTOR_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_VECTOR_RSRVD1)
+
+#define HW_ICOLL_LEVELACK	(0x00000010)
+
+#define BP_ICOLL_LEVELACK_RSRVD1	4
+#define BM_ICOLL_LEVELACK_RSRVD1	0xFFFFFFF0
+#define BF_ICOLL_LEVELACK_RSRVD1(v) \
+		(((v) << 4) & BM_ICOLL_LEVELACK_RSRVD1)
+#define BP_ICOLL_LEVELACK_IRQLEVELACK	0
+#define BM_ICOLL_LEVELACK_IRQLEVELACK	0x0000000F
+#define BF_ICOLL_LEVELACK_IRQLEVELACK(v)  \
+		(((v) << 0) & BM_ICOLL_LEVELACK_IRQLEVELACK)
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0 0x1
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL1 0x2
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL2 0x4
+#define BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL3 0x8
+
+#define HW_ICOLL_CTRL	(0x00000020)
+#define HW_ICOLL_CTRL_SET	(0x00000024)
+#define HW_ICOLL_CTRL_CLR	(0x00000028)
+#define HW_ICOLL_CTRL_TOG	(0x0000002c)
+
+#define BM_ICOLL_CTRL_SFTRST	0x80000000
+#define BV_ICOLL_CTRL_SFTRST__RUN      0x0
+#define BV_ICOLL_CTRL_SFTRST__IN_RESET 0x1
+#define BM_ICOLL_CTRL_CLKGATE	0x40000000
+#define BV_ICOLL_CTRL_CLKGATE__RUN       0x0
+#define BV_ICOLL_CTRL_CLKGATE__NO_CLOCKS 0x1
+#define BP_ICOLL_CTRL_RSRVD3	24
+#define BM_ICOLL_CTRL_RSRVD3	0x3F000000
+#define BF_ICOLL_CTRL_RSRVD3(v)  \
+		(((v) << 24) & BM_ICOLL_CTRL_RSRVD3)
+#define BP_ICOLL_CTRL_VECTOR_PITCH	21
+#define BM_ICOLL_CTRL_VECTOR_PITCH	0x00E00000
+#define BF_ICOLL_CTRL_VECTOR_PITCH(v)  \
+		(((v) << 21) & BM_ICOLL_CTRL_VECTOR_PITCH)
+#define BV_ICOLL_CTRL_VECTOR_PITCH__DEFAULT_BY4 0x0
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY4         0x1
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY8         0x2
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY12        0x3
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY16        0x4
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY20        0x5
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY24        0x6
+#define BV_ICOLL_CTRL_VECTOR_PITCH__BY28        0x7
+#define BM_ICOLL_CTRL_BYPASS_FSM	0x00100000
+#define BV_ICOLL_CTRL_BYPASS_FSM__NORMAL 0x0
+#define BV_ICOLL_CTRL_BYPASS_FSM__BYPASS 0x1
+#define BM_ICOLL_CTRL_NO_NESTING	0x00080000
+#define BV_ICOLL_CTRL_NO_NESTING__NORMAL  0x0
+#define BV_ICOLL_CTRL_NO_NESTING__NO_NEST 0x1
+#define BM_ICOLL_CTRL_ARM_RSE_MODE	0x00040000
+#define BM_ICOLL_CTRL_FIQ_FINAL_ENABLE	0x00020000
+#define BV_ICOLL_CTRL_FIQ_FINAL_ENABLE__DISABLE 0x0
+#define BV_ICOLL_CTRL_FIQ_FINAL_ENABLE__ENABLE  0x1
+#define BM_ICOLL_CTRL_IRQ_FINAL_ENABLE	0x00010000
+#define BV_ICOLL_CTRL_IRQ_FINAL_ENABLE__DISABLE 0x0
+#define BV_ICOLL_CTRL_IRQ_FINAL_ENABLE__ENABLE  0x1
+#define BP_ICOLL_CTRL_RSRVD1	0
+#define BM_ICOLL_CTRL_RSRVD1	0x0000FFFF
+#define BF_ICOLL_CTRL_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_CTRL_RSRVD1)
+
+#define HW_ICOLL_VBASE	(0x00000040)
+#define HW_ICOLL_VBASE_SET	(0x00000044)
+#define HW_ICOLL_VBASE_CLR	(0x00000048)
+#define HW_ICOLL_VBASE_TOG	(0x0000004c)
+
+#define BP_ICOLL_VBASE_TABLE_ADDRESS	2
+#define BM_ICOLL_VBASE_TABLE_ADDRESS	0xFFFFFFFC
+#define BF_ICOLL_VBASE_TABLE_ADDRESS(v) \
+		(((v) << 2) & BM_ICOLL_VBASE_TABLE_ADDRESS)
+#define BP_ICOLL_VBASE_RSRVD1	0
+#define BM_ICOLL_VBASE_RSRVD1	0x00000003
+#define BF_ICOLL_VBASE_RSRVD1(v)  \
+		(((v) << 0) & BM_ICOLL_VBASE_RSRVD1)
+
+#define HW_ICOLL_STAT	(0x00000070)
+
+#define BP_ICOLL_STAT_RSRVD1	7
+#define BM_ICOLL_STAT_RSRVD1	0xFFFFFF80
+#define BF_ICOLL_STAT_RSRVD1(v) \
+		(((v) << 7) & BM_ICOLL_STAT_RSRVD1)
+#define BP_ICOLL_STAT_VECTOR_NUMBER	0
+#define BM_ICOLL_STAT_VECTOR_NUMBER	0x0000007F
+#define BF_ICOLL_STAT_VECTOR_NUMBER(v)  \
+		(((v) << 0) & BM_ICOLL_STAT_VECTOR_NUMBER)
+
+/*
+ *  multi-register-define name HW_ICOLL_RAWn
+ *              base 0x000000A0
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_ICOLL_RAWn(n)	(0x000000a0 + (n) * 0x10)
+#define HW_ICOLL_RAWn_SET(n)	(0x000000a4 + (n) * 0x10)
+#define HW_ICOLL_RAWn_CLR(n)	(0x000000a8 + (n) * 0x10)
+#define HW_ICOLL_RAWn_TOG(n)	(0x000000ac + (n) * 0x10)
+#define BP_ICOLL_RAWn_RAW_IRQS	0
+#define BM_ICOLL_RAWn_RAW_IRQS	0xFFFFFFFF
+#define BF_ICOLL_RAWn_RAW_IRQS(v)	(v)
+
+/*
+ *  multi-register-define name HW_ICOLL_INTERRUPTn
+ *              base 0x00000120
+ *              count 128
+ *              offset 0x10
+ */
+#define HW_ICOLL_INTERRUPTn(n)	(0x00000120 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_SET(n)	(0x00000124 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_CLR(n)	(0x00000128 + (n) * 0x10)
+#define HW_ICOLL_INTERRUPTn_TOG(n)	(0x0000012c + (n) * 0x10)
+#define BP_ICOLL_INTERRUPTn_RSRVD1	5
+#define BM_ICOLL_INTERRUPTn_RSRVD1	0xFFFFFFE0
+#define BF_ICOLL_INTERRUPTn_RSRVD1(v) \
+		(((v) << 5) & BM_ICOLL_INTERRUPTn_RSRVD1)
+#define BM_ICOLL_INTERRUPTn_ENFIQ	0x00000010
+#define BV_ICOLL_INTERRUPTn_ENFIQ__DISABLE 0x0
+#define BV_ICOLL_INTERRUPTn_ENFIQ__ENABLE  0x1
+#define BM_ICOLL_INTERRUPTn_SOFTIRQ	0x00000008
+#define BV_ICOLL_INTERRUPTn_SOFTIRQ__NO_INTERRUPT    0x0
+#define BV_ICOLL_INTERRUPTn_SOFTIRQ__FORCE_INTERRUPT 0x1
+#define BM_ICOLL_INTERRUPTn_ENABLE	0x00000004
+#define BV_ICOLL_INTERRUPTn_ENABLE__DISABLE 0x0
+#define BV_ICOLL_INTERRUPTn_ENABLE__ENABLE  0x1
+#define BP_ICOLL_INTERRUPTn_PRIORITY	0
+#define BM_ICOLL_INTERRUPTn_PRIORITY	0x00000003
+#define BF_ICOLL_INTERRUPTn_PRIORITY(v)  \
+		(((v) << 0) & BM_ICOLL_INTERRUPTn_PRIORITY)
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL0 0x0
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL1 0x1
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL2 0x2
+#define BV_ICOLL_INTERRUPTn_PRIORITY__LEVEL3 0x3
+
+#define HW_ICOLL_DEBUG	(0x00001120)
+#define HW_ICOLL_DEBUG_SET	(0x00001124)
+#define HW_ICOLL_DEBUG_CLR	(0x00001128)
+#define HW_ICOLL_DEBUG_TOG	(0x0000112c)
+
+#define BP_ICOLL_DEBUG_INSERVICE	28
+#define BM_ICOLL_DEBUG_INSERVICE	0xF0000000
+#define BF_ICOLL_DEBUG_INSERVICE(v) \
+		(((v) << 28) & BM_ICOLL_DEBUG_INSERVICE)
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_INSERVICE__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_LEVEL_REQUESTS	24
+#define BM_ICOLL_DEBUG_LEVEL_REQUESTS	0x0F000000
+#define BF_ICOLL_DEBUG_LEVEL_REQUESTS(v)  \
+		(((v) << 24) & BM_ICOLL_DEBUG_LEVEL_REQUESTS)
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_LEVEL_REQUESTS__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_REQUESTS_BY_LEVEL	20
+#define BM_ICOLL_DEBUG_REQUESTS_BY_LEVEL	0x00F00000
+#define BF_ICOLL_DEBUG_REQUESTS_BY_LEVEL(v)  \
+		(((v) << 20) & BM_ICOLL_DEBUG_REQUESTS_BY_LEVEL)
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL0 0x1
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL1 0x2
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL2 0x4
+#define BV_ICOLL_DEBUG_REQUESTS_BY_LEVEL__LEVEL3 0x8
+#define BP_ICOLL_DEBUG_RSRVD2	18
+#define BM_ICOLL_DEBUG_RSRVD2	0x000C0000
+#define BF_ICOLL_DEBUG_RSRVD2(v)  \
+		(((v) << 18) & BM_ICOLL_DEBUG_RSRVD2)
+#define BM_ICOLL_DEBUG_FIQ	0x00020000
+#define BV_ICOLL_DEBUG_FIQ__NO_FIQ_REQUESTED 0x0
+#define BV_ICOLL_DEBUG_FIQ__FIQ_REQUESTED    0x1
+#define BM_ICOLL_DEBUG_IRQ	0x00010000
+#define BV_ICOLL_DEBUG_IRQ__NO_IRQ_REQUESTED 0x0
+#define BV_ICOLL_DEBUG_IRQ__IRQ_REQUESTED    0x1
+#define BP_ICOLL_DEBUG_RSRVD1	10
+#define BM_ICOLL_DEBUG_RSRVD1	0x0000FC00
+#define BF_ICOLL_DEBUG_RSRVD1(v)  \
+		(((v) << 10) & BM_ICOLL_DEBUG_RSRVD1)
+#define BP_ICOLL_DEBUG_VECTOR_FSM	0
+#define BM_ICOLL_DEBUG_VECTOR_FSM	0x000003FF
+#define BF_ICOLL_DEBUG_VECTOR_FSM(v)  \
+		(((v) << 0) & BM_ICOLL_DEBUG_VECTOR_FSM)
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_IDLE         0x000
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE1  0x001
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE2  0x002
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_PENDING      0x004
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE3  0x008
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE4  0x010
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING1 0x020
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING2 0x040
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_ISR_RUNNING3 0x080
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE5  0x100
+#define BV_ICOLL_DEBUG_VECTOR_FSM__FSM_MULTICYCLE6  0x200
+
+#define HW_ICOLL_DBGREAD0	(0x00001130)
+#define HW_ICOLL_DBGREAD0_SET	(0x00001134)
+#define HW_ICOLL_DBGREAD0_CLR	(0x00001138)
+#define HW_ICOLL_DBGREAD0_TOG	(0x0000113c)
+
+#define BP_ICOLL_DBGREAD0_VALUE	0
+#define BM_ICOLL_DBGREAD0_VALUE	0xFFFFFFFF
+#define BF_ICOLL_DBGREAD0_VALUE(v)	(v)
+
+#define HW_ICOLL_DBGREAD1	(0x00001140)
+#define HW_ICOLL_DBGREAD1_SET	(0x00001144)
+#define HW_ICOLL_DBGREAD1_CLR	(0x00001148)
+#define HW_ICOLL_DBGREAD1_TOG	(0x0000114c)
+
+#define BP_ICOLL_DBGREAD1_VALUE	0
+#define BM_ICOLL_DBGREAD1_VALUE	0xFFFFFFFF
+#define BF_ICOLL_DBGREAD1_VALUE(v)	(v)
+
+#define HW_ICOLL_DBGFLAG	(0x00001150)
+#define HW_ICOLL_DBGFLAG_SET	(0x00001154)
+#define HW_ICOLL_DBGFLAG_CLR	(0x00001158)
+#define HW_ICOLL_DBGFLAG_TOG	(0x0000115c)
+
+#define BP_ICOLL_DBGFLAG_RSRVD1	16
+#define BM_ICOLL_DBGFLAG_RSRVD1	0xFFFF0000
+#define BF_ICOLL_DBGFLAG_RSRVD1(v) \
+		(((v) << 16) & BM_ICOLL_DBGFLAG_RSRVD1)
+#define BP_ICOLL_DBGFLAG_FLAG	0
+#define BM_ICOLL_DBGFLAG_FLAG	0x0000FFFF
+#define BF_ICOLL_DBGFLAG_FLAG(v)  \
+		(((v) << 0) & BM_ICOLL_DBGFLAG_FLAG)
+
+/*
+ *  multi-register-define name HW_ICOLL_DBGREQUESTn
+ *              base 0x00001160
+ *              count 4
+ *              offset 0x10
+ */
+#define HW_ICOLL_DBGREQUESTn(n)	(0x00001160 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_SET(n)	(0x00001164 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_CLR(n)	(0x00001168 + (n) * 0x10)
+#define HW_ICOLL_DBGREQUESTn_TOG(n)	(0x0000116c + (n) * 0x10)
+#define BP_ICOLL_DBGREQUESTn_BITS	0
+#define BM_ICOLL_DBGREQUESTn_BITS	0xFFFFFFFF
+#define BF_ICOLL_DBGREQUESTn_BITS(v)	(v)
+
+#define HW_ICOLL_VERSION	(0x000011e0)
+
+#define BP_ICOLL_VERSION_MAJOR	24
+#define BM_ICOLL_VERSION_MAJOR	0xFF000000
+#define BF_ICOLL_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_ICOLL_VERSION_MAJOR)
+#define BP_ICOLL_VERSION_MINOR	16
+#define BM_ICOLL_VERSION_MINOR	0x00FF0000
+#define BF_ICOLL_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_ICOLL_VERSION_MINOR)
+#define BP_ICOLL_VERSION_STEP	0
+#define BM_ICOLL_VERSION_STEP	0x0000FFFF
+#define BF_ICOLL_VERSION_STEP(v)  \
+		(((v) << 0) & BM_ICOLL_VERSION_STEP)
+#endif /* __ARCH_ARM___ICOLL_H */
diff --git a/arch/arm/plat-mxs/regs-usbphy.h b/arch/arm/plat-mxs/regs-usbphy.h
new file mode 100644
index 0000000..cf64bfd
--- /dev/null
+++ b/arch/arm/plat-mxs/regs-usbphy.h
@@ -0,0 +1,323 @@
+/*
+ * Freescale USBPHY Register Definitions
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.52
+ * Template revision: 26195
+ */
+
+#ifndef __ARCH_ARM___USBPHY_H
+#define __ARCH_ARM___USBPHY_H
+
+
+#define HW_USBPHY_PWD	(0x00000000)
+#define HW_USBPHY_PWD_SET	(0x00000004)
+#define HW_USBPHY_PWD_CLR	(0x00000008)
+#define HW_USBPHY_PWD_TOG	(0x0000000c)
+
+#define BP_USBPHY_PWD_RSVD2	21
+#define BM_USBPHY_PWD_RSVD2	0xFFE00000
+#define BF_USBPHY_PWD_RSVD2(v) \
+		(((v) << 21) & BM_USBPHY_PWD_RSVD2)
+#define BM_USBPHY_PWD_RXPWDRX	0x00100000
+#define BM_USBPHY_PWD_RXPWDDIFF	0x00080000
+#define BM_USBPHY_PWD_RXPWD1PT1	0x00040000
+#define BM_USBPHY_PWD_RXPWDENV	0x00020000
+#define BP_USBPHY_PWD_RSVD1	13
+#define BM_USBPHY_PWD_RSVD1	0x0001E000
+#define BF_USBPHY_PWD_RSVD1(v)  \
+		(((v) << 13) & BM_USBPHY_PWD_RSVD1)
+#define BM_USBPHY_PWD_TXPWDV2I	0x00001000
+#define BM_USBPHY_PWD_TXPWDIBIAS	0x00000800
+#define BM_USBPHY_PWD_TXPWDFS	0x00000400
+#define BP_USBPHY_PWD_RSVD0	0
+#define BM_USBPHY_PWD_RSVD0	0x000003FF
+#define BF_USBPHY_PWD_RSVD0(v)  \
+		(((v) << 0) & BM_USBPHY_PWD_RSVD0)
+
+#define HW_USBPHY_TX	(0x00000010)
+#define HW_USBPHY_TX_SET	(0x00000014)
+#define HW_USBPHY_TX_CLR	(0x00000018)
+#define HW_USBPHY_TX_TOG	(0x0000001c)
+
+#define BP_USBPHY_TX_RSVD5	29
+#define BM_USBPHY_TX_RSVD5	0xE0000000
+#define BF_USBPHY_TX_RSVD5(v) \
+		(((v) << 29) & BM_USBPHY_TX_RSVD5)
+#define BP_USBPHY_TX_USBPHY_TX_EDGECTRL	26
+#define BM_USBPHY_TX_USBPHY_TX_EDGECTRL	0x1C000000
+#define BF_USBPHY_TX_USBPHY_TX_EDGECTRL(v)  \
+		(((v) << 26) & BM_USBPHY_TX_USBPHY_TX_EDGECTRL)
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_INVERT	0x02000000
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_MUX	0x01000000
+#define BP_USBPHY_TX_RSVD4	22
+#define BM_USBPHY_TX_RSVD4	0x00C00000
+#define BF_USBPHY_TX_RSVD4(v)  \
+		(((v) << 22) & BM_USBPHY_TX_RSVD4)
+#define BM_USBPHY_TX_TXENCAL45DP	0x00200000
+#define BM_USBPHY_TX_RSVD3	0x00100000
+#define BP_USBPHY_TX_TXCAL45DP	16
+#define BM_USBPHY_TX_TXCAL45DP	0x000F0000
+#define BF_USBPHY_TX_TXCAL45DP(v)  \
+		(((v) << 16) & BM_USBPHY_TX_TXCAL45DP)
+#define BP_USBPHY_TX_RSVD2	14
+#define BM_USBPHY_TX_RSVD2	0x0000C000
+#define BF_USBPHY_TX_RSVD2(v)  \
+		(((v) << 14) & BM_USBPHY_TX_RSVD2)
+#define BM_USBPHY_TX_TXENCAL45DN	0x00002000
+#define BM_USBPHY_TX_RSVD1	0x00001000
+#define BP_USBPHY_TX_TXCAL45DN	8
+#define BM_USBPHY_TX_TXCAL45DN	0x00000F00
+#define BF_USBPHY_TX_TXCAL45DN(v)  \
+		(((v) << 8) & BM_USBPHY_TX_TXCAL45DN)
+#define BP_USBPHY_TX_RSVD0	4
+#define BM_USBPHY_TX_RSVD0	0x000000F0
+#define BF_USBPHY_TX_RSVD0(v)  \
+		(((v) << 4) & BM_USBPHY_TX_RSVD0)
+#define BP_USBPHY_TX_D_CAL	0
+#define BM_USBPHY_TX_D_CAL	0x0000000F
+#define BF_USBPHY_TX_D_CAL(v)  \
+		(((v) << 0) & BM_USBPHY_TX_D_CAL)
+
+#define HW_USBPHY_RX	(0x00000020)
+#define HW_USBPHY_RX_SET	(0x00000024)
+#define HW_USBPHY_RX_CLR	(0x00000028)
+#define HW_USBPHY_RX_TOG	(0x0000002c)
+
+#define BP_USBPHY_RX_RSVD2	23
+#define BM_USBPHY_RX_RSVD2	0xFF800000
+#define BF_USBPHY_RX_RSVD2(v) \
+		(((v) << 23) & BM_USBPHY_RX_RSVD2)
+#define BM_USBPHY_RX_RXDBYPASS	0x00400000
+#define BP_USBPHY_RX_RSVD1	7
+#define BM_USBPHY_RX_RSVD1	0x003FFF80
+#define BF_USBPHY_RX_RSVD1(v)  \
+		(((v) << 7) & BM_USBPHY_RX_RSVD1)
+#define BP_USBPHY_RX_DISCONADJ	4
+#define BM_USBPHY_RX_DISCONADJ	0x00000070
+#define BF_USBPHY_RX_DISCONADJ(v)  \
+		(((v) << 4) & BM_USBPHY_RX_DISCONADJ)
+#define BM_USBPHY_RX_RSVD0	0x00000008
+#define BP_USBPHY_RX_ENVADJ	0
+#define BM_USBPHY_RX_ENVADJ	0x00000007
+#define BF_USBPHY_RX_ENVADJ(v)  \
+		(((v) << 0) & BM_USBPHY_RX_ENVADJ)
+
+#define HW_USBPHY_CTRL	(0x00000030)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define HW_USBPHY_CTRL_CLR	(0x00000038)
+#define HW_USBPHY_CTRL_TOG	(0x0000003c)
+
+#define BM_USBPHY_CTRL_SFTRST	0x80000000
+#define BM_USBPHY_CTRL_CLKGATE	0x40000000
+#define BM_USBPHY_CTRL_UTMI_SUSPENDM	0x20000000
+#define BM_USBPHY_CTRL_HOST_FORCE_LS_SE0	0x10000000
+#define BM_USBPHY_CTRL_RSVD3	0x08000000
+#define BM_USBPHY_CTRL_ENAUTOSET_USBCLKS	0x04000000
+#define BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE	0x02000000
+#define BM_USBPHY_CTRL_FSDLL_RST_EN	0x01000000
+#define BM_USBPHY_CTRL_ENVBUSCHG_WKUP	0x00800000
+#define BM_USBPHY_CTRL_ENIDCHG_WKUP	0x00400000
+#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP	0x00200000
+#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD	0x00100000
+#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE	0x00080000
+#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL	0x00040000
+#define BM_USBPHY_CTRL_WAKEUP_IRQ	0x00020000
+#define BM_USBPHY_CTRL_ENIRQWAKEUP	0x00010000
+#define BM_USBPHY_CTRL_ENUTMILEVEL3	0x00008000
+#define BM_USBPHY_CTRL_ENUTMILEVEL2	0x00004000
+#define BM_USBPHY_CTRL_DATA_ON_LRADC	0x00002000
+#define BM_USBPHY_CTRL_DEVPLUGIN_IRQ	0x00001000
+#define BM_USBPHY_CTRL_ENIRQDEVPLUGIN	0x00000800
+#define BM_USBPHY_CTRL_RESUME_IRQ	0x00000400
+#define BM_USBPHY_CTRL_ENIRQRESUMEDETECT	0x00000200
+#define BM_USBPHY_CTRL_RESUMEIRQSTICKY	0x00000100
+#define BM_USBPHY_CTRL_ENOTGIDDETECT	0x00000080
+#define BM_USBPHY_CTRL_RSVD1	0x00000040
+#define BM_USBPHY_CTRL_DEVPLUGIN_POLARITY	0x00000020
+#define BM_USBPHY_CTRL_ENDEVPLUGINDETECT	0x00000010
+#define BM_USBPHY_CTRL_HOSTDISCONDETECT_IRQ	0x00000008
+#define BM_USBPHY_CTRL_ENIRQHOSTDISCON	0x00000004
+#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT	0x00000002
+#define BM_USBPHY_CTRL_RSVD0	0x00000001
+
+#define HW_USBPHY_STATUS	(0x00000040)
+
+#define BP_USBPHY_STATUS_RSVD4	11
+#define BM_USBPHY_STATUS_RSVD4	0xFFFFF800
+#define BF_USBPHY_STATUS_RSVD4(v) \
+		(((v) << 11) & BM_USBPHY_STATUS_RSVD4)
+#define BM_USBPHY_STATUS_RESUME_STATUS	0x00000400
+#define BM_USBPHY_STATUS_RSVD3	0x00000200
+#define BM_USBPHY_STATUS_OTGID_STATUS	0x00000100
+#define BM_USBPHY_STATUS_RSVD2	0x00000080
+#define BM_USBPHY_STATUS_DEVPLUGIN_STATUS	0x00000040
+#define BP_USBPHY_STATUS_RSVD1	4
+#define BM_USBPHY_STATUS_RSVD1	0x00000030
+#define BF_USBPHY_STATUS_RSVD1(v)  \
+		(((v) << 4) & BM_USBPHY_STATUS_RSVD1)
+#define BM_USBPHY_STATUS_HOSTDISCONDETECT_STATUS	0x00000008
+#define BP_USBPHY_STATUS_RSVD0	0
+#define BM_USBPHY_STATUS_RSVD0	0x00000007
+#define BF_USBPHY_STATUS_RSVD0(v)  \
+		(((v) << 0) & BM_USBPHY_STATUS_RSVD0)
+
+#define HW_USBPHY_DEBUG	(0x00000050)
+#define HW_USBPHY_DEBUG_SET	(0x00000054)
+#define HW_USBPHY_DEBUG_CLR	(0x00000058)
+#define HW_USBPHY_DEBUG_TOG	(0x0000005c)
+
+#define BM_USBPHY_DEBUG_RSVD3	0x80000000
+#define BM_USBPHY_DEBUG_CLKGATE	0x40000000
+#define BM_USBPHY_DEBUG_HOST_RESUME_DEBUG	0x20000000
+#define BP_USBPHY_DEBUG_SQUELCHRESETLENGTH	25
+#define BM_USBPHY_DEBUG_SQUELCHRESETLENGTH	0x1E000000
+#define BF_USBPHY_DEBUG_SQUELCHRESETLENGTH(v)  \
+		(((v) << 25) & BM_USBPHY_DEBUG_SQUELCHRESETLENGTH)
+#define BM_USBPHY_DEBUG_ENSQUELCHRESET	0x01000000
+#define BP_USBPHY_DEBUG_RSVD2	21
+#define BM_USBPHY_DEBUG_RSVD2	0x00E00000
+#define BF_USBPHY_DEBUG_RSVD2(v)  \
+		(((v) << 21) & BM_USBPHY_DEBUG_RSVD2)
+#define BP_USBPHY_DEBUG_SQUELCHRESETCOUNT	16
+#define BM_USBPHY_DEBUG_SQUELCHRESETCOUNT	0x001F0000
+#define BF_USBPHY_DEBUG_SQUELCHRESETCOUNT(v)  \
+		(((v) << 16) & BM_USBPHY_DEBUG_SQUELCHRESETCOUNT)
+#define BP_USBPHY_DEBUG_RSVD1	13
+#define BM_USBPHY_DEBUG_RSVD1	0x0000E000
+#define BF_USBPHY_DEBUG_RSVD1(v)  \
+		(((v) << 13) & BM_USBPHY_DEBUG_RSVD1)
+#define BM_USBPHY_DEBUG_ENTX2RXCOUNT	0x00001000
+#define BP_USBPHY_DEBUG_TX2RXCOUNT	8
+#define BM_USBPHY_DEBUG_TX2RXCOUNT	0x00000F00
+#define BF_USBPHY_DEBUG_TX2RXCOUNT(v)  \
+		(((v) << 8) & BM_USBPHY_DEBUG_TX2RXCOUNT)
+#define BP_USBPHY_DEBUG_RSVD0	6
+#define BM_USBPHY_DEBUG_RSVD0	0x000000C0
+#define BF_USBPHY_DEBUG_RSVD0(v)  \
+		(((v) << 6) & BM_USBPHY_DEBUG_RSVD0)
+#define BP_USBPHY_DEBUG_ENHSTPULLDOWN	4
+#define BM_USBPHY_DEBUG_ENHSTPULLDOWN	0x00000030
+#define BF_USBPHY_DEBUG_ENHSTPULLDOWN(v)  \
+		(((v) << 4) & BM_USBPHY_DEBUG_ENHSTPULLDOWN)
+#define BP_USBPHY_DEBUG_HSTPULLDOWN	2
+#define BM_USBPHY_DEBUG_HSTPULLDOWN	0x0000000C
+#define BF_USBPHY_DEBUG_HSTPULLDOWN(v)  \
+		(((v) << 2) & BM_USBPHY_DEBUG_HSTPULLDOWN)
+#define BM_USBPHY_DEBUG_DEBUG_INTERFACE_HOLD	0x00000002
+#define BM_USBPHY_DEBUG_OTGIDPIOLOCK	0x00000001
+
+#define HW_USBPHY_DEBUG0_STATUS	(0x00000060)
+
+#define BP_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT	26
+#define BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT	0xFC000000
+#define BF_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT(v) \
+		(((v) << 26) & BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT	16
+#define BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT	0x03FF0000
+#define BF_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(v)  \
+		(((v) << 16) & BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT	0
+#define BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT	0x0000FFFF
+#define BF_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(v)  \
+		(((v) << 0) & BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT)
+
+#define HW_USBPHY_DEBUG1	(0x00000070)
+#define HW_USBPHY_DEBUG1_SET	(0x00000074)
+#define HW_USBPHY_DEBUG1_CLR	(0x00000078)
+#define HW_USBPHY_DEBUG1_TOG	(0x0000007c)
+
+#define BP_USBPHY_DEBUG1_RSVD1	15
+#define BM_USBPHY_DEBUG1_RSVD1	0xFFFF8000
+#define BF_USBPHY_DEBUG1_RSVD1(v) \
+		(((v) << 15) & BM_USBPHY_DEBUG1_RSVD1)
+#define BP_USBPHY_DEBUG1_ENTAILADJVD	13
+#define BM_USBPHY_DEBUG1_ENTAILADJVD	0x00006000
+#define BF_USBPHY_DEBUG1_ENTAILADJVD(v)  \
+		(((v) << 13) & BM_USBPHY_DEBUG1_ENTAILADJVD)
+#define BM_USBPHY_DEBUG1_ENTX2TX	0x00001000
+#define BP_USBPHY_DEBUG1_RSVD0	4
+#define BM_USBPHY_DEBUG1_RSVD0	0x00000FF0
+#define BF_USBPHY_DEBUG1_RSVD0(v)  \
+		(((v) << 4) & BM_USBPHY_DEBUG1_RSVD0)
+#define BP_USBPHY_DEBUG1_DBG_ADDRESS	0
+#define BM_USBPHY_DEBUG1_DBG_ADDRESS	0x0000000F
+#define BF_USBPHY_DEBUG1_DBG_ADDRESS(v)  \
+		(((v) << 0) & BM_USBPHY_DEBUG1_DBG_ADDRESS)
+
+#define HW_USBPHY_VERSION	(0x00000080)
+
+#define BP_USBPHY_VERSION_MAJOR	24
+#define BM_USBPHY_VERSION_MAJOR	0xFF000000
+#define BF_USBPHY_VERSION_MAJOR(v) \
+		(((v) << 24) & BM_USBPHY_VERSION_MAJOR)
+#define BP_USBPHY_VERSION_MINOR	16
+#define BM_USBPHY_VERSION_MINOR	0x00FF0000
+#define BF_USBPHY_VERSION_MINOR(v)  \
+		(((v) << 16) & BM_USBPHY_VERSION_MINOR)
+#define BP_USBPHY_VERSION_STEP	0
+#define BM_USBPHY_VERSION_STEP	0x0000FFFF
+#define BF_USBPHY_VERSION_STEP(v)  \
+		(((v) << 0) & BM_USBPHY_VERSION_STEP)
+
+#define HW_USBPHY_IP	(0x00000090)
+#define HW_USBPHY_IP_SET	(0x00000094)
+#define HW_USBPHY_IP_CLR	(0x00000098)
+#define HW_USBPHY_IP_TOG	(0x0000009c)
+
+#define BP_USBPHY_IP_RSVD1	25
+#define BM_USBPHY_IP_RSVD1	0xFE000000
+#define BF_USBPHY_IP_RSVD1(v) \
+		(((v) << 25) & BM_USBPHY_IP_RSVD1)
+#define BP_USBPHY_IP_DIV_SEL	23
+#define BM_USBPHY_IP_DIV_SEL	0x01800000
+#define BF_USBPHY_IP_DIV_SEL(v)  \
+		(((v) << 23) & BM_USBPHY_IP_DIV_SEL)
+#define BV_USBPHY_IP_DIV_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_DIV_SEL__LOWER     0x1
+#define BV_USBPHY_IP_DIV_SEL__LOWEST    0x2
+#define BV_USBPHY_IP_DIV_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_LFR_SEL	21
+#define BM_USBPHY_IP_LFR_SEL	0x00600000
+#define BF_USBPHY_IP_LFR_SEL(v)  \
+		(((v) << 21) & BM_USBPHY_IP_LFR_SEL)
+#define BV_USBPHY_IP_LFR_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_LFR_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_LFR_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_LFR_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_CP_SEL	19
+#define BM_USBPHY_IP_CP_SEL	0x00180000
+#define BF_USBPHY_IP_CP_SEL(v)  \
+		(((v) << 19) & BM_USBPHY_IP_CP_SEL)
+#define BV_USBPHY_IP_CP_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_CP_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_CP_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_CP_SEL__UNDEFINED 0x3
+#define BM_USBPHY_IP_TSTI_TX_DP	0x00040000
+#define BM_USBPHY_IP_TSTI_TX_DM	0x00020000
+#define BM_USBPHY_IP_ANALOG_TESTMODE	0x00010000
+#define BP_USBPHY_IP_RSVD0	3
+#define BM_USBPHY_IP_RSVD0	0x0000FFF8
+#define BF_USBPHY_IP_RSVD0(v)  \
+		(((v) << 3) & BM_USBPHY_IP_RSVD0)
+#define BM_USBPHY_IP_EN_USB_CLKS	0x00000004
+#define BM_USBPHY_IP_PLL_LOCKED	0x00000002
+#define BM_USBPHY_IP_PLL_POWER	0x00000001
+#endif /* __ARCH_ARM___USBPHY_H */
diff --git a/arch/arm/plat-mxs/timer-match.c b/arch/arm/plat-mxs/timer-match.c
new file mode 100644
index 0000000..a24c44e
--- /dev/null
+++ b/arch/arm/plat-mxs/timer-match.c
@@ -0,0 +1,164 @@
+/*
+ * System timer for Freescale i.MXS
+ *
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach/time.h>
+
+#include <mach/device.h>
+#include <mach/regs-timrot.h>
+
+static struct mxs_sys_timer *online_timer;
+
+static irqreturn_t mxs_timer_handler(int irq, void *dev_id);
+
+static cycle_t mxs_get_cycles(struct clocksource *cs)
+{
+	return ~__raw_readl(online_timer->base +
+			    HW_TIMROT_RUNNING_COUNTn(online_timer->id));
+}
+
+static int mxs_set_next_event(unsigned long delta,
+			      struct clock_event_device *dev)
+{
+	unsigned int match;
+	match = __raw_readl(online_timer->base +
+			    HW_TIMROT_MATCH_COUNTn(online_timer->id)) - delta;
+	__raw_writel(match, online_timer->base +
+		     HW_TIMROT_MATCH_COUNTn(online_timer->id));
+	return (int)(match -
+		     __raw_readl(online_timer->base +
+				 HW_TIMROT_RUNNING_COUNTn(online_timer->id)))
+	    > 0 ? -ETIME : 0;
+}
+
+
+static void mxs_set_mode(enum clock_event_mode mode,
+			 struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN | BM_TIMROT_TIMCTRLn_IRQ,
+			online_timer->base  + HW_TIMROT_TIMCTRLn_CLR(0));
+	break;
+	case CLOCK_EVT_MODE_RESUME:
+	case CLOCK_EVT_MODE_ONESHOT:
+	__raw_writel(BM_TIMROT_ROTCTRL_SFTRST | BM_TIMROT_ROTCTRL_CLKGATE,
+			online_timer->base  + HW_TIMROT_ROTCTRL_CLR);
+	__raw_writel(BF_TIMROT_TIMCTRLn_SELECT(online_timer->clk_sel) |
+		     BM_TIMROT_TIMCTRLn_IRQ_EN |
+		     BM_TIMROT_TIMCTRLn_MATCH_MODE,
+		     online_timer->base + HW_TIMROT_TIMCTRLn(online_timer->id));
+	break;
+	default:
+	break;
+	}
+}
+
+static struct clock_event_device mxs_clockevent = {
+	.name = "mxs tick timer ",
+	.features = CLOCK_EVT_FEAT_ONESHOT,
+	.shift = 32,
+	.set_next_event = mxs_set_next_event,
+	.set_mode = mxs_set_mode,
+	.rating = 200,
+};
+
+static struct clocksource mxs_clocksource = {
+	.name = "mxs clock source",
+	.rating = 250,
+	.read = mxs_get_cycles,
+	.mask = CLOCKSOURCE_MASK(32),
+	.shift = 10,
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS
+};
+
+static struct irqaction mxs_timer_irq = {
+	.name = "i.MX/mxs Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mxs_timer_handler,
+	.dev_id = &mxs_clockevent,
+};
+
+static int __init mxs_clocksource_init(struct clk *timer_clk)
+{
+	unsigned int c = clk_get_rate(timer_clk);
+
+	mxs_clocksource.mult = clocksource_hz2mult(c, mxs_clocksource.shift);
+	clocksource_register(&mxs_clocksource);
+	return 0;
+}
+
+static int __init mxs_clockevent_init(struct clk *timer_clk)
+{
+	unsigned int c = clk_get_rate(timer_clk);
+
+	mxs_clockevent.mult = div_sc(c, NSEC_PER_SEC, mxs_clockevent.shift);
+	mxs_clockevent.min_delta_ns = clockevent_delta2ns(0xF, &mxs_clockevent);
+	mxs_clockevent.max_delta_ns = clockevent_delta2ns(0xFFFFFFF0,
+							  &mxs_clockevent);
+	mxs_clockevent.cpumask = cpumask_of(0);
+
+	clockevents_register_device(&mxs_clockevent);
+	return 0;
+}
+
+static irqreturn_t mxs_timer_handler(int irq, void *dev_id)
+{
+	struct clock_event_device *c = dev_id;
+	if (__raw_readl(online_timer->base +
+			HW_TIMROT_TIMCTRLn(online_timer->id)) &
+	    BM_TIMROT_TIMCTRLn_IRQ) {
+		__raw_writel(BM_TIMROT_TIMCTRLn_IRQ,
+			     online_timer->base +
+			     HW_TIMROT_TIMCTRLn_CLR(online_timer->id));
+		c->event_handler(c);
+	}
+	return IRQ_HANDLED;
+}
+
+void mxs_timer_init(struct mxs_sys_timer *timer)
+{
+	if (!timer->base || !timer->clk || IS_ERR(timer->clk))
+		return;
+	if (online_timer)
+		return;
+	online_timer = timer;
+	clk_enable(online_timer->clk);
+	__raw_writel(BF_TIMROT_TIMCTRLn_SELECT(online_timer->clk_sel) |
+		     BM_TIMROT_TIMCTRLn_IRQ_EN |
+		     BM_TIMROT_TIMCTRLn_MATCH_MODE,
+		     online_timer->base + HW_TIMROT_TIMCTRLn(online_timer->id));
+	mxs_clocksource_init(online_timer->clk);
+	mxs_clockevent_init(online_timer->clk);
+	setup_irq(online_timer->irq, &mxs_timer_irq);
+}
+
+
diff --git a/arch/arm/plat-mxs/timer-nomatch.c b/arch/arm/plat-mxs/timer-nomatch.c
new file mode 100644
index 0000000..66c488c
--- /dev/null
+++ b/arch/arm/plat-mxs/timer-nomatch.c
@@ -0,0 +1,194 @@
+/*
+ * System timer for Freescale STMP37XX/STMP378X
+ *
+ * Embedded Alley Solutions, Inc <source@embeddedalley.com>
+ *
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/regs-timrot.h>
+
+#ifndef HW_TIMROT_TIMCOUNTn
+#define HW_TIMROT_TIMCOUNTn HW_TIMROT_RUNNING_COUNTn
+#endif
+static struct mxs_sys_timer *online_timer;
+
+static irqreturn_t
+mxs_nomatch_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *c = dev_id;
+
+	/* timer 0 */
+	if (__raw_readl(online_timer->base + HW_TIMROT_TIMCTRLn(0)) &
+			BM_TIMROT_TIMCTRLn_IRQ) {
+
+		__raw_writel(BM_TIMROT_TIMCTRLn_IRQ,
+				online_timer->base + HW_TIMROT_TIMCTRLn_CLR(0));
+		c->event_handler(c);
+	}
+
+	/* timer 1 */
+	else if (__raw_readl(online_timer->base + HW_TIMROT_TIMCTRLn(1))
+			& BM_TIMROT_TIMCTRLn_IRQ) {
+		__raw_writel(BM_TIMROT_TIMCTRLn_IRQ,
+				online_timer->base + HW_TIMROT_TIMCTRLn_CLR(1));
+		__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN,
+				online_timer->base + HW_TIMROT_TIMCTRLn_CLR(1));
+		__raw_writel(0xFFFF,
+				online_timer->base + HW_TIMROT_TIMCOUNTn(1));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static cycle_t mxs_nomatch_clock_read(struct clocksource *cs)
+{
+	return ~((__raw_readl(online_timer->base + HW_TIMROT_TIMCOUNTn(1))
+				& 0xFFFF0000) >> 16);
+}
+
+static int
+mxs_nomatch_timrot_set_next_event(unsigned long delta,
+		struct clock_event_device *dev)
+{
+	/* reload the timer */
+	__raw_writel(delta, online_timer->base + HW_TIMROT_TIMCOUNTn(0));
+	return 0;
+}
+
+static void
+mxs_nomatch_timrot_set_mode(enum clock_event_mode mode,
+		struct clock_event_device *dev)
+{
+}
+
+static struct clock_event_device ckevt_timrot = {
+	.name		= "timrot",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.shift		= 32,
+	.set_next_event	= mxs_nomatch_timrot_set_next_event,
+	.set_mode	= mxs_nomatch_timrot_set_mode,
+};
+
+static struct clocksource cksrc_mxs_nomatch = {
+	.name           = "mxs clock source",
+	.rating         = 250,
+	.read           = mxs_nomatch_clock_read,
+	.mask           = CLOCKSOURCE_MASK(16),
+	.shift          = 10,
+	.flags			= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static struct irqaction mxs_nomatch_timer_irq = {
+	.name		= "mxs_nomatch_timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= mxs_nomatch_timer_interrupt,
+	.dev_id		= &ckevt_timrot,
+};
+
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+void mxs_nomatch_timer_init(struct mxs_sys_timer *timer)
+{
+
+	if (online_timer)
+		return;
+
+	online_timer = timer;
+
+	cksrc_mxs_nomatch.mult = clocksource_hz2mult(CLOCK_TICK_RATE,
+				cksrc_mxs_nomatch.shift);
+	ckevt_timrot.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC,
+				ckevt_timrot.shift);
+	ckevt_timrot.min_delta_ns = clockevent_delta2ns(2, &ckevt_timrot);
+	ckevt_timrot.max_delta_ns = clockevent_delta2ns(0xFFF, &ckevt_timrot);
+	ckevt_timrot.cpumask = cpumask_of(0);
+
+	/* clear two timers */
+	__raw_writel(0, online_timer->base + HW_TIMROT_TIMCOUNTn(0));
+	__raw_writel(0, online_timer->base + HW_TIMROT_TIMCOUNTn(1));
+
+	/* configure them */
+	__raw_writel(
+		(8 << BP_TIMROT_TIMCTRLn_SELECT) |  /* 32 kHz */
+		BM_TIMROT_TIMCTRLn_RELOAD |
+		BM_TIMROT_TIMCTRLn_UPDATE |
+		BM_TIMROT_TIMCTRLn_IRQ_EN,
+			online_timer->base + HW_TIMROT_TIMCTRLn(0));
+	__raw_writel(
+		(8 << BP_TIMROT_TIMCTRLn_SELECT) |  /* 32 kHz */
+		BM_TIMROT_TIMCTRLn_RELOAD |
+		BM_TIMROT_TIMCTRLn_UPDATE |
+		BM_TIMROT_TIMCTRLn_IRQ_EN,
+			online_timer->base + HW_TIMROT_TIMCTRLn(1));
+
+	__raw_writel(CLOCK_TICK_RATE / HZ - 1,
+			online_timer->base + HW_TIMROT_TIMCOUNTn(0));
+	__raw_writel(0xFFFF, online_timer->base + HW_TIMROT_TIMCOUNTn(1));
+
+	setup_irq(IRQ_TIMER0, &mxs_nomatch_timer_irq);
+
+	clocksource_register(&cksrc_mxs_nomatch);
+	clockevents_register_device(&ckevt_timrot);
+}
+
+#ifdef CONFIG_PM
+
+void mxs_nomatch_suspend_timer(void)
+{
+	__raw_writel(BM_TIMROT_TIMCTRLn_IRQ_EN | BM_TIMROT_TIMCTRLn_IRQ,
+			online_timer->base  + HW_TIMROT_TIMCTRLn_CLR(0));
+	__raw_writel(BM_TIMROT_ROTCTRL_CLKGATE,
+			online_timer->base  + HW_TIMROT_ROTCTRL_SET);
+}
+
+void mxs_nomatch_resume_timer(void)
+{
+	__raw_writel(BM_TIMROT_ROTCTRL_SFTRST | BM_TIMROT_ROTCTRL_CLKGATE,
+			online_timer->base  + HW_TIMROT_ROTCTRL_CLR);
+	__raw_writel(
+		8 << BP_TIMROT_TIMCTRLn_SELECT |  /* 32 kHz */
+		BM_TIMROT_TIMCTRLn_RELOAD |
+		BM_TIMROT_TIMCTRLn_UPDATE |
+		BM_TIMROT_TIMCTRLn_IRQ_EN,
+			online_timer->base  + HW_TIMROT_TIMCTRLn(0));
+	__raw_writel(
+		8 << BP_TIMROT_TIMCTRLn_SELECT |  /* 32 kHz */
+		BM_TIMROT_TIMCTRLn_RELOAD |
+		BM_TIMROT_TIMCTRLn_UPDATE |
+		BM_TIMROT_TIMCTRLn_IRQ_EN,
+			online_timer->base  + HW_TIMROT_TIMCTRLn(1));
+	__raw_writel(CLOCK_TICK_RATE / HZ - 1,
+			online_timer->base  + HW_TIMROT_TIMCOUNTn(0));
+	__raw_writel(0xFFFF, online_timer->base  + HW_TIMROT_TIMCOUNTn(1));
+}
+
+#else
+
+#define mxs_nomatch_suspend_timer	NULL
+#define	mxs_nomatch_resume_timer	NULL
+
+#endif	/* CONFIG_PM */
diff --git a/arch/arm/plat-mxs/unique-id.c b/arch/arm/plat-mxs/unique-id.c
new file mode 100644
index 0000000..35c0fcd
--- /dev/null
+++ b/arch/arm/plat-mxs/unique-id.c
@@ -0,0 +1,198 @@
+/*
+ * Unique ID manipulation sysfs access generic functions
+ *
+ * Author: dmitry pervushin <dimka@embeddedalley.com>
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+
+#include <mach/unique-id.h>
+
+static int unlock;
+static spinlock_t u_lock;
+static const unsigned long UID_AUTOLOCK_TIMEOUT = HZ * 60 * 3;
+static struct timer_list u_timer;
+
+static void uid_timer_autolock(unsigned long param)
+{
+	struct timer_list *tmr = (struct timer_list *)param;
+
+	if (spin_trylock(&u_lock)) {
+		if (unlock)
+			pr_debug("%s: locked down.\n", __func__);
+		unlock = 0;
+		spin_unlock(&u_lock);
+	}
+	mod_timer(tmr, jiffies + UID_AUTOLOCK_TIMEOUT);
+}
+
+static LIST_HEAD(uid_provider_list);
+
+struct uid_provider {
+	struct kobject 	*kobj;
+	struct list_head list;
+	struct uid_ops  *ops;
+	void *context;
+};
+
+static struct uid_provider *uid_provider_find(const char *name);
+
+#define UID_FWD_SYSFS_FILE(var, file, param) \
+	static ssize_t var##_show(struct kobject *kobj, 		\
+			struct kobj_attribute *attr, char *buf) 	\
+	{								\
+		struct uid_provider *p = 				\
+			uid_provider_find(kobject_name(kobj));		\
+		ssize_t r;						\
+		BUG_ON(p == NULL);					\
+		r = (p->ops && p->ops->file##_show) ? 			\
+			p->ops->file##_show(p->context, buf, param) : 0;\
+		return r;						\
+	}								\
+									\
+	static ssize_t var##_store(struct kobject *kobj, 		\
+		struct kobj_attribute *attr, const char *buf, 		\
+			size_t count)					\
+	{								\
+		struct uid_provider *p =				\
+			uid_provider_find(kobject_name(kobj));		\
+		ssize_t r;						\
+		int ul;							\
+		BUG_ON(p == NULL);					\
+		spin_lock(&u_lock);					\
+		ul = unlock;						\
+		spin_unlock(&u_lock);					\
+		if (ul) 						\
+			r =  (p->ops && p->ops->file##_store) ? 	\
+		    p->ops->file##_store(p->context, buf, count, param) \
+				: count;				\
+		else							\
+			r = -EACCES;					\
+		return r;						\
+	}
+
+struct kobject *uid_kobj;
+
+#define UID_ATTR(_name, _varname) \
+	static struct kobj_attribute _varname##_attr = \
+		__ATTR(_name, 0644, _varname##_show, _varname##_store)
+
+UID_FWD_SYSFS_FILE(id, id, 1);
+UID_FWD_SYSFS_FILE(id_bin, id, 0);
+UID_ATTR(id, id);
+UID_ATTR(id.bin, id_bin);
+
+static struct attribute *uid_attrs[] = {
+	&id_attr.attr,
+	&id_bin_attr.attr,
+	NULL
+};
+
+static struct attribute_group uid_attr_group = {
+	.attrs = uid_attrs,
+};
+
+struct kobject *uid_provider_init(const char *name,
+			struct uid_ops *ops, void *context)
+{
+	struct uid_provider *new;
+	int err;
+
+	new = kzalloc(sizeof(*new), GFP_KERNEL);
+	if (!new) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	new->kobj = kobject_create_and_add(name, uid_kobj);
+	if (!new->kobj) {
+		err = -ENOMEM;
+		goto out;
+	}
+	new->ops = ops;
+	new->context = context;
+
+	err = sysfs_create_group(new->kobj, &uid_attr_group);
+	if (err)
+		goto out2;
+
+	list_add_tail(&new->list, &uid_provider_list);
+	return new->kobj;
+out2:
+	kobject_del(new->kobj);
+out:
+	kfree(new);
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(uid_provider_init);
+
+static struct uid_provider *uid_provider_find(const char *name)
+{
+	struct uid_provider *p;
+
+	list_for_each_entry(p, &uid_provider_list, list) {
+		if (strcmp(kobject_name(p->kobj), name) == 0)
+			return p;
+	}
+	return NULL;
+}
+
+void uid_provider_remove(const char *name)
+{
+	struct uid_provider *p;
+
+	p = uid_provider_find(name);
+	if (!p)
+		return;
+	kobject_del(p->kobj);
+	list_del(&p->list);
+	kfree(p);
+}
+EXPORT_SYMBOL_GPL(uid_provider_remove);
+
+static int uid_sysfs_init(void)
+{
+	int error;
+
+	uid_kobj = kobject_create_and_add("uid", NULL);
+	if (!uid_kobj) {
+		error = -ENOMEM;
+		goto out1;
+	}
+
+	spin_lock_init(&u_lock);
+	setup_timer(&u_timer, uid_timer_autolock, (unsigned long)&u_timer);
+
+	/* try to lock each 3 minutes */
+	mod_timer(&u_timer, jiffies + UID_AUTOLOCK_TIMEOUT);
+	return 0;
+
+out1:
+	printk(KERN_ERR"%s failed, error %d.", __func__, error);
+	return error;
+}
+
+module_param(unlock, int, 0600)
+core_initcall(uid_sysfs_init);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("dmitry pervushin <dimka@embeddedalley.com>");
+MODULE_DESCRIPTION("Unique ID simple framework");
diff --git a/arch/arm/plat-mxs/usb_common.c b/arch/arm/plat-mxs/usb_common.c
new file mode 100644
index 0000000..fa94660
--- /dev/null
+++ b/arch/arm/plat-mxs/usb_common.c
@@ -0,0 +1,381 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <linux/io.h>
+#include "regs-usbphy.h"
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+void fsl_platform_set_test_mode(
+				struct fsl_usb2_platform_data *pdata,
+				enum usb_test_mode mode)
+{
+}
+EXPORT_SYMBOL(fsl_platform_set_test_mode);
+
+/* enable/disable high-speed disconnect detector of phy ctrl */
+void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+				  bool enable)
+{
+	if (enable)
+		__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+			IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL_SET);
+	else
+		__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+			IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL_CLR);
+}
+EXPORT_SYMBOL(fsl_platform_set_usb_phy_dis);
+
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+static struct resource *otg_resources;
+
+struct resource *otg_get_resources(void)
+{
+	pr_debug("otg_get_resources\n");
+	return otg_resources;
+}
+EXPORT_SYMBOL(otg_get_resources);
+
+int otg_set_resources(struct resource *resources)
+{
+	otg_resources = resources;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_resources);
+#endif
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	if (name == NULL) {
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0)
+			return g_xc_ops[i];
+	}
+	pr_debug("Failed %s\n", __func__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+static int instance_id = ~(u32) 0;
+struct platform_device *host_pdev_register(struct resource *res, int n_res,
+						struct fsl_usb2_platform_data
+						*config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	pr_debug(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	instance_id++;
+
+	return pdev;
+}
+
+int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
+{
+	u32 tmp;
+	void __iomem *phy_reg = IO_ADDRESS(pdata->phy_regs);
+	void __iomem *usb_reg = pdata->regs;
+	void __iomem *usbcmd, *phy_ctrl, *portsc;
+
+	/* Reset USB IP */
+	usbcmd = usb_reg + UOG_USBCMD;
+	tmp = __raw_readl(usbcmd); /* usb command */
+	tmp &= ~UCMD_RUN_STOP;
+	__raw_writel(tmp, usbcmd);
+	while (__raw_readl(usbcmd) & UCMD_RUN_STOP)
+		;
+
+	tmp |= UCMD_RESET;
+	__raw_writel(tmp, usbcmd);
+	while (__raw_readl(usbcmd) & UCMD_RESET)
+		;
+	mdelay(10);
+
+	/* Reset USBPHY module */
+	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
+	tmp = __raw_readl(phy_ctrl);
+	tmp |= BM_USBPHY_CTRL_SFTRST;
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	tmp = __raw_readl(phy_ctrl);
+	tmp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* set UTMI xcvr */
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	portsc = usb_reg + UOG_PORTSC1;
+	tmp = __raw_readl(portsc);
+	tmp &=  ~PORTSC_PTS_MASK;
+	tmp |= (PORTSC_PTS_UTMI | PORTSC_PTW);
+	__raw_writel(tmp, portsc);
+
+	/* Power up the PHY */
+	__raw_writel(0, phy_reg + HW_USBPHY_PWD);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_phy_enable);
+
+static int otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+	u32 tmp;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "DR transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	otg_used = 0;
+	if (!otg_used) {
+		pr_debug("%s: grab pins\n", __func__);
+		if (xops->init)
+			xops->init(xops);
+		usb_phy_enable(pdata);
+	}
+	/* Enable internal Phy clock */
+	tmp = __raw_readl(pdata->regs + UOG_PORTSC1);
+	tmp &= ~PORTSC_PHCD;
+	__raw_writel(tmp, pdata->regs + UOG_PORTSC1);
+
+	if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+		/* enable FS/LS device */
+		tmp = __raw_readl(IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL);
+		tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 |
+			BM_USBPHY_CTRL_ENUTMILEVEL3);
+		__raw_writel(tmp, IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL);
+	}
+
+	otg_used++;
+	pr_debug("%s: success\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	int tmp;
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	/* Disable internal Phy clock */
+	tmp = __raw_readl(pdata->regs + UOG_PORTSC1);
+	tmp |= PORTSC_PHCD;
+	__raw_writel(tmp, pdata->regs + UOG_PORTSC1);
+
+	pdata->regs = NULL;
+	otg_used--;
+}
+EXPORT_SYMBOL(usbotg_uninit);
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+	u32 tmp;
+	void __iomem *phy_reg = IO_ADDRESS(pdata->phy_regs);
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (xops->init)
+		xops->init(xops);
+	usb_phy_enable(pdata);
+	/* enable FS/LS device */
+	tmp = __raw_readl(phy_reg + HW_USBPHY_CTRL);
+	tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3);
+	__raw_writel(tmp, phy_reg + HW_USBPHY_CTRL);
+
+	pr_debug("%s: %s success\n", __func__, pdata->name);
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+}
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+int usb_host_wakeup_irq(struct device *wkup_dev)
+{
+	return 0;
+}
+EXPORT_SYMBOL(usb_host_wakeup_irq);
+
+void usb_host_set_wakeup(struct device *wkup_dev, bool para)
+{
+}
+EXPORT_SYMBOL(usb_host_set_wakeup);
+
+#ifdef CONFIG_ARCH_MX28
+#define USBPHY_PHYS_ADDR USBPHY0_PHYS_ADDR
+#endif
+
+int fsl_is_usb_plugged(void)
+{
+	return __raw_readl(IO_ADDRESS(USBPHY_PHYS_ADDR) + HW_USBPHY_STATUS) & \
+		BM_USBPHY_STATUS_DEVPLUGIN_STATUS;
+}
+EXPORT_SYMBOL(fsl_is_usb_plugged);
+
+void fsl_enable_usb_plugindetect(void)
+{
+	__raw_writel(BM_USBPHY_CTRL_ENDEVPLUGINDETECT,
+			IO_ADDRESS(USBPHY_PHYS_ADDR) + HW_USBPHY_CTRL_SET);
+}
+EXPORT_SYMBOL(fsl_enable_usb_plugindetect);
+
diff --git a/arch/arm/plat-mxs/utmixc.c b/arch/arm/plat-mxs/utmixc.c
new file mode 100644
index 0000000..8ad6bd4
--- /dev/null
+++ b/arch/arm/plat-mxs/utmixc.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/pmic_external.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+extern void fsl_phy_usb_utmi_init(struct fsl_xcvr_ops *this);
+extern void fsl_phy_usb_utmi_uninit(struct fsl_xcvr_ops *this);
+extern void fsl_phy_set_power(struct fsl_xcvr_ops *this,
+			struct fsl_usb2_platform_data *pdata, int on);
+#include <mach/regs-power.h>
+#include <asm/io.h>
+
+
+static void set_vbus_draw(struct fsl_xcvr_ops *this,
+		struct fsl_usb2_platform_data *pdata, unsigned mA)
+{
+#ifdef CONFIG_MXS_VBUS_CURRENT_DRAW
+	if ((__raw_readl(REGS_POWER_BASE + HW_POWER_5VCTRL)
+		& BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT) == 0x20000) {
+		printk(KERN_INFO "USB enumeration done,current limitation release\r\n");
+		__raw_writel(__raw_readl(REGS_POWER_BASE + HW_POWER_5VCTRL) |
+		BM_POWER_5VCTRL_CHARGE_4P2_ILIMIT, REGS_POWER_BASE +
+		HW_POWER_5VCTRL);
+	}
+#endif
+}
+static struct fsl_xcvr_ops utmi_ops = {
+	.name = "utmi",
+	.xcvr_type = PORTSC_PTS_UTMI,
+	.init = fsl_phy_usb_utmi_init,
+	.uninit = fsl_phy_usb_utmi_uninit,
+	.set_vbus_power = fsl_phy_set_power,
+	.set_vbus_draw = set_vbus_draw,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init utmixc_init(void)
+{
+	fsl_usb_xcvr_register(&utmi_ops);
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit utmixc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&utmi_ops);
+}
+
+#ifdef CONFIG_MXS_VBUS_CURRENT_DRAW
+	fs_initcall(utmixc_init);
+#else
+	module_init(utmixc_init);
+#endif
+module_exit(utmixc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("utmi xcvr driver");
+MODULE_LICENSE("GPL");
-- 
1.5.4.4

