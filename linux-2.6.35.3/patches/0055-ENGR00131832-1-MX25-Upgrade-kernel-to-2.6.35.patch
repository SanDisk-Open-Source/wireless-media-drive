From 0ddaf3bc72ff1b9540ca47aa030b885107dc52c6 Mon Sep 17 00:00:00 2001
From: Alan Tull <r80115@freescale.com>
Date: Thu, 23 Sep 2010 14:17:05 -0500
Subject: [PATCH] ENGR00131832-1 MX25: Upgrade kernel to 2.6.35

This patch contains changes to mach-mx25 files.
Contains all checkpatch and copyright fixes.

Signed-off-by: Alan Tull <r80115@freescale.com>
---
 arch/arm/configs/imx25_3stack_defconfig       | 1933 +++++++++++++++++++++++++
 arch/arm/configs/imx25_updater_defconfig      | 1608 ++++++++++++++++++++
 arch/arm/mach-mx25/Kconfig                    |   75 +
 arch/arm/mach-mx25/Makefile                   |   16 +-
 arch/arm/mach-mx25/board-mx25_3stack.h        |  175 +++
 arch/arm/mach-mx25/bus_freq.c                 |  102 ++
 arch/arm/mach-mx25/clock.c                    | 1662 +++++++++++++++++++++-
 arch/arm/mach-mx25/cpu.c                      |   63 +
 arch/arm/mach-mx25/crm_regs.h                 |  249 ++++
 arch/arm/mach-mx25/devices.c                  |  279 ++++
 arch/arm/mach-mx25/dma.c                      |  663 +++++++++
 arch/arm/mach-mx25/iomux.c                    |  199 +++
 arch/arm/mach-mx25/iomux.h                    |  233 +++
 arch/arm/mach-mx25/mm.c                       |    2 +-
 arch/arm/mach-mx25/mx25_3stack.c              |  846 +++++++++++
 arch/arm/mach-mx25/mx25_3stack_cpld.c         |  247 ++++
 arch/arm/mach-mx25/mx25_3stack_gpio.c         | 1367 +++++++++++++++++
 arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c |  147 ++
 arch/arm/mach-mx25/mx25_pins.h                |  250 ++++
 arch/arm/mach-mx25/pm.c                       |  103 ++
 arch/arm/mach-mx25/sdma_script_code.h         |  158 ++
 arch/arm/mach-mx25/serial.c                   |  332 +++++
 arch/arm/mach-mx25/serial.h                   |  148 ++
 arch/arm/mach-mx25/system.c                   |  159 ++
 arch/arm/mach-mx25/usb.h                      |  103 ++
 arch/arm/mach-mx25/usb_dr.c                   |  122 ++
 arch/arm/mach-mx25/usb_h2.c                   |   88 ++
 arch/arm/plat-mxc/Makefile                    |    4 +-
 arch/arm/plat-mxc/cpu_common.c                |   27 +-
 arch/arm/plat-mxc/include/mach/mx25.h         |  246 ++++-
 arch/arm/plat-mxc/include/mach/mxc.h          |    2 +-
 31 files changed, 11586 insertions(+), 22 deletions(-)

diff --git a/arch/arm/configs/imx25_3stack_defconfig b/arch/arm/configs/imx25_3stack_defconfig
new file mode 100644
index 0000000..4b72242
--- /dev/null
+++ b/arch/arm/configs/imx25_3stack_defconfig
@@ -0,0 +1,1933 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Mon Nov  2 15:32:48 2009
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_DMA_ZONE_SIZE=24
+CONFIG_UTMI_MXC=y
+CONFIG_UTMI_MXC_OTG=m
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+CONFIG_ARCH_MX25=y
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX37 is not set
+# CONFIG_ARCH_MX51 is not set
+CONFIG_MXC_SDMA_API=y
+CONFIG_SDMA_IRAM=y
+CONFIG_SDMA_IRAM_SIZE=0x1000
+CONFIG_ARCH_MXC_HAS_NFC_V2=y
+CONFIG_I2C_MXC_SELECT1=y
+# CONFIG_I2C_MXC_SELECT2 is not set
+# CONFIG_I2C_MXC_SELECT3 is not set
+
+#
+# MX25 Options
+#
+CONFIG_MX25_OPTIONS=y
+CONFIG_MACH_MX25_3DS=y
+# CONFIG_MX25_DOZE_DURING_IDLE is not set
+
+#
+# SDMA options
+#
+CONFIG_ARCH_MXC_HAS_NFC_V2_1=y
+
+#
+# Device options
+#
+# CONFIG_FLEXCAN_MXC_SELECT1 is not set
+# CONFIG_MXC_IRQ_PRIOR is not set
+# CONFIG_MXC_PWM is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_IMX=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+# CONFIG_CAN_BCM is not set
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_DEV is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+CONFIG_CAN_FLEXCAN=y
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+# CONFIG_KINGSUN_DONGLE is not set
+# CONFIG_KSDAZZLE_DONGLE is not set
+# CONFIG_KS959_DONGLE is not set
+
+#
+# FIR device drivers
+#
+# CONFIG_USB_IRDA is not set
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_MCS_FIR is not set
+# CONFIG_MXC_FIR is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_IMX_NFC is not set
+CONFIG_MTD_NAND_MXC_V2=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_FEC is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_PLUSB is not set
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_IMX_ADC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_MXC_IIM=y
+CONFIG_IMX_SIM=m
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_IMX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_IMX is not set
+CONFIG_I2C_MXC=y
+# CONFIG_I2C_MXC_HS is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_MXC_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXC_CAMERA=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+# CONFIG_MXC_CAMERA_MC521DA is not set
+# CONFIG_MXC_EMMA_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640_EMMA is not set
+# CONFIG_MXC_CAMERA_MICRON111 is not set
+CONFIG_MXC_CAMERA_OV2640=m
+# CONFIG_MXC_CAMERA_OV3640 is not set
+# CONFIG_MXC_TVIN_ADV7180 is not set
+# CONFIG_VIDEO_MXC_OUTPUT is not set
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+# CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_CH7026 is not set
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_LCDC=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_MXC_SPDIF is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_MXC_SOC=y
+CONFIG_SND_MXC_SOC_SSI=y
+CONFIG_SND_MXC_SOC_ESAI=m
+CONFIG_SND_MXC_SOC_IRAM=y
+CONFIG_SND_SOC_IMX_3STACK_SGTL5000=y
+# CONFIG_SND_SOC_IMX_3STACK_AK4647 is not set
+CONFIG_SND_SOC_IMX_3STACK_WM8580=m
+CONFIG_SND_SOC_IMX_3STACK_AK5702=m
+# CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_AK5702=m
+CONFIG_SND_SOC_WM8580=m
+CONFIG_SND_SOC_SGTL5000=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KYE is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_KENSINGTON is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H2=y
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_STATIC_IRAM is not set
+# CONFIG_USB_EHCI_FSL_MC13783 is not set
+# CONFIG_USB_EHCI_FSL_1301 is not set
+# CONFIG_USB_EHCI_FSL_1504 is not set
+CONFIG_USB_EHCI_FSL_UTMI=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_STATIC_IRAM_PPH=y
+CONFIG_USB_ARC=m
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_ARC_OTG=y
+# CONFIG_USB_GADGET_FSL_MC13783 is not set
+# CONFIG_USB_GADGET_FSL_1301 is not set
+# CONFIG_USB_GADGET_FSL_1504 is not set
+CONFIG_USB_GADGET_FSL_UTMI=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_IMX_ESDHCI=y
+# CONFIG_MMC_IMX_ESDHCI_SELECT2 is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+CONFIG_RTC_DRV_IMXDI=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MC34704=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# MXC support drivers
+#
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_MC13783 is not set
+# CONFIG_MXC_PMIC_MC13892 is not set
+CONFIG_MXC_PMIC_MC34704=y
+# CONFIG_MXC_PMIC_MC9SDZ60 is not set
+CONFIG_MXC_PMIC_CHARDEV=y
+
+#
+# MXC PMIC Client Drivers
+#
+# CONFIG_MXC_PMIC_MC9S08DZ60 is not set
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+# CONFIG_MXC_DRYICE is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+
+#
+# Broadcom GPS ioctrl support
+#
+
+#
+# MXC Media Local Bus Driver
+#
+
+#
+# i.MX ADC support
+#
+CONFIG_IMX_ADC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/configs/imx25_updater_defconfig b/arch/arm/configs/imx25_updater_defconfig
new file mode 100644
index 0000000..5821299
--- /dev/null
+++ b/arch/arm/configs/imx25_updater_defconfig
@@ -0,0 +1,1608 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION="-updater"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_OPROFILE=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=24
+CONFIG_UTMI_MXC=y
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+CONFIG_ARCH_MX25=y
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX37 is not set
+# CONFIG_ARCH_MX51 is not set
+CONFIG_MXC_SDMA_API=y
+CONFIG_SDMA_IRAM=y
+CONFIG_ARCH_MXC_HAS_NFC_V2=y
+CONFIG_I2C_MXC_SELECT1=y
+# CONFIG_I2C_MXC_SELECT2 is not set
+# CONFIG_I2C_MXC_SELECT3 is not set
+
+#
+# MX25 Options
+#
+CONFIG_MX25_OPTIONS=y
+CONFIG_MACH_MX25_3DS=y
+# CONFIG_MX25_DOZE_DURING_IDLE is not set
+CONFIG_ARCH_MXC_HAS_NFC_V2_1=y
+
+#
+# Device options
+#
+CONFIG_ISP1504_MXC=y
+# CONFIG_MXC_IRQ_PRIOR is not set
+# CONFIG_MXC_PWM is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttymxc0,115200 rdinit=/linuxrc"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_IMX=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_XIP is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MXC_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_IMX_NFC is not set
+CONFIG_MTD_NAND_MXC_V2=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_IMX_ADC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_MXC_IIM=y
+CONFIG_IMX_SIM=m
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_IMX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_IMX is not set
+CONFIG_I2C_MXC=y
+# CONFIG_I2C_MXC_HS is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_MEDIA_TUNER_MC44S803=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXC_CAMERA=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+# CONFIG_MXC_CAMERA_MC521DA is not set
+# CONFIG_MXC_EMMA_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640_EMMA is not set
+# CONFIG_MXC_CAMERA_MICRON111 is not set
+CONFIG_MXC_CAMERA_OV2640=m
+# CONFIG_MXC_CAMERA_OV3640 is not set
+# CONFIG_MXC_TVIN_ADV7180 is not set
+# CONFIG_VIDEO_MXC_OUTPUT is not set
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+# CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_CH7026 is not set
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_LCDC=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KYE is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_KENSINGTON is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H2=y
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_STATIC_IRAM is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_STATIC_IRAM_PPH=y
+CONFIG_USB_ARC=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_FSL_UTP=y
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MXC_OTG is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_IMX_ESDHCI=y
+# CONFIG_MMC_IMX_ESDHCI_SELECT2 is not set
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+CONFIG_RTC_DRV_IMXDI=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MC34704=y
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+
+#
+# MXC support drivers
+#
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_MC13783 is not set
+# CONFIG_MXC_PMIC_MC13892 is not set
+CONFIG_MXC_PMIC_MC34704=y
+# CONFIG_MXC_PMIC_MC9SDZ60 is not set
+CONFIG_MXC_PMIC_CHARDEV=y
+
+#
+# MXC PMIC Client Drivers
+#
+# CONFIG_MXC_PMIC_MC9S08DZ60 is not set
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+# CONFIG_MXC_DRYICE is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+
+#
+# Broadcom GPS ioctrl support
+#
+
+#
+# MXC Media Local Bus Driver
+#
+
+#
+# i.MX ADC support
+#
+CONFIG_IMX_ADC=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx25/Kconfig b/arch/arm/mach-mx25/Kconfig
index 54d2173..95f966a 100644
--- a/arch/arm/mach-mx25/Kconfig
+++ b/arch/arm/mach-mx25/Kconfig
@@ -5,4 +5,79 @@ comment "MX25 platforms:"
 config MACH_MX25_3DS
 	bool "Support MX25PDK (3DS) Platform"
 
+menu "MX25 Options"
+
+config MX25_OPTIONS
+	bool
+	default y
+	select CPU_ARM926T
+	select USB_ARCH_HAS_EHCI
+
+config MX25_DOZE_DURING_IDLE
+	bool "Enter Doze mode during idle"
+	help
+	  Turning on this option will put the CPU into Doze mode during idle.
+	  The default is to enter Wait mode during idle. Doze mode during
+	  idle will save additional power over Wait mode.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA transfer"
+	depends on MXC_SDMA_API
+	help
+	  Support Internal RAM as SDMA buffer or control structures
+
+config ARCH_MXC_HAS_NFC_V2
+        bool "MXC NFC Hardware Version 2"
+        depends on ARCH_MX25
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V2_1
+        bool "MXC NFC Hardware Version 2.1"
+        depends on ARCH_MXC_HAS_NFC_V2
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2.1
+           If unsure, say N.
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C3 module.
+
+config FLEXCAN_MXC_SELECT1
+	bool "Enable FlexCAN1 module"
+	depends on CAN_FLEXCAN
+	help
+	  Enable MX25 FlexCAN1 module.
+
+endmenu
+endmenu
 endif
diff --git a/arch/arm/mach-mx25/Makefile b/arch/arm/mach-mx25/Makefile
index 10cebc5..93e835c 100644
--- a/arch/arm/mach-mx25/Makefile
+++ b/arch/arm/mach-mx25/Makefile
@@ -1,3 +1,13 @@
-obj-y				:= mm.o devices.o
-obj-$(CONFIG_ARCH_MX25)		+= clock.o
-obj-$(CONFIG_MACH_MX25_3DS)	+= mach-mx25pdk.o
+obj-y		:= system.o iomux.o cpu.o mm.o clock.o bus_freq.o devices.o serial.o
+
+obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
+obj-$(CONFIG_SPI_MXC)		+= mx25_3stack_cpld.o
+obj-$(CONFIG_MACH_MX25_3DS)	+= mx25_3stack.o mx25_3stack_gpio.o mx25_3stack_pmic_mc34704.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H2)	+= usb_h2.o
+
+obj-$(CONFIG_PM)		+= pm.o
+
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y	+= usb_dr.o
+endif
diff --git a/arch/arm/mach-mx25/board-mx25_3stack.h b/arch/arm/mach-mx25/board-mx25_3stack.h
new file mode 100644
index 0000000..ec2f9e9
--- /dev/null
+++ b/arch/arm/mach-mx25/board-mx25_3stack.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+
+#ifdef CONFIG_MACH_MX25_3DS
+
+/*!
+ * @defgroup BRDCFG_MX25 Board Configuration Options
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * @file mach-mx25/board-mx25_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX25 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX25
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+#include <linux/fsl_devices.h>
+
+/*!
+ * @name MXC UART board-level configurations
+ */
+/*! @{ */
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           0
+
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0
+
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name debug board parameters
+ */
+/*! @{ */
+/*!
+ * Base address of debug board
+ */
+#define DEBUG_BASE_ADDRESS      0x78000000	/* Use a dummy base address */
+
+/* External ethernet LAN9217 base address */
+#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
+
+/* External UART */
+#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x08000)
+#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		0x20000
+
+/* LED switchs */
+#define LED_SWITCH_REG		(BOARD_IO_ADDR + 0x00)
+/* buttons */
+#define SWITCH_BUTTON_REG	(BOARD_IO_ADDR + 0x08)
+/* status, interrupt */
+#define INTR_STATUS_REG		(BOARD_IO_ADDR + 0x10)
+#define INTR_RESET_REG		(BOARD_IO_ADDR + 0x20)
+/*CPLD configuration*/
+#define CONFIG1_REG		(BOARD_IO_ADDR + 0x28)
+#define CONFIG2_REG		(BOARD_IO_ADDR + 0x30)
+/*interrupt mask */
+#define INTR_MASK_REG		(BOARD_IO_ADDR + 0x38)
+
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	(BOARD_IO_ADDR + 0x40)
+#define	MAGIC_NUMBER2_REG	(BOARD_IO_ADDR + 0x48)
+/* CPLD code version */
+#define CPLD_CODE_VER_REG       (BOARD_IO_ADDR + 0x50)
+/* magic word for debug CPLD */
+#define MAGIC3_NUMBER3_REG	(BOARD_IO_ADDR + 0x58)
+/* module reset register*/
+#define CONTROL_REG		(BOARD_IO_ADDR + 0x60)
+/* CPU ID and Personality ID*/
+#define IDENT_REG		(BOARD_IO_ADDR + 0x68)
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        MX25_PIN_GPIO1_1
+
+#define EXPIO_INT_ENET_INT          (MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUARTA_INT        (MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUARTB_INT        (MXC_BOARD_IRQ_START + 2)
+
+/*! This is System IRQ used by LAN9217 for interrupt generation taken
+ * from platform.h
+ */
+#define LAN9217_IRQ              EXPIO_INT_ENET_INT
+
+/*! This is base virtual address of debug board*/
+extern unsigned int mx25_3stack_board_io;
+
+#define MXC_BD_LED1             (1 << 0)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED5             (1 << 4)
+#define MXC_BD_LED6             (1 << 5)
+#define MXC_BD_LED7             (1 << 6)
+#define MXC_BD_LED8             (1 << 7)
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+#define MXC_DEFAULT_INTENSITY	127
+#define MXC_INTENSITY_OFF	0
+
+/*! @} */
+
+extern void mx25_3stack_gpio_init(void) __init;
+extern int headphone_det_status(void);
+extern void sgtl5000_enable_amp(void);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_write_protect(struct device *dev);
+extern void gpio_can_active(int id);
+extern void gpio_can_inactive(int id);
+extern struct flexcan_platform_data flexcan_data[];
+extern void mx2fb_set_brightness(uint8_t);
+extern int __init mx25_3stack_init_mc34704(void);
+extern void imx_adc_set_hsync(int on);
+
+#endif				/* CONFIG_MACH_MX25_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__ */
diff --git a/arch/arm/mach-mx25/bus_freq.c b/arch/arm/mach-mx25/bus_freq.c
new file mode 100644
index 0000000..9c98e9f
--- /dev/null
+++ b/arch/arm/mach-mx25/bus_freq.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+char *gp_reg_id = "REG3_CORE";
+
+int set_low_bus_freq(void)
+{
+	return 0;
+}
+
+int set_high_bus_freq(int high_bus_freq)
+{
+	return 0;
+}
+
+int low_freq_bus_used(void)
+{
+	return 0;
+}
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		   },
+	.probe = busfreq_probe,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx25/clock.c b/arch/arm/mach-mx25/clock.c
index 1550149..5a52e30 100644
--- a/arch/arm/mach-mx25/clock.c
+++ b/arch/arm/mach-mx25/clock.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 by Sascha Hauer, Pengutronix
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,6 +17,8 @@
  * MA 02110-1301, USA.
  */
 
+#include <linux/module.h>
+#include <linux/spinlock.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/list.h>
@@ -28,6 +31,7 @@
 #include <mach/hardware.h>
 #include <mach/common.h>
 #include <mach/mx25.h>
+#include "crm_regs.h"
 
 #define CRM_BASE	MX25_IO_ADDRESS(MX25_CRM_BASE_ADDR)
 
@@ -52,6 +56,1515 @@
 #define CCM_LTR2	0x48
 #define CCM_LTR3	0x4c
 
+#define OSC24M_CLK_FREQ     24000000	/* 24M reference clk */
+#define OSC32K_CLK_FREQ     32768	/* 32.768k oscillator in */
+
+#if defined CONFIG_CPU_FREQ_IMX
+#define AHB_CLK_DEFAULT 133000000
+#define ARM_SRC_DEFAULT 532000000
+#endif
+
+static struct clk mpll_clk;
+static struct clk upll_clk;
+static struct clk ahb_clk;
+static struct clk upll_24610k_clk;
+int cpu_wp_nr;
+
+static int clk_cgcr_enable(struct clk *clk);
+static void clk_cgcr_disable(struct clk *clk);
+static unsigned long get_rate_ipg(struct clk *clk);
+
+static int _clk_upll_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg &= ~MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
+
+	while ((__raw_readl(MXC_CCM_UPCTL) & MXC_CCM_UPCTL_LF) == 0)
+		;
+
+	return 0;
+}
+
+static void _clk_upll_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg |= MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
+}
+
+static int _perclk_enable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg |= 1 << clk->id;
+	__raw_writel(reg, MXC_CCM_CGCR0);
+
+	return 0;
+}
+
+static void _perclk_disable(struct clk *clk)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg &= ~(1 << clk->id);
+	__raw_writel(reg, MXC_CCM_CGCR0);
+}
+
+static unsigned long _clk_osc24m_get_rate(struct clk *clk)
+{
+	return OSC24M_CLK_FREQ;
+}
+
+static unsigned long _clk_osc32k_get_rate(struct clk *clk)
+{
+	return OSC32K_CLK_FREQ;
+}
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk;
+	unsigned long reg;
+	unsigned long long temp;
+
+	ref_clk = clk_get_rate(clk->parent);
+
+	if (clk == &mpll_clk) {
+		reg = __raw_readl(MXC_CCM_MPCTL);
+		pdf = (reg & MXC_CCM_MPCTL_PD_MASK) >> MXC_CCM_MPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_MPCTL_MFD_MASK) >> MXC_CCM_MPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_MPCTL_MFI_MASK) >> MXC_CCM_MPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_MPCTL_MFN_MASK) >> MXC_CCM_MPCTL_MFN_OFFSET;
+	} else if (clk == &upll_clk) {
+		reg = __raw_readl(MXC_CCM_UPCTL);
+		pdf = (reg & MXC_CCM_UPCTL_PD_MASK) >> MXC_CCM_UPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_UPCTL_MFD_MASK) >> MXC_CCM_UPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_UPCTL_MFI_MASK) >> MXC_CCM_UPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_UPCTL_MFN_MASK) >> MXC_CCM_UPCTL_MFN_OFFSET;
+	} else {
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return temp;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	int div = clk_get_rate(clk->parent) / rate;
+
+	if (clk_get_rate(clk->parent) % rate)
+		div++;
+
+	if (div > 4)
+		div = 4;
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div = 0x0, reg = 0x0;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+#if defined CONFIG_CPU_FREQ_IMX
+	struct cpu_wp *cpu_wp;
+	unsigned long ahb_clk_div = 0;
+	unsigned long arm_src = 0;
+	int i;
+
+	cpu_wp = get_cpu_wp(&cpu_wp_nr);
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (cpu_wp[i].cpu_rate == rate) {
+			div = cpu_wp[i].cpu_podf;
+			ahb_clk_div = cpu_wp[i].cpu_rate / AHB_CLK_DEFAULT - 1;
+			arm_src =
+			    (cpu_wp[i].pll_rate == ARM_SRC_DEFAULT) ? 0 : 1;
+			break;
+		}
+	}
+	if (i == cpu_wp_nr)
+		return -EINVAL;
+	reg = (cctl & ~MXC_CCM_CCTL_ARM_MASK) |
+	    (div << MXC_CCM_CCTL_ARM_OFFSET);
+	reg = (reg & ~MXC_CCM_CCTL_AHB_MASK) |
+	    (ahb_clk_div << MXC_CCM_CCTL_AHB_OFFSET);
+	reg = (reg & ~MXC_CCM_CCTL_ARM_SRC) |
+	    (arm_src << MXC_CCM_CCTL_ARM_SRC_OFFSET);
+	__raw_writel(reg, MXC_CCM_CCTL);
+#else
+	div = clk_get_rate(clk->parent) / rate;
+
+	if (div > 4 || div < 1 || ((clk_get_rate(clk->parent) / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    (cctl & ~MXC_CCM_CCTL_ARM_MASK) | (div << MXC_CCM_CCTL_ARM_OFFSET);
+	__raw_writel(reg, MXC_CCM_CCTL);
+#endif
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_get_rate(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+	unsigned long rate;
+
+	div = (cctl & MXC_CCM_CCTL_ARM_MASK) >> MXC_CCM_CCTL_ARM_OFFSET;
+
+	rate = clk_get_rate(clk->parent) / (div + 1);
+
+	if (cctl & MXC_CCM_CCTL_ARM_SRC) {
+		rate *= 3;
+		rate /= 4;
+	}
+
+	return rate;
+}
+
+static unsigned long _clk_ahb_get_rate(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+	div = (cctl & MXC_CCM_CCTL_AHB_MASK) >> MXC_CCM_CCTL_AHB_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static void *pcdr_a[4] = {
+	MXC_CCM_PCDR0, MXC_CCM_PCDR1, MXC_CCM_PCDR2, MXC_CCM_PCDR3
+};
+static unsigned long _clk_perclkx_get_rate(struct clk *clk)
+{
+	unsigned long perclk_pdf;
+	unsigned long pcdr;
+
+	pcdr = __raw_readl(pcdr_a[clk->id >> 2]);
+
+	perclk_pdf =
+	    (pcdr >> ((clk->id & 3) << 3)) & MXC_CCM_PCDR1_PERDIV1_MASK;
+
+	return clk_get_rate(clk->parent) / (perclk_pdf + 1);
+}
+
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		div = 64;
+
+	return parent_rate / div;
+}
+
+static int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
+
+	if (clk->id < 0 || clk->id > 15)
+		return -EINVAL;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (div > 64 || div < 1 || ((parent_rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    __raw_readl(pcdr_a[clk->id >> 2]) & ~(MXC_CCM_PCDR1_PERDIV1_MASK <<
+						  ((clk->id & 3) << 3));
+	reg |= div << ((clk->id & 3) << 3);
+	__raw_writel(reg, pcdr_a[clk->id >> 2]);
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &upll_clk)
+		mcr |= (1 << clk->id);
+	else
+		mcr &= ~(1 << clk->id);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent3(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr = __raw_readl(MXC_CCM_MCR);
+	int bit;
+
+	if (parent != &upll_clk && parent != &ahb_clk &&
+	    parent != &upll_24610k_clk)
+		return -EINVAL;
+
+	switch (clk->id) {
+	case 2:
+		bit = MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET;
+		break;
+	case 13:
+		bit = MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET;
+		break;
+	case 14:
+		bit = MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (parent == &upll_24610k_clk) {
+		mcr |= 1 << bit;
+		__raw_writel(mcr, MXC_CCM_MCR);
+		clk->parent = parent;
+	} else {
+		mcr &= ~(1 << bit);
+		__raw_writel(mcr, MXC_CCM_MCR);
+		return _clk_perclkx_set_parent(clk, parent);
+	}
+
+	return 0;
+}
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent) / 2;	/* Always AHB / 2 */
+}
+
+static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->round_rate(clk->parent, rate);
+}
+
+static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->set_rate(clk->parent, rate);
+}
+
+/* Top-level clocks */
+
+static struct clk osc24m_clk = {
+	.get_rate = _clk_osc24m_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk osc32k_clk = {
+	.get_rate = _clk_osc32k_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk mpll_clk = {
+	.parent = &osc24m_clk,
+	.get_rate = _clk_pll_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk upll_clk = {
+	.parent = &osc24m_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_upll_enable,
+	.disable = _clk_upll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_24610k_get_rate(struct clk *clk)
+{
+	long long temp = clk_get_rate(clk->parent) * 2461LL;
+
+	do_div(temp, 24000);
+
+	return temp;	/* Always (UPLL * 24.61 / 240) */
+}
+
+static struct clk upll_24610k_clk = {
+	.parent = &upll_clk,
+	.get_rate = _clk_24610k_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+/* Mid-level clocks */
+
+static struct clk cpu_clk = {	/* ARM clock */
+	.parent = &mpll_clk,
+	.set_rate = _clk_cpu_set_rate,
+	.get_rate = _clk_cpu_get_rate,
+	.round_rate = _clk_cpu_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahb_clk = {	/* a.k.a. HCLK */
+	.parent = &cpu_clk,
+	.get_rate = _clk_ahb_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+
+/* Bottom-level clocks */
+
+struct clk usb_ahb_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk rtic_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_RTIC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk emi_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_EMI_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk brom_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_BROM_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+static struct clk per_clk[] = {
+	/* per_csi_clk */
+	{
+	 .id = 0,
+	 .parent = &upll_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_epit_clk */
+	{
+	 .id = 1,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esai_clk */
+	{
+	 .id = 2,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esdhc1_clk */
+	{
+	 .id = 3,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esdhc2_clk */
+	{
+	 .id = 4,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_gpt_clk */
+	{
+	 .id = 5,
+	 .parent = &ahb_clk,	/* Must be AHB */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_i2c_clk */
+	{
+	 .id = 6,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_lcdc_clk */
+	{
+	 .id = 7,
+	 .parent = &upll_clk,	/* Must be UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_nfc_clk */
+	{
+	 .id = 8,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_owire_clk */
+	{
+	 .id = 9,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_pwm_clk */
+	{
+	 .id = 10,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_sim1_clk */
+	{
+	 .id = 11,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_sim2_clk */
+	{
+	 .id = 12,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_ssi1_clk */
+	{
+	 .id = 13,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_ssi2_clk */
+	{
+	 .id = 14,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_uart_clk */
+	{
+	 .id = 15,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+};
+
+struct clk nfc_clk = {
+	.id = 0,
+	.parent = &per_clk[8],
+};
+
+struct clk audmux_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_AUDMUX_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ata_clk[] = {
+	{
+	/* ata_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ATA_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &ata_clk[1],},
+	{
+	/* ata_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ATA_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk can_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk csi_clk[] = {
+	{
+	/* csi_clk */
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &csi_clk[1],},
+	{
+	/* csi_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSI_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &csi_clk[2],},
+	{
+	/* csi_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_CSI_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk cspi_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI1_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI2_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI3_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk dryice_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_DRYICE_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ect_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_ECT_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk epit1_clk[] = {
+	{
+	/* epit_clk */
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &epit1_clk[1],},
+	{
+	/* epit_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk epit2_clk[] = {
+	{
+	/* epit_clk */
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &epit2_clk[1],},
+	{
+	/* epit_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esai_clk[] = {
+	{
+	/* esai_clk */
+	 .id = 0,
+	 .parent = &per_clk[2],
+	 .secondary = &esai_clk[1],},
+	{
+	/* esai_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESAI_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esai_clk[2],},
+	{
+	/* esai_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESAI_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esdhc1_clk[] = {
+	{
+	/* esdhc_clk */
+	 .id = 0,
+	 .parent = &per_clk[3],
+	 .secondary = &esdhc1_clk[1],},
+	{
+	/* esdhc_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC1_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esdhc1_clk[2],},
+	{
+	/* esdhc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esdhc2_clk[] = {
+	{
+	/* esdhc_clk */
+	 .id = 1,
+	 .parent = &per_clk[4],
+	 .secondary = &esdhc2_clk[1],},
+	{
+	/* esdhc_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC2_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esdhc2_clk[2],},
+	{
+	/* esdhc_ahb_clk */
+	 .id = 1,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk fec_clk[] = {
+	{
+	/* fec_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_FEC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &fec_clk[1],},
+	{
+	/* fec_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_FEC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk gpio_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 0,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 1,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 2,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 3,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT4_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk i2c_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &per_clk[6],},
+	{
+	 .id = 1,
+	 .parent = &per_clk[6],},
+	{
+	 .id = 2,
+	 .parent = &per_clk[6],},
+};
+
+struct clk iim_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IIM_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk iomuxc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IOMUXC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk kpp_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_KPP_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk lcdc_clk[] = {
+	{
+	/* lcdc_clk */
+	 .id = 0,
+	 .parent = &per_clk[7],
+	 .secondary = &lcdc_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	/* lcdc_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_LCDC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &lcdc_clk[2],},
+	{
+	/* lcdc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_LCDC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk owire_clk[] = {
+	{
+	/* owire_clk */
+	 .id = 0,
+	 .parent = &per_clk[9],
+	 .secondary = &owire_clk[1],},
+	{
+	/* owire_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_OWIRE_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm1_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 0,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm1_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_PWM1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm2_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 1,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm2_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm3_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 2,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm3_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm4_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 3,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm4_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk rng_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_RNGB_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk scc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SCC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk sdma_clk[] = {
+	{
+	/* sdma_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SDMA_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &sdma_clk[1],},
+	{
+	/* sdma_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SDMA_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk sim1_clk[] = {
+	{
+	/* sim1_clk */
+	 .id = 0,
+	 .parent = &per_clk[11],
+	 .secondary = &sim1_clk[1],},
+	{
+	/* sim_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk sim2_clk[] = {
+	{
+	/* sim2_clk */
+	 .id = 1,
+	 .parent = &per_clk[12],
+	 .secondary = &sim2_clk[1],},
+	{
+	/* sim_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk slcdc_clk[] = {
+	{
+	/* slcdc_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SLCDC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &slcdc_clk[1],},
+	{
+	/* slcdc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk spba_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SPBA_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ssi1_clk[] = {
+	{
+	/* ssi_clk */
+	 .id = 0,
+	 .parent = &per_clk[13],
+	 .secondary = &ssi1_clk[1],},
+	{
+	/* ssi_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk ssi2_clk[] = {
+	{
+	/* ssi_clk */
+	 .id = 1,
+	 .parent = &per_clk[14],
+	 .secondary = &ssi2_clk[1],},
+	{
+	/* ssi_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk tsc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_TCHSCRN_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk uart1_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 0,
+	 .parent = &per_clk[15],
+	 .secondary = &uart1_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart2_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 1,
+	 .parent = &per_clk[15],
+	 .secondary = &uart2_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart3_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 2,
+	 .parent = &per_clk[15],
+	 .secondary = &uart3_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart4_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 3,
+	 .parent = &per_clk[15],
+	 .secondary = &uart4_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART4_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart5_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 4,
+	 .parent = &per_clk[15],
+	 .secondary = &uart5_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART5_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk wdog_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_WDOG_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+static unsigned long _clk_usb_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return parent_rate / div;
+}
+
+static int _clk_usb_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+
+	if (parent_rate / div != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCTL) & ~MXC_CCM_CCTL_USB_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_CCTL_USB_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCTL);
+
+	return 0;
+}
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_CCTL) & MXC_CCM_CCTL_USB_DIV_MASK;
+
+	div >>= MXC_CCM_CCTL_USB_DIV_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static int _clk_usb_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &ahb_clk)
+		mcr |= (1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
+	else
+		mcr &= ~(1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static struct clk usb_clk = {
+	.parent = &upll_clk,
+	.get_rate = _clk_usb_get_rate,
+	.set_rate = _clk_usb_set_rate,
+	.round_rate = _clk_usb_round_rate,
+	.set_parent = _clk_usb_set_parent,
+};
+
+/* CLKO */
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return parent_rate / div;
+}
+
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_MCR_CLKO_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static unsigned long _clk_clko_get_rate(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_MCR) & MXC_CCM_MCR_CLKO_DIV_MASK;
+
+	div >>= MXC_CCM_MCR_CLKO_DIV_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static struct clk *clko_sources[] = {
+	&osc32k_clk,		/* 0x0 */
+	&osc24m_clk,		/* 0x1 */
+	&cpu_clk,		/* 0x2 */
+	&ahb_clk,		/* 0x3 */
+	&ipg_clk,		/* 0x4 */
+	NULL,			/* 0x5 */
+	NULL,			/* 0x6 */
+	NULL,			/* 0x7 */
+	NULL,			/* 0x8 */
+	NULL,			/* 0x9 */
+	&per_clk[0],		/* 0xA */
+	&per_clk[2],		/* 0xB */
+	&per_clk[13],		/* 0xC */
+	&per_clk[14],		/* 0xD */
+	&usb_clk,		/* 0xE */
+	NULL,			/* 0xF */
+};
+
+#define NR_CLKO_SOURCES (sizeof(clko_sources) / sizeof(struct clk *))
+
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long reg =
+	    __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_SEL_MASK;
+	struct clk **src;
+	int i;
+
+	for (i = 0, src = clko_sources; i < NR_CLKO_SOURCES; i++, src++)
+		if (*src == parent)
+			break;
+
+	if (i == NR_CLKO_SOURCES)
+		return -EINVAL;
+
+	clk->parent = parent;
+
+	reg |= i << MXC_CCM_MCR_CLKO_SEL_OFFSET;
+
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static struct clk clko_clk = {
+	.get_rate = _clk_clko_get_rate,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_MCR,
+	.enable_shift = MXC_CCM_MCR_CLKO_EN_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
 static unsigned long get_rate_mpll(void)
 {
 	ulong mpctl = __raw_readl(CRM_BASE + CCM_MPCTL);
@@ -59,12 +1572,14 @@ static unsigned long get_rate_mpll(void)
 	return mxc_decode_pll(mpctl, 24000000);
 }
 
+# if 0
 static unsigned long get_rate_upll(void)
 {
 	ulong mpctl = __raw_readl(CRM_BASE + CCM_UPCTL);
 
 	return mxc_decode_pll(mpctl, 24000000);
 }
+#endif
 
 unsigned long get_rate_arm(struct clk *clk)
 {
@@ -89,6 +1604,7 @@ static unsigned long get_rate_ipg(struct clk *clk)
 	return get_rate_ahb(NULL) >> 1;
 }
 
+#if 0
 static unsigned long get_rate_per(int per)
 {
 	unsigned long ofs = (per & 0x3) * 8;
@@ -133,6 +1649,7 @@ static unsigned long get_rate_otg(struct clk *clk)
 {
 	return 48000000; /* FIXME */
 }
+#endif
 
 static int clk_cgcr_enable(struct clk *clk)
 {
@@ -154,6 +1671,7 @@ static void clk_cgcr_disable(struct clk *clk)
 	__raw_writel(reg, clk->enable_reg);
 }
 
+#if 0
 #define DEFINE_CLOCK(name, i, er, es, gr, sr, s)	\
 	static struct clk name = {			\
 		.id		= i,			\
@@ -191,6 +1709,7 @@ DEFINE_CLOCK(i2c_clk,	 0, CCM_CGCR0,  6, get_rate_i2c, NULL, NULL);
 DEFINE_CLOCK(fec_clk,	 0, CCM_CGCR1, 15, get_rate_ipg, NULL, &fec_ahb_clk);
 DEFINE_CLOCK(dryice_clk, 0, CCM_CGCR1,  8, get_rate_ipg, NULL, NULL);
 DEFINE_CLOCK(lcdc_clk,	 0, CCM_CGCR1, 29, get_rate_lcdc, NULL, &lcdc_per_clk);
+#endif
 
 #define _REGISTER_CLOCK(d, n, c)	\
 	{				\
@@ -200,6 +1719,7 @@ DEFINE_CLOCK(lcdc_clk,	 0, CCM_CGCR1, 29, get_rate_lcdc, NULL, &lcdc_per_clk);
 	},
 
 static struct clk_lookup lookups[] = {
+#if 0
 	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk)
 	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk)
 	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk)
@@ -225,10 +1745,108 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("fec.0", NULL, fec_clk)
 	_REGISTER_CLOCK("imxdi_rtc.0", NULL, dryice_clk)
 	_REGISTER_CLOCK("imx-fb.0", NULL, lcdc_clk)
+#endif
+	_REGISTER_CLOCK(NULL, "osc24m_clk", osc24m_clk)
+	_REGISTER_CLOCK(NULL, "osc32k_clk", osc32k_clk)
+	_REGISTER_CLOCK(NULL, "mpll_clk", mpll_clk)
+	_REGISTER_CLOCK(NULL, "upll_clk", upll_clk)
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk)
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk)
+	_REGISTER_CLOCK(NULL, "ipg_clk", ipg_clk)
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk)
+	_REGISTER_CLOCK("mxcintuart.0", NULL, uart1_clk[0])
+	_REGISTER_CLOCK("mxcintuart.1", NULL, uart2_clk[0])
+	_REGISTER_CLOCK("mxcintuart.2", NULL, uart3_clk[0])
+	_REGISTER_CLOCK("mxcintuart.3", NULL, uart4_clk[0])
+	_REGISTER_CLOCK("mxcintuart.4", NULL, uart5_clk[0])
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk)
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk)
+	_REGISTER_CLOCK("mxc_nandv2_flash.0", NULL, nfc_clk)
+	_REGISTER_CLOCK("spi_imx.0", NULL, cspi_clk[0])
+	_REGISTER_CLOCK("spi_imx.1", NULL, cspi_clk[1])
+	_REGISTER_CLOCK("spi_imx.2", NULL, cspi_clk[2])
+	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm3_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm4_clk[0])
+	_REGISTER_CLOCK("mxc_keypad.0", NULL, kpp_clk)
+	_REGISTER_CLOCK("imx_adc.0", NULL, tsc_clk)
+	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c_clk[0])
+	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c_clk[1])
+	_REGISTER_CLOCK("imx-i2c.2", NULL, i2c_clk[2])
+	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0])
+	_REGISTER_CLOCK("imxdi_rtc.0", NULL, dryice_clk)
+	_REGISTER_CLOCK("imx-fb.0", NULL, lcdc_clk[0])
+	_REGISTER_CLOCK("mxc_sdma.0", "sdma_ipg_clk", sdma_clk[0])
+	_REGISTER_CLOCK("mxc_sdma.0", "sdma_ahb_clk", sdma_clk[1])
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk[0])
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt1_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt3_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt4_clk[0])
+	_REGISTER_CLOCK(NULL, "clko_clk", clko_clk)
+	_REGISTER_CLOCK("pata_fsl", NULL, ata_clk[0])
+	_REGISTER_CLOCK("FlexCAN.0", NULL, can_clk[0])
+	_REGISTER_CLOCK("mxc_esai.0", NULL, esai_clk[0])
+	_REGISTER_CLOCK("mxc_iim.0", NULL, iim_clk)
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk[0])
+	_REGISTER_CLOCK("mxc_scc.0", NULL, scc_clk)
+	_REGISTER_CLOCK("mxc_sim.0", NULL, sim1_clk[0])
+	_REGISTER_CLOCK("mxc_sim.0", NULL, sim2_clk[0])
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi1_clk[0])
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi2_clk[0])
+	_REGISTER_CLOCK("mxc_ipu", "csi_clk", csi_clk[0])
+	_REGISTER_CLOCK(NULL, "lcdc_clk", lcdc_clk[0])
+	_REGISTER_CLOCK(NULL, "slcdc_clk", lcdc_clk[0])
+	_REGISTER_CLOCK(NULL, "rng_clk", rng_clk)
+	_REGISTER_CLOCK(NULL, "audmux_clk", audmux_clk)
+	_REGISTER_CLOCK(NULL, "ect_clk", ect_clk)
+	_REGISTER_CLOCK(NULL, "epit1_clk", epit1_clk[0])
+	_REGISTER_CLOCK(NULL, "epit2_clk", epit2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpio_clk", gpio_clk[0])
+	_REGISTER_CLOCK(NULL, "iomuxc_clk", iomuxc_clk)
+	_REGISTER_CLOCK(NULL, "spba_clk", spba_clk)
+	_REGISTER_CLOCK(NULL, "wdog_clk", wdog_clk)
+	_REGISTER_CLOCK(NULL, "per_csi_clk", per_clk[0])
+	_REGISTER_CLOCK(NULL, "per_epit_clk", per_clk[1])
+	_REGISTER_CLOCK(NULL, "per_esai_clk", per_clk[2])
+	_REGISTER_CLOCK(NULL, "per_esdhc1_clk", per_clk[3])
+	_REGISTER_CLOCK(NULL, "per_esdhc2_clk", per_clk[4])
+	_REGISTER_CLOCK(NULL, "per_gpt_clk", per_clk[5])
+	_REGISTER_CLOCK(NULL, "per_i2c_clk", per_clk[6])
+	_REGISTER_CLOCK(NULL, "per_lcdc_clk", per_clk[7])
+	_REGISTER_CLOCK(NULL, "per_nfc_clk", per_clk[8])
+	_REGISTER_CLOCK(NULL, "per_owire_clk", per_clk[9])
+	_REGISTER_CLOCK(NULL, "per_pwm_clk", per_clk[10])
+	_REGISTER_CLOCK(NULL, "per_sim1_clk", per_clk[11])
+	_REGISTER_CLOCK(NULL, "per_sim2_clk", per_clk[12])
+	_REGISTER_CLOCK(NULL, "per_ssi1_clk", per_clk[13])
+	_REGISTER_CLOCK(NULL, "per_ssi2_clk", per_clk[14])
+	_REGISTER_CLOCK(NULL, "per_uart_clk", per_clk[15])
 };
 
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	upll_clk.get_rate(&upll_clk);
+	per_clk[5].get_rate(&per_clk[5]);
+	per_clk[5].enable(&per_clk[5]);
+
+	return clk_get_rate(&per_clk[5]);
+}
+
 int __init mx25_clocks_init(void)
 {
+	int i;
+	unsigned long upll_rate;
+	unsigned long ahb_rate;
+
 	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
 
 	/* Turn off all clocks except the ones we need to survive, namely:
@@ -236,13 +1854,53 @@ int __init mx25_clocks_init(void)
 	 * SCC
 	 */
 	__raw_writel((1 << 19), CRM_BASE + CCM_CGCR0);
-	__raw_writel((0xf << 16) | (3 << 26), CRM_BASE + CCM_CGCR1);
+
+	__raw_writel((1 << MXC_CCM_CGCR1_GPT1_OFFSET) |
+		     (1 << MXC_CCM_CGCR1_IIM_OFFSET),
+		     CRM_BASE + CCM_CGCR1);
+
 	__raw_writel((1 << 5), CRM_BASE + CCM_CGCR2);
 
 	/* Clock source for lcdc is upll */
 	__raw_writel(__raw_readl(CRM_BASE+0x64) | (1 << 7), CRM_BASE + 0x64);
 
-	mxc_timer_init(&gpt_clk, MX25_IO_ADDRESS(MX25_GPT1_BASE_ADDR), 54);
+	/* Init all perclk sources to ahb clock*/
+	for (i = 0; i < (sizeof(per_clk) / sizeof(struct clk)); i++)
+		per_clk[i].set_parent(&per_clk[i], &ahb_clk);
+
+	/* GPT clock must be derived from AHB clock */
+	ahb_rate = clk_get_rate(&ahb_clk);
+	clk_set_rate(&per_clk[5], ahb_rate / 10);
+
+	/* LCDC clock must be derived from UPLL clock */
+	upll_rate = clk_get_rate(&upll_clk);
+	clk_set_parent(&per_clk[7], &upll_clk);
+	clk_set_rate(&per_clk[7], upll_rate);
+
+	/* the NFC clock must be derived from AHB clock */
+	clk_set_parent(&per_clk[8], &ahb_clk);
+	clk_set_rate(&per_clk[8], ahb_rate / 6);
+
+	/* sim clock */
+	clk_set_rate(&per_clk[11], ahb_rate / 2);
+
+	/* the csi clock must be derived from UPLL clock */
+	clk_set_parent(&per_clk[0], &upll_clk);
+	clk_set_rate(&per_clk[0], upll_rate / 5);
+
+	pr_info("Clock input source is %ld\n", clk_get_rate(&osc24m_clk));
+
+	clk_enable(&emi_clk);
+	clk_enable(&gpio_clk[0]);
+	clk_enable(&gpio_clk[1]);
+	clk_enable(&gpio_clk[2]);
+	clk_enable(&iim_clk);
+	clk_enable(&gpt1_clk[0]);
+	clk_enable(&iomuxc_clk);
+	clk_enable(&scc_clk);
+
+	mxc_timer_init(&gpt1_clk[0], IO_ADDRESS(MX25_GPT1_BASE_ADDR),
+		       MX25_INT_GPT1);
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx25/cpu.c b/arch/arm/mach-mx25/cpu.c
new file mode 100644
index 0000000..f64dfbf
--- /dev/null
+++ b/arch/arm/mach-mx25/cpu.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mach-mx25/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX25
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/iram_alloc.h>
+#include <mach/hardware.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev)
+		mxc_set_system_rev(0x25, CHIP_REV_1_0);
+}
+
+static int __init post_cpu_init(void)
+{
+	void __iomem *base;
+	unsigned int reg;
+
+	iram_init(MX25_IRAM_BASE_ADDR, IRAM_SIZE);
+
+	base = IO_ADDRESS(MX25_AIPS1_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	base = IO_ADDRESS(MX25_AIPS2_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	return 0;
+}
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx25/crm_regs.h b/arch/arm/mach-mx25/crm_regs.h
new file mode 100644
index 0000000..b9368dd
--- /dev/null
+++ b/arch/arm/mach-mx25/crm_regs.h
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+
+#include <mach/hardware.h>
+
+#define MXC_CCM_BASE			((char *)IO_ADDRESS(MX25_CRM_BASE_ADDR))
+
+/* Register offsets */
+#define MXC_CCM_MPCTL               (MXC_CCM_BASE + 0x00)
+#define MXC_CCM_UPCTL               (MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CCTL                (MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CGCR0               (MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CGCR1               (MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CGCR2               (MXC_CCM_BASE + 0x14)
+#define MXC_CCM_PCDR0               (MXC_CCM_BASE + 0x18)
+#define MXC_CCM_PCDR1               (MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_PCDR2               (MXC_CCM_BASE + 0x20)
+#define MXC_CCM_PCDR3               (MXC_CCM_BASE + 0x24)
+#define MXC_CCM_RCSR                (MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CRDR                (MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_DCVR0               (MXC_CCM_BASE + 0x30)
+#define MXC_CCM_DCVR1               (MXC_CCM_BASE + 0x34)
+#define MXC_CCM_DCVR2               (MXC_CCM_BASE + 0x38)
+#define MXC_CCM_DCVR3               (MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_LTR0                (MXC_CCM_BASE + 0x40)
+#define MXC_CCM_LTR1                (MXC_CCM_BASE + 0x44)
+#define MXC_CCM_LTR2                (MXC_CCM_BASE + 0x48)
+#define MXC_CCM_LTR3                (MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTBR0               (MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTBR1               (MXC_CCM_BASE + 0x54)
+#define MXC_CCM_PMCR0               (MXC_CCM_BASE + 0x58)
+#define MXC_CCM_PMCR1               (MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_PMCR2               (MXC_CCM_BASE + 0x60)
+#define MXC_CCM_MCR                 (MXC_CCM_BASE + 0x64)
+#define MXC_CCM_LPIMR0              (MXC_CCM_BASE + 0x68)
+#define MXC_CCM_LPIMR1              (MXC_CCM_BASE + 0x6C)
+
+#define MXC_CCM_MPCTL_BRMO          (1 << 31)
+#define MXC_CCM_MPCTL_PD_OFFSET     26
+#define MXC_CCM_MPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_MPCTL_MFD_OFFSET    16
+#define MXC_CCM_MPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_MPCTL_MFI_OFFSET    10
+#define MXC_CCM_MPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_MPCTL_MFN_OFFSET    0
+#define MXC_CCM_MPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_MPCTL_LF            (1 << 15)
+
+#define MXC_CCM_UPCTL_BRMO          (1 << 31)
+#define MXC_CCM_UPCTL_PD_OFFSET     26
+#define MXC_CCM_UPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_UPCTL_MFD_OFFSET    16
+#define MXC_CCM_UPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_UPCTL_MFI_OFFSET    10
+#define MXC_CCM_UPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_UPCTL_MFN_OFFSET    0
+#define MXC_CCM_UPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_UPCTL_LF            (1 << 15)
+
+#define MXC_CCM_CCTL_ARM_OFFSET     30
+#define MXC_CCM_CCTL_ARM_MASK       (0x3 << 30)
+#define MXC_CCM_CCTL_AHB_OFFSET     28
+#define MXC_CCM_CCTL_AHB_MASK       (0x3 << 28)
+#define MXC_CCM_CCTL_MPLL_RST       (1 << 27)
+#define MXC_CCM_CCTL_UPLL_RST       (1 << 26)
+#define MXC_CCM_CCTL_LP_CTL_OFFSET  24
+#define MXC_CCM_CCTL_LP_CTL_MASK    (0x3 << 24)
+#define MXC_CCM_CCTL_LP_MODE_RUN    (0x0 << 24)
+#define MXC_CCM_CCTL_LP_MODE_WAIT   (0x1 << 24)
+#define MXC_CCM_CCTL_LP_MODE_DOZE   (0x2 << 24)
+#define MXC_CCM_CCTL_LP_MODE_STOP   (0x3 << 24)
+#define MXC_CCM_CCTL_UPLL_DISABLE   (1 << 23)
+#define MXC_CCM_CCTL_MPLL_BYPASS    (1 << 22)
+#define MXC_CCM_CCTL_USB_DIV_OFFSET 16
+#define MXC_CCM_CCTL_USB_DIV_MASK   (0x3 << 16)
+#define MXC_CCM_CCTL_CG_CTRL        (1 << 15)
+#define MXC_CCM_CCTL_ARM_SRC        (1 << 14)
+#define MXC_CCM_CCTL_ARM_SRC_OFFSET	14
+
+#define MXC_CCM_CGCR0_HCLK_ATA_OFFSET    16
+#define MXC_CCM_CGCR0_HCLK_BROM_OFFSET   17
+#define MXC_CCM_CGCR0_HCLK_CSI_OFFSET    18
+#define MXC_CCM_CGCR0_HCLK_EMI_OFFSET    19
+#define MXC_CCM_CGCR0_HCLK_ESAI_OFFSET   20
+#define MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET 21
+#define MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET 22
+#define MXC_CCM_CGCR0_HCLK_FEC_OFFSET    23
+#define MXC_CCM_CGCR0_HCLK_LCDC_OFFSET   24
+#define MXC_CCM_CGCR0_HCLK_RTIC_OFFSET   25
+#define MXC_CCM_CGCR0_HCLK_SDMA_OFFSET   26
+#define MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET  27
+#define MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET 28
+
+#define MXC_CCM_CGCR0_PER_CSI_OFFSET     0
+#define MXC_CCM_CGCR0_PER_EPIT_OFFSET    1
+#define MXC_CCM_CGCR0_PER_ESAI_OFFSET    2
+#define MXC_CCM_CGCR0_PER_ESDHC1_OFFSET  3
+#define MXC_CCM_CGCR0_PER_ESDHC2_OFFSET  4
+#define MXC_CCM_CGCR0_PER_GPT_OFFSET     5
+#define MXC_CCM_CGCR0_PER_I2C_OFFSET     6
+#define MXC_CCM_CGCR0_PER_LCDC_OFFSET    7
+#define MXC_CCM_CGCR0_PER_NFC_OFFSET     8
+#define MXC_CCM_CGCR0_PER_OWIRE_OFFSET   9
+#define MXC_CCM_CGCR0_PER_PWM_OFFSET     10
+#define MXC_CCM_CGCR0_PER_SIM1_OFFSET    11
+#define MXC_CCM_CGCR0_PER_SIM2_OFFSET    12
+#define MXC_CCM_CGCR0_PER_SSI1_OFFSET    13
+#define MXC_CCM_CGCR0_PER_SSI2_OFFSET    14
+#define MXC_CCM_CGCR0_PER_UART_OFFSET    15
+
+#define MXC_CCM_CGCR1_AUDMUX_OFFSET      0
+#define MXC_CCM_CGCR1_ATA_OFFSET         1
+#define MXC_CCM_CGCR1_CAN1_OFFSET        2
+#define MXC_CCM_CGCR1_CAN2_OFFSET        3
+#define MXC_CCM_CGCR1_CSI_OFFSET         4
+#define MXC_CCM_CGCR1_CSPI1_OFFSET       5
+#define MXC_CCM_CGCR1_CSPI2_OFFSET       6
+#define MXC_CCM_CGCR1_CSPI3_OFFSET       7
+#define MXC_CCM_CGCR1_DRYICE_OFFSET      8
+#define MXC_CCM_CGCR1_ECT_OFFSET         9
+#define MXC_CCM_CGCR1_EPIT1_OFFSET       10
+#define MXC_CCM_CGCR1_EPIT2_OFFSET       11
+#define MXC_CCM_CGCR1_ESAI_OFFSET        12
+#define MXC_CCM_CGCR1_ESDHC1_OFFSET      13
+#define MXC_CCM_CGCR1_ESDHC2_OFFSET      14
+#define MXC_CCM_CGCR1_FEC_OFFSET         15
+#define MXC_CCM_CGCR1_GPIO1_OFFSET       16
+#define MXC_CCM_CGCR1_GPIO2_OFFSET       17
+#define MXC_CCM_CGCR1_GPIO3_OFFSET       18
+#define MXC_CCM_CGCR1_GPT1_OFFSET        19
+#define MXC_CCM_CGCR1_GPT2_OFFSET        20
+#define MXC_CCM_CGCR1_GPT3_OFFSET        21
+#define MXC_CCM_CGCR1_GPT4_OFFSET        22
+#define MXC_CCM_CGCR1_I2C1_OFFSET        23
+#define MXC_CCM_CGCR1_I2C2_OFFSET        24
+#define MXC_CCM_CGCR1_I2C3_OFFSET        25
+#define MXC_CCM_CGCR1_IIM_OFFSET         26
+#define MXC_CCM_CGCR1_IOMUXC_OFFSET      27
+#define MXC_CCM_CGCR1_KPP_OFFSET         28
+#define MXC_CCM_CGCR1_LCDC_OFFSET        29
+#define MXC_CCM_CGCR1_OWIRE_OFFSET       30
+#define MXC_CCM_CGCR1_PWM1_OFFSET        31
+
+#define MXC_CCM_CGCR2_PWM2_OFFSET        (32-32)
+#define MXC_CCM_CGCR2_PWM3_OFFSET        (33-32)
+#define MXC_CCM_CGCR2_PWM4_OFFSET        (34-32)
+#define MXC_CCM_CGCR2_RNGB_OFFSET        (35-32)
+#define MXC_CCM_CGCR2_RTIC_OFFSET        (36-32)
+#define MXC_CCM_CGCR2_SCC_OFFSET         (37-32)
+#define MXC_CCM_CGCR2_SDMA_OFFSET        (38-32)
+#define MXC_CCM_CGCR2_SIM1_OFFSET        (39-32)
+#define MXC_CCM_CGCR2_SIM2_OFFSET        (40-32)
+#define MXC_CCM_CGCR2_SLCDC_OFFSET       (41-32)
+#define MXC_CCM_CGCR2_SPBA_OFFSET        (42-32)
+#define MXC_CCM_CGCR2_SSI1_OFFSET        (43-32)
+#define MXC_CCM_CGCR2_SSI2_OFFSET        (44-32)
+#define MXC_CCM_CGCR2_TCHSCRN_OFFSET     (45-32)
+#define MXC_CCM_CGCR2_UART1_OFFSET       (46-32)
+#define MXC_CCM_CGCR2_UART2_OFFSET       (47-32)
+#define MXC_CCM_CGCR2_UART3_OFFSET       (48-32)
+#define MXC_CCM_CGCR2_UART4_OFFSET       (49-32)
+#define MXC_CCM_CGCR2_UART5_OFFSET       (50-32)
+#define MXC_CCM_CGCR2_WDOG_OFFSET        (51-32)
+
+#define MXC_CCM_CGCR0_STOP_MODE_MASK	\
+			((1 << MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_RTIC_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_EMI_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_BROM_OFFSET))
+
+#define MXC_CCM_CGCR1_STOP_MODE_MASK	((1 << MXC_CCM_CGCR1_IIM_OFFSET) | \
+					 (1 << MXC_CCM_CGCR1_CAN2_OFFSET) | \
+					 (1 << MXC_CCM_CGCR1_CAN1_OFFSET))
+
+#define MXC_CCM_CGCR2_STOP_MODE_MASK	((1 << MXC_CCM_CGCR2_SPBA_OFFSET) | \
+					 (1 << MXC_CCM_CGCR2_SDMA_OFFSET) | \
+					 (1 << MXC_CCM_CGCR2_RTIC_OFFSET))
+
+#define MXC_CCM_PCDR1_PERDIV1_MASK       0x3f
+
+#define MXC_CCM_RCSR_NF16B               (1 << 14)
+
+#define MXC_CCM_PMCR1_CPEN_EMI		(1 << 29)
+#define MXC_CCM_PMCR1_CSPAEM_P_OFFSET	26
+#define MXC_CCM_PMCR1_CSPAEM_N_OFFSET	24
+#define MXC_CCM_PMCR1_CSPAEM_MASK	(0xf << 24)
+#define MXC_CCM_PMCR1_WBCN_OFFSET	16
+#define MXC_CCM_PMCR1_CPEN		(1 << 13)
+#define MXC_CCM_PMCR1_CSPA_P_OFFSET	11
+#define MXC_CCM_PMCR1_CSPA_N_OFFSET	9
+#define MXC_CCM_PMCR1_CSPA_MASK		(0xf << 9)
+
+#define MXC_CCM_PMCR1_WBCN_MASK		(0xff << 16)
+#define MXC_CCM_PMCR1_WBCN_DEFAULT	0xa0
+#define MXC_CCM_PMCR1_WBB_INCR		0
+#define MXC_CCM_PMCR1_WBB_MODE		1
+#define MXC_CCM_PMCR1_WBB_DECR		2
+#define MXC_CCM_PMCR1_WBB_MINI		3
+
+#define MXC_CCM_PMCR2_VSTBY		(1 << 17)
+#define MXC_CCM_PMCR2_OSC24M_DOWN	(1 << 16)
+
+#define MXC_CCM_PMCR1_AWB_EN		(MXC_CCM_PMCR1_CPEN_EMI | \
+					 MXC_CCM_PMCR1_CPEN | \
+					 (MXC_CCM_PMCR1_WBCN_DEFAULT << \
+					 MXC_CCM_PMCR1_WBCN_OFFSET))
+
+#define MXC_CCM_PMCR1_WBB_DEFAULT	((MXC_CCM_PMCR1_WBB_DECR << \
+					 MXC_CCM_PMCR1_CSPAEM_P_OFFSET) | \
+					 (MXC_CCM_PMCR1_WBB_DECR << \
+					 MXC_CCM_PMCR1_CSPAEM_N_OFFSET) | \
+					 (MXC_CCM_PMCR1_WBB_DECR << \
+					 MXC_CCM_PMCR1_CSPA_P_OFFSET) | \
+					 (MXC_CCM_PMCR1_WBB_DECR << \
+					 MXC_CCM_PMCR1_CSPA_N_OFFSET))
+
+#define MXC_CCM_PMCR1_AWB_DEFAULT	(MXC_CCM_PMCR1_AWB_EN | \
+					 MXC_CCM_PMCR1_WBB_DEFAULT)
+
+#define MXC_CCM_MCR_USB_XTAL_MUX_OFFSET  31
+#define MXC_CCM_MCR_CLKO_EN_OFFSET       30
+#define MXC_CCM_MCR_CLKO_DIV_OFFSET      24
+#define MXC_CCM_MCR_CLKO_DIV_MASK        (0x3F << 24)
+#define MXC_CCM_MCR_CLKO_SEL_OFFSET      20
+#define MXC_CCM_MCR_CLKO_SEL_MASK        (0xF << 20)
+#define MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET  19
+#define MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET  18
+#define MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET  17
+#define MXC_CCM_MCR_USB_CLK_MUX_OFFSET   16
+
+#define MXC_CCM_MCR_PER_CLK_MUX_MASK     (0xFFFF << 0)
+
+#define MXC_CCM_LPIMR0_MASK		0xFFFFFFFF
+#define MXC_CCM_LPIMR1_MASK		0xFFFFFFFF
+
+#endif				/* __ARCH_ARM_MACH_MX25_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx25/devices.c b/arch/arm/mach-mx25/devices.c
index 3a405fa..b78b173 100644
--- a/arch/arm/mach-mx25/devices.c
+++ b/arch/arm/mach-mx25/devices.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2009 Sascha Hauer, <kernel@pengutronix.de>
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -17,11 +18,102 @@
  */
 
 #include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
 #include <linux/dma-mapping.h>
 #include <linux/gpio.h>
+#include <linux/fsl_devices.h>
 #include <mach/mx25.h>
 #include <mach/irqs.h>
 
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/mmc.h>
+#include <mach/sdma.h>
+
+#include "iomux.h"
+#include "sdma_script_code.h"
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	sdma_script_addr->mxc_sdma_per_2_per_addr = -1;
+
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = -1;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = -1;
+
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+	sdma_script_addr->mxc_sdma_descrambler_addr = -1;
+
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+}
+
+static struct resource sdma_resources[] = {
+	{
+		.start = MX25_SDMA_BASE_ADDR,
+		.end = MX25_SDMA_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX25_INT_SDMA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_sdma",
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(sdma_resources),
+	.resource = sdma_resources,
+};
+
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
+
 static struct resource uart0[] = {
 	{
 		.start = 0x43f90000,
@@ -515,3 +607,190 @@ struct platform_device mxc_wdt = {
 	.num_resources = ARRAY_SIZE(mxc_wdt_resources),
 	.resource = mxc_wdt_resources,
 };
+
+/* imx adc driver */
+#if defined(CONFIG_IMX_ADC) || defined(CONFIG_IMX_ADC_MODULE)
+
+static struct resource imx_adc_resources[] = {
+	[0] = {
+	       .start = MX25_INT_TSC,
+	       .end = MX25_INT_TSC,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[1] = {
+	       .start = MX25_TSC_BASE_ADDR,
+	       .end = MX25_TSC_BASE_ADDR + PAGE_SIZE,
+	       .flags = IORESOURCE_MEM,
+	       }
+};
+
+static struct platform_device imx_adc_device = {
+	.name = "imx_adc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(imx_adc_resources),
+	.resource = imx_adc_resources,
+	.dev = {
+		.release = NULL,
+		},
+};
+static void imx_init_adc(void)
+{
+	(void)platform_device_register(&imx_adc_device);
+}
+#else
+static void imx_init_adc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_MXC_SOC_ESAI) || defined(CONFIG_SND_MXC_SOC_ESAI_MODULE)
+
+static struct mxc_esai_platform_data esai_data = {
+	.activate_esai_ports = gpio_activate_esai_ports,
+	.deactivate_esai_ports = gpio_deactivate_esai_ports,
+};
+
+static struct resource esai_resources[] = {
+	{
+		.start = MX25_ESAI_BASE_ADDR,
+		.end = MX25_ESAI_BASE_ADDR + 0x100,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX25_INT_ESAI,
+		.end = MX25_INT_ESAI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_esai_device = {
+	.name = "mxc_esai",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(esai_resources),
+	.resource = esai_resources,
+	.dev = {
+		.platform_data = &esai_data,
+	},
+};
+
+static void mxc_init_esai(void)
+{
+	platform_device_register(&mxc_esai_device);
+}
+#else
+static void mxc_init_esai(void)
+{
+
+}
+#endif
+
+static struct mxc_audio_platform_data mxc_surround_audio_data = {
+	.ext_ram = 1,
+};
+
+static struct platform_device mxc_alsa_surround_device = {
+	.name = "imx-3stack-wm8580",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_surround_audio_data,
+		},
+};
+
+static void mxc_init_surround_audio(void)
+{
+	platform_device_register(&mxc_alsa_surround_device);
+}
+
+#if defined(CONFIG_MXC_IIM) || defined(CONFIG_MXC_IIM_MODULE)
+static struct resource mxc_iim_resources[] = {
+	{
+	 .start = MX25_IIM_BASE_ADDR,
+	 .end = MX25_IIM_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_iim_device = {
+	.name = "mxc_iim",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_iim_resources),
+	.resource = mxc_iim_resources
+};
+
+static inline void mxc_init_iim(void)
+{
+	if (platform_device_register(&mxc_iim_device) < 0)
+		dev_err(&mxc_iim_device.dev,
+			"Unable to register mxc iim device\n");
+}
+#else
+static inline void mxc_init_iim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_MXC_SOC_SSI) || defined(CONFIG_SND_MXC_SOC_SSI_MODULE)
+
+static struct resource ssi1_resources[] = {
+	{
+	 .start = MX25_SSI1_BASE_ADDR,
+	 .end = MX25_SSI1_BASE_ADDR + 0x5C,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MX25_INT_SSI1,
+	 .end = MX25_INT_SSI1,
+	 .flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_alsa_ssi1_device = {
+	.name = "mxc_ssi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ssi1_resources),
+	.resource = ssi1_resources,
+};
+
+static struct resource ssi2_resources[] = {
+	{
+	 .start = MX25_SSI2_BASE_ADDR,
+	 .end = MX25_SSI2_BASE_ADDR + 0x5C,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MX25_INT_SSI2,
+	 .end = MX25_INT_SSI2,
+	 .flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_alsa_ssi2_device = {
+	.name = "mxc_ssi",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(ssi2_resources),
+	.resource = ssi2_resources,
+};
+
+static inline void mxc_init_ssi(void)
+{
+	platform_device_register(&mxc_alsa_ssi1_device);
+	platform_device_register(&mxc_alsa_ssi2_device);
+}
+#else
+static inline void mxc_init_ssi(void)
+{
+}
+#endif /* CONFIG_SND_MXC_SOC_SSI */
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_dma();
+	mxc_init_surround_audio();
+	imx_init_adc();
+	mxc_init_iim();
+	mxc_init_ssi();
+	mxc_init_esai();
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
diff --git a/arch/arm/mach-mx25/dma.c b/arch/arm/mach-mx25/dma.c
new file mode 100644
index 0000000..85a9275
--- /dev/null
+++ b/arch/arm/mach-mx25/dma.c
@@ -0,0 +1,663 @@
+/*
+ *  Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+
+#include "serial.h"
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define soc_trans_type	int_2_per
+#else
+#define soc_trans_type	emi_2_per
+#endif
+
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+
+#define MXC_ESAI_TX_REG	0x00
+#define MXC_ESAI_RX_REG	0x04
+#define MXC_ESAI_FIFO_WML 0x40
+
+struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = MX25_UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = MX25_UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = MX25_UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = MX25_UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = MX25_UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = MX25_UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = MX25_UART4_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = MX25_UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = MX25_UART5_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = MX25_UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_ESAI_16BIT_RX, &mxc_sdma_esai_16bit_rx_params},
+	{MXC_DMA_ESAI_16BIT_TX, &mxc_sdma_esai_16bit_tx_params},
+	{MXC_DMA_ESAI_24BIT_RX, &mxc_sdma_esai_24bit_rx_params},
+	{MXC_DMA_ESAI_24BIT_TX, &mxc_sdma_esai_24bit_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	struct mxc_sdma_info_entry_s *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx25/iomux.c b/arch/arm/mach-mx25/iomux.c
new file mode 100644
index 0000000..7c100f2
--- /dev/null
+++ b/arch/arm/mach-mx25/iomux.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX25 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX25
+ */
+/*!
+ * @file mach-mx25/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX25
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+
+/*!
+ * IOMUX register (base) addresses
+ */
+#define IOMUXGPR		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR))
+#define IOMUXSW_MUX_CTL		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x008)
+#define IOMUXSW_MUX_END		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x228)
+#define IOMUXSW_PAD_CTL		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x22C)
+#define IOMUXSW_PAD_END		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x414)
+#define IOMUXSW_INPUT_CTL	(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x460)
+#define IOMUXSW_INPUT_END	(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x580)
+
+#define MUX_PIN_NUM_MAX		\
+		(((IOMUXSW_MUX_END - IOMUXSW_MUX_CTL) >> 2) + 1)
+#define MUX_INPUT_NUM_MUX	\
+		(((IOMUXSW_INPUT_END - IOMUXSW_INPUT_CTL) >> 2) + 1)
+
+#define PIN_TO_IOMUX_INDEX(pin) (PIN_TO_IOMUX_MUX(pin) >> 2)
+
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+#define MUX_USED 0x80
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  cfg		an output function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	void *mux_reg = IOMUXGPR + PIN_TO_IOMUX_MUX(pin);
+	u8 *rp;
+
+	BUG_ON(pin_index > MUX_PIN_NUM_MAX);
+	BUG_ON((mux_reg > IOMUXSW_MUX_END) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(cfg, mux_reg);
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if (*rp && *rp != (cfg | MUX_USED)) {
+		/*Console: how to do */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, index=%d register=%p, "
+		       " prev=0x%x new=0x%x\n", pin_index, mux_reg,
+		       *rp, cfg);
+		ret = -EINVAL;
+	}
+	*rp = cfg | MUX_USED;
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	int ret = iomux_config_mux(pin, cfg);
+	if (IOMUX_TO_GPIO(pin) < MXC_GPIO_IRQS) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			ret |= gpio_request(IOMUX_TO_GPIO(pin), NULL);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+
+	BUG_ON((pin_index > MUX_PIN_NUM_MAX));
+
+	*rp = 0;
+	if (IOMUX_TO_GPIO(pin) < MXC_GPIO_IRQS) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			gpio_free(IOMUX_TO_GPIO(pin));
+	}
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin     a pin number as defined in \b #iomux_pin_name_t
+ * @param  config  the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	void *pad_reg = IOMUXGPR + PIN_TO_IOMUX_PAD(pin);
+
+	BUG_ON((pad_reg > IOMUXSW_PAD_END) || (pad_reg < IOMUXSW_PAD_CTL));
+
+	__raw_writel(config, pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
+/*!
+ * This function configures input path.
+ *
+ * @param input index of input select register as defined in \b
+ *			#iomux_input_select_t
+ * @param config the binary value of elements defined in \b
+ *			#iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	void *reg = IOMUXSW_INPUT_CTL + (input << 2);
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+
+	__raw_writel(config, reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx25/iomux.h b/arch/arm/mach-mx25/iomux.h
new file mode 100644
index 0000000..d91f976
--- /dev/null
+++ b/arch/arm/mach-mx25/iomux.h
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX25_IOMUX_H__
+#define __MACH_MX25_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+#include "mx25_pins.h"
+
+/*!
+ * @file mach-mx25/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX25
+ */
+
+typedef unsigned int iomux_pin_name_t;
+
+/*!
+ * IOMUX functions
+ * SW_MUX_CTL
+ */
+typedef enum iomux_pin_config {
+	MUX_CONFIG_FUNC = 0,	/*!< used as function */
+	MUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	MUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	MUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	MUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	MUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	MUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	MUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	MUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+	MUX_CONFIG_GPIO = MUX_CONFIG_ALT5,	/*!< used as GPIO */
+} iomux_pin_cfg_t;
+
+/*!
+ * IOMUX pad functions
+ * SW_PAD_CTL
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_DRV_3_3V = 0x0 << 13,
+	PAD_CTL_DRV_1_8V = 0x1 << 13,
+	PAD_CTL_HYS_CMOS = 0x0 << 8,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 8,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PUE_PUD = 0x1 << 6,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * IOMUX general purpose functions
+ * IOMUXC_GPR1
+ */
+typedef enum iomux_gp_func {
+	MUX_SDCTL_CSD0_SEL = 0x1 << 0,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 1,
+} iomux_gp_func_t;
+
+/*!
+ * IOMUX SELECT_INPUT register index
+ * Base register is IOMUXSW_INPUT_CTL in iomux.c
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXFS_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_DA_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_TXFS_AMX,
+	MUX_IN_CAN1_IPP_IND_CANRX,
+	MUX_IN_CAN2_IPP_IND_CANRX,
+	MUX_IN_CSI_IPP_CSI_D_0,
+	MUX_IN_CSI_IPP_CSI_D_1,
+	MUX_IN_CSPI1_IPP_IND_SS3_B,
+	MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI2_IPP_IND_MISO,
+	MUX_IN_CSPI2_IPP_IND_MOSI,
+	MUX_IN_CSPI2_IPP_IND_SS0_B,
+	MUX_IN_CSPI2_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI3_IPP_IND_MISO,
+	MUX_IN_CSPI3_IPP_IND_MOSI,
+	MUX_IN_CSPI3_IPP_IND_SS0_B,
+	MUX_IN_CSPI3_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_IND_SS2_B,
+	MUX_IN_CSPI3_IPP_IND_SS3_B,
+	MUX_IN_ESDHC1_IPP_DAT4_IN,
+	MUX_IN_ESDHC1_IPP_DAT5_IN,
+	MUX_IN_ESDHC1_IPP_DAT6_IN,
+	MUX_IN_ESDHC1_IPP_DAT7_IN,
+	MUX_IN_ESDHC2_IPP_CARD_CLK_IN,
+	MUX_IN_ESDHC2_IPP_CMD_IN,
+	MUX_IN_ESDHC2_IPP_DAT0_IN,
+	MUX_IN_ESDHC2_IPP_DAT1_IN,
+	MUX_IN_ESDHC2_IPP_DAT2_IN,
+	MUX_IN_ESDHC2_IPP_DAT3_IN,
+	MUX_IN_ESDHC2_IPP_DAT4_IN,
+	MUX_IN_ESDHC2_IPP_DAT5_IN,
+	MUX_IN_ESDHC2_IPP_DAT6_IN,
+	MUX_IN_ESDHC2_IPP_DAT7_IN,
+	MUX_IN_FEC_FEC_COL,
+	MUX_IN_FEC_FEC_CRS,
+	MUX_IN_FEC_FEC_RDATA_2,
+	MUX_IN_FEC_FEC_RDATA_3,
+	MUX_IN_FEC_FEC_RX_CLK,
+	MUX_IN_FEC_FEC_RX_ER,
+	MUX_IN_I2C2_IPP_SCL_IN,
+	MUX_IN_I2C2_IPP_SDA_IN,
+	MUX_IN_I2C3_IPP_SCL_IN,
+	MUX_IN_I2C3_IPP_SDA_IN,
+	MUX_IN_KPP_IPP_IND_COL_4,
+	MUX_IN_KPP_IPP_IND_COL_5,
+	MUX_IN_KPP_IPP_IND_COL_6,
+	MUX_IN_KPP_IPP_IND_COL_7,
+	MUX_IN_KPP_IPP_IND_ROW_4,
+	MUX_IN_KPP_IPP_IND_ROW_5,
+	MUX_IN_KPP_IPP_IND_ROW_6,
+	MUX_IN_KPP_IPP_IND_ROW_7,
+	MUX_IN_SIM1_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM1_PIN_SIM_SIMPD1,
+	MUX_IN_SIM1_SIM_RCVD1_IO,
+	MUX_IN_SIM2_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM2_PIN_SIM_SIMPD1,
+	MUX_IN_SIM2_SIM_RCVD1_IO,
+	MUX_IN_UART3_IPP_UART_RTS_B,
+	MUX_IN_UART3_IPP_UART_RXD_MUX,
+	MUX_IN_UART4_IPP_UART_RTS_B,
+	MUX_IN_UART4_IPP_UART_RXD_MUX,
+	MUX_IN_UART5_IPP_UART_RTS_B,
+	MUX_IN_UART5_IPP_UART_RXD_MUX,
+	MUX_IN_USB_TOP_IPP_IND_OTG_USB_OC,
+	MUX_IN_USB_TOP_IPP_IND_UH2_USB_OC,
+} iomux_input_select_t;
+
+/*!
+ * IOMUX input functions
+ * SW_SELECT_INPUT bits 2-0
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_cfg_t;
+
+struct mxc_iomux_pin_cfg {
+	iomux_pin_name_t pin;
+	u8 mux_mode;
+	u16 pad_cfg;
+	u8 in_select;
+	u8 in_mode;
+};
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b
+ *				#iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b
+ *				#iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b
+ *				#iomux_input_cfg_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+#endif
diff --git a/arch/arm/mach-mx25/mm.c b/arch/arm/mach-mx25/mm.c
index a7e587f..2b707da 100644
--- a/arch/arm/mach-mx25/mm.c
+++ b/arch/arm/mach-mx25/mm.c
@@ -2,7 +2,7 @@
  *  Copyright (C) 1999,2000 Arm Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
- *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright (C) 2005-2007, 2010 Freescale Semiconductor, Inc.
  *    - add MX31 specific definitions
  *
  * This program is free software; you can redistribute it and/or modify
diff --git a/arch/arm/mach-mx25/mx25_3stack.c b/arch/arm/mach-mx25/mx25_3stack.c
new file mode 100644
index 0000000..aa9169e
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack.c
@@ -0,0 +1,846 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/smsc911x.h>
+#include <linux/fec.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/keypad.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+
+#include "board-mx25_3stack.h"
+#include "crm_regs.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+unsigned int mx25_3stack_board_io;
+
+/* working point(wp): 0 - 399MHz; 1 - 266MHz; 2 - 133MHz; */
+/* 24MHz input clock table */
+static struct cpu_wp cpu_wp_mx25[] = {
+	{
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .cpu_podf = 0x0,
+	 .cpu_voltage = 1450000},
+	{
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .cpu_podf = 0x1,
+	 .cpu_voltage = 1340000},
+	{
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .cpu_podf = 0x3,
+	 .cpu_voltage = 1340000},
+};
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	*wp = 3;
+	return cpu_wp_mx25;
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+static u16 keymapping[16] = {
+	KEY_UP, KEY_DOWN, KEY_VOLUMEDOWN, KEY_HOME,
+	KEY_RIGHT, KEY_LEFT, KEY_ENTER, KEY_VOLUMEUP,
+	KEY_F6, KEY_F8, KEY_F9, KEY_F10,
+	KEY_F1, KEY_F2, KEY_F3, KEY_POWER,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	[0] = {
+	       .start = MX25_INT_KPP,
+	       .end = MX25_INT_KPP,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[1] = {
+		.start = MX25_KPP_BASE_ADDR,
+		.end = MX25_KPP_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+		},
+};
+
+static struct keypad_data keypad_plat_data = {
+	.rowmax = 4,
+	.colmax = 4,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+/* mxc keypad driver */
+static struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &keypad_plat_data,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC_V2) || defined(CONFIG_MTD_NAND_MXC_V2_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+	 .name = "nand.bootloader",
+	 .offset = 0,
+	 .size = 3 * 1024 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 5 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.configure",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 8 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct resource mxc_nand_resources[] = {
+	{
+		.flags = IORESOURCE_MEM,
+		.name  = "NFC_AXI_BASE",
+		.start = MX25_NFC_BASE_ADDR,
+		.end   = MX25_NFC_BASE_ADDR + SZ_8K - 1,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+		.start = MX25_INT_NANDFC,
+		.end   = MX25_INT_NANDFC,
+	},
+};
+
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+	.resource = mxc_nand_resources,
+	.num_resources = ARRAY_SIZE(mxc_nand_resources),
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+    defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "CPT-VGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+/*
+ * Power on/off CPT VGA panel.
+ */
+void board_power_lcd(int on)
+{
+	if (on) {
+		/* Enable HSYNC bit of touch screen */
+		imx_adc_set_hsync(1);
+		mx2fb_set_brightness(MXC_DEFAULT_INTENSITY);
+	} else {
+		/* disable HSYNC bit of touchscreen */
+		imx_adc_set_hsync(0);
+		mx2fb_set_brightness(MXC_INTENSITY_OFF);
+	}
+}
+EXPORT_SYMBOL_GPL(board_power_lcd);
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXC)
+static struct platform_device mxcbl_devices[] = {
+#if defined(CONFIG_BACKLIGHT_MXC_LCDC) || \
+    defined(CONFIG_BACKLIGHT_MXC_LCDC_MODULE)
+	{
+	 .name = "mxc_lcdc_bl",
+	 .id = 0,
+	 },
+#endif
+};
+
+static inline void mxc_init_bl(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxcbl_devices); i++)
+		platform_device_register(&mxcbl_devices[i]);
+}
+#else
+static inline void mxc_init_bl(void)
+{
+}
+#endif
+
+/*!
+ * Power Key interrupt handler.
+ */
+static irqreturn_t power_key_int(int irq, void *dev_id)
+{
+	pr_info("on-off key pressed\n");
+	return 0;
+}
+
+/*!
+ * Power Key initialization.
+ */
+static int __init mxc_init_power_key(void)
+{
+	/*Set power key as wakeup resource */
+	int irq, ret;
+
+	mxc_request_iomux(MX25_PIN_A25, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX25_PIN_A25, PAD_CTL_DRV_NORMAL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A25), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A25));
+
+	irq = IOMUX_TO_IRQ(MX25_PIN_A25);
+	set_irq_type(irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(irq, power_key_int, 0, "power_key", 0);
+	if (ret)
+		pr_info("register on-off key interrupt failed\n");
+	else
+		enable_irq_wake(irq);
+
+	return ret;
+}
+
+late_initcall(mxc_init_power_key);
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "cpld_spi",
+	 .max_speed_hz = 18000000,
+	 .bus_num = 1,
+	 .chip_select = 0,
+	 .mode = SPI_MODE_2,
+	 },
+	{
+	 .modalias = "wm8580_spi",
+	 .max_speed_hz = 8000000,	/* max spi SCK clock speed in HZ */
+	 .bus_num = 1,
+	 .chip_select = 1,
+	 },
+};
+
+static struct mxc_camera_platform_data camera_data = {
+	.core_regulator = NULL,
+	.io_regulator = NULL,
+	.analog_regulator = NULL,
+	.gpo_regulator = NULL,
+	.mclk = 24000000,
+};
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "ak5702-i2c",
+	 .addr = 0x13,
+	 },
+	{
+	 .type = "ov2640",
+	 .addr = 0x30,
+	 .platform_data = (void *)&camera_data,
+	 },
+};
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 2,
+	.src_port = 1,
+	.ext_port = 4,
+	.hp_irq = IOMUX_TO_IRQ(MX25_PIN_A10),
+	.hp_status = headphone_det_status,
+	.sysclk = 8300000,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &sgtl5000_data,
+		},
+};
+
+static void mxc_init_sgtl5000(void)
+{
+	struct clk *cko1, *parent;
+	unsigned long rate;
+
+	/* cko1 clock */
+	mxc_request_iomux(MX25_PIN_CLKO, MUX_CONFIG_FUNC);
+
+	cko1 = clk_get(NULL, "clko_clk");
+	if (IS_ERR(cko1))
+		return;
+	parent = clk_get(NULL, "ipg_clk");
+	if (IS_ERR(parent))
+		return;
+	clk_set_parent(cko1, parent);
+	rate = clk_round_rate(cko1, 13000000);
+	if (rate < 8000000 || rate > 27000000) {
+		pr_err("Error: SGTL5000 mclk freq %ld out of range!\n", rate);
+		clk_put(parent);
+		clk_put(cko1);
+		return;
+	}
+	clk_set_rate(cko1, rate);
+	clk_enable(cko1);
+	sgtl5000_data.sysclk = rate;
+	sgtl5000_enable_amp();
+	platform_device_register(&mxc_sgtl5000_device);
+}
+#else
+static inline void mxc_init_sgtl5000(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_AK5702) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_AK5702_MODULE)
+static struct platform_device mxc_ak5702_device = {
+	.name = "imx-3stack-ak5702",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+};
+
+static void mxc_init_ak5702(void)
+{
+	platform_device_register(&mxc_ak5702_device);
+}
+#else
+static inline void mxc_init_ak5702(void)
+{
+}
+#endif
+
+#if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+	 .start = LAN9217_BASE_ADDR,
+	 .end = LAN9217_BASE_ADDR + 255,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_BOARD_IRQ_START,
+	 .flags = IORESOURCE_IRQ,
+	 }
+};
+
+struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.flags = 0x8000 | SMSC911X_USE_16BIT | SMSC911X_FORCE_INTERNAL_PHY,
+};
+
+static struct platform_device smsc_lan9217_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &smsc911x_config,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static int __init mxc_init_enet(void)
+{
+	(void)platform_device_register(&smsc_lan9217_device);
+	return 0;
+}
+#else
+static int __init mxc_init_enet(void)
+{
+	return 0;
+}
+#endif
+
+late_initcall(mxc_init_enet);
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+static struct resource mxc_fec_resources[] = {
+	{
+		.start	= MX25_FEC_BASE_ADDR,
+		.end	= MX25_FEC_BASE_ADDR + 0xfff,
+		.flags	= IORESOURCE_MEM
+	}, {
+		.start	= MX25_INT_FEC,
+		.end	= MX25_INT_FEC,
+		.flags	= IORESOURCE_IRQ
+	},
+};
+
+static struct fec_platform_data fec_data = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+struct platform_device mxc_fec_device = {
+	.name = "fec",
+	.id = 0,
+	.dev = {
+		.platform_data = &fec_data,
+	},
+	.num_resources = ARRAY_SIZE(mxc_fec_resources),
+	.resource = mxc_fec_resources,
+};
+
+static __init int mxc_init_fec(void)
+{
+	return platform_device_register(&mxc_fec_device);
+}
+#else
+static inline int mxc_init_fec(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_IMX_SIM) || defined(CONFIG_IMX_SIM_MODULE)
+/* Used to configure the SIM bus */
+static struct mxc_sim_platform_data sim1_data = {
+	.clk_rate = 5000000,
+	.clock_sim = "sim1_clk",
+	.power_sim = NULL,
+	.init = NULL,
+	.exit = NULL,
+	.detect = 1,
+};
+
+/*!
+ * Resource definition for the SIM
+ */
+static struct resource mxc_sim1_resources[] = {
+	[0] = {
+	       .start = MX25_SIM1_BASE_ADDR,
+	       .end = MX25_SIM1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_SIM1,
+	       .end = MX25_INT_SIM1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for IMX SIM */
+static struct platform_device mxc_sim1_device = {
+	.name = "mxc_sim",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &sim1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxc_sim1_resources),
+	.resource = mxc_sim1_resources,
+};
+
+static inline void mxc_init_sim(void)
+{
+	(void)platform_device_register(&mxc_sim1_device);
+}
+#else
+static inline void mxc_init_sim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_29_30 | MMC_VDD_32_33,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 52000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = MX25_MMC_SDHC1_BASE_ADDR,
+	       .end = MX25_MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_SDHC1,
+	       .end = MX25_INT_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = IOMUX_TO_IRQ(MX25_PIN_A15),
+	       .end = IOMUX_TO_IRQ(MX25_PIN_A15),
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxsdhci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+#ifdef CONFIG_MMC_IMX_ESDHCI_SELECT2
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_29_30 | MMC_VDD_32_33,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 52000000,
+	.card_fixed = 1,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.clock_mmc = "esdhc2_clk",
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MX25_MMC_SDHC2_BASE_ADDR,
+	       .end = MX25_MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_SDHC2,
+	       .end = MX25_INT_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+#endif
+
+static inline void mxc_init_mmc(void)
+{
+	(void)platform_device_register(&mxcsdhc1_device);
+#ifdef CONFIG_MMC_IMX_ESDHCI_SELECT2
+	(void)platform_device_register(&mxcsdhc2_device);
+#endif
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+static void __init mx25_3stack_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	mx25_clocks_init();
+	uart_clk = clk_get_sys("imx-uart.0", NULL);
+	early_console_setup(MX25_UART1_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init = mx25_3stack_timer_init,
+};
+
+#if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
+static void flexcan_xcvr_enable(int id, int en)
+{
+	static int pwdn;
+
+	if (id != 1)		/* MX25 3-stack uses only CAN2 */
+		return;
+
+	if (en) {
+		if (!pwdn++)
+			gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+	} else {
+		if (!--pwdn)
+			gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 1);
+	}
+}
+
+struct flexcan_platform_data flexcan_data[] = {
+	{
+	 .core_reg = NULL,
+	 .io_reg = NULL,
+	 .xcvr_enable = flexcan_xcvr_enable,
+	 .active = gpio_can_active,
+	 .inactive = gpio_can_inactive,
+	 .br_clksrc = 1,
+	 .br_rjw = 2,
+	 .br_presdiv = 6,
+	 .br_propseg = 4,
+	 .br_pseg1 = 4,
+	 .br_pseg2 = 7,
+	 .bcc = 1,
+	 .srx_dis = 1,
+	 .smp = 1,
+	 .boff_rec = 1,
+	 .ext_msg = 1,
+	 .std_msg = 1,},
+	{
+	 .core_reg = NULL,
+	 .io_reg = NULL,
+	 .xcvr_enable = flexcan_xcvr_enable,
+	 .active = gpio_can_active,
+	 .inactive = gpio_can_inactive,
+	 .br_clksrc = 1,
+	 .br_rjw = 2,
+	 .br_presdiv = 6,
+	 .br_propseg = 4,
+	 .br_pseg1 = 4,
+	 .br_pseg2 = 7,
+	 .bcc = 1,
+	 .srx_dis = 1,
+	 .smp = 1,
+	 .boff_rec = 1,
+	 .ext_msg = 1,
+	 .std_msg = 1,},
+};
+
+static struct resource flexcan1_resources[] = {
+	{
+	 .start = MX25_CAN1_BASE_ADDR,
+	 .end = MX25_CAN1_BASE_ADDR + 0x97F,
+	 .flags = IORESOURCE_MEM,},
+	{
+	 .start = MX25_INT_CAN1,
+	 .end = MX25_INT_CAN1,
+	 .flags = IORESOURCE_IRQ,}
+};
+static struct resource flexcan2_resources[] = {
+	{
+	 .start = MX25_CAN3_BASE_ADDR,
+	 .end = MX25_CAN3_BASE_ADDR + 0x97F,
+	 .flags = IORESOURCE_MEM,},
+	{
+	 .start = MX25_INT_CAN2,
+	 .end = MX25_INT_CAN2,
+	 .flags = IORESOURCE_IRQ,}
+};
+
+static struct platform_device flexcan_devices[] = {
+	{
+	 .name = "FlexCAN",
+	 .id = 0,
+	 .num_resources = ARRAY_SIZE(flexcan1_resources),
+	 .resource = flexcan1_resources,},
+	{
+	 .name = "FlexCAN",
+	 .id = 1,
+	 .num_resources = ARRAY_SIZE(flexcan2_resources),
+	 .resource = flexcan2_resources,},
+};
+
+static inline void mxc_init_flexcan(void)
+{
+#ifdef CONFIG_FLEXCAN_MXC_SELECT1
+	/* MX25 3stack doesn't use CAN1 */
+	mxc_register_device(&flexcan_devices[0], &flexcan_data[0]);
+#endif
+	mxc_register_device(&flexcan_devices[1], &flexcan_data[1]);
+}
+#else
+static inline void mxc_init_flexcan(void)
+{
+}
+#endif
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	pr_info("AIPS1 VA base: 0x%p\n", IO_ADDRESS(MX25_AIPS1_BASE_ADDR));
+	mxc_cpu_common_init();
+	mx25_3stack_gpio_init();
+	mxc_init_keypad();
+#ifdef CONFIG_I2C
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+#endif
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+	mx25_3stack_init_mc34704();
+	mxc_init_fb();
+	mxc_init_bl();
+	mxc_init_nand_mtd();
+	mxc_init_sgtl5000();
+	mxc_init_ak5702();
+	mxc_init_mmc();
+	mxc_init_sim();
+	mxc_init_fec();
+	mxc_init_flexcan();
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX25_3DS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX25_3DS, "Freescale MX25 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = MX25_AIPS1_BASE_ADDR,
+	.io_pg_offst = ((MX25_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mx25_map_io,
+	.init_irq = mx25_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx25/mx25_3stack_cpld.c b/arch/arm/mach-mx25/mx25_3stack_cpld.c
new file mode 100644
index 0000000..32fb68a
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_cpld.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <mach/hardware.h>
+#include <asm/mach/irq.h>
+#include <mach/gpio.h>
+#include "board-mx25_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack_cpld.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+extern int mxc_spi_poll_transfer(struct spi_device *spi,
+				 struct spi_transfer *t);
+static int __init mxc_expio_init(void);
+
+struct spi_device *cpld_spi;
+
+/*!
+ * This function is used to tranfer data to CPLD regs over CSPI
+ */
+static inline int mx25_3ds_cpld_rw(u8 *buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+
+	if (!cpld_spi)
+		return -1;
+
+	mxc_spi_poll_transfer(cpld_spi, &t);
+	return 0;
+}
+
+/*!
+ * This function is called to read a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be read
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_read(unsigned int offset)
+{
+	unsigned int frame[2];
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = 0;
+
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+	data = (frame[1] >> 6) & 0xFFFF;
+
+	reg_num = (offset + 2) >> 1;
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	data |= (((frame[1] >> 6) & 0xFFFF) << 16);
+	return data;
+}
+EXPORT_SYMBOL(spi_cpld_read);
+
+/*!
+ * This function is called to write to a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be written
+ * @param        reg_val   value to be written
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_write(unsigned int offset, unsigned int reg_val)
+{
+	unsigned int frame[2] = { 0, 0 };
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = reg_val;
+
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	reg_num = (offset + 2) >> 1;
+	data = reg_val >> 16;
+	frame[0] = 0;
+	frame[1] = 0;
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_cpld_write);
+
+static int __init mx25_3ds_cpld_probe(struct spi_device *spi)
+{
+	unsigned int i = 0;
+
+	spi->bits_per_word = 46;
+	cpld_spi = spi;
+
+	spi_setup(spi);
+	i = spi_cpld_read(CPLD_CODE_VER_REG);
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n", i);
+	spi_cpld_write(LED_SWITCH_REG, 0xFF);
+
+	/* disable the interrupt and clear the status */
+	spi_cpld_write(INTR_MASK_REG, 0);
+	spi_cpld_write(INTR_RESET_REG, 0xFFFF);
+	spi_cpld_write(INTR_RESET_REG, 0);
+	spi_cpld_write(INTR_MASK_REG, 0x1E);
+
+	mxc_expio_init();
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the CPLD callback functions.
+ */
+static struct spi_driver mx25_3ds_cpld_driver = {
+	.driver = {
+		   .name = "cpld_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mx25_3ds_cpld_probe,
+};
+
+static int __init mx25_3ds_cpld_init(void)
+{
+	pr_info("Registering the CPLD Driver\n");
+	return spi_register_driver(&mx25_3ds_cpld_driver);
+}
+device_initcall(mx25_3ds_cpld_init);
+
+static int __initdata is_dbg_removed = { 0 };
+static int __init remove_dbg_setup(char *__unused)
+{
+	is_dbg_removed = 1;
+	return 0;
+}
+__setup("remove_dbg", remove_dbg_setup);
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 expio_irq;
+	struct irq_desc *d;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	expio_irq = MXC_BOARD_IRQ_START;
+
+	d = irq_desc + expio_irq;
+	if (unlikely(!(d->handle_irq))) {
+		printk(KERN_ERR "\nEXPIO irq: %d unhandled\n", expio_irq);
+		BUG();		/* oops */
+	}
+	d->handle_irq(expio_irq, d);
+
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	/* clear the interrupt status */
+	spi_cpld_write(INTR_RESET_REG, 1);
+	spi_cpld_write(INTR_RESET_REG, 0);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	if (is_dbg_removed)
+		return 0;
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_request_iomux(MX25_PIN_PWM, MUX_CONFIG_GPIO);
+	mxc_iomux_set_pad(MX25_PIN_PWM, PAD_CTL_PUE_PUD);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_PWM), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_PWM));
+
+	for (i = MXC_BOARD_IRQ_START;
+	     i < (MXC_BOARD_IRQ_START + MXC_BOARD_IRQS);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(IOMUX_TO_IRQ(MX25_PIN_PWM), IRQF_TRIGGER_LOW);
+	set_irq_chained_handler(IOMUX_TO_IRQ(MX25_PIN_PWM),
+				mxc_expio_irq_handler);
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-mx25/mx25_3stack_gpio.c b/arch/arm/mach-mx25/mx25_3stack_gpio.c
new file mode 100644
index 0000000..042aca3
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_gpio.c
@@ -0,0 +1,1367 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include "board-mx25_3stack.h"
+#include "iomux.h"
+
+/*!
+ * @file mach-mx25/mx25_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX25
+ */
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+};
+
+static struct mxc_iomux_pin_cfg __initdata sim_iomux_pins[] = {
+	/* SIM1 */
+	/* SIM1 CLK */
+	{
+	 MX25_PIN_CSI_D2, MUX_CONFIG_ALT4,
+	 PAD_CTL_SRE_FAST |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 RST */
+	{
+	 MX25_PIN_CSI_D3, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 VEN */
+	{
+	 MX25_PIN_CSI_D4, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 TX */
+	{
+	 MX25_PIN_CSI_D5, MUX_CONFIG_ALT4,
+	 PAD_CTL_SRE_FAST |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OpenDrain | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 PD */
+	{
+	 MX25_PIN_CSI_D6, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 */
+	/* SIM2 CLK */
+	{
+	 MX25_PIN_CSI_D8, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 RST */
+	{
+	 MX25_PIN_CSI_D9, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 VEN */
+	{
+	 MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_NONE,
+	 },
+	/* SIM2 TX */
+	{
+	 MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 PD */
+	{
+	 MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+};
+
+static int __initdata enable_sim = { 0 };
+static int __init sim_setup(char *__unused)
+{
+	enable_sim = 1;
+	return 1;
+}
+
+__setup("sim", sim_setup);
+
+/*!
+ * This system-wide GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by
+ * \b fixup_mx25_3stack() during system startup. This function is board
+ * specific.
+ */
+void __init mx25_3stack_gpio_init(void)
+{
+	int i, num = 0;
+	struct mxc_iomux_pin_cfg *pin_ptr;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					    mxc_iomux_pins[i].in_mode);
+	}
+
+	if (enable_sim) {
+		pin_ptr = sim_iomux_pins;
+		num = ARRAY_SIZE(sim_iomux_pins);
+	}
+
+	for (i = 0; i < num; i++) {
+		mxc_request_iomux(pin_ptr[i].pin, pin_ptr[i].mux_mode);
+		if (pin_ptr[i].pad_cfg)
+			mxc_iomux_set_pad(pin_ptr[i].pin, pin_ptr[i].pad_cfg);
+		if (pin_ptr[i].in_select)
+			mxc_iomux_set_input(pin_ptr[i].in_select,
+					pin_ptr[i].in_mode);
+	}
+}
+
+/*!
+ * Activate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+	case 0:
+		/* UART 1 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_TXD,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_CTS,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+	case 1:
+		/* UART 2 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_TXD, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_CTS, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		break;
+	case 2:
+		/* UART 3 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+		break;
+	case 3:
+		/* UART 4 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_ALT2); /*RXD*/
+		mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_ALT2); /*TXD*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT2); /*RTS*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT2); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH0);
+	case 4:
+		/* UART 5 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Inactivate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_RXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_TXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_RTS), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_CTS), NULL);
+
+		mxc_free_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_TXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RTS), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_CTS), NULL);
+
+		mxc_free_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW3), NULL);
+
+		mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+		break;
+	case 3:
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+		break;
+	case 4:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL);
+
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Activate Keypad
+ */
+void gpio_keypad_active(void)
+{
+	mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_FUNC);
+
+#define KPP_PAD_CTL_ROW (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU)
+#define KPP_PAD_CTL_COL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW0, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW1, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW2, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW3, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL0, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL1, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL2, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL3, KPP_PAD_CTL_COL);
+
+#undef KPP_PAD_CTL_ROW
+#undef KPP_PAD_CTL_COL
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Inactivate Keypad
+ */
+void gpio_keypad_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL3), NULL);
+
+	mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Activate FEC
+ */
+void gpio_fec_active(void)
+{
+	mxc_request_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_POWER_FAIL, MUX_CONFIG_FUNC); /* PHY INT */
+
+#define FEC_PAD_CTL1 (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PUE_PUD | \
+		      PAD_CTL_PKE_ENABLE)
+#define FEC_PAD_CTL2 (PAD_CTL_PUE_PUD)
+
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_CLK, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RX_DV, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA0, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA0, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_EN, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDC, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDIO, FEC_PAD_CTL1 | PAD_CTL_22K_PU);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA1, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA1, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_POWER_FAIL, FEC_PAD_CTL1);
+
+	/*
+	 * Set up the FEC_RESET_B and FEC_ENABLE GPIO pins.
+	 * Assert FEC_RESET_B, then power up the PHY by asserting
+	 * FEC_ENABLE, at the same time lifting FEC_RESET_B.
+	 *
+	 * FEC_RESET_B: gpio2[3] is ALT 5 mode of pin D12
+	 * FEC_ENABLE_B: gpio4[8] is ALT 5 mode of pin A17
+	 */
+	mxc_request_iomux(MX25_PIN_A17, MUX_CONFIG_ALT5); /* FEC_EN */
+	mxc_request_iomux(MX25_PIN_D12, MUX_CONFIG_ALT5); /* FEC_RESET_B */
+
+	mxc_iomux_set_pad(MX25_PIN_A17, PAD_CTL_ODE_OpenDrain);
+	mxc_iomux_set_pad(MX25_PIN_D12, 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A17), "a17");
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D12), "d12");
+
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A17), 0); /* FEC_EN */
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D12), 0); /* FEC_RESET_B */
+
+	/* drop PHY power */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 0);	/* FEC_EN */
+
+	/* assert reset */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D12), 0);	/* FEC_RESET_B */
+	udelay(2);		/* spec says 1us min */
+
+	/* turn on PHY power and lift reset */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 1);	/* FEC_EN */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D12), 1);	/* FEC_RESET_B */
+
+#undef FEC_PAD_CTL_COMMON
+#undef FEC_PAD_CTL1
+#undef FEC_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_fec_active);
+
+/*!
+ * Inactivate FEC
+ */
+void gpio_fec_inactive(void)
+{
+	/*
+	 * Turn off the PHY.
+	 */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TX_CLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RX_DV), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RDATA0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TDATA0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TX_EN), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_MDC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_MDIO), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RDATA1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TDATA1), NULL);
+
+	mxc_free_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_GPIO);
+	mxc_request_iomux(MX25_PIN_POWER_FAIL, MUX_CONFIG_FUNC); /* PHY INT */
+
+	mxc_free_iomux(MX25_PIN_A17, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D12, MUX_CONFIG_GPIO); /* FEC_RESET_B */
+
+	/* We keep pin A17, so FEC_ENABLE doesn't float */
+}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+/*!
+ * Activate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+#define I2C_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		     PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		mxc_request_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_CLK, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_DAT, I2C_PAD_CTL);
+		break;
+	case 1:
+		/*I2C2*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN, INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN, INPUT_CTL_PATH1);
+
+#if 0
+		/* Or use FEC pins if it is not used */
+		mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_ALT1); /*SCL*/
+		mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_ALT1); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_FEC_RDATA1, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_FEC_RX_DV, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN, INPUT_CTL_PATH0);
+#endif
+
+		break;
+	case 2:
+		/*I2C3*/
+		mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_HSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_VSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SCL_IN, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SDA_IN, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+#undef I2C_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Inactivate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_I2C1_CLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_I2C1_DAT), NULL);
+		mxc_free_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/*I2C2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+
+#if 0
+		/* Or use FEC pins if not in use */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RDATA1, NULL); /*SCL*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RX_DV, NULL); /*SDA*/
+		mxc_free_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+#endif
+
+		break;
+	case 2:
+		/*I2C3*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_HSYNC), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSYNC), NULL);
+		mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * Activate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+#define SPI_PAD_CTL1 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_100K_PU)
+#define SPI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_PUE_PUD|PAD_CTL_100K_PU)
+
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_FUNC);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT5); /*SS2*/
+#endif
+		mxc_request_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_ALT2); /*SS3*/
+
+		/* Or if VSTBY_ACK is being used */
+		/*mxc_request_iomux(MX25_PIN_NF_CE0, MUX_CONFIG_ALT1);*/ /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MOSI, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MISO, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SCLK, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_RDY, SPI_PAD_CTL1);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+#endif
+		mxc_iomux_set_pad(MX25_PIN_VSTBY_ACK, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI1_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH1);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT2); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT2); /*MISO*/
+		mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_ALT2); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_ALT2); /*RDY*/
+		mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_ALT2); /*SS0*/
+		mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT2); /*SS1*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_ALT6); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_LD12, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD14, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD15, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_OE_ACD, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_CONTRAST, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS, SPI_PAD_CTL2);
+
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+		break;
+	case 2:
+		/* SPI3 */
+		mxc_request_iomux(MX25_PIN_EB0, MUX_CONFIG_ALT6); /*SS0*/
+		mxc_request_iomux(MX25_PIN_EB1, MUX_CONFIG_ALT6); /*SS1*/
+		mxc_request_iomux(MX25_PIN_CS4, MUX_CONFIG_ALT6); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_CS5, MUX_CONFIG_ALT6); /*MISO*/
+		mxc_request_iomux(MX25_PIN_ECB, MUX_CONFIG_ALT6); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LBA, MUX_CONFIG_ALT6); /*RDY*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT7); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_EB0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_EB1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS4, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS5, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_ECB, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_LBA, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS2_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+#undef SPI_PAD_CTL1
+#undef SPI_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Inactivate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_MOSI), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_MISO), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SS0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SS1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SCLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_RDY), NULL);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*SS2*/
+#endif
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSTBY_ACK), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_GPIO);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+#endif
+		mxc_free_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SPI2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD12), NULL); /*MOSI*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD13), NULL); /*MISO*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD14), NULL); /*SCLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD15), NULL); /*RDY*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE_ACD), NULL); /*SS0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CONTRAST), NULL); /*SS1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*SS2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RTS), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		/* SPI3 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB0), NULL); /*SS0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB1), NULL); /*SS1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CS4), NULL); /*MOSI*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CS5), NULL); /*MISO*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_ECB), NULL); /*SCLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LBA), NULL); /*RDY*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL); /*SS2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D9), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_EB0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_EB1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS5, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_ECB, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LBA, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Activate LCD
+ */
+void gpio_lcdc_active(void)
+{
+	mxc_request_iomux(MX25_PIN_LD0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_ALT2); /*D16*/
+	mxc_request_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_ALT2); /*D17*/
+	mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LSCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_FUNC);
+
+#define LCD_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX25_PIN_LD0, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD1, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD2, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD3, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD4, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD5, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD6, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD7, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD8, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD9, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD10, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD11, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD12, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD13, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD14, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD15, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_E, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_F, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_HSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_VSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LSCLK, LCD_PAD_CTL | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE_ACD, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CONTRAST, LCD_PAD_CTL);
+}
+EXPORT_SYMBOL(gpio_lcdc_active);
+
+/*!
+ * Inactivate LCD
+ */
+void gpio_lcdc_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD4), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD5), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD6), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD7), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_E), NULL); /*D16*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_F), NULL); /*D17*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_HSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LSCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE_ACD), NULL);
+
+	mxc_free_iomux(MX25_PIN_LD0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LSCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_lcdc_inactive);
+
+/*!
+ * Activate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+#define SDHC_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+		      PAD_CTL_47K_PU | PAD_CTL_SRE_FAST)
+
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		mxc_request_iomux(MX25_PIN_SD1_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_A14, MUX_CONFIG_ALT5); /*SD1_WP*/
+		mxc_request_iomux(MX25_PIN_A15, MUX_CONFIG_ALT5); /*SD1_DET*/
+
+		mxc_iomux_set_pad(MX25_PIN_SD1_CMD, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_CLK, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA0, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA1, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_A14, PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX25_PIN_A15, PAD_CTL_DRV_NORMAL);
+
+		/* Set write protect and card detect gpio as inputs */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_A14), "a14");
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_A15), "a15");
+		gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A14)); /*SD1_WP*/
+		gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A15)); /*SD1_DET*/
+
+		break;
+	case 1:
+		/* SDHC2 */
+		mxc_request_iomux(MX25_PIN_LD8,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CMD*/
+		mxc_request_iomux(MX25_PIN_LD9,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CLK*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT6); /*DAT0*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT6); /*DAT1*/
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT6); /*DAT2*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT6); /*DAT3*/
+
+		mxc_iomux_set_pad(MX25_PIN_LD8, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD9, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD10, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD11, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD12, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D4, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D5, SDHC_PAD_CTL);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Inactivate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_CMD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_CLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA3), NULL);
+
+		mxc_free_iomux(MX25_PIN_SD1_CMD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_A14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_A15, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SDHC2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD8), NULL); /*CMD*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD9), NULL); /*CLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD10), NULL); /*DAT0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD11), NULL); /*DAT1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD12), NULL); /*DAT2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD13), NULL); /*DAT3*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL); /*DAT4*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL); /*DAT5*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL); /*DAT6*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL); /*DAT7*/
+
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	unsigned int ret = 0;
+
+	ret = gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A15));
+	return ret;
+}
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*!
+ * Get pin value to detect write protection
+ */
+int sdhc_write_protect(struct device *dev)
+{
+	unsigned int rc = 0;
+
+	rc = gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A14));
+	return rc;
+}
+EXPORT_SYMBOL(sdhc_write_protect);
+
+/*
+ *  USB Host2
+ *
+ *  This configuration uses the on-chip FS/LS serial transceiver.
+ *  USBPHY2_{DP,DM} pins are not muxed.
+ *  We just need to grab USBH2_PWR, USBH2_OC and the Bluetooth/USB
+ *  mux control signal.
+ */
+int gpio_usbh2_active(void)
+{
+	if (mxc_request_iomux(MX25_PIN_D9, MUX_CONFIG_ALT6)  ||	/* PWR */
+	    mxc_request_iomux(MX25_PIN_D8, MUX_CONFIG_ALT6)  ||	/* OC */
+	    mxc_request_iomux(MX25_PIN_A21, MUX_CONFIG_ALT5)) {	/* BT_USB_CS */
+		return -EINVAL;
+	}
+
+	/*
+	 * This pin controls the mux that switches between
+	 * the J18 connector and the on-board bluetooth module.
+	 *  dir: 0 = out
+	 *  pin: 0 = J18, 1 = BT
+	 */
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A21), "a21");
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A21), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A21), 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	mxc_free_iomux(MX25_PIN_D9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_D8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_A21, MUX_CONFIG_GPIO);
+}
+
+/*
+ *  USB OTG UTMI
+ *
+ *  This configuration uses the on-chip UTMI transceiver.
+ *  USBPHY1_{VBUS,DP,DM,UID,RREF} pins are not muxed.
+ *  We just need to grab the USBOTG_PWR and USBOTG_OC pins.
+ */
+int gpio_usbotg_utmi_active(void)
+{
+	if (mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT2)  || /* PWR */
+	    mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT2)) {  /* OC */
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_active);
+
+void gpio_usbotg_utmi_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_A), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_B), NULL);
+
+	mxc_free_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_inactive);
+
+/*!
+ * Activate camera sensor
+ */
+void gpio_sensor_active(void)
+{
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_A19, MUX_CONFIG_ALT5); /*CSI_PWDN*/
+	mxc_request_iomux(MX25_PIN_A20, MUX_CONFIG_ALT5); /*CMOS_RST*/
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A19), "a19");
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A20), "a20");
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A19), 0); /*CSI_PWDN*/
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A19), 0);
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A20), 0); /*CMOS_RST*/
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A20), 0);
+	mdelay(20);
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A20), 1);
+
+#define CSI_PAD_CTL1 (PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU)
+#define CSI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU)
+
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, CSI_PAD_CTL1);
+}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Inactivate camera sensor
+ */
+void gpio_sensor_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D6), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D7), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D8), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D9), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_HSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_MCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_PIXCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_VSYNC), NULL);
+
+	mxc_free_iomux(MX25_PIN_A19, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A20, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Activate ESAI ports to enable surround sound I/O
+ */
+void gpio_activate_esai_ports(void)
+{
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT3); /*SCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT3); /*FSR*/
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT3); /*HCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT3); /*SCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_ALT3); /*FST*/
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_ALT3); /*HCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_ALT3); /*TX5_RX0*/
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT3); /*TX4_RX1*/
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT3); /*TX3_RX2*/
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT3); /*TX2_RX3*/
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT3); /*TX1*/
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_ALT3); /*TX0*/
+
+#define ESAI_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU | PAD_CTL_PUE_PUD)
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, ESAI_PAD_CTL);
+
+#undef ESAI_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_activate_esai_ports);
+
+/*!
+ * Inactivate ESAI ports to disable surround sound I/O
+ */
+void gpio_deactivate_esai_ports(void)
+{
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_deactivate_esai_ports);
+
+
+/*!
+ * Activate CAN
+ */
+void gpio_can_active(int id)
+{
+#define CAN_PAD_CTL (PAD_CTL_DRV_3_3V | PAD_CTL_PKE_NONE | PAD_CTL_ODE_CMOS | \
+		     PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW)
+#define CAN_PAD_IN_CTL (PAD_CTL_HYS_CMOS | PAD_CTL_PKE_NONE)
+
+	switch (id) {
+	case 0:
+		/* CAN1 */
+		mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT6); /*RXCAN*/
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_A, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_B, CAN_PAD_IN_CTL);
+
+		mxc_iomux_set_input(MUX_IN_CAN1_IPP_IND_CANRX, INPUT_CTL_PATH1);
+		break;
+	case 1:
+		/* CAN2 */
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT6); /*RXCAN*/
+		mxc_request_iomux(MX25_PIN_D14, MUX_CONFIG_ALT5); /*PWDN*/
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, CAN_PAD_IN_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D14, CAN_PAD_CTL);
+
+		mxc_iomux_set_input(MUX_IN_CAN2_IPP_IND_CANRX, INPUT_CTL_PATH1);
+
+		/* Configure CAN_PWDN as output */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_D14), "d14");
+		gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+
+		/* Enable input by setting PWDN/TLE6250.INH low (gpio4 bit6) */
+		gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_active);
+
+/*!
+ * Inactivate CAN
+ */
+void gpio_can_inactive(int id)
+{
+	switch (id) {
+	case 0:
+		/* CAN1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_A), NULL); /*TXCAN*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_B), NULL); /*RXCAN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_FUNC);
+
+		break;
+	case 1:
+		/* CAN2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*TXCAN*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL); /*RXCAN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_FUNC);
+
+		/* Disable input by setting PWDN/TLE6250.INH high */
+		gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 1);
+		mxc_free_iomux(MX25_PIN_D14, MUX_CONFIG_ALT5);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_inactive);
+
+/*!
+ * This function activates DAM port 4 to enable
+ * audio I/O.
+ */
+void gpio_activate_audio_ports(void)
+{
+	mxc_request_iomux(MX25_PIN_EB0, MUX_CONFIG_ALT4); /*SSI4_STXD*/
+	mxc_request_iomux(MX25_PIN_EB1, MUX_CONFIG_ALT4); /*SSI4_SRXD*/
+	mxc_request_iomux(MX25_PIN_RW, MUX_CONFIG_ALT4); /*SSI4_STXFS*/
+	mxc_request_iomux(MX25_PIN_OE, MUX_CONFIG_ALT4); /*SSI4_SCK*/
+	mxc_request_iomux(MX25_PIN_A10, MUX_CONFIG_ALT5); /*HP_DEC*/
+	mxc_request_iomux(MX25_PIN_D13, MUX_CONFIG_ALT5); /*AMP_SHUTDOWN*/
+
+	mxc_iomux_set_pad(MX25_PIN_EB0, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_EB1, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_RW, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_D13, PAD_CTL_DRV_3_3V);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A10), "a10");
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A10));
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D13), "d13");
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D13), 0);
+}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+/*!
+ * This function deactivates DAM port 4 for
+ * audio I/O
+ */
+void gpio_deactive_audio_ports(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB0), NULL); /*SSI4_STXD*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB1), NULL); /*SSI4_SRXD*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_RW), NULL); /*SSI4_STXFS*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE), NULL); /*SSI4_SCK*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A10), NULL); /*HP_DEC*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D13), NULL); /*AMP_SHUTDOWN*/
+
+	mxc_free_iomux(MX25_PIN_EB0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_EB1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_RW, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A10, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D13, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_deactive_audio_ports);
+
+int headphone_det_status(void)
+{
+	return gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A10));
+}
+EXPORT_SYMBOL(headphone_det_status);
+
+void sgtl5000_enable_amp(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D13), 1);
+}
+EXPORT_SYMBOL(sgtl5000_enable_amp);
diff --git a/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c b/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c
new file mode 100644
index 0000000..6c857d0
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c
@@ -0,0 +1,147 @@
+/*
+ * mx25-3stack-pmic-mc34704.c  --  i.MX25 3STACK Driver for MC34704 PMIC
+ */
+ /*
+  * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc34704/core.h>
+#include "iomux.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+struct mc34704;
+
+static struct regulator_consumer_supply rcpu_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "0-000a",
+	},
+};
+
+static struct regulator_consumer_supply rddr_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDIO",
+		.dev_name = "0-000a",
+	},
+};
+
+static struct regulator_init_data rbklt_init = {
+	.constraints = {
+			.name = "REG1_BKLT",
+			.min_uV =
+			mV_to_uV(REG1_V_MV * (1000 + REG1_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG1_V_MV * (1000 + REG1_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			}
+};
+
+static struct regulator_init_data rcpu_init = {
+	.constraints = {
+			.name = "REG2_CPU",
+			.min_uV =
+			mV_to_uV(REG2_V_MV * (1000 + REG2_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG2_V_MV * (1000 + REG2_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(rcpu_consumers),
+	.consumer_supplies = rcpu_consumers,
+};
+
+static struct regulator_init_data rcore_init = {
+	.constraints = {
+			.name = "REG3_CORE",
+			.min_uV =
+			mV_to_uV(REG3_V_MV * (1000 + REG3_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG3_V_MV * (1000 + REG3_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			}
+};
+
+static struct regulator_init_data rddr_init = {
+	.constraints = {
+			.name = "REG4_DDR",
+			.min_uV =
+			mV_to_uV(REG4_V_MV * (1000 + REG4_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG4_V_MV * (1000 + REG4_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(rddr_consumers),
+	.consumer_supplies = rddr_consumers,
+};
+
+static struct regulator_init_data rpers_init = {
+	.constraints = {
+			.name = "REG5_PERS",
+			.min_uV =
+			mV_to_uV(REG5_V_MV * (1000 + REG5_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG5_V_MV * (1000 + REG5_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			}
+};
+
+static int mc34704_regulator_init(struct mc34704 *mc34704)
+{
+	mc34704_register_regulator(mc34704, MC34704_BKLT, &rbklt_init);
+	mc34704_register_regulator(mc34704, MC34704_CPU, &rcpu_init);
+	mc34704_register_regulator(mc34704, MC34704_CORE, &rcore_init);
+	mc34704_register_regulator(mc34704, MC34704_DDR, &rddr_init);
+	mc34704_register_regulator(mc34704, MC34704_PERS, &rpers_init);
+
+	return 0;
+}
+
+static struct mc34704_platform_data mc34704_plat = {
+	.init = mc34704_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc34704_i2c_device = {
+	.type = "mc34704",
+	.addr = 0x54,
+	.platform_data = &mc34704_plat,
+};
+
+int __init mx25_3stack_init_mc34704(void)
+{
+	return i2c_register_board_info(0, &mc34704_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx25/mx25_pins.h b/arch/arm/mach-mx25/mx25_pins.h
new file mode 100644
index 0000000..ce11f82
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_pins.h
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX25_PINS_H__
+#define __ASM_ARCH_MXC_MX25_PINS_H__
+
+/*!
+ * @file arch-mxc/mx25_pins.h
+ *
+ * @brief MX25 I/O Pin List
+ *
+ * @ingroup GPIO_MX25
+ */
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20 - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   | RSVD  | PAD_I | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (base is IOMUX_module_base ) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Similar field
+ * definitions are used for the pad control register.  For example,
+ * MX25_PIN_A14 is defined in the enumeration:
+ * ( 0x10 << MUX_I) | ( 0x230 << PAD_I)
+ * So the absolute address is: IOMUX_module_base + 0x10.
+ * The pad control register offset is: 0x230.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I		0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * reserved filed
+ */
+#define RSVD_I		21
+
+#define NON_GPIO_I	0x7
+#define PIN_TO_MUX_MASK	((1<<(PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK	((1<<(RSVD_I - PAD_I)) - 1)
+#define NON_MUX_I	PIN_TO_MUX_MASK
+
+#define _MXC_BUILD_PIN(gp, gi, mi, pi) \
+		(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+		((mi) << MUX_I) | ((pi) << PAD_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, pi) \
+		_MXC_BUILD_PIN(gp, gi, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+		_MXC_BUILD_PIN(NON_GPIO_I, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin) ((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin) ((pin >> PAD_I) & PIN_TO_PAD_MASK)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+enum iomux_pins {
+	MX25_PIN_A10 = _MXC_BUILD_GPIO_PIN(3, 0, 0x8, 0x0),
+	MX25_PIN_A13 = _MXC_BUILD_GPIO_PIN(3, 1, 0x0c, 0x22C),
+	MX25_PIN_A14 = _MXC_BUILD_GPIO_PIN(1, 0, 0x10, 0x230),
+	MX25_PIN_A15 = _MXC_BUILD_GPIO_PIN(1, 1, 0x14, 0x234),
+	MX25_PIN_A16 = _MXC_BUILD_GPIO_PIN(1, 2, 0x18, 0x0),
+	MX25_PIN_A17 = _MXC_BUILD_GPIO_PIN(1, 3, 0x1c, 0x238),
+	MX25_PIN_A18 = _MXC_BUILD_GPIO_PIN(1, 4, 0x20, 0x23c),
+	MX25_PIN_A19 = _MXC_BUILD_GPIO_PIN(1, 5, 0x24, 0x240),
+	MX25_PIN_A20 = _MXC_BUILD_GPIO_PIN(1, 6, 0x28, 0x244),
+	MX25_PIN_A21 = _MXC_BUILD_GPIO_PIN(1, 7, 0x2c, 0x248),
+	MX25_PIN_A22 = _MXC_BUILD_GPIO_PIN(1, 8, 0x30, 0x0),
+	MX25_PIN_A23 = _MXC_BUILD_GPIO_PIN(1, 9, 0x34, 0x24c),
+	MX25_PIN_A24 = _MXC_BUILD_GPIO_PIN(1, 10, 0x38, 0x250),
+	MX25_PIN_A25 = _MXC_BUILD_GPIO_PIN(1, 11, 0x3c, 0x254),
+	MX25_PIN_EB0 = _MXC_BUILD_GPIO_PIN(1, 12, 0x40, 0x258),
+	MX25_PIN_EB1 = _MXC_BUILD_GPIO_PIN(1, 13, 0x44, 0x25c),
+	MX25_PIN_OE =  _MXC_BUILD_GPIO_PIN(1, 14, 0x48, 0x260),
+	MX25_PIN_CS0 = _MXC_BUILD_GPIO_PIN(3, 2, 0x4c, 0x0),
+	MX25_PIN_CS1 = _MXC_BUILD_GPIO_PIN(3, 3, 0x50, 0x0),
+	MX25_PIN_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 0x54, 0x264),
+	MX25_PIN_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 0x58, 0x268),
+	MX25_PIN_NF_CE0 = _MXC_BUILD_GPIO_PIN(2, 22, 0x5c, 0x26c),
+	MX25_PIN_ECB = _MXC_BUILD_GPIO_PIN(2, 23, 0x60, 0x270),
+	MX25_PIN_LBA = _MXC_BUILD_GPIO_PIN(2, 24, 0x64, 0x274),
+	MX25_PIN_BCLK = _MXC_BUILD_GPIO_PIN(3, 4, 0x68, 0x0),
+	MX25_PIN_RW = _MXC_BUILD_GPIO_PIN(2, 25, 0x6c, 0x278),
+	MX25_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(2, 26, 0x70, 0x0),
+	MX25_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(2, 27, 0x74, 0x0),
+	MX25_PIN_NFALE = _MXC_BUILD_GPIO_PIN(2, 28, 0x78, 0x0),
+	MX25_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(2, 29, 0x7c, 0x0),
+	MX25_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(2, 30, 0x80, 0x0),
+	MX25_PIN_NFRB = _MXC_BUILD_GPIO_PIN(2, 31, 0x84, 0x27c),
+	MX25_PIN_D15 = _MXC_BUILD_GPIO_PIN(3, 5, 0x88, 0x280),
+	MX25_PIN_D14 = _MXC_BUILD_GPIO_PIN(3, 6, 0x8c, 0x284),
+	MX25_PIN_D13 = _MXC_BUILD_GPIO_PIN(3, 7, 0x90, 0x288),
+	MX25_PIN_D12 = _MXC_BUILD_GPIO_PIN(3, 8, 0x94, 0x28c),
+	MX25_PIN_D11 = _MXC_BUILD_GPIO_PIN(3, 9, 0x98, 0x290),
+	MX25_PIN_D10 = _MXC_BUILD_GPIO_PIN(3, 10, 0x9c, 0x294),
+	MX25_PIN_D9 = _MXC_BUILD_GPIO_PIN(3, 11, 0xa0, 0x298),
+	MX25_PIN_D8 = _MXC_BUILD_GPIO_PIN(3, 12, 0xa4, 0x29c),
+	MX25_PIN_D7 = _MXC_BUILD_GPIO_PIN(3, 13, 0xa8, 0x2a0),
+	MX25_PIN_D6 = _MXC_BUILD_GPIO_PIN(3, 14, 0xac, 0x2a4),
+	MX25_PIN_D5 = _MXC_BUILD_GPIO_PIN(3, 15, 0xb0, 0x2a8),
+	MX25_PIN_D4 = _MXC_BUILD_GPIO_PIN(3, 16, 0xb4, 0x2ac),
+	MX25_PIN_D3 = _MXC_BUILD_GPIO_PIN(3, 17, 0xb8, 0x2b0),
+	MX25_PIN_D2 = _MXC_BUILD_GPIO_PIN(3, 18, 0xbc, 0x2b4),
+	MX25_PIN_D1 = _MXC_BUILD_GPIO_PIN(3, 19, 0xc0, 0x2b8),
+	MX25_PIN_D0 = _MXC_BUILD_GPIO_PIN(3, 20, 0xc4, 0x2bc),
+	MX25_PIN_LD0 = _MXC_BUILD_GPIO_PIN(1, 15, 0xc8, 0x2c0),
+	MX25_PIN_LD1 = _MXC_BUILD_GPIO_PIN(1, 16, 0xcc, 0x2c4),
+	MX25_PIN_LD2 = _MXC_BUILD_GPIO_PIN(1, 17, 0xd0, 0x2c8),
+	MX25_PIN_LD3 = _MXC_BUILD_GPIO_PIN(1, 18, 0xd4, 0x2cc),
+	MX25_PIN_LD4 = _MXC_BUILD_GPIO_PIN(1, 19, 0xd8, 0x2d0),
+	MX25_PIN_LD5 = _MXC_BUILD_GPIO_PIN(0, 19, 0xdc, 0x2d4),
+	MX25_PIN_LD6 = _MXC_BUILD_GPIO_PIN(0, 20, 0xe0, 0x2d8),
+	MX25_PIN_LD7 = _MXC_BUILD_GPIO_PIN(0, 21, 0xe4, 0x2dc),
+	MX25_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(0xe8, 0x2e0),
+	MX25_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(0xec, 0x2e4),
+	MX25_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(0xf0, 0x2e8),
+	MX25_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(0xf4, 0x2ec),
+	MX25_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(0xf8, 0x2f0),
+	MX25_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(0xfc, 0x2f4),
+	MX25_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(0x100, 0x2f8),
+	MX25_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x2fc),
+	MX25_PIN_HSYNC = _MXC_BUILD_GPIO_PIN(0, 22, 0x108, 0x300),
+	MX25_PIN_VSYNC = _MXC_BUILD_GPIO_PIN(0, 23, 0x10c, 0x304),
+	MX25_PIN_LSCLK = _MXC_BUILD_GPIO_PIN(0, 24, 0x110, 0x308),
+	MX25_PIN_OE_ACD = _MXC_BUILD_GPIO_PIN(0, 25, 0x114, 0x30c),
+	MX25_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(0x118, 0x310),
+	MX25_PIN_PWM = _MXC_BUILD_GPIO_PIN(0, 26, 0x11c, 0x314),
+	MX25_PIN_CSI_D2 = _MXC_BUILD_GPIO_PIN(0, 27, 0x120, 0x318),
+	MX25_PIN_CSI_D3 = _MXC_BUILD_GPIO_PIN(0, 28, 0x124, 0x31c),
+	MX25_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(0, 29, 0x128, 0x320),
+	MX25_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(0, 30, 0x12c, 0x324),
+	MX25_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(0, 31, 0x130, 0x328),
+	MX25_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(0, 6, 0x134, 0x32c),
+	MX25_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(0, 7, 0x138, 0x330),
+	MX25_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(3, 21, 0x13c, 0x334),
+	MX25_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(0, 8, 0x140, 0x338),
+	MX25_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(0, 9, 0x144, 0x33c),
+	MX25_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(0, 10, 0x148, 0x340),
+	MX25_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(0, 11, 0x14c, 0x344),
+	MX25_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(0, 12, 0x150, 0x348),
+	MX25_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(0, 13, 0x154, 0x34c),
+	MX25_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(0, 14, 0x158, 0x350),
+	MX25_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(0, 15, 0x15c, 0x354),
+	MX25_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(0, 16, 0x160, 0x358),
+	MX25_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(0, 17, 0x164, 0x35c),
+	MX25_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(0, 18, 0x168, 0x360),
+	MX25_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(1, 22, 0x16c, 0x364),
+	MX25_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 22, 0x170, 0x368),
+	MX25_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 23, 0x174, 0x36c),
+	MX25_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 24, 0x178, 0x370),
+	MX25_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 25, 0x17c, 0x374),
+	MX25_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(3, 26, 0x180, 0x378),
+	MX25_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(3, 27, 0x184, 0x37c),
+	MX25_PIN_UART2_RTS = _MXC_BUILD_GPIO_PIN(3, 28, 0x188, 0x380),
+	MX25_PIN_UART2_CTS = _MXC_BUILD_GPIO_PIN(3, 29, 0x18c, 0x384),
+	MX25_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 23, 0x190, 0x388),
+	MX25_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 24, 0x194, 0x38c),
+	MX25_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 25, 0x198, 0x390),
+	MX25_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 26, 0x19c, 0x394),
+	MX25_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 27, 0x1a0, 0x398),
+	MX25_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 28, 0x1a4, 0x39c),
+	MX25_PIN_KPP_ROW0 = _MXC_BUILD_GPIO_PIN(1, 29, 0x1a8, 0x3a0),
+	MX25_PIN_KPP_ROW1 = _MXC_BUILD_GPIO_PIN(1, 30, 0x1ac, 0x3a4),
+	MX25_PIN_KPP_ROW2 = _MXC_BUILD_GPIO_PIN(1, 31, 0x1b0, 0x3a8),
+	MX25_PIN_KPP_ROW3 = _MXC_BUILD_GPIO_PIN(2, 0, 0x1b4, 0x3ac),
+	MX25_PIN_KPP_COL0 = _MXC_BUILD_GPIO_PIN(2, 1, 0x1b8, 0x3b0),
+	MX25_PIN_KPP_COL1 = _MXC_BUILD_GPIO_PIN(2, 2, 0x1bc, 0x3b4),
+	MX25_PIN_KPP_COL2 = _MXC_BUILD_GPIO_PIN(2, 3, 0x1c0, 0x3b8),
+	MX25_PIN_KPP_COL3 = _MXC_BUILD_GPIO_PIN(2, 4, 0x1c4, 0x3bc),
+	MX25_PIN_FEC_MDC = _MXC_BUILD_GPIO_PIN(2, 5, 0x1c8, 0x3c0),
+	MX25_PIN_FEC_MDIO = _MXC_BUILD_GPIO_PIN(2, 6, 0x1cc, 0x3c4),
+	MX25_PIN_FEC_TDATA0 = _MXC_BUILD_GPIO_PIN(2, 7, 0x1d0, 0x3c8),
+	MX25_PIN_FEC_TDATA1 = _MXC_BUILD_GPIO_PIN(2, 8, 0x1d4, 0x3cc),
+	MX25_PIN_FEC_TX_EN = _MXC_BUILD_GPIO_PIN(2, 9, 0x1d8, 0x3d0),
+	MX25_PIN_FEC_RDATA0 = _MXC_BUILD_GPIO_PIN(2, 10, 0x1dc, 0x3d4),
+	MX25_PIN_FEC_RDATA1 = _MXC_BUILD_GPIO_PIN(2, 11, 0x1e0, 0x3d8),
+	MX25_PIN_FEC_RX_DV = _MXC_BUILD_GPIO_PIN(2, 12, 0x1e4, 0x3dc),
+	MX25_PIN_FEC_TX_CLK = _MXC_BUILD_GPIO_PIN(2, 13, 0x1e8, 0x3e0),
+	MX25_PIN_RTCK = _MXC_BUILD_GPIO_PIN(2, 14, 0x1ec, 0x3e4),
+	MX25_PIN_DE_B = _MXC_BUILD_GPIO_PIN(1, 20, 0x1f0, 0x3ec),
+	MX25_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x3e8),
+	MX25_PIN_GPIO_A = _MXC_BUILD_GPIO_PIN(0, 0, 0x1f4, 0x3f0),
+	MX25_PIN_GPIO_B = _MXC_BUILD_GPIO_PIN(0, 1, 0x1f8, 0x3f4),
+	MX25_PIN_GPIO_C = _MXC_BUILD_GPIO_PIN(0, 2, 0x1fc, 0x3f8),
+	MX25_PIN_GPIO_D = _MXC_BUILD_GPIO_PIN(0, 3, 0x200, 0x3fc),
+	MX25_PIN_GPIO_E = _MXC_BUILD_GPIO_PIN(0, 4, 0x204, 0x400),
+	MX25_PIN_GPIO_F = _MXC_BUILD_GPIO_PIN(0, 5, 0x208, 0x404),
+	MX25_PIN_EXT_ARMCLK = _MXC_BUILD_GPIO_PIN(2, 15, 0x20c, 0x0),
+	MX25_PIN_UPLL_BYPCLK = _MXC_BUILD_GPIO_PIN(2, 16, 0x210, 0x0),
+	MX25_PIN_VSTBY_REQ = _MXC_BUILD_GPIO_PIN(2, 17, 0x214, 0x408),
+	MX25_PIN_VSTBY_ACK = _MXC_BUILD_GPIO_PIN(2, 18, 0x218, 0x40c),
+	MX25_PIN_POWER_FAIL = _MXC_BUILD_GPIO_PIN(2, 19, 0x21c, 0x410),
+	MX25_PIN_CLKO = _MXC_BUILD_GPIO_PIN(1, 21, 0x220, 0x414),
+	MX25_PIN_BOOT_MODE0 = _MXC_BUILD_GPIO_PIN(3, 30, 0x224, 0x0),
+	MX25_PIN_BOOT_MODE1 = _MXC_BUILD_GPIO_PIN(3, 31, 0x228, 0x0),
+
+	MX25_PIN_CTL_GRP_DVS_MISC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x418),
+	MX25_PIN_CTL_GRP_DSE_FEC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x41c),
+	MX25_PIN_CTL_GRP_DVS_JTAG = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x420),
+	MX25_PIN_CTL_GRP_DSE_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x424),
+	MX25_PIN_CTL_GRP_DSE_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x428),
+	MX25_PIN_CTL_GRP_DSE_WEIM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x42c),
+	MX25_PIN_CTL_GRP_DSE_DDR = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x430),
+	MX25_PIN_CTL_GRP_DVS_CRM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x434),
+	MX25_PIN_CTL_GRP_DSE_KPP = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x438),
+	MX25_PIN_CTL_GRP_DSE_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x43c),
+	MX25_PIN_CTL_GRP_DSE_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x440),
+	MX25_PIN_CTL_GRP_DSE_UART = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x444),
+	MX25_PIN_CTL_GRP_DVS_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x448),
+	MX25_PIN_CTL_GRP_DVS_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x44c),
+	MX25_PIN_CTL_GRP_DSE_CSPI1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x450),
+	MX25_PIN_CTL_GRP_DDRTYPE = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x454),
+	MX25_PIN_CTL_GRP_DVS_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x458),
+	MX25_PIN_CTL_GRP_DVS_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x45c)
+};
+
+#endif
+#endif
diff --git a/arch/arm/mach-mx25/pm.c b/arch/arm/mach-mx25/pm.c
new file mode 100644
index 0000000..690bce7
--- /dev/null
+++ b/arch/arm/mach-mx25/pm.c
@@ -0,0 +1,103 @@
+/*
+ *  Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX25 i.MX25 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx25/pm.c
+ * @brief This file contains suspend operations
+ *
+ * @ingroup MSL_MX25
+ */
+static unsigned int cgcr0, cgcr1, cgcr2;
+
+static int mx25_suspend_enter(suspend_state_t state)
+{
+	unsigned int reg;
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* Executing CP15 (Wait-for-Interrupt) Instruction */
+	cpu_do_idle();
+
+	reg = (__raw_readl(MXC_CCM_CGCR0) & ~MXC_CCM_CGCR0_STOP_MODE_MASK) |
+	    cgcr0;
+	__raw_writel(reg, MXC_CCM_CGCR0);
+
+	reg = (__raw_readl(MXC_CCM_CGCR1) & ~MXC_CCM_CGCR1_STOP_MODE_MASK) |
+	    cgcr1;
+	__raw_writel(reg, MXC_CCM_CGCR1);
+
+	reg = (__raw_readl(MXC_CCM_CGCR2) & ~MXC_CCM_CGCR2_STOP_MODE_MASK) |
+	    cgcr2;
+	__raw_writel(reg, MXC_CCM_CGCR2);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx25_suspend_prepare(void)
+{
+	cgcr0 = __raw_readl(MXC_CCM_CGCR0) & MXC_CCM_CGCR0_STOP_MODE_MASK;
+	cgcr1 = __raw_readl(MXC_CCM_CGCR1) & MXC_CCM_CGCR1_STOP_MODE_MASK;
+	cgcr2 = __raw_readl(MXC_CCM_CGCR2) & MXC_CCM_CGCR2_STOP_MODE_MASK;
+
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx25_suspend_finish(void)
+{
+}
+
+static int mx25_pm_valid(suspend_state_t state)
+{
+	return state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX;
+}
+
+struct platform_suspend_ops mx25_suspend_ops = {
+	.valid = mx25_pm_valid,
+	.prepare = mx25_suspend_prepare,
+	.enter = mx25_suspend_enter,
+	.finish = mx25_suspend_finish,
+};
+
+static int __init mx25_pm_init(void)
+{
+	pr_info("Static Power Management for Freescale i.MX25\n");
+	suspend_set_ops(&mx25_suspend_ops);
+
+	return 0;
+}
+
+late_initcall(mx25_pm_init);
diff --git a/arch/arm/mach-mx25/sdma_script_code.h b/arch/arm/mach-mx25/sdma_script_code.h
new file mode 100644
index 0000000..6adacb0
--- /dev/null
+++ b/arch/arm/mach-mx25/sdma_script_code.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/************************************************************************
+
+			SDMA RELEASE LABEL:	"SS15_SENNA"
+
+************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_H
+#define SDMA_SCRIPT_CODE_H
+
+/*!
+ * SDMA ROM scripts start addresses and sizes
+ */
+#define start_ADDR	0
+#define start_SIZE	22
+
+#define core_ADDR	80
+#define core_SIZE	233
+
+#define common_ADDR	313
+#define common_SIZE	416
+
+#define ap_2_ap_ADDR	729
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	770
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	834
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	904
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	979
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	1048
+#define mcu_2_shp_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1120
+#define uartsh_2_mcu_SIZE	69
+
+#define app_2_per_ADDR	1189
+#define app_2_per_SIZE	66
+
+#define per_2_app_ADDR	1255
+#define per_2_app_SIZE	74
+
+#define per_2_shp_ADDR	1329
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1407
+#define shp_2_per_SIZE	72
+
+#define mcu_2_ata_ADDR	1479
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1560
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1656
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1883
+#define test_SIZE	63
+
+#define signature_ADDR	1022
+#define signature_SIZE	1
+
+/*!
+ * SDMA RAM scripts start addresses and sizes
+ */
+#define ext_mem__ipu_ram_ADDR	6144
+#define ext_mem__ipu_ram_SIZE	123
+
+#define uart_2_per_ADDR	6267
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6340
+#define uartsh_2_per_SIZE	67
+
+/*!
+ * SDMA RAM image start address and size
+ */
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			263
+
+/*!
+ * Buffer that holds the SDMA RAM image
+ */
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0x0e70, 0x0611, 0x5616, 0xc18a, 0x7d2a, 0x5ade, 0x008e, 0xc19c,
+	0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5,
+	0xd84f, 0x982b, 0x6b05, 0xc6d8, 0x7e27, 0x7f29, 0x982b, 0x6d01,
+	0x03df, 0x7d05, 0x6bd5, 0xc702, 0x7e18, 0x7f1a, 0x982b, 0x6b05,
+	0xc678, 0x7e07, 0x7f06, 0x52de, 0x53e6, 0xc1a8, 0x7dd7, 0x0200,
+	0x9803, 0x0007, 0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc2ad,
+	0x048b, 0x0498, 0x0454, 0x068a, 0x982b, 0x0207, 0x680c, 0x6ddf,
+	0x0107, 0x68ff, 0x60d0, 0x9834, 0x0207, 0x68ff, 0x6d28, 0x0107,
+	0x6004, 0x680c, 0x9834, 0x0007, 0x68ff, 0x60d0, 0x9834, 0x0288,
+	0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da,
+	0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804,
+	0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf,
+	0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb,
+	0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3,
+	0x65ff, 0x7ed1, 0x0006, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1e, 0x1e94, 0x6ee3,
+	0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb,
+	0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27, 0x6ac8, 0x7f23, 0x2501,
+	0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260,
+	0x7df1, 0x62d0, 0xc2d1, 0x98c0, 0x6ee3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a,
+	0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d09, 0xc251,
+	0x57db, 0x987f, 0x0007, 0x6aff, 0x62d0, 0xc2d1, 0x0458, 0x0454,
+	0x6add, 0x7ff8, 0xc261, 0x987c, 0xc230, 0xc23a, 0x57db, 0x52f3,
+	0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d17, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d26, 0x6ac8,
+	0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc2d1, 0x9903, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d0e, 0x6ac8,
+	0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d0b,
+	0xc251, 0x57db, 0x98c9, 0x0007, 0x6aff, 0x6add, 0x7ffc, 0x62d0,
+	0xc2d1, 0x0458, 0x0454, 0x6add, 0x7ff6, 0xc261, 0x98c6
+};
+#endif
diff --git a/arch/arm/mach-mx25/serial.c b/arch/arm/mach-mx25/serial.c
new file mode 100644
index 0000000..c2310d7
--- /dev/null
+++ b/arch/arm/mach-mx25/serial.c
@@ -0,0 +1,332 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx25/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX25
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <mach/hardware.h>
+#include <mach/mxc_uart.h>
+#include "serial.h"
+#include "board-mx25_3stack.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       },
+#if UART3_ENABLED == 1
+	[2] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#endif
+#if UART4_ENABLED == 1
+	[3] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = UART4_MUX_INTS,
+	       .mode = UART4_MODE,
+	       .ir_mode = UART4_IR,
+	       .enabled = UART4_ENABLED,
+	       .hardware_flow = UART4_HW_FLOW,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_enabled = UART4_DMA_ENABLE,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#endif
+#if UART5_ENABLED == 1
+	[4] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = UART5_MUX_INTS,
+	       .mode = UART5_MODE,
+	       .ir_mode = UART5_IR,
+	       .enabled = UART5_ENABLED,
+	       .hardware_flow = UART5_HW_FLOW,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_enabled = UART5_DMA_ENABLE,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#endif
+};
+
+static struct resource mxc_uart_resources1[] = {
+	{
+		.start = MX25_UART1_BASE_ADDR,
+		.end = MX25_UART1_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = UART1_INT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART1_INT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART1_INT3,
+		.flags = IORESOURCE_IRQ,
+	},
+
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_uart_resources1),
+	.resource = mxc_uart_resources1,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct resource mxc_uart_resources2[] = {
+	{
+		.start = MX25_UART2_BASE_ADDR,
+		.end = MX25_UART2_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = UART2_INT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART2_INT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART2_INT3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources2),
+	.resource = mxc_uart_resources2,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+#if UART3_ENABLED == 1
+static struct resource mxc_uart_resources3[] = {
+	{
+		.start = MX25_UART3_BASE_ADDR,
+		.end = MX25_UART3_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = UART3_INT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART3_INT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART3_INT3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources3),
+	.resource = mxc_uart_resources3,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+#endif
+#if UART4_ENABLED == 1
+static struct resource mxc_uart_resources4[] = {
+	{
+		.start = MX25_UART4_BASE_ADDR,
+		.end = MX25_UART4_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = UART4_INT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART4_INT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART4_INT3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources4),
+	.resource = mxc_uart_resources4,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+#endif
+#if UART5_ENABLED == 1
+static struct resource mxc_uart_resources5[] = {
+	{
+		.start = MX25_UART5_BASE_ADDR,
+		.end = MX25_UART5_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = UART5_INT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART5_INT2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = UART5_INT3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources5),
+	.resource = mxc_uart_resources5,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+#endif
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+#if UART3_ENABLED == 1
+	platform_device_register(&mxc_uart_device3);
+#endif				/* UART3_ENABLED */
+#if UART4_ENABLED == 1
+	platform_device_register(&mxc_uart_device4);
+#endif				/* UART4_ENABLED */
+#if UART5_ENABLED == 1
+	platform_device_register(&mxc_uart_device5);
+#endif				/* UART5_ENABLED */
+
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx25/serial.h b/arch/arm/mach-mx25/serial.h
new file mode 100644
index 0000000..c6e77f9
--- /dev/null
+++ b/arch/arm/mach-mx25/serial.h
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_SERIAL_H__
+#define __ARCH_ARM_MACH_MX25_SERIAL_H__
+
+/*!
+ * @file mach-mx25/serial.h
+ *
+ * @ingroup MSL_MX25
+ */
+#include <mach/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        (-1)
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        1
+#define UART4_DMA_RXBUFSIZE     1024
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        1
+#define UART5_DMA_RXBUFSIZE     1024
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MX25_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              (-1)
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              (-1)
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MX25_INT_UART2
+#define UART2_INT2              (-1)
+#define UART2_INT3              (-1)
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MX25_INT_UART3
+#define UART3_INT2              (-1)
+#define UART3_INT3              (-1)
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              MX25_INT_UART4
+#define UART4_INT2              (-1)
+#define UART4_INT3              (-1)
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              MX25_INT_UART5
+#define UART5_INT2              (-1)
+#define UART5_INT3              (-1)
+
+#endif				/* __ARCH_ARM_MACH_MX25_SERIAL_H__ */
diff --git a/arch/arm/mach-mx25/system.c b/arch/arm/mach-mx25/system.c
new file mode 100644
index 0000000..f70b601
--- /dev/null
+++ b/arch/arm/mach-mx25/system.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX25 i.MX25 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx25/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * MX25 low-power mode
+ */
+enum mx25_low_pwr_mode {
+	MX25_RUN_MODE,
+	MX25_WAIT_MODE,
+	MX25_DOZE_MODE,
+	MX25_STOP_MODE
+};
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function is used to set cpu low power mode before WFI instruction
+ *
+ * @param  mode         indicates different kinds of power modes
+ */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	unsigned int lpm;
+	unsigned long reg;
+	unsigned int pmcr1, pmcr2, lpimr;
+	unsigned int cgcr0, cgcr1, cgcr2;
+	struct irq_desc *desc;
+	int i;
+
+	/*read CCTL value */
+	reg = __raw_readl(MXC_CCM_CCTL);
+
+	switch (mode) {
+	case WAIT_UNCLOCKED_POWER_OFF:
+		lpm = MX25_DOZE_MODE;
+		break;
+
+	case STOP_POWER_ON:
+	case STOP_POWER_OFF:
+		lpm = MX25_STOP_MODE;
+		/* The clock of LCDC/SLCDC, SDMA, RTIC, RNGC, MAX, CAN
+		   and EMI needs to be gated on when entering Stop mode.
+		 */
+		cgcr0 = __raw_readl(MXC_CCM_CGCR0);
+		cgcr1 = __raw_readl(MXC_CCM_CGCR1);
+		cgcr2 = __raw_readl(MXC_CCM_CGCR2);
+		__raw_writel(cgcr0 | MXC_CCM_CGCR0_STOP_MODE_MASK,
+			     MXC_CCM_CGCR0);
+		__raw_writel(cgcr1 | MXC_CCM_CGCR1_STOP_MODE_MASK,
+			     MXC_CCM_CGCR1);
+		__raw_writel(cgcr2 | MXC_CCM_CGCR2_STOP_MODE_MASK,
+			     MXC_CCM_CGCR2);
+		/* The interrupts which are not wake-up sources need
+		   be mask when entering Stop mode.
+		 */
+		lpimr = MXC_CCM_LPIMR0_MASK;
+		for (i = 0; i < 32; i++) {
+			desc = irq_desc + i;
+			if ((desc->status & IRQ_WAKEUP) != 0)
+				lpimr &= ~(1 << i);
+		}
+		__raw_writel(lpimr, MXC_CCM_LPIMR0);
+		lpimr = MXC_CCM_LPIMR1_MASK;
+		for (i = 32; i < 64; i++) {
+			desc = irq_desc + i;
+			if ((desc->status & IRQ_WAKEUP) != 0)
+				lpimr &= ~(1 << (i - 32));
+		}
+		__raw_writel(lpimr, MXC_CCM_LPIMR1);
+
+		if (mode == STOP_POWER_OFF) {
+			pmcr2 = __raw_readl(MXC_CCM_PMCR2);
+			pmcr2 |= (MXC_CCM_PMCR2_OSC24M_DOWN |
+				  MXC_CCM_PMCR2_VSTBY);
+			__raw_writel(pmcr2, MXC_CCM_PMCR2);
+			pmcr1 = __raw_readl(MXC_CCM_PMCR1);
+			pmcr1 &= ~(MXC_CCM_PMCR1_WBCN_MASK |
+				   MXC_CCM_PMCR1_CSPAEM_MASK |
+				   MXC_CCM_PMCR1_CSPA_MASK);
+			pmcr1 |= MXC_CCM_PMCR1_AWB_DEFAULT;
+			__raw_writel(pmcr1, MXC_CCM_PMCR1);
+		}
+		break;
+
+	case WAIT_CLOCKED:
+	case WAIT_UNCLOCKED:
+	default:
+		/* Wait is the default mode used when idle. */
+		lpm = MX25_WAIT_MODE;
+		break;
+	}
+
+	/* program LP CTL bit */
+	reg = ((reg & (~MXC_CCM_CCTL_LP_CTL_MASK)) |
+	       lpm << MXC_CCM_CCTL_LP_CTL_OFFSET);
+
+	__raw_writel(reg, MXC_CCM_CCTL);
+}
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled) {
+		/* set as Wait mode */
+		mxc_cpu_lp_set(WAIT_UNCLOCKED);
+		cpu_do_idle();
+	}
+}
+
+#if 0
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	/* Assert SRS signal */
+	mxc_wd_reset();
+}
+#endif
diff --git a/arch/arm/mach-mx25/usb.h b/arch/arm/mach-mx25/usb.h
new file mode 100644
index 0000000..b1c21a7
--- /dev/null
+++ b/arch/arm/mach-mx25/usb.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
diff --git a/arch/arm/mach-mx25/usb_dr.c b/arch/arm/mach-mx25/usb_dr.c
new file mode 100644
index 0000000..4a410ed
--- /dev/null
+++ b/arch/arm/mach-mx25/usb_dr.c
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable);
+
+/*
+ * platform data structs
+ *	- Which one to use is determined by CONFIG options in usb.h
+ *	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* via RT9706 */
+	.gpio_usb_active   = gpio_usbotg_utmi_active,
+	.gpio_usb_inactive = gpio_usbotg_utmi_inactive,
+	.transceiver       = "utmi",
+	.wake_up_enable = _wake_up_enable,
+};
+
+/*
+ * resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+	       .start = (u32)(USB_OTGREGS_BASE),
+	       .end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_USB_OTG,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ *	dev.platform_data field plugged at run time
+ */
+static struct platform_device __maybe_unused dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (get_usb_mode(pdata) == FSL_USB_DR_DEVICE) {
+		if (enable)
+			USBCTRL |= (UCTRL_OWIE | UCTRL_VBUS_WKUP_EN);
+		else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL &= ~UCTRL_VBUS_WKUP_EN;
+		}
+	} else {
+		if (enable)
+			USBCTRL |= UCTRL_OWIE;
+		else
+			USBCTRL &= ~UCTRL_OWIE;
+	}
+}
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx25/usb_h2.c b/arch/arm/mach-mx25/usb_h2.c
new file mode 100644
index 0000000..ba29172
--- /dev/null
+++ b/arch/arm/mach-mx25/usb_h2.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 500,		/* via RT9702 */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "serial",		/* on-chip */
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H2REGS_BASE),
+	       .end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_USB_HTG,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+void usbh2_get_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO1");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+	    xcvr_pwr->regu1 = usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO3");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+	    xcvr_pwr->regu2 = usbh2_regux;
+}
+EXPORT_SYMBOL(usbh2_get_xcvr_power);
+
+void usbh2_put_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+		       platform_data)->xcvr_pwr->regu2;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux);
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+		       platform_data)->xcvr_pwr->regu1;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux);
+}
+EXPORT_SYMBOL(usbh2_put_xcvr_power);
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+module_init(usbh2_init);
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index 2395f78..26b0e96 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y :=cpu.o cpu_common.o system.o gpio.o clock.o snoop.o io.o time.o devices.o
+obj-y :=cpu.o cpu_common.o system.o gpio.o clock.o snoop.o io.o time.o devices.o usb_common.o
 
 obj-$(CONFIG_IRAM_ALLOC) += iram.o
 
@@ -34,7 +34,7 @@ obj-y += sdma/
 endif
 
 obj-$(CONFIG_ARCH_MX37) += dptc.o dvfs_core.o
-obj-$(CONFIG_ARCH_MX5) += dvfs_core.o usb_common.o
+obj-$(CONFIG_ARCH_MX5) += dvfs_core.o
 
 # CPU FREQ support
 obj-$(CONFIG_CPU_FREQ_IMX)    += cpufreq.o
diff --git a/arch/arm/plat-mxc/cpu_common.c b/arch/arm/plat-mxc/cpu_common.c
index 265f838..dba08ba 100644
--- a/arch/arm/plat-mxc/cpu_common.c
+++ b/arch/arm/plat-mxc/cpu_common.c
@@ -28,9 +28,10 @@ extern int mxc_early_serial_console_init(unsigned long base, struct clk *clk);
  * @ingroup MSL_MX31 MSL_MXC91321
  */
 
-static void __init system_rev_setup(char **p)
+static int __init system_rev_setup(char *p)
 {
-	system_rev = simple_strtoul(*p, NULL, 16);
+	system_rev = simple_strtoul(p, NULL, 16);
+	return 0;
 }
 early_param("system_rev=", system_rev_setup);
 
@@ -44,28 +45,30 @@ int uart_at_24; 			/* OFF: 0 (default); ON: 1 */
  *       "off" -- JTAG is disconnected, so WFI is enabled
  */
 
-static void __init jtag_wfi_setup(char **p)
+static int __init jtag_wfi_setup(char *p)
 {
-	if (memcmp(*p, "on", 2) == 0) {
+	if (memcmp(p, "on", 2) == 0) {
 		mxc_jtag_enabled = 1;
-		*p += 2;
-	} else if (memcmp(*p, "off", 3) == 0) {
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
 		mxc_jtag_enabled = 0;
-		*p += 3;
+		p += 3;
 	}
+	return 0;
 }
 early_param("jtag=", jtag_wfi_setup);
 
-static void __init uart_parent_setup(char **p)
+static int __init uart_parent_setup(char *p)
 {
-	if (memcmp(*p, "on", 2) == 0) {
+	if (memcmp(p, "on", 2) == 0) {
 		/* set the UART parent clock to be lp-apm */
 		uart_at_24 = 1;
-		*p += 2;
-	} else if (memcmp(*p, "off", 3) == 0) {
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
 		uart_at_24 = 0;
-		*p += 3;
+		p += 3;
 	}
+	return 0;
 }
 early_param("debug_uart=", uart_parent_setup);
 
diff --git a/arch/arm/plat-mxc/include/mach/mx25.h b/arch/arm/plat-mxc/include/mach/mx25.h
index 4eb6e33..faba051 100644
--- a/arch/arm/plat-mxc/include/mach/mx25.h
+++ b/arch/arm/plat-mxc/include/mach/mx25.h
@@ -1,6 +1,26 @@
 #ifndef __MACH_MX25_H__
 #define __MACH_MX25_H__
 
+/*
+ * IRAM
+ */
+#define MX25_IRAM_BASE_ADDR       0x78000000	/* internal ram */
+#define MX25_IRAM_SIZE            SZ_128K
+#define IRAM_SIZE MX25_IRAM_SIZE
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x10000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+#define USB_IRAM_SIZE	SZ_8K
+#else
+#define USB_IRAM_SIZE 0
+#endif
+
 #define MX25_AIPS1_BASE_ADDR		0x43f00000
 #define MX25_AIPS1_BASE_ADDR_VIRT	0xfc000000
 #define MX25_AIPS1_SIZE			SZ_1M
@@ -11,11 +31,54 @@
 #define MX25_AVIC_BASE_ADDR_VIRT	0xfc400000
 #define MX25_AVIC_SIZE			SZ_1M
 
+#define MX25_MAX_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x04000)
+#define MX25_CLKCTL_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x08000)
+#define MX25_ETB_SLOT4_BASE_ADDR	(MX25_AIPS1_BASE_ADDR + 0x0c000)
+#define MX25_ETB_SLOT5_BASE_ADDR	(MX25_AIPS1_BASE_ADDR + 0x10000)
+#define MX25_AAPE_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x14000)
+#define MX25_I2C_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x80000)
+#define MX25_I2C3_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x84000)
+#define MX25_CAN1_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x88000)
+#define MX25_CAN3_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x8c000)
+#define MX25_I2C2_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x98000)
+#define MX25_OWIRE_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x9c000)
+#define MX25_ATA_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa0000)
+#define MX25_CSPI1_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa4000)
+#define MX25_KPP_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa8000)
 #define MX25_IOMUXC_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xac000)
+#define MX25_AUDMUX_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xb0000)
+#define MX25_ECT_A_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xb8000)
+#define MX25_ECT_B_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xbc000)
 
+#define MX25_CCM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x80000)
 #define MX25_CRM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x80000)
+#define MX25_GPT4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x84000)
+#define MX25_GPT3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x88000)
+#define MX25_GPT2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x8c000)
 #define MX25_GPT1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x90000)
+#define MX25_EPIT1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x94000)
+#define MX25_EPIT2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x98000)
+#define MX25_GPIO4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x9c000)
+#define MX25_PWM2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa0000)
+#define MX25_GPIO3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa4000)
+#define MX25_PWM3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa8000)
+#define MX25_SCC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xac000)
+#define MX25_RNGB_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xb0000)
+#define MX25_MMC_SDHC1_BASE_ADDR	(MX25_AIPS2_BASE_ADDR + 0xb4000)
+#define MX25_MMC_SDHC2_BASE_ADDR	(MX25_AIPS2_BASE_ADDR + 0xb8000)
+#define MX25_SLCDC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xc0000)
+#define MX25_PWM4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xc8000)
+#define MX25_GPIO1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xcc000)
+#define MX25_GPIO2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xd0000)
+#define MX25_SDMA_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xd4000)
 #define MX25_WDOG_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xdc000)
+#define MX25_PWM1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xe0000)
+#define MX25_RTIC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xec000)
+#define MX25_IIM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf0000)
+#define MX25_USBOTG_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf4000)
+#define OTG_BASE_ADDR			MX25_USBOTG_BASE_ADDR
+#define MX25_CSI_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf8000)
+#define MX25_SRTC_BASE_ADDR		(DRYICE_BASE_ADDR)
 
 #define MX25_GPIO1_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0xcc000)
 #define MX25_GPIO2_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0xd0000)
@@ -27,6 +90,8 @@
 	IMX_IO_ADDRESS(x, MX25_AIPS2) ?:			\
 	IMX_IO_ADDRESS(x, MX25_AVIC))
 
+#define IO_ADDRESS MX25_IO_ADDRESS
+
 #define MX25_UART1_BASE_ADDR		0x43f90000
 #define MX25_UART2_BASE_ADDR		0x43f94000
 
@@ -34,15 +99,194 @@
 #define MX25_NFC_BASE_ADDR		0xbb000000
 #define MX25_DRYICE_BASE_ADDR		0x53ffc000
 #define MX25_LCDC_BASE_ADDR		0x53fbc000
+#define LCDC_BASE_ADDR			MX25_LCDC_BASE_ADDR
+
+#define MX25_SPBA0_BASE_ADDR		0x50000000
+#define MX25_SPBA0_BASE_ADDR_VIRT	0xfc100000
+#define MX25_SPBA0_SIZE			SZ_1M
+
+#define MX25_CSPI3_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x04000)
+#define MX25_UART4_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x08000)
+#define MX25_UART3_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x0c000)
+#define MX25_CSPI2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x10000)
+#define MX25_SSI2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x14000)
+#define MX25_ESAI_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x18000)
+#define MX25_ATA_DMA_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x20000)
+#define MX25_SIM1_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x24000)
+#define MX25_SIM2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x28000)
+#define MX25_UART5_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x2c000)
+#define MX25_TSC_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x30000)
+#define MX25_SSI1_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x34000)
+#define MX25_SPBA_CTRL_BASE_ADDR	(MX25_SPBA0_BASE_ADDR + 0x3c000)
 
+/*
+ *  Interrupt numbers
+ */
+
+#define MX25_INT_CSPI3		0
+#define MX25_INT_GPT4		1
+#define MX25_INT_OWIRE		2
+#define MX25_INT_I2C		3
+#define MX25_INT_I2C2		4
+#define MX25_INT_UART4		5
+#define MX25_INT_RTIC		6
+#define MX25_INT_ESAI		7
+#define MX25_INT_SDHC2		8
+#define MX25_INT_SDHC1		9
+#define MX25_INT_I2C3		10
+#define MX25_INT_SSI2		11
+#define MX25_INT_SSI1		12
+#define MX25_INT_CSPI2		13
+#define MX25_INT_CSPI1		14
+#define MX25_INT_ATA		15
+#define MX25_INT_GPIO3		16
+#define MX25_INT_CSI		17
+#define MX25_INT_UART3		18
+#define MX25_INT_IIM		19
+#define MX25_INT_SIM1		20
+#define MX25_INT_SIM2		21
+#define MX25_INT_RNG		22
+#define MX25_INT_GPIO4		23
+#define MX25_INT_KPP		24
 #define MX25_INT_DRYICE	25
-#define MX25_INT_FEC	57
+#define MX25_INT_PWM		26
+#define MX25_INT_EPIT2		27
+#define MX25_INT_EPIT1		28
+#define MX25_INT_GPT3		29
+#define MX25_INT_POWER_FAIL	30
+#define MX25_INT_CRM		31
+#define MX25_INT_UART2		32
 #define MX25_INT_NANDFC	33
+#define MX25_INT_SDMA		34
+#define MX25_INT_USB_HTG	35
+#define MX25_INT_PWM2		36
+#define MX25_INT_USB_OTG	37
+#define MX25_INT_SLCDC		38
 #define MX25_INT_LCDC	39
+#define MX25_INT_UART5		40
+#define MX25_INT_PWM3		41
+#define MX25_INT_PWM4		42
+#define MX25_INT_CAN1		43
+#define MX25_INT_CAN2		44
+#define MX25_INT_UART1		45
+#define MX25_INT_TSC		46
+#define MX25_INT_ECT		48
+#define MX25_INT_SCC_SCM	49
+#define MX25_INT_SCC_SMN	50
+#define MX25_INT_GPIO2		51
+#define MX25_INT_GPIO1		52
+#define MX25_INT_GPT2		53
+#define MX25_INT_GPT1		54
+#define MX25_INT_WDOG		55
+#define MX25_INT_DRYICE_SEC	56
+#define MX25_INT_FEC		57
+#define MX25_INT_EXT_INT5	58
+#define MX25_INT_EXT_INT4	59
+#define MX25_INT_EXT_INT3	60
+#define MX25_INT_EXT_INT2	61
+#define MX25_INT_EXT_INT1	62
+#define MX25_INT_EXT_INT0	63
+
+#define MXC_INT_LCDC		MX25_INT_LCDC
+#define MXC_INT_GPT		MX25_INT_GPT1
+#define MXC_INT_CSI		MX25_INT_CSI
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_IRAM         30
+#define MXC_DMA_CHANNEL_UART1_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1         MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX      MXC_DMA_DYNAMIC_CHANNEL
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI1_TX      (MXC_DMA_CHANNEL_IRAM + 1)
+#else
+#define MXC_DMA_CHANNEL_SSI1_TX      MXC_DMA_DYNAMIC_CHANNEL
+#endif
+#define MXC_DMA_CHANNEL_SSI2_RX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_RX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_TX      MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_EXTREQ0    0
+#define DMA_REQ_CCM        1
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_UART3_RX   10
+#define DMA_REQ_UART3_TX   11
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_EXTREQ1    14
+#define DMA_REQ_EXTREQ2    15
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_SSI2_RX1   22
+#define DMA_REQ_SSI2_TX1   23
+#define DMA_REQ_SSI2_RX0   24
+#define DMA_REQ_SSI2_TX0   25
+#define DMA_REQ_SSI1_RX1   26
+#define DMA_REQ_SSI1_TX1   27
+#define DMA_REQ_SSI1_RX0   28
+#define DMA_REQ_SSI1_TX0   29
+#define DMA_REQ_NFC        30
+#define DMA_REQ_ECT        31
+#define DMA_REQ_ESAI_RX    32
+#define DMA_REQ_ESAI_TX    33
+#define DMA_REQ_CSPI3_RX   34
+#define DMA_REQ_CSPI3_TX   35
+#define DMA_REQ_SIM2_RX    36
+#define DMA_REQ_SIM2_TX    37
+#define DMA_REQ_SIM1_RX    38
+#define DMA_REQ_SIM1_TX    39
+#define DMA_REQ_TSC_GCQ    44
+#define DMA_REQ_TSC_TCQ    45
+#define DMA_REQ_UART5_RX   46
+#define DMA_REQ_UART5_TX   47
+
+#define IS_MEM_DEVICE_NONSHARED(x)	0
+
+/*!
+ * NFMS bit in RCSR register for pagesize of nandflash
+ */
+#define NFMS (*((volatile u32 *)IO_ADDRESS(MX25_CCM_BASE_ADDR + 0x28)))
+#define NFMS_NF_DWIDTH		14
+#define NFMS_NF_PG_SZ		8
 
 #if defined(IMX_NEEDS_DEPRECATED_SYMBOLS)
 #define UART1_BASE_ADDR			MX25_UART1_BASE_ADDR
 #define UART2_BASE_ADDR			MX25_UART2_BASE_ADDR
 #endif
 
+#define CSI_BASE_ADDR			MX25_CSI_BASE_ADDR
+#define AUDMUX_BASE_ADDR		MX25_AUDMUX_BASE_ADDR
+#define MXC_INT_ESAI			MX25_INT_ESAI
+
 #endif /* ifndef __MACH_MX25_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 1b274a0..f2b9608 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -236,7 +236,7 @@ struct mxc_unifi_platform_data *get_unifi_plat_data(void);
 #define MUX_IO_P		29
 #define MUX_IO_I		24
 
-#ifdef CONFIG_ARCH_MX5
+#if defined(CONFIG_ARCH_MX5) || defined(CONFIG_ARCH_MX25)
 #define IOMUX_TO_GPIO(pin) 	((((unsigned int)pin >> MUX_IO_P) * 32) + ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) - 1)))
 #define IOMUX_TO_IRQ(pin)	(MXC_GPIO_IRQ_START + IOMUX_TO_GPIO(pin))
 #endif
-- 
1.5.4.4

