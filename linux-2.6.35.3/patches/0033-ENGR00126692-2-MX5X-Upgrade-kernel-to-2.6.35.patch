From 4dcb1e4f577f7331930301798da548447208f35a Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <Dinh.Nguyen@freescale.com>
Date: Mon, 14 Jun 2010 16:59:21 -0500
Subject: [PATCH] ENGR00126692-2: MX5X: Upgrade kernel to 2.6.35

This patch contains changes to mach-mx5 files.
Contains all checkpatch and copyright fixes.

Acked-by: Rob Herring <r.herring@freescale.com>
Signed-off-by: Dinh Nguyen <Dinh.Nguyen@freescale.com>
---
 arch/arm/configs/imx5_defconfig               | 2194 +++++++++++
 arch/arm/configs/imx5_updater_defconfig       | 1696 +++++++++
 arch/arm/mach-mx5/Kconfig                     |   75 +-
 arch/arm/mach-mx5/Makefile                    |   11 +-
 arch/arm/mach-mx5/Makefile.boot               |   12 +-
 arch/arm/mach-mx5/bus_freq.c                  |  566 +++
 arch/arm/mach-mx5/clock.c                     | 4908 +++++++++++++++++++++++++
 arch/arm/mach-mx5/clock_mx50.c                | 3200 ++++++++++++++++
 arch/arm/mach-mx5/cpu.c                       |  158 +-
 arch/arm/mach-mx5/crm_regs.h                  |  628 +++-
 arch/arm/mach-mx5/devices.c                   | 1593 ++++++++-
 arch/arm/mach-mx5/devices.h                   |   75 +-
 arch/arm/mach-mx5/dma.c                       | 1428 +++++++
 arch/arm/mach-mx5/dummy_gpio.c                |  119 +
 arch/arm/mach-mx5/early_setup.c               |   29 +
 arch/arm/mach-mx5/iomux.c                     |  268 ++
 arch/arm/mach-mx5/iomux.h                     |  202 +
 arch/arm/mach-mx5/lpmodes.c                   |  308 ++
 arch/arm/mach-mx5/mm.c                        |   84 +-
 arch/arm/mach-mx5/mx50_arm2.c                 |  803 ++++
 arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c    |  419 +++
 arch/arm/mach-mx5/mx50_suspend.S              |  220 ++
 arch/arm/mach-mx5/mx51_3stack.c               | 1075 ++++++
 arch/arm/mach-mx5/mx51_3stack_gpio.c          |  852 +++++
 arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c  |  354 ++
 arch/arm/mach-mx5/mx51_babbage.c              | 1276 +++++++
 arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c |  420 +++
 arch/arm/mach-mx5/mx51_pins.h                 |  409 ++
 arch/arm/mach-mx5/mx53_evk.c                  | 1680 +++++++++
 arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c     |  347 ++
 arch/arm/mach-mx5/pm.c                        |  251 ++
 arch/arm/mach-mx5/sdma_script_code.h          |  170 +
 arch/arm/mach-mx5/sdma_script_code_mx50.h     |  129 +
 arch/arm/mach-mx5/sdma_script_code_mx53.h     |  193 +
 arch/arm/mach-mx5/sdram_autogating.c          |  201 +
 arch/arm/mach-mx5/serial.c                    |  278 ++
 arch/arm/mach-mx5/serial.h                    |   66 +
 arch/arm/mach-mx5/suspend.S                   |  153 +
 arch/arm/mach-mx5/system.c                    |  161 +
 arch/arm/mach-mx5/usb.h                       |   48 +
 arch/arm/mach-mx5/usb_dr.c                    |  164 +
 arch/arm/mach-mx5/usb_h1.c                    |  190 +
 arch/arm/mach-mx5/usb_h2.c                    |   74 +
 arch/arm/mach-mx5/wfi.S                       |  426 +++
 arch/arm/plat-mxc/Kconfig                     |    1 -
 arch/arm/plat-mxc/include/mach/arc_otg.h      |    7 +-
 arch/arm/plat-mxc/include/mach/common.h       |   11 +-
 arch/arm/plat-mxc/include/mach/hardware.h     |    3 +
 arch/arm/plat-mxc/include/mach/iomux-mx50.h   |  513 +++
 arch/arm/plat-mxc/include/mach/iomux-mx51.h   |  467 ++-
 arch/arm/plat-mxc/include/mach/iomux-mx53.h   |  577 +++
 arch/arm/plat-mxc/include/mach/iomux-v3.h     |    2 +
 arch/arm/plat-mxc/include/mach/memory.h       |    3 +
 arch/arm/plat-mxc/include/mach/mx5x.h         |  645 ++++
 arch/arm/plat-mxc/include/mach/mxc.h          |   21 +-
 arch/arm/plat-mxc/system.c                    |   11 +-
 arch/arm/plat-mxc/tzic.c                      |  123 +-
 arch/arm/plat-mxc/usb_common.c                |   39 +-
 58 files changed, 29719 insertions(+), 617 deletions(-)

diff --git a/arch/arm/configs/imx5_defconfig b/arch/arm/configs/imx5_defconfig
new file mode 100644
index 0000000..9bc2c89
--- /dev/null
+++ b/arch/arm/configs/imx5_defconfig
@@ -0,0 +1,2194 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Wed Jul 14 13:56:00 2010
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=96
+CONFIG_UTMI_MXC=y
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX37 is not set
+CONFIG_ARCH_MX5=y
+CONFIG_MXC_SDMA_API=y
+CONFIG_SDMA_IRAM=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ARCH_MXC_HAS_NFC_V3=y
+CONFIG_ARCH_MX51=y
+CONFIG_ARCH_MX53=y
+CONFIG_ARCH_MX50=y
+CONFIG_MX5_OPTIONS=y
+CONFIG_MX5_MULTI_ARCH=y
+CONFIG_MACH_MX51_3DS=y
+CONFIG_MACH_MX51_BABBAGE=y
+CONFIG_MACH_MX53_EVK=y
+CONFIG_MACH_MX50_ARM2=y
+CONFIG_ARCH_MXC_IOMUX_V3=y
+
+#
+# MX5x Options:
+#
+CONFIG_ARCH_MXC_HAS_NFC_V3_2=y
+CONFIG_MXC_TZIC=y
+CONFIG_ISP1504_MXC=y
+# CONFIG_MXC_IRQ_PRIOR is not set
+CONFIG_MXC_PWM=y
+CONFIG_MXC_DVFS_PER=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HIGHMEM=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+CONFIG_RUNTIME_PHYS_OFFSET=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_IMX=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_APM_EMULATION=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+
+#
+# CAN Device Drivers
+#
+CONFIG_CAN_VCAN=y
+# CONFIG_CAN_DEV is not set
+CONFIG_CAN_DEBUG_DEVICES=y
+CONFIG_CAN_FLEXCAN=y
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=y
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=y
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_MXC_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_IMX_NFC is not set
+CONFIG_MTD_NAND_MXC_V3=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=m
+# CONFIG_ATA_NONSTANDARD is not set
+# CONFIG_SATA_PMP is not set
+CONFIG_SATA_AHCI_PLATFORM=m
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_MV is not set
+# CONFIG_PATA_PLATFORM is not set
+CONFIG_PATA_FSL=m
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+CONFIG_SMSC911X=y
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+CONFIG_FEC=y
+# CONFIG_FEC_1588 is not set
+# CONFIG_FEC2 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_LIBERTAS is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_ATH6K_LEGACY=m
+CONFIG_AR600x_SD31_XXX=y
+# CONFIG_AR600x_WB31_XXX is not set
+# CONFIG_AR600x_SD32_XXX is not set
+# CONFIG_AR600x_CUSTOM_XXX is not set
+# CONFIG_ATH6KL_ENABLE_COEXISTENCE is not set
+# CONFIG_ATH6KL_HCI_BRIDGE is not set
+# CONFIG_ATH6KL_CFG80211 is not set
+# CONFIG_ATH6KL_HTC_RAW_INTERFACE is not set
+# CONFIG_ATH6KL_VIRTUAL_SCATTER_GATHER is not set
+CONFIG_ATH6KL_DEBUG=y
+# CONFIG_ATH6KL_ENABLE_HOST_DEBUG is not set
+CONFIG_ATH6KL_ENABLE_TARGET_DEBUG_PRINTS=y
+CONFIG_AR600x_DEBUG_UART_TX_PIN=8
+# CONFIG_ATH6KL_DISABLE_TARGET_DBGLOGS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_APMPOWER is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_FM_SI4702=m
+CONFIG_MXC_IIM=y
+CONFIG_MXS_VIIM=y
+CONFIG_IMX_SIM=m
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_IMX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_IMX is not set
+CONFIG_I2C_MXC=y
+CONFIG_I2C_MXC_HS=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=m
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=m
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2751 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2438=m
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_APM_POWER=y
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_SENSORS_ISL29003=y
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+CONFIG_VIDEO_MXC_CAMERA=m
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+# CONFIG_VIDEO_MXC_CSI_CAMERA is not set
+# CONFIG_MXC_CAMERA_MC521DA is not set
+# CONFIG_MXC_EMMA_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640_EMMA is not set
+# CONFIG_MXC_CAMERA_MICRON111 is not set
+# CONFIG_MXC_CAMERA_OV2640 is not set
+CONFIG_MXC_CAMERA_OV3640=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_PRP_VF_SDC=m
+CONFIG_MXC_IPU_PRP_ENC=m
+CONFIG_MXC_IPU_CSI_ENC=m
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+# CONFIG_VIDEO_MXC_IPUV1_WVGA_OUTPUT is not set
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL=y
+CONFIG_FB_MXC_TVOUT_TVE=y
+CONFIG_FB_MXC_LDB=y
+# CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
+CONFIG_FB_MXC_CH7026=y
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+CONFIG_FB_MXC_EINK_PANEL=y
+# CONFIG_FB_MXC_EINK_AUTO_UPDATE_MODE is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_MC13892=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_MXC_SPDIF=m
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_MXC_SOC=y
+CONFIG_SND_MXC_SOC_SSI=y
+CONFIG_SND_MXC_SOC_ESAI=y
+CONFIG_SND_MXC_SOC_IRAM=y
+CONFIG_SND_SOC_IMX_3STACK_SGTL5000=y
+# CONFIG_SND_SOC_IMX_3STACK_AK4647 is not set
+# CONFIG_SND_SOC_IMX_3STACK_WM8580 is not set
+# CONFIG_SND_SOC_IMX_3STACK_AK5702 is not set
+# CONFIG_SND_SOC_IMX_3STACK_BLUETOOTH is not set
+CONFIG_SND_SOC_IMX_3STACK_CS42888=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_CS42888=y
+CONFIG_SND_SOC_SGTL5000=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CYPRESS=m
+# CONFIG_HID_DRAGONRISE is not set
+CONFIG_HID_EZKEY=m
+# CONFIG_HID_KYE is not set
+CONFIG_HID_GYRATION=m
+# CONFIG_HID_KENSINGTON is not set
+CONFIG_HID_LOGITECH=m
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_PANTHERLORD=m
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SUNPLUS=m
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ARC=y
+# CONFIG_USB_EHCI_ARC_OTG is not set
+# CONFIG_USB_STATIC_IRAM is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+# CONFIG_USB_STATIC_IRAM_PPH is not set
+CONFIG_USB_ARC=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_FSL_UTP is not set
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MXC_OTG is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+CONFIG_SDIO_UNIFI_FS=m
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_MXC is not set
+CONFIG_MMC_IMX_ESDHCI=y
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_MC13892=y
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_MC13892=y
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_MXC_PXP=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+CONFIG_UIO_PDRV_GENIRQ=m
+# CONFIG_UIO_SMX is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_STAGING is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_MC13783 is not set
+CONFIG_MXC_PMIC_MC13892=y
+CONFIG_MXC_PMIC_I2C=y
+CONFIG_MXC_PMIC_SPI=y
+# CONFIG_MXC_PMIC_MC34704 is not set
+# CONFIG_MXC_PMIC_MC9SDZ60 is not set
+# CONFIG_MXC_PMIC_CHARDEV is not set
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_MC13892_ADC=y
+CONFIG_MXC_MC13892_RTC=y
+CONFIG_MXC_MC13892_LIGHT=y
+CONFIG_MXC_MC13892_BATTERY=y
+CONFIG_MXC_MC13892_CONNECTIVITY=y
+CONFIG_MXC_MC13892_POWER=y
+# CONFIG_MXC_PMIC_MC9S08DZ60 is not set
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_SCC2 is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+
+#
+# SAHARA2 Security Hardware Support
+#
+# CONFIG_MXC_SAHARA is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+CONFIG_MXC_VPU=y
+CONFIG_MXC_VPU_IRAM=y
+# CONFIG_MXC_VPU_DEBUG is not set
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+CONFIG_MXC_BLUETOOTH=m
+
+#
+# Broadcom GPS ioctrl support
+#
+CONFIG_GPS_IOCTRL=m
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=m
+
+#
+# i.MX ADC support
+#
+# CONFIG_IMX_ADC is not set
+
+#
+# MXC GPU support
+#
+CONFIG_MXC_AMD_GPU=m
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4DEV_COMPAT is not set
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_FILE_CAPABILITIES=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/configs/imx5_updater_defconfig b/arch/arm/configs/imx5_updater_defconfig
new file mode 100644
index 0000000..4a06eb3
--- /dev/null
+++ b/arch/arm/configs/imx5_updater_defconfig
@@ -0,0 +1,1696 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.31
+# Tue Jul 27 15:14:58 2010
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_ARCH_MTD_XIP=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+
+#
+# Performance Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_IRAM_ALLOC=y
+CONFIG_DMA_ZONE_SIZE=96
+CONFIG_UTMI_MXC=y
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX1 is not set
+# CONFIG_ARCH_MX2 is not set
+# CONFIG_ARCH_MX3 is not set
+# CONFIG_ARCH_MX25 is not set
+# CONFIG_ARCH_MX35 is not set
+# CONFIG_ARCH_MX37 is not set
+CONFIG_ARCH_MX5=y
+CONFIG_MXC_SDMA_API=y
+CONFIG_SDMA_IRAM=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+CONFIG_ARCH_MXC_HAS_NFC_V3=y
+CONFIG_ARCH_MX51=y
+CONFIG_ARCH_MX53=y
+CONFIG_ARCH_MX50=y
+CONFIG_MX5_OPTIONS=y
+CONFIG_MX5_MULTI_ARCH=y
+CONFIG_MACH_MX51_3DS=y
+CONFIG_MACH_MX51_BABBAGE=y
+CONFIG_MACH_MX53_EVK=y
+CONFIG_MACH_MX50_ARM2=y
+
+#
+# MX5x Options:
+#
+CONFIG_ARCH_MXC_HAS_NFC_V3_2=y
+CONFIG_MXC_TZIC=y
+CONFIG_ISP1504_MXC=y
+# CONFIG_MXC_IRQ_PRIOR is not set
+CONFIG_MXC_PWM=y
+CONFIG_ARCH_MXC_IOMUX_V3=y
+CONFIG_MXC_DVFS_PER=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_VMSPLIT_3G is not set
+CONFIG_VMSPLIT_2G=y
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0x80000000
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HIGHMEM=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+CONFIG_RUNTIME_PHYS_OFFSET=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200 root=/dev/mtdblock2 rw rootfstype=jffs2 ip=off"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_IMX=y
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_APM_EMULATION=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_NET is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+# CONFIG_MTD_MXC is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_MXC_DATAFLASH=y
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_IMX_NFC is not set
+CONFIG_MTD_NAND_MXC_V3=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_MTD_UBI_BLOCK is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_UB is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_APMPOWER is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+CONFIG_FM_SI4702=y
+CONFIG_MXC_IIM=y
+CONFIG_IMX_SIM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_IMX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_IMX is not set
+CONFIG_I2C_MXC=y
+CONFIG_I2C_MXC_HS=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_I2C_SLAVE is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+# CONFIG_SPI_MXC_SELECT2 is not set
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+CONFIG_W1=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=y
+# CONFIG_W1_MASTER_GPIO is not set
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+# CONFIG_W1_SLAVE_DS2431 is not set
+# CONFIG_W1_SLAVE_DS2751 is not set
+# CONFIG_W1_SLAVE_DS2433 is not set
+CONFIG_W1_SLAVE_DS2438=y
+# CONFIG_W1_SLAVE_DS2760 is not set
+# CONFIG_W1_SLAVE_BQ27000 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+CONFIG_APM_POWER=y
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_SENSORS_ISL29003=y
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=y
+CONFIG_MXC_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+# CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_TVOUT_TVE is not set
+# CONFIG_FB_MXC_LDB is not set
+# CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL is not set
+# CONFIG_FB_MXC_CH7026 is not set
+# CONFIG_FB_MXC_TVOUT_CH7024 is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_MXC_EINK_PANEL is not set
+# CONFIG_FB_MXC_ELCDIF_FB is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_BACKLIGHT_MXC=y
+CONFIG_BACKLIGHT_MXC_MC13892=y
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+# CONFIG_FONT_8x8 is not set
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KYE is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_KENSINGTON is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ARC=y
+# CONFIG_USB_EHCI_ARC_OTG is not set
+# CONFIG_USB_STATIC_IRAM is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ARC=y
+# CONFIG_USB_STATIC_IRAM_PPH is not set
+CONFIG_USB_ARC=y
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+CONFIG_USB_FILE_STORAGE=y
+CONFIG_FSL_UTP=y
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MXC_OTG is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+CONFIG_SDIO_UNIFI_FS=y
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_MXC is not set
+CONFIG_MMC_IMX_ESDHCI=y
+# CONFIG_MMC_IMX_ESDHCI_PIO_MODE is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_MC13892=y
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_BD2802 is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+# CONFIG_RTC_DRV_IMXDI is not set
+CONFIG_RTC_MC13892=y
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+CONFIG_MXC_PXP=y
+CONFIG_MXC_PXP_CLIENT_DEVICE=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+CONFIG_UIO_PDRV_GENIRQ=y
+# CONFIG_UIO_SMX is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_STAGING is not set
+
+#
+# MXC support drivers
+#
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V3=y
+
+#
+# MXC SSI support
+#
+# CONFIG_MXC_SSI is not set
+
+#
+# MXC Digital Audio Multiplexer support
+#
+# CONFIG_MXC_DAM is not set
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_PMIC=y
+# CONFIG_MXC_PMIC_MC13783 is not set
+CONFIG_MXC_PMIC_MC13892=y
+CONFIG_MXC_PMIC_I2C=y
+CONFIG_MXC_PMIC_SPI=y
+# CONFIG_MXC_PMIC_MC34704 is not set
+# CONFIG_MXC_PMIC_MC9SDZ60 is not set
+# CONFIG_MXC_PMIC_CHARDEV is not set
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_MC13892_ADC=y
+CONFIG_MXC_MC13892_RTC=y
+CONFIG_MXC_MC13892_LIGHT=y
+CONFIG_MXC_MC13892_BATTERY=y
+CONFIG_MXC_MC13892_CONNECTIVITY=y
+CONFIG_MXC_MC13892_POWER=y
+# CONFIG_MXC_PMIC_MC9S08DZ60 is not set
+
+#
+# MXC Security Drivers
+#
+# CONFIG_MXC_SECURITY_SCC is not set
+# CONFIG_MXC_SECURITY_SCC2 is not set
+# CONFIG_MXC_SECURITY_RNG is not set
+
+#
+# SAHARA2 Security Hardware Support
+#
+# CONFIG_MXC_SAHARA is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# MXC HARDWARE EVENT
+#
+# CONFIG_MXC_HWEVENT is not set
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+# CONFIG_MXC_VPU is not set
+# CONFIG_MXC_VPU_IRAM is not set
+
+#
+# MXC Asynchronous Sample Rate Converter support
+#
+
+#
+# MXC Bluetooth support
+#
+CONFIG_MXC_BLUETOOTH=y
+
+#
+# Broadcom GPS ioctrl support
+#
+CONFIG_GPS_IOCTRL=y
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=y
+
+#
+# i.MX ADC support
+#
+# CONFIG_IMX_ADC is not set
+
+#
+# MXC GPU support
+#
+# CONFIG_MXC_AMD_GPU is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4DEV_COMPAT is not set
+CONFIG_EXT4_FS_XATTR=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_FILE_CAPABILITIES=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_CRYPTODEV is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
index 1576d51..7ae1b1e 100644
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -2,17 +2,88 @@ if ARCH_MX5
 
 config ARCH_MX51
 	bool
-	default y
+	select USB_ARCH_HAS_EHCI
+	select MXC_TZIC
+	select ARCH_MXC_IOMUX_V3
+
+config ARCH_MX53
+	bool
+	select USB_ARCH_HAS_EHCI
 	select MXC_TZIC
 	select ARCH_MXC_IOMUX_V3
 
-comment "MX5 platforms:"
+config ARCH_MX50
+	bool
+
+config FORCE_MAX_ZONEORDER
+    int "MAX_ORDER"
+    default "13"
+
+config MX5_MULTI_ARCH
+	bool
+	default y
+	select RUNTIME_PHYS_OFFSET
+	depends on ARCH_MX51
+	depends on ARCH_MX50 || ARCH_MX53
+
+config MACH_MX51_3DS
+	bool "Support MX51 3-Stack platform"
+	select ARCH_MX51
+	help
+	  Include support for MX51 3-Stack platform. This includes specific
+	  configurations for the board and its peripherals.
 
 config MACH_MX51_BABBAGE
 	bool "Support MX51 BABBAGE platforms"
+	select ARCH_MX51
 	help
 	  Include support for MX51 Babbage platform, also known as MX51EVK in
 	  u-boot. This includes specific configurations for the board and its
 	  peripherals.
 
+config MACH_MX53_EVK
+	bool "Support MX53 EVK platform"
+	select ARCH_MX53
+	help
+	  Include support for MX53 EVK platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MACH_MX50_ARM2
+	bool "Support MX50 Armadillo2 platform"
+	select ARCH_MX50
+	help
+	  Include support for MX50 EVK platform. This includes specific
+	  configurations for the board and its peripherals.
+
+comment "MX5x Options:"
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3
+        bool "MXC NFC Hardware Version 3"
+        depends on ARCH_MX5
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V3_2
+        bool "MXC NFC Hardware Version 3.2"
+        depends on ARCH_MXC_HAS_NFC_V3
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 3.1
+           If unsure, say N.
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA transfer"
+	depends on MXC_SDMA_API
+	help
+	  Support Internal RAM as SDMA buffer or control structures
+
 endif
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
index bf23f86..72b3a56 100644
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -3,7 +3,14 @@
 #
 
 # Object file lists.
-obj-y   := cpu.o mm.o clock-mx51.o devices.o
+obj-y   := system.o iomux.o cpu.o mm.o devices.o serial.o dma.o lpmodes.o pm.o \
+sdram_autogating.o bus_freq.o usb_dr.o usb_h1.o usb_h2.o dummy_gpio.o  early_setup.o
 
-obj-$(CONFIG_MACH_MX51_BABBAGE) += board-mx51_babbage.o
+obj-$(CONFIG_ARCH_MX51) += clock.o suspend.o
+obj-$(CONFIG_ARCH_MX53) += clock.o suspend.o
+obj-$(CONFIG_ARCH_MX50) += clock_mx50.o mx50_suspend.o
 
+obj-$(CONFIG_MACH_MX51_3DS) += mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX51_BABBAGE) += mx51_babbage.o mx51_babbage_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX53_EVK) += mx53_evk.o mx53_evk_pmic_mc13892.o
+obj-$(CONFIG_MACH_MX50_ARM2) += mx50_arm2.o mx50_arm2_pmic_mc13892.o
diff --git a/arch/arm/mach-mx5/Makefile.boot b/arch/arm/mach-mx5/Makefile.boot
index 9939a19..434ef85 100644
--- a/arch/arm/mach-mx5/Makefile.boot
+++ b/arch/arm/mach-mx5/Makefile.boot
@@ -1,3 +1,9 @@
-   zreladdr-y	:= 0x90008000
-params_phys-y	:= 0x90000100
-initrd_phys-y	:= 0x90800000
+   zreladdr-$(CONFIG_ARCH_MX51)	:= 0x90008000
+params_phys-$(CONFIG_ARCH_MX51)	:= 0x90000100
+initrd_phys-$(CONFIG_ARCH_MX51)	:= 0x90800000
+   zreladdr-$(CONFIG_ARCH_MX53)	:= 0x70008000
+params_phys-$(CONFIG_ARCH_MX53)	:= 0x70000100
+initrd_phys-$(CONFIG_ARCH_MX53)	:= 0x70800000
+   zreladdr-$(CONFIG_ARCH_MX50)	:= 0x70008000
+params_phys-$(CONFIG_ARCH_MX50)	:= 0x70000100
+initrd_phys-$(CONFIG_ARCH_MX50)	:= 0x70800000
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
new file mode 100644
index 0000000..7103b94
--- /dev/null
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -0,0 +1,566 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+#include "crm_regs.h"
+
+#define LP_APM_CLK   			24000000
+#define NAND_LP_APM_CLK			12000000
+#define AXI_A_NORMAL_CLK		166250000
+#define AXI_A_CLK_NORMAL_DIV		4
+#define AXI_B_CLK_NORMAL_DIV		5
+#define AHB_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define EMI_SLOW_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define NFC_CLK_NORMAL_DIV      	4
+
+static unsigned long lp_normal_rate;
+static unsigned long lp_med_rate;
+static unsigned long ddr_normal_rate;
+static unsigned long ddr_low_rate;
+
+static struct clk *ddr_clk;
+static struct clk *pll1_sw_clk;
+static struct clk *pll2;
+static struct clk *pll3;
+static struct clk *main_bus_clk;
+static struct clk *axi_a_clk;
+static struct clk *axi_b_clk;
+static struct clk *cpu_clk;
+static struct clk *ddr_hf_clk;
+static struct clk *nfc_clk;
+static struct clk *ahb_clk;
+static struct clk *vpu_clk;
+static struct clk *vpu_core_clk;
+static struct clk *emi_slow_clk;
+static struct clk *ddr_clk;
+static struct clk *ipu_clk;
+static struct clk *periph_apm_clk;
+static struct clk *lp_apm;
+static struct clk *osc;
+static struct clk *gpc_dvfs_clk;
+static struct clk *emi_garb_clk;
+
+struct regulator *lp_regulator;
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+int bus_freq_scaling_initialized;
+char *gp_reg_id = "SW1";
+char *lp_reg_id = "SW2";
+
+static struct cpu_wp *cpu_wp_tbl;
+static struct device *busfreq_dev;
+static int busfreq_suspended;
+/* True if bus_frequency is scaled not using DVFS-PER */
+int bus_freq_scaling_is_active;
+
+int cpu_wp_nr;
+int lp_high_freq;
+int lp_med_freq;
+
+extern int dvfs_core_is_active;
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+
+struct dvfs_wp dvfs_core_setpoint[] = {
+						{33, 8, 33, 10, 10, 0x08},
+						{26, 0, 33, 20, 10, 0x08},
+						{28, 8, 33, 20, 30, 0x08},
+						{29, 0, 33, 20, 10, 0x08},};
+
+int set_low_bus_freq(void)
+{
+	u32 reg;
+
+	if (busfreq_suspended)
+		return 0;
+
+	if (bus_freq_scaling_initialized) {
+		/* can not enter low bus freq, when cpu is in highest freq */
+		if (clk_get_rate(cpu_clk) != cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+			return 0;
+
+		/* currently not support on mx53 */
+		if (cpu_is_mx53())
+			return 0;
+
+		stop_dvfs_per();
+
+		stop_sdram_autogating();
+		/*Change the DDR freq to 133Mhz. */
+		clk_set_rate(ddr_hf_clk,
+		     clk_round_rate(ddr_hf_clk, ddr_low_rate));
+
+		/* Set PLL3 to 133Mhz if no-one is using it. */
+		if (clk_get_usecount(pll3) == 0) {
+			u32 pll3_rate = clk_get_rate(pll3);
+
+			clk_enable(pll3);
+			clk_set_rate(pll3, clk_round_rate(pll3, 133000000));
+			/* Set the parent of Periph_apm_clk to be PLL3 */
+			clk_set_parent(periph_apm_clk, pll3);
+			clk_set_parent(main_bus_clk, periph_apm_clk);
+
+			/* Set the AHB dividers to be 1. */
+			/* Set the dividers to be  1, so the clock rates
+			  * are at 133MHz.
+			  */
+			reg = __raw_readl(MXC_CCM_CBCDR);
+			reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+					| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+					| MXC_CCM_CBCDR_AHB_PODF_MASK
+					| MXC_CCM_CBCDR_EMI_PODF_MASK
+					| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+			reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+					| 0 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+					| 0 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+					| 0 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+					| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+			__raw_writel(reg, MXC_CCM_CBCDR);
+
+			clk_enable(emi_garb_clk);
+			while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+				udelay(10);
+			clk_disable(emi_garb_clk);
+
+			/* Set the source of Periph_APM_Clock to be lp-apm. */
+			clk_set_parent(periph_apm_clk, lp_apm);
+
+			/* Set PLL3 back to original rate. */
+			clk_set_rate(pll3, clk_round_rate(pll3, pll3_rate));
+			clk_disable(pll3);
+
+			low_bus_freq_mode = 1;
+			high_bus_freq_mode = 0;
+		}
+	}
+	return 0;
+}
+
+int set_high_bus_freq(int high_bus_freq)
+{
+	u32 reg;
+
+	if (bus_freq_scaling_initialized) {
+
+		stop_sdram_autogating();
+
+		if (low_bus_freq_mode) {
+			/* Relock PLL3 to 133MHz */
+			if (clk_get_usecount(pll3) == 0) {
+				u32 pll3_rate = clk_get_rate(pll3);
+
+				clk_enable(pll3);
+				clk_set_rate(pll3,
+					clk_round_rate(pll3, 133000000));
+				clk_set_parent(periph_apm_clk, pll3);
+				/* Set the dividers to the default dividers */
+				reg = __raw_readl(MXC_CCM_CBCDR);
+				reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+					| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+					| MXC_CCM_CBCDR_AHB_PODF_MASK
+					| MXC_CCM_CBCDR_EMI_PODF_MASK
+					| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+				reg |= (3 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+					| 4 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+					| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+				__raw_writel(reg, MXC_CCM_CBCDR);
+
+				clk_enable(emi_garb_clk);
+				while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+					udelay(10);
+
+				low_bus_freq_mode = 0;
+				high_bus_freq_mode = 1;
+				clk_disable(emi_garb_clk);
+
+				/*Set the main_bus_clk parent to be PLL2. */
+				clk_set_parent(main_bus_clk, pll2);
+
+				/* Relock PLL3 to its original rate */
+				clk_set_rate(pll3,
+					clk_round_rate(pll3, pll3_rate));
+				clk_disable(pll3);
+			}
+
+			/*Change the DDR freq to 200MHz*/
+			clk_set_rate(ddr_hf_clk,
+			    clk_round_rate(ddr_hf_clk, ddr_normal_rate));
+
+			start_dvfs_per();
+		}
+		if (bus_freq_scaling_is_active) {
+			/*
+			 * If the CPU freq is 800MHz, set the bus to the high
+			 * setpoint (133MHz) and DDR to 200MHz.
+			 */
+			if (clk_get_rate(cpu_clk) !=
+					cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+				high_bus_freq = 1;
+
+			if (((clk_get_rate(ahb_clk) == lp_med_rate)
+					&& lp_high_freq) || high_bus_freq) {
+				/* Set to the high setpoint. */
+				high_bus_freq_mode = 1;
+
+				clk_set_rate(ahb_clk,
+				clk_round_rate(ahb_clk, lp_normal_rate));
+
+				clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, ddr_normal_rate));
+			}
+
+			if (!lp_high_freq && !high_bus_freq) {
+				/* Set to the medium setpoint. */
+				high_bus_freq_mode = 0;
+				low_bus_freq_mode = 0;
+
+				clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, ddr_low_rate));
+
+				clk_set_rate(ahb_clk,
+					clk_round_rate(ahb_clk, lp_med_rate));
+			}
+		}
+		start_sdram_autogating();
+	}
+	return 0;
+}
+
+int low_freq_bus_used(void)
+{
+	if ((clk_get_usecount(ipu_clk) == 0)
+	    && (clk_get_usecount(vpu_clk) == 0)
+	    && (lp_high_freq == 0)
+	    && (lp_med_freq == 0))
+		return 1;
+	else
+		return 0;
+}
+
+void setup_pll(void)
+{
+}
+
+static ssize_t bus_freq_scaling_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (bus_freq_scaling_is_active)
+		return sprintf(buf, "Bus frequency scaling is enabled\n");
+	else
+		return sprintf(buf, "Bus frequency scaling is disabled\n");
+}
+
+static ssize_t bus_freq_scaling_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	u32 reg;
+
+
+	if (strstr(buf, "1") != NULL) {
+		if (dvfs_per_active()) {
+			printk(KERN_INFO "bus frequency scaling cannot be\
+				 enabled when DVFS-PER is active\n");
+			return size;
+		}
+
+		/* Initialize DVFS-PODF to 0. */
+		reg = __raw_readl(MXC_CCM_CDCR);
+		reg &= ~MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK;
+		__raw_writel(reg, MXC_CCM_CDCR);
+		clk_set_parent(main_bus_clk, pll2);
+
+		bus_freq_scaling_is_active = 1;
+		set_high_bus_freq(0);
+	} else if (strstr(buf, "0") != NULL) {
+		if (bus_freq_scaling_is_active)
+			set_high_bus_freq(1);
+		bus_freq_scaling_is_active = 0;
+	}
+	return size;
+}
+
+static int busfreq_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	if (low_bus_freq_mode)
+		set_high_bus_freq(1);
+	busfreq_suspended = 1;
+	return 0;
+}
+
+static int busfreq_resume(struct platform_device *pdev)
+{
+	busfreq_suspended = 0;
+	return  0;
+}
+
+static DEVICE_ATTR(enable, 0644, bus_freq_scaling_enable_show,
+			bus_freq_scaling_enable_store);
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	unsigned long pll2_rate, pll1_rate;
+
+	busfreq_dev = &pdev->dev;
+
+	main_bus_clk = clk_get(NULL, "main_bus_clk");
+	if (IS_ERR(main_bus_clk)) {
+		printk(KERN_DEBUG "%s: failed to get main_bus_clk\n",
+		       __func__);
+		return PTR_ERR(main_bus_clk);
+	}
+
+	pll1_sw_clk = clk_get(NULL, "pll1_sw_clk");
+	if (IS_ERR(pll1_sw_clk)) {
+		printk(KERN_DEBUG "%s: failed to get pll1_sw_clk\n", __func__);
+		return PTR_ERR(pll1_sw_clk);
+	}
+
+	pll2 = clk_get(NULL, "pll2");
+	if (IS_ERR(pll2)) {
+		printk(KERN_DEBUG "%s: failed to get pll2\n", __func__);
+		return PTR_ERR(pll2);
+	}
+
+	pll1_rate = clk_get_rate(pll1_sw_clk);
+	pll2_rate = clk_get_rate(pll2);
+
+	if (pll2_rate == 665000000) {
+		/* for mx51 */
+		lp_normal_rate = pll2_rate / 5;
+		lp_med_rate = pll2_rate / 8;
+		ddr_normal_rate = pll1_rate / 4; /* 200M */
+		ddr_low_rate = pll1_rate / 6; /* 133M */
+	} else if (pll2_rate == 600000000) {
+		/* for mx53 evk rev.A */
+		lp_normal_rate = pll2_rate / 5;
+		lp_med_rate = pll2_rate / 8;
+		ddr_normal_rate = pll2_rate / 2;
+		ddr_low_rate = pll2_rate / 2;
+	} else if (pll2_rate == 400000000) {
+		/* for mx53 evk rev.B */
+		lp_normal_rate = pll2_rate / 3;
+		lp_med_rate = pll2_rate / 5;
+		ddr_normal_rate = pll2_rate / 1;
+		ddr_low_rate = pll2_rate / 3;
+	}
+
+	pll3 = clk_get(NULL, "pll3");
+	if (IS_ERR(pll3)) {
+		printk(KERN_DEBUG "%s: failed to get pll3\n", __func__);
+		return PTR_ERR(pll3);
+	}
+
+	axi_a_clk = clk_get(NULL, "axi_a_clk");
+	if (IS_ERR(axi_a_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_a_clk\n",
+		       __func__);
+		return PTR_ERR(axi_a_clk);
+	}
+
+	axi_b_clk = clk_get(NULL, "axi_b_clk");
+	if (IS_ERR(axi_b_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_b_clk\n",
+		       __func__);
+		return PTR_ERR(axi_b_clk);
+	}
+
+	if (cpu_is_mx51())
+		ddr_hf_clk = clk_get(NULL, "ddr_hf_clk");
+	else
+		ddr_hf_clk = clk_get(NULL, "axi_a_clk");
+
+	if (IS_ERR(ddr_hf_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_hf_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_hf_clk);
+	}
+
+	emi_slow_clk = clk_get(NULL, "emi_slow_clk");
+	if (IS_ERR(emi_slow_clk)) {
+		printk(KERN_DEBUG "%s: failed to get emi_slow_clk\n",
+		       __func__);
+		return PTR_ERR(emi_slow_clk);
+	}
+
+	nfc_clk = clk_get(NULL, "nfc_clk");
+	if (IS_ERR(nfc_clk)) {
+		printk(KERN_DEBUG "%s: failed to get nfc_clk\n",
+		       __func__);
+		return PTR_ERR(nfc_clk);
+	}
+
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	if (IS_ERR(ahb_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ahb_clk\n",
+		       __func__);
+		return PTR_ERR(ahb_clk);
+	}
+
+	vpu_core_clk = clk_get(NULL, "vpu_core_clk");
+	if (IS_ERR(vpu_core_clk)) {
+		printk(KERN_DEBUG "%s: failed to get vpu_core_clk\n",
+		       __func__);
+		return PTR_ERR(vpu_core_clk);
+	}
+
+	ddr_clk = clk_get(NULL, "ddr_clk");
+	if (IS_ERR(ddr_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_clk);
+	}
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n",
+		       __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	ipu_clk = clk_get(NULL, "ipu_clk");
+	if (IS_ERR(ipu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ipu_clk\n",
+		       __func__);
+		return PTR_ERR(ipu_clk);
+	}
+
+	if (cpu_is_mx51())
+		emi_garb_clk = clk_get(NULL, "emi_garb_clk");
+	else
+		emi_garb_clk = clk_get(NULL, "emi_intr_clk.1");
+	if (IS_ERR(emi_garb_clk)) {
+		printk(KERN_DEBUG "%s: failed to get emi_garb_clk\n",
+		       __func__);
+		return PTR_ERR(emi_garb_clk);
+	}
+
+	vpu_clk = clk_get(NULL, "vpu_clk");
+	if (IS_ERR(vpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get vpu_clk\n",
+		       __func__);
+		return PTR_ERR(vpu_clk);
+	}
+
+	periph_apm_clk = clk_get(NULL, "periph_apm_clk");
+	if (IS_ERR(periph_apm_clk)) {
+		printk(KERN_DEBUG "%s: failed to get periph_apm_clk\n",
+		       __func__);
+		return PTR_ERR(periph_apm_clk);
+	}
+
+	lp_apm = clk_get(NULL, "lp_apm");
+	if (IS_ERR(lp_apm)) {
+		printk(KERN_DEBUG "%s: failed to get lp_apm\n",
+		       __func__);
+		return PTR_ERR(lp_apm);
+	}
+
+	osc = clk_get(NULL, "osc");
+	if (IS_ERR(osc)) {
+		printk(KERN_DEBUG "%s: failed to get osc\n", __func__);
+		return PTR_ERR(osc);
+	}
+
+	gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	if (IS_ERR(gpc_dvfs_clk)) {
+		printk(KERN_DEBUG "%s: failed to get gpc_dvfs_clk\n", __func__);
+		return PTR_ERR(gpc_dvfs_clk);
+	}
+
+	err = sysfs_create_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for BUSFREQ");
+		return err;
+	}
+
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 1;
+	bus_freq_scaling_is_active = 0;
+	bus_freq_scaling_initialized = 1;
+
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		},
+	.probe = busfreq_probe,
+	.suspend = busfreq_suspend,
+	.resume = busfreq_resume,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	sysfs_remove_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+	bus_freq_scaling_initialized = 0;
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
new file mode 100644
index 0000000..35dda70
--- /dev/null
+++ b/arch/arm/mach-mx5/clock.c
@@ -0,0 +1,4908 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/hrtimer.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/clkdev.h>
+#include <asm/div64.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+
+#include "crm_regs.h"
+
+/* External clock values passed-in by the board code */
+static unsigned long external_high_reference, external_low_reference;
+static unsigned long oscillator_reference, ckih2_reference;
+
+static struct clk pll1_main_clk;
+static struct clk pll1_sw_clk;
+static struct clk pll2_sw_clk;
+static struct clk pll3_sw_clk;
+static struct clk pll4_sw_clk;
+static struct clk lp_apm_clk;
+static struct clk tve_clk;
+static struct clk emi_fast_clk;
+static struct clk emi_slow_clk;
+static struct clk emi_intr_clk[];
+static struct clk ddr_clk;
+static struct clk ipu_clk[];
+static struct clk ldb_di_clk[];
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk ddr_hf_clk;
+static struct clk mipi_hsp_clk;
+static struct clk gpu3d_clk;
+static struct clk gpu2d_clk;
+static struct clk vpu_clk[];
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *pll4_base;
+
+extern int cpu_wp_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
+static int max_axi_a_clk;
+static int max_axi_b_clk;
+
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+#define MAX_AXI_A_CLK_MX51 	166250000
+#define MAX_AXI_A_CLK_MX53 	400000000
+#define MAX_AXI_B_CLK_MX51 	133000000
+#define MAX_AXI_B_CLK_MX53 	200000000
+#define MAX_AHB_CLK			133000000
+#define MAX_EMI_SLOW_CLK		133000000
+#define MAX_DDR_HF_RATE		200000000
+
+extern int mxc_jtag_enabled;
+extern int uart_at_24;
+extern int cpufreq_trig_needed;
+extern int low_bus_freq_mode;
+
+static int cpu_clk_set_wp(int wp);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+
+static struct clk esdhc3_clk[];
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGRx_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static int _clk_enable_inrun(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
+}
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else
+		BUG();
+
+	return 0;
+}
+
+/*
+ * For the ddr muxed input clock
+ */
+static inline u32 _get_mux_ddr(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3, struct clk *m4)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else
+		BUG();
+
+	return 0;
+}
+
+static inline void __iomem *_get_pll_base(struct clk *pll)
+{
+	if (pll == &pll1_main_clk)
+		return pll1_base;
+	else if (pll == &pll2_sw_clk)
+		return pll2_base;
+	else if (pll == &pll3_sw_clk)
+		return pll3_base;
+	else if (pll == &pll4_sw_clk)
+		return pll4_base;
+	else
+		BUG();
+
+	return NULL;
+}
+
+static unsigned long get_high_reference_clock_rate(struct clk *clk)
+{
+	return external_high_reference;
+}
+
+static unsigned long get_low_reference_clock_rate(struct clk *clk)
+{
+	return external_low_reference;
+}
+
+static unsigned long get_oscillator_reference_clock_rate(struct clk *clk)
+{
+	return oscillator_reference;
+}
+
+static unsigned long get_ckih2_reference_clock_rate(struct clk *clk)
+{
+	return ckih2_reference;
+}
+
+/* External high frequency clock */
+static struct clk ckih_clk = {
+	.get_rate = get_high_reference_clock_rate,
+};
+
+static struct clk ckih2_clk = {
+	.get_rate = get_ckih2_reference_clock_rate,
+};
+
+static struct clk osc_clk = {
+	.get_rate = get_oscillator_reference_clock_rate,
+};
+
+/* External low frequency (32kHz) clock */
+static struct clk ckil_clk = {
+	.get_rate = get_low_reference_clock_rate,
+};
+
+static unsigned long _fpm_get_rate(struct clk *clk)
+{
+	u32 rate = ckil_clk.get_rate(&ckil_clk) * 512;
+	if ((__raw_readl(MXC_CCM_CCR) & MXC_CCM_CCR_FPM_MULT_MASK) != 0)
+		rate *= 2;
+	return rate;
+}
+
+static int _fpm_enable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg |= MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+	return 0;
+}
+
+static void _fpm_disable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg &= ~MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+}
+
+static struct clk fpm_clk = {
+	.parent = &ckil_clk,
+	.get_rate = _fpm_get_rate,
+	.enable = _fpm_enable,
+	.disable = _fpm_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _fpm_div2_get_rate(struct clk *clk)
+{
+	return  clk_get_rate(clk->parent) / 2;
+}
+
+static struct clk fpm_div2_clk = {
+	.parent = &fpm_clk,
+	.get_rate = _fpm_div2_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	void __iomem *pllbase;
+	s64 temp;
+
+	pllbase = _get_pll_base(clk);
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = 2 * clk_get_rate(clk->parent);
+	if (dbl != 0)
+		ref_clk *= 2;
+
+	ref_clk /= (pdf + 1);
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	return temp;
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, reg1;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	long mfi, pdf, mfn, mfd = 999999;
+	s64 temp64;
+	unsigned long quad_parent_rate;
+	unsigned long pll_hfsm, dp_ctl;
+
+	pllbase = _get_pll_base(clk);
+
+	quad_parent_rate = 4 * clk_get_rate(clk->parent);
+	pdf = mfi = -1;
+	while (++pdf < 16 && mfi < 5)
+		mfi = rate * (pdf+1) / quad_parent_rate;
+	if (mfi > 15)
+		return -1;
+	pdf--;
+
+	temp64 = rate*(pdf+1) - quad_parent_rate*mfi;
+	do_div(temp64, quad_parent_rate/1000000);
+	mfn = (long)temp64;
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	/* use dpdck0_2 */
+	__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	if (pll_hfsm == 0) {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);
+	} else {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	/* If auto restart is disabled, restart the PLL and
+	  * wait for it to lock.
+	  */
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	if (reg & MXC_PLL_DP_CTL_UPEN) {
+		reg = __raw_readl(pllbase + MXC_PLL_DP_CONFIG);
+		if (!(reg & MXC_PLL_DP_CONFIG_AREN)) {
+			reg1 = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+			reg1 |= MXC_PLL_DP_CTL_RST;
+			__raw_writel(reg1, pllbase + MXC_PLL_DP_CTL);
+		}
+		/* Wait for lock */
+		getnstimeofday(&nstimeofday);
+		while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL)
+					& MXC_PLL_DP_CTL_LRF)) {
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+				panic("pll_set_rate: pll relock failed\n");
+		}
+	}
+	return 0;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	getnstimeofday(&nstimeofday);
+	while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_LRF)) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll relock failed\n");
+	}
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static struct clk pll1_main_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll1_main_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+		/* Set the step_clk parent to be lp_apm, to save power. */
+		mux = _get_mux(&lp_apm_clk, &lp_apm_clk, NULL, &pll2_sw_clk,
+			       &pll3_sw_clk);
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+		    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+	} else {
+		if (parent == &lp_apm_clk) {
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+			reg = __raw_readl(MXC_CCM_CCSR);
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+		} else {
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+			__raw_writel(reg, MXC_CCM_CCSR);
+			reg = __raw_readl(MXC_CCM_CCSR);
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+
+		}
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static unsigned long _clk_pll1_sw_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+	div = 1;
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (clk->parent == &pll2_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;
+	} else if (clk->parent == &pll3_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+/* pll1 switch clock */
+static struct clk pll1_sw_clk = {
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.get_rate = _clk_pll1_sw_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll2_sw_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	} else {
+		reg = (reg & ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL);
+		reg |= MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+	return 0;
+}
+
+/* same as pll2_main_clk. These two clocks should always be the same */
+static struct clk pll2_sw_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.set_rate = _clk_pll_set_rate,
+	.set_parent = _clk_pll2_sw_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll3_main_clk. These two clocks should always be the same */
+static struct clk pll3_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll4_main_clk. These two clocks should always be the same */
+static struct clk pll4_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &osc_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	else if (parent == &fpm_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static struct clk lp_apm_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_arm_get_rate(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_wp_nr)
+		return -EINVAL;
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_wp_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+
+static struct clk cpu_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_arm_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
+static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll3_sw_clk, &lp_apm_clk, NULL);
+
+	reg = __raw_readl(MXC_CCM_CBCMR) & ~MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_periph_apm_set_parent failed\n");
+	}
+	return 0;
+}
+
+static struct clk periph_apm_clk = {
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_periph_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+/* TODO: Need to sync with GPC to determine if DVFS is in place so that
+ * the DVFS_PODF divider can be applied in CDCR register.
+ */
+static unsigned long _clk_main_bus_get_rate(struct clk *clk)
+{
+	u32 div = 0;
+
+	if (dvfs_per_divider_active() || low_bus_freq_mode)
+		div  = (__raw_readl(MXC_CCM_CDCR) & 0x3);
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	if (parent == &pll2_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) &
+		    ~MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else if (parent == &periph_apm_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) | MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else {
+		return -EINVAL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk main_bus_clk = {
+	.parent = &pll2_sw_clk,
+	.set_parent = _clk_main_bus_set_parent,
+	.get_rate = _clk_main_bus_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_axi_a_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_axi_a_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_a_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_a_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_a_get_rate,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_ddr_hf_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_DDR_PODF_MASK) >>
+	       MXC_CCM_CBCDR_DDR_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_ddr_hf_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_DDR_HF_RATE)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+static int _clk_ddr_hf_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_DDR_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_DDR_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_DDR_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("clk_ddr_hf_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk ddr_hf_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_ddr_hf_get_rate,
+	.round_rate = _clk_ddr_hf_round_rate,
+	.set_rate = _clk_ddr_hf_set_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_axi_b_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_axi_b_set_rate failed\n");
+	}
+
+	emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_b_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_b_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_b_get_rate,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_ahb_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+
+static int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AHB_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AHB_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AHB_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_ahb_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_ahb_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_AHB_CLK)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk ahb_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_ahb_get_rate,
+	.set_rate = _clk_ahb_set_rate,
+	.round_rate = _clk_ahb_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_max_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with MAX when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+
+static void _clk_max_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable_inwait(clk);
+
+	/* No Handshake with MAX when LPM is entered as its disabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk ahb_max_clk = {
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
+static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk) {
+		reg |= MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else if (parent == &main_bus_clk) {
+		reg &= ~MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else {
+		BUG();
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_EMI_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_emi_slow_set_rate failed\n");
+	}
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_EMI_SLOW_CLK)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk emi_slow_clk = {
+	.parent = &main_bus_clk,
+	.set_parent = _clk_emi_slow_set_parent,
+	.get_rate = _clk_emi_slow_get_rate,
+	.set_rate = _clk_emi_slow_set_rate,
+	.round_rate = _clk_emi_slow_round_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahbmux1_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk ahbmux2_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+
+static struct clk emi_fast_clk = {
+	.parent = &ddr_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk emi_intr_clk[] = {
+	{
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	},
+	{
+	/* On MX51 - this clock is name emi_garb_clk, and controls the
+	 * access of ARM to GARB.
+	 */
+	.id = 1,
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	}
+};
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
+	       MXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_ipg_per_get_rate(struct clk *clk)
+{
+	u32 reg, prediv1, prediv2, podf;
+
+	if (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {
+		/* the main_bus_clk is the one before the DVFS engine */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		prediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;
+		prediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
+			MXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;
+		return clk_get_rate(clk->parent) / (prediv1 * prediv2 * podf);
+	} else if (clk->parent == &ipg_clk) {
+		return clk_get_rate(&ipg_clk);
+	}
+	BUG();
+	return 0;
+}
+
+static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &main_bus_clk, &lp_apm_clk, &ipg_clk, NULL);
+	if (mux == 2) {
+		reg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+		if (mux == 0)
+			reg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+		else
+			reg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk ipg_perclk = {
+	.parent = &lp_apm_clk,
+	.get_rate = _clk_ipg_per_get_rate,
+	.set_parent = _clk_ipg_per_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_ipmux_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1  << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_ipmux_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(0x1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static struct clk ipumux1_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG6_1_OFFSET,
+	.enable = _clk_ipmux_enable,
+	.disable = _clk_ipmux_disable,
+};
+
+static struct clk ipumux2_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG6_2_OFFSET,
+	.enable = _clk_ipmux_enable,
+	.disable = _clk_ipmux_disable,
+};
+
+static int _clk_ocram_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void _clk_ocram_disable(struct clk *clk)
+{
+}
+
+static struct clk ocram_clk = {
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.enable = _clk_ocram_enable,
+	.disable = _clk_ocram_disable,
+};
+
+
+static struct clk aips_tz1_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk gpc_dvfs_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk sdma_clk[] = {
+	{
+	 .parent = &ahb_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .enable = _clk_sdma_enable,
+	 .disable = _clk_sdma_disable,
+	 },
+	{
+	 .parent = &ipg_clk,
+#ifdef CONFIG_SDMA_IRAM
+	 .secondary = &emi_intr_clk[0],
+#endif
+	 },
+};
+
+static int _clk_ipu_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CCDR_IPU_HS_MASK;
+	else
+		reg &= ~MXC_CCM_CCDR_IPU_HS_MX53_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* Handshake with IPU when LPM is entered as its enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	start_sdram_autogating();
+
+	return 0;
+}
+
+static void _clk_ipu_disable(struct clk *clk)
+{
+	u32 reg;
+
+	if (sdram_autogating_active())
+		stop_sdram_autogating();
+
+	_clk_disable(clk);
+
+	/* No handshake with IPU whe dividers are changed
+	 * as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	else
+		reg |= MXC_CCM_CCDR_IPU_HS_MX53_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* No handshake with IPU when LPM is entered as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static int _clk_ipu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &ahb_clk,
+		       &emi_slow_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+
+static struct clk ipu_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &ipu_clk[1],
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.enable = _clk_ipu_enable,
+	.disable = _clk_ipu_disable,
+	.set_parent = _clk_ipu_set_parent,
+	 .flags = CPU_FREQ_TRIG_UPDATE | AHB_MED_SET_POINT | RATE_PROPAGATES,
+	},
+	{
+	 .parent = &emi_fast_clk,
+	 .secondary = &ahbmux1_clk,
+	}
+};
+
+static int _clk_ipu_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg &= ~MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id);
+	if (parent == &pll3_sw_clk)
+		;
+	else if (parent == &osc_clk)
+		reg |= 1 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &ckih_clk)
+		reg |= 2 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if ((parent == &pll4_sw_clk) && (clk->id == 0)) {
+		if (cpu_is_mx51())
+			return -EINVAL;
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	} else if ((parent == &tve_clk) && (clk->id == 1))
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if ((parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())
+		reg |= 5 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else		/* Assume any other clock is external clock pin */
+		reg |= 4 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_ipu_di_get_rate(struct clk *clk)
+{
+	u32 reg, mux;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = (reg & MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id)) >>
+		MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	if (mux == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET) + 1;
+	} else if ((mux == 3) && (clk->id == 1)) {
+		div = 8;
+	} else if ((mux == 3) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+			MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ipu_di_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if ((clk->parent == &pll4_sw_clk) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if (((clk->parent == &tve_clk) && (clk->id == 1)) ||
+		((clk->parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())) {
+		return 0;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static unsigned long _clk_ipu_di_round_rate(struct clk *clk,
+					    unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if ((clk->parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())
+		return parent_rate;
+	else {
+		div = parent_rate / rate;
+		if (div > 8)
+			div = 8;
+		else if (div == 0)
+			div++;
+		return parent_rate / div;
+	}
+}
+
+static struct clk ipu_di_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.get_rate = _clk_ipu_di_get_rate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.flags = RATE_PROPAGATES,
+	},
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.get_rate = _clk_ipu_di_get_rate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.flags = RATE_PROPAGATES,
+	},
+};
+
+static int _clk_ldb_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+
+	if ((parent == &pll3_sw_clk)) {
+		if (clk->id == 0)
+			reg &= ~(MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL);
+		else
+			reg &= ~(MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL);
+	} else if ((parent == &pll4_sw_clk)) {
+		if (clk->id == 0)
+			reg |= MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL;
+		else
+			reg |= MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL;
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+	return 0;
+}
+
+static unsigned long _clk_ldb_di_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	if (clk->id == 0)
+		div = __raw_readl(MXC_CCM_CSCMR2) &
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	else
+		div = __raw_readl(MXC_CCM_CSCMR2) &
+			MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+
+	if (div)
+		return clk_get_rate(clk->parent) / 7;
+
+	return (2 * clk_get_rate(clk->parent)) / 7;
+}
+
+static unsigned long _clk_ldb_di_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (rate * 7 <= parent_rate)
+		return parent_rate / 7;
+	else
+		return 2 * parent_rate / 7;
+}
+
+static int _clk_ldb_di_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div = 0;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (rate * 7 <= parent_rate) {
+		div = 7;
+		rate = parent_rate / 7;
+	} else
+		rate = 2 * parent_rate / 7;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	if (div == 7)
+		reg |= (clk->id ? MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV :
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV);
+	else
+		reg &= ~(clk->id ? MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV :
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static int _clk_ldb_di_enable(struct clk *clk)
+{
+	_clk_enable(clk);
+	ipu_di_clk[clk->id].set_parent(&ipu_di_clk[clk->id], clk);
+	ipu_di_clk[clk->id].parent = clk;
+	ipu_di_clk[clk->id].enable(&ipu_di_clk[clk->id]);
+	ipu_di_clk[clk->id].usecount++;
+	return 0;
+}
+
+static void _clk_ldb_di_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+	ipu_di_clk[clk->id].disable(&ipu_di_clk[clk->id]);
+	ipu_di_clk[clk->id].usecount--;
+}
+
+static struct clk ldb_di_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll4_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.get_rate = _clk_ldb_di_get_rate,
+	.set_parent = _clk_ldb_di_set_parent,
+	.round_rate = _clk_ldb_di_round_rate,
+	.set_rate = _clk_ldb_di_set_rate,
+	.enable = _clk_ldb_di_enable,
+	.disable = _clk_ldb_di_disable,
+	.flags = RATE_PROPAGATES | AHB_MED_SET_POINT,
+	},
+	{
+	.id = 1,
+	.parent = &pll4_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.get_rate = _clk_ldb_di_get_rate,
+	.set_parent = _clk_ldb_di_set_parent,
+	.round_rate = _clk_ldb_di_round_rate,
+	.set_rate = _clk_ldb_di_set_rate,
+	.enable = _clk_ldb_di_enable,
+	.disable = _clk_ldb_di_disable,
+	.flags = RATE_PROPAGATES | AHB_MED_SET_POINT,
+	},
+};
+
+static int _clk_csi0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi0_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent)/(pred * podf);
+}
+
+static unsigned long _clk_csi0_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_csi0_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi0_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi0_set_parent,
+	.get_rate = _clk_csi0_get_rate,
+	.round_rate = _clk_csi0_round_rate,
+	.set_rate = _clk_csi0_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_csi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi1_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent)/(pred * podf) ;
+}
+
+static unsigned long _clk_csi1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_csi1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi1_set_parent,
+	.get_rate = _clk_csi1_get_rate,
+	.round_rate = _clk_csi1_round_rate,
+	.set_rate = _clk_csi1_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static int _clk_hsc_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_hsc_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with HSC as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static struct clk mipi_esc_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+};
+
+static struct clk mipi_hsc2_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.secondary = &mipi_esc_clk,
+};
+
+static struct clk mipi_hsc1_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.secondary = &mipi_hsc2_clk,
+};
+
+static struct clk mipi_hsp_clk = {
+	.parent = &ipu_clk[0],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.enable = _clk_hsc_enable,
+	.disable = _clk_hsc_disable,
+	.secondary = &mipi_hsc1_clk,
+};
+
+static int _clk_tve_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+
+	if ((parent == &pll3_sw_clk) && cpu_is_mx51()) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_CLK_SEL);
+	} else if ((parent == &pll4_sw_clk) && cpu_is_mx53()) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL);
+	} else if ((parent == &osc_clk) && cpu_is_mx51()) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg &= ~MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else if (parent == &ckih_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL; /* Reserved on MX53 */
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static unsigned long _clk_tve_get_rate(struct clk *clk)
+{
+	u32 reg, div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & (MXC_CCM_CSCMR1_TVE_CLK_SEL | MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL)) == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_tve_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
+		return -EINVAL;
+
+	div = parent_rate / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return parent_rate / div;
+}
+
+static int _clk_tve_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
+		return -EINVAL;
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	div--;
+	reg = __raw_readl(MXC_CCM_CDCDR) & ~MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+	reg |= div << MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+	return 0;
+}
+
+static int _clk_tve_enable(struct clk *clk)
+{
+	_clk_enable(clk);
+	if (clk_get_parent(&ipu_di_clk[1]) != clk) {
+		clk_enable(&ipu_di_clk[1]);
+		ipu_di_clk[1].set_parent(&ipu_di_clk[1], clk);
+		ipu_di_clk[1].parent = clk;
+	}
+	return 0;
+}
+
+static void _clk_tve_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+	if (clk_get_parent(&ipu_di_clk[1]) == clk) {
+		ipu_di_clk[1].set_parent(&ipu_di_clk[1], &pll3_sw_clk);
+		ipu_di_clk[1].parent = &pll3_sw_clk;
+		clk_disable(&ipu_di_clk[1]);
+	}
+}
+
+static struct clk tve_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_tve_set_parent,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.get_rate = _clk_tve_get_rate,
+	.round_rate = _clk_tve_round_rate,
+	.set_rate = _clk_tve_set_rate,
+	.enable = _clk_tve_enable,
+	.disable = _clk_tve_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk spba_clk = {
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_uart_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent)/(prediv * podf) ;
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk uart_main_clk = {
+	.parent = &pll2_sw_clk,
+	.get_rate = _clk_uart_get_rate,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART1_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+#ifdef UART1_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART2_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+#ifdef UART2_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART3_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart4_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART4_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart5_clk[] = {
+	{
+	 .id = 4,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart5_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART5_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk gpt_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &gpt_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm1_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm2_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 1,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static unsigned long _clk_hsi2c_serial_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR3);
+	prediv = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static struct clk hsi2c_serial_clk = {
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.secondary = &spba_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.get_rate = _clk_hsi2c_serial_get_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk hsi2c_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long _clk_cspi_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.parent = &pll3_sw_clk,
+	.get_rate = _clk_cspi_get_rate,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi3_clk = {
+	.id = 2,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.secondary = &aips_tz2_clk,
+};
+
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static unsigned long _clk_ssi1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .secondary = &ssi1_clk[1],
+	 .get_rate = _clk_ssi1_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi1_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &aips_tz2_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static unsigned long _clk_ssi2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .secondary = &ssi2_clk[1],
+	 .get_rate = _clk_ssi2_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi2_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &spba_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static unsigned long _clk_ssi_ext1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || div > 512)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~(MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK |
+		 MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	return 0;
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_ssi_ext1_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static struct clk ssi_ext1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.set_rate = _clk_ssi_ext1_set_rate,
+	.round_rate = _clk_ssi_ext1_round_rate,
+	.get_rate = _clk_ssi_ext1_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_ssi_ext2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.get_rate = _clk_ssi_ext2_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_esai_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	if (parent ==  &pll1_sw_clk || parent ==  &pll2_sw_clk ||
+		    parent ==  &pll3_sw_clk) {
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			NULL);
+		reg &= ~MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET;
+		reg &= ~MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK;
+		reg |= 0 << MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET;
+		/* divider setting */
+	} else {
+		mux = _get_mux(parent, &ssi1_clk[0], &ssi2_clk[0], &ckih_clk,
+			&ckih2_clk);
+		reg &= ~MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK;
+		reg |= (mux + 1) << MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET;
+		/* divider setting */
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	/* set podf = 0 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	return 0;
+}
+
+static unsigned long _clk_esai_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	if (clk->parent ==  &pll1_sw_clk || clk->parent ==  &pll2_sw_clk ||
+		    clk->parent ==  &pll3_sw_clk) {
+		pred = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / (pred * podf);
+	} else {
+		podf = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / podf;
+	}
+}
+
+static struct clk esai_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esai_set_parent,
+	 .get_rate = _clk_esai_get_rate,
+	 .secondary = &esai_clk[1],
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk iim_clk = {
+	.parent = &ipg_clk,
+	.secondary = &aips_tz2_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax1_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 };
+
+static struct clk tmax2_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk tmax3_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static unsigned long _clk_usboh3_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_usboh3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk usboh3_clk[] = {
+	{
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_usboh3_set_parent,
+	 .get_rate = _clk_usboh3_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &usboh3_clk[1],
+	 .flags = AHB_MED_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .parent = &tmax2_clk,
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static struct clk usb_ahb_clk = {
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static unsigned long _clk_usb_phy_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		prediv = ((reg & MXC_CCM_CDCDR_USB_PHY_PRED_MASK) >>
+			  MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_USB_PHY_PODF_MASK) >>
+			MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET) + 1;
+
+		div = (prediv * podf);
+	}
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &osc_clk)
+		reg &= ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else if (parent == &pll3_sw_clk)
+		reg |= MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk usb_phy_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.disable = _clk_disable,
+	}
+};
+
+static struct clk esdhc_dep_clks = {
+	 .parent = &spba_clk,
+	 .secondary = &emi_fast_clk,
+};
+
+static unsigned long _clk_esdhc1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+
+static int _clk_sdhc1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	 __calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	return 0;
+}
+
+static struct clk esdhc1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc1_set_parent,
+	 .get_rate = _clk_esdhc1_get_rate,
+	 .set_rate = _clk_sdhc1_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc1_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+
+};
+
+static unsigned long _clk_esdhc2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / (prediv * podf);
+	}
+	return clk_get_rate(clk->parent);
+}
+
+static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (cpu_is_mx51()) {
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	} else { /* MX53  */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else
+			BUG();
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static int _clk_esdhc2_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (cpu_is_mx51()) {
+		div = parent_rate / rate;
+
+		if ((parent_rate / div) != rate)
+			return -EINVAL;
+
+		 __calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) <<
+				MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) <<
+				MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+	return 0;
+}
+
+static struct clk esdhc2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esdhc2_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc2_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else
+			BUG();
+	} else { /* MX53 */
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_esdhc3_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_sdhc3_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (cpu_is_mx53()) {
+		div = parent_rate / rate;
+
+		if ((parent_rate / div) != rate)
+			return -EINVAL;
+
+		__calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET;
+		 __raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+	return 0;
+}
+
+
+static struct clk esdhc3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc3_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ahb_max_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	} else {/*MX53 */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc4_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc4_clk[1],
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc4_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static struct clk sata_clk = {
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ieee_1588_clk = {
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mlb_clk[] = {
+	{
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+	.secondary = &mlb_clk[1],
+	},
+	{
+	.parent = &emi_fast_clk,
+	.secondary = &emi_intr_clk[1],
+	},
+};
+
+static struct clk can1_clk[] = {
+	{
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.secondary = &can1_clk[1],
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.id = 0,
+	.parent = &lp_apm_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static struct clk can2_clk[] = {
+	{
+	.id = 1,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.secondary = &can2_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.id = 1,
+	.parent = &lp_apm_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static int _clk_sim_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR2) & ~MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_sim_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	pred = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / (pred * podf);
+}
+
+static unsigned long _clk_sim_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_sim_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set SIM clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR2) &
+	    ~(MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK |
+	      MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR2);
+
+	return 0;
+
+}
+
+static struct clk sim_clk[] = {
+	{
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_sim_set_parent,
+	.secondary = &sim_clk[1],
+	.get_rate = _clk_sim_get_rate,
+	.round_rate = _clk_sim_round_rate,
+	.set_rate = _clk_sim_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static unsigned long _clk_nfc_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_NFC_PODF_MASK) >>
+	       MXC_CCM_CBCDR_NFC_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_nfc_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	/*
+	 * Compute the divider we'd have to use to reach the target rate.
+	 */
+
+	div = parent_rate / rate;
+
+	/*
+	 * If there's a remainder after the division, then we have to increment
+	 * the divider. There are two reasons for this:
+	 *
+	 * 1) The frequency we round to must be LESS THAN OR EQUAL to the
+	 *    target. We aren't allowed to round to a frequency that is higher
+	 *    than the target.
+	 *
+	 * 2) This also catches the case where target rate is less than the
+	 *    parent rate, which implies a divider of zero. We can't allow a
+	 *    divider of zero.
+	 */
+
+	if (parent_rate % rate)
+		div++;
+
+	/*
+	 * The divider for this clock is 3 bits wide, so we can't possibly
+	 * divide the parent by more than eight.
+	 */
+
+	if (div > 8)
+		return -EINVAL;
+
+	return parent_rate / div;
+
+}
+
+static int _clk_nfc_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_NFC_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_NFC_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY){
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_nfc_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk emi_enfc_clk = {
+	.parent = &emi_slow_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.disable = _clk_disable_inwait,
+	.get_rate = _clk_nfc_get_rate,
+	.round_rate = _clk_nfc_round_rate,
+	.set_rate = _clk_nfc_set_rate,
+};
+
+static int _clk_spdif_xtal_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &osc_clk, &ckih_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk spdif_xtal_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_spdif_xtal_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_spdif0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF0_COM;
+	if (parent != &ssi1_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF0_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif0_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	u32 div = 1;
+
+	if (clk->parent != &ssi1_clk[0]) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET) + 1;
+		div = (pred * podf);
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk spdif0_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif0_set_parent,
+	.get_rate = _clk_spdif0_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_spdif1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF1_COM;
+	if (parent != &ssi2_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF1_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif1_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	u32 div = 1;
+
+	if (clk->parent != &ssi2_clk[0]) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET) + 1;
+		div = (pred * podf);
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk spdif1_clk[] = {
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif1_set_parent,
+	.get_rate = _clk_spdif1_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, reg2, mux;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	reg2 = __raw_readl(MXC_CCM_CBCDR);
+	if (cpu_is_mx51()) {
+		clk->parent = &ddr_hf_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, &ddr_hf_clk);
+	} else {
+		clk->parent = &axi_a_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, NULL);
+	}
+	if (mux < 4) {
+		reg = (reg & ~MXC_CCM_CBCMR_DDR_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCMR);
+		if (cpu_is_mx51())
+			reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL);
+	} else {
+		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL) |
+			(MXC_CCM_CBCDR_DDR_HF_SEL);
+	}
+	if (cpu_is_mx51()) {
+		__raw_writel(reg2, MXC_CCM_CBCDR);
+		getnstimeofday(&nstimeofday);
+		while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_DDR_HF_CLK_SEL_BUSY){
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("_clk_ddr_set_parent failed\n");
+		}
+	}
+	return 0;
+}
+
+static struct clk ddr_clk = {
+	.parent = &axi_b_clk,
+	.set_parent = _clk_ddr_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_arm_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk arm_axi_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_arm_axi_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_vpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	/* Set VPU's parent to be axi_a or ahb when its enabled. */
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		clk_set_parent(&vpu_clk[0], &ahb_clk);
+		clk_set_parent(&vpu_clk[1], &ahb_clk);
+	} else if (cpu_is_mx51()) {
+		clk_set_parent(&vpu_clk[0], &axi_a_clk);
+		clk_set_parent(&vpu_clk[1], &axi_a_clk);
+	}
+
+	return _clk_enable(clk);
+
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+
+	/* Set VPU's parent to be axi_b when its disabled. */
+	if (cpu_is_mx51()) {
+		clk_set_parent(&vpu_clk[0], &axi_b_clk);
+		clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	}
+}
+
+static struct clk vpu_clk[] = {
+	{
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &vpu_clk[1],
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_vpu_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_vpu_disable,
+	 .secondary = &vpu_clk[2],
+	 },
+	{
+	 .parent = &emi_fast_clk,
+#ifdef CONFIG_MXC_VPU_IRAM
+	 .secondary = &emi_intr_clk[0],
+#endif
+	 }
+};
+
+static int _clk_lpsr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	mux = _get_mux(parent, &ckil_clk, &osc_clk, NULL, NULL);
+	reg = (reg & ~MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static struct clk lpsr_clk = {
+	.parent = &ckil_clk,
+	.set_parent = _clk_lpsr_set_parent,
+};
+
+static unsigned long _clk_pgc_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	div = (reg & MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK) >>
+	    MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET;
+	div = 1 >> div;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk pgc_clk = {
+	.parent = &ipg_clk,
+	.get_rate = _clk_pgc_get_rate,
+};
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	return 60000000;
+}
+
+/*usb OTG clock */
+static struct clk usb_clk = {
+	.get_rate = _clk_usb_get_rate,
+};
+
+static struct clk usb_utmi_clk = {
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CSCMR1,
+	.enable_shift = MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ata_clk = {
+	.parent = &ipg_clk,
+	.secondary = &spba_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk owire_clk = {
+	.parent = &ipg_perclk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static struct clk fec_clk[] = {
+	{
+	.parent = &ipg_clk,
+	.secondary = &fec_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .parent = &tmax2_clk,
+	 .secondary = &fec_clk[2],
+	},
+	{
+	 .parent = &aips_tz2_clk,
+	 .secondary = &emi_fast_clk,
+	},
+};
+
+static struct clk sahara_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &sahara_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
+};
+
+static struct clk scc_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &scc_clk[1],
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
+};
+
+
+static int _clk_gpu3d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+
+static struct clk garb_clk = {
+	.parent = &axi_a_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpu3d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu3d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	.secondary = &garb_clk,
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long cko1_get_rate(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg = reg >> MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	return clk_get_rate(clk->parent) / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = (parent_rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg |= div << MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return parent_rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg;
+
+	if (parent == &cpu_clk)
+		sel = 0;
+	else if (parent == &pll1_sw_clk)
+		sel = 1;
+	else if (parent == &pll2_sw_clk)
+		sel = 2;
+	else if (parent == &pll3_sw_clk)
+		sel = 3;
+	else if (parent == &emi_slow_clk)
+		sel = 4;
+	else if (parent == &pll4_sw_clk)
+		sel = 5;
+	else if (parent == &emi_enfc_clk)
+		sel = 6;
+	else if (parent == &ipu_di_clk[0])
+		sel = 8;
+	else if (parent == &ahb_clk)
+		sel = 11;
+	else if (parent == &ipg_clk)
+		sel = 12;
+	else if (parent == &ipg_perclk)
+		sel = 13;
+	else if (parent == &ckil_clk)
+		sel = 14;
+	else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_SEL_MASK;
+	reg |= sel << MXC_CCM_CCOSR_CKOL_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.get_rate = cko1_get_rate,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+
+#define _REGISTER_CLOCK(d, n, c) \
+	{ \
+		.dev_id = d, \
+		.con_id = n, \
+		.clk = &c, \
+	}
+
+static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "osc", osc_clk),
+	_REGISTER_CLOCK(NULL, "ckih", ckih_clk),
+	_REGISTER_CLOCK(NULL, "ckih2", ckih2_clk),
+	_REGISTER_CLOCK(NULL, "ckil", ckil_clk),
+	_REGISTER_CLOCK(NULL, "pll1_main_clk", pll1_main_clk),
+	_REGISTER_CLOCK(NULL, "pll1_sw_clk", pll1_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll2", pll2_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll3", pll3_sw_clk),
+	_REGISTER_CLOCK(NULL, "gpc_dvfs_clk", gpc_dvfs_clk),
+	_REGISTER_CLOCK(NULL, "lp_apm", lp_apm_clk),
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk),
+	_REGISTER_CLOCK(NULL, "periph_apm_clk", periph_apm_clk),
+	_REGISTER_CLOCK(NULL, "main_bus_clk", main_bus_clk),
+	_REGISTER_CLOCK(NULL, "axi_a_clk", axi_a_clk),
+	_REGISTER_CLOCK(NULL, "axi_b_clk", axi_b_clk),
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk),
+	_REGISTER_CLOCK(NULL, "ahb_max_clk", ahb_max_clk),
+	_REGISTER_CLOCK(NULL, "vpu_clk", vpu_clk[0]),
+	_REGISTER_CLOCK(NULL, "vpu_core_clk", vpu_clk[1]),
+	_REGISTER_CLOCK(NULL, "nfc_clk", emi_enfc_clk),
+	_REGISTER_CLOCK("mxc_sdma", "sdma_ahb_clk", sdma_clk[0]),
+	_REGISTER_CLOCK("mxc_sdma", "sdma_ipg_clk", sdma_clk[1]),
+	_REGISTER_CLOCK(NULL, "ipu_clk", ipu_clk[0]),
+	_REGISTER_CLOCK("mxc_ipu", "ipu_di0_clk", ipu_di_clk[0]),
+	_REGISTER_CLOCK("mxc_ipu", "ipu_di1_clk", ipu_di_clk[1]),
+	_REGISTER_CLOCK("mxc_ipu", "csi_mclk1", csi0_clk),
+	_REGISTER_CLOCK("mxc_ipu", "csi_mclk2", csi1_clk),
+	_REGISTER_CLOCK("tve.0", NULL, tve_clk),
+	_REGISTER_CLOCK("mxcintuart.0", NULL, uart1_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.1", NULL, uart2_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.2", NULL, uart3_clk[0]),
+	_REGISTER_CLOCK("mxc_i2c.0", NULL, i2c_clk[0]),
+	_REGISTER_CLOCK("mxc_i2c.1", NULL, i2c_clk[1]),
+	_REGISTER_CLOCK("mxc_i2c.2", NULL, i2c_clk[2]),
+	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk[0]),
+	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.0", NULL, cspi1_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.1", NULL, cspi2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.2", NULL, cspi3_clk),
+	_REGISTER_CLOCK(NULL, "ssi_lp_apm_clk", ssi_lp_apm_clk),
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi1_clk[0]),
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi2_clk[0]),
+	_REGISTER_CLOCK(NULL, "ssi_ext1_clk", ssi_ext1_clk),
+	_REGISTER_CLOCK(NULL, "ssi_ext2_clk", ssi_ext2_clk),
+	_REGISTER_CLOCK("mxc_iim.0", NULL, iim_clk),
+	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk),
+	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy_clk[0]),
+	_REGISTER_CLOCK(NULL, "usb_utmi_clk", usb_utmi_clk),
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk),
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.2", NULL, esdhc3_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.3", NULL, esdhc4_clk[0]),
+	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk),
+	_REGISTER_CLOCK(NULL, "ddr_clk", ddr_clk),
+	_REGISTER_CLOCK(NULL, "emi_enfc_clk", emi_enfc_clk),
+	_REGISTER_CLOCK(NULL, "emi_fast_clk", emi_fast_clk),
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.0", emi_intr_clk[0]),
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.1", emi_intr_clk[1]),
+	_REGISTER_CLOCK(NULL, "spdif_xtal_clk", spdif_xtal_clk),
+	_REGISTER_CLOCK("mxc_alsa_spdif.0", NULL, spdif0_clk[0]),
+	_REGISTER_CLOCK("mxc_vpu.0", NULL, vpu_clk[0]),
+	_REGISTER_CLOCK(NULL, "lpsr_clk", lpsr_clk),
+	_REGISTER_CLOCK("mxc_rtc.0", NULL, rtc_clk),
+	_REGISTER_CLOCK("pata_fsl", NULL, ata_clk),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+	_REGISTER_CLOCK(NULL, "sahara_clk", sahara_clk[0]),
+	_REGISTER_CLOCK("mxc_gpu.0", NULL, gpu3d_clk),
+	_REGISTER_CLOCK(NULL, "garb_clk", garb_clk),
+	_REGISTER_CLOCK("mxc_gpu.0", "gpu2d_clk", gpu2d_clk),
+	_REGISTER_CLOCK("mxc_scc.0", NULL, scc_clk[0]),
+	_REGISTER_CLOCK(NULL, "cko1", cko1_clk),
+	_REGISTER_CLOCK(NULL, "gpt", gpt_clk[0]),
+	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0]),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+};
+
+static struct clk_lookup mx51_lookups[] = {
+	_REGISTER_CLOCK("mxc_i2c_hs.3", NULL, hsi2c_serial_clk),
+	_REGISTER_CLOCK("mxc_sim.0", NULL, sim_clk[0]),
+	_REGISTER_CLOCK("mxc_alsa_spdif.0", NULL, spdif1_clk[0]),
+	_REGISTER_CLOCK(NULL, "mipi_hsp_clk", mipi_hsp_clk),
+	_REGISTER_CLOCK(NULL, "ddr_hf_clk", ddr_hf_clk),
+};
+
+static struct clk_lookup mx53_lookups[] = {
+	_REGISTER_CLOCK(NULL, "pll4", pll4_sw_clk),
+	_REGISTER_CLOCK("mxcintuart.3", NULL, uart4_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.4", NULL, uart5_clk[0]),
+	_REGISTER_CLOCK("mxc_i2c.2", NULL, i2c_clk[2]),
+	_REGISTER_CLOCK(NULL, "usb_phy2_clk", usb_phy_clk[1]),
+	_REGISTER_CLOCK(NULL, "ocram_clk", ocram_clk),
+	_REGISTER_CLOCK("imx-sata.0", NULL, sata_clk),
+	_REGISTER_CLOCK(NULL, "ieee_1588_clk", ieee_1588_clk),
+	_REGISTER_CLOCK("mxc_mlb.0", NULL, mlb_clk[0]),
+	_REGISTER_CLOCK("FlexCAN.0", NULL, can1_clk[0]),
+	_REGISTER_CLOCK("FlexCAM.1", NULL, can2_clk[0]),
+	_REGISTER_CLOCK("mxc_ldb", NULL, ldb_di_clk[0]),
+	_REGISTER_CLOCK("mxc_esai.0", NULL, esai_clk[0]),
+};
+
+static void clk_tree_init(void)
+{
+	u32 reg, dp_ctl;
+
+	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
+
+	/*
+	 *Initialise the IPG PER CLK dividers to 3. IPG_PER_CLK should be at
+	 * 8MHz, its derived from lp_apm.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
+	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+
+	if (cpu_is_mx51()) {
+		dp_ctl = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll1_main_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll2_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll2_sw_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll3_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll3_sw_clk.parent = &fpm_clk;
+	} else {
+		/* set pll4_clk parent */
+		pll4_sw_clk.parent = &osc_clk;
+	}
+
+	/* set emi_slow_clk parent */
+	emi_slow_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MXC_CCM_CBCDR_EMI_CLK_SEL) != 0)
+		emi_slow_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+}
+
+
+int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	__iomem void *base;
+	struct clk *tclk;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
+	u32 pll1_rate;
+
+	pll1_base = ioremap(PLL1_BASE_ADDR, SZ_4K);
+	pll2_base = ioremap(PLL2_BASE_ADDR, SZ_4K);
+	pll3_base = ioremap(PLL3_BASE_ADDR, SZ_4K);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG4_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(1 << MXC_CCM_CCGRx_CG8_OFFSET, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG2_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG6_1_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG6_2_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG7_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG8_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG9_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG10_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG11_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG4_OFFSET, MXC_CCM_CCGR6);
+
+	external_low_reference = ckil;
+	external_high_reference = ckih1;
+	ckih2_reference = ckih2;
+	oscillator_reference = osc;
+
+	/* Fix up clocks unique to MX51. */
+	esdhc2_clk[0].get_rate = _clk_esdhc2_get_rate;
+	esdhc2_clk[0].set_rate = _clk_esdhc2_set_rate;
+
+	clk_tree_init();
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+	for (i = 0; i < ARRAY_SIZE(mx51_lookups); i++)
+		clkdev_add(&mx51_lookups[i]);
+
+	max_axi_a_clk = MAX_AXI_A_CLK_MX51;
+	max_axi_b_clk = MAX_AXI_B_CLK_MX51;
+
+	/* set DDR clock parent */
+	reg = 0;
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) >= 1) {
+		reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+		reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+		if (reg)
+			tclk = &ddr_hf_clk;
+	}
+	if (reg == 0) {
+		reg = __raw_readl(MXC_CCM_CBCMR) &
+					MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+		reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+
+		if (reg == 0) {
+			tclk = &axi_a_clk;
+		} else if (reg == 1) {
+			tclk = &axi_b_clk;
+		} else if (reg == 2) {
+			tclk = &emi_slow_clk;
+		} else {
+			tclk = &ahb_clk;
+		}
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	/* Disable the handshake with HSC block as its not
+	  * initialised right now.
+	  */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	clk_enable(&cpu_clk);
+
+	/* Set SDHC parents to be PLL2 */
+	clk_set_parent(&esdhc1_clk[0], &pll2_sw_clk);
+	clk_set_parent(&esdhc2_clk[0], &pll2_sw_clk);
+
+	/* set SDHC root clock as 166.25MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 166250000);
+	clk_set_rate(&esdhc2_clk[0], 166250000);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	clk_set_parent(&gpu3d_clk, &axi_a_clk);
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* move the spdif1 to 24MHz */
+	clk_set_parent(&spdif1_clk[0], &spdif_xtal_clk);
+	/* set the spdif1 dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from SSI1_CLK_ROOT */
+	clk_set_parent(&ssi_ext1_clk, &ssi1_clk[0]);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	if (pll1_rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	for (j = 0; j < cpu_wp_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_wp_tbl[j].cpu_podf =
+				(pll1_rate / cpu_wp_tbl[j].cpu_rate)
+				- 1;
+			if (pll1_rate / (cpu_wp_tbl[j].cpu_podf + 1) >
+					cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_podf++;
+				cpu_wp_tbl[j].cpu_rate =
+					 pll1_rate /
+					 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+				cpu_wp_tbl[j].cpu_rate *= 1000;
+			}
+			if (pll1_rate / (cpu_wp_tbl[j].cpu_podf + 1) <
+						cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_rate = pll1_rate;
+			}
+		}
+	cpu_wp_tbl[j].pll_rate = pll1_rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	clk_set_parent(&arm_axi_clk, &axi_a_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+
+	if (uart_at_24) {
+		/* Move UART to run from lp_apm */
+		clk_set_parent(&uart_main_clk, &lp_apm_clk);
+
+		/* Set the UART dividers to divide, so the UART_CLK is 24MHz. */
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PODF_MASK;
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PRED_MASK;
+		reg |= (0 << MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) |
+		    (0 << MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	} else {
+		/* Move UART to run from PLL1 */
+		clk_set_parent(&uart_main_clk, &pll1_sw_clk);
+
+		/* Set the UART dividers to divide,
+		 * so the UART_CLK is 66.5MHz.
+		 */
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PODF_MASK;
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PRED_MASK;
+		reg |= (5 << MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) |
+		    (1 << MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 130000000));
+
+	/* Change the NFC clock rate to be 1:4 ratio with emi clock. */
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			(clk_get_rate(&emi_slow_clk))/4));
+
+	base = ioremap(GPT1_BASE_ADDR, SZ_4K);
+	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	return 0;
+}
+
+int __init mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	__iomem void *base;
+	struct clk *tclk;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
+	u32 pll1_rate;
+
+	pll1_base = ioremap(MX53_BASE_ADDR(PLL1_BASE_ADDR), SZ_4K);
+	pll2_base = ioremap(MX53_BASE_ADDR(PLL2_BASE_ADDR), SZ_4K);
+	pll3_base = ioremap(MX53_BASE_ADDR(PLL3_BASE_ADDR), SZ_4K);
+	pll4_base = ioremap(MX53_BASE_ADDR(PLL4_BASE_ADDR), SZ_4K);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG4_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(1 << MXC_CCM_CCGRx_CG8_OFFSET, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG2_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG6_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG7_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG8_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG9_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG10_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG11_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(3 << MXC_CCM_CCGRx_CG0_OFFSET |
+				3 << MXC_CCM_CCGRx_CG1_OFFSET |
+				3 << MXC_CCM_CCGRx_CG4_OFFSET |
+				3 << MXC_CCM_CCGRx_CG8_OFFSET |
+				3 << MXC_CCM_CCGRx_CG9_OFFSET |
+				3 << MXC_CCM_CCGRx_CG12_OFFSET |
+				3 << MXC_CCM_CCGRx_CG13_OFFSET , MXC_CCM_CCGR6);
+
+	__raw_writel(0, MXC_CCM_CCGR7);
+
+	external_low_reference = ckil;
+	external_high_reference = ckih1;
+	ckih2_reference = ckih2;
+	oscillator_reference = osc;
+
+	usb_phy_clk[0].enable_reg = MXC_CCM_CCGR4;
+	usb_phy_clk[0].enable_shift = MXC_CCM_CCGRx_CG5_OFFSET;
+
+	ipumux1_clk.enable_reg = MXC_CCM_CCGR5;
+	ipumux1_clk.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET;
+	ipumux2_clk.enable_reg = MXC_CCM_CCGR6;
+	ipumux2_clk.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET;
+
+	esdhc3_clk[0].get_rate = _clk_esdhc3_get_rate;
+	esdhc3_clk[0].set_rate = _clk_sdhc3_set_rate;
+
+#ifdef CONFIG_MXC_VPU_IRAM
+	 vpu_clk[2].secondary = &emi_intr_clk[1];
+#endif
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+	usboh3_clk[1].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	ssi2_clk[2].secondary = &emi_intr_clk[1];
+	ssi1_clk[2].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SDMA_IRAM
+	sdma_clk[1].secondary = &emi_intr_clk[1];
+#endif
+
+	clk_tree_init();
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+	for (i = 0; i < ARRAY_SIZE(mx53_lookups); i++)
+		clkdev_add(&mx53_lookups[i]);
+
+	clk_set_parent(&esai_clk[0], &ckih_clk);
+
+	ldb_di_clk[0].parent = ldb_di_clk[1].parent =
+	tve_clk.parent = &pll4_sw_clk;
+
+	max_axi_a_clk = MAX_AXI_A_CLK_MX53;
+	max_axi_b_clk = MAX_AXI_B_CLK_MX53;
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CBCMR) &
+				MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+	if (reg == 0) {
+		tclk = &axi_a_clk;
+	} else if (reg == 1) {
+		tclk = &axi_b_clk;
+	} else if (reg == 2) {
+		tclk = &emi_slow_clk;
+	} else {
+		tclk = &ahb_clk;
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
+	clk_set_parent(&esdhc1_clk[2], &tmax2_clk);
+	clk_set_parent(&esdhc2_clk[0], &esdhc1_clk[0]);
+	clk_set_parent(&esdhc3_clk[0], &pll2_sw_clk);
+
+	clk_set_parent(&ipu_di_clk[0], &pll4_sw_clk);
+
+#if 0
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+#endif
+
+	clk_enable(&cpu_clk);
+
+	clk_enable(&main_bus_clk);
+
+	/* Set AXI_B_CLK to be 200MHz */
+	clk_set_rate(&axi_b_clk, 200000000);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from PLL2 for camera */
+	clk_disable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext1_clk, &pll2_sw_clk);
+	clk_set_rate(&ssi_ext1_clk, 24000000);
+	clk_enable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+	clk_set_parent(&usb_phy_clk[1], &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	/* set SDHC root clock as 200MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 200000000);
+	clk_set_rate(&esdhc3_clk[0], 200000000);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	if (pll1_rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	for (j = 0; j < cpu_wp_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_wp_tbl[j].cpu_podf =
+				(pll1_rate / cpu_wp_tbl[j].cpu_rate)
+				- 1;
+			if (pll1_rate / (cpu_wp_tbl[j].cpu_podf + 1) >
+					cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_podf++;
+				cpu_wp_tbl[j].cpu_rate =
+					 pll1_rate /
+					 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+				cpu_wp_tbl[j].cpu_rate *= 1000;
+			}
+			if (pll1_rate / (cpu_wp_tbl[j].cpu_podf + 1) <
+						cpu_wp_tbl[j].cpu_rate) {
+				cpu_wp_tbl[j].cpu_rate = pll1_rate;
+			}
+		}
+	cpu_wp_tbl[j].pll_rate = pll1_rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	clk_set_parent(&arm_axi_clk, &axi_b_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+	clk_set_parent(&uart_main_clk, &pll3_sw_clk);
+	clk_set_parent(&gpu3d_clk, &axi_b_clk);
+	clk_set_parent(&gpu2d_clk, &axi_b_clk);
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 130000000));
+
+	/* Change the NFC clock rate to be 1:4 ratio with emi clock. */
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			(clk_get_rate(&emi_slow_clk))/4));
+
+	base = ioremap(MX53_BASE_ADDR(GPT1_BASE_ADDR), SZ_4K);
+	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	return 0;
+}
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 reg;
+	u32 stat;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * If DDR clock is sourced from PLL1, we cannot drop PLL1 freq.
+	 * Use the ARM_PODF to change the freq of the core, leave the PLL1
+	 * freq unchanged.
+	 */
+	if (ddr_clk.parent == &ddr_hf_clk) {
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+		reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CACRR);
+		cpu_curr_wp = wp;
+	} else {
+		struct timespec nstimeofday;
+		struct timespec curtime;
+
+		/* Change the ARM clock to requested frequency */
+		/* First move the ARM clock to step clock which is running
+		 * at 24MHz.
+		 */
+
+		/* Change the source of pll1_sw_clk to be the step_clk */
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		/* Stop the PLL */
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		/* PDF and MFI */
+		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_OP);
+
+		/* MFD */
+		__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_MFD);
+
+		/* MFI */
+		__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_MFN);
+
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg |= MXC_PLL_DP_CTL_UPEN;
+		/* Set the UPEN bits */
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+		/* Forcefully restart the PLL */
+		reg |= MXC_PLL_DP_CTL_RST;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		/* Wait for the PLL to lock */
+		getnstimeofday(&nstimeofday);
+		do {
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("pll1 relock failed\n");
+			stat = __raw_readl(pll1_base + MXC_PLL_DP_CTL) &
+			    MXC_PLL_DP_CTL_LRF;
+		} while (!stat);
+
+		reg = __raw_readl(MXC_CCM_CCSR);
+		/* Move the PLL1 back to the pll1_main_clk */
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		cpu_curr_wp = wp;
+	}
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/clock_mx50.c b/arch/arm/mach-mx5/clock_mx50.c
new file mode 100644
index 0000000..69fc5f6
--- /dev/null
+++ b/arch/arm/mach-mx5/clock_mx50.c
@@ -0,0 +1,3200 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/hrtimer.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/clkdev.h>
+#include <asm/div64.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+
+#include "crm_regs.h"
+
+/* External clock values passed-in by the board code */
+static unsigned long external_high_reference, external_low_reference;
+static unsigned long oscillator_reference, ckih2_reference;
+
+static struct clk pll1_main_clk;
+static struct clk pll1_sw_clk;
+static struct clk pll2_sw_clk;
+static struct clk pll3_sw_clk;
+static struct clk apll_clk;
+static struct clk pfd0_clk;
+static struct clk pfd1_clk;
+static struct clk pfd2_clk;
+static struct clk pfd3_clk;
+static struct clk pfd4_clk;
+static struct clk pfd5_clk;
+static struct clk pfd6_clk;
+static struct clk pfd7_clk;
+static struct clk lp_apm_clk;
+static struct clk weim_clk;
+static struct clk ddr_clk;
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk gpu2d_clk;
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *apll_base;
+
+extern int cpu_wp_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
+static int max_axi_a_clk;
+static int max_axi_b_clk;
+
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+#define WAIT(exp, timeout) \
+({ \
+	struct timespec nstimeofday; \
+	struct timespec curtime; \
+	int result = 1; \
+	getnstimeofday(&nstimeofday); \
+	while (!(exp)) { \
+		getnstimeofday(&curtime); \
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > (timeout)) \
+			result = 0; \
+	} \
+	result; \
+})
+
+#define MAX_AXI_A_CLK_MX50 	400000000
+#define MAX_AXI_B_CLK_MX50 	200000000
+#define MAX_AHB_CLK		133000000
+#define MAX_EMI_SLOW_CLK	133000000
+
+extern int mxc_jtag_enabled;
+extern int uart_at_24;
+extern int cpufreq_trig_needed;
+extern int low_bus_freq_mode;
+
+static int cpu_clk_set_wp(int wp);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+
+static struct clk esdhc3_clk[];
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGRx_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static int _clk_enable_inrun(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
+}
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static unsigned long _clk_round_rate_div(struct clk *clk,
+						unsigned long rate,
+						u32 max_div,
+						u32 *new_div)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = DIV_ROUND_UP(parent_rate, rate);
+	if (div > max_div)
+		div = max_div;
+	else if (div == 0)
+		div++;
+	if (new_div != NULL)
+		*new_div = div;
+
+	return parent_rate / div;
+}
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else
+		BUG();
+
+	return 0;
+}
+
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux8(struct clk *parent, struct clk *m0, struct clk *m1,
+			    struct clk *m2, struct clk *m3, struct clk *m4,
+			    struct clk *m5, struct clk *m6, struct clk *m7)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else if (parent == m5)
+		return 5;
+	else if (parent == m6)
+		return 6;
+	else if (parent == m7)
+		return 7;
+	else
+		BUG();
+
+	return 0;
+}
+
+static inline void __iomem *_get_pll_base(struct clk *pll)
+{
+	if (pll == &pll1_main_clk)
+		return pll1_base;
+	else if (pll == &pll2_sw_clk)
+		return pll2_base;
+	else if (pll == &pll3_sw_clk)
+		return pll3_base;
+	else
+		BUG();
+
+	return NULL;
+}
+
+static unsigned long get_high_reference_clock_rate(struct clk *clk)
+{
+	return external_high_reference;
+}
+
+static unsigned long get_low_reference_clock_rate(struct clk *clk)
+{
+	return external_low_reference;
+}
+
+static unsigned long get_oscillator_reference_clock_rate(struct clk *clk)
+{
+	return oscillator_reference;
+}
+
+static unsigned long get_ckih2_reference_clock_rate(struct clk *clk)
+{
+	return ckih2_reference;
+}
+
+/* External high frequency clock */
+static struct clk ckih_clk = {
+	.get_rate = get_high_reference_clock_rate,
+};
+
+static struct clk ckih2_clk = {
+	.get_rate = get_ckih2_reference_clock_rate,
+};
+
+static struct clk osc_clk = {
+	.get_rate = get_oscillator_reference_clock_rate,
+};
+
+/* External low frequency (32kHz) clock */
+static struct clk ckil_clk = {
+	.get_rate = get_low_reference_clock_rate,
+};
+
+static int apll_enable(struct clk *clk)
+{
+	__raw_writel(1, apll_base + MXC_ANADIG_MISC_SET);
+	return 0;
+}
+
+static void apll_disable(struct clk *clk)
+{
+	__raw_writel(1, apll_base + MXC_ANADIG_MISC_CLR);
+}
+
+static unsigned long apll_get_rate(struct clk *clk)
+{
+	return 480000000;
+}
+
+static struct clk apll_clk = {
+	.get_rate = apll_get_rate,
+	.enable = apll_enable,
+	.disable = apll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long pfd_get_rate(struct clk *clk)
+{
+	u32 frac;
+	u64 rate;
+	frac = __raw_readl(apll_base +
+		(int)clk->enable_reg) >> clk->enable_shift;
+	frac &= MXC_ANADIG_PFD_FRAC_MASK;
+	rate = (u64)clk_get_rate(clk->parent) * 18;
+	do_div(rate, frac);
+	return rate;
+}
+
+static unsigned long pfd_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 frac;
+	u64 tmp;
+	tmp = (u64)clk_get_rate(clk->parent) * 18;
+	do_div(tmp, rate);
+	frac = tmp;
+	frac = frac < 18 ? 18 : frac;
+	frac = frac > 35 ? 35 : frac;
+	do_div(tmp, frac);
+	return tmp;
+}
+
+static int pfd_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 frac;
+	u64 tmp;
+	tmp = (u64)clk_get_rate(clk->parent) * 18;
+	do_div(tmp, rate);
+	frac = tmp;
+	frac = frac < 18 ? 18 : frac;
+	frac = frac > 35 ? 35 : frac;
+	/* clear clk frac bits */
+	__raw_writel(MXC_ANADIG_PFD_FRAC_MASK << clk->enable_shift,
+			apll_base + (int)clk->enable_reg + 8);
+	/* set clk frac bits */
+	__raw_writel(frac << clk->enable_shift,
+			apll_base + (int)clk->enable_reg + 4);
+
+	tmp = (u64)clk_get_rate(clk->parent) * 18;
+	do_div(tmp, frac);
+	return 0;
+}
+
+static int pfd_enable(struct clk *clk)
+{
+	int index;
+	index = _get_mux8(clk, &pfd0_clk, &pfd1_clk, &pfd2_clk, &pfd3_clk,
+			&pfd4_clk, &pfd5_clk, &pfd6_clk, &pfd7_clk);
+	__raw_writel(1 << (index + MXC_ANADIG_PFD_DIS_OFFSET),
+			apll_base + MXC_ANADIG_PLLCTRL_CLR);
+	/* clear clk gate bit */
+	__raw_writel((1 << (clk->enable_shift + 7)),
+			apll_base + (int)clk->enable_reg + 8);
+
+	/* check lock bit */
+	if (!WAIT(__raw_readl(apll_base + MXC_ANADIG_PLLCTRL)
+		  & MXC_ANADIG_APLL_LOCK, 50000)) {
+		__raw_writel(MXC_ANADIG_APLL_FORCE_LOCK,
+			     apll_base + MXC_ANADIG_PLLCTRL_CLR);
+		__raw_writel(MXC_ANADIG_APLL_FORCE_LOCK,
+			     apll_base + MXC_ANADIG_PLLCTRL_SET);
+		if (!WAIT(__raw_readl(apll_base + MXC_ANADIG_PLLCTRL)
+			  & MXC_ANADIG_APLL_LOCK, SPIN_DELAY))
+			panic("pfd_enable failed!\n");
+	}
+
+	return 0;
+}
+
+static void pfd_disable(struct clk *clk)
+{
+	int index;
+	index = _get_mux8(clk, &pfd0_clk, &pfd1_clk, &pfd2_clk, &pfd3_clk,
+			&pfd4_clk, &pfd5_clk, &pfd6_clk, &pfd7_clk);
+	/* set clk gate bit */
+	__raw_writel((1 << (clk->enable_shift + 7)),
+			apll_base + (int)clk->enable_reg + 4);
+	__raw_writel(1 << (index + MXC_ANADIG_PFD_DIS_OFFSET),
+			apll_base + MXC_ANADIG_PLLCTRL_SET);
+}
+
+static struct clk pfd0_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC0,
+	.enable_shift = MXC_ANADIG_PFD0_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd1_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC0,
+	.enable_shift = MXC_ANADIG_PFD1_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd2_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC0,
+	.enable_shift = MXC_ANADIG_PFD2_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd3_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC0,
+	.enable_shift = MXC_ANADIG_PFD3_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd4_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC1,
+	.enable_shift = MXC_ANADIG_PFD4_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd5_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC1,
+	.enable_shift = MXC_ANADIG_PFD5_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd6_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC1,
+	.enable_shift = MXC_ANADIG_PFD6_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk pfd7_clk = {
+	.parent = &apll_clk,
+	.enable_reg = (void *)MXC_ANADIG_FRAC1,
+	.enable_shift = MXC_ANADIG_PFD7_FRAC_OFFSET,
+	.get_rate = pfd_get_rate,
+	.set_rate = pfd_set_rate,
+	.round_rate = pfd_round_rate,
+	.enable = pfd_enable,
+	.disable = pfd_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	void __iomem *pllbase;
+	s64 temp;
+
+	pllbase = _get_pll_base(clk);
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = 2 * clk_get_rate(clk->parent);
+	if (dbl != 0)
+		ref_clk *= 2;
+
+	ref_clk /= (pdf + 1);
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	return temp;
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, reg1;
+	void __iomem *pllbase;
+
+	long mfi, pdf, mfn, mfd = 999999;
+	s64 temp64;
+	unsigned long quad_parent_rate;
+	unsigned long pll_hfsm, dp_ctl;
+
+	pllbase = _get_pll_base(clk);
+
+	quad_parent_rate = 4 * clk_get_rate(clk->parent);
+	pdf = mfi = -1;
+	while (++pdf < 16 && mfi < 5)
+		mfi = rate * (pdf+1) / quad_parent_rate;
+	if (mfi > 15)
+		return -1;
+	pdf--;
+
+	temp64 = rate*(pdf+1) - quad_parent_rate*mfi;
+	do_div(temp64, quad_parent_rate/1000000);
+	mfn = (long)temp64;
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	/* use dpdck0_2 */
+	__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	if (pll_hfsm == 0) {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);
+	} else {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	/* If auto restart is disabled, restart the PLL and
+	  * wait for it to lock.
+	  */
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	if (reg & MXC_PLL_DP_CTL_UPEN) {
+		reg = __raw_readl(pllbase + MXC_PLL_DP_CONFIG);
+		if (!(reg & MXC_PLL_DP_CONFIG_AREN)) {
+			reg1 = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+			reg1 |= MXC_PLL_DP_CTL_RST;
+			__raw_writel(reg1, pllbase + MXC_PLL_DP_CTL);
+		}
+		/* Wait for lock */
+		if (!WAIT(__raw_readl(pllbase + MXC_PLL_DP_CTL)
+			  & MXC_PLL_DP_CTL_LRF, SPIN_DELAY))
+			panic("pll_set_rate: pll relock failed\n");
+	}
+	return 0;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	if (!WAIT(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_LRF,
+				SPIN_DELAY))
+		panic("pll relock failed\n");
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static struct clk pll1_main_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll1_main_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+		/* Set the step_clk parent to be lp_apm, to save power. */
+		mux = _get_mux(&lp_apm_clk, &lp_apm_clk, NULL, &pll2_sw_clk,
+			       &pll3_sw_clk);
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+		    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+	} else {
+		if (parent == &lp_apm_clk) {
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+			reg = __raw_readl(MXC_CCM_CCSR);
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+		} else {
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+			__raw_writel(reg, MXC_CCM_CCSR);
+			reg = __raw_readl(MXC_CCM_CCSR);
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+
+		}
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static unsigned long _clk_pll1_sw_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+	div = 1;
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (clk->parent == &pll2_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;
+	} else if (clk->parent == &pll3_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+/* pll1 switch clock */
+static struct clk pll1_sw_clk = {
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.get_rate = _clk_pll1_sw_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll2_sw_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	} else {
+		reg = (reg & ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL);
+		reg |= MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+	return 0;
+}
+
+/* same as pll2_main_clk. These two clocks should always be the same */
+static struct clk pll2_sw_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.set_rate = _clk_pll_set_rate,
+	.set_parent = _clk_pll2_sw_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+/* same as pll3_main_clk. These two clocks should always be the same */
+static struct clk pll3_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &osc_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	else if (parent == &apll_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static struct clk lp_apm_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_arm_get_rate(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_wp_nr)
+		return -EINVAL;
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_wp_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+
+static struct clk cpu_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_arm_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
+/* TODO: Need to sync with GPC to determine if DVFS is in place so that
+ * the DVFS_PODF divider can be applied in CDCR register.
+ */
+static unsigned long _clk_main_bus_get_rate(struct clk *clk)
+{
+	u32 div = 0;
+
+	if (dvfs_per_divider_active() || low_bus_freq_mode)
+		div  = (__raw_readl(MXC_CCM_CDCR) & 0x3);
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			&lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CBCDR) & ~MX50_CCM_CBCDR_PERIPH_CLK_SEL_MASK;
+	reg |= mux;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	return 0;
+}
+
+static struct clk main_bus_clk = {
+	.parent = &pll2_sw_clk,
+	.set_parent = _clk_main_bus_set_parent,
+	.get_rate = _clk_main_bus_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_axi_a_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (!WAIT(!(__raw_readl(MXC_CCM_CDHIPR)
+	     & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY), SPIN_DELAY))
+		panic("pll _clk_axi_a_set_rate failed\n");
+
+	return 0;
+}
+
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_a_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_a_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_a_get_rate,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_axi_b_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (!WAIT(!(__raw_readl(MXC_CCM_CDHIPR)
+	     & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY), SPIN_DELAY))
+		panic("_clk_axi_b_set_rate failed\n");
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_b_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_b_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_b_get_rate,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_ahb_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+
+static int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AHB_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AHB_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (!WAIT(!(__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AHB_PODF_BUSY),
+				SPIN_DELAY))
+			panic("_clk_ahb_set_rate failed\n");
+
+	return 0;
+}
+
+static unsigned long _clk_ahb_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_AHB_CLK)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk ahb_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_ahb_get_rate,
+	.set_rate = _clk_ahb_set_rate,
+	.round_rate = _clk_ahb_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static int _clk_max_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with MAX when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+
+static void _clk_max_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable_inwait(clk);
+
+	/* No Handshake with MAX when LPM is entered as its disabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk ahb_max_clk = {
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
+static int _clk_weim_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk)
+		reg |= MX50_CCM_CBCDR_WEIM_CLK_SEL;
+	else if (parent == &main_bus_clk)
+		reg &= ~MX50_CCM_CBCDR_WEIM_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	return 0;
+}
+
+static unsigned long _clk_weim_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_weim_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	if (!WAIT(!(__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_EMI_PODF_BUSY),
+		  SPIN_DELAY))
+		panic("_clk_emi_slow_set_rate failed\n");
+
+	return 0;
+}
+
+static unsigned long _clk_weim_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_EMI_SLOW_CLK)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk weim_clk = {
+	.parent = &main_bus_clk,
+	.set_parent = _clk_weim_set_parent,
+	.get_rate = _clk_weim_get_rate,
+	.set_rate = _clk_weim_set_rate,
+	.round_rate = _clk_weim_round_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahbmux1_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
+	       MXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_ipg_per_get_rate(struct clk *clk)
+{
+	u32 reg, prediv1, prediv2, podf;
+
+	if (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {
+		/* the main_bus_clk is the one before the DVFS engine */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		prediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;
+		prediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
+			MXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;
+		return clk_get_rate(clk->parent) / (prediv1 * prediv2 * podf);
+	} else if (clk->parent == &ipg_clk) {
+		return clk_get_rate(&ipg_clk);
+	}
+	BUG();
+	return 0;
+}
+
+static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &main_bus_clk, &lp_apm_clk, &ipg_clk, NULL);
+	if (mux == 2) {
+		reg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+		if (mux == 0)
+			reg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+		else
+			reg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk ipg_perclk = {
+	.parent = &lp_apm_clk,
+	.get_rate = _clk_ipg_per_get_rate,
+	.set_parent = _clk_ipg_per_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipmux1_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk ipmux2_clk = {
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_ocram_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void _clk_ocram_disable(struct clk *clk)
+{
+}
+
+static struct clk ocram_clk = {
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.enable = _clk_ocram_enable,
+	.disable = _clk_ocram_disable,
+};
+
+
+static struct clk aips_tz1_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk gpc_dvfs_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk sdma_clk[] = {
+	{
+	 .parent = &ahb_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .enable = _clk_sdma_enable,
+	 .disable = _clk_sdma_disable,
+	 },
+	{
+	 .parent = &ipg_clk,
+	 },
+};
+
+static struct clk spba_clk = {
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_uart_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent)/(prediv * podf) ;
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk uart_main_clk = {
+	.parent = &pll2_sw_clk,
+	.get_rate = _clk_uart_get_rate,
+	.set_parent = _clk_uart_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART1_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+#ifdef UART1_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART2_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+#ifdef UART2_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART3_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart4_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART4_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart5_clk[] = {
+	{
+	 .id = 4,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart5_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#ifdef UART5_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk gpt_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &gpt_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm1_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm2_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 1,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static unsigned long _clk_cspi_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.parent = &pll3_sw_clk,
+	.get_rate = _clk_cspi_get_rate,
+	.set_parent = _clk_cspi_set_parent,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi3_clk = {
+	.id = 2,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.secondary = &aips_tz2_clk,
+};
+
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static unsigned long _clk_ssi1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .secondary = &ssi1_clk[1],
+	 .get_rate = _clk_ssi1_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi1_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &aips_tz2_clk,
+	 },
+};
+
+static unsigned long _clk_ssi2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .secondary = &ssi2_clk[1],
+	 .get_rate = _clk_ssi2_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi2_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &spba_clk,
+	 },
+};
+
+static unsigned long _clk_ssi_ext1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || div > 512)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~(MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK |
+		 MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	return 0;
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_ssi_ext1_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static struct clk ssi_ext1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.set_rate = _clk_ssi_ext1_set_rate,
+	.round_rate = _clk_ssi_ext1_round_rate,
+	.get_rate = _clk_ssi_ext1_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_ssi_ext2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.get_rate = _clk_ssi_ext2_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax2_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk usb_ahb_clk = {
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk usb_phy_clk[] = {
+	{
+	.id = 0,
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	.id = 1,
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.disable = _clk_disable,
+	}
+};
+
+static struct clk esdhc_dep_clks = {
+	 .parent = &spba_clk,
+};
+
+static unsigned long _clk_esdhc1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = reg & ~MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+
+static int _clk_esdhc1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	 __calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	return 0;
+}
+
+static struct clk esdhc1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc1_set_parent,
+	 .get_rate = _clk_esdhc1_get_rate,
+	 .set_rate = _clk_esdhc1_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc1_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+
+};
+
+static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+	else if (parent == &esdhc3_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk esdhc2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc2_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc2_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	mux = _get_mux8(parent, &pll1_sw_clk, &pll2_sw_clk,
+			&pll3_sw_clk, &lp_apm_clk, &pfd0_clk,
+			&pfd1_clk, &pfd4_clk, &osc_clk);
+	reg = reg & ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_esdhc3_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_esdhc3_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET;
+	 __raw_writel(reg, MXC_CCM_CSCDR1);
+
+	return 0;
+}
+
+
+static struct clk esdhc3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc3_set_parent,
+	 .get_rate = _clk_esdhc3_get_rate,
+	 .set_rate = _clk_esdhc3_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ahb_max_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &esdhc1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else if (parent == &esdhc3_clk[0])
+		reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+	else
+		BUG();
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc4_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc4_clk[1],
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc4_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CLK_DDR);
+	if (parent == &pfd0_clk)
+		reg |= MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	else if (parent == &pll1_sw_clk)
+		reg &= ~MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	else
+		return -EINVAL;
+	return 0;
+}
+
+static unsigned long _clk_ddr_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CLK_DDR);
+	div = (reg & MXC_CCM_CLK_DDR_DDR_DIV_PLL_MASK) >>
+		MXC_CCM_CLK_DDR_DDR_DIV_PLL_OFFSET;
+	if (div)
+		return clk_get_rate(clk->parent) / div;
+
+	return 0;
+}
+
+static struct clk ddr_clk = {
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_ddr_set_parent,
+	.get_rate = _clk_ddr_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_pgc_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	div = (reg & MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK) >>
+	    MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET;
+	div = 1 >> div;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk pgc_clk = {
+	.parent = &ipg_clk,
+	.get_rate = _clk_pgc_get_rate,
+};
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	return 60000000;
+}
+
+/*usb OTG clock */
+static struct clk usb_clk = {
+	.get_rate = _clk_usb_get_rate,
+};
+
+static struct clk rtc_clk = {
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.parent = &ipg_perclk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static struct clk fec_clk[] = {
+	{
+	.parent = &ipg_clk,
+	.secondary = &fec_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .parent = &tmax2_clk,
+	 .secondary = &fec_clk[2],
+	},
+	{
+	 .parent = &aips_tz2_clk,
+	},
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &weim_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk apbh_dma_clk = {
+	.parent = &pll1_sw_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+};
+
+static int _clk_display_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd2_clk, &pll1_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static unsigned long _clk_display_axi_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_DISPLAY_AXI);
+	div &= MXC_CCM_DISPLAY_AXI_DIV_MASK;
+	if (div == 0) { /* gated off */
+		return clk_get_rate(clk->parent);
+	} else {
+		return clk_get_rate(clk->parent) / div;
+	}
+}
+
+static unsigned long _clk_display_axi_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 6) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_display_axi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 6) - 1;
+	_clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_DISPLAY_AXI);
+	reg &= ~MXC_CCM_DISPLAY_AXI_DIV_MASK;
+	reg |= new_div << MXC_CCM_DISPLAY_AXI_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_DISPLAY_AXI);
+
+#if 0
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_DISPLAY_AXI_BUSY)
+		;
+#endif
+
+	return 0;
+}
+
+static struct clk display_axi_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_display_axi_set_parent,
+	.get_rate = _clk_display_axi_get_rate,
+	.set_rate = _clk_display_axi_set_rate,
+	.round_rate = _clk_display_axi_round_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_DISPLAY_AXI,
+	.enable_shift = MXC_CCM_DISPLAY_AXI_CLKGATE_OFFSET,
+};
+
+/* TODO: check Auto-Slow Mode */
+static struct clk pxp_axi_clk = {
+	.parent = &display_axi_clk,
+	.secondary = &apbh_dma_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+};
+
+static struct clk elcdif_axi_clk = {
+	.parent = &display_axi_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+};
+
+static int _clk_elcdif_pix_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd6_clk, &pll1_sw_clk, &ckih_clk);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static unsigned long _clk_elcdif_pix_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	prediv = ((reg & MXC_CCM_ELCDIFPIX_CLK_PRED_MASK) >>
+		  MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_ELCDIFPIX_CLK_PODF_MASK) >>
+		MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static unsigned long _clk_elcdif_pix_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 12) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_elcdif_pix_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 12) - 1;
+	_clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	/* Pre-divider set to 1 - only use PODF for clk dividing */
+	reg &= ~MXC_CCM_ELCDIFPIX_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET;
+	reg &= ~MXC_CCM_ELCDIFPIX_CLK_PODF_MASK;
+	reg |= new_div << MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_ELCDIFPIX);
+
+	return 0;
+}
+
+static struct clk elcdif_pix_clk = {
+	.parent = &osc_clk,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.set_parent = _clk_elcdif_pix_set_parent,
+	.get_rate = _clk_elcdif_pix_get_rate,
+	.round_rate = _clk_elcdif_pix_round_rate,
+	.set_rate = _clk_elcdif_pix_set_rate,
+};
+
+static int _clk_epdc_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd3_clk, &pll1_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static unsigned long _clk_epdc_axi_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_EPDC_AXI);
+	div &= MXC_CCM_EPDC_AXI_DIV_MASK;
+	if (div == 0) { /* gated off */
+		return clk_get_rate(clk->parent);
+	} else {
+		return clk_get_rate(clk->parent) / div;
+	}
+}
+
+static unsigned long _clk_epdc_axi_round_rate_div(struct clk *clk,
+						unsigned long rate,
+						u32 *new_div)
+{
+	u32 div, max_div;
+
+	max_div = (2 << 6) - 1;
+	div = DIV_ROUND_UP(clk_get_rate(clk->parent), rate);
+	if (div > max_div)
+		div = max_div;
+	else if (div == 0)
+		div++;
+	if (new_div != NULL)
+		*new_div = div;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_epdc_axi_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	return _clk_epdc_axi_round_rate_div(clk, rate, NULL);
+}
+
+static int _clk_epdc_axi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div;
+	u32 reg;
+
+	_clk_epdc_axi_round_rate_div(clk, rate, &new_div);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg &= ~MXC_CCM_EPDC_AXI_DIV_MASK;
+	reg |= new_div << MXC_CCM_EPDC_AXI_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_EPDC_AXI_BUSY)
+		;
+
+	return 0;
+}
+
+static int _clk_epdc_axi_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg |= MXC_CCM_CCGRx_CG8_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg |= MXC_CCM_EPDC_AXI_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+
+	return 0;
+}
+
+static void _clk_epdc_axi_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg &= ~MXC_CCM_CCGRx_CG8_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDC_AXI);
+	reg &= ~MXC_CCM_EPDC_AXI_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDC_AXI);
+}
+
+/* TODO: check Auto-Slow Mode */
+static struct clk epdc_axi_clk = {
+	.parent = &apbh_dma_clk,
+	.set_parent = _clk_epdc_axi_set_parent,
+	.get_rate = _clk_epdc_axi_get_rate,
+	.set_rate = _clk_epdc_axi_set_rate,
+	.round_rate = _clk_epdc_axi_round_rate,
+	.enable = _clk_epdc_axi_enable,
+	.disable = _clk_epdc_axi_disable,
+};
+
+
+static int _clk_epdc_pix_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CLKSEQ_BYPASS);
+	mux = _get_mux(parent, &osc_clk, &pfd5_clk, &pll1_sw_clk, &ckih_clk);
+	reg = (reg & ~MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLKSEQ_BYPASS);
+
+	return 0;
+}
+
+static unsigned long _clk_epdc_pix_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	div = __raw_readl(MXC_CCM_EPDCPIX);
+	div &= MXC_CCM_EPDC_PIX_CLK_PODF_MASK;
+	if (div == 0) { /* gated off */
+		return clk_get_rate(clk->parent);
+	} else {
+		return clk_get_rate(clk->parent) / div;
+	}
+}
+
+static unsigned long _clk_epdc_pix_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 max_div = (2 << 12) - 1;
+	return _clk_round_rate_div(clk, rate, max_div, NULL);
+}
+
+static int _clk_epdc_pix_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 new_div, max_div;
+	u32 reg;
+
+	max_div = (2 << 12) - 1;
+	_clk_round_rate_div(clk, rate, max_div, &new_div);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	/* Pre-divider set to 1 - only use PODF for clk dividing */
+	reg &= ~MXC_CCM_EPDC_PIX_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_EPDC_PIX_CLK_PRED_OFFSET;
+	reg &= ~MXC_CCM_EPDC_PIX_CLK_PODF_MASK;
+	reg |= new_div << MXC_CCM_EPDC_PIX_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+
+	while (__raw_readl(MXC_CCM_CSR2) & MXC_CCM_CSR2_EPDC_PIX_BUSY)
+		;
+
+	return 0;
+}
+
+static int _clk_epdc_pix_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg |= MXC_CCM_CCGRx_CG5_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	reg |= MXC_CCM_EPDC_PIX_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+
+	return 0;
+}
+
+static void _clk_epdc_pix_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCGR6);
+	reg &= ~MXC_CCM_CCGRx_CG5_MASK;
+	__raw_writel(reg, MXC_CCM_CCGR6);
+
+	reg = __raw_readl(MXC_CCM_EPDCPIX);
+	reg &= ~MXC_CCM_EPDC_PIX_CLKGATE_MASK;
+	__raw_writel(reg, MXC_CCM_EPDCPIX);
+}
+
+/* TODO: check Auto-Slow Mode */
+static struct clk epdc_pix_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_epdc_pix_set_parent,
+	.get_rate = _clk_epdc_pix_get_rate,
+	.set_rate = _clk_epdc_pix_set_rate,
+	.round_rate = _clk_epdc_pix_round_rate,
+	.enable = _clk_epdc_pix_enable,
+	.disable = _clk_epdc_pix_disable,
+};
+
+static unsigned long cko1_get_rate(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MX50_CCM_CCOSR_CKO1_DIV_MASK;
+	reg = reg >> MX50_CCM_CCOSR_CKO1_DIV_OFFSET;
+	return clk_get_rate(clk->parent) / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MX50_CCM_CCOSR_CKO1_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = (parent_rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_DIV_MASK;
+	reg |= div << MX50_CCM_CCOSR_CKO1_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return parent_rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg, fast;
+
+	if (parent == &cpu_clk) {
+		sel = 0;
+		fast = 1;
+	} else if (parent == &pll1_sw_clk) {
+		sel = 1;
+		fast = 1;
+	} else if (parent == &pll2_sw_clk) {
+		sel = 2;
+		fast = 1;
+	} else if (parent == &pll3_sw_clk) {
+		sel = 3;
+		fast = 1;
+	} else if (parent == &apll_clk) {
+		sel = 0;
+		fast = 0;
+	} else if (parent == &pfd0_clk) {
+		sel = 1;
+		fast = 0;
+	} else if (parent == &pfd1_clk) {
+		sel = 2;
+		fast = 0;
+	} else if (parent == &pfd2_clk) {
+		sel = 3;
+		fast = 0;
+	} else if (parent == &pfd3_clk) {
+		sel = 4;
+		fast = 0;
+	} else if (parent == &pfd4_clk) {
+		sel = 5;
+		fast = 0;
+	} else if (parent == &pfd5_clk) {
+		sel = 6;
+		fast = 0;
+	} else if (parent == &pfd6_clk) {
+		sel = 7;
+		fast = 0;
+	} else if (parent == &weim_clk) {
+		sel = 10;
+		fast = 0;
+	} else if (parent == &ahb_clk) {
+		sel = 11;
+		fast = 0;
+	} else if (parent == &ipg_clk) {
+		sel = 12;
+		fast = 0;
+	} else if (parent == &ipg_perclk) {
+		sel = 13;
+		fast = 0;
+	} else if (parent == &pfd7_clk) {
+		sel = 15;
+		fast = 0;
+	} else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MX50_CCM_CCOSR_CKO1_SEL_MASK;
+	reg |= sel << MX50_CCM_CCOSR_CKO1_SEL_OFFSET;
+	if (fast)
+		reg &= ~MX50_CCM_CCOSR_CKO1_SLOW_SEL;
+	else
+		reg |= MX50_CCM_CCOSR_CKO1_SLOW_SEL;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = cko1_get_rate,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+
+#define _REGISTER_CLOCK(d, n, c) \
+	{ \
+		.dev_id = d, \
+		.con_id = n, \
+		.clk = &c, \
+	}
+
+static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "osc", osc_clk),
+	_REGISTER_CLOCK(NULL, "ckih", ckih_clk),
+	_REGISTER_CLOCK(NULL, "ckih2", ckih2_clk),
+	_REGISTER_CLOCK(NULL, "ckil", ckil_clk),
+	_REGISTER_CLOCK(NULL, "pll1_main_clk", pll1_main_clk),
+	_REGISTER_CLOCK(NULL, "pll1_sw_clk", pll1_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll2", pll2_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll3", pll3_sw_clk),
+	_REGISTER_CLOCK(NULL, "gpc_dvfs_clk", gpc_dvfs_clk),
+	_REGISTER_CLOCK(NULL, "lp_apm", lp_apm_clk),
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk),
+	_REGISTER_CLOCK(NULL, "main_bus_clk", main_bus_clk),
+	_REGISTER_CLOCK(NULL, "axi_a_clk", axi_a_clk),
+	_REGISTER_CLOCK(NULL, "axi_b_clk", axi_b_clk),
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk),
+	_REGISTER_CLOCK(NULL, "ahb_max_clk", ahb_max_clk),
+	_REGISTER_CLOCK("mxc_sdma", "sdma_ahb_clk", sdma_clk[0]),
+	_REGISTER_CLOCK("mxc_sdma", "sdma_ipg_clk", sdma_clk[1]),
+	_REGISTER_CLOCK("mxcintuart.0", NULL, uart1_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.1", NULL, uart2_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.2", NULL, uart3_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.3", NULL, uart4_clk[0]),
+	_REGISTER_CLOCK("mxcintuart.4", NULL, uart5_clk[0]),
+	_REGISTER_CLOCK("mxc_i2c.0", NULL, i2c_clk[0]),
+	_REGISTER_CLOCK("mxc_i2c.1", NULL, i2c_clk[1]),
+	_REGISTER_CLOCK("mxc_i2c.2", NULL, i2c_clk[2]),
+	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk[0]),
+	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.0", NULL, cspi1_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.1", NULL, cspi2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.2", NULL, cspi3_clk),
+	_REGISTER_CLOCK(NULL, "ssi_lp_apm_clk", ssi_lp_apm_clk),
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi1_clk[0]),
+	_REGISTER_CLOCK("mxc_ssi.0", NULL, ssi2_clk[0]),
+	_REGISTER_CLOCK(NULL, "ssi_ext1_clk", ssi_ext1_clk),
+	_REGISTER_CLOCK(NULL, "ssi_ext2_clk", ssi_ext2_clk),
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk),
+	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy_clk[0]),
+	_REGISTER_CLOCK(NULL, "usb_phy2_clk", usb_phy_clk[1]),
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk),
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.2", NULL, esdhc3_clk[0]),
+	_REGISTER_CLOCK("mxsdhci.3", NULL, esdhc4_clk[0]),
+	_REGISTER_CLOCK(NULL, "ddr_clk", ddr_clk),
+	_REGISTER_CLOCK("mxc_rtc.0", NULL, rtc_clk),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+	_REGISTER_CLOCK("mxc_gpu.0", "gpu2d_clk", gpu2d_clk),
+	_REGISTER_CLOCK(NULL, "cko1", cko1_clk),
+	_REGISTER_CLOCK(NULL, "gpt", gpt_clk[0]),
+	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0]),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+};
+
+static void clk_tree_init(void)
+{
+	u32 reg;
+
+	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
+
+	/*
+	 *Initialise the IPG PER CLK dividers to 3. IPG_PER_CLK should be at
+	 * 8MHz, its derived from lp_apm.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
+	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+
+	/* set weim_clk parent */
+	weim_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MX50_CCM_CBCDR_WEIM_CLK_SEL) != 0)
+		weim_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+}
+
+int __init mx50_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1)
+{
+	__iomem void *base;
+	int i = 0, j = 0, reg;
+	int wp_cnt = 0;
+	u32 pll1_rate;
+
+	pll1_base = ioremap(MX53_BASE_ADDR(PLL1_BASE_ADDR), SZ_4K);
+	pll2_base = ioremap(MX53_BASE_ADDR(PLL2_BASE_ADDR), SZ_4K);
+	pll3_base = ioremap(MX53_BASE_ADDR(PLL3_BASE_ADDR), SZ_4K);
+	apll_base = ioremap(ANATOP_BASE_ADDR, SZ_4K);
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG4_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(0, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG6_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG8_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG9_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(3 << MXC_CCM_CCGRx_CG0_OFFSET |
+				3 << MXC_CCM_CCGRx_CG1_OFFSET |
+				3 << MXC_CCM_CCGRx_CG4_OFFSET |
+				3 << MXC_CCM_CCGRx_CG8_OFFSET |
+				3 << MXC_CCM_CCGRx_CG9_OFFSET |
+				3 << MXC_CCM_CCGRx_CG12_OFFSET |
+				3 << MXC_CCM_CCGRx_CG13_OFFSET |
+				2 << MXC_CCM_CCGRx_CG14_OFFSET |
+				3 << MXC_CCM_CCGRx_CG15_OFFSET, MXC_CCM_CCGR6);
+
+	__raw_writel(0, MXC_CCM_CCGR7);
+
+	external_low_reference = ckil;
+	external_high_reference = ckih1;
+	oscillator_reference = osc;
+
+	usb_phy_clk[0].enable_reg = MXC_CCM_CCGR4;
+	usb_phy_clk[0].enable_shift = MXC_CCM_CCGRx_CG5_OFFSET;
+
+	clk_tree_init();
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
+	max_axi_a_clk = MAX_AXI_A_CLK_MX50;
+	max_axi_b_clk = MAX_AXI_B_CLK_MX50;
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CLK_DDR) &
+				MXC_CCM_CLK_DDR_DDR_PFD_SEL;
+	if (reg)
+		clk_set_parent(&ddr_clk, &pfd0_clk);
+	else
+		clk_set_parent(&ddr_clk, &pll1_sw_clk);
+
+	clk_set_parent(&esdhc1_clk[0], &pll2_sw_clk);
+	clk_set_parent(&esdhc1_clk[2], &tmax2_clk);
+	clk_set_parent(&esdhc2_clk[0], &esdhc1_clk[0]);
+	clk_set_parent(&esdhc3_clk[0], &pll2_sw_clk);
+
+	reg = __raw_readl(MXC_CCM_ELCDIFPIX);
+	reg &= ~MXC_CCM_ELCDIFPIX_CLKGATE_MASK;
+	reg = 0x3 << MXC_CCM_ELCDIFPIX_CLKGATE_OFFSET;
+	__raw_writel(reg, MXC_CCM_ELCDIFPIX);
+	clk_set_parent(&elcdif_pix_clk, &pll1_sw_clk);
+
+	clk_enable(&cpu_clk);
+
+	clk_enable(&main_bus_clk);
+
+	/* TO DO
+	clk_enable(&apbh_dma_clk);*/
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+
+	/* set DISPLAY_AXI to 200Mhz */
+	clk_set_parent(&display_axi_clk, &pll1_sw_clk);
+	clk_set_rate(&display_axi_clk, 200000000);
+
+	/* Enable and set EPDC AXI to 200MHz
+	TO DO
+	clk_set_parent(&epdc_axi_clk, &pfd3_clk);
+	clk_enable(&epdc_axi_clk);
+	clk_set_rate(&epdc_axi_clk, 200000000);*/
+
+	clk_set_parent(&epdc_pix_clk, &pfd5_clk);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from PLL2 for camera */
+	clk_disable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext1_clk, &pll2_sw_clk);
+	clk_set_rate(&ssi_ext1_clk, 24000000);
+	clk_enable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+	clk_set_parent(&usb_phy_clk[1], &osc_clk);
+
+	/* set SDHC root clock as 200MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 200000000);
+	clk_set_rate(&esdhc3_clk[0], 200000000);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	if (pll1_rate <= cpu_wp_tbl[cpu_wp_nr - 1].cpu_rate)
+		wp_cnt = 1;
+	else if (pll1_rate <= cpu_wp_tbl[1].cpu_rate &&
+				pll1_rate > cpu_wp_tbl[2].cpu_rate)
+		wp_cnt = cpu_wp_nr - 1;
+	else
+		wp_cnt = cpu_wp_nr;
+
+	cpu_wp_tbl[0].cpu_rate = pll1_rate;
+
+	if (wp_cnt == 1) {
+		cpu_wp_tbl[0] = cpu_wp_tbl[cpu_wp_nr - 1];
+		memset(&cpu_wp_tbl[cpu_wp_nr - 1], 0, sizeof(struct cpu_wp));
+		memset(&cpu_wp_tbl[cpu_wp_nr - 2], 0, sizeof(struct cpu_wp));
+	} else if (wp_cnt < cpu_wp_nr) {
+		for (i = 0; i < wp_cnt; i++)
+			cpu_wp_tbl[i] = cpu_wp_tbl[i+1];
+		memset(&cpu_wp_tbl[i], 0, sizeof(struct cpu_wp));
+	}
+
+	if (wp_cnt < cpu_wp_nr) {
+		set_num_cpu_wp(wp_cnt);
+		cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+	}
+
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	for (j = 0; j < cpu_wp_nr; j++) {
+		/* Change the CPU podf divider based on the boot up
+		 * pll1 rate.
+		 */
+		cpu_wp_tbl[j].cpu_podf = max(
+			(int)((pll1_rate / cpu_wp_tbl[j].cpu_rate)
+			- 1), 0);
+		if (pll1_rate/(cpu_wp_tbl[j].cpu_podf + 1) >
+				cpu_wp_tbl[j].cpu_rate) {
+			cpu_wp_tbl[j].cpu_podf++;
+			cpu_wp_tbl[j].cpu_rate =
+				 pll1_rate/
+				 (1000 * (cpu_wp_tbl[j].cpu_podf + 1));
+			cpu_wp_tbl[j].cpu_rate *= 1000;
+		}
+		if (pll1_rate/(cpu_wp_tbl[j].cpu_podf + 1) <
+					cpu_wp_tbl[j].cpu_rate) {
+			cpu_wp_tbl[j].cpu_rate = pll1_rate;
+		}
+		cpu_wp_tbl[j].pll_rate = pll1_rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_wp_nr)
+		BUG();
+
+	clk_set_parent(&uart_main_clk, &lp_apm_clk);
+	clk_set_parent(&gpu2d_clk, &axi_b_clk);
+
+	clk_set_parent(&weim_clk, &ahb_clk);
+	clk_set_rate(&weim_clk, clk_round_rate(&weim_clk, 130000000));
+
+	base = ioremap(MX53_BASE_ADDR(GPT1_BASE_ADDR), SZ_4K);
+	mxc_timer_init(&gpt_clk[0], base, MXC_INT_GPT);
+	return 0;
+}
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 reg;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * leave the PLL1 freq unchanged.
+	 */
+	reg = __raw_readl(MXC_CCM_CACRR);
+	reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+	reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CACRR);
+	cpu_curr_wp = wp;
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
index 2d37785..93a42e8 100644
--- a/arch/arm/mach-mx5/cpu.c
+++ b/arch/arm/mach-mx5/cpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -12,19 +12,35 @@
  */
 
 #include <linux/types.h>
+#include <linux/err.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/module.h>
+#include <linux/init.h>
+#include <linux/iram_alloc.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <mach/common.h>
 #include <mach/hardware.h>
-#include <asm/io.h>
 
+#define CORTEXA8_PLAT_AMC	0x18
+#define SRPG_NEON_PUPSCR	0x284
+#define SRPG_NEON_PDNSCR	0x288
+#define SRPG_ARM_PUPSCR		0x2A4
+#define SRPG_ARM_PDNSCR		0x2A8
+#define SRPG_EMPGC0_PUPSCR	0x2E4
+#define SRPG_EMPGC0_PDNSCR	0x2E8
+#define SRPG_EMPGC1_PUPSCR	0x304
+#define SRPG_EMPGC1_PDNSCR	0x308
+
+void __iomem *arm_plat_base;
+void __iomem *gpc_base;
 static int cpu_silicon_rev = -1;
 
 #define SI_REV 0x48
 
 static void query_silicon_parameter(void)
 {
-	void __iomem *rom = ioremap(MX51_IROM_BASE_ADDR, MX51_IROM_SIZE);
+	void __iomem *rom = ioremap(IROM_BASE_ADDR, IROM_SIZE);
 	u32 rev;
 
 	if (!rom) {
@@ -35,16 +51,16 @@ static void query_silicon_parameter(void)
 	rev = readl(rom + SI_REV);
 	switch (rev) {
 	case 0x1:
-		cpu_silicon_rev = MX51_CHIP_REV_1_0;
+		cpu_silicon_rev = CHIP_REV_1_0;
 		break;
 	case 0x2:
-		cpu_silicon_rev = MX51_CHIP_REV_1_1;
+		cpu_silicon_rev = CHIP_REV_1_1;
 		break;
 	case 0x10:
-		cpu_silicon_rev = MX51_CHIP_REV_2_0;
+		cpu_silicon_rev = CHIP_REV_2_0;
 		break;
 	case 0x20:
-		cpu_silicon_rev = MX51_CHIP_REV_3_0;
+		cpu_silicon_rev = CHIP_REV_3_0;
 		break;
 	default:
 		cpu_silicon_rev = 0;
@@ -70,29 +86,147 @@ int mx51_revision(void)
 }
 EXPORT_SYMBOL(mx51_revision);
 
+struct cpu_wp *(*get_cpu_wp)(int *wp);
+void (*set_num_cpu_wp)(int num);
+
+static void __init mipi_hsc_disable(void)
+{
+	void __iomem *reg_hsc_mcd = ioremap(MIPI_HSC_BASE_ADDR, SZ_4K);
+	void __iomem *reg_hsc_mxt_conf = reg_hsc_mcd + 0x800;
+	struct clk *clk;
+	uint32_t temp;
+
+	/* Temporarily setup MIPI module to legacy mode */
+	clk = clk_get(NULL, "mipi_hsp_clk");
+	if (!IS_ERR(clk)) {
+		clk_enable(clk);
+
+		/* Temporarily setup MIPI module to legacy mode */
+		__raw_writel(0xF00, reg_hsc_mcd);
+
+		/* CSI mode reserved*/
+		temp = __raw_readl(reg_hsc_mxt_conf);
+		__raw_writel(temp | 0x0FF, reg_hsc_mxt_conf);
+
+		if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0) {
+			temp = __raw_readl(reg_hsc_mxt_conf);
+			__raw_writel(temp | 0x10000, reg_hsc_mxt_conf);
+		}
+
+		clk_disable(clk);
+		clk_put(clk);
+	}
+	iounmap(reg_hsc_mcd);
+}
+
+/*!
+ * This function resets IPU
+ */
+void mx5_ipu_reset(void)
+{
+	u32 *reg;
+	u32 value;
+	reg = ioremap(MX53_BASE_ADDR(SRC_BASE_ADDR), PAGE_SIZE);
+	value = __raw_readl(reg);
+	value = value | 0x8;
+	__raw_writel(value, reg);
+	iounmap(reg);
+}
+
+void mx5_vpu_reset(void)
+{
+	u32 reg;
+	void __iomem *src_base;
+
+	src_base = ioremap(MX53_BASE_ADDR(SRC_BASE_ADDR), PAGE_SIZE);
+
+	/* mask interrupt due to vpu passed reset */
+	reg = __raw_readl(src_base + 0x18);
+	reg |= 0x02;
+	__raw_writel(reg, src_base + 0x18);
+
+	reg = __raw_readl(src_base);
+	reg |= 0x5;    /* warm reset vpu */
+	__raw_writel(reg, src_base);
+	while (__raw_readl(src_base) & 0x04)
+		;
+
+	iounmap(src_base);
+}
+
 static int __init post_cpu_init(void)
 {
-	unsigned int reg;
 	void __iomem *base;
+	unsigned int reg;
+	struct clk *gpcclk = clk_get(NULL, "gpc_dvfs_clk");
+	int iram_size = IRAM_SIZE;
 
-	if (!cpu_is_mx51())
+	if (!cpu_is_mx5())
 		return 0;
 
-	base = MX51_IO_ADDRESS(MX51_AIPS1_BASE_ADDR);
+	if (cpu_is_mx51()) {
+		mipi_hsc_disable();
+
+#if defined(CONFIG_MXC_SECURITY_SCC) || defined(CONFIG_MXC_SECURITY_SCC_MODULE)
+		iram_size -= SCC_RAM_SIZE;
+#endif
+		iram_init(MX51_IRAM_BASE_ADDR, iram_size);
+	} else {
+		iram_init(MX53_IRAM_BASE_ADDR, iram_size);
+	}
+
+	gpc_base = ioremap(MX53_BASE_ADDR(GPC_BASE_ADDR), SZ_4K);
+	clk_enable(gpcclk);
+
+	/* Setup the number of clock cycles to wait for SRPG
+	 * power up and power down requests.
+	 */
+	__raw_writel(0x010F0201, gpc_base + SRPG_ARM_PUPSCR);
+	__raw_writel(0x010F0201, gpc_base + SRPG_NEON_PUPSCR);
+	__raw_writel(0x00000008, gpc_base + SRPG_EMPGC0_PUPSCR);
+	__raw_writel(0x00000008, gpc_base + SRPG_EMPGC1_PUPSCR);
+
+	__raw_writel(0x01010101, gpc_base + SRPG_ARM_PDNSCR);
+	__raw_writel(0x01010101, gpc_base + SRPG_NEON_PDNSCR);
+	__raw_writel(0x00000018, gpc_base + SRPG_EMPGC0_PDNSCR);
+	__raw_writel(0x00000018, gpc_base + SRPG_EMPGC1_PDNSCR);
+
+	clk_disable(gpcclk);
+	clk_put(gpcclk);
+
+	/* Set ALP bits to 000. Set ALP_EN bit in Arm Memory Controller reg. */
+	arm_plat_base = ioremap(MX53_BASE_ADDR(ARM_BASE_ADDR), SZ_4K);
+	reg = 0x8;
+	__raw_writel(reg, arm_plat_base + CORTEXA8_PLAT_AMC);
+
+	base = ioremap(MX53_BASE_ADDR(AIPS1_BASE_ADDR), SZ_4K);
 	__raw_writel(0x0, base + 0x40);
 	__raw_writel(0x0, base + 0x44);
 	__raw_writel(0x0, base + 0x48);
 	__raw_writel(0x0, base + 0x4C);
 	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
 	__raw_writel(reg, base + 0x50);
+	iounmap(base);
 
-	base = MX51_IO_ADDRESS(MX51_AIPS2_BASE_ADDR);
+	base = ioremap(MX53_BASE_ADDR(AIPS2_BASE_ADDR), SZ_4K);
 	__raw_writel(0x0, base + 0x40);
 	__raw_writel(0x0, base + 0x44);
 	__raw_writel(0x0, base + 0x48);
 	__raw_writel(0x0, base + 0x4C);
 	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
 	__raw_writel(reg, base + 0x50);
+	iounmap(base);
+
+	if (cpu_is_mx51() || cpu_is_mx53()) {
+		/*Allow for automatic gating of the EMI internal clock.
+		 * If this is done, emi_intr CCGR bits should be set to 11.
+		 */
+		base = ioremap(MX53_BASE_ADDR(M4IF_BASE_ADDR), SZ_4K);
+		reg = __raw_readl(base + 0x8c);
+		reg &= ~0x1;
+		__raw_writel(reg, base + 0x8c);
+		iounmap(base);
+	}
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx5/crm_regs.h b/arch/arm/mach-mx5/crm_regs.h
index c776b9a..bae16db 100644
--- a/arch/arm/mach-mx5/crm_regs.h
+++ b/arch/arm/mach-mx5/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -11,12 +11,7 @@
 #ifndef __ARCH_ARM_MACH_MX51_CRM_REGS_H__
 #define __ARCH_ARM_MACH_MX51_CRM_REGS_H__
 
-#define MX51_CCM_BASE		MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR)
-#define MX51_DPLL1_BASE		MX51_IO_ADDRESS(MX51_PLL1_BASE_ADDR)
-#define MX51_DPLL2_BASE		MX51_IO_ADDRESS(MX51_PLL2_BASE_ADDR)
-#define MX51_DPLL3_BASE		MX51_IO_ADDRESS(MX51_PLL3_BASE_ADDR)
-#define MX51_CORTEXA8_BASE	MX51_IO_ADDRESS(MX51_ARM_BASE_ADDR)
-#define MX51_GPC_BASE		MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR)
+#define MXC_CCM_BASE	(IO_ADDRESS(CCM_BASE_ADDR))
 
 /* PLL Register Offsets */
 #define MXC_PLL_DP_CTL			0x00
@@ -73,41 +68,103 @@
 #define MXC_PLL_DP_DESTAT_TOG_SEL	(1 << 31)
 #define MXC_PLL_DP_DESTAT_MFN		0x07FFFFFF
 
+/* Register addresses of apll and pfd*/
+#define MXC_ANADIG_FRAC0		0x10
+#define MXC_ANADIG_FRAC0_SET		0x14
+#define MXC_ANADIG_FRAC0_CLR		0x18
+#define MXC_ANADIG_FRAC1		0x20
+#define MXC_ANADIG_FRAC1_SET		0x24
+#define MXC_ANADIG_FRAC1_CLR		0x28
+#define MXC_ANADIG_MISC			0x60
+#define MXC_ANADIG_MISC_SET		0x64
+#define MXC_ANADIG_MISC_CLR		0x68
+#define MXC_ANADIG_PLLCTRL		0x70
+#define MXC_ANADIG_PLLCTRL_SET		0x74
+#define MXC_ANADIG_PLLCTRL_CLR		0x78
+
+/* apll and pfd Register Bit definitions */
+
+#define MXC_ANADIG_PFD3_CLKGATE		(1 << 31)
+#define MXC_ANADIG_PFD3_STABLE		(1 << 30)
+#define MXC_ANADIG_PFD3_FRAC_OFFSET	24
+#define MXC_ANADIG_PFD_FRAC_MASK	0x3F
+#define MXC_ANADIG_PFD2_CLKGATE		(1 << 23)
+#define MXC_ANADIG_PFD2_STABLE		(1 << 22)
+#define MXC_ANADIG_PFD2_FRAC_OFFSET	16
+#define MXC_ANADIG_PFD1_CLKGATE		(1 << 15)
+#define MXC_ANADIG_PFD1_STABLE		(1 << 14)
+#define MXC_ANADIG_PFD1_FRAC_OFFSET	8
+#define MXC_ANADIG_PFD0_CLKGATE		(1 << 7)
+#define MXC_ANADIG_PFD0_STABLE		(1 << 6)
+#define MXC_ANADIG_PFD0_FRAC_OFFSET	0
+
+#define MXC_ANADIG_PFD7_CLKGATE		(1 << 31)
+#define MXC_ANADIG_PFD7_STABLE		(1 << 30)
+#define MXC_ANADIG_PFD7_FRAC_OFFSET	24
+#define MXC_ANADIG_PFD6_CLKGATE		(1 << 23)
+#define MXC_ANADIG_PFD6_STABLE		(1 << 22)
+#define MXC_ANADIG_PFD6_FRAC_OFFSET	16
+#define MXC_ANADIG_PFD5_CLKGATE		(1 << 15)
+#define MXC_ANADIG_PFD5_STABLE		(1 << 14)
+#define MXC_ANADIG_PFD5_FRAC_OFFSET	8
+#define MXC_ANADIG_PFD4_CLKGATE		(1 << 7)
+#define MXC_ANADIG_PFD4_STABLE		(1 << 6)
+#define MXC_ANADIG_PFD4_FRAC_OFFSET	0
+
+#define MXC_ANADIG_APLL_LOCK		(1 << 31)
+#define MXC_ANADIG_APLL_FORCE_LOCK	(1 << 30)
+#define MXC_ANADIG_PFD_DIS_OFFSET	16
+#define MXC_ANADIG_PFD_DIS_MASK		0xff
+#define MXC_ANADIG_APLL_LOCK_CNT_OFFSET	0
+#define MXC_ANADIG_APLL_LOCK_CNT_MASK	0xffff
+
 /* Register addresses of CCM*/
-#define MXC_CCM_CCR		(MX51_CCM_BASE + 0x00)
-#define MXC_CCM_CCDR		(MX51_CCM_BASE + 0x04)
-#define MXC_CCM_CSR		(MX51_CCM_BASE + 0x08)
-#define MXC_CCM_CCSR		(MX51_CCM_BASE + 0x0C)
-#define MXC_CCM_CACRR		(MX51_CCM_BASE + 0x10)
-#define MXC_CCM_CBCDR		(MX51_CCM_BASE + 0x14)
-#define MXC_CCM_CBCMR		(MX51_CCM_BASE + 0x18)
-#define MXC_CCM_CSCMR1		(MX51_CCM_BASE + 0x1C)
-#define MXC_CCM_CSCMR2		(MX51_CCM_BASE + 0x20)
-#define MXC_CCM_CSCDR1		(MX51_CCM_BASE + 0x24)
-#define MXC_CCM_CS1CDR		(MX51_CCM_BASE + 0x28)
-#define MXC_CCM_CS2CDR		(MX51_CCM_BASE + 0x2C)
-#define MXC_CCM_CDCDR		(MX51_CCM_BASE + 0x30)
-#define MXC_CCM_CHSCDR		(MX51_CCM_BASE + 0x34)
-#define MXC_CCM_CSCDR2		(MX51_CCM_BASE + 0x38)
-#define MXC_CCM_CSCDR3		(MX51_CCM_BASE + 0x3C)
-#define MXC_CCM_CSCDR4		(MX51_CCM_BASE + 0x40)
-#define MXC_CCM_CWDR		(MX51_CCM_BASE + 0x44)
-#define MXC_CCM_CDHIPR		(MX51_CCM_BASE + 0x48)
-#define MXC_CCM_CDCR		(MX51_CCM_BASE + 0x4C)
-#define MXC_CCM_CTOR		(MX51_CCM_BASE + 0x50)
-#define MXC_CCM_CLPCR		(MX51_CCM_BASE + 0x54)
-#define MXC_CCM_CISR		(MX51_CCM_BASE + 0x58)
-#define MXC_CCM_CIMR		(MX51_CCM_BASE + 0x5C)
-#define MXC_CCM_CCOSR		(MX51_CCM_BASE + 0x60)
-#define MXC_CCM_CGPR		(MX51_CCM_BASE + 0x64)
-#define MXC_CCM_CCGR0		(MX51_CCM_BASE + 0x68)
-#define MXC_CCM_CCGR1		(MX51_CCM_BASE + 0x6C)
-#define MXC_CCM_CCGR2		(MX51_CCM_BASE + 0x70)
-#define MXC_CCM_CCGR3		(MX51_CCM_BASE + 0x74)
-#define MXC_CCM_CCGR4		(MX51_CCM_BASE + 0x78)
-#define MXC_CCM_CCGR5		(MX51_CCM_BASE + 0x7C)
-#define MXC_CCM_CCGR6		(MX51_CCM_BASE + 0x80)
-#define MXC_CCM_CMEOR		(MX51_CCM_BASE + 0x84)
+#define MXC_CCM_CCR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_CCDR		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CSR		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CACRR		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CBCDR		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_CBCMR		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_CSCMR1		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CSCMR2		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CSCDR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CS1CDR		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CS2CDR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_CDCDR		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_CHSCDR		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_CSCDR2		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_CSCDR3		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_CSCDR4		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_CWDR		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_CDHIPR		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_CDCR		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_CTOR		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_CLPCR		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_CISR		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_CIMR		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_CCOSR		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_CGPR		(MXC_CCM_BASE + 0x64)
+#define MXC_CCM_CCGR0		(MXC_CCM_BASE + 0x68)
+#define MXC_CCM_CCGR1		(MXC_CCM_BASE + 0x6C)
+#define MXC_CCM_CCGR2		(MXC_CCM_BASE + 0x70)
+#define MXC_CCM_CCGR3		(MXC_CCM_BASE + 0x74)
+#define MXC_CCM_CCGR4		(MXC_CCM_BASE + 0x78)
+#define MXC_CCM_CCGR5		(MXC_CCM_BASE + 0x7C)
+#define MXC_CCM_CCGR6		(MXC_CCM_BASE + 0x80)
+#define MXC_CCM_CCGR7		(MXC_CCM_BASE + 0x84)
+#define MXC_CCM_CMEOR		(MXC_CCM_BASE + 0x88)
+#define MXC_CCM_CSR2		(MXC_CCM_BASE + 0x8C)
+#define MXC_CCM_CLKSEQ_BYPASS	(MXC_CCM_BASE + 0x90)
+#define MXC_CCM_CLK_SYS		(MXC_CCM_BASE + 0x94)
+#define MXC_CCM_CLK_DDR		(MXC_CCM_BASE + 0x98)
+#define MXC_CCM_ELCDIFPIX	(MXC_CCM_BASE + 0x9C)
+#define MXC_CCM_EPDCPIX		(MXC_CCM_BASE + 0xA0)
+#define MXC_CCM_DISPLAY_AXI	(MXC_CCM_BASE + 0xA4)
+#define MXC_CCM_EPDC_AXI	(MXC_CCM_BASE + 0xA8)
+#define MXC_CCM_GPMI		(MXC_CCM_BASE + 0xAC)
+#define MXC_CCM_BCH		(MXC_CCM_BASE + 0xB0)
+#define MXC_CCM_MSHC_XMSCKI	(MXC_CCM_BASE + 0xB4)
 
 /* Define the bits in register CCR */
 #define MXC_CCM_CCR_COSC_EN		(1 << 12)
@@ -119,82 +176,101 @@
 #define MXC_CCM_CCR_OSCNT_MASK	(0xFF)
 
 /* Define the bits in register CCDR */
+/* MX51 */
 #define MXC_CCM_CCDR_HSC_HS_MASK	(0x1 << 18)
 #define MXC_CCM_CCDR_IPU_HS_MASK	(0x1 << 17)
 #define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
+/* MX53 */
+#define MXC_CCM_CCDR_IPU_HS_MX53_MASK	(0x1 << 21)
+#define MXC_CCM_CCDR_EMI_HS_INT2_MASK	(0x1 << 20)
+#define MXC_CCM_CCDR_EMI_HS_INT1_MASK	(0x1 << 19)
+#define MXC_CCM_CCDR_EMI_HS_SLOW_MASK	(0x1 << 18)
+#define MXC_CCM_CCDR_EMI_HS_FAST_MASK	(0x1 << 17)
+#define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
 
 /* Define the bits in register CSR */
 #define MXC_CCM_CSR_COSR_READY	(1 << 5)
-#define MXC_CCM_CSR_LVS_VALUE	(1 << 4)
+#define MXC_CCM_CSR_LVS_VALUE		(1 << 4)
 #define MXC_CCM_CSR_CAMP2_READY	(1 << 3)
 #define MXC_CCM_CSR_CAMP1_READY	(1 << 2)
 #define MXC_CCM_CSR_FPM_READY	(1 << 1)
-#define MXC_CCM_CSR_REF_EN_B	(1 << 0)
+#define MXC_CCM_CSR_TEMP_MON_ALARM	(1 << 1)
+#define MXC_CCM_CSR_REF_EN_B		(1 << 0)
 
 /* Define the bits in register CCSR */
-#define MXC_CCM_CCSR_LP_APM_SEL		(0x1 << 9)
-#define MXC_CCM_CCSR_STEP_SEL_OFFSET	(7)
-#define MXC_CCM_CCSR_STEP_SEL_MASK	(0x3 << 7)
+#define MXC_CCM_CCSR_PLL3_PFD_EN		(0x1 << 13)
+#define MXC_CCM_CCSR_PLL2_PFD_EN		(0x1 << 12)
+#define MXC_CCM_CCSR_PLL1_PFD_EN		(0x1 << 11)
+#define MXC_CCM_CCSR_LP_APM_SEL			(0x1 << 10)
+#define MXC_CCM_CCSR_LP_APM_SE_MX51L		(0x1 << 9)
+#define MXC_CCM_CCSR_PLL4_SW_CLK_SEL		(1 << 9)
+#define MXC_CCM_CCSR_STEP_SEL_OFFSET		(7)
+#define MXC_CCM_CCSR_STEP_SEL_MASK		(0x3 << 7)
 #define MXC_CCM_CCSR_STEP_SEL_LP_APM	   0
 #define MXC_CCM_CCSR_STEP_SEL_PLL1_BYPASS  1 /* Only when JTAG connected? */
 #define MXC_CCM_CCSR_STEP_SEL_PLL2_DIVIDED 2
 #define MXC_CCM_CCSR_STEP_SEL_PLL3_DIVIDED 3
 #define MXC_CCM_CCSR_PLL2_PODF_OFFSET	(5)
-#define MXC_CCM_CCSR_PLL2_PODF_MASK	(0x3 << 5)
+#define MXC_CCM_CCSR_PLL2_PODF_MASK		(0x3 << 5)
 #define MXC_CCM_CCSR_PLL3_PODF_OFFSET	(3)
-#define MXC_CCM_CCSR_PLL3_PODF_MASK	(0x3 << 3)
+#define MXC_CCM_CCSR_PLL3_PODF_MASK		(0x3 << 3)
 #define MXC_CCM_CCSR_PLL1_SW_CLK_SEL	(1 << 2) /* 0: pll1_main_clk,
 						    1: step_clk */
-#define MXC_CCM_CCSR_PLL2_SW_CLK_SEL	(1 << 1)
-#define MXC_CCM_CCSR_PLL3_SW_CLK_SEL	(1 << 0)
+#define MXC_CCM_CCSR_PLL2_SW_CLK_SEL		(1 << 1)
+#define MXC_CCM_CCSR_PLL3_SW_CLK_SEL		(1 << 0)
 
 /* Define the bits in register CACRR */
 #define MXC_CCM_CACRR_ARM_PODF_OFFSET	(0)
-#define MXC_CCM_CACRR_ARM_PODF_MASK	(0x7)
+#define MXC_CCM_CACRR_ARM_PODF_MASK		(0x7)
 
 /* Define the bits in register CBCDR */
-#define MXC_CCM_CBCDR_EMI_CLK_SEL		(0x1 << 26)
-#define MXC_CCM_CBCDR_PERIPH_CLK_SEL		(0x1 << 25)
+#define MX50_CCM_CBCDR_WEIM_CLK_SEL		(0x1 << 27)
+#define MXC_CCM_CBCDR_EMI_CLK_SEL			(0x1 << 26)
+#define MXC_CCM_CBCDR_PERIPH_CLK_SEL			(0x1 << 25)
+#define MX50_CCM_CBCDR_PERIPH_CLK_SEL_OFFSET	(25)
+#define MX50_CCM_CBCDR_PERIPH_CLK_SEL_MASK	(0x3 << 25)
 #define MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET		(30)
-#define MXC_CCM_CBCDR_DDR_HF_SEL		(0x1 << 30)
+#define MXC_CCM_CBCDR_DDR_HF_SEL			(0x1 << 30)
 #define MXC_CCM_CBCDR_DDR_PODF_OFFSET		(27)
-#define MXC_CCM_CBCDR_DDR_PODF_MASK		(0x7 << 27)
+#define MXC_CCM_CBCDR_DDR_PODF_MASK			(0x7 << 27)
 #define MXC_CCM_CBCDR_EMI_PODF_OFFSET		(22)
-#define MXC_CCM_CBCDR_EMI_PODF_MASK		(0x7 << 22)
+#define MXC_CCM_CBCDR_EMI_PODF_MASK			(0x7 << 22)
 #define MXC_CCM_CBCDR_AXI_B_PODF_OFFSET		(19)
 #define MXC_CCM_CBCDR_AXI_B_PODF_MASK		(0x7 << 19)
 #define MXC_CCM_CBCDR_AXI_A_PODF_OFFSET		(16)
 #define MXC_CCM_CBCDR_AXI_A_PODF_MASK		(0x7 << 16)
 #define MXC_CCM_CBCDR_NFC_PODF_OFFSET		(13)
-#define MXC_CCM_CBCDR_NFC_PODF_MASK		(0x7 << 13)
+#define MXC_CCM_CBCDR_NFC_PODF_MASK			(0x7 << 13)
 #define MXC_CCM_CBCDR_AHB_PODF_OFFSET		(10)
-#define MXC_CCM_CBCDR_AHB_PODF_MASK		(0x7 << 10)
+#define MXC_CCM_CBCDR_AHB_PODF_MASK			(0x7 << 10)
 #define MXC_CCM_CBCDR_IPG_PODF_OFFSET		(8)
-#define MXC_CCM_CBCDR_IPG_PODF_MASK		(0x3 << 8)
-#define MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET	(6)
+#define MXC_CCM_CBCDR_IPG_PODF_MASK			(0x3 << 8)
+#define MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET		(6)
 #define MXC_CCM_CBCDR_PERCLK_PRED1_MASK		(0x3 << 6)
-#define MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET	(3)
+#define MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET		(3)
 #define MXC_CCM_CBCDR_PERCLK_PRED2_MASK		(0x7 << 3)
-#define MXC_CCM_CBCDR_PERCLK_PODF_OFFSET	(0)
+#define MXC_CCM_CBCDR_PERCLK_PODF_OFFSET		(0)
 #define MXC_CCM_CBCDR_PERCLK_PODF_MASK		(0x7)
 
 /* Define the bits in register CBCMR */
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET		(16)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET	(14)
-#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK	(0x3 << 14)
-#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET	(12)
-#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK	(0x3 << 12)
-#define MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET	(10)
+#define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK		(0x3 << 14)
+#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET		(12)
+#define MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET		(10)
 #define MXC_CCM_CBCMR_DDR_CLK_SEL_MASK		(0x3 << 10)
 #define MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET	(8)
-#define MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK	(0x3 << 8)
+#define MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK		(0x3 << 8)
 #define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_OFFSET	(6)
-#define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK	(0x3 << 6)
-#define MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET	(4)
+#define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK		(0x3 << 6)
+#define MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET		(4)
 #define MXC_CCM_CBCMR_GPU_CLK_SEL_MASK		(0x3 << 4)
-#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET	(14)
-#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK	(0x3 << 14)
-#define MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL	(0x1 << 1)
-#define MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL	(0x1 << 0)
+#define MXC_CCM_CBCMR_DBG_APB_CLK_SEL_OFFSET	(2)
+#define MXC_CCM_CBCMR_DBG_APB_CLK_SEL_MASK	(0x3 << 2)
+#define MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL		(0x1 << 1)
+#define MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL		(0x1 << 0)
 
 /* Define the bits in register CSCMR1 */
 #define MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET		(30)
@@ -203,96 +279,126 @@
 #define MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK		(0x3 << 28)
 #define MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET		(26)
 #define MXC_CCM_CSCMR1_USB_PHY_CLK_SEL			(0x1 << 26)
-#define MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET		(24)
-#define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK		(0x3 << 24)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET			(24)
+#define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK			(0x3 << 24)
 #define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET		(22)
-#define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK		(0x3 << 22)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET	(20)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK	(0x3 << 20)
-#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL			(0x1 << 19)
+#define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK			(0x3 << 22)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET	(20)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51		(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC2_CLK_SEL			(0x1 << 19)
 #define MXC_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 18)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET	(16)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK	(0x3 << 16)
-#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET		(14)
-#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK		(0x3 << 14)
-#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET		(12)
-#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK		(0x3 << 12)
-#define MXC_CCM_CSCMR1_SSI3_CLK_SEL			(0x1 << 11)
-#define MXC_CCM_CSCMR1_VPU_RCLK_SEL			(0x1 << 10)
+#define MX50_CCM_CSCMR1_ESDHC1_CLK_SEL_OFFSET	(21)
+#define MX50_CCM_CSCMR1_ESDHC1_CLK_SEL_MASK	(0x3 << 21)
+#define MX50_CCM_CSCMR1_ESDHC2_CLK_SEL			(0x1 << 20)
+#define MX50_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK		(0x3 << 16)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET			(14)
+#define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK			(0x3 << 14)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET			(12)
+#define MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK			(0x3 << 12)
+#define MXC_CCM_CSCMR1_SSI3_CLK_SEL				(0x1 << 11)
+#define MXC_CCM_CSCMR1_VPU_RCLK_SEL				(0x1 << 10)
 #define MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET		(8)
 #define MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK		(0x3 << 8)
-#define MXC_CCM_CSCMR1_TVE_CLK_SEL			(0x1 << 7)
+#define MXC_CCM_CSCMR1_TVE_CLK_SEL				(0x1 << 7)
 #define MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL			(0x1 << 6)
-#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET		(4)
-#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK		(0x3 << 4)
-#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET		(2)
-#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK		(0x3 << 2)
-#define MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL		(0x1 << 1)
-#define MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL		(0x1)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET			(4)
+#define MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK			(0x3 << 4)
+#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET			(2)
+#define MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK			(0x3 << 2)
+#define MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL			(0x1 << 1)
+#define MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL			(0x1)
 
 /* Define the bits in register CSCMR2 */
 #define MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(n)		(26+n*3)
 #define MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(n)		(0x7 << (26+n*3))
-#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET		(24)
-#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK		(0x3 << 24)
-#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET		(22)
-#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK		(0x3 << 22)
+#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET	(24)
+#define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK	(0x3 << 24)
+#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET	(22)
+#define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK	(0x3 << 22)
+/* MX51 */
 #define MXC_CCM_CSCMR2_ESC_CLK_SEL_OFFSET		(20)
-#define MXC_CCM_CSCMR2_ESC_CLK_SEL_MASK			(0x3 << 20)
+#define MXC_CCM_CSCMR2_ESC_CLK_SEL_MASK		(0x3 << 20)
 #define MXC_CCM_CSCMR2_HSC2_CLK_SEL_OFFSET		(18)
 #define MXC_CCM_CSCMR2_HSC2_CLK_SEL_MASK		(0x3 << 18)
 #define MXC_CCM_CSCMR2_HSC1_CLK_SEL_OFFSET		(16)
 #define MXC_CCM_CSCMR2_HSC1_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_OFFSET		(14)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_MASK		(0x3 << 14)
+/* MX53 */
+#define MXC_CCM_CSCMR2_ASRC_CLK_SEL				(1<<21)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET		(19)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK		(0x3 << 19)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK		(0x7 << 16)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_OFFSET		(14)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_MASK		(0x3 << 14)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_OFFSET		(12)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_MASK		(0x3 << 12)
+/* MX51 */
 #define MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET		(10)
-#define MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK			(0x3 << 10)
+#define MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK		(0x3 << 10)
 #define MXC_CCM_CSCMR2_SLIMBUS_COM			(0x1 << 9)
-#define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_OFFSET		(6)
+#define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_OFFSET	(6)
 #define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_MASK		(0x7 << 6)
+/* MX53 */
+#define MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV			(0x1 << 11)
+#define MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV			(0x1 << 10)
+#define MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL			(0x1 << 9)
+#define MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL			(0x1 << 8)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		(6)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK		(0x3 << 6)
 #define MXC_CCM_CSCMR2_SPDIF1_COM			(1 << 5)
 #define MXC_CCM_CSCMR2_SPDIF0_COM			(1 << 4)
-#define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET		(2)
+#define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET	(2)
 #define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK		(0x3 << 2)
-#define MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET		(0)
+#define MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET	(0)
 #define MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK		(0x3)
 
 /* Define the bits in register CSCDR1 */
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET	(22)
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK		(0x7 << 22)
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET	(19)
-#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK	(0x7 << 19)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET	(16)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK	(0x7 << 16)
-#define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET		(14)
-#define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK		(0x3 << 14)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET	(11)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK	(0x7 << 11)
+#define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK	(0x7 << 16)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET			(14)
+#define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK			(0x3 << 14)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET	(11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK	(0x7 << 11)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		(8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		(6)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK		(0x3 << 6)
 #define MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET		(3)
-#define MXC_CCM_CSCDR1_UART_CLK_PRED_MASK		(0x7 << 3)
+#define MXC_CCM_CSCDR1_UART_CLK_PRED_MASK			(0x7 << 3)
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		(0)
-#define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		(0x7)
+#define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK			(0x7)
 
 /* Define the bits in register CS1CDR and CS2CDR */
-#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET		(22)
-#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK		(0x7 << 22)
-#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET		(16)
-#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET	(25)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET	(16)
+#define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK	(0x3F << 16)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET		(9)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK	(0x7 << 9)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		(6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		(0)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK		(0x3F)
 
-#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET		(22)
-#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK		(0x7 << 22)
-#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET		(16)
-#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK	(0x7 << 22)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET	(16)
+#define MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK	(0x3F << 16)
 #define MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET		(6)
 #define MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET		(0)
@@ -300,50 +406,74 @@
 
 /* Define the bits in register CDCDR */
 #define MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET		(28)
-#define MXC_CCM_CDCDR_TVE_CLK_PRED_MASK			(0x7 << 28)
-#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET		(25)
+#define MXC_CCM_CDCDR_TVE_CLK_PRED_MASK		(0x7 << 28)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET	(25)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
-#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET		(19)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET	(19)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x3F << 19)
-#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET		(16)
+/* MX51 */
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET	(16)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 16)
-#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET		(9)
+/* MX53 */
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET		(16)
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_MASK			(0x7 << 16)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET	(9)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK		(0x3F << 9)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET		(6)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_MASK			(0x7 << 6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET		(3)
-#define MXC_CCM_CDCDR_USB_PHY_PRED_MASK			(0x7 << 3)
+#define MXC_CCM_CDCDR_USB_PHY_PRED_MASK		(0x7 << 3)
 #define MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET		(0)
-#define MXC_CCM_CDCDR_USB_PHY_PODF_MASK			(0x7)
+#define MXC_CCM_CDCDR_USB_PHY_PODF_MASK		(0x7)
 
 /* Define the bits in register CHSCCDR */
+/* MX51 */
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_OFFSET		(12)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_MASK		(0x7 << 12)
-#define MXC_CCM_CHSCCDR_ESC_CLK_PODF_OFFSET		(6)
+#define MXC_CCM_CHSCCDR_ESC_CLK_PODF_OFFSET	(6)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PODF_MASK		(0x3F << 6)
-#define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_OFFSET		(3)
+#define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_OFFSET	(3)
 #define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_MASK		(0x7 << 3)
-#define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_OFFSET		(0)
+#define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_OFFSET	(0)
 #define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_MASK		(0x7)
+/* MX53 */
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_OFFSET		(6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_MASK			(0x3 << 6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_OFFSET		(4)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_MASK			(0x3 << 4)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_OFFSET		(2)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_MASK		(0x3 << 2)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_OFFSET		(0)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_MASK		(0x3)
 
 /* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_OFFSET	(28)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_MASK		(0x7 << 28)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET		(25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET		(19)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK		(0x3F << 19)
+/* MX51 */
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET		(16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK		(0x7 << 16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET		(9)
 #define MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK		(0x3F << 9)
-#define MXC_CCM_CSCDR2_SLIMBUS_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CSCDR2_SLIMBUS_CLK_PRED_OFFSET	(6)
 #define MXC_CCM_CSCDR2_SLIMBUS_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_OFFSET		(0)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_MASK		(0x3F)
+/* MX53 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_MASK		(0x3F)
 
 /* Define the bits in register CSCDR3 */
-#define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET		(16)
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET	(16)
 #define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK		(0x7 << 16)
-#define MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET		(9)
+#define MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET	(9)
 #define MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK		(0x3F << 9)
 #define MXC_CCM_CSCDR3_FIRI_CLK_PRED_OFFSET		(6)
 #define MXC_CCM_CSCDR3_FIRI_CLK_PRED_MASK		(0x7 << 6)
@@ -352,13 +482,13 @@
 
 /* Define the bits in register CSCDR4 */
 #define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET	(16)
-#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK		(0x7 << 16)
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK	(0x7 << 16)
 #define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET	(9)
-#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK	(0x3F << 9)
 #define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET	(6)
-#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK	(0x7 << 6)
 #define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET	(0)
-#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK		(0x3F)
+#define MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK	(0x3F)
 
 /* Define the bits in register CDHIPR */
 #define MXC_CCM_CDHIPR_ARM_PODF_BUSY			(1 << 16)
@@ -373,58 +503,92 @@
 #define MXC_CCM_CDHIPR_AXI_A_PODF_BUSY			(1 << 0)
 
 /* Define the bits in register CDCR */
-#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER		(0x1 << 2)
-#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET	(0)
+#define MX50_CCM_CDCR_SW_PERIPH_CLK_DIV_REQ_STATUS	(0x1 << 7)
+#define MX50_CCM_CDCR_SW_PERIPH_CLK_DIV_REQ		(0x1 << 6)
+#define MX50_CCM_CDCR_SW_DVFS_EN				(0x1 << 5)
+#define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER			(0x1 << 2)
+#define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET		(0)
 #define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK		(0x3)
 
 /* Define the bits in register CLPCR */
+/* MX51 */
 #define MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS		(0x1 << 23)
-#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS		(0x1 << 22)
-#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS		(0x1 << 21)
-#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS	(0x1 << 20)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51		(0x1 << 20)
+/* MX53 */
+#define MXC_CCM_CLPCR_BYPASS_CAN2_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_CAN1_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX53			(0x1 << 26)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS			(0x1 << 25)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS			(0x1 << 24)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT2_LPM_HS		(0x1 << 23)
+#define MX50_CCM_CLPCR_BYPASS_RNGB_LPM_HS		(0x1 << 23)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT1_LPM_HS		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_EMI_SLOW_LPM_HS		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_EMI_FAST_LPM_HS		(0x1 << 20)
 #define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS		(0x1 << 19)
 #define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS		(0x1 << 18)
-#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS	(0x1 << 17)
-#define MXC_CCM_CLPCR_BYPASS_RNGC_LPM_HS	(0x1 << 16)
-#define MXC_CCM_CLPCR_COSC_PWRDOWN		(0x1 << 11)
+#define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS		(0x1 << 17)
+#define MXC_CCM_CLPCR_BYPASS_RNGC_LPM_HS		(0x1 << 16)
+#define MXC_CCM_CLPCR_COSC_PWRDOWN			(0x1 << 11)
 #define MXC_CCM_CLPCR_STBY_COUNT_OFFSET		(9)
 #define MXC_CCM_CLPCR_STBY_COUNT_MASK		(0x3 << 9)
-#define MXC_CCM_CLPCR_VSTBY			(0x1 << 8)
-#define MXC_CCM_CLPCR_DIS_REF_OSC		(0x1 << 7)
-#define MXC_CCM_CLPCR_SBYOS			(0x1 << 6)
-#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM	(0x1 << 5)
-#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET	(3)
+#define MXC_CCM_CLPCR_VSTBY				(0x1 << 8)
+#define MXC_CCM_CLPCR_DIS_REF_OSC			(0x1 << 7)
+#define MXC_CCM_CLPCR_SBYOS				(0x1 << 6)
+#define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM		(0x1 << 5)
+#define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET		(3)
 #define MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK		(0x3 << 3)
-#define MXC_CCM_CLPCR_LPM_OFFSET		(0)
+#define MXC_CCM_CLPCR_BYPASS_PMIC_VFUNC_READY		(0x1 << 2)
+#define MXC_CCM_CLPCR_LPM_OFFSET			(0)
 #define MXC_CCM_CLPCR_LPM_MASK			(0x3)
 
 /* Define the bits in register CISR */
-#define MXC_CCM_CISR_ARM_PODF_LOADED			(0x1 << 25)
-#define MXC_CCM_CISR_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
+#define MXC_CCM_CISR_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CISR_ARM_PODF_LOADED		(0x1 << 26)
+#define MXC_CCM_CISR_TEMP_MON_ALARM				(0x1 << 25)
+#define MXC_CCM_CISR_EMI_CLK_SEL_LOADED			(0x1 << 23)
+#define MXC_CCM_CISR_PER_CLK_SEL_LOADED			(0x1 << 22)
+#define MXC_CCM_CISR_NFC_IPG_INT_MEM_PODF_LOADED		(0x1 << 21)
 #define MXC_CCM_CISR_AHB_PODF_LOADED			(0x1 << 20)
-#define MXC_CCM_CISR_EMI_PODF_LOADED			(0x1 << 19)
+#define MXC_CCM_CISR_EMI_PODF_LOADED				(0x1 << 19)
 #define MXC_CCM_CISR_AXI_B_PODF_LOADED			(0x1 << 18)
 #define MXC_CCM_CISR_AXI_A_PODF_LOADED			(0x1 << 17)
-#define MXC_CCM_CISR_DIVIDER_LOADED			(0x1 << 16)
+#define MXC_CCM_CISR_DIVIDER_LOADED				(0x1 << 16)
 #define MXC_CCM_CISR_COSC_READY				(0x1 << 6)
-#define MXC_CCM_CISR_CKIH2_READY			(0x1 << 5)
+#define MXC_CCM_CISR_CKIH2_READY				(0x1 << 5)
 #define MXC_CCM_CISR_CKIH_READY				(0x1 << 4)
+#define MX50_CCM_CISR_CAMP1_READY			(0x1 << 4)
 #define MXC_CCM_CISR_FPM_READY				(0x1 << 3)
-#define MXC_CCM_CISR_LRF_PLL3				(0x1 << 2)
-#define MXC_CCM_CISR_LRF_PLL2				(0x1 << 1)
-#define MXC_CCM_CISR_LRF_PLL1				(0x1)
+#define MXC_CCM_CISR_LRF_PLL3					(0x1 << 2)
+#define MXC_CCM_CISR_LRF_PLL2					(0x1 << 1)
+#define MXC_CCM_CISR_LRF_PLL1					(0x1)
 
 /* Define the bits in register CIMR */
-#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED_MX51		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED_MX51	(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 26)
+#define MXC_CCM_CIMR_MASK_TEMP_MON_ALARM		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_CLK_SEL_LOADED		(0x1 << 23)
+#define MXC_CCM_CIMR_MASK_PER_CLK_SEL_LOADED		(0x1 << 22)
 #define MXC_CCM_CIMR_MASK_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
-#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED		(0x1 << 20)
-#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED		(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_AHB_PODF_LOADED_MX53		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_EMI_SLOW_PODF_LOADED_MX53		(0x1 << 19)
+#define MX50_CCM_CIMR_MASK_WEIM_PODF_LOADED		(0x1 << 19)
 #define MXC_CCM_CIMR_MASK_AXI_B_PODF_LOADED		(0x1 << 18)
 #define MXC_CCM_CIMR_MASK_AXI_A_PODF_LOADED		(0x1 << 17)
 #define MXC_CCM_CIMR_MASK_DIVIDER_LOADED		(0x1 << 16)
-#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 5)
+/* MX51 */
+#define MXC_CCM_CIMR_MASK_COSC_READY_MX51			(0x1 << 5)
 #define MXC_CCM_CIMR_MASK_CKIH_READY			(0x1 << 4)
 #define MXC_CCM_CIMR_MASK_FPM_READY			(0x1 << 3)
+/* MX53/MX50 */
+#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 6)
+#define MXC_CCM_CIMR_MASK_CAMP2_READY			(0x1 << 5)
+#define MXC_CCM_CIMR_MASK_CAMP1_READY			(0x1 << 4)
+#define MXC_CCM_CIMR_MASK_LRF_PLL4			(0x1 << 3)
 #define MXC_CCM_CIMR_MASK_LRF_PLL3			(0x1 << 2)
 #define MXC_CCM_CIMR_MASK_LRF_PLL2			(0x1 << 1)
 #define MXC_CCM_CIMR_MASK_LRF_PLL1			(0x1)
@@ -442,11 +606,20 @@
 #define MXC_CCM_CCOSR_CKOL_SEL_MASK			(0xF)
 
 /* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_ARM_CLK_INPUT_SEL				(0x1 << 24)
+#define MXC_CCM_CGPR_ARM_ASYNC_REF_EN				(0x1 << 23)
 #define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(0x1 << 4)
 #define MXC_CCM_CGPR_FPM_SEL				(0x1 << 3)
 #define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET		(0)
 #define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_MASK		(0x7)
 
+#define MX50_CCM_CCOSR_CKO1_SLOW_SEL			(0x1 << 8)
+#define MX50_CCM_CCOSR_CKO1_EN				(0x1 << 7)
+#define MX50_CCM_CCOSR_CKO1_DIV_OFFSET			(4)
+#define MX50_CCM_CCOSR_CKO1_DIV_MASK			(0x7 << 4)
+#define MX50_CCM_CCOSR_CKO1_SEL_OFFSET			(0)
+#define MX50_CCM_CCOSR_CKO1_SEL_MASK			(0xF)
+
 /* Define the bits in registers CCGRx */
 #define MXC_CCM_CCGRx_CG_MASK				0x3
 #define MXC_CCM_CCGRx_MOD_OFF				0x0
@@ -485,30 +658,87 @@
 #define MXC_CCM_CCGRx_CG1_OFFSET			2
 #define MXC_CCM_CCGRx_CG0_OFFSET			0
 
-#define MXC_DPTC_LP_BASE	(MX51_GPC_BASE + 0x80)
-#define MXC_DPTC_GP_BASE	(MX51_GPC_BASE + 0x100)
-#define MXC_DVFS_CORE_BASE	(MX51_GPC_BASE + 0x180)
-#define MXC_DPTC_PER_BASE	(MX51_GPC_BASE + 0x1C0)
-#define MXC_PGC_IPU_BASE	(MX51_GPC_BASE + 0x220)
-#define MXC_PGC_VPU_BASE	(MX51_GPC_BASE + 0x240)
-#define MXC_PGC_GPU_BASE	(MX51_GPC_BASE + 0x260)
-#define MXC_SRPG_NEON_BASE	(MX51_GPC_BASE + 0x280)
-#define MXC_SRPG_ARM_BASE	(MX51_GPC_BASE + 0x2A0)
-#define MXC_SRPG_EMPGC0_BASE	(MX51_GPC_BASE + 0x2C0)
-#define MXC_SRPG_EMPGC1_BASE	(MX51_GPC_BASE + 0x2D0)
-#define MXC_SRPG_MEGAMIX_BASE	(MX51_GPC_BASE + 0x2E0)
-#define MXC_SRPG_EMI_BASE	(MX51_GPC_BASE + 0x300)
+#define MXC_CCM_CCGR5_CG6_1_OFFSET			12
+#define MXC_CCM_CCGR5_CG6_2_OFFSET			13
+
+/* Define the bits in registers CSR2  */
+#define MXC_CCM_CSR2_ELCDIF_PIX_BUSY			(0x1 << 9)
+#define MXC_CCM_CSR2_EPDC_PIX_BUSY			(0x1 << 8)
+#define MXC_CCM_CSR2_EPDC_AXI_BUSY			(0x1 << 4)
+#define MXC_CCM_CSR2_DISPLAY_AXI_BUSY			(0x1 << 3)
+
+/* Define the bits in registers CLKSEQ_BYPASS  */
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_OFFSET	14
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_MASK	(0x3 << 14)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_OFFSET	12
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_MASK	(0x3 << 12)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_OFFSET	4
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_MASK	(0x3 << 4)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_OFFSET	2
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_MASK	(0x3 << 2)
+
+/* Define the bits in registers CLK_DDR */
+#define MXC_CCM_CLK_DDR_DDR_CLKGATE_OFFSET	(30)
+#define MXC_CCM_CLK_DDR_DDR_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_CLK_DDR_DDR_PFD_SEL		(1 << 6)
+#define MXC_CCM_CLK_DDR_DDR_DIV_PLL_OFFSET	(0)
+#define MXC_CCM_CLK_DDR_DDR_DIV_PLL_MASK	(0x3F)
+
+/* Define the bits in register DISPLAY_AXI */
+#define MXC_CCM_DISPLAY_AXI_CLKGATE_OFFSET	(30)
+#define MXC_CCM_DISPLAY_AXI_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_DISPLAY_AXI_DIV_OFFSET		(0)
+#define MXC_CCM_DISPLAY_AXI_DIV_MASK		(0x3F)
+
+/* Define the bits in register EPDC_AXI */
+#define MXC_CCM_EPDC_AXI_CLKGATE_OFFSET	(30)
+#define MXC_CCM_EPDC_AXI_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_EPDC_AXI_DIV_OFFSET		(0)
+#define MXC_CCM_EPDC_AXI_DIV_MASK		(0x3F)
+
+/* Define the bits in register EPDCPIX */
+#define MXC_CCM_EPDC_PIX_CLKGATE_OFFSET		(30)
+#define MXC_CCM_EPDC_PIX_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_EPDC_PIX_CLK_PRED_OFFSET	(12)
+#define MXC_CCM_EPDC_PIX_CLK_PRED_MASK		(0x3 << 12)
+#define MXC_CCM_EPDC_PIX_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_EPDC_PIX_CLK_PODF_MASK		(0xFFF)
+
+/* Define the bits in register ELCDIFPIX */
+#define MXC_CCM_ELCDIFPIX_CLKGATE_OFFSET	(30)
+#define MXC_CCM_ELCDIFPIX_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET	(12)
+#define MXC_CCM_ELCDIFPIX_CLK_PRED_MASK		(0x3 << 12)
+#define MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_ELCDIFPIX_CLK_PODF_MASK		(0xFFF)
+
+#define MXC_GPC_BASE		(IO_ADDRESS(GPC_BASE_ADDR))
+#define MXC_DPTC_LP_BASE	(MXC_GPC_BASE + 0x80)
+#define MXC_DPTC_GP_BASE	(MXC_GPC_BASE + 0x100)
+#define MXC_DVFS_CORE_BASE	(MXC_GPC_BASE + 0x180)
+#define MXC_DVFS_PER_BASE	(MXC_GPC_BASE + 0x1C4)
+#define MXC_PGC_IPU_BASE	(MXC_GPC_BASE + 0x220)
+#define MXC_PGC_VPU_BASE	(MXC_GPC_BASE + 0x240)
+#define MXC_PGC_GPU_BASE	(MXC_GPC_BASE + 0x260)
+#define MXC_SRPG_NEON_BASE	(MXC_GPC_BASE + 0x280)
+#define MXC_SRPG_ARM_BASE	(MXC_GPC_BASE + 0x2A0)
+#define MXC_SRPG_EMPGC0_BASE	(MXC_GPC_BASE + 0x2C0)
+#define MXC_SRPG_EMPGC1_BASE	(MXC_GPC_BASE + 0x2D0)
+#define MXC_SRPG_MEGAMIX_BASE	(MXC_GPC_BASE + 0x2E0)
+#define MXC_SRPG_EMI_BASE	(MXC_GPC_BASE + 0x300)
 
 /* CORTEXA8 platform */
-#define MXC_CORTEXA8_PLAT_PVID		(MX51_CORTEXA8_BASE + 0x0)
-#define MXC_CORTEXA8_PLAT_GPC		(MX51_CORTEXA8_BASE + 0x4)
-#define MXC_CORTEXA8_PLAT_PIC		(MX51_CORTEXA8_BASE + 0x8)
-#define MXC_CORTEXA8_PLAT_LPC		(MX51_CORTEXA8_BASE + 0xC)
-#define MXC_CORTEXA8_PLAT_NEON_LPC	(MX51_CORTEXA8_BASE + 0x10)
-#define MXC_CORTEXA8_PLAT_ICGC		(MX51_CORTEXA8_BASE + 0x14)
-#define MXC_CORTEXA8_PLAT_AMC		(MX51_CORTEXA8_BASE + 0x18)
-#define MXC_CORTEXA8_PLAT_NMC		(MX51_CORTEXA8_BASE + 0x20)
-#define MXC_CORTEXA8_PLAT_NMS		(MX51_CORTEXA8_BASE + 0x24)
+extern void __iomem *arm_plat_base;
+#define MXC_CORTEXA8_BASE		(arm_plat_base)
+#define MXC_CORTEXA8_PLAT_PVID		(arm_plat_base + 0x0)
+#define MXC_CORTEXA8_PLAT_GPC		(arm_plat_base + 0x4)
+#define MXC_CORTEXA8_PLAT_PIC		(arm_plat_base + 0x8)
+#define MXC_CORTEXA8_PLAT_LPC		(arm_plat_base + 0xC)
+#define MXC_CORTEXA8_PLAT_NEON_LPC	(arm_plat_base + 0x10)
+#define MXC_CORTEXA8_PLAT_ICGC		(arm_plat_base + 0x14)
+#define MXC_CORTEXA8_PLAT_AMC		(arm_plat_base + 0x18)
+#define MXC_CORTEXA8_PLAT_NMC		(arm_plat_base + 0x20)
+#define MXC_CORTEXA8_PLAT_NMS		(arm_plat_base + 0x24)
 
 /* DVFS CORE */
 #define MXC_DVFSTHRS		(MXC_DVFS_CORE_BASE + 0x00)
@@ -529,14 +759,22 @@
 #define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
 #define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
 
+/* DVFS PER */
+#define MXC_DVFSPER_LTR0	(MXC_DVFS_PER_BASE)
+#define MXC_DVFSPER_LTR1	(MXC_DVFS_PER_BASE + 0x04)
+#define MXC_DVFSPER_LTR2	(MXC_DVFS_PER_BASE + 0x08)
+#define MXC_DVFSPER_LTR3	(MXC_DVFS_PER_BASE + 0x0C)
+#define MXC_DVFSPER_LTBR0	(MXC_DVFS_PER_BASE + 0x10)
+#define MXC_DVFSPER_LTBR1	(MXC_DVFS_PER_BASE + 0x14)
+#define MXC_DVFSPER_PMCR0	(MXC_DVFS_PER_BASE + 0x18)
+#define MXC_DVFSPER_PMCR1	(MXC_DVFS_PER_BASE + 0x1C)
+
 /* GPC */
-#define MXC_GPC_CNTR		(MX51_GPC_BASE + 0x0)
-#define MXC_GPC_PGR		(MX51_GPC_BASE + 0x4)
-#define MXC_GPC_VCR		(MX51_GPC_BASE + 0x8)
-#define MXC_GPC_ALL_PU		(MX51_GPC_BASE + 0xC)
-#define MXC_GPC_NEON		(MX51_GPC_BASE + 0x10)
-#define MXC_GPC_PGR_ARMPG_OFFSET	8
-#define MXC_GPC_PGR_ARMPG_MASK		(3 << 8)
+#define MXC_GPC_CNTR		(MXC_GPC_BASE + 0x0)
+#define MXC_GPC_PGR		(MXC_GPC_BASE + 0x4)
+#define MXC_GPC_VCR		(MXC_GPC_BASE + 0x8)
+#define MXC_GPC_ALL_PU		(MXC_GPC_BASE + 0xC)
+#define MXC_GPC_NEON		(MXC_GPC_BASE + 0x10)
 
 /* PGC */
 #define MXC_PGC_IPU_PGCR	(MXC_PGC_IPU_BASE + 0x0)
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
index 7130449..2494c72 100644
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -1,7 +1,8 @@
 /*
- * Copyright 2009 Amit Kucheria <amit.kucheria@canonical.com>
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
- *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
  * Version 2 or later at the following locations:
@@ -10,82 +11,418 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
 #include <linux/dma-mapping.h>
-#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/ipu.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/uio_driver.h>
+#include <linux/mxc_scc2_driver.h>
+#include <linux/iram_alloc.h>
+#include <linux/gpmi-nfc.h>
+#include <mach/common.h>
 #include <mach/hardware.h>
-#include <mach/imx-uart.h>
-#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <mach/sdma.h>
+/*#include "dma-apbh.h"*/
+
+/* Flag used to indicate when IRAM has been initialized */
+int iram_ready;
+/* Flag used to indicate if dvfs_core is active. */
+int dvfs_core_is_active;
+
+static struct resource sdma_resources[] = {
+	{
+		.start = SDMA_BASE_ADDR,
+		.end = SDMA_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SDMA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dma_device = {
+	.name = "mxc_sdma",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(sdma_resources),
+	.resource = sdma_resources,
+};
+
+static struct resource mxc_w1_master_resources[] = {
+	{
+		.start = OWIRE_BASE_ADDR,
+		.end   = OWIRE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_OWIRE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_w1_master_device = {
+	.name = "mxc_w1",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_w1_master_resources),
+	.resource = mxc_w1_master_resources,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	{
+		.start = KPP_BASE_ADDR,
+		.end = KPP_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_KPP,
+		.end = MXC_INT_KPP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
 
-static struct resource uart0[] = {
+struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+};
+
+static struct resource rtc_resources[] = {
 	{
-		.start = MX51_UART1_BASE_ADDR,
-		.end = MX51_UART1_BASE_ADDR + 0xfff,
+		.start = SRTC_BASE_ADDR,
+		.end = SRTC_BASE_ADDR + 0x40,
 		.flags = IORESOURCE_MEM,
-	}, {
-		.start = MX51_MXC_INT_UART1,
-		.end = MX51_MXC_INT_UART1,
+	},
+	{
+		.start = MXC_INT_SRTC_NTZ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+
+static struct resource mxc_nand_resources[] = {
+	{
+		.flags = IORESOURCE_MEM,
+		.name  = "NFC_AXI_BASE",
+		.start = MX51_NFC_BASE_ADDR_AXI,
+		.end   = MX51_NFC_BASE_ADDR_AXI + SZ_8K - 1,
+	},
+	{
+		.flags = IORESOURCE_MEM,
+		.name  = "NFC_IP_BASE",
+		.start = NFC_BASE_ADDR + 0x00,
+		.end   = NFC_BASE_ADDR + 0x34 - 1,
+	},
+	{
 		.flags = IORESOURCE_IRQ,
+		.start = MXC_INT_NFC,
+		.end   = MXC_INT_NFC,
 	},
 };
 
-struct platform_device mxc_uart_device0 = {
-	.name = "imx-uart",
+struct platform_device mxc_nandv2_mtd_device = {
+	.name = "mxc_nandv2_flash",
 	.id = 0,
-	.resource = uart0,
-	.num_resources = ARRAY_SIZE(uart0),
+	.resource = mxc_nand_resources,
+	.num_resources = ARRAY_SIZE(mxc_nand_resources),
 };
 
-static struct resource uart1[] = {
+static struct resource wdt_resources[] = {
 	{
-		.start = MX51_UART2_BASE_ADDR,
-		.end = MX51_UART2_BASE_ADDR + 0xfff,
+		.start = WDOG1_BASE_ADDR,
+		.end = WDOG1_BASE_ADDR + 0x30,
 		.flags = IORESOURCE_MEM,
-	}, {
-		.start = MX51_MXC_INT_UART2,
-		.end = MX51_MXC_INT_UART2,
+	},
+};
+
+struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static struct resource pwm1_resources[] = {
+	{
+		.start = PWM1_BASE_ADDR,
+		.end = PWM1_BASE_ADDR + 0x14,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_PWM1,
+		.end = MXC_INT_PWM1,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_uart_device1 = {
-	.name = "imx-uart",
+struct platform_device mxc_pwm1_device = {
+	.name = "mxc_pwm",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(pwm1_resources),
+	.resource = pwm1_resources,
+};
+
+static struct resource pwm2_resources[] = {
+	{
+		.start = PWM2_BASE_ADDR,
+		.end = PWM2_BASE_ADDR + 0x14,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_PWM2,
+		.end = MXC_INT_PWM2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_pwm2_device = {
+	.name = "mxc_pwm",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(pwm2_resources),
+	.resource = pwm2_resources,
+};
+
+struct platform_device mxc_pwm_backlight_device = {
+	.name = "pwm-backlight",
+	.id = -1,
+};
+
+static struct resource flexcan0_resources[] = {
+	{
+	    .start = CAN1_BASE_ADDR,
+	    .end = CAN1_BASE_ADDR + 0x3FFF,
+	    .flags = IORESOURCE_MEM,
+	},
+	{
+	    .start = MXC_INT_CAN1,
+	    .end = MXC_INT_CAN1,
+	    .flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_flexcan0_device = {
+	.name = "FlexCAN",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(flexcan0_resources),
+	.resource = flexcan0_resources,
+};
+
+static struct resource flexcan1_resources[] = {
+	{
+	    .start = CAN2_BASE_ADDR,
+	    .end = CAN2_BASE_ADDR + 0x3FFF,
+	    .flags = IORESOURCE_MEM,
+	},
+	{
+	    .start = MXC_INT_CAN2,
+	    .end = MXC_INT_CAN2,
+	    .flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_flexcan1_device = {
+	.name = "FlexCAN",
 	.id = 1,
-	.resource = uart1,
-	.num_resources = ARRAY_SIZE(uart1),
+	.num_resources = ARRAY_SIZE(flexcan1_resources),
+	.resource = flexcan1_resources,
 };
 
-static struct resource uart2[] = {
+static struct resource ipu_resources[] = {
 	{
-		.start = MX51_UART3_BASE_ADDR,
-		.end = MX51_UART3_BASE_ADDR + 0xfff,
+		.start = MX51_IPU_CTRL_BASE_ADDR,
+		.end = MX51_IPU_CTRL_BASE_ADDR + SZ_512M,
 		.flags = IORESOURCE_MEM,
-	}, {
-		.start = MX51_MXC_INT_UART3,
-		.end = MX51_MXC_INT_UART3,
+	},
+	{
+		.start = MXC_INT_IPU_SYN,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MXC_INT_IPU_ERR,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_uart_device2 = {
-	.name = "imx-uart",
-	.id = 2,
-	.resource = uart2,
-	.num_resources = ARRAY_SIZE(uart2),
+struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
 };
 
-static struct resource mxc_fec_resources[] = {
+static struct resource epdc_resources[] = {
 	{
-		.start	= MX51_MXC_FEC_BASE_ADDR,
-		.end	= MX51_MXC_FEC_BASE_ADDR + 0xfff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= MX51_MXC_INT_FEC,
-		.end	= MX51_MXC_INT_FEC,
+	 .start = EPDC_BASE_ADDR,
+	 .end = EPDC_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	.start  = MXC_INT_EPDC,
+	.end = MXC_INT_EPDC,
+	.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device epdc_device = {
+	.name = "mxc_epdc_fb",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(epdc_resources),
+	.resource = epdc_resources,
+};
+
+static struct resource elcdif_resources[] = {
+	{
+	 .start = ELCDIF_BASE_ADDR,
+	 .end = ELCDIF_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	.start  = MXC_INT_ELCDIF,
+	.end = MXC_INT_ELCDIF,
+	.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device elcdif_device = {
+	.name = "mxc_elcdif_fb",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(elcdif_resources),
+	.resource = elcdif_resources,
+};
+
+struct platform_device mxc_fb_devices[] = {
+	{
+		.name = "mxc_sdc_fb",
+		.id = 0,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+	{
+		.name = "mxc_sdc_fb",
+		.id = 1,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+	{
+		.name = "mxc_sdc_fb",
+		.id = 2,
+		.dev = {
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	},
+};
+
+static struct resource ldb_resources[] = {
+	{
+		.start = IOMUXC_BASE_ADDR,
+		.end = IOMUXC_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device mxc_ldb_device = {
+	.name = "mxc_ldb",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ldb_resources),
+	.resource = ldb_resources,
+};
+
+static struct resource vpu_resources[] = {
+	{
+		.start = VPU_BASE_ADDR,
+		.end = VPU_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start	= MXC_INT_VPU,
+		.end = MXC_INT_VPU,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
 
+struct platform_device mxcvpu_device = {
+	.name = "mxc_vpu",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(vpu_resources),
+	.resource = vpu_resources,
+};
+
+static struct resource scc_resources[] = {
+	{
+		.start = SCC_BASE_ADDR,
+		.end = SCC_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start	= MX51_SCC_RAM_BASE_ADDR,
+		.end = MX51_SCC_RAM_BASE_ADDR + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device mxcscc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(scc_resources),
+	.resource = scc_resources,
+};
+
+static struct resource rngb_resources[] = {
+	{
+		.start = RNGB_BASE_ADDR,
+		.end = RNGB_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_RNGB_BLOCK,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* the RNGC driver applies for MX50's RNGB hw */
+struct platform_device mxc_rngb_device = {
+	.name = "fsl_rngc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(rngb_resources),
+	.resource = rngb_resources,
+};
+
+static struct resource mxc_fec_resources[] = {
+	{
+		.start	= FEC_BASE_ADDR,
+		.end	= FEC_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM
+	},
+	{
+		.start	= MXC_INT_FEC,
+		.end	= MXC_INT_FEC,
+		.flags	= IORESOURCE_IRQ
+	},
+};
+
 struct platform_device mxc_fec_device = {
 	.name = "fec",
 	.id = 0,
@@ -93,34 +430,576 @@ struct platform_device mxc_fec_device = {
 	.resource = mxc_fec_resources,
 };
 
+static struct resource mxcspi1_resources[] = {
+	{
+		.start = CSPI1_BASE_ADDR,
+		.end = CSPI1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI1,
+		.end = MXC_INT_CSPI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+static struct resource mxcspi2_resources[] = {
+	{
+		.start = CSPI2_BASE_ADDR,
+		.end = CSPI2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI2,
+		.end = MXC_INT_CSPI2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+
+static struct resource mxcspi3_resources[] = {
+	{
+		.start = CSPI3_BASE_ADDR,
+		.end = CSPI3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_CSPI,
+		.end = MXC_INT_CSPI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+
+static struct resource mxci2c1_resources[] = {
+	{
+		.start = I2C1_BASE_ADDR,
+		.end = I2C1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_I2C1,
+		.end = MXC_INT_I2C1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxci2c2_resources[] = {
+	{
+		.start = I2C2_BASE_ADDR,
+		.end = I2C2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_I2C2,
+		.end = MXC_INT_I2C2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxci2c3_resources[] = {
+	{
+	       .start = I2C3_BASE_ADDR,
+	       .end = I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	{
+	       .start = MXC_INT_I2C3,
+	       .end = MXC_INT_I2C3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+struct platform_device mxci2c_devices[] = {
+	{
+		.name = "mxc_i2c",
+		.id = 0,
+		.num_resources = ARRAY_SIZE(mxci2c1_resources),
+		.resource = mxci2c1_resources,
+	},
+	{
+		.name = "mxc_i2c",
+		.id = 1,
+		.num_resources = ARRAY_SIZE(mxci2c2_resources),
+		.resource = mxci2c2_resources,
+	},
+	{
+		.name = "mxc_i2c",
+		.id = 2,
+		.num_resources = ARRAY_SIZE(mxci2c3_resources),
+		.resource = mxci2c3_resources,
+	},
+};
+
+static struct resource mxci2c_hs_resources[] = {
+	{
+		.start = HSI2C_DMA_BASE_ADDR,
+		.end = HSI2C_DMA_BASE_ADDR + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_HS_I2C,
+		.end = MXC_INT_HS_I2C,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxci2c_hs_device = {
+	.name = "mxc_i2c_hs",
+	.id = 3,
+	.num_resources = ARRAY_SIZE(mxci2c_hs_resources),
+	.resource = mxci2c_hs_resources
+};
+
+static struct resource ssi1_resources[] = {
+	{
+		.start = SSI1_BASE_ADDR,
+		.end = SSI1_BASE_ADDR + 0x5C,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SSI1,
+		.end = MXC_INT_SSI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_ssi1_device = {
+	.name = "mxc_ssi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ssi1_resources),
+	.resource = ssi1_resources,
+};
+
+static struct resource ssi2_resources[] = {
+	{
+		.start = SSI2_BASE_ADDR,
+		.end = SSI2_BASE_ADDR + 0x5C,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SSI2,
+		.end = MXC_INT_SSI2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_ssi2_device = {
+	.name = "mxc_ssi",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(ssi2_resources),
+	.resource = ssi2_resources,
+};
+
+static struct resource esai_resources[] = {
+	{
+		.start = ESAI_BASE_ADDR,
+		.end = ESAI_BASE_ADDR + 0x100,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_ESAI,
+		.end = MXC_INT_ESAI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_esai_device = {
+	.name = "mxc_esai",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(esai_resources),
+	.resource = esai_resources,
+};
+
+static struct resource tve_resources[] = {
+	{
+		.start = TVE_BASE_ADDR,
+		.end = TVE_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_TVE,
+		.end = MXC_INT_TVE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_tve_device = {
+	.name = "tve",
+	.num_resources = ARRAY_SIZE(tve_resources),
+	.resource = tve_resources,
+};
+
+static struct resource dvfs_core_resources[] = {
+	{
+		.start = DVFSCORE_BASE_ADDR,
+		.end = DVFSCORE_BASE_ADDR + 4 * SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_GPC1,
+		.end = MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dvfs_core_device = {
+	.name = "mxc_dvfs_core",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(dvfs_core_resources),
+	.resource = dvfs_core_resources,
+};
+
+static struct resource dvfs_per_resources[] = {
+	{
+		.start = DVFSPER_BASE_ADDR,
+		.end = DVFSPER_BASE_ADDR + 2 * SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_GPC1,
+		.end = MXC_INT_GPC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dvfs_per_device = {
+	 .name = "mxc_dvfsper",
+	 .id = 0,
+	 .num_resources = ARRAY_SIZE(dvfs_per_resources),
+	 .resource = dvfs_per_resources,
+};
+
+struct mxc_gpio_port mxc_gpio_ports[] = {
+	{
+		.chip.label = "gpio-0",
+		.base = IO_ADDRESS(GPIO1_BASE_ADDR),
+		.irq = MXC_INT_GPIO1_LOW,
+		.irq_high = MXC_INT_GPIO1_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START
+	},
+	{
+		.chip.label = "gpio-1",
+		.base = IO_ADDRESS(GPIO2_BASE_ADDR),
+		.irq = MXC_INT_GPIO2_LOW,
+		.irq_high = MXC_INT_GPIO2_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 1
+	},
+	{
+		.chip.label = "gpio-2",
+		.base = IO_ADDRESS(GPIO3_BASE_ADDR),
+		.irq = MXC_INT_GPIO3_LOW,
+		.irq_high = MXC_INT_GPIO3_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
+	},
+	{
+		.chip.label = "gpio-3",
+		.base = IO_ADDRESS(GPIO4_BASE_ADDR),
+		.irq = MXC_INT_GPIO4_LOW,
+		.irq_high = MXC_INT_GPIO4_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
+	},
+	{
+		.chip.label = "gpio-4",
+		.base = IO_ADDRESS(GPIO5_BASE_ADDR),
+		.irq = MXC_INT_GPIO5_LOW,
+		.irq_high = MXC_INT_GPIO5_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 4
+	},
+	{
+		.chip.label = "gpio-5",
+		.base = IO_ADDRESS(GPIO6_BASE_ADDR),
+		.irq = MXC_INT_GPIO6_LOW,
+		.irq_high = MXC_INT_GPIO6_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 5
+	},
+	{
+		.chip.label = "gpio-6",
+		.base = IO_ADDRESS(GPIO7_BASE_ADDR),
+		.irq = MXC_INT_GPIO7_LOW,
+		.irq_high = MXC_INT_GPIO7_HIGH,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 6
+	},
+};
+
+int __init mxc_register_gpios(void)
+{
+	if (cpu_is_mx51())
+		return mxc_gpio_init(mxc_gpio_ports, 4);
+	else if (cpu_is_mx50())
+		return mxc_gpio_init(mxc_gpio_ports, 6);
+	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
+}
+
+static struct resource spdif_resources[] = {
+	{
+		.start = SPDIF_BASE_ADDR,
+		.end = SPDIF_BASE_ADDR + 0x50,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SPDIF_MX51,
+		.end = MXC_INT_SPDIF_MX51,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_alsa_spdif_device = {
+	.name = "mxc_alsa_spdif",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(spdif_resources),
+	.resource = spdif_resources,
+};
+
+struct platform_device mx51_lpmode_device = {
+	.name = "mx51_lpmode",
+	.id = 0,
+};
+
+struct platform_device busfreq_device = {
+	.name = "busfreq",
+	.id = 0,
+};
+
+static struct resource mxc_m4if_resources[] = {
+	{
+		.start = M4IF_BASE_ADDR,
+		.end = M4IF_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device sdram_autogating_device = {
+	.name = "sdram_autogating",
+	.id = 0,
+	.resource = mxc_m4if_resources,
+	.num_resources = ARRAY_SIZE(mxc_m4if_resources),
+};
+
+static struct resource mxc_iim_resources[] = {
+	{
+		.start = IIM_BASE_ADDR,
+		.end = IIM_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device mxc_iim_device = {
+	.name = "mxc_iim",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_iim_resources),
+	.resource = mxc_iim_resources
+};
+
+static struct resource mxc_sim_resources[] = {
+	{
+		.start = SIM_BASE_ADDR,
+		.end = SIM_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SIM_IPB,
+		.end = MXC_INT_SIM_IPB,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MXC_INT_SIM_DAT,
+		.end = MXC_INT_SIM_DAT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_sim_device = {
+	.name = "mxc_sim",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_sim_resources),
+	.resource = mxc_sim_resources,
+};
+
+static struct resource mxcsdhc1_resources[] = {
+	{
+		.start = MMC_SDHC1_BASE_ADDR,
+		.end = MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC1,
+		.end = MXC_INT_MMC_SDHC1,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxcsdhc2_resources[] = {
+	{
+		.start = MMC_SDHC2_BASE_ADDR,
+		.end = MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC2,
+		.end = MXC_INT_MMC_SDHC2,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource mxcsdhc3_resources[] = {
+	{
+		.start = MMC_SDHC3_BASE_ADDR,
+		.end = MMC_SDHC3_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_MMC_SDHC3,
+		.end = MXC_INT_MMC_SDHC3,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxcsdhc1_device = {
+	.name = "mxsdhci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+struct platform_device mxcsdhc3_device = {
+	.name = "mxsdhci",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(mxcsdhc3_resources),
+	.resource = mxcsdhc3_resources,
+};
+
+static struct resource pata_fsl_resources[] = {
+	{
+		.start = ATA_BASE_ADDR,
+		.end = ATA_BASE_ADDR + 0x000000C8,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_ATA,
+		.end = MXC_INT_ATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pata_fsl_device = {
+	.name = "pata_fsl",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pata_fsl_resources),
+	.resource = pata_fsl_resources,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+static struct resource ahci_fsl_resources[] = {
+	{
+		.start = MX53_SATA_BASE_ADDR,
+		.end = MX53_SATA_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SATA,
+		.end = MXC_INT_SATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device ahci_fsl_device = {
+	.name = "ahci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ahci_fsl_resources),
+	.resource = ahci_fsl_resources,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
 static u64 usb_dma_mask = DMA_BIT_MASK(32);
 
 static struct resource usbotg_resources[] = {
 	{
-		.start = MX51_OTG_BASE_ADDR,
-		.end = MX51_OTG_BASE_ADDR + 0x1ff,
+		.start = OTG_BASE_ADDR,
+		.end = OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource usbotg_xcvr_resources[] = {
+	{
+		.start = OTG_BASE_ADDR,
+		.end = OTG_BASE_ADDR + 0x1ff,
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = MX51_MXC_INT_USB_OTG,
+		.start = MXC_INT_USB_OTG,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-/* OTG gadget device */
 struct platform_device mxc_usbdr_udc_device = {
 	.name		= "fsl-usb2-udc",
 	.id		= -1,
+	.dev  = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource      = usbotg_resources,
 	.num_resources	= ARRAY_SIZE(usbotg_resources),
-	.resource	= usbotg_resources,
+};
+
+struct platform_device mxc_usbdr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
 	.dev		= {
 		.dma_mask		= &usb_dma_mask,
 		.coherent_dma_mask	= DMA_BIT_MASK(32),
 	},
+	.resource      = usbotg_xcvr_resources,
+	.num_resources = ARRAY_SIZE(usbotg_xcvr_resources),
 };
 
 struct platform_device mxc_usbdr_host_device = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 0,
 	.num_resources = ARRAY_SIZE(usbotg_resources),
 	.resource = usbotg_resources,
@@ -132,18 +1011,18 @@ struct platform_device mxc_usbdr_host_device = {
 
 static struct resource usbh1_resources[] = {
 	{
-		.start = MX51_OTG_BASE_ADDR + 0x200,
-		.end = MX51_OTG_BASE_ADDR + 0x200 + 0x1ff,
+		.start = OTG_BASE_ADDR + 0x200,
+		.end = OTG_BASE_ADDR + 0x200 + 0x1ff,
 		.flags = IORESOURCE_MEM,
 	},
 	{
-		.start = MX51_MXC_INT_USB_H1,
+		.start = MXC_INT_USB_H1,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
 struct platform_device mxc_usbh1_device = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 1,
 	.num_resources = ARRAY_SIZE(usbh1_resources),
 	.resource = usbh1_resources,
@@ -153,49 +1032,601 @@ struct platform_device mxc_usbh1_device = {
 	},
 };
 
-static struct resource mxc_wdt_resources[] = {
+static struct resource usbh2_resources[] = {
 	{
-		.start = MX51_WDOG_BASE_ADDR,
-		.end = MX51_WDOG_BASE_ADDR + SZ_16K - 1,
+		.start = OTG_BASE_ADDR + 0x400,
+		.end = OTG_BASE_ADDR + 0x400 + 0x1ff,
 		.flags = IORESOURCE_MEM,
 	},
+	{
+		.start = MXC_INT_USB_H2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbh2_device = {
+	.name = "fsl-ehci",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(usbh2_resources),
+	.resource = usbh2_resources,
+	.dev = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
 };
 
-struct platform_device mxc_wdt = {
-	.name = "imx2-wdt",
+static struct resource mxc_gpu_resources[] = {
+	{
+		.start = MXC_INT_GPU2_IRQ,
+		.end = MXC_INT_GPU2_IRQ,
+		.name = "gpu_2d_irq",
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MXC_INT_GPU,
+		.end = MXC_INT_GPU,
+		.name = "gpu_3d_irq",
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MX51_GPU2D_BASE_ADDR,
+		.end = MX51_GPU2D_BASE_ADDR + SZ_4K - 1,
+		.name = "gpu_2d_registers",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = GPU_BASE_ADDR,
+		.end = GPU_BASE_ADDR + SZ_128K - 1,
+		.name = "gpu_3d_registers",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX51_GPU_GMEM_BASE_ADDR,
+		.end = MX51_GPU_GMEM_BASE_ADDR + SZ_128K - 1,
+		.name = "gpu_graphics_mem",
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 0,
+		.end = 0,
+		.name = "gpu_reserved_mem",
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device gpu_device = {
+	.name = "mxc_gpu",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_wdt_resources),
-	.resource = mxc_wdt_resources,
+	.num_resources = ARRAY_SIZE(mxc_gpu_resources),
+	.resource = mxc_gpu_resources,
 };
 
-static struct mxc_gpio_port mxc_gpio_ports[] = {
+static struct resource mxc_gpu2d_resources[] = {
 	{
-		.chip.label = "gpio-0",
-		.base = MX51_IO_ADDRESS(MX51_GPIO1_BASE_ADDR),
-		.irq = MX51_MXC_INT_GPIO1_LOW,
-		.virtual_irq_start = MXC_GPIO_IRQ_START
+		.start = MX51_GPU2D_BASE_ADDR,
+		.end = MX51_GPU2D_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
 	},
 	{
-		.chip.label = "gpio-1",
-		.base = MX51_IO_ADDRESS(MX51_GPIO2_BASE_ADDR),
-		.irq = MX51_MXC_INT_GPIO2_LOW,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 1
+		.flags = IORESOURCE_MEM,
 	},
 	{
-		.chip.label = "gpio-2",
-		.base = MX51_IO_ADDRESS(MX51_GPIO3_BASE_ADDR),
-		.irq = MX51_MXC_INT_GPIO3_LOW,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+#if defined(CONFIG_UIO_PDRV_GENIRQ) || defined(CONFIG_UIO_PDRV_GENIRQ_MODULE)
+static struct clk *gpu_clk;
+static atomic_t *gpu_use_count;
+
+int gpu2d_open(struct uio_info *info, struct inode *inode)
+{
+	int err = 0;
+
+	if (atomic_inc_return(gpu_use_count) == 1) {
+		gpu_clk = clk_get(NULL, "gpu2d_clk");
+		if (IS_ERR(gpu_clk))
+			err = PTR_ERR(gpu_clk);
+
+		err = clk_enable(gpu_clk);
+	}
+	return err;
+}
+
+int gpu2d_release(struct uio_info *info, struct inode *inode)
+{
+	if (atomic_dec_and_test(gpu_use_count)) {
+		if (IS_ERR(gpu_clk))
+			return PTR_ERR(gpu_clk);
+
+		clk_disable(gpu_clk);
+		clk_put(gpu_clk);
+	}
+	return 0;
+}
+
+static int gpu2d_mmap(struct uio_info *info, struct vm_area_struct *vma)
+{
+	int mi = vma->vm_pgoff;
+	if (mi < 0)
+		return -EINVAL;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+
+	return remap_pfn_range(vma,
+			       vma->vm_start,
+			       info->mem[mi].addr >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start,
+			       vma->vm_page_prot);
+}
+
+static struct uio_info gpu2d_info = {
+	.name = "imx_gpu2d",
+	.version = "1",
+	.irq = MXC_INT_GPU2_IRQ,
+	.open = gpu2d_open,
+	.release = gpu2d_release,
+	.mmap = gpu2d_mmap,
+};
+
+static struct platform_device mxc_gpu2d_device = {
+	.name = "uio_pdrv_genirq",
+	.dev = {
+		.platform_data = &gpu2d_info,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(mxc_gpu2d_resources),
+	.resource = mxc_gpu2d_resources,
+};
+
+static inline void mxc_init_gpu2d(void)
+{
+	void *gpu_mem;
+	gpu_mem = dma_alloc_coherent(&mxc_gpu2d_device.dev, SZ_64K, &mxc_gpu2d_resources[1].start, GFP_DMA);
+	mxc_gpu2d_resources[1].end = mxc_gpu2d_resources[1].start + SZ_64K - 1;
+	memset(gpu_mem, 0, SZ_64K);
+	gpu_use_count = gpu_mem + SZ_64K - 4;
+
+	dma_alloc_coherent(&mxc_gpu2d_device.dev, 88 * SZ_1K, &mxc_gpu2d_resources[2].start, GFP_DMA);
+	mxc_gpu2d_resources[2].end = mxc_gpu2d_resources[2].start + (88 * SZ_1K) - 1;
+
+	platform_device_register(&mxc_gpu2d_device);
+}
+#else
+static inline void mxc_init_gpu2d(void)
+{
+}
+#endif
+
+static struct resource mlb_resources[] = {
+	[0] = {
+	       .start = MLB_BASE_ADDR,
+	       .end = MLB_BASE_ADDR + 0x300,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_MLB,
+	       .end = MXC_INT_MLB,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+struct platform_device mxc_mlb_device = {
+	.name = "mxc_mlb",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mlb_resources),
+	.resource = mlb_resources,
+};
+
+static struct resource pxp_resources[] = {
+	{
+	 .start = EPXP_BASE_ADDR,
+	 .end = EPXP_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_EPXP,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+struct platform_device mxc_pxp_device = {
+	.name = "mxc-pxp",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pxp_resources),
+	.resource = pxp_resources,
+};
+
+struct platform_device mxc_pxp_client_device = {
+	.name = "pxp-device",
+	.id = -1,
+};
+
+struct platform_device mxc_v4l2_device = {
+	.name = "mxc_v4l2_capture",
+	.id = 0,
+};
+
+struct platform_device mxc_v4l2out_device = {
+	.name = "mxc_v4l2_output",
+	.id = 0,
+};
+
+struct resource viim_resources[] = {
+	[0] = {
+		.start  = (GPT1_BASE_ADDR - 0x20000000),
+		.end    = (GPT1_BASE_ADDR - 0x20000000) + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = OCOTP_CTRL_BASE_ADDR,
+		.end    = OCOTP_CTRL_BASE_ADDR + PAGE_SIZE - 1,
+		.flags  = IORESOURCE_MEM,
 	},
+};
+struct platform_device mxs_viim = {
+	.name   = "mxs_viim",
+	.id     = -1,
+	.num_resources = ARRAY_SIZE(viim_resources),
+	.resource = viim_resources,
+};
+
+static struct resource dma_apbh_resources[] = {
 	{
-		.chip.label = "gpio-3",
-		.base = MX51_IO_ADDRESS(MX51_GPIO4_BASE_ADDR),
-		.irq = MX51_MXC_INT_GPIO4_LOW,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
+		.start = APBHDMA_BASE_ADDR,
+		.end = APBHDMA_BASE_ADDR + 0x2000 - 1,
+		.flags = IORESOURCE_MEM,
 	},
 };
 
-int __init mxc_register_gpios(void)
+struct platform_device mxs_dma_apbh_device = {
+	.name = "mxs-dma-apbh",
+	.num_resources = ARRAY_SIZE(dma_apbh_resources),
+	.resource = dma_apbh_resources,
+};
+
+void __init mx5_init_irq(void)
 {
-	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
+	unsigned long tzic_addr;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		tzic_addr = MX51_TZIC_BASE_ADDR_T01;
+	else if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		tzic_addr = MX51_TZIC_BASE_ADDR;
+	else /* mx53 and mx50 */
+		tzic_addr = MX53_TZIC_BASE_ADDR;
+
+	mxc_tzic_init_irq(tzic_addr);
 }
+
+#define SCM_RD_DELAY	1000000 /* in nanoseconds */
+#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
+static __init void mxc_init_scc_iram(void)
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint8_t *UMID_base;
+	uint32_t *MAP_base;
+	uint8_t i;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint32_t ram_partitions, ram_partition_size, ram_size;
+	uint32_t scm_version_register;
+	struct timespec stime;
+	struct timespec curtime;
+	long scm_rd_timeout = 0;
+	long cur_ns = 0;
+	long start_ns = 0;
+
+	scc_base = ioremap((uint32_t) scc_resources[0].start, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC REGS\n");
+		return;
+	}
+
+	scm_version_register = __raw_readl(scc_base + SCM_VERSION_REG);
+	ram_partitions = 1 + ((scm_version_register & SCM_VER_NP_MASK)
+		>> SCM_VER_NP_SHIFT);
+	ram_partition_size = (uint32_t) (1 <<
+		((scm_version_register & SCM_VER_BPP_MASK)
+		>> SCM_VER_BPP_SHIFT));
+
+	ram_size = (uint32_t)(ram_partitions * ram_partition_size);
+
+	scm_ram_base = ioremap((uint32_t) scc_resources[1].start, ram_size);
+
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC RAM\n");
+		return;
+	}
+
+	/* Wait for any running SCC operations to finish or fail */
+	getnstimeofday(&stime);
+	do {
+		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec > stime.tv_nsec)
+			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
+		else{
+			/*Converted second to nanosecond and add to
+			nsec when current nanosec is less than
+			start time nanosec.*/
+			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+			curtime.tv_nsec;
+			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+				stime.tv_nsec;
+			scm_rd_timeout = cur_ns - start_ns;
+		}
+	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
+
+	/* Check for failures */
+	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
+		/* Special message for bad secret key fuses */
+		if (reg_value & SCM_STATUS_KST_BAD_KEY)
+			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
+		else
+		    printk(KERN_ERR "SECURE RAM FAILURE\n");
+
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	scm_rd_timeout = 0;
+
+	/* Release all partitions for SCC2 driver on MX53*/
+	if (cpu_is_mx53())
+		scc_partno = 0;
+	/* Release final two partitions for SCC2 driver on MX51 */
+	else
+		scc_partno = ram_partitions -
+			(SCC_RAM_SIZE / ram_partition_size);
+
+	for (partition_no = scc_partno; partition_no < ram_partitions;
+	     partition_no++) {
+		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
+			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
+			SCM_ZCMD_CCMD_MASK));
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		udelay(1);
+		/* Wait for zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else {
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+	}
+
+	/* 4 partitions on MX53 */
+	if (cpu_is_mx53())
+		reg_mask = 0xFF;
+
+	/*Check all expected partitions released */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != 0) {
+		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+	/* we are done if this is MX53, since no sharing of IRAM and SCC_RAM */
+	if (cpu_is_mx53())
+		goto exit;
+
+	reg_mask = 0;
+	scm_rd_timeout = 0;
+	/* Allocate remaining partitions for general use */
+	for (partition_no = 0; partition_no < scc_partno; partition_no++) {
+		/* Supervisor mode claims a partition for it's own use
+		by writing zero to SMID register.*/
+		__raw_writel(0, scc_base + (SCM_SMID0_REG + 8 * partition_no));
+
+		/* Wait for any zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else{
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout"
+			"for Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+		/* Set UMID=0 and permissions for universal data
+		read/write access */
+		MAP_base = scm_ram_base +
+			(uint32_t) (partition_no * ram_partition_size);
+		UMID_base = (uint8_t *) MAP_base + 0x10;
+		for (i = 0; i < 16; i++)
+			UMID_base[i] = 0;
+
+		MAP_base[0] = (SCM_PERM_NO_ZEROIZE | SCM_PERM_HD_SUP_DISABLE |
+			SCM_PERM_HD_READ | SCM_PERM_HD_WRITE |
+			SCM_PERM_HD_EXECUTE | SCM_PERM_TH_READ |
+			SCM_PERM_TH_WRITE);
+		reg_mask |= (3 << (2 * (partition_no)));
+	}
+
+	/* Check all expected partitions allocated */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != reg_mask) {
+		printk(KERN_ERR "FAILED TO ACQUIRE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return;
+	}
+
+exit:
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+	iram_ready = 1;
+}
+
+#define MX53_OFFSET 0x20000000
+
+int __init mxc_init_devices(void)
+{
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		sdma_resources[0].start -= MX53_OFFSET;
+		sdma_resources[0].end -= MX53_OFFSET;
+		mxc_w1_master_resources[0].start -= MX53_OFFSET;
+		mxc_w1_master_resources[0].end -= MX53_OFFSET;
+		mxc_kpp_resources[0].start -= MX53_OFFSET;
+		mxc_kpp_resources[0].end -= MX53_OFFSET;
+		rtc_resources[0].start -= MX53_OFFSET;
+		rtc_resources[0].end -= MX53_OFFSET;
+
+		wdt_resources[0].start -= MX53_OFFSET;
+		wdt_resources[0].end -= MX53_OFFSET;
+		pwm1_resources[0].start -= MX53_OFFSET;
+		pwm1_resources[0].end -= MX53_OFFSET;
+		pwm2_resources[0].start -= MX53_OFFSET;
+		pwm2_resources[0].end -= MX53_OFFSET;
+		flexcan0_resources[0].start -= MX53_OFFSET;
+		flexcan0_resources[0].end -= MX53_OFFSET;
+		flexcan1_resources[0].start -= MX53_OFFSET;
+		flexcan1_resources[0].end -= MX53_OFFSET;
+		mxc_fec_resources[0].start -= MX53_OFFSET;
+		mxc_fec_resources[0].end -= MX53_OFFSET;
+		vpu_resources[0].start -= MX53_OFFSET;
+		vpu_resources[0].end -= MX53_OFFSET;
+		scc_resources[0].start -= MX53_OFFSET;
+		scc_resources[0].end -= MX53_OFFSET;
+		scc_resources[1].start = MX53_SCC_RAM_BASE_ADDR;
+		scc_resources[1].end = MX53_SCC_RAM_BASE_ADDR + SZ_16K - 1;
+		rngb_resources[0].start -= MX53_OFFSET;
+		rngb_resources[0].end -= MX53_OFFSET;
+		mxcspi1_resources[0].start -= MX53_OFFSET;
+		mxcspi1_resources[0].end -= MX53_OFFSET;
+		mxcspi2_resources[0].start -= MX53_OFFSET;
+		mxcspi2_resources[0].end -= MX53_OFFSET;
+		mxcspi3_resources[0].start -= MX53_OFFSET;
+		mxcspi3_resources[0].end -= MX53_OFFSET;
+		mxci2c1_resources[0].start -= MX53_OFFSET;
+		mxci2c1_resources[0].end -= MX53_OFFSET;
+		mxci2c2_resources[0].start -= MX53_OFFSET;
+		mxci2c2_resources[0].end -= MX53_OFFSET;
+		mxci2c3_resources[0].start -= MX53_OFFSET;
+		mxci2c3_resources[0].end -= MX53_OFFSET;
+		ssi1_resources[0].start -= MX53_OFFSET;
+		ssi1_resources[0].end -= MX53_OFFSET;
+		ssi2_resources[0].start -= MX53_OFFSET;
+		ssi2_resources[0].end -= MX53_OFFSET;
+		esai_resources[0].start -= MX53_OFFSET;
+		esai_resources[0].end -= MX53_OFFSET;
+		tve_resources[0].start -= MX53_OFFSET;
+		tve_resources[0].end -= MX53_OFFSET;
+		dvfs_core_resources[0].start -= MX53_OFFSET;
+		dvfs_core_resources[0].end -= MX53_OFFSET;
+		dvfs_per_resources[0].start -= MX53_OFFSET;
+		dvfs_per_resources[0].end -= MX53_OFFSET;
+		spdif_resources[0].start -= MX53_OFFSET;
+		spdif_resources[0].end -= MX53_OFFSET;
+		spdif_resources[1].start = MXC_INT_SPDIF_MX53;
+		spdif_resources[1].end = MXC_INT_SPDIF_MX53;
+		mxc_m4if_resources[0].start -= MX53_OFFSET;
+		mxc_m4if_resources[0].end -= MX53_OFFSET;
+		mxc_iim_resources[0].start -= MX53_OFFSET;
+		mxc_iim_resources[0].end -= MX53_OFFSET;
+		mxc_sim_resources[0].start -= MX53_OFFSET;
+		mxc_sim_resources[0].end -= MX53_OFFSET;
+		mxcsdhc1_resources[0].start -= MX53_OFFSET;
+		mxcsdhc1_resources[0].end -= MX53_OFFSET;
+		mxcsdhc2_resources[0].start -= MX53_OFFSET;
+		mxcsdhc2_resources[0].end -= MX53_OFFSET;
+		mxcsdhc3_resources[0].start -= MX53_OFFSET;
+		mxcsdhc3_resources[0].end -= MX53_OFFSET;
+		usbotg_resources[0].start -= MX53_OFFSET;
+		usbotg_resources[0].end -= MX53_OFFSET;
+		usbotg_xcvr_resources[0].start -= MX53_OFFSET;
+		usbotg_xcvr_resources[0].end -= MX53_OFFSET;
+		usbh1_resources[0].start -= MX53_OFFSET;
+		usbh1_resources[0].end -= MX53_OFFSET;
+		usbh2_resources[0].start -= MX53_OFFSET;
+		usbh2_resources[0].end -= MX53_OFFSET;
+		mxc_gpu_resources[2].start = MX53_GPU2D_BASE_ADDR;
+		mxc_gpu_resources[2].end = MX53_GPU2D_BASE_ADDR + SZ_4K - 1;
+		mxc_gpu2d_resources[0].start = MX53_GPU2D_BASE_ADDR;
+		mxc_gpu2d_resources[0].end = MX53_GPU2D_BASE_ADDR + SZ_4K - 1;
+		if (cpu_is_mx53()) {
+			mxc_gpu_resources[4].start = MX53_GPU_GMEM_BASE_ADDR;
+			mxc_gpu_resources[4].end = MX53_GPU_GMEM_BASE_ADDR
+						+ SZ_256K - 1;
+		} else {
+			mxc_gpu_resources[1].start = 0;
+			mxc_gpu_resources[1].end = 0;
+			mxc_gpu_resources[3].start = 0;
+			mxc_gpu_resources[3].end = 0;
+			mxc_gpu_resources[4].start = 0;
+			mxc_gpu_resources[4].end = 0;
+		}
+		ipu_resources[0].start = MX53_IPU_CTRL_BASE_ADDR;
+		ipu_resources[0].end = MX53_IPU_CTRL_BASE_ADDR + SZ_128M - 1;
+		mlb_resources[0].start -= MX53_OFFSET;
+		mlb_resources[0].end -= MX53_OFFSET;
+		mxc_nandv2_mtd_device.resource[0].start =
+					MX53_NFC_BASE_ADDR_AXI;
+		mxc_nandv2_mtd_device.resource[0].end =
+					MX53_NFC_BASE_ADDR_AXI + SZ_8K - 1;
+		mxc_nandv2_mtd_device.resource[1].start -= MX53_OFFSET;
+		mxc_nandv2_mtd_device.resource[1].end -= MX53_OFFSET;
+		ldb_resources[0].start -=  MX53_OFFSET;
+		ldb_resources[0].end -=  MX53_OFFSET;
+	} else if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		scc_resources[1].start += 0x8000;
+		scc_resources[1].end += 0x8000;
+	}
+
+
+	if (cpu_is_mx51() || cpu_is_mx53())
+		mxc_init_scc_iram();
+	mxc_init_gpu2d();
+	return 0;
+}
+postcore_initcall(mxc_init_devices);
+
diff --git a/arch/arm/mach-mx5/devices.h b/arch/arm/mach-mx5/devices.h
index c879ae7..891212c 100644
--- a/arch/arm/mach-mx5/devices.h
+++ b/arch/arm/mach-mx5/devices.h
@@ -1,3 +1,22 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
 extern struct platform_device mxc_uart_device0;
 extern struct platform_device mxc_uart_device1;
 extern struct platform_device mxc_uart_device2;
@@ -5,4 +24,58 @@ extern struct platform_device mxc_fec_device;
 extern struct platform_device mxc_usbdr_host_device;
 extern struct platform_device mxc_usbh1_device;
 extern struct platform_device mxc_usbdr_udc_device;
-extern struct platform_device mxc_wdt;
+extern struct platform_device mxc_dma_device;
+extern struct platform_device mxc_w1_master_device;
+extern struct platform_device mxc_keypad_device;
+extern struct platform_device mxc_rtc_device;
+extern struct platform_device mxc_nandv2_mtd_device;
+extern struct platform_device imx_nfc_device;
+extern struct platform_device mxc_wdt_device;
+extern struct platform_device mxc_pwm1_device;
+extern struct platform_device mxc_pwm2_device;
+extern struct platform_device mxc_pwm_backlight_device;
+extern struct platform_device mxc_flexcan0_device;
+extern struct platform_device mxc_flexcan1_device;
+extern struct platform_device mxc_ipu_device;
+extern struct platform_device mxc_fb_devices[];
+extern struct platform_device mxc_ldb_device;
+extern struct platform_device mxcvpu_device;
+extern struct platform_device mxcscc_device;
+extern struct platform_device mxcspi1_device;
+extern struct platform_device mxcspi2_device;
+extern struct platform_device mxcspi3_device;
+extern struct platform_device mxci2c_devices[];
+extern struct platform_device mxci2c_hs_device;
+extern struct platform_device mxc_tve_device;
+extern struct platform_device mxc_dvfs_core_device;
+extern struct platform_device mxc_dvfs_per_device;
+extern struct platform_device mxc_ssi1_device;
+extern struct platform_device mxc_ssi2_device;
+extern struct platform_device mxc_esai_device;
+extern struct platform_device mxc_alsa_spdif_device;
+extern struct platform_device mx51_lpmode_device;
+extern struct platform_device mx53_lpmode_device;
+extern struct platform_device busfreq_device;
+extern struct platform_device sdram_autogating_device;
+extern struct platform_device mxc_iim_device;
+extern struct platform_device mxc_sim_device;
+extern struct platform_device mxcsdhc1_device;
+extern struct platform_device mxcsdhc2_device;
+extern struct platform_device mxcsdhc3_device;
+extern struct platform_device ahci_fsl_device;
+extern struct platform_device pata_fsl_device;
+extern struct platform_device gpu_device;
+extern struct platform_device mxc_usbdr_udc_device;
+extern struct platform_device mxc_usbdr_otg_device;
+extern struct platform_device mxc_usbdr_host_device;
+extern struct platform_device mxc_usbh1_device;
+extern struct platform_device mxc_usbh2_device;
+extern struct platform_device mxc_mlb_device;
+extern struct platform_device mxc_nandv2_mtd_device;
+extern struct platform_device mxc_pxp_device;
+extern struct platform_device mxc_pxp_client_device;
+extern struct platform_device epdc_device;
+extern struct platform_device elcdif_device;
+extern struct platform_device mxc_v4l2_device;
+extern struct platform_device mxc_v4l2out_device;
+extern struct platform_device mxs_viim;
diff --git a/arch/arm/mach-mx5/dma.c b/arch/arm/mach-mx5/dma.c
new file mode 100644
index 0000000..39b7776
--- /dev/null
+++ b/arch/arm/mach-mx5/dma.c
@@ -0,0 +1,1428 @@
+/*
+ *  Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+#include <mach/mxc_uart.h>
+
+#include "serial.h"
+#include "sdma_script_code.h"
+#include "sdma_script_code_mx53.h"
+#include "sdma_script_code_mx50.h"
+
+#define MXC_MMC_BUFFER_ACCESS     0x20
+#define MXC_SDHC_MMC_WML          64
+#define MXC_SDHC_SD_WML           256
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_SPDIF_TXFIFO_WML      0x8
+#define MXC_SPDIF_RXFIFO_WML      0x8
+#define MXC_SPDIF_TX_REG          0x2C
+#define MXC_SPDIF_RX_REG          0x14
+#define MXC_ASRC_FIFO_WML         0x40
+#define MXC_ASRCA_RX_REG          0x60
+#define MXC_ASRCA_TX_REG          0x64
+#define MXC_ASRCB_RX_REG          0x68
+#define MXC_ASRCB_TX_REG          0x6C
+#define MXC_ASRCC_RX_REG          0x70
+#define MXC_ASRCC_TX_REG          0x74
+#define MXC_ESAI_TX_REG           0x00
+#define MXC_ESAI_RX_REG           0x04
+#define MXC_ESAI_FIFO_WML         0x40
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	void *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX_MX51,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX_MX51,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF_MX51,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SPDIF_MX51,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_RXFIFO_WML,
+			.per_address = SPDIF_BASE_ADDR + MXC_SPDIF_RX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SPDIF_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SPDIF_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA4,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA5,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ASRC_DMA3,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ASRC_DMA6,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI1_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI1_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI2_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_SSI2_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI1_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI1_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI1_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX1,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI2_TX0,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_SSI2_TX2,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_SSI2_TX1,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCA_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCB_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcc_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = DMA_REQ_ESAI_TX,
+				       .event_id2 = DMA_REQ_ASRC_DMA6,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ASRC_FIFO_WML,
+			    .per_address2 = ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			    },
+	.channel_num = MXC_DMA_CHANNEL_ASRCC_ESAI,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = int_2_per,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = int_2_per,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_RX, &mxc_sdma_spdif_32bit_rx_params},
+	{MXC_DMA_ASRC_A_RX, &mxc_sdma_asrca_rx_params},
+	{MXC_DMA_ASRC_A_TX, &mxc_sdma_asrca_tx_params},
+	{MXC_DMA_ASRC_B_RX, &mxc_sdma_asrcb_rx_params},
+	{MXC_DMA_ASRC_B_TX, &mxc_sdma_asrcb_tx_params},
+	{MXC_DMA_ASRC_C_RX, &mxc_sdma_asrcc_rx_params},
+	{MXC_DMA_ASRC_C_TX, &mxc_sdma_asrcc_tx_params},
+	{MXC_DMA_ASRCA_SSI1_TX0, &mxc_sdma_asrca_ssi1_tx0_params},
+	{MXC_DMA_ASRCA_SSI1_TX1, &mxc_sdma_asrca_ssi1_tx1_params},
+	{MXC_DMA_ASRCA_SSI2_TX0, &mxc_sdma_asrca_ssi2_tx0_params},
+	{MXC_DMA_ASRCA_SSI2_TX1, &mxc_sdma_asrca_ssi2_tx1_params},
+	{MXC_DMA_ASRCB_SSI1_TX0, &mxc_sdma_asrcb_ssi1_tx0_params},
+	{MXC_DMA_ASRCB_SSI1_TX1, &mxc_sdma_asrcb_ssi1_tx1_params},
+	{MXC_DMA_ASRCB_SSI2_TX0, &mxc_sdma_asrcb_ssi2_tx0_params},
+	{MXC_DMA_ASRCB_SSI2_TX1, &mxc_sdma_asrcb_ssi2_tx1_params},
+	{MXC_DMA_ASRCA_ESAI, &mxc_sdma_asrca_esai_params},
+	{MXC_DMA_ASRCB_ESAI, &mxc_sdma_asrcb_esai_params},
+	{MXC_DMA_ASRCC_ESAI, &mxc_sdma_asrcc_esai_params},
+	{MXC_DMA_ESAI_16BIT_RX, &mxc_sdma_esai_16bit_rx_params},
+	{MXC_DMA_ESAI_16BIT_TX, &mxc_sdma_esai_16bit_tx_params},
+	{MXC_DMA_ESAI_24BIT_RX, &mxc_sdma_esai_24bit_rx_params},
+	{MXC_DMA_ESAI_24BIT_TX, &mxc_sdma_esai_24bit_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+static int __init dma_fixups(void)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+	dma_channel_ext_params *params;
+
+	if (cpu_is_mx51())
+		return 0;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		params = &(((mxc_sdma_channel_ext_params_t *)p->chnl_info)->chnl_ext_params);
+		params->common.per_address -= 0x20000000;
+		if (params->common.ext)
+			params->per_address2 -= 0x20000000;
+	}
+
+	mxc_sdma_uart2_rx_params.chnl_params.event_id = DMA_REQ_FIRI_RX;
+	mxc_sdma_uart2_tx_params.chnl_params.event_id = DMA_REQ_FIRI_TX;
+	mxc_sdma_uart3_rx_params.chnl_params.event_id = DMA_REQ_UART3_RX_MX53;
+	mxc_sdma_uart3_tx_params.chnl_params.event_id = DMA_REQ_UART3_TX_MX53;
+	mxc_sdma_spdif_16bit_tx_params.chnl_params.event_id = DMA_REQ_SPDIF_TX;
+	mxc_sdma_spdif_32bit_tx_params.chnl_params.event_id = DMA_REQ_SPDIF_TX;
+
+	return 0;
+}
+arch_initcall(dma_fixups);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
+
+static void __init mx51_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	/* ATA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+}
+
+static void __init mx53_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = firi_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = mcu_2_firi_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR_MX53;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_MX53;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR_MX53;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = mcu_2_shp_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_MX53;
+
+	/* ATA use it's own DMA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = -1;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = -1;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = mcu_2_app_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_MX53;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = spdif_2_mcu_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = mcu_2_spdif_ADDR_MX53;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = asrc__mcu_ADDR_MX53;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = mcu_2_app_ADDR_MX53;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code_mx53;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR_MX53;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_MX53;
+}
+
+static void __init mx50_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	/* AP<->BP */
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_ap_2_ap_fixed_addr = -1;
+
+	/*misc */
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	/* firi */
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	/* uart */
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_MX50;
+
+	/* UART SH */
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR_MX50;
+
+	/* SHP */
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = mcu_2_shp_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_MX50;
+
+	/* ATA use it's own DMA */
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = -1;
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = -1;
+
+	/* app */
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = mcu_2_app_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_MX50;
+
+	/* MSHC */
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	/* spdif */
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = -1;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = -1;
+
+	/* IPU */
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = -1;
+
+	/* DVFS */
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+
+	/* core */
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code_mx50;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR_MX50;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_MX50;
+}
+
+void __init mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	if (cpu_is_mx51())
+		mx51_sdma_get_script_info(sdma_script_addr);
+	else if (cpu_is_mx53())
+		mx53_sdma_get_script_info(sdma_script_addr);
+	else
+		mx50_sdma_get_script_info(sdma_script_addr);
+}
+
diff --git a/arch/arm/mach-mx5/dummy_gpio.c b/arch/arm/mach-mx5/dummy_gpio.c
new file mode 100644
index 0000000..6766cdf
--- /dev/null
+++ b/arch/arm/mach-mx5/dummy_gpio.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2007-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+
+void gpio_uart_active(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_active);
+
+void gpio_uart_inactive(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+void gpio_gps_active(void) {}
+EXPORT_SYMBOL(gpio_gps_active);
+
+void gpio_gps_inactive(void) {}
+EXPORT_SYMBOL(gpio_gps_inactive);
+
+void config_uartdma_event(int port) {}
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_spi_active(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_active);
+
+void gpio_spi_inactive(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+void gpio_owire_active(void) {}
+EXPORT_SYMBOL(gpio_owire_active);
+
+void gpio_owire_inactive(void) {}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+void gpio_i2c_active(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+void gpio_i2c_inactive(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+void gpio_i2c_hs_active(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_active);
+
+void gpio_i2c_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_inactive);
+
+void gpio_pmic_active(void) {}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+void gpio_activate_audio_ports(void) {}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+void gpio_sdhc_active(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+void gpio_sdhc_inactive(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+void gpio_sensor_select(int sensor) {}
+
+void gpio_sensor_active(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_inactive(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+void gpio_ata_active(void) {}
+EXPORT_SYMBOL(gpio_ata_active);
+
+void gpio_ata_inactive(void) {}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+void gpio_nand_active(void) {}
+EXPORT_SYMBOL(gpio_nand_active);
+
+void gpio_nand_inactive(void) {}
+EXPORT_SYMBOL(gpio_nand_inactive);
+
+void gpio_keypad_active(void) {}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+void gpio_keypad_inactive(void) {}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+int gpio_usbotg_hs_active(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+void gpio_fec_active(void) {}
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void) {}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+void gpio_spdif_active(void) {}
+EXPORT_SYMBOL(gpio_spdif_active);
+
+void gpio_spdif_inactive(void) {}
+EXPORT_SYMBOL(gpio_spdif_inactive);
+
+void gpio_mlb_active(void) {}
+EXPORT_SYMBOL(gpio_mlb_active);
+
+void gpio_mlb_inactive(void) {}
+EXPORT_SYMBOL(gpio_mlb_inactive);
diff --git a/arch/arm/mach-mx5/early_setup.c b/arch/arm/mach-mx5/early_setup.c
new file mode 100644
index 0000000..dd731d7
--- /dev/null
+++ b/arch/arm/mach-mx5/early_setup.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/init.h>
+#include <linux/string.h>
+
+int __initdata primary_di = { 0 };
+static int __init di_setup(char *__unused)
+{
+	primary_di = 1;
+	return 1;
+}
+__setup("di1_primary", di_setup);
+
diff --git a/arch/arm/mach-mx5/iomux.c b/arch/arm/mach-mx5/iomux.c
new file mode 100644
index 0000000..25b8514
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX5 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX5
+ */
+/*!
+ * @file mach-mx5/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX5
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+#include "mx51_pins.h"
+
+#define MUX_I_START_MX53	0x0020
+#define PAD_I_START_MX53	0x348
+#define INPUT_CTL_START_MX53	0x730
+#define MUX_I_END_MX53		(PAD_I_START_MX53 - 4)
+
+#define PAD_I_START_MX50	0x2CC
+#define INPUT_CTL_START_MX50	0x6C4
+
+/*!
+ * IOMUX register (base) addressesf
+ */
+#define IOMUXGPR0		(IO_ADDRESS(IOMUXC_BASE_ADDR))
+#define IOMUXGPR1		(IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004)
+#define IOMUXSW_MUX_CTL	(IO_ADDRESS(IOMUXC_BASE_ADDR))
+#define IOMUXSW_INPUT_CTL	(IO_ADDRESS(IOMUXC_BASE_ADDR))
+
+static u8 iomux_pin_res_table[(0x3F0 / 4) + 1];
+static DEFINE_SPINLOCK(gpio_mux_lock);
+
+static inline void *_get_sw_pad(void)
+{
+	if (cpu_is_mx51())
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX51;
+	else if (cpu_is_mx53())
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX53;
+	else
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + PAD_I_START_MX50;
+}
+
+static inline void *_get_mux_reg(iomux_pin_name_t pin)
+{
+	u32 mux_reg = PIN_TO_IOMUX_MUX(pin);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (mux_reg >= 0x2FC)
+			mux_reg += 8;
+		else if (mux_reg >= 0x130)
+			mux_reg += 0xC;
+	}
+	return IOMUXSW_MUX_CTL + mux_reg;
+}
+
+static inline void *_get_pad_reg(iomux_pin_name_t pin)
+{
+	u32 pad_reg = PIN_TO_IOMUX_PAD(pin);
+	void __iomem *sw_pad_reg = _get_sw_pad();
+
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if ((pin == MX51_PIN_NANDF_RB5) ||
+			(pin == MX51_PIN_NANDF_RB6) ||
+			(pin == MX51_PIN_NANDF_RB7))
+			; /* Do nothing */
+		else if (pad_reg == 0x4D0 - PAD_I_START_MX51)
+			pad_reg += 0x4C;
+		else if (pad_reg == 0x860 - PAD_I_START_MX51)
+			pad_reg += 0x9C;
+		else if (pad_reg >= 0x804 - PAD_I_START_MX51)
+			pad_reg += 0xB0;
+		else if (pad_reg >= 0x7FC - PAD_I_START_MX51)
+			pad_reg += 0xB4;
+		else if (pad_reg >= 0x4E4 - PAD_I_START_MX51)
+			pad_reg += 0xCC;
+		else
+			pad_reg += 8;
+	}
+	return sw_pad_reg + pad_reg;
+}
+
+static inline void *_get_mux_end(void)
+{
+	if (cpu_is_mx50())
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x2C8;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0)
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + (0x3F8 - 4);
+	else
+		return IO_ADDRESS(IOMUXC_BASE_ADDR) + (0x3F0 - 4);
+}
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	void __iomem *mux_reg = _get_mux_reg(pin);
+	u32 mux_data = 0;
+	u8 *rp;
+
+	BUG_ON((mux_reg > _get_mux_end()) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+
+	if (config == IOMUX_CONFIG_GPIO)
+		mux_data = PIN_TO_ALT_GPIO(pin);
+	else
+		mux_data = config;
+
+	__raw_writel(mux_data, mux_reg);
+
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if ((mux_data & *rp) && (*rp != mux_data)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, reg=%p, "
+		       " prev=0x%x new=0x%x\n", mux_reg, *rp, mux_data);
+		ret = -EINVAL;
+	}
+	*rp = mux_data;
+	spin_unlock(&gpio_mux_lock);
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	a configuration as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	int ret = iomux_config_mux(pin, config);
+	int gpio = IOMUX_TO_GPIO(pin);
+
+	if (!ret && (gpio < MXC_GPIO_IRQS) && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin))))
+		ret |= gpio_request(gpio, NULL);
+
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+	int gpio = IOMUX_TO_GPIO(pin);
+
+	*rp = 0;
+	if ((gpio < MXC_GPIO_IRQS)
+	    && ((config == IOMUX_CONFIG_GPIO)
+		|| (config == PIN_TO_ALT_GPIO(pin))))
+		gpio_free(gpio);
+
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	void __iomem *pad_reg = _get_pad_reg(pin);
+	void __iomem *sw_pad_reg = _get_sw_pad();
+
+	BUG_ON(pad_reg < sw_pad_reg);
+	__raw_writel(config, pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin)
+{
+	void __iomem *pad_reg = _get_pad_reg(pin);
+
+	return __raw_readl(pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_get_pad);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ *      */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	void __iomem *reg;
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) < 0) {
+		if (input == MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 4;
+		else if (input == MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT)
+			input -= 5;
+		else if (input >= MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT)
+			input -= 3;
+		else if (input >= MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT)
+			input -= 2;
+		else if (input >= MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT)
+			input -= 1;
+
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51_TO1;
+	} else if (cpu_is_mx51()) {
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX51;
+	} else if (cpu_is_mx53()) {
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX53;
+	} else
+		reg = IOMUXSW_INPUT_CTL + (input << 2) + INPUT_CTL_START_MX50;
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+	__raw_writel(config, reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx5/iomux.h b/arch/arm/mach-mx5/iomux.h
new file mode 100644
index 0000000..0732f21
--- /dev/null
+++ b/arch/arm/mach-mx5/iomux.h
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX5_IOMUX_H__
+#define __MACH_MX5_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+
+/*!
+ * @file mach-mx5/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX5
+ */
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |  23 - 21 | 20  - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I  | GPIO_I | PAD_I  | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 9 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX51_PIN_ETM_D0 is defined in the enumeration:
+ *    ( (0x28 - MUX_I_START) << MUX_I)|( (0x250 - PAD_I_START) << PAD_I)
+ * It means the mux control register is at register offset 0x28. The pad control
+ * register offset is: 0x250 and also occupy the least significant bits
+ * within the register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I			0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I			10
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent which
+ * mux mode is for GPIO (0-based)
+ */
+#define GPIO_I			21
+
+#define NON_GPIO_PORT		0x7
+#define PIN_TO_MUX_MASK		((1 << (PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK		((1 << (GPIO_I - PAD_I)) - 1)
+#define PIN_TO_ALT_GPIO_MASK		((1 << (MUX_IO_I - GPIO_I)) - 1)
+
+#define NON_MUX_I		PIN_TO_MUX_MASK
+#define NON_PAD_I		PIN_TO_PAD_MASK
+
+#define PIN_TO_IOMUX_MUX(pin)	((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin)	((pin >> PAD_I) & PIN_TO_PAD_MASK)
+#define PIN_TO_ALT_GPIO(pin)	((pin >> GPIO_I) & PIN_TO_ALT_GPIO_MASK)
+#define PIN_TO_IOMUX_INDEX(pin)	(PIN_TO_IOMUX_MUX(pin) >> 2)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+typedef unsigned int iomux_pin_name_t;
+typedef unsigned int iomux_input_select_t;
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,	/*!< used as alternate function 0 */
+	IOMUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	IOMUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	IOMUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	IOMUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	IOMUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	IOMUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	IOMUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	IOMUX_CONFIG_GPIO,	/*!< added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0,
+	PAD_CTL_DRV_LOW = 0x0 << 1,
+	PAD_CTL_DRV_MEDIUM = 0x1 << 1,
+	PAD_CTL_DRV_HIGH = 0x2 << 1,
+	PAD_CTL_DRV_MAX = 0x3 << 1,
+	PAD_CTL_ODE_OPENDRAIN_NONE = 0x0 << 3,
+	PAD_CTL_ODE_OPENDRAIN_ENABLE = 0x1 << 3,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_360K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_75k_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_HYS_NONE = 0x0 << 8,
+	PAD_CTL_HYS_ENABLE = 0x1 << 8,
+	PAD_CTL_DDR_INPUT_CMOS = 0x0 << 9,
+	PAD_CTL_DDR_INPUT_DDR = 0x1 << 9,
+	PAD_CTL_DRV_VOT_LOW = 0x0 << 13,
+	PAD_CTL_DRV_VOT_HIGH = 0x1 << 13,
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_config_t;
+
+struct mxc_iomux_pin_cfg {
+	iomux_pin_name_t pin;
+	u8 mux_mode;
+	u16 pad_cfg;
+	u8 in_select;
+	u8 in_mode;
+};
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  config	config as defined in \b #iomux_pin_ocfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t config);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config      the ORed value of elements defined in
+ *                             \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function gets the current pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @return		current pad value
+ */
+unsigned int mxc_iomux_get_pad(iomux_pin_name_t pin);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in
+ *                              \b #iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b #iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+
+#endif				/*  __MACH_MX5_IOMUX_H__ */
diff --git a/arch/arm/mach-mx5/lpmodes.c b/arch/arm/mach-mx5/lpmodes.c
new file mode 100644
index 0000000..fad2d81
--- /dev/null
+++ b/arch/arm/mach-mx5/lpmodes.c
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx51_lpmodes.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC low power modes setup.
+ *
+ * MX51 is designed to play and video with minimal power consumption.
+ * This driver enables the platform to enter and exit audio and video low
+ * power modes.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+#include <linux/regulator/machine.h>
+
+#define ARM_LP_CLK  166250000
+#define GP_LPM_VOLTAGE 775000
+#define GP_NORMAL_VOLTAGE 1050000
+
+static int org_cpu_rate;
+int lp_video_mode;
+int lp_audio_mode;
+static struct device *lpmode_dev;
+struct regulator *gp_core;
+
+void enter_lp_video_mode(void)
+{
+}
+
+void exit_lp_video_mode(void)
+{
+}
+
+void enter_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	int ret;
+
+	struct clk *p_clk;
+	struct clk *amode_parent_clk;
+
+
+	tclk = clk_get(NULL, "ipu_clk");
+	if (clk_get_usecount(tclk) != 0) {
+		printk(KERN_INFO
+		"Cannot enter AUDIO LPM mode - display is still active\n");
+		return;
+	}
+
+	tclk = clk_get(NULL, "cpu_clk");
+	org_cpu_rate = clk_get_rate(tclk);
+
+#ifdef CHANGE_DDR2_TO_PLL2
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+	/* Set CPU clock to be derived from PLL2 instead of PLL1 */
+	tclk = clk_get(NULL, "pll1_sw_clk");
+	clk_set_parent(tclk, clk_get(NULL, "pll2"));
+	clk_enable(tclk);
+
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+
+	/*Change the DDR freq to 133Mhz. */
+	tclk = clk_get(NULL, "ddr_hf_clk");
+	clk_set_rate(tclk, clk_round_rate(tclk, 133000000));
+
+	tclk = clk_get(NULL, "cpu_clk");
+	ret = clk_set_rate(tclk, ARM_LP_CLK);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+	/* Set the voltage to 0.775v for the GP domain. */
+	ret = regulator_set_voltage(gp_core, GP_LPM_VOLTAGE, GP_LPM_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	tclk = clk_get(NULL, "periph_apm_clk");
+	amode_parent_clk = clk_get(NULL, "lp_apm");
+	p_clk = clk_get_parent(tclk);
+	/* Make sure osc_clk is the parent of lp_apm. */
+	clk_set_parent(amode_parent_clk, clk_get(NULL, "osc"));
+	/* Set the parent of periph_apm_clk to be lp_apm */
+	clk_set_parent(tclk, amode_parent_clk);
+
+	amode_parent_clk = tclk;
+
+	tclk = clk_get(NULL, "main_bus_clk");
+	p_clk = clk_get_parent(tclk);
+	/* Set the parent of main_bus_clk to be periph_apm_clk */
+	clk_set_parent(tclk, amode_parent_clk);
+
+	clk_set_rate(clk_get(NULL, "axi_a_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "axi_b_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "ahb_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "emi_slow_clk"), 24000000);
+	clk_set_rate(clk_get(NULL, "nfc_clk"), 12000000);
+
+	/* disable PLL3 */
+	tclk = clk_get(NULL, "pll3");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	/* disable PLL2 */
+	tclk = clk_get(NULL, "pll2");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	/* disable PLL1 */
+	tclk = clk_get(NULL, "pll1_main_clk");
+	if (tclk->usecount == 1)
+		clk_disable(tclk);
+
+	lp_audio_mode = 1;
+}
+
+void exit_lp_audio_mode(void)
+{
+	struct clk *tclk;
+	struct clk *p_clk;
+	struct clk *rmode_parent_clk;
+	int ret;
+
+	/* Set the voltage to 1.05v for the GP domain. */
+	ret = regulator_set_voltage(gp_core,
+				    GP_NORMAL_VOLTAGE, GP_NORMAL_VOLTAGE);
+	if (ret < 0)
+		printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!\n");
+
+	rmode_parent_clk = clk_get(NULL, "pll2");
+	clk_enable(rmode_parent_clk);
+
+	tclk = clk_get(NULL, "main_bus_clk");
+	p_clk = clk_get_parent(tclk);
+
+	/* Set the dividers before setting the parent clock. */
+	clk_set_rate(clk_get(NULL, "axi_a_clk"), 6000000);
+	clk_set_rate(clk_get(NULL, "axi_b_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "ahb_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "emi_slow_clk"), 4800000);
+	clk_set_rate(clk_get(NULL, "nfc_clk"), 1200000);
+	/* Set the parent of main_bus_clk to be pll2 */
+	clk_set_parent(tclk, rmode_parent_clk);
+
+#ifdef CHANGE_DDR2_TO_PLL2
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "axi_a_clk"));
+
+	/* Set CPU clock to be derived from PLL1 instead of PLL2 */
+	tclk = clk_get(NULL, "pll1_sw_clk");
+	clk_set_parent(tclk, clk_get(NULL, "pll1_main_clk"));
+	clk_disable(tclk);
+
+	tclk = clk_get(NULL, "ddr_clk");
+	clk_set_parent(tclk, clk_get(NULL, "ddr_hf_clk"));
+#endif
+
+	tclk = clk_get(NULL, "cpu_clk");
+	ret = clk_set_rate(tclk, org_cpu_rate);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+	clk_put(tclk);
+
+	tclk = clk_get(NULL, "cpu_clk");
+
+	ret = clk_set_rate(tclk, org_cpu_rate);
+	if (ret != 0)
+		printk(KERN_DEBUG "cannot set CPU clock rate\n");
+
+
+	/*Change the DDR freq to 200MHz*/
+	tclk = clk_get(NULL, "ddr_hf_clk");
+	clk_set_rate(tclk, clk_round_rate(tclk, 200000000));
+	lp_audio_mode = 0;
+
+}
+
+static ssize_t lp_curr_mode(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	if (lp_video_mode)
+		return sprintf(buf, "in lp_video_mode\n");
+	else if (lp_audio_mode)
+		return sprintf(buf, "in lp_audio_mode\n");
+	else
+		return sprintf(buf, "in normal mode\n");
+}
+
+static ssize_t set_lp_mode(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf, size_t size)
+{
+	printk(KERN_DEBUG "In set_lp_mode() \n");
+
+	if (strstr(buf, "enable_lp_video") != NULL) {
+		if (!lp_video_mode)
+			enter_lp_video_mode();
+	} else if (strstr(buf, "disable_lp_video") != NULL) {
+		if (lp_video_mode)
+			exit_lp_video_mode();
+	} else if (strstr(buf, "enable_lp_audio") != NULL) {
+		if (!lp_audio_mode)
+			enter_lp_audio_mode();
+	} else if (strstr(buf, "disable_lp_audio") != NULL) {
+		if (lp_audio_mode)
+			exit_lp_audio_mode();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(lp_modes, 0644, lp_curr_mode, set_lp_mode);
+
+/*!
+ * This is the probe routine for the lp_mode driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mx51_lpmode_probe(struct platform_device *pdev)
+{
+	u32 res = 0;
+	lpmode_dev = &pdev->dev;
+
+	res = sysfs_create_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+	if (res) {
+		printk(KERN_ERR
+		"lpmode_dev: Unable to register sysdev entry for lpmode_dev");
+		return res;
+	}
+
+	if (res != 0) {
+		printk(KERN_ERR "lpmode_dev: Unable to start");
+		return res;
+	}
+	gp_core = regulator_get(NULL, "SW1");
+	lp_video_mode = 0;
+	lp_audio_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver mx51_lpmode_driver = {
+	.driver = {
+		   .name = "mx51_lpmode",
+		   },
+	.probe = mx51_lpmode_probe,
+};
+
+/*!
+ * Initialise the mx51_lpmode_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init lpmode_init(void)
+{
+	if (platform_driver_register(&mx51_lpmode_driver) != 0) {
+		printk(KERN_ERR "mx37_lpmode_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "LPMode driver module loaded\n");
+	return 0;
+}
+
+static void __exit lpmode_cleanup(void)
+{
+	sysfs_remove_file(&lpmode_dev->kobj, &dev_attr_lp_modes.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx51_lpmode_driver);
+}
+
+module_init(lpmode_init);
+module_exit(lpmode_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("LPMode driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/mm.c b/arch/arm/mach-mx5/mm.c
index b7677ef..5a8768e 100644
--- a/arch/arm/mach-mx5/mm.c
+++ b/arch/arm/mach-mx5/mm.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * The code contained herein is licensed under the GNU General Public
  * License.  You may obtain a copy of the GNU General Public License
@@ -15,69 +15,49 @@
 #include <linux/init.h>
 
 #include <asm/mach/map.h>
+#include <mach/iomux-v3.h>
 
 #include <mach/hardware.h>
 #include <mach/common.h>
 #include <mach/iomux-v3.h>
 
-/*
- * Define the MX51 memory map.
+/*!
+ * This structure defines the MX5x memory map.
  */
-static struct map_desc mxc_io_desc[] __initdata = {
+static struct map_desc mx5_io_desc[] __initdata = {
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_DEVICE},
 	{
-		.virtual = MX51_IRAM_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX51_IRAM_BASE_ADDR),
-		.length = MX51_IRAM_SIZE,
-		.type = MT_DEVICE
-	}, {
-		.virtual = MX51_DEBUG_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX51_DEBUG_BASE_ADDR),
-		.length = MX51_DEBUG_SIZE,
-		.type = MT_DEVICE
-	}, {
-		.virtual = MX51_AIPS1_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX51_AIPS1_BASE_ADDR),
-		.length = MX51_AIPS1_SIZE,
-		.type = MT_DEVICE
-	}, {
-		.virtual = MX51_SPBA0_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX51_SPBA0_BASE_ADDR),
-		.length = MX51_SPBA0_SIZE,
-		.type = MT_DEVICE
-	}, {
-		.virtual = MX51_AIPS2_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX51_AIPS2_BASE_ADDR),
-		.length = MX51_AIPS2_SIZE,
-		.type = MT_DEVICE
-	},
+	 .virtual = SPBA0_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+	 .length = SPBA0_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_DEVICE},
 };
 
-/*
+/*!
  * This function initializes the memory map. It is called during the
- * system startup to create static physical to virtual memory mappings
- * for the IO modules.
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
  */
-void __init mx51_map_io(void)
+void __init mx5_map_io(void)
 {
-	mxc_set_cpu_type(MXC_CPU_MX51);
-	mxc_iomux_v3_init(MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR));
-	mxc_arch_reset_init(MX51_IO_ADDRESS(MX51_WDOG_BASE_ADDR));
-	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
-}
-
-void __init mx51_init_irq(void)
-{
-	unsigned long tzic_addr;
-	void __iomem *tzic_virt;
+	int i;
 
-	if (mx51_revision() < MX51_CHIP_REV_2_0)
-		tzic_addr = MX51_TZIC_BASE_ADDR_TO1;
-	else
-		tzic_addr = MX51_TZIC_BASE_ADDR;
+	mxc_iomux_v3_init(IO_ADDRESS(IOMUXC_BASE_ADDR));
+	/* Fixup the mappings for MX53 */
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		for (i = 0; i < ARRAY_SIZE(mx5_io_desc); i++)
+			mx5_io_desc[i].pfn -= __phys_to_pfn(0x20000000);
+	}
 
-	tzic_virt = ioremap(tzic_addr, SZ_16K);
-	if (!tzic_virt)
-		panic("unable to map TZIC interrupt controller\n");
-
-	tzic_init_irq(tzic_virt);
+	iotable_init(mx5_io_desc, ARRAY_SIZE(mx5_io_desc));
 }
+
diff --git a/arch/arm/mach-mx5/mx50_arm2.c b/arch/arm/mach-mx5/mx50_arm2.c
new file mode 100644
index 0000000..b17bb86
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_arm2.c
@@ -0,0 +1,803 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/max17135.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/videodev2.h>
+#include <linux/mxcfb.h>
+#include <linux/fec.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/flash.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/iomux-mx50.h>
+
+#include "devices.h"
+#include "usb.h"
+
+#define SD1_WP	(3*32 + 19)	/*GPIO_4_19 */
+#define SD1_CD	(0*32 + 27)	/*GPIO_1_27 */
+#define SD2_WP	(4*32 + 16)	/*GPIO_5_16 */
+#define SD2_CD	(4*32 + 17) /*GPIO_5_17 */
+#define SD3_WP	(4*32 + 28) /*GPIO_5_28 */
+#define SD3_CD	(3*32 + 4) /*GPIO_4_4 */
+#define HP_DETECT	(3*32 + 15)	/*GPIO_4_15 */
+#define PWR_INT		(3*32 + 18)	/*GPIO_4_18 */
+#define EPDC_PMIC_WAKE		(5*32 + 16)	/*GPIO_6_16 */
+#define EPDC_PMIC_INT		(5*32 + 17)	/*GPIO_6_17 */
+#define EPDC_VCOM	(3*32 + 21)	/*GPIO_4_21 */
+#define EPDC_PWRSTAT	(2*32 + 28)	/*GPIO_3_28 */
+#define EPDC_ELCDIF_BACKLIGHT	(1*32 + 18)	/*GPIO_2_18 */
+#define CSPI_CS1	(3*32 + 13)	/*GPIO_4_13 */
+#define CSPI_CS2	(3*32 + 11) /*GPIO_4_11*/
+
+extern int __init mx50_arm2_init_mc13892(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+
+static struct pad_desc  mx50_armadillo2[] = {
+	/* SD1 */
+	MX50_PAD_ECSPI2_SS0__GPIO_4_19,
+	MX50_PAD_EIM_CRE__GPIO_1_27,
+	MX50_PAD_SD1_CMD__SD1_CMD,
+
+	MX50_PAD_SD1_CLK__SD1_CLK,
+	MX50_PAD_SD1_D0__SD1_D0,
+	MX50_PAD_SD1_D1__SD1_D1,
+	MX50_PAD_SD1_D2__SD1_D2,
+	MX50_PAD_SD1_D3__SD1_D3,
+
+	/* SD2 */
+	MX50_PAD_SD2_CD__GPIO_5_17,
+	MX50_PAD_SD2_WP__GPIO_5_16,
+	MX50_PAD_SD2_CMD__SD2_CMD,
+	MX50_PAD_SD2_CLK__SD2_CLK,
+	MX50_PAD_SD2_D0__SD2_D0,
+	MX50_PAD_SD2_D1__SD2_D1,
+	MX50_PAD_SD2_D2__SD2_D2,
+	MX50_PAD_SD2_D3__SD2_D3,
+	MX50_PAD_SD2_D4__SD2_D4,
+	MX50_PAD_SD2_D5__SD2_D5,
+	MX50_PAD_SD2_D6__SD2_D6,
+	MX50_PAD_SD2_D7__SD2_D7,
+
+	/* SD3 */
+	MX50_PAD_SD3_WP__GPIO_5_28,
+	MX50_PAD_KEY_COL2__GPIO_4_4,
+	MX50_PAD_SD3_CMD__SD3_CMD,
+	MX50_PAD_SD3_CLK__SD3_CLK,
+	MX50_PAD_SD3_D0__SD3_D0,
+	MX50_PAD_SD3_D1__SD3_D1,
+	MX50_PAD_SD3_D2__SD3_D2,
+	MX50_PAD_SD3_D3__SD3_D3,
+	MX50_PAD_SD3_D4__SD3_D4,
+	MX50_PAD_SD3_D5__SD3_D5,
+	MX50_PAD_SD3_D6__SD3_D6,
+	MX50_PAD_SD3_D7__SD3_D7,
+
+	MX50_PAD_SSI_RXD__SSI_RXD,
+	MX50_PAD_SSI_TXD__SSI_TXD,
+	MX50_PAD_SSI_TXC__SSI_TXC,
+	MX50_PAD_SSI_TXFS__SSI_TXFS,
+
+	/* LINE1_DETECT (headphone detect) */
+	MX50_PAD_ECSPI1_SS0__GPIO_4_15,
+
+	/* PWR_INT */
+	MX50_PAD_ECSPI2_MISO__GPIO_4_18,
+
+	/* UART pad setting */
+	MX50_PAD_UART1_TXD__UART1_TXD,
+	MX50_PAD_UART1_RXD__UART1_RXD,
+	MX50_PAD_UART1_CTS__UART1_CTS,
+	MX50_PAD_UART1_RTS__UART1_RTS,
+	MX50_PAD_UART2_TXD__UART2_TXD,
+	MX50_PAD_UART2_RXD__UART2_RXD,
+	MX50_PAD_UART2_CTS__UART2_CTS,
+	MX50_PAD_UART2_RTS__UART2_RTS,
+
+	MX50_PAD_I2C1_SCL__I2C1_SCL,
+	MX50_PAD_I2C1_SDA__I2C1_SDA,
+	MX50_PAD_I2C2_SCL__I2C2_SCL,
+	MX50_PAD_I2C2_SDA__I2C2_SDA,
+	MX50_PAD_I2C3_SCL__I2C3_SCL,
+	MX50_PAD_I2C3_SDA__I2C3_SDA,
+
+	/* EPDC pins */
+	MX50_PAD_EPDC_D0__EPDC_D0,
+	MX50_PAD_EPDC_D1__EPDC_D1,
+	MX50_PAD_EPDC_D2__EPDC_D2,
+	MX50_PAD_EPDC_D3__EPDC_D3,
+	MX50_PAD_EPDC_D4__EPDC_D4,
+	MX50_PAD_EPDC_D5__EPDC_D5,
+	MX50_PAD_EPDC_D6__EPDC_D6,
+	MX50_PAD_EPDC_D7__EPDC_D7,
+	MX50_PAD_EPDC_GDCLK__EPDC_GDCLK,
+	MX50_PAD_EPDC_GDSP__EPDC_GDSP,
+	MX50_PAD_EPDC_GDOE__EPDC_GDOE	,
+	MX50_PAD_EPDC_GDRL__EPDC_GDRL,
+	MX50_PAD_EPDC_SDCLK__EPDC_SDCLK,
+	MX50_PAD_EPDC_SDOE__EPDC_SDOE,
+	MX50_PAD_EPDC_SDLE__EPDC_SDLE,
+	MX50_PAD_EPDC_SDSHR__EPDC_SDSHR,
+	MX50_PAD_EPDC_BDR0__EPDC_BDR0,
+	MX50_PAD_EPDC_SDCE0__EPDC_SDCE0,
+	MX50_PAD_EPDC_SDCE1__EPDC_SDCE1,
+	MX50_PAD_EPDC_SDCE2__EPDC_SDCE2,
+
+	MX50_PAD_EPDC_PWRSTAT__GPIO_3_28,
+	MX50_PAD_EPDC_VCOM0__GPIO_4_21,
+
+	MX50_PAD_DISP_D8__DISP_D8,
+	MX50_PAD_DISP_D9__DISP_D9,
+	MX50_PAD_DISP_D10__DISP_D10,
+	MX50_PAD_DISP_D11__DISP_D11,
+	MX50_PAD_DISP_D12__DISP_D12,
+	MX50_PAD_DISP_D13__DISP_D13,
+	MX50_PAD_DISP_D14__DISP_D14,
+	MX50_PAD_DISP_D15__DISP_D15,
+	MX50_PAD_DISP_RS__ELCDIF_VSYNC,
+
+	/* ELCDIF contrast */
+	MX50_PAD_DISP_BUSY__GPIO_2_18,
+
+	MX50_PAD_DISP_CS__ELCDIF_HSYNC,
+	MX50_PAD_DISP_RD__ELCDIF_EN,
+	MX50_PAD_DISP_WR__ELCDIF_PIXCLK,
+
+	/* EPD PMIC WAKEUP */
+	MX50_PAD_UART4_TXD__GPIO_6_16,
+
+	/* EPD PMIC intr */
+	MX50_PAD_UART4_RXD__GPIO_6_17,
+
+	MX50_PAD_EPITO__USBH1_PWR,
+	/* Need to comment below line if
+	 * one needs to debug owire.
+	 */
+	MX50_PAD_OWIRE__USBH1_OC,
+	MX50_PAD_PWM2__USBOTG_PWR,
+	MX50_PAD_PWM1__USBOTG_OC,
+
+	MX50_PAD_SSI_RXC__FEC_MDIO,
+	MX50_PAD_SSI_RXC__FEC_MDIO,
+	MX50_PAD_DISP_D0__FEC_TXCLK,
+	MX50_PAD_DISP_D1__FEC_RX_ER,
+	MX50_PAD_DISP_D2__FEC_RX_DV,
+	MX50_PAD_DISP_D3__FEC_RXD1,
+	MX50_PAD_DISP_D4__FEC_RXD0,
+	MX50_PAD_DISP_D5__FEC_TX_EN,
+	MX50_PAD_DISP_D6__FEC_TXD1,
+	MX50_PAD_DISP_D7__FEC_TXD0,
+	MX50_PAD_SSI_RXFS__FEC_MDC,
+
+	MX50_PAD_CSPI_SS0__CSPI_SS0,
+	MX50_PAD_ECSPI1_MOSI__CSPI_SS1,
+	MX50_PAD_CSPI_MOSI__CSPI_MOSI,
+	MX50_PAD_CSPI_MISO__CSPI_MISO,
+};
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+static struct cpu_wp *mx50_arm2_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+static void mx50_arm2_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct fec_platform_data fec_data = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+/* workaround for cspi chipselect pin may not keep correct level when idle */
+static void mx50_arm2_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		break;
+	case 2:
+		break;
+	case 3:
+		switch (chipselect) {
+		case 0x1:
+			{
+			struct pad_desc cspi_ss0 = MX50_PAD_CSPI_SS0__CSPI_SS0;
+			struct pad_desc cspi_cs1 = MX50_PAD_ECSPI1_MOSI__GPIO_4_13;
+
+			/* pull up/down deassert it */
+			mxc_iomux_v3_setup_pad(&cspi_ss0);
+			mxc_iomux_v3_setup_pad(&cspi_cs1);
+
+			gpio_request(CSPI_CS1, "cspi-cs1");
+			gpio_direction_input(CSPI_CS1);
+			}
+			break;
+		case 0x2:
+			{
+			struct pad_desc cspi_ss1 = MX50_PAD_ECSPI1_MOSI__CSPI_SS1;
+			struct pad_desc cspi_ss0 = MX50_PAD_CSPI_SS0__GPIO_4_11;
+
+			/*disable other ss */
+			mxc_iomux_v3_setup_pad(&cspi_ss1);
+			mxc_iomux_v3_setup_pad(&cspi_ss0);
+
+			/* pull up/down deassert it */
+			gpio_request(CSPI_CS2, "cspi-cs2");
+			gpio_direction_input(CSPI_CS2);
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void mx50_arm2_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		break;
+	case 2:
+		break;
+	case 3:
+		switch (chipselect) {
+		case 0x1:
+			gpio_free(CSPI_CS1);
+			break;
+		case 0x2:
+			gpio_free(CSPI_CS2);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+}
+
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx50_arm2_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx50_arm2_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_spi_master mxcspi3_data = {
+	.maxchipselect = 4,
+	.spi_version = 7,
+	.chipselect_active = mx50_arm2_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx50_arm2_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = OCOTP_CTRL_BASE_ADDR + 0x80,
+};
+
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+static struct regulator_init_data max17135_init_data[] __initdata = {
+	{
+		.constraints = {
+			.name = "DISPLAY",
+		},
+	}, {
+		.constraints = {
+			.name = "GVDD",
+			.min_uV = V_to_uV(20),
+			.max_uV = V_to_uV(20),
+		},
+	}, {
+		.constraints = {
+			.name = "GVEE",
+			.min_uV = V_to_uV(-22),
+			.max_uV = V_to_uV(-22),
+		},
+	}, {
+		.constraints = {
+			.name = "HVINN",
+			.min_uV = V_to_uV(-22),
+			.max_uV = V_to_uV(-22),
+		},
+	}, {
+		.constraints = {
+			.name = "HVINP",
+			.min_uV = V_to_uV(20),
+			.max_uV = V_to_uV(20),
+		},
+	}, {
+		.constraints = {
+			.name = "VCOM",
+			.min_uV = mV_to_uV(-4325),
+			.max_uV = mV_to_uV(-500),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		},
+	}, {
+		.constraints = {
+			.name = "VNEG",
+			.min_uV = V_to_uV(-15),
+			.max_uV = V_to_uV(-15),
+		},
+	}, {
+		.constraints = {
+			.name = "VPOS",
+			.min_uV = V_to_uV(15),
+			.max_uV = V_to_uV(15),
+		},
+	},
+};
+
+static struct max17135_platform_data max17135_pdata __initdata = {
+	.vneg_pwrup = 1,
+	.gvee_pwrup = 1,
+	.vpos_pwrup = 2,
+	.gvdd_pwrup = 1,
+	.gvdd_pwrdn = 1,
+	.vpos_pwrdn = 2,
+	.gvee_pwrdn = 1,
+	.vneg_pwrdn = 1,
+	.gpio_pmic_pwrgood = EPDC_PWRSTAT,
+	.gpio_pmic_vcom_ctrl = EPDC_VCOM,
+	.gpio_pmic_wakeup = EPDC_PMIC_WAKE,
+	.gpio_pmic_intr = EPDC_PMIC_INT,
+	.regulator_init = max17135_init_data,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "backlight-i2c",
+	 .addr = 0x2c,
+	 },
+	{
+	 .type = "eeprom",
+	 .addr = 0x50,
+	 },
+};
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+	 I2C_BOARD_INFO("max17135", 0x48),
+	 .platform_data = &max17135_pdata,
+	 },
+};
+
+static struct mtd_partition mxc_dataflash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 0x000100000,},
+	{
+	 .name = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,},
+};
+
+static struct flash_platform_data mxc_spi_flash_data[] = {
+	{
+	 .name = "mxc_dataflash",
+	 .parts = mxc_dataflash_partitions,
+	 .nr_parts = ARRAY_SIZE(mxc_dataflash_partitions),
+	 .type = "at45db321d",}
+};
+
+
+static struct spi_board_info mxc_dataflash_device[] __initdata = {
+	{
+	 .modalias = "mxc_dataflash",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 3,
+	 .chip_select = 1,
+	 .platform_data = &mxc_spi_flash_data[0],},
+};
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(SD1_WP);
+	else if (to_platform_device(dev)->id == 1)
+		rc = gpio_get_value(SD2_WP);
+	else if (to_platform_device(dev)->id == 2)
+		rc = gpio_get_value(SD3_WP);
+
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret = 0;
+	if (to_platform_device(dev)->id == 0)
+		ret = gpio_get_value(SD1_CD);
+	else if (to_platform_device(dev)->id == 1)
+		ret = gpio_get_value(SD2_CD);
+	else if (to_platform_device(dev)->id == 2)
+		ret = gpio_get_value(SD3_CD);
+
+	return ret;
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static struct mxc_mmc_platform_data mmc3_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+/* TO DO */
+	return 0;
+}
+
+static int headphone_det_status(void)
+{
+	return (gpio_get_value(HP_DETECT) != 0);
+}
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ_V3(HP_DETECT),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12288000,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+static struct pad_desc armadillo2_wvga_pads[] = {
+	MX50_PAD_DISP_D0__DISP_D0,
+	MX50_PAD_DISP_D1__DISP_D1,
+	MX50_PAD_DISP_D2__DISP_D2,
+	MX50_PAD_DISP_D3__DISP_D3,
+	MX50_PAD_DISP_D4__DISP_D4,
+	MX50_PAD_DISP_D5__DISP_D5,
+	MX50_PAD_DISP_D6__DISP_D6,
+	MX50_PAD_DISP_D7__DISP_D7,
+};
+
+static void wvga_reset(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(armadillo2_wvga_pads, \
+				ARRAY_SIZE(armadillo2_wvga_pads));
+	return;
+}
+
+static struct mxc_lcd_platform_data lcd_wvga_data = {
+	.reset = wvga_reset,
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_claa",
+	.dev = {
+		.platform_data = &lcd_wvga_data,
+		},
+};
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 800x480 @ 57 Hz , pixel clk @ 27MHz */
+	 "CLAA-WVGA", 57, 800, 480, 37037, 40, 60, 10, 10, 20, 10,
+	 FB_SYNC_CLK_LAT_FALL,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = V4L2_PIX_FMT_RGB565,
+	 .mode_str = "CLAA-WVGA",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+};
+
+static int __initdata enable_w1 = { 0 };
+static int __init w1_setup(char *__unused)
+{
+	enable_w1 = 1;
+	return cpu_is_mx50();
+}
+
+__setup("w1", w1_setup);
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_set_cpu_type(MXC_CPU_MX50);
+
+	get_cpu_wp = mx50_arm2_get_cpu_wp;
+	set_num_cpu_wp = mx50_arm2_set_num_cpu_wp;
+}
+
+static void __init mx50_arm2_io_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx50_armadillo2, \
+			ARRAY_SIZE(mx50_armadillo2));
+
+	gpio_request(SD1_WP, "sdhc1-wp");
+	gpio_direction_input(SD1_WP);
+
+	gpio_request(SD1_CD, "sdhc1-cd");
+	gpio_direction_input(SD1_CD);
+
+	gpio_request(SD2_WP, "sdhc2-wp");
+	gpio_direction_input(SD2_WP);
+
+	gpio_request(SD2_CD, "sdhc2-cd");
+	gpio_direction_input(SD2_CD);
+
+	gpio_request(SD3_WP, "sdhc3-wp");
+	gpio_direction_input(SD3_WP);
+
+	gpio_request(SD3_CD, "sdhc3-cd");
+	gpio_direction_input(SD3_CD);
+
+	gpio_request(HP_DETECT, "hp-det");
+	gpio_direction_input(HP_DETECT);
+
+	gpio_request(PWR_INT, "pwr-int");
+	gpio_direction_input(PWR_INT);
+
+	gpio_request(EPDC_PMIC_WAKE, "epdc-pmic-wake");
+	gpio_direction_output(EPDC_PMIC_WAKE, 0);
+
+	gpio_request(EPDC_VCOM, "epdc-vcom");
+	gpio_direction_output(EPDC_VCOM, 0);
+
+	gpio_request(EPDC_PMIC_INT, "epdc-pmic-int");
+	gpio_direction_input(EPDC_PMIC_INT);
+
+	gpio_request(EPDC_PWRSTAT, "epdc-pwrstat");
+	gpio_direction_input(EPDC_PWRSTAT);
+
+	/* ELCDIF backlight */
+	gpio_request(EPDC_ELCDIF_BACKLIGHT, "elcdif-backlight");
+	gpio_direction_output(EPDC_ELCDIF_BACKLIGHT, 1);
+
+	if (enable_w1) {
+		struct pad_desc one_wire = MX50_PAD_OWIRE__OWIRE;
+		mxc_iomux_v3_setup_pad(&one_wire);
+	}
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	/* SD card detect irqs */
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ_V3(SD1_CD);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ_V3(SD1_CD);
+	mxcsdhc2_device.resource[2].start = IOMUX_TO_IRQ_V3(SD2_CD);
+	mxcsdhc2_device.resource[2].end = IOMUX_TO_IRQ_V3(SD2_CD);
+	mxcsdhc3_device.resource[2].start = IOMUX_TO_IRQ_V3(SD3_CD);
+	mxcsdhc3_device.resource[2].end = IOMUX_TO_IRQ_V3(SD3_CD);
+
+	mxc_cpu_common_init();
+	mx50_arm2_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxcspi3_device, &mxcspi3_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[2], &mxci2c_data);
+
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mxc_pxp_device, NULL);
+	mxc_register_device(&mxc_pxp_client_device, NULL);
+	/*
+	mxc_register_device(&mx53_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	*/
+
+/*	mxc_register_device(&mxc_keypad_device, &keypad_plat_data); */
+
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxcsdhc3_device, &mmc3_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	mxc_register_device(&mxc_fec_device, &fec_data);
+	spi_register_board_info(mxc_dataflash_device,
+				ARRAY_SIZE(mxc_dataflash_device));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+				ARRAY_SIZE(mxc_i2c2_board_info));
+
+	mxc_register_device(&epdc_device, NULL);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
+	mxc_register_device(&elcdif_device, &fb_data[0]);
+	mxc_register_device(&mxs_viim, NULL);
+
+	mx50_arm2_init_mc13892();
+/*
+	pm_power_off = mxc_power_off;
+	*/
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+	mx5_usb_dr_init();
+	mx5_usbh1_init();
+}
+
+static void __init mx50_arm2_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	mx50_clocks_init(32768, 24000000, 22579200);
+
+	uart_clk = clk_get_sys("mxcintuart.0", NULL);
+	early_console_setup(MX53_BASE_ADDR(UART1_BASE_ADDR), uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx50_arm2_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX50_ARM2 data structure.
+ */
+MACHINE_START(MX50_ARM2, "Freescale MX50 ARM2 Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c b/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c
new file mode 100644
index 0000000..66972b1
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_arm2_pmic_mc13892.c
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+
+#include <mach/iomux-mx50.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+/* Coin cell charger enable */
+#define COINCHEN_LSH	23
+#define COINCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* regulator standby mask */
+#define GEN1_STBY_MASK		(1 << 1)
+#define IOHI_STBY_MASK		(1 << 4)
+#define DIG_STBY_MASK		(1 << 10)
+#define GEN2_STBY_MASK		(1 << 13)
+#define PLL_STBY_MASK		(1 << 16)
+#define USB2_STBY_MASK		(1 << 19)
+
+#define GEN3_STBY_MASK		(1 << 1)
+#define CAM_STBY_MASK		(1 << 7)
+#define VIDEO_STBY_MASK		(1 << 13)
+#define AUDIO_STBY_MASK		(1 << 16)
+#define SD_STBY_MASK		(1 << 19)
+
+/* 0x92412 */
+#define REG_MODE_0_ALL_MASK	(GEN1_STBY_MASK |\
+				DIG_STBY_MASK | GEN2_STBY_MASK |\
+				PLL_STBY_MASK)
+/* 0x92082 */
+#define REG_MODE_1_ALL_MASK	(CAM_STBY_MASK | VIDEO_STBY_MASK |\
+				AUDIO_STBY_MASK | SD_STBY_MASK)
+
+/* switch mode setting */
+#define	SW1MODE_LSB	0
+#define	SW2MODE_LSB	10
+#define	SW3MODE_LSB	0
+#define	SW4MODE_LSB	8
+
+#define	SWMODE_MASK	0xF
+#define SWMODE_AUTO	0x8
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+static struct regulator_consumer_supply vgen1_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "1-000a",
+	},
+	{
+		/* sgtl5000 */
+		.supply = "VDDIO",
+		.dev_name = "1-000a",
+	},
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(1200),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	},
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2775),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.apply_uV = 1,
+	},
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(3000),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vgen1_consumers),
+	.consumer_supplies = vgen1_consumers,
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value, register_mask;
+	printk("Initializing regulators for mx50 arm2.\n");
+
+	/* TBD later. */
+#if 0
+	/* enable standby controll for all regulators */
+	pmic_read_reg(REG_MODE_0, &value, 0xffffff);
+	value |= REG_MODE_0_ALL_MASK;
+	pmic_write_reg(REG_MODE_0, value, 0xffffff);
+
+	pmic_read_reg(REG_MODE_1, &value, 0xffffff);
+	value |= REG_MODE_1_ALL_MASK;
+	pmic_write_reg(REG_MODE_1, value, 0xffffff);
+#endif
+
+	/* enable switch audo mode */
+	pmic_read_reg(REG_IDENTIFICATION, &value, 0xffffff);
+	/* only for mc13892 2.0A */
+	if ((value & 0x0000FFFF) == 0x45d0) {
+		pmic_read_reg(REG_SW_4, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW1MODE_LSB) |
+		       (SWMODE_MASK << SW2MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW1MODE_LSB) |
+			(SWMODE_AUTO << SW2MODE_LSB);
+		pmic_write_reg(REG_SW_4, value, 0xffffff);
+
+		pmic_read_reg(REG_SW_5, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW3MODE_LSB) |
+			(SWMODE_MASK << SW4MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW3MODE_LSB) |
+			(SWMODE_AUTO << SW4MODE_LSB);
+		pmic_write_reg(REG_SW_5, value, 0xffffff);
+	}
+	/* Enable coin cell charger */
+	value = BITFVAL(COINCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(COINCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	regulator_has_full_constraints();
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct spi_board_info __initdata mc13892_spi_device = {
+	.modalias = "pmic_spi",
+	.irq = IOMUX_TO_IRQ_V3(114),
+	.max_speed_hz = 6000000,	/* max spi SCK clock speed in HZ */
+	.bus_num = 3,
+	.chip_select = 0,
+	.platform_data = &mc13892_plat,
+};
+
+
+int __init mx50_arm2_init_mc13892(void)
+{
+	return spi_register_board_info(&mc13892_spi_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx50_suspend.S b/arch/arm/mach-mx5/mx50_suspend.S
new file mode 100644
index 0000000..25a49d4
--- /dev/null
+++ b/arch/arm/mach-mx5/mx50_suspend.S
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  	1 << 2
+#define ARM_CTRL_ICACHE  	1 << 12
+#define ARM_AUXCR_L2EN   	1 << 1
+
+/*
+ *	mx50_suspend
+ *
+ *	Suspend the processor (eg, wait for interrupt).
+ *    Set the DDR into Self Refresh
+ *	IRQs are already disabled.
+ */
+ENTRY(mx50_suspend)
+    stmfd   sp!, {r4,r5,r6,r7,r9,r10,r11}     @ Save registers
+
+   mov    r6, r0                       @save databahn address
+    /* Disable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    bic     r0, r0, #ARM_CTRL_ICACHE @ Disable ICache
+    bic     r0, r0, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000   @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedClean
+    mov     r10, #0
+Loop1Clean:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type
+                                         @ for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipClean                @ No cache or only instruction cache
+    						  @ at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7                 @ Extract the line length field
+    add     r2, r2, #4                 @ Add 4 for the line length offset
+                                            @ (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the
+                                           @ way size (right aligned)
+    clz     r5, r4                       @ R5 is the bit position of the way
+                                           @ size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index
+                                           @ size (right aligned)
+Loop2Clean:
+    mov     r9, r4                     @ R9 working copy of the max way size
+                                           @ (right aligned)
+Loop3Clean:
+    orr     r11, r10, r9, lsl r5      @ Factor in the way number and cache
+                                           @number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c14, 2 @ Clean and invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Clean
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Clean
+SkipClean:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Clean
+
+FinishedClean:
+
+    /* Disable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    bic     r0, r0, #ARM_AUXCR_L2EN @ Disable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+/* Wait for the databahn to idle
+     Meaning, no access to the databahn is
+     being made.
+*/
+EnterWFI:
+ 	ldr 	r1,  [r6, #0x8]
+	ldr     r0,[r1]
+	and     r0, r0, #0x100
+	ldr     r2, =0x100
+	cmp     r0, r2
+	beq     EnterWFI
+	/* Enter self-refresh mode */
+	ldr     r1,[r6, #0x4]
+	ldr     r0,[r1]
+	orr     r0,r0,#0x1
+	str     r0,[r1]
+
+LoopCKE0:
+	/* Wait for CKE = 0 */
+	ldr     r1,[r6, #0x8]
+	ldr     r0,[r1]
+	and     r0, r0, #0x10
+	ldr     r2, =0x10
+	cmp     r0, r2
+	beq     LoopCKE0
+	/* Stop controller */
+	ldr     r1,[r6, #0]
+	ldr     r0,[r1]
+	and     r0,r0,#0xfffffffe
+	str     r0,[r1]
+
+    .long     0xe320f003              @ Opcode for WFI
+
+
+	/* Start controller */
+	ldr     r1,[r6, #0]
+	ldr     r0,[r1]
+	orr     r0,r0,#0x1
+	str     r0,[r1]
+
+LoopPHY:
+	/* Wait for PHY ready */
+	ldr     r1,[r6, #0xC]
+	ldr     r0,[r1]
+	and     r0, r0, #0xfffffffe
+	ldr     r2, =0x0
+	cmp     r0, r2
+	beq     LoopPHY
+	/*Leave self-refresh mode */
+	ldr     r1,[r6, #4]
+	ldr     r0,[r1]
+	and     r0,r0,#0xfffffffe
+	str     r0,[r1]
+
+LoopCKE1:
+	/*Wait for CKE = 1 */
+	ldr     r1,[r6, #0x8]
+	ldr     r0,[r1]
+	and     r0, r0, #0x10
+	ldr     r2, =0x0
+	cmp     r0, r2
+	beq     LoopCKE1
+
+    mov     r0, #0
+    mcr     p15, 0, r0, c7, c5, 0   @ Invalidate inst cache
+
+/* Invalidate data caches */
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000   @ Isolate level of coherency
+    mov     r3, r3, lsr #23          @ Cache level value (naturally aligned)
+    beq     FinishedInvalidate
+    mov     r10, #0
+Loop1Invalidate:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2            @ R0 bottom 3 bits = Cache
+                                           @Type for this level
+    and     r1, r1, #7                @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipInvalidate           @ No cache or only instruction cache
+                                           @at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7                 @ Extract the line length field
+    add     r2, r2, #4                 @ Add 4 for the line length offset
+                                            @(log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3       @ R4 is the max number on the way
+                                            @size (right aligned)
+    clz     r5, r4                        @ R5 is the bit position of the way
+                                            @ size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13      @ R7 is the max number of the
+                                            @ index size (right aligned)
+Loop2Invalidate:
+    mov     r9, r4                       @ R9 working copy of the max way
+                                             @ size (right aligned)
+Loop3Invalidate:
+    orr     r11, r10, r9, lsl r5        @ Factor in the way number and cache
+                                             @ number into R11
+    orr     r11, r11, r7, lsl r2        @ Factor in the index number
+    mcr     p15, 0, r11, c7, c6, 2  @ Invalidate by set/way
+    subs    r9, r9, #1                 @ Decrement the way number
+    bge     Loop3Invalidate
+    subs    r7, r7, #1                 @ Decrement the index
+    bge     Loop2Invalidate
+SkipInvalidate:
+    add     r10, r10, #2              @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Invalidate
+
+FinishedInvalidate:
+
+    /* Enable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1     @ R0 = auxiliary control reg
+    orr     r0, r0, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    /* Enable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    orr     r0, r0, #ARM_CTRL_ICACHE @ Enable ICache
+    orr     r0, r0, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    /* Restore registers */
+    ldmfd sp!, {r4,r5,r6,r7,r9,r10,r11}
+    mov		pc, lr
+
+	.type	mx50_do_suspend, #object
+ENTRY(mx50_do_suspend)
+	.word	mx50_suspend
+	.size	mx50_suspend, . - mx50_suspend
diff --git a/arch/arm/mach-mx5/mx51_3stack.c b/arch/arm/mach-mx5/mx51_3stack.c
new file mode 100644
index 0000000..9b8b723
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_3stack.c
@@ -0,0 +1,1075 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/smsc911x.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/pmic_external.h>
+#include <linux/ipu.h>
+#include <linux/pwm_backlight.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/keypad.h>
+#include <mach/common.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+
+#include "devices.h"
+#include "iomux.h"
+#include "mx51_pins.h"
+#include "crm_regs.h"
+#include "usb.h"
+
+/*!
+ * @file mach-mx51/mx51_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX51
+ */
+#define DEBUG_BOARD_BASE_ADDRESS(n)	(n)
+/* LAN9217 ethernet base address */
+#define LAN9217_BASE_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n))
+
+#define BOARD_IO_ADDR(n)	(DEBUG_BOARD_BASE_ADDRESS(n) + 0x20000)
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG	0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+/* interrupts like external uart , external ethernet etc*/
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX51_PIN_GPIO1_6)
+
+#define EXPIO_INT_ENET		(MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUART_A 	(MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUART_B 	(MXC_BOARD_IRQ_START + 2)
+#define EXPIO_INT_BUTTON_A 	(MXC_BOARD_IRQ_START + 3)
+#define EXPIO_INT_BUTTON_B 	(MXC_BOARD_IRQ_START + 4)
+
+#define MXC_IRQ_TO_EXPIO(irq)	((irq) - MXC_BOARD_IRQ_START)
+
+/*! This is System IRQ used by LAN9217 */
+#define LAN9217_IRQ	EXPIO_INT_ENET
+
+extern int __init mx51_3stack_init_mc13892(void);
+extern void __init mx51_3stack_io_init(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+static bool debug_board_present;
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+struct cpu_wp *mx51_3stack_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+void mx51_3stack_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static u16 keymapping[24] = {
+	KEY_1, KEY_2, KEY_3, KEY_F1, KEY_UP, KEY_F2,
+	KEY_4, KEY_5, KEY_6, KEY_LEFT, KEY_SELECT, KEY_RIGHT,
+	KEY_7, KEY_8, KEY_9, KEY_F3, KEY_DOWN, KEY_F4,
+	KEY_0, KEY_OK, KEY_ESC, KEY_ENTER, KEY_MENU, KEY_BACK,
+};
+
+static struct keypad_data keypad_plat_data = {
+	.rowmax = 4,
+	.colmax = 6,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+extern void mx5_ipu_reset(void);
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 2,
+	.reset = mx5_ipu_reset,
+};
+
+extern void mx5_vpu_reset(void);
+static struct mxc_vpu_platform_data mxc_vpu_data = {
+	.reset = mx5_vpu_reset,
+};
+
+/* workaround for ecspi chipselect pin may not keep correct level when idle */
+static void mx51_3ds_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	u32 gpio;
+
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			mxc_request_iomux(MX51_PIN_CSPI1_SS0,
+					  IOMUX_CONFIG_ALT0);
+			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS0,
+					  PAD_CTL_HYS_ENABLE |
+					  PAD_CTL_PKE_ENABLE |
+					  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST);
+			break;
+		case 0x2:
+			gpio = IOMUX_TO_GPIO(MX51_PIN_CSPI1_SS0);
+			mxc_request_iomux(MX51_PIN_CSPI1_SS0,
+					  IOMUX_CONFIG_GPIO);
+			gpio_request(gpio, "cspi1_ss0");
+			gpio_direction_output(gpio, 0);
+			gpio_set_value(gpio, 1 & (~status));
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static void mx51_3ds_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			mxc_free_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX51_PIN_CSPI1_SS0,
+					  IOMUX_CONFIG_GPIO);
+			mxc_free_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_GPIO);
+			break;
+		case 0x2:
+			mxc_free_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_GPIO);
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx51_3ds_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx51_3ds_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+	.dig_reg = "VDIG",
+};
+
+static struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+static struct mxc_dvfsper_data dvfs_per_data = {
+	.reg_id = "SW2",
+	.clk_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
+	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
+	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
+	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
+	.div3_offset = 0,
+	.div3_mask = 0x7,
+	.div3_div = 2,
+	.lp_high = 1200000,
+	.lp_low = 1200000,
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+};
+
+
+/* NAND Flash Partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition nand_flash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 3 * 1024 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 5 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs1",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs2",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+#endif
+
+extern void gpio_nand_active(void);
+extern void gpio_nand_inactive(void);
+
+static int nand_init(void)
+{
+	/* Configure the pins */
+	gpio_nand_active();
+	return 0;
+}
+
+static void nand_exit(void)
+{
+	/* Free the pins */
+	gpio_nand_inactive();
+}
+
+static struct flash_platform_data mxc_nand_data = {
+	#ifdef CONFIG_MTD_PARTITIONS
+		.parts = nand_flash_partitions,
+		.nr_parts = ARRAY_SIZE(nand_flash_partitions),
+	#endif
+	.width = 1,
+	.init = nand_init,
+	.exit = nand_exit,
+};
+
+/* i.MX MTD NAND Flash Controller */
+
+#if defined(CONFIG_MTD_NAND_IMX_NFC) || defined(CONFIG_MTD_NAND_IMX_NFC_MODULE)
+
+/*
+ * Platform-specific information about this device. Some of the details depend
+ * on the SoC. See imx_init_nfc() below for code that fills in the rest.
+ */
+
+static struct imx_nfc_platform_data imx_nfc_platform_data = {
+	.nfc_major_version  = 3,
+	.nfc_minor_version  = 2,
+	.force_ce           = false,
+	.target_cycle_in_ns = 30,
+	.clock_name         = "nfc_clk",
+	.set_page_size      = 0,
+	.interleave         = false,
+	#ifdef CONFIG_MTD_PARTITIONS
+		.partitions      = nand_flash_partitions,
+		.partition_count = ARRAY_SIZE(nand_flash_partitions),
+	#endif
+};
+
+#endif /* i.MX MTD NAND Flash Controller */
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB666,
+	 },
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_YUV444,
+	 },
+};
+
+static void lcd_reset_to2(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	ipu_reset_disp_panel();
+
+	return;
+}
+
+static void lcd_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), "ser_rs");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 0);
+	/* do reset */
+	msleep(10);		/* tRES >= 100us */
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 1);
+	msleep(60);
+}
+
+static struct mxc_lcd_platform_data lcd_data = {
+	.core_reg = "VIOHI",
+	.io_reg = "SW4",
+	.reset = lcd_reset,
+};
+
+static struct platform_device mxc_lcd_device = {
+	.name = "lcd_spi",
+};
+
+static void wvga_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 1);
+}
+
+static struct mxc_lcd_platform_data lcd_wvga_data = {
+	.reset = wvga_reset,
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_claa",
+};
+
+static struct platform_device mxcbl_device = {
+	.name = "mxc_mc13892_bl",
+};
+
+static void si4702_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 0);
+	msleep(100);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 1);
+	msleep(100);
+}
+
+static void si4702_clock_ctl(int flag)
+{
+}
+
+static void si4702_gpio_get(void)
+{
+	/* reset pin */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), "eim_dtack");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 0);
+}
+
+static void si4702_gpio_put(void)
+{
+}
+
+static struct mxc_fm_platform_data si4702_data = {
+	.reg_vio = "SW4",
+	.reg_vdd = "VIOHI",
+	.gpio_get = si4702_gpio_get,
+	.gpio_put = si4702_gpio_put,
+	.reset = si4702_reset,
+	.clock_ctl = si4702_clock_ctl,
+	.sksnr = 0,
+	.skcnt = 0,
+	.band = 0,
+	.space = 100,
+	.seekth = 0xa,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "wm8903-i2c",
+	 .addr = 0x1a,
+	 },
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "tsc2007",
+	 .addr = 0x48,
+	 .irq  = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
+	},
+	{
+	 .type = "si4702",
+	 .addr = 0x10,
+	 .platform_data = (void *)&si4702_data,
+	 },
+};
+
+static struct mxc_camera_platform_data camera_data = {
+	.io_regulator = "SW4",
+	.analog_regulator = "VIOHI",
+	.mclk = 24000000,
+	.csi = 0,
+};
+static struct mxc_lightsensor_platform_data ls_data = {
+	.vdd_reg = NULL,
+	.rext = 100,
+};
+
+static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
+	{
+		.type = "ov3640",
+		.addr = 0x3C,
+		.platform_data = (void *)&camera_data,
+	},
+	{
+		.type = "isl29003",
+		.addr = 0x44,
+		.platform_data = &ls_data,
+	 },
+};
+
+static struct resource smsc911x_resources[] = {
+	{
+	 .start = CS5_BASE_ADDR,
+	 .end = CS5_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = LAN9217_IRQ,
+	 .end = LAN9217_IRQ,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.flags = SMSC911X_USE_32BIT | SMSC911X_FORCE_INTERNAL_PHY,
+};
+
+static struct platform_device smsc_lan9217_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static struct mxc_sim_platform_data sim_data = {
+	.clk_rate = 4000000,
+	.clock_sim = "sim_clk",
+	.power_sim = NULL,
+	.init = NULL,
+	.exit = NULL,
+	.detect = 0,
+};
+
+/*!
+ * Get WP pin value to detect write protection
+ */
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1));
+	else
+		rc = 0;
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0));
+		return ret;
+	} else {		/* config the det pin for SDHC2 */
+		return 0;
+	}
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_32_33,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 52000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+	    MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static u32 brd_io;
+static void expio_ack_irq(u32 irq);
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr_val;
+	u32 int_valid;
+	u32 expio_irq;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr_val = __raw_readw(brd_io + INTR_MASK_REG);
+	int_valid = __raw_readw(brd_io + INTR_STATUS_REG) & ~imr_val;
+
+	if (unlikely(!int_valid))
+		goto out;
+
+	expio_irq = MXC_BOARD_IRQ_START;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irq_desc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d);
+	}
+
+      out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u16 reg;
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* mask the interrupt */
+	reg = __raw_readw(brd_io + INTR_MASK_REG);
+	reg |= (1 << expio);
+	__raw_writew(reg, brd_io + INTR_MASK_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u16 reg;
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* unmask the interrupt */
+	reg = __raw_readw(brd_io + INTR_MASK_REG);
+	reg &= ~(1 << expio);
+	__raw_writew(reg, brd_io + INTR_MASK_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	brd_io = (u32) ioremap(BOARD_IO_ADDR(CS5_BASE_ADDR), SZ_4K);
+	if (brd_io == 0)
+		return -ENOMEM;
+
+	if ((__raw_readw(brd_io + MAGIC_NUMBER1_REG) != 0xAAAA) ||
+	    (__raw_readw(brd_io + MAGIC_NUMBER2_REG) != 0x5555) ||
+	    (__raw_readw(brd_io + MAGIC_NUMBER3_REG) != 0xCAFE)) {
+		pr_info("3-Stack Debug board not detected \n");
+		return -ENODEV;
+	} else {
+		debug_board_present = true;
+	}
+
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n",
+		readw(brd_io + CPLD_CODE_VER_REG));
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_6), "gpio1_6");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_6));
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0, brd_io + INTR_MASK_REG);
+	__raw_writew(0xFFFF, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	__raw_writew(0x1F, brd_io + INTR_MASK_REG);
+	for (i = MXC_BOARD_IRQ_START; i < (MXC_BOARD_IRQ_START + MXC_BOARD_IRQS);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQF_TRIGGER_LOW);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
+
+	return 0;
+}
+
+extern void gpio_ata_active(void);
+extern void gpio_ata_inactive(void);
+
+static int ata_init(struct platform_device *pdev)
+{
+	/* Configure the pins */
+	gpio_ata_active();
+	return 0;
+}
+
+static void ata_exit(void)
+{
+	/* Free the pins */
+	gpio_ata_inactive();
+}
+
+static struct fsl_ata_platform_data ata_data = {
+	.udma_mask = ATA_UDMA3,
+	.mwdma_mask = ATA_MWDMA2,
+	.pio_mask = ATA_PIO4,
+	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
+	.max_sg = MXC_IDE_DMA_BD_NR,
+	.init = ata_init,
+	.exit = ata_exit,
+	.core_reg = NULL,
+	.io_reg = NULL,
+};
+
+static struct platform_device mxc_wm8903_device = {
+	.name = "imx-3stack-wm8903",
+	.id = 0,
+};
+
+static struct mxc_audio_platform_data wm8903_data;
+
+static void __init mxc_init_wm8903(void)
+{
+	wm8903_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
+	clk_put(wm8903_data.ssi_clk[0]);
+
+	wm8903_data.ssi_clk[1] = clk_get(NULL, "ssi_clk.1");
+	clk_put(wm8903_data.ssi_clk[1]);
+
+	wm8903_data.ssi_num = 1;
+	wm8903_data.src_port = 2;
+	wm8903_data.ext_port = 3;
+
+	(void)platform_device_register(&mxc_wm8903_device);
+}
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+int headphone_det_status(void)
+{
+	return gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A26));
+}
+
+static struct mxc_audio_platform_data sgtl5000_data;
+
+static int mxc_sgtl5000_plat_init(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(&mxc_sgtl5000_device.dev, "GPO2");
+	if (IS_ERR(reg))
+		return -EINVAL;
+	sgtl5000_data.priv = reg;
+	return 0;
+}
+
+static int mxc_sgtl5000_plat_finit(void)
+{
+	struct regulator *reg;
+	reg = sgtl5000_data.priv;
+	if (reg) {
+		regulator_put(reg);
+		sgtl5000_data.priv = NULL;
+	}
+	return 0;
+}
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+	struct regulator *reg;
+	reg = sgtl5000_data.priv;
+
+	if (!reg)
+		return -EINVAL;
+	if (enable)
+		regulator_enable(reg);
+	else
+		regulator_disable(reg);
+	return 0;
+}
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ(MX51_PIN_EIM_A26),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12000000,
+	.init = mxc_sgtl5000_plat_init,
+	.finit = mxc_sgtl5000_plat_finit,
+};
+
+static void bt_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), 1);
+}
+
+static struct mxc_bt_platform_data mxc_bt_data = {
+	.bt_vdd = NULL,
+	.bt_vdd_parent = NULL,
+	.bt_vusb = "SW4",
+	.bt_vusb_parent = NULL,
+	.bt_reset = bt_reset,
+};
+
+static struct platform_device mxc_bt_device = {
+	.name = "mxc_bt",
+	.id = 0,
+};
+
+static void mxc_unifi_hardreset(int pin_level)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), pin_level & 0x01);
+}
+
+static struct mxc_unifi_platform_data unifi_data = {
+	.hardreset = mxc_unifi_hardreset,
+	.reg_vdd_vpa = "VSD",
+	.reg_1v5_dd = "VGEN1",
+	.host_id = 1,
+};
+
+struct mxc_unifi_platform_data *get_unifi_plat_data(void)
+{
+	return &unifi_data;
+}
+EXPORT_SYMBOL(get_unifi_plat_data);
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_set_cpu_type(MXC_CPU_MX51);
+
+	get_cpu_wp = mx51_3stack_get_cpu_wp;
+	set_num_cpu_wp = mx51_3stack_set_num_cpu_wp;
+}
+
+static struct mxc_gps_platform_data gps_data = {
+	.core_reg = "VIOHI",
+	.analog_reg = "SW4",
+};
+
+static struct platform_device mxc_gps_device = {
+	.name = "gps_ioctrl",
+	.id = -1,
+};
+
+int gpio_gps_access(int para)
+{
+	iomux_pin_name_t pin;
+	pin = (para & 0x1) ? MX51_PIN_EIM_CS2 : MX51_PIN_EIM_CRE;
+
+	if (para & 0x4) /* Read GPIO */
+		return gpio_get_value(IOMUX_TO_GPIO(pin));
+	else if (para & 0x2) /* Write GPIO */
+		gpio_set_value(IOMUX_TO_GPIO(pin), 1);
+	else
+		gpio_set_value(IOMUX_TO_GPIO(pin), 0);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_gps_access);
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	int err;
+
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+	mxc_ipu_data.csi_clk[0] = clk_get(NULL, "csi_mclk1");
+	mxc_ipu_data.csi_clk[1] = clk_get(NULL, "csi_mclk2");
+
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+
+	mxc_cpu_common_init();
+	mx51_3stack_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_hs_device, &mxci2c_hs_data);
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, &mxc_vpu_data);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mxcscc_device, NULL);
+	mxc_register_device(&mx51_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	mxc_register_device(&mxc_iim_device, NULL);
+	mxc_register_device(&mxc_pwm1_device, NULL);
+	mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+	mxc_register_device(&mxc_keypad_device, &keypad_plat_data);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0);
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxc_sim_device, &sim_data);
+	mxc_register_device(&pata_fsl_device, &ata_data);
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
+
+	mxc_expio_init();
+	if (debug_board_present)
+		mxc_register_device(&smsc_lan9217_device, &smsc911x_config);
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		lcd_data.reset = lcd_reset_to2;
+
+	mxc_register_device(&mxc_lcd_device, &lcd_data);
+	mxc_register_device(&lcd_wvga_device, &lcd_wvga_data);
+	mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+	mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+	mxc_register_device(&mxc_fb_devices[2], NULL);
+	mxc_register_device(&mxcbl_device, NULL);
+
+#if defined(CONFIG_MTD_NAND_IMX_NFC) || defined(CONFIG_MTD_NAND_IMX_NFC_MODULE)
+	mxc_register_device(&imx_nfc_device, &imx_nfc_platform_data);
+#else
+	mxc_register_device(&mxc_nandv2_mtd_device, &mxc_nand_data);
+#endif
+	mx51_3stack_init_mc13892();
+
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+	i2c_register_board_info(3, mxc_i2c_hs_board_info,
+				ARRAY_SIZE(mxc_i2c_hs_board_info));
+
+	mxc_init_wm8903();
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+	mxc_register_device(&mxc_bt_device, &mxc_bt_data);
+	mxc_register_device(&mxc_gps_device, &gps_data);
+	mxc_register_device(&mxc_v4l2_device, NULL);
+	mxc_register_device(&mxc_v4l2out_device, NULL);
+
+	mx5_usb_dr_init();
+	mx5_usbh1_init();
+
+	/* Setup Touchscreen interrupt */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5), "gpio1_5");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5));
+
+	err = mxc_request_iomux(MX51_PIN_EIM_D19, IOMUX_CONFIG_GPIO);
+	if (err)
+		printk(KERN_ERR "Error: bt reset request gpio failed!\n");
+	else {
+		gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), "eim_d19");
+		gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), 0);
+	}
+}
+
+static void __init mx51_3stack_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	/* Change the CPU voltages for TO2*/
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) <= 1) {
+		cpu_wp_auto[0].cpu_voltage = 1175000;
+		cpu_wp_auto[1].cpu_voltage = 1100000;
+		cpu_wp_auto[2].cpu_voltage = 1000000;
+	}
+
+	mx51_clocks_init(32768, 24000000, 22579200, 24576000);
+
+	uart_clk = clk_get(NULL, "uart_clk.0");
+	early_console_setup(UART1_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx51_3stack_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX51_3STACK data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX51_3DS, "Freescale MX51 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx51_3stack_gpio.c b/arch/arm/mach-mx5/mx51_3stack_gpio.c
new file mode 100644
index 0000000..b0fca77
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_3stack_gpio.c
@@ -0,0 +1,852 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+
+#include "iomux.h"
+#include "mx51_pins.h"
+
+/*!
+ * @file mach-mx5/mx51_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+#define ATA_PAD_CONFIG (PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH)
+
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+	/* CSI0 */
+	{
+	MX51_PIN_CSI1_D8, IOMUX_CONFIG_ALT3,
+	PAD_CTL_PKE_ENABLE,
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	INPUT_CTL_PATH1,
+	},
+	{
+	MX51_PIN_CSI1_D9, IOMUX_CONFIG_ALT3,
+	PAD_CTL_PKE_ENABLE,
+	},
+	{
+	 MX51_PIN_CSI1_D10, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D11, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D12, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D13, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D14, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D15, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D16, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D17, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D18, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D19, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_VSYNC, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX51_PIN_CSI1_HSYNC, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_SLOW | PAD_CTL_DRV_MEDIUM | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_VOT_HIGH),
+	 MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{			/* SPI1 */
+	 MX51_PIN_CSPI1_MISO, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_MOSI, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_RDY, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_SCLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_OWIRE_LINE, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE |
+		 PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+		 PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP2_DAT15, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX51_PIN_DI_GP2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_DI_GP3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL0, IOMUX_CONFIG_ALT0,
+	},
+	{
+	 MX51_PIN_KEY_COL1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL4, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL5, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0,
+	 },
+	{			/* AUD3_TXD */
+	 MX51_PIN_AUD3_BB_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_RXD */
+	 MX51_PIN_AUD3_BB_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_CLK */
+	 MX51_PIN_AUD3_BB_CK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_FS */
+	 MX51_PIN_AUD3_BB_FS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{
+	 MX51_PIN_EIM_D16, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_A27, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{
+	MX51_PIN_EIM_EB2, IOMUX_CONFIG_ALT1,
+	PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL | PAD_CTL_100K_PD,
+	},
+	{
+	 MX51_PIN_EIM_DTACK, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_EIM_CS2, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_CRE, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DI_GP4, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_DIN, IOMUX_CONFIG_GPIO,
+	 0,
+	 MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_RS, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_DIO, IOMUX_CONFIG_GPIO,
+	 },
+	{ /* TO2 */
+	MX51_PIN_DI1_D1_CS, IOMUX_CONFIG_ALT4,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_D0_CS, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN11, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN12, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN13, IOMUX_CONFIG_ALT1,
+	},
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	{
+	 MX51_PIN_DISP1_DAT0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT8, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT9, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT10, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT11, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT12, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT13, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT14, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT15, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT16, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT17, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT18, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT19, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT20, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT21, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT22, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT23, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+#endif
+	{
+	 MX51_PIN_I2C1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 0x1E4,
+	 },
+	{
+	 MX51_PIN_I2C1_DAT, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 0x1E4,
+	 },
+	{
+	 MX51_PIN_GPIO1_6, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX51_PIN_GPIO1_7, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_PULL |
+			 PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE |
+			 PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_GPIO1_2, IOMUX_CONFIG_ALT2 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+	  PAD_CTL_100K_PU | PAD_CTL_HYS_ENABLE),
+	 MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT, INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_GPIO1_3, IOMUX_CONFIG_ALT2 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+	  PAD_CTL_100K_PU | PAD_CTL_HYS_ENABLE),
+	 MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT, INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_CLK */
+	 MX51_PIN_USBH1_CLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_DIR */
+	 MX51_PIN_USBH1_DIR, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_NXT */
+	 MX51_PIN_USBH1_NXT, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_DATA0 */
+	 MX51_PIN_USBH1_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA1 */
+	 MX51_PIN_USBH1_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA2 */
+	 MX51_PIN_USBH1_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA3 */
+	 MX51_PIN_USBH1_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA4 */
+	 MX51_PIN_USBH1_DATA4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA5 */
+	 MX51_PIN_USBH1_DATA5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA6 */
+	 MX51_PIN_USBH1_DATA6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA7 */
+	 MX51_PIN_USBH1_DATA7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	 {			/* USB1_OC */
+	 MX51_PIN_GPIO1_9, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_SRE_SLOW | PAD_CTL_DRV_LOW | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USB1_PWR */
+	 MX51_PIN_GPIO1_8, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PKE_NONE | PAD_CTL_HYS_ENABLE),
+	 },
+	{
+	 MX51_PIN_SD1_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_GPIO1_0, IOMUX_CONFIG_GPIO | IOMUX_CONFIG_SION,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_GPIO1_1, IOMUX_CONFIG_GPIO | IOMUX_CONFIG_SION,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_SD2_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART1_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{
+	 MX51_PIN_UART1_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART1_RTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH),
+	 MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{
+	 MX51_PIN_UART1_CTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH),
+	 },
+	{
+	 MX51_PIN_UART2_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH2,
+	 },
+	{
+	 MX51_PIN_UART2_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_D26, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_EIM_D25, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART3_RXD, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH4,
+	 },
+	{
+	 MX51_PIN_UART3_TXD, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_D27, IOMUX_CONFIG_ALT3,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_EIM_D24, IOMUX_CONFIG_ALT3,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata ata_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_ALE, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RE_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_WE_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CLE, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RB0, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_WP_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	/* TO 2.0 */
+	{
+	 MX51_PIN_GPIO_NAND, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	/* TO 1.0 */
+	{
+	 MX51_PIN_NANDF_RB5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RB1, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D0, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D1, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D2, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D3, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D4, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D6, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D7, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D8, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D9, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D10, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D11, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D12, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D13, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D14, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D15, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata nand_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_CS0, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT0,
+	 },
+	/* TO2 */
+	{
+	 MX51_PIN_GPIO_NAND, IOMUX_CONFIG_ALT0,
+	 },
+	/* TO1 */
+	{
+	 MX51_PIN_NANDF_RB5, IOMUX_CONFIG_ALT0,
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata sim_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_100K_PD |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+};
+
+static int __initdata enable_ata = { 0 };
+static int __init ata_setup(char *__unused)
+{
+	enable_ata = 1;
+	return 1;
+}
+
+__setup("ata", ata_setup);
+
+static int __initdata enable_sim = { 0 };
+static int __init sim_setup(char *__unused)
+{
+	enable_sim = 1;
+	return 1;
+}
+
+__setup("sim", sim_setup);
+
+void __init mx51_3stack_io_init(void)
+{
+	int i, num;
+	struct mxc_iomux_pin_cfg *pin_ptr;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					  mxc_iomux_pins[i].in_mode);
+	}
+
+	if (enable_ata) {
+		pin_ptr = ata_iomux_pins;
+		num = ARRAY_SIZE(ata_iomux_pins);
+	} else if (enable_sim) {
+		pin_ptr = sim_iomux_pins;
+		num = ARRAY_SIZE(sim_iomux_pins);
+	} else {
+		pin_ptr = nand_iomux_pins;
+		num = ARRAY_SIZE(nand_iomux_pins);
+	}
+
+	for (i = 0; i < num; i++) {
+		mxc_request_iomux(pin_ptr[i].pin, pin_ptr[i].mux_mode);
+		if (pin_ptr[i].pad_cfg)
+			mxc_iomux_set_pad(pin_ptr[i].pin, pin_ptr[i].pad_cfg);
+		if (pin_ptr[i].in_select)
+			mxc_iomux_set_input(pin_ptr[i].in_select,
+					pin_ptr[i].in_mode);
+	}
+
+	/* TO3 doesn't need pad to drive CSI_DATA_EN[0] high */
+	if (cpu_is_mx51_rev(CHIP_REV_3_0) > 0)
+		mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT0);
+
+	/* Camera low power */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), "csi1_d8");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), "eim_eb2");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), 0);    /* TO1 */
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), 0);      /* TO1 */
+
+	/* Camera reset */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), "csi1_d9");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), 1);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), "di1_d1_cs");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0), "gpio1_0");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0));	/* SD1 CD */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1), "gpio1_1");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1));	/* SD1 WP */
+
+	/* EIM_D16 */
+	/* osc_en is shared by SPDIF */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), "eim_d16");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), 1);
+
+	/* LCD related gpio */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), "di1_d1_cs");
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), "dispb2_ser_di0");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 0);
+
+	/* GPS related gpio */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), "eim_cs2");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), "eim_cre");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 1);
+}
diff --git a/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
new file mode 100644
index 0000000..84c33ec
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
@@ -0,0 +1,354 @@
+/*
+ * mx51-3stack-pmic-mc13892.c  --  i.MX51 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+#include "mx51_pins.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define STANDBYSECINV_LSH 11
+#define STANDBYSECINV_WID 1
+
+/* Coin cell charger enable */
+#define COINCHEN_LSH	23
+#define COINCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+/*!
+ * the event handler for power on event
+ */
+static void power_on_evt_handler(void)
+{
+	pr_info("pwr on event1 is received \n");
+}
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value;
+	pmic_event_callback_t power_key_event;
+	int register_mask;
+
+	printk("Initializing regulators for 3-stack.\n");
+	if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+		sw2_init.constraints.state_mem.uV = 1100000;
+	else if (mxc_cpu_is_rev(CHIP_REV_2_0) == 1) {
+		sw2_init.constraints.state_mem.uV = 1250000;
+		sw1_init.constraints.state_mem.uV = 1000000;
+	}
+
+	/* subscribe PWRON1 event to enable ON_OFF key */
+	power_key_event.param = NULL;
+	power_key_event.func = (void *)power_on_evt_handler;
+	pmic_event_subscribe(EVENT_PWRONI, power_key_event);
+
+	/* Bit 4 DRM: keep VSRTC and CLK32KMCU on for all states */
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+	/* Set the STANDBYSECINV bit, so that STANDBY pin is
+	 * interpreted as active low.
+	 */
+	value = BITFVAL(STANDBYSECINV, 1);
+	register_mask = BITFMASK(STANDBYSECINV);
+	pmic_write_reg(REG_POWER_CTL2, value, register_mask);
+
+	/* Enable coin cell charger */
+	value = BITFVAL(COINCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(COINCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx51_3stack_init_mc13892(void)
+{
+	return i2c_register_board_info(1, &mc13892_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx51_babbage.c b/arch/arm/mach-mx5/mx51_babbage.c
new file mode 100644
index 0000000..a78cc5b
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_babbage.c
@@ -0,0 +1,1276 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/keypad.h>
+#include <asm/mach/flash.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/mxc_edid.h>
+#include <mach/iomux-mx51.h>
+
+#include "devices.h"
+#include "crm_regs.h"
+#include "usb.h"
+
+/*!
+ * @file mach-mx51/mx51_babbage.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX51
+ */
+
+#define BABBAGE_SD1_CD			(0*32 + 0)	/* GPIO_1_0 */
+#define BABBAGE_SD1_WP		(0*32 + 1)	/* GPIO_1_1 */
+#define BABBAGE_SD2_CD_2_0		(0*32 + 4)	/* GPIO_1_4 */
+#define BABBAGE_SD2_WP		(0*32 + 5)	/* GPIO_1_5 */
+#define BABBAGE_SD2_CD_2_5		(0*32 + 6)	/* GPIO_1_6 */
+#define BABBAGE_PMIC_INT		(0*32 + 8)	/* GPIO_1_8 */
+
+#define BABBAGE_USB_CLK_EN_B		(1*32 + 1)	/* GPIO_2_1 */
+#define BABBAGE_OSC_EN_B		(1*32 + 2)	/* GPIO_2_2 */
+#define BABBAGE_PHY_RESET		(1*32 + 5)	/* GPIO_2_5 */
+#define BABBAGE_CAM_RESET		(1*32 + 7)	/* GPIO_2_7 */
+#define BABBAGE_FM_PWR		(1*32 + 12)	/* GPIO_2_12 */
+#define BABBAGE_VGA_RESET		(1*32 + 13)	/* GPIO_2_13 */
+#define BABBAGE_FEC_PHY_RESET		(1*32 + 14)	/* GPIO_2_14 */
+#define BABBAGE_FM_RESET		(1*32 + 15)	/* GPIO_2_15 */
+#define BABBAGE_AUDAMP_STBY		(1*32 + 17)	/* GPIO_2_17 */
+#define BABBAGE_POWER_KEY		(1*32 + 21)	/* GPIO_2_21 */
+
+#define BABBAGE_26M_OSC_EN		(2*32 + 1)	/* GPIO_3_1 */
+#define BABBAGE_LVDS_POWER_DOWN	(2*32 + 3)	/* GPIO_3_3 */
+#define BABBAGE_DISP_BRIGHTNESS_CTL	(2*32 + 4)	/* GPIO_3_4 */
+#define BABBAGE_DVI_RESET		(2*32 + 5)	/* GPIO_3_5 */
+#define BABBAGE_DVI_POWER		(2*32 + 6)	/* GPIO_3_6 */
+#define BABBAGE_HEADPHONE_DET	(2*32 + 26)	/* GPIO_3_26 */
+#define BABBAGE_DVI_DET		(2*32 + 28)	/* GPIO_3_28 */
+
+#define BABBAGE_LCD_3V3_ON		(3*32 + 9)	/* GPIO_4_9 */
+#define BABBAGE_LCD_5V_ON		(3*32 + 10)	/* GPIO_4_10 */
+#define BABBAGE_CAM_LOW_POWER	(3*32 + 10)	/* GPIO_4_12 */
+#define BABBAGE_DVI_I2C_EN		(3*32 + 14)	/* GPIO_4_14 */
+#define BABBAGE_CSP1_SS0_GPIO		(3*32 + 24)	/* GPIO_4_24 */
+#define BABBAGE_AUDIO_CLK_EN		(3*32 + 26)	/* GPIO_4_26 */
+
+extern int __init mx51_babbage_init_mc13892(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+
+static struct pad_desc mx51babbage_pads[] = {
+	/* UART1 */
+	MX51_PAD_UART1_RXD__UART1_RXD,
+	MX51_PAD_UART1_TXD__UART1_TXD,
+	MX51_PAD_UART1_RTS__UART1_RTS,
+	MX51_PAD_UART1_CTS__UART1_CTS,
+
+	/* USB HOST1 */
+	MX51_PAD_USBH1_STP__USBH1_STP,
+	MX51_PAD_USBH1_CLK__USBH1_CLK,
+	MX51_PAD_USBH1_DIR__USBH1_DIR,
+	MX51_PAD_USBH1_NXT__USBH1_NXT,
+	MX51_PAD_USBH1_DATA0__USBH1_DATA0,
+	MX51_PAD_USBH1_DATA1__USBH1_DATA1,
+	MX51_PAD_USBH1_DATA2__USBH1_DATA2,
+	MX51_PAD_USBH1_DATA3__USBH1_DATA3,
+	MX51_PAD_USBH1_DATA4__USBH1_DATA4,
+	MX51_PAD_USBH1_DATA5__USBH1_DATA5,
+	MX51_PAD_USBH1_DATA6__USBH1_DATA6,
+	MX51_PAD_USBH1_DATA7__USBH1_DATA7,
+
+	MX51_PAD_GPIO_1_0__GPIO_1_0,
+	MX51_PAD_GPIO_1_1__GPIO_1_1,
+	MX51_PAD_GPIO_1_4__GPIO_1_4,
+	MX51_PAD_GPIO_1_5__GPIO_1_5,
+	MX51_PAD_GPIO_1_6__GPIO_1_6,
+	MX51_PAD_GPIO_1_8__GPIO_1_8,
+	MX51_PAD_UART3_RXD__GPIO_1_22,
+
+	MX51_PAD_EIM_D17__GPIO_2_1,
+	MX51_PAD_EIM_D18__GPIO_2_2,
+	MX51_PAD_EIM_D21__GPIO_2_5,
+	MX51_PAD_EIM_D23__GPIO_2_7,
+	MX51_PAD_EIM_A16__GPIO_2_10,
+	MX51_PAD_EIM_A17__GPIO_2_11,
+	MX51_PAD_EIM_A18__GPIO_2_12,
+	MX51_PAD_EIM_A19__GPIO_2_13,
+	MX51_PAD_EIM_A20__GPIO_2_14,
+	MX51_PAD_EIM_A21__GPIO_2_15,
+	MX51_PAD_EIM_A22__GPIO_2_16,
+	MX51_PAD_EIM_A23__GPIO_2_17,
+	MX51_PAD_EIM_A27__GPIO_2_21,
+	MX51_PAD_EIM_DTACK__GPIO_2_31,
+
+	MX51_PAD_EIM_LBA__GPIO_3_1,
+	MX51_PAD_DI1_D0_CS__GPIO_3_3,
+	MX51_PAD_DISPB2_SER_DIN__GPIO_3_5,
+	MX51_PAD_DISPB2_SER_DIO__GPIO_3_6,
+	MX51_PAD_NANDF_CS0__GPIO_3_16,
+	MX51_PAD_NANDF_CS1__GPIO_3_17,
+	MX51_PAD_NANDF_D14__GPIO_3_26,
+	MX51_PAD_NANDF_D12__GPIO_3_28,
+
+	MX51_PAD_CSI2_D12__GPIO_4_9,
+	MX51_PAD_CSI2_D13__GPIO_4_10,
+	MX51_PAD_CSI2_D19__GPIO_4_12,
+	MX51_PAD_CSI2_HSYNC__GPIO_4_14,
+	MX51_PAD_CSPI1_RDY__GPIO_4_26,
+
+	MX51_PAD_EIM_EB2__FEC_MDIO,
+	MX51_PAD_EIM_EB3__FEC_RDAT1,
+	MX51_PAD_EIM_CS2__FEC_RDAT2,
+	MX51_PAD_EIM_CS3__FEC_RDAT3,
+	MX51_PAD_EIM_CS4__FEC_RX_ER,
+	MX51_PAD_EIM_CS5__FEC_CRS,
+	MX51_PAD_NANDF_RB2__FEC_COL,
+	MX51_PAD_NANDF_RB3__FEC_RXCLK,
+	MX51_PAD_NANDF_RB6__FEC_RDAT0,
+	MX51_PAD_NANDF_RB7__FEC_TDAT0,
+	MX51_PAD_NANDF_CS2__FEC_TX_ER,
+	MX51_PAD_NANDF_CS3__FEC_MDC,
+	MX51_PAD_NANDF_CS4__FEC_TDAT1,
+	MX51_PAD_NANDF_CS5__FEC_TDAT2,
+	MX51_PAD_NANDF_CS6__FEC_TDAT3,
+	MX51_PAD_NANDF_CS7__FEC_TX_EN,
+	MX51_PAD_NANDF_RDY_INT__FEC_TX_CLK,
+
+	MX51_PAD_GPIO_NAND__PATA_INTRQ,
+
+	MX51_PAD_DI_GP4__DI2_PIN15,
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	MX51_PAD_DISP1_DAT22__DISP2_DAT16,
+	MX51_PAD_DISP1_DAT23__DISP2_DAT17,
+
+	MX51_PAD_DI1_D1_CS__GPIO_3_4,
+#endif
+	MX51_PAD_I2C1_CLK__HSI2C_CLK,
+	MX51_PAD_I2C1_DAT__HSI2C_DAT,
+	MX51_PAD_EIM_D16__I2C1_SDA,
+	MX51_PAD_EIM_D19__I2C1_SCL,
+
+	MX51_PAD_GPIO_1_2__PWM_PWMO,
+
+	MX51_PAD_GPIO_1_3__I2C2_SDA,
+	MX51_PAD_KEY_COL4__I2C2_SCL,
+
+	MX51_PAD_SD1_CMD__SD1_CMD,
+	MX51_PAD_SD1_CLK__SD1_CLK,
+	MX51_PAD_SD1_DATA0__SD1_DATA0,
+	MX51_PAD_SD1_DATA1__SD1_DATA1,
+	MX51_PAD_SD1_DATA2__SD1_DATA2,
+	MX51_PAD_SD1_DATA3__SD1_DATA3,
+
+	MX51_PAD_SD2_CMD__SD2_CMD,
+	MX51_PAD_SD2_CLK__SD2_CLK,
+	MX51_PAD_SD2_DATA0__SD2_DATA0,
+	MX51_PAD_SD2_DATA1__SD2_DATA1,
+	MX51_PAD_SD2_DATA2__SD2_DATA2,
+	MX51_PAD_SD2_DATA3__SD2_DATA3,
+
+	MX51_PAD_AUD3_BB_TXD__AUD3_BB_TXD,
+	MX51_PAD_AUD3_BB_RXD__AUD3_BB_RXD,
+	MX51_PAD_AUD3_BB_CK__AUD3_BB_CK,
+	MX51_PAD_AUD3_BB_FS__AUD3_BB_FS,
+
+	MX51_PAD_CSPI1_SS1__CSPI1_SS1,
+
+	MX51_PAD_DI_GP3__CSI1_DATA_EN,
+	MX51_PAD_CSI1_D10__CSI1_D10,
+	MX51_PAD_CSI1_D11__CSI1_D11,
+	MX51_PAD_CSI1_D12__CSI1_D12,
+	MX51_PAD_CSI1_D13__CSI1_D13,
+	MX51_PAD_CSI1_D14__CSI1_D14,
+	MX51_PAD_CSI1_D15__CSI1_D15,
+	MX51_PAD_CSI1_D16__CSI1_D16,
+	MX51_PAD_CSI1_D17__CSI1_D17,
+	MX51_PAD_CSI1_D18__CSI1_D18,
+	MX51_PAD_CSI1_D19__CSI1_D19,
+	MX51_PAD_CSI1_VSYNC__CSI1_VSYNC,
+	MX51_PAD_CSI1_HSYNC__CSI1_HSYNC,
+
+	MX51_PAD_OWIRE_LINE__SPDIF_OUT1,
+};
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* NTSC TV output */
+	 "TV-NTSC", 60, 720, 480, 74074,
+	 122, 15,
+	 18, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED,
+	 0,},
+	{
+	 /* PAL TV output */
+	 "TV-PAL", 50, 720, 576, 74074,
+	 132, 11,
+	 22, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED | FB_VMODE_ODD_FLD_FIRST,
+	 0,},
+	{
+	 /* 720p60 TV output */
+	 "720P60", 60, 1280, 720, 13468,
+	 260, 109,
+	 25, 4,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT |
+			FB_SYNC_EXT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	 /*MITSUBISHI LVDS panel */
+	 "XGA", 60, 1024, 768, 15385,
+	 220, 40,
+	 21, 7,
+	 60, 10,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	 /* 800x480 @ 57 Hz , pixel clk @ 27MHz */
+	 "CLAA-WVGA", 57, 800, 480, 37037, 40, 60, 10, 10, 20, 10,
+	 FB_SYNC_CLK_LAT_FALL,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+struct cpu_wp *mx51_babbage_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+void mx51_babbage_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static u16 keymapping[16] = {
+	KEY_UP, KEY_DOWN, KEY_MENU, KEY_BACK,
+	KEY_RIGHT, KEY_LEFT, KEY_SELECT, KEY_ENTER,
+	KEY_F1, KEY_F3, KEY_1, KEY_3,
+	KEY_F2, KEY_F4, KEY_2, KEY_4,
+};
+
+static struct keypad_data keypad_plat_data = {
+	.rowmax = 4,
+	.colmax = 4,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 0,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+extern void mx5_ipu_reset(void);
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 2,
+	.reset = mx5_ipu_reset,
+};
+
+extern void mx5_vpu_reset(void);
+static struct mxc_vpu_platform_data mxc_vpu_data = {
+	.reset = mx5_vpu_reset,
+};
+
+/* workaround for ecspi chipselect pin may not keep correct level when idle */
+static void mx51_babbage_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			{
+			struct pad_desc cspi1_ss0 = MX51_PAD_CSPI1_SS0__CSPI1_SS0;
+
+			mxc_iomux_v3_setup_pad(&cspi1_ss0);
+			break;
+			}
+		case 0x2:
+			{
+			struct pad_desc cspi1_ss0_gpio = MX51_PAD_CSPI1_SS0__GPIO_4_24;
+
+			mxc_iomux_v3_setup_pad(&cspi1_ss0_gpio);
+			gpio_request(BABBAGE_CSP1_SS0_GPIO, "cspi1-gpio");
+			gpio_direction_output(BABBAGE_CSP1_SS0_GPIO, 0);
+			gpio_set_value(BABBAGE_CSP1_SS0_GPIO, 1 & (~status));
+			break;
+			}
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static void mx51_babbage_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			break;
+		case 0x2:
+			gpio_free(BABBAGE_CSP1_SS0_GPIO);
+			break;
+
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx51_babbage_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx51_babbage_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_i2c_platform_data mxci2c_hs_data = {
+	.i2c_clk = 400000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+};
+
+static struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+static struct mxc_dvfsper_data dvfs_per_data = {
+	.reg_id = "SW2",
+	.clk_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.gpc_adu = 0x0,
+	.vai_mask = MXC_DVFSPMCR0_FSVAI_MASK,
+	.vai_offset = MXC_DVFSPMCR0_FSVAI_OFFSET,
+	.dvfs_enable_bit = MXC_DVFSPMCR0_DVFEN,
+	.irq_mask = MXC_DVFSPMCR0_FSVAIM,
+	.div3_offset = 0,
+	.div3_mask = 0x7,
+	.div3_div = 2,
+	.lp_high = 1200000,
+	.lp_low = 1200000,
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* spdif_ext_clk source for 44.1KHz */
+	.spdif_clk_48000 = 7,	/* audio osc source */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+};
+
+static struct resource mxcfb_resources[] = {
+	[0] = {
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB24,
+	 .mode_str = "1024x768M-16@60",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB565,
+	 .mode_str = "CLAA-WVGA",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+};
+
+extern int primary_di;
+static int __init mxc_init_fb(void)
+{
+	if (!machine_is_mx51_babbage())
+		return 0;
+
+	/* DI0-LVDS */
+	gpio_set_value(BABBAGE_LVDS_POWER_DOWN, 0);
+	msleep(1);
+	gpio_set_value(BABBAGE_LVDS_POWER_DOWN, 1);
+	gpio_set_value(BABBAGE_LCD_3V3_ON, 1);
+	gpio_set_value(BABBAGE_LCD_5V_ON, 1);
+
+	/* DVI Detect */
+	gpio_request(BABBAGE_DVI_DET, "dvi-detect");
+	gpio_direction_input(BABBAGE_DVI_DET);
+	/* DVI Reset - Assert for i2c disabled mode */
+	gpio_request(BABBAGE_DVI_RESET, "dvi-reset");
+	gpio_direction_output(BABBAGE_DVI_RESET, 0);
+	/* DVI Power-down */
+	gpio_request(BABBAGE_DVI_POWER, "dvi-power");
+	gpio_direction_output(BABBAGE_DVI_POWER, 1);
+
+	/* WVGA Reset */
+	gpio_set_value(BABBAGE_DISP_BRIGHTNESS_CTL, 1);
+
+	if (primary_di) {
+		printk(KERN_INFO "DI1 is primary\n");
+
+		/* DI1 -> DP-BG channel: */
+		mxc_fb_devices[1].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[1].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+
+		/* DI0 -> DC channel: */
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+	} else {
+		printk(KERN_INFO "DI0 is primary\n");
+
+		/* DI0 -> DP-BG channel: */
+		mxc_fb_devices[0].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[0].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+
+		/* DI1 -> DC channel: */
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+	}
+
+	/*
+	 * DI0/1 DP-FG channel:
+	 */
+	mxc_register_device(&mxc_fb_devices[2], NULL);
+
+	return 0;
+}
+device_initcall(mxc_init_fb);
+
+static int handle_edid(int *pixclk)
+{
+#if 0
+	int err = 0;
+	int dvi = 0;
+	int fb0 = 0;
+	int fb1 = 1;
+	struct fb_var_screeninfo screeninfo;
+	struct i2c_adapter *adp;
+
+	memset(&screeninfo, 0, sizeof(screeninfo));
+
+	adp = i2c_get_adapter(1);
+
+	if (cpu_is_mx51_rev(CHIP_REV_3_0) > 0) {
+		gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI2_HSYNC), 1);
+		msleep(1);
+	}
+	err = read_edid(adp, &screeninfo, &dvi);
+	if (cpu_is_mx51_rev(CHIP_REV_3_0) > 0)
+		gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI2_HSYNC), 0);
+
+	if (!err) {
+		printk(KERN_INFO " EDID read\n");
+		if (!dvi) {
+			enable_vga = 1;
+			fb0 = 1; /* fb0 will be VGA */
+			fb1 = 0; /* fb1 will be DVI or TV */
+		}
+
+		/* Handle TV modes */
+		/* This logic is fairly complex yet still doesn't handle all
+		   possibilities.  Once a customer knows the platform
+		   configuration, this should be simplified to what is desired.
+		 */
+		if (screeninfo.xres == 1920 && screeninfo.yres != 1200) {
+			/* MX51 can't handle clock speeds for anything larger.*/
+			if (!enable_tv)
+				enable_tv = 1;
+			if (enable_vga || enable_wvga || enable_tv == 2)
+				enable_tv = 2;
+			fb_data[0].mode = &(video_modes[0]);
+			if (!enable_wvga)
+				fb_data[1].mode_str = "800x600M-16@60";
+		} else if (screeninfo.xres > 1280 && screeninfo.yres > 1024) {
+			if (!enable_wvga) {
+				fb_data[fb0].mode_str = "1280x1024M-16@60";
+				fb_data[fb1].mode_str = NULL;
+			} else {
+				/* WVGA is preset so the DVI can't be > this. */
+				fb_data[0].mode_str = "1024x768M-16@60";
+			}
+		} else if (screeninfo.xres > 0 && screeninfo.yres > 0) {
+			if (!enable_wvga) {
+				fb_data[fb0].mode =
+					kzalloc(sizeof(struct fb_videomode),
+							GFP_KERNEL);
+				fb_var_to_videomode(fb_data[fb0].mode,
+						    &screeninfo);
+				fb_data[fb0].mode_str = NULL;
+				if (screeninfo.xres >= 1280 &&
+						screeninfo.yres > 720)
+					fb_data[fb1].mode_str = NULL;
+				else if (screeninfo.xres > 1024 &&
+						screeninfo.yres > 768)
+					fb_data[fb1].mode_str =
+						"800x600M-16@60";
+				else if (screeninfo.xres > 800 &&
+						screeninfo.yres > 600)
+					fb_data[fb1].mode_str =
+						"1024x768M-16@60";
+			} else {
+				/* A WVGA panel was specified and an EDID was
+				   read thus there is a DVI monitor attached. */
+				if (screeninfo.xres >= 1024)
+					fb_data[0].mode_str = "1024x768M-16@60";
+				else if (screeninfo.xres >= 800)
+					fb_data[0].mode_str = "800x600M-16@60";
+				else
+					fb_data[0].mode_str = "640x480M-16@60";
+			}
+		}
+	}
+#endif
+	return 0;
+}
+
+static void dvi_reset(void)
+{
+	gpio_direction_output(BABBAGE_DVI_RESET, 0);
+	gpio_set_value(BABBAGE_DVI_RESET, 0);
+	msleep(50);
+
+	/* do reset */
+	gpio_set_value(BABBAGE_DVI_RESET, 1);
+	msleep(20);		/* tRES >= 50us */
+
+	gpio_set_value(BABBAGE_DVI_RESET, 0);
+}
+
+static struct mxc_lcd_platform_data dvi_data = {
+	.core_reg = "VGEN1",
+	.io_reg = "VGEN3",
+	.reset = dvi_reset,
+};
+
+static void vga_reset(void)
+{
+
+	gpio_set_value(BABBAGE_VGA_RESET, 0);
+	msleep(50);
+	/* do reset */
+	gpio_set_value(BABBAGE_VGA_RESET, 1);
+	msleep(10);		/* tRES >= 50us */
+	gpio_set_value(BABBAGE_VGA_RESET, 0);
+}
+
+static struct mxc_lcd_platform_data vga_data = {
+	.core_reg = "VCAM",
+	.io_reg = "VGEN3",
+	.analog_reg = "VAUDIO",
+	.reset = vga_reset,
+};
+
+static void si4702_reset(void)
+{
+	return;
+
+	gpio_set_value(BABBAGE_FM_RESET, 0);
+	msleep(100);
+	gpio_set_value(BABBAGE_FM_RESET, 1);
+	msleep(100);
+}
+
+static void si4702_clock_ctl(int flag)
+{
+	gpio_set_value(BABBAGE_FM_PWR, flag);
+	msleep(100);
+}
+
+static void si4702_gpio_get(void)
+{
+	gpio_request(BABBAGE_FM_PWR, "fm-power");
+	gpio_direction_output(BABBAGE_FM_PWR, 0);
+}
+
+static void si4702_gpio_put(void)
+{
+}
+
+static struct mxc_fm_platform_data si4702_data = {
+	.reg_vio = "SW4",
+	.reg_vdd = "VIOHI",
+	.gpio_get = si4702_gpio_get,
+	.gpio_put = si4702_gpio_put,
+	.reset = si4702_reset,
+	.clock_ctl = si4702_clock_ctl,
+};
+
+static struct mxc_camera_platform_data camera_data = {
+	.io_regulator = "SW4",
+	.analog_regulator = "VIOHI",
+	.mclk = 24000000,
+	.csi = 0,
+};
+
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+	{
+	.type = "ov3640",
+	.addr = 0x3C,
+	.platform_data = (void *)&camera_data,
+	},
+};
+
+static struct mxc_lightsensor_platform_data ls_data = {
+	.vdd_reg = "VIOHI",
+	.rext = 100,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "isl29003",
+	 .addr = 0x44,
+	 .platform_data = &ls_data,
+	 },
+};
+
+static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
+	{
+	 .type = "sii9022",
+	 .addr = 0x39,
+	 .platform_data = &dvi_data,
+	 },
+	{
+	 .type = "ch7026",
+	 .addr = 0x75,
+	 .platform_data = &vga_data,
+	 },
+	{
+	 .type = "si4702",
+	 .addr = 0x10,
+	 .platform_data = (void *)&si4702_data,
+	 },
+};
+
+static struct mtd_partition mxc_spi_nor_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 0x00040000,},
+	{
+	 .name = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,},
+
+};
+
+static struct mtd_partition mxc_dataflash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 0x000100000,},
+	{
+	 .name = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,},
+};
+
+static struct flash_platform_data mxc_spi_flash_data[] = {
+	{
+	 .name = "mxc_spi_nor",
+	 .parts = mxc_spi_nor_partitions,
+	 .nr_parts = ARRAY_SIZE(mxc_spi_nor_partitions),
+	 .type = "sst25vf016b",},
+	{
+	 .name = "mxc_dataflash",
+	 .parts = mxc_dataflash_partitions,
+	 .nr_parts = ARRAY_SIZE(mxc_dataflash_partitions),
+	 .type = "at45db321d",}
+};
+
+static struct spi_board_info mxc_spi_nor_device[] __initdata = {
+	{
+	 .modalias = "mxc_spi_nor",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 1,
+	 .chip_select = 1,
+	 .platform_data = &mxc_spi_flash_data[0],
+	},
+};
+
+static struct spi_board_info mxc_dataflash_device[] __initdata = {
+	{
+	 .modalias = "mxc_dataflash",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 1,
+	 .chip_select = 1,
+	 .platform_data = &mxc_spi_flash_data[1],},
+};
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(BABBAGE_SD1_WP);
+	else
+		rc = gpio_get_value(BABBAGE_SD2_WP);
+
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(BABBAGE_SD1_CD);
+		return ret;
+	} else {		/* config the det pin for SDHC2 */
+		if (board_is_rev(BOARD_REV_2))
+			/* BB2.5 */
+			ret = gpio_get_value(BABBAGE_SD2_CD_2_5);
+		else
+			/* BB2.0 */
+			ret = gpio_get_value(BABBAGE_SD2_CD_2_0);
+		return ret;
+	}
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+	    MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 52000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+	    MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+	gpio_set_value(BABBAGE_AUDAMP_STBY, enable ? 1 : 0);
+	return 0;
+}
+
+static int headphone_det_status(void)
+{
+	return (gpio_get_value(BABBAGE_HEADPHONE_DET) == 0);
+}
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ_V3(BABBAGE_HEADPHONE_DET),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12288000,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+static int __initdata enable_w1 = { 0 };
+static int __init w1_setup(char *__unused)
+{
+	enable_w1 = 1;
+	return cpu_is_mx51();
+}
+
+__setup("w1", w1_setup);
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	char *str;
+	struct tag *t;
+	struct tag *mem_tag = 0;
+	int total_mem = SZ_512M;
+	int left_mem = 0;
+	int gpu_mem = SZ_64M;
+	int fb_mem = SZ_32M;
+
+	mxc_set_cpu_type(MXC_CPU_MX51);
+
+	get_cpu_wp = mx51_babbage_get_cpu_wp;
+	set_num_cpu_wp = mx51_babbage_set_num_cpu_wp;
+
+	for_each_tag(mem_tag, tags) {
+		if (mem_tag->hdr.tag == ATAG_MEM) {
+			total_mem = mem_tag->u.mem.size;
+			left_mem = total_mem - gpu_mem - fb_mem;
+			break;
+		}
+	}
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag == ATAG_CMDLINE) {
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "mem=");
+			if (str != NULL) {
+				str += 4;
+				left_mem = memparse(str, &str);
+				if (left_mem == 0 || left_mem > total_mem)
+					left_mem = total_mem - gpu_mem - fb_mem;
+			}
+
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "gpu_memory=");
+			if (str != NULL) {
+				str += 11;
+				gpu_mem = memparse(str, &str);
+			}
+
+			break;
+		}
+	}
+
+	if (mem_tag) {
+		fb_mem = total_mem - left_mem - gpu_mem;
+		if (fb_mem < 0) {
+			gpu_mem = total_mem - left_mem;
+			fb_mem = 0;
+		}
+		mem_tag->u.mem.size = left_mem;
+
+		/*reserve memory for gpu*/
+		gpu_device.resource[5].start =
+				mem_tag->u.mem.start + left_mem;
+		gpu_device.resource[5].end =
+				gpu_device.resource[5].start + gpu_mem - 1;
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+		if (fb_mem) {
+			mxcfb_resources[0].start =
+				gpu_device.resource[5].end + 1;
+			mxcfb_resources[0].end =
+				mxcfb_resources[0].start + fb_mem - 1;
+		} else {
+			mxcfb_resources[0].start = 0;
+			mxcfb_resources[0].end = 0;
+		}
+#endif
+	}
+}
+
+#define PWGT1SPIEN (1<<15)
+#define PWGT2SPIEN (1<<16)
+#define USEROFFSPI (1<<3)
+
+static void mxc_power_off(void)
+{
+	/* We can do power down one of two ways:
+	   Set the power gating
+	   Set USEROFFSPI */
+
+	/* Set the power gate bits to power down */
+	pmic_write_reg(REG_POWER_MISC, (PWGT1SPIEN|PWGT2SPIEN),
+		(PWGT1SPIEN|PWGT2SPIEN));
+}
+
+/*!
+ * Power Key interrupt handler.
+ */
+static irqreturn_t power_key_int(int irq, void *dev_id)
+{
+	pr_info(KERN_INFO "PWR key pressed\n");
+	return 0;
+}
+
+/*!
+ * Power Key initialization.
+ */
+static int __init mxc_init_power_key(void)
+{
+	/* Set power key as wakeup resource */
+	int irq, ret;
+	irq = IOMUX_TO_IRQ_V3(BABBAGE_POWER_KEY);
+	set_irq_type(irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(irq, power_key_int, 0, "power_key", 0);
+	if (ret)
+		pr_info("register on-off key interrupt failed\n");
+	else
+		enable_irq_wake(irq);
+	return ret;
+}
+late_initcall(mxc_init_power_key);
+
+static void __init mx51_babbage_io_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx51babbage_pads,
+					ARRAY_SIZE(mx51babbage_pads));
+
+	gpio_request(BABBAGE_PMIC_INT, "pmic-int");
+	gpio_request(BABBAGE_SD1_CD, "sdhc1-detect");
+	gpio_request(BABBAGE_SD1_WP, "sdhc1-wp");
+
+	gpio_direction_input(BABBAGE_PMIC_INT);
+	gpio_direction_input(BABBAGE_SD1_CD);
+	gpio_direction_input(BABBAGE_SD1_WP);
+
+	if (board_is_rev(BOARD_REV_2)) {
+		/* SD2 CD for BB2.5 */
+		gpio_request(BABBAGE_SD2_CD_2_5, "sdhc2-detect");
+		gpio_direction_input(BABBAGE_SD2_CD_2_5);
+	} else {
+		/* SD2 CD for BB2.0 */
+		gpio_request(BABBAGE_SD2_CD_2_0, "sdhc2-detect");
+		gpio_direction_input(BABBAGE_SD2_CD_2_0);
+	}
+	gpio_request(BABBAGE_SD2_WP, "sdhc2-wp");
+	gpio_direction_input(BABBAGE_SD2_WP);
+
+	/* reset FEC PHY */
+	gpio_request(BABBAGE_FEC_PHY_RESET, "fec-phy-reset");
+	gpio_direction_output(BABBAGE_FEC_PHY_RESET, 0);
+	msleep(10);
+	gpio_set_value(BABBAGE_FEC_PHY_RESET, 1);
+
+	/* reset FM */
+	gpio_request(BABBAGE_FM_RESET, "fm-reset");
+	gpio_direction_output(BABBAGE_FM_RESET, 0);
+	msleep(10);
+	gpio_set_value(BABBAGE_FM_RESET, 1);
+
+	/* Drive 26M_OSC_EN line high */
+	gpio_request(BABBAGE_26M_OSC_EN, "26m-osc-en");
+	gpio_direction_output(BABBAGE_26M_OSC_EN, 1);
+
+	/* Drive USB_CLK_EN_B line low */
+	gpio_request(BABBAGE_USB_CLK_EN_B, "usb-clk_en_b");
+	gpio_direction_output(BABBAGE_USB_CLK_EN_B, 0);
+
+	/* De-assert USB PHY RESETB */
+	gpio_request(BABBAGE_PHY_RESET, "usb-phy-reset");
+	gpio_direction_output(BABBAGE_PHY_RESET, 1);
+
+	/* hphone_det_b */
+	gpio_request(BABBAGE_HEADPHONE_DET, "hphone-det");
+	gpio_direction_input(BABBAGE_HEADPHONE_DET);
+
+	/* audio_clk_en_b */
+	gpio_request(BABBAGE_AUDIO_CLK_EN, "audio-clk-en");
+	gpio_direction_output(BABBAGE_AUDIO_CLK_EN, 0);
+
+	/* power key */
+	gpio_request(BABBAGE_POWER_KEY, "power-key");
+	gpio_direction_input(BABBAGE_POWER_KEY);
+
+	if (cpu_is_mx51_rev(CHIP_REV_3_0) > 0) {
+		/* DVI_I2C_ENB = 0 tristates the DVI I2C level shifter */
+		gpio_request(BABBAGE_DVI_I2C_EN, "dvi-i2c-en");
+		gpio_direction_output(BABBAGE_DVI_I2C_EN, 0);
+	}
+
+	/* Deassert VGA reset to free i2c bus */
+	gpio_request(BABBAGE_VGA_RESET, "vga-reset");
+	gpio_direction_output(BABBAGE_VGA_RESET, 1);
+
+	/* LCD related gpio */
+	gpio_request(BABBAGE_DISP_BRIGHTNESS_CTL, "disp-brightness-ctl");
+	gpio_request(BABBAGE_LVDS_POWER_DOWN, "lvds-power-down");
+	gpio_request(BABBAGE_LCD_3V3_ON, "lcd-3v3-on");
+	gpio_request(BABBAGE_LCD_5V_ON, "lcd-5v-on");
+	gpio_direction_output(BABBAGE_DISP_BRIGHTNESS_CTL, 0);
+	gpio_direction_output(BABBAGE_LVDS_POWER_DOWN, 0);
+	gpio_direction_output(BABBAGE_LCD_3V3_ON, 0);
+	gpio_direction_output(BABBAGE_LCD_5V_ON, 0);
+
+	/* Camera reset */
+	gpio_request(BABBAGE_CAM_RESET, "cam-reset");
+	gpio_direction_output(BABBAGE_CAM_RESET, 1);
+
+	/* Camera low power */
+	gpio_request(BABBAGE_CAM_LOW_POWER, "cam-low-power");
+	gpio_direction_output(BABBAGE_CAM_LOW_POWER, 0);
+
+	/* OSC_EN */
+	gpio_request(BABBAGE_OSC_EN_B, "osc-en");
+	gpio_direction_output(BABBAGE_OSC_EN_B, 1);
+
+	if (enable_w1) {
+		/* OneWire */
+		struct pad_desc onewire = MX51_PAD_OWIRE_LINE__OWIRE_LINE;
+		mxc_iomux_v3_setup_pad(&onewire);
+	}
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+	mxc_ipu_data.csi_clk[0] = clk_get(NULL, "csi_mclk1");
+	mxc_ipu_data.csi_clk[1] = clk_get(NULL, "csi_mclk2");
+
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+	/* SD card detect irqs */
+	mxcsdhc2_device.resource[2].start = IOMUX_TO_IRQ_V3(BABBAGE_SD2_CD_2_5);
+	mxcsdhc2_device.resource[2].end = IOMUX_TO_IRQ_V3(BABBAGE_SD2_CD_2_5);
+	mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ_V3(BABBAGE_SD1_CD);
+	mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ_V3(BABBAGE_SD1_CD);
+
+	mxc_cpu_common_init();
+	mx51_babbage_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_hs_device, &mxci2c_hs_data);
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, &mxc_vpu_data);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mxcscc_device, NULL);
+	mxc_register_device(&mx51_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	mxc_register_device(&mxc_iim_device, NULL);
+	mxc_register_device(&mxc_pwm1_device, NULL);
+	mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+	mxc_register_device(&mxc_keypad_device, &keypad_plat_data);
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc2_device, &mmc2_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
+	mxc_register_device(&mxc_fec_device, NULL);
+	mxc_register_device(&mxc_v4l2_device, NULL);
+	mxc_register_device(&mxc_v4l2out_device, NULL);
+
+	mx51_babbage_init_mc13892();
+
+	if (board_is_rev(BOARD_REV_2))
+		/* BB2.5 */
+		spi_register_board_info(mxc_dataflash_device,
+					ARRAY_SIZE(mxc_dataflash_device));
+	else
+		/* BB2.0 */
+		spi_register_board_info(mxc_spi_nor_device,
+					ARRAY_SIZE(mxc_spi_nor_device));
+
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+				ARRAY_SIZE(mxc_i2c0_board_info));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) >= 1) {
+		vga_data.core_reg = NULL;
+		vga_data.io_reg = NULL;
+		vga_data.analog_reg = NULL;
+	}
+	i2c_register_board_info(3, mxc_i2c_hs_board_info,
+				ARRAY_SIZE(mxc_i2c_hs_board_info));
+
+	pm_power_off = mxc_power_off;
+
+	if (cpu_is_mx51_rev(CHIP_REV_1_1) == 2) {
+		sgtl5000_data.sysclk = 26000000;
+	}
+	gpio_request(BABBAGE_AUDAMP_STBY, "audioamp-stdby");
+	gpio_direction_output(BABBAGE_AUDAMP_STBY, 0);
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+
+	mx5_usb_dr_init();
+	mx5_usbh1_init();
+}
+
+static void __init mx51_babbage_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	/* Change the CPU voltages for TO2*/
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) <= 1) {
+		cpu_wp_auto[0].cpu_voltage = 1175000;
+		cpu_wp_auto[1].cpu_voltage = 1100000;
+		cpu_wp_auto[2].cpu_voltage = 1000000;
+	}
+
+	mx51_clocks_init(32768, 24000000, 22579200, 24576000);
+
+	uart_clk = clk_get_sys("mxcintuart.0", NULL);
+	early_console_setup(UART1_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx51_babbage_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX51_BABBAGE data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX51_BABBAGE, "Freescale MX51 Babbage Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io	= AIPS1_BASE_ADDR,
+	.io_pg_offst	= ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c b/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c
new file mode 100644
index 0000000..830f4e8
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_babbage_pmic_mc13892.c
@@ -0,0 +1,420 @@
+/*
+ * mx51-babbage-pmic-mc13892.c  --  i.MX51 Babbage Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx51.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+/* Coin cell charger enable */
+#define COINCHEN_LSH	23
+#define COINCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* regulator standby mask */
+#define GEN1_STBY_MASK		(1 << 1)
+#define IOHI_STBY_MASK		(1 << 4)
+#define DIG_STBY_MASK		(1 << 10)
+#define GEN2_STBY_MASK		(1 << 13)
+#define PLL_STBY_MASK		(1 << 16)
+#define USB2_STBY_MASK		(1 << 19)
+
+#define GEN3_STBY_MASK		(1 << 1)
+#define CAM_STBY_MASK		(1 << 7)
+#define VIDEO_STBY_MASK		(1 << 13)
+#define AUDIO_STBY_MASK		(1 << 16)
+#define SD_STBY_MASK		(1 << 19)
+
+/* 0x92412 */
+#define REG_MODE_0_ALL_MASK	(GEN1_STBY_MASK |\
+				DIG_STBY_MASK | GEN2_STBY_MASK |\
+				PLL_STBY_MASK)
+/* 0x92082 */
+#define REG_MODE_1_ALL_MASK	(CAM_STBY_MASK | VIDEO_STBY_MASK |\
+				AUDIO_STBY_MASK | SD_STBY_MASK)
+
+/* switch mode setting */
+#define	SW1MODE_LSB	0
+#define	SW2MODE_LSB	10
+#define	SW3MODE_LSB	0
+#define	SW4MODE_LSB	8
+
+#define	SWMODE_MASK	0xF
+#define SWMODE_AUTO	0x8
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+static struct regulator_consumer_supply vdig_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "1-000a",
+	},
+};
+
+static struct regulator_consumer_supply vvideo_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDIO",
+		.dev_name = "1-000a",
+	},
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1650),
+		.max_uV = mV_to_uV(1650),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vdig_consumers),
+	.consumer_supplies = vdig_consumers,
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2775),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.apply_uV = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vvideo_consumers),
+	.consumer_supplies = vvideo_consumers,
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(1200),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value, register_mask;
+	printk("Initializing regulators for Babbage.\n");
+	if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+		sw2_init.constraints.state_mem.uV = 1100000;
+	else if (mxc_cpu_is_rev(CHIP_REV_2_0) == 1) {
+		sw2_init.constraints.state_mem.uV = 1250000;
+		sw1_init.constraints.state_mem.uV = 1000000;
+	}
+
+	/* enable standby controll for all regulators */
+	pmic_read_reg(REG_MODE_0, &value, 0xffffff);
+	value |= REG_MODE_0_ALL_MASK;
+	pmic_write_reg(REG_MODE_0, value, 0xffffff);
+
+	pmic_read_reg(REG_MODE_1, &value, 0xffffff);
+	value |= REG_MODE_1_ALL_MASK;
+	pmic_write_reg(REG_MODE_1, value, 0xffffff);
+
+	/* enable switch audo mode */
+	pmic_read_reg(REG_IDENTIFICATION, &value, 0xffffff);
+	/* only for mc13892 2.0A */
+	if ((value & 0x0000FFFF) == 0x45d0) {
+		pmic_read_reg(REG_SW_4, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW1MODE_LSB) |
+		       (SWMODE_MASK << SW2MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW1MODE_LSB) |
+			(SWMODE_AUTO << SW2MODE_LSB);
+		pmic_write_reg(REG_SW_4, value, 0xffffff);
+
+		pmic_read_reg(REG_SW_5, &value, 0xffffff);
+		register_mask = (SWMODE_MASK << SW3MODE_LSB) |
+			(SWMODE_MASK << SW4MODE_LSB);
+		value &= ~register_mask;
+		value |= (SWMODE_AUTO << SW3MODE_LSB) |
+			(SWMODE_AUTO << SW4MODE_LSB);
+		pmic_write_reg(REG_SW_5, value, 0xffffff);
+	}
+
+	/* Enable coin cell charger */
+	value = BITFVAL(COINCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(COINCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	regulator_has_full_constraints();
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct spi_board_info __initdata mc13892_spi_device = {
+	.modalias = "pmic_spi",
+	.irq = IOMUX_TO_IRQ_V3(8),
+	.max_speed_hz = 6000000,	/* max spi SCK clock speed in HZ */
+	.bus_num = 1,
+	.chip_select = 0,
+	.platform_data = &mc13892_plat,
+};
+
+
+int __init mx51_babbage_init_mc13892(void)
+{
+	return spi_register_board_info(&mc13892_spi_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx51_pins.h b/arch/arm/mach-mx5/mx51_pins.h
new file mode 100644
index 0000000..351cdb2
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_pins.h
@@ -0,0 +1,409 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX51_PINS_H__
+#define __ASM_ARCH_MXC_MX51_PINS_H__
+#include "iomux.h"
+
+/*!
+ * @file arch-mxc/mx51_pins.h
+ *
+ * @brief MX51 I/O Pin List
+ *
+ * @ingroup GPIO_MX51
+ */
+
+#ifndef __ASSEMBLY__
+
+#define PAD_I_START_MX51		0x3F0
+#define INPUT_CTL_START_MX51		0x8C4
+#define INPUT_CTL_START_MX51_TO1	0x928
+
+#define MUX_I_END_MX51		(PAD_I_START_MX51 - 4)
+
+#define _MXC_BUILD_PIN_MX51(gp, gi, ga, mi, pi) \
+	(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+	((mi) << MUX_I) | \
+	((pi - PAD_I_START_MX51) << PAD_I) | \
+	((ga) << GPIO_I))
+
+#define _MXC_BUILD_GPIO_PIN_MX51(gp, gi, ga, mi, pi) \
+    _MXC_BUILD_PIN_MX51(gp, gi, ga, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN_MX51(mi, pi) \
+    _MXC_BUILD_PIN_MX51(NON_GPIO_PORT, 0, 0, mi, pi)
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX51 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+enum iomux_pins_mx51 {
+	MX51_PIN_EIM_DA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1C, 0x7A8),
+	MX51_PIN_EIM_DA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x20, 0x7A8),
+	MX51_PIN_EIM_DA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x24, 0x7A8),
+	MX51_PIN_EIM_DA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x28, 0x7A8),
+	MX51_PIN_EIM_DA4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2C, 0x7AC),
+	MX51_PIN_EIM_DA5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x30, 0x7AC),
+	MX51_PIN_EIM_DA6 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x34, 0x7AC),
+	MX51_PIN_EIM_DA7 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x38, 0x7AC),
+	MX51_PIN_EIM_DA8 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C, 0x7B0),
+	MX51_PIN_EIM_DA9 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x40, 0x7B0),
+	MX51_PIN_EIM_DA10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x44, 0x7B0),
+	MX51_PIN_EIM_DA11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x48, 0x7B0),
+	MX51_PIN_EIM_DA12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x4C, 0x7BC),
+	MX51_PIN_EIM_DA13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x50, 0x7BC),
+	MX51_PIN_EIM_DA14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x54, 0x7BC),
+	MX51_PIN_EIM_DA15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x58, 0x7BC),
+	MX51_PIN_EIM_D16 = _MXC_BUILD_GPIO_PIN_MX51(1, 0, 1, 0x5C, 0x3F0),
+	MX51_PIN_EIM_D17 = _MXC_BUILD_GPIO_PIN_MX51(1, 1, 1, 0x60, 0x3F4),
+	MX51_PIN_EIM_D18 = _MXC_BUILD_GPIO_PIN_MX51(1, 2, 1, 0x64, 0x3F8),
+	MX51_PIN_EIM_D19 = _MXC_BUILD_GPIO_PIN_MX51(1, 3, 1, 0x68, 0x3FC),
+	MX51_PIN_EIM_D20 = _MXC_BUILD_GPIO_PIN_MX51(1, 4, 1, 0x6C, 0x400),
+	MX51_PIN_EIM_D21 = _MXC_BUILD_GPIO_PIN_MX51(1, 5, 1, 0x70, 0x404),
+	MX51_PIN_EIM_D22 = _MXC_BUILD_GPIO_PIN_MX51(1, 6, 1, 0x74, 0x408),
+	MX51_PIN_EIM_D23 = _MXC_BUILD_GPIO_PIN_MX51(1, 7, 1, 0x78, 0x40C),
+	MX51_PIN_EIM_D24 = _MXC_BUILD_GPIO_PIN_MX51(1, 8, 1, 0x7C, 0x410),
+	MX51_PIN_EIM_D25 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x80, 0x414),
+	MX51_PIN_EIM_D26 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x84, 0x418),
+	MX51_PIN_EIM_D27 = _MXC_BUILD_GPIO_PIN_MX51(1, 9, 1, 0x88, 0x41C),
+	MX51_PIN_EIM_D28 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x8C, 0x420),
+	MX51_PIN_EIM_D29 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x90, 0x424),
+	MX51_PIN_EIM_D30 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x94, 0x428),
+	MX51_PIN_EIM_D31 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x98, 0x42C),
+	MX51_PIN_EIM_A16 = _MXC_BUILD_GPIO_PIN_MX51(1, 10, 1, 0x9C, 0x430),
+	MX51_PIN_EIM_A17 = _MXC_BUILD_GPIO_PIN_MX51(1, 11, 1, 0xA0, 0x434),
+	MX51_PIN_EIM_A18 = _MXC_BUILD_GPIO_PIN_MX51(1, 12, 1, 0xA4, 0x438),
+	MX51_PIN_EIM_A19 = _MXC_BUILD_GPIO_PIN_MX51(1, 13, 1, 0xA8, 0x43C),
+	MX51_PIN_EIM_A20 = _MXC_BUILD_GPIO_PIN_MX51(1, 14, 1, 0xAC, 0x440),
+	MX51_PIN_EIM_A21 = _MXC_BUILD_GPIO_PIN_MX51(1, 15, 1, 0xB0, 0x444),
+	MX51_PIN_EIM_A22 = _MXC_BUILD_GPIO_PIN_MX51(1, 16, 1, 0xB4, 0x448),
+	MX51_PIN_EIM_A23 = _MXC_BUILD_GPIO_PIN_MX51(1, 17, 1, 0xB8, 0x44C),
+	MX51_PIN_EIM_A24 = _MXC_BUILD_GPIO_PIN_MX51(1, 18, 1, 0xBC, 0x450),
+	MX51_PIN_EIM_A25 = _MXC_BUILD_GPIO_PIN_MX51(1, 19, 1, 0xC0, 0x454),
+	MX51_PIN_EIM_A26 = _MXC_BUILD_GPIO_PIN_MX51(1, 20, 1, 0xC4, 0x458),
+	MX51_PIN_EIM_A27 = _MXC_BUILD_GPIO_PIN_MX51(1, 21, 1, 0xC8, 0x45C),
+	MX51_PIN_EIM_EB0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0xCC, 0x460),
+	MX51_PIN_EIM_EB1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0xD0, 0x464),
+	MX51_PIN_EIM_EB2 = _MXC_BUILD_GPIO_PIN_MX51(1, 22, 1, 0xD4, 0x468),
+	MX51_PIN_EIM_EB3 = _MXC_BUILD_GPIO_PIN_MX51(1, 23, 1, 0xD8, 0x46C),
+	MX51_PIN_EIM_OE = _MXC_BUILD_GPIO_PIN_MX51(1, 24, 1, 0xDC, 0x470),
+	MX51_PIN_EIM_CS0 = _MXC_BUILD_GPIO_PIN_MX51(1, 25, 1, 0xE0, 0x474),
+	MX51_PIN_EIM_CS1 = _MXC_BUILD_GPIO_PIN_MX51(1, 26, 1, 0xE4, 0x478),
+	MX51_PIN_EIM_CS2 = _MXC_BUILD_GPIO_PIN_MX51(1, 27, 1, 0xE8, 0x47C),
+	MX51_PIN_EIM_CS3 = _MXC_BUILD_GPIO_PIN_MX51(1, 28, 1, 0xEC, 0x480),
+	MX51_PIN_EIM_CS4 = _MXC_BUILD_GPIO_PIN_MX51(1, 29, 1, 0xF0, 0x484),
+	MX51_PIN_EIM_CS5 = _MXC_BUILD_GPIO_PIN_MX51(1, 30, 1, 0xF4, 0x488),
+	MX51_PIN_EIM_DTACK = _MXC_BUILD_GPIO_PIN_MX51(1, 31, 1, 0xF8, 0x48C),
+	MX51_PIN_EIM_LBA = _MXC_BUILD_GPIO_PIN_MX51(2, 1, 1, 0xFC, 0x494),
+	MX51_PIN_EIM_CRE = _MXC_BUILD_GPIO_PIN_MX51(2, 2, 1, 0x100, 0x4A0),
+	MX51_PIN_DRAM_CS1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x104, 0x4D0),
+	MX51_PIN_NANDF_WE_B = _MXC_BUILD_GPIO_PIN_MX51(2, 3, 3, 0x108, 0x4E4),
+	MX51_PIN_NANDF_RE_B = _MXC_BUILD_GPIO_PIN_MX51(2, 4, 3, 0x10C, 0x4E8),
+	MX51_PIN_NANDF_ALE = _MXC_BUILD_GPIO_PIN_MX51(2, 5, 3, 0x110, 0x4EC),
+	MX51_PIN_NANDF_CLE = _MXC_BUILD_GPIO_PIN_MX51(2, 6, 3, 0x114, 0x4F0),
+	MX51_PIN_NANDF_WP_B = _MXC_BUILD_GPIO_PIN_MX51(2, 7, 3, 0x118, 0x4F4),
+	MX51_PIN_NANDF_RB0 = _MXC_BUILD_GPIO_PIN_MX51(2, 8, 3, 0x11C, 0x4F8),
+	MX51_PIN_NANDF_RB1 = _MXC_BUILD_GPIO_PIN_MX51(2, 9, 3, 0x120, 0x4FC),
+	MX51_PIN_NANDF_RB2 = _MXC_BUILD_GPIO_PIN_MX51(2, 10, 3, 0x124, 0x500),
+	MX51_PIN_NANDF_RB3 = _MXC_BUILD_GPIO_PIN_MX51(2, 11, 3, 0x128, 0x504),
+	MX51_PIN_GPIO_NAND = _MXC_BUILD_GPIO_PIN_MX51(2, 12, 3, 0x12C, 0x514),
+	MX51_PIN_NANDF_RB4 = MX51_PIN_GPIO_NAND,
+	MX51_PIN_NANDF_RB5 = _MXC_BUILD_GPIO_PIN_MX51(2, 13, 3, 0x130, 0x5D8),
+	MX51_PIN_NANDF_RB6 = _MXC_BUILD_GPIO_PIN_MX51(2, 14, 3, 0x134, 0x5DC),
+	MX51_PIN_NANDF_RB7 = _MXC_BUILD_GPIO_PIN_MX51(2, 15, 3, 0x138, 0x5E0),
+	MX51_PIN_NANDF_CS0 = _MXC_BUILD_GPIO_PIN_MX51(2, 16, 3, 0x130, 0x518),
+	MX51_PIN_NANDF_CS1 = _MXC_BUILD_GPIO_PIN_MX51(2, 17, 3, 0x134, 0x51C),
+	MX51_PIN_NANDF_CS2 = _MXC_BUILD_GPIO_PIN_MX51(2, 18, 3, 0x138, 0x520),
+	MX51_PIN_NANDF_CS3 = _MXC_BUILD_GPIO_PIN_MX51(2, 19, 3, 0x13C, 0x524),
+	MX51_PIN_NANDF_CS4 = _MXC_BUILD_GPIO_PIN_MX51(2, 20, 3, 0x140, 0x528),
+	MX51_PIN_NANDF_CS5 = _MXC_BUILD_GPIO_PIN_MX51(2, 21, 3, 0x144, 0x52C),
+	MX51_PIN_NANDF_CS6 = _MXC_BUILD_GPIO_PIN_MX51(2, 22, 3, 0x148, 0x530),
+	MX51_PIN_NANDF_CS7 = _MXC_BUILD_GPIO_PIN_MX51(2, 23, 3, 0x14C, 0x534),
+	MX51_PIN_NANDF_RDY_INT = _MXC_BUILD_GPIO_PIN_MX51(2, 24, 3, 0x150, 0x538),
+	MX51_PIN_NANDF_D15 = _MXC_BUILD_GPIO_PIN_MX51(2, 25, 3, 0x154, 0x53C),
+	MX51_PIN_NANDF_D14 = _MXC_BUILD_GPIO_PIN_MX51(2, 26, 3, 0x158, 0x540),
+	MX51_PIN_NANDF_D13 = _MXC_BUILD_GPIO_PIN_MX51(2, 27, 3, 0x15C, 0x544),
+	MX51_PIN_NANDF_D12 = _MXC_BUILD_GPIO_PIN_MX51(2, 28, 3, 0x160, 0x548),
+	MX51_PIN_NANDF_D11 = _MXC_BUILD_GPIO_PIN_MX51(2, 29, 3, 0x164, 0x54C),
+	MX51_PIN_NANDF_D10 = _MXC_BUILD_GPIO_PIN_MX51(2, 30, 3, 0x168, 0x550),
+	MX51_PIN_NANDF_D9 = _MXC_BUILD_GPIO_PIN_MX51(2, 31, 3, 0x16C, 0x554),
+	MX51_PIN_NANDF_D8 = _MXC_BUILD_GPIO_PIN_MX51(3, 0, 3, 0x170, 0x558),
+	MX51_PIN_NANDF_D7 = _MXC_BUILD_GPIO_PIN_MX51(3, 1, 3, 0x174, 0x55C),
+	MX51_PIN_NANDF_D6 = _MXC_BUILD_GPIO_PIN_MX51(3, 2, 3, 0x178, 0x560),
+	MX51_PIN_NANDF_D5 = _MXC_BUILD_GPIO_PIN_MX51(3, 3, 3, 0x17C, 0x564),
+	MX51_PIN_NANDF_D4 = _MXC_BUILD_GPIO_PIN_MX51(3, 4, 3, 0x180, 0x568),
+	MX51_PIN_NANDF_D3 = _MXC_BUILD_GPIO_PIN_MX51(3, 5, 3, 0x184, 0x56C),
+	MX51_PIN_NANDF_D2 = _MXC_BUILD_GPIO_PIN_MX51(3, 6, 3, 0x188, 0x570),
+	MX51_PIN_NANDF_D1 = _MXC_BUILD_GPIO_PIN_MX51(3, 7, 3, 0x18C, 0x574),
+	MX51_PIN_NANDF_D0 = _MXC_BUILD_GPIO_PIN_MX51(3, 8, 3, 0x190, 0x578),
+	MX51_PIN_CSI1_D8 = _MXC_BUILD_GPIO_PIN_MX51(2, 12, 3, 0x194, 0x57C),
+	MX51_PIN_CSI1_D9 = _MXC_BUILD_GPIO_PIN_MX51(2, 13, 3, 0x198, 0x580),
+	MX51_PIN_CSI1_D10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x19C, 0x584),
+	MX51_PIN_CSI1_D11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A0, 0x588),
+	MX51_PIN_CSI1_D12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A4, 0x58C),
+	MX51_PIN_CSI1_D13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1A8, 0x590),
+	MX51_PIN_CSI1_D14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1AC, 0x594),
+	MX51_PIN_CSI1_D15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B0, 0x598),
+	MX51_PIN_CSI1_D16 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B4, 0x59C),
+	MX51_PIN_CSI1_D17 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1B8, 0x5A0),
+	MX51_PIN_CSI1_D18 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1BC, 0x5A4),
+	MX51_PIN_CSI1_D19 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x1C0, 0x5A8),
+	MX51_PIN_CSI1_VSYNC = _MXC_BUILD_GPIO_PIN_MX51(2, 14, 3, 0x1C4, 0x5AC),
+	MX51_PIN_CSI1_HSYNC = _MXC_BUILD_GPIO_PIN_MX51(2, 15, 3, 0x1C8, 0x5B0),
+	MX51_PIN_CSI1_PIXCLK = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x5B4),
+	MX51_PIN_CSI1_MCLK = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x5B8),
+	MX51_PIN_CSI1_PKE0 = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x860),
+	MX51_PIN_CSI2_D12 = _MXC_BUILD_GPIO_PIN_MX51(3, 9, 3, 0x1CC, 0x5BC),
+	MX51_PIN_CSI2_D13 = _MXC_BUILD_GPIO_PIN_MX51(3, 10, 3, 0x1D0, 0x5C0),
+	MX51_PIN_CSI2_D14 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1D4, 0x5C4),
+	MX51_PIN_CSI2_D15 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1D8, 0x5C8),
+	MX51_PIN_CSI2_D16 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1DC, 0x5CC),
+	MX51_PIN_CSI2_D17 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1E0, 0x5D0),
+	MX51_PIN_CSI2_D18 = _MXC_BUILD_GPIO_PIN_MX51(3, 11, 3, 0x1E4, 0x5D4),
+	MX51_PIN_CSI2_D19 = _MXC_BUILD_GPIO_PIN_MX51(3, 12, 3, 0x1E8, 0x5D8),
+	MX51_PIN_CSI2_VSYNC = _MXC_BUILD_GPIO_PIN_MX51(3, 13, 3, 0x1EC, 0x5DC),
+	MX51_PIN_CSI2_HSYNC = _MXC_BUILD_GPIO_PIN_MX51(3, 14, 3, 0x1F0, 0x5E0),
+	MX51_PIN_CSI2_PIXCLK = _MXC_BUILD_GPIO_PIN_MX51(3, 15, 3, 0x1F4, 0x5E4),
+	MX51_PIN_CSI2_PKE0 = _MXC_BUILD_NON_GPIO_PIN_MX51(NON_MUX_I, 0x81C),
+	MX51_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN_MX51(3, 16, 3, 0x1F8, 0x5E8),
+	MX51_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN_MX51(3, 17, 3, 0x1FC, 0x5EC),
+	MX51_PIN_AUD3_BB_TXD = _MXC_BUILD_GPIO_PIN_MX51(3, 18, 3, 0x200, 0x5F0),
+	MX51_PIN_AUD3_BB_RXD = _MXC_BUILD_GPIO_PIN_MX51(3, 19, 3, 0x204, 0x5F4),
+	MX51_PIN_AUD3_BB_CK = _MXC_BUILD_GPIO_PIN_MX51(3, 20, 3, 0x208, 0x5F8),
+	MX51_PIN_AUD3_BB_FS = _MXC_BUILD_GPIO_PIN_MX51(3, 21, 3, 0x20C, 0x5FC),
+	MX51_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN_MX51(3, 22, 3, 0x210, 0x600),
+	MX51_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN_MX51(3, 23, 3, 0x214, 0x604),
+	MX51_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN_MX51(3, 24, 3, 0x218, 0x608),
+	MX51_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN_MX51(3, 25, 3, 0x21C, 0x60C),
+	MX51_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN_MX51(3, 26, 3, 0x220, 0x610),
+	MX51_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN_MX51(3, 27, 3, 0x224, 0x614),
+	MX51_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN_MX51(3, 28, 3, 0x228, 0x618),
+	MX51_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN_MX51(3, 29, 3, 0x22C, 0x61C),
+	MX51_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN_MX51(3, 30, 3, 0x230, 0x620),
+	MX51_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN_MX51(3, 31, 3, 0x234, 0x624),
+	MX51_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN_MX51(0, 20, 3, 0x238, 0x628),
+	MX51_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN_MX51(0, 21, 3, 0x23C, 0x62C),
+	MX51_PIN_UART3_RXD = _MXC_BUILD_GPIO_PIN_MX51(0, 22, 3, 0x240, 0x630),
+	MX51_PIN_UART3_TXD = _MXC_BUILD_GPIO_PIN_MX51(0, 23, 3, 0x244, 0x634),
+	MX51_PIN_OWIRE_LINE = _MXC_BUILD_GPIO_PIN_MX51(0, 24, 3, 0x248, 0x638),
+	MX51_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x24C, 0x63C),
+	MX51_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x250, 0x640),
+	MX51_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x254, 0x644),
+	MX51_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x258, 0x648),
+	MX51_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x25C, 0x64C),
+	MX51_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x260, 0x650),
+	MX51_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x264, 0x654),
+	MX51_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x268, 0x658),
+	MX51_PIN_KEY_COL4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x26C, 0x65C),
+	MX51_PIN_KEY_COL5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x270, 0x660),
+	MX51_PIN_USBH1_CLK = _MXC_BUILD_GPIO_PIN_MX51(0, 25, 2, 0x278, 0x678),
+	MX51_PIN_USBH1_DIR = _MXC_BUILD_GPIO_PIN_MX51(0, 26, 2, 0x27C, 0x67C),
+	MX51_PIN_USBH1_STP = _MXC_BUILD_GPIO_PIN_MX51(0, 27, 2, 0x280, 0x680),
+	MX51_PIN_USBH1_NXT = _MXC_BUILD_GPIO_PIN_MX51(0, 28, 2, 0x284, 0x684),
+	MX51_PIN_USBH1_DATA0 = _MXC_BUILD_GPIO_PIN_MX51(0, 11, 2, 0x288, 0x688),
+	MX51_PIN_USBH1_DATA1 = _MXC_BUILD_GPIO_PIN_MX51(0, 12, 2, 0x28C, 0x68C),
+	MX51_PIN_USBH1_DATA2 = _MXC_BUILD_GPIO_PIN_MX51(0, 13, 2, 0x290, 0x690),
+	MX51_PIN_USBH1_DATA3 = _MXC_BUILD_GPIO_PIN_MX51(0, 14, 2, 0x294, 0x694),
+	MX51_PIN_USBH1_DATA4 = _MXC_BUILD_GPIO_PIN_MX51(0, 15, 2, 0x298, 0x698),
+	MX51_PIN_USBH1_DATA5 = _MXC_BUILD_GPIO_PIN_MX51(0, 16, 2, 0x29C, 0x69C),
+	MX51_PIN_USBH1_DATA6 = _MXC_BUILD_GPIO_PIN_MX51(0, 17, 2, 0x2A0, 0x6A0),
+	MX51_PIN_USBH1_DATA7 = _MXC_BUILD_GPIO_PIN_MX51(0, 18, 2, 0x2A4, 0x6A4),
+	MX51_PIN_DI1_PIN11 = _MXC_BUILD_GPIO_PIN_MX51(2, 0, 4, 0x2A8, 0x6A8),
+	MX51_PIN_DI1_PIN12 = _MXC_BUILD_GPIO_PIN_MX51(2, 1, 4, 0x2AC, 0x6AC),
+	MX51_PIN_DI1_PIN13 = _MXC_BUILD_GPIO_PIN_MX51(2, 2, 4, 0x2B0, 0x6B0),
+	MX51_PIN_DI1_D0_CS = _MXC_BUILD_GPIO_PIN_MX51(2, 3, 4, 0x2B4, 0x6B4),
+	MX51_PIN_DI1_D1_CS = _MXC_BUILD_GPIO_PIN_MX51(2, 4, 4, 0x2B8, 0x6B8),
+	MX51_PIN_DISPB2_SER_DIN = _MXC_BUILD_GPIO_PIN_MX51(2, 5, 4, 0x2BC, 0x6BC),
+	MX51_PIN_DISPB2_SER_DIO = _MXC_BUILD_GPIO_PIN_MX51(2, 6, 4, 0x2C0, 0x6C0),
+	MX51_PIN_DISPB2_SER_CLK = _MXC_BUILD_GPIO_PIN_MX51(2, 7, 4, 0x2C4, 0x6C4),
+	MX51_PIN_DISPB2_SER_RS = _MXC_BUILD_GPIO_PIN_MX51(2, 8, 4, 0x2C8, 0x6C8),
+	MX51_PIN_DISP1_DAT0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2CC, 0x6CC),
+	MX51_PIN_DISP1_DAT1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D0, 0x6D0),
+	MX51_PIN_DISP1_DAT2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D4, 0x6D4),
+	MX51_PIN_DISP1_DAT3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2D8, 0x6D8),
+	MX51_PIN_DISP1_DAT4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2DC, 0x6DC),
+	MX51_PIN_DISP1_DAT5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E0, 0x6E0),
+	MX51_PIN_DISP1_DAT6 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E4, 0x6E4),
+	MX51_PIN_DISP1_DAT7 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2E8, 0x6E8),
+	MX51_PIN_DISP1_DAT8 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2EC, 0x6EC),
+	MX51_PIN_DISP1_DAT9 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F0, 0x6F0),
+	MX51_PIN_DISP1_DAT10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F4, 0x6F4),
+	MX51_PIN_DISP1_DAT11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2F8, 0x6F8),
+	MX51_PIN_DISP1_DAT12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x2FC, 0x6FC),
+	MX51_PIN_DISP1_DAT13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x300, 0x700),
+	MX51_PIN_DISP1_DAT14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x304, 0x704),
+	MX51_PIN_DISP1_DAT15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x308, 0x708),
+	MX51_PIN_DISP1_DAT16 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x30C, 0x70C),
+	MX51_PIN_DISP1_DAT17 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x310, 0x710),
+	MX51_PIN_DISP1_DAT18 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x314, 0x714),
+	MX51_PIN_DISP1_DAT19 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x318, 0x718),
+	MX51_PIN_DISP1_DAT20 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x31C, 0x71C),
+	MX51_PIN_DISP1_DAT21 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x320, 0x720),
+	MX51_PIN_DISP1_DAT22 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x324, 0x724),
+	MX51_PIN_DISP1_DAT23 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x328, 0x728),
+	MX51_PIN_DI1_PIN3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x32C, 0x72C),
+	MX51_PIN_DI1_PIN2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x330, 0x734),
+	MX51_PIN_DI_GP1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x334, 0x73C),
+	MX51_PIN_DI_GP2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x338, 0x740),
+	MX51_PIN_DI_GP3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x33C, 0x744),
+	MX51_PIN_DI2_PIN4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x340, 0x748),
+	MX51_PIN_DI2_PIN2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x344, 0x74C),
+	MX51_PIN_DI2_PIN3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x348, 0x750),
+	MX51_PIN_DI2_DISP_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x34C, 0x754),
+	MX51_PIN_DI_GP4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x350, 0x758),
+	MX51_PIN_DISP2_DAT0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x354, 0x75C),
+	MX51_PIN_DISP2_DAT1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x358, 0x760),
+	MX51_PIN_DISP2_DAT2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x35C, 0x764),
+	MX51_PIN_DISP2_DAT3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x360, 0x768),
+	MX51_PIN_DISP2_DAT4 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x364, 0x76C),
+	MX51_PIN_DISP2_DAT5 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x368, 0x770),
+	MX51_PIN_DISP2_DAT6 = _MXC_BUILD_GPIO_PIN_MX51(0, 19, 5, 0x36C, 0x774),
+	MX51_PIN_DISP2_DAT7 = _MXC_BUILD_GPIO_PIN_MX51(0, 29, 5, 0x370, 0x778),
+	MX51_PIN_DISP2_DAT8 = _MXC_BUILD_GPIO_PIN_MX51(0, 30, 5, 0x374, 0x77C),
+	MX51_PIN_DISP2_DAT9 = _MXC_BUILD_GPIO_PIN_MX51(0, 31, 5, 0x378, 0x780),
+	MX51_PIN_DISP2_DAT10 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x37C, 0x784),
+	MX51_PIN_DISP2_DAT11 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x380, 0x788),
+	MX51_PIN_DISP2_DAT12 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x384, 0x78C),
+	MX51_PIN_DISP2_DAT13 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x388, 0x790),
+	MX51_PIN_DISP2_DAT14 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x38C, 0x794),
+	MX51_PIN_DISP2_DAT15 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x390, 0x798),
+	MX51_PIN_SD1_CMD = _MXC_BUILD_NON_GPIO_PIN_MX51(0x394, 0x79C),
+	MX51_PIN_SD1_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x398, 0x7A0),
+	MX51_PIN_SD1_DATA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x39C, 0x7A4),
+	MX51_PIN_SD1_DATA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A0, 0x7A8),
+	MX51_PIN_SD1_DATA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A4, 0x7AC),
+	MX51_PIN_SD1_DATA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3A8, 0x7B0),
+	MX51_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN_MX51(0, 0, 1, 0x3AC, 0x7B4),
+	MX51_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN_MX51(0, 1, 1, 0x3B0, 0x7B8),
+	MX51_PIN_SD2_CMD = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3B4, 0x7BC),
+	MX51_PIN_SD2_CLK = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3B8, 0x7C0),
+	MX51_PIN_SD2_DATA0 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3BC, 0x7C4),
+	MX51_PIN_SD2_DATA1 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C0, 0x7C8),
+	MX51_PIN_SD2_DATA2 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C4, 0x7CC),
+	MX51_PIN_SD2_DATA3 = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3C8, 0x7D0),
+	MX51_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN_MX51(0, 2, 0, 0x3CC, 0x7D4),
+	MX51_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN_MX51(0, 3, 0, 0x3D0, 0x7D8),
+	MX51_PIN_PMIC_INT_REQ = _MXC_BUILD_NON_GPIO_PIN_MX51(0x3D4, 0x7FC),
+	MX51_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN_MX51(0, 4, 0, 0x3D8, 0x804),
+	MX51_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN_MX51(0, 5, 0, 0x3DC, 0x808),
+	MX51_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN_MX51(0, 6, 0, 0x3E0, 0x80C),
+	MX51_PIN_GPIO1_7 = _MXC_BUILD_GPIO_PIN_MX51(0, 7, 0, 0x3E4, 0x810),
+	MX51_PIN_GPIO1_8 = _MXC_BUILD_GPIO_PIN_MX51(0, 8, 0, 0x3E8, 0x814),
+	MX51_PIN_GPIO1_9 = _MXC_BUILD_GPIO_PIN_MX51(0, 9, 0, 0x3EC, 0x818),
+};
+
+/*!
+ * various IOMUX input select register index
+ */
+enum iomux_input_select_mx51 {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX_SELECT_I = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX_SELECT_I,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_RXFS_AMX_SELECT,
+	MUX_IN_AUDMUX_P5_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P5_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DA_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_DB_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_RXFS_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXCLK_AMX_SELECT_INPUT,
+	MUX_IN_AUDMUX_P6_INPUT_TXFS_AMX_SELECT_INPUT,
+	MUX_IN_CCM_IPP_DI_CLK_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_CCM_IPP_DI1_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL1_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CCM_PLL2_BYPASS_CLK_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MISO_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_MOSI_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_2_SELECT_INPUT,
+	MUX_IN_CSPI_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_DPLLIP1_L1T_TOG_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_ECSPI2_IPP_IND_SS_B_1_SELECT_INPUT,
+	MUX_IN_ECSPI2_IPP_IND_SS_B_3_SELECT_INPUT,
+	MUX_IN_EMI_IPP_IND_RDY_INT_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT0_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT1_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT2_IN_SELECT_INPUT,
+	MUX_IN_ESDHC3_IPP_DAT3_IN_SELECT_INPUT,
+	MUX_IN_FEC_FEC_COL_SELECT_INPUT,
+	MUX_IN_FEC_FEC_CRS_SELECT_INPUT,
+	MUX_IN_FEC_FEC_MDI_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_0_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_1_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_2_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RDATA_3_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_CLK_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_DV_SELECT_INPUT,
+	MUX_IN_FEC_FEC_RX_ER_SELECT_INPUT,
+	MUX_IN_FEC_FEC_TX_CLK_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_1_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_2_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_3_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_4_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_6_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_7_SELECT_INPUT,
+	MUX_IN_GPIO3_IPP_IND_G_IN_8_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS1_DATA_EN_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_VSYNC_SELECT_INPUT,
+	/* TO2 */
+	MUX_IN_HSC_MIPI_MIX_PAR_DI_WAIT_SELECT_INPUT,
+	MUX_IN_HSC_MIPI_MIX_PAR_SISG_TRIG_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+	MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_0_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_IPU_IPP_DI_1_IND_DISPB_SD_D_SELECT_INPUT,
+
+	MUX_IN_KPP_IPP_IND_COL_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_COL_7_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_4_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_5_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_6_SELECT_INPUT,
+	MUX_IN_KPP_IPP_IND_ROW_7_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_CLK_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_0_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_1_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_2_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_3_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_4_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_5_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_6_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DATA_7_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_DIR_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_NXT_SELECT_INPUT,
+	MUX_IN_USBOH3_IPP_IND_UH3_STP_SELECT_INPUT,
+	MUX_INPUT_NUM_MUX,
+};
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX51_PINS_H__ */
diff --git a/arch/arm/mach-mx5/mx53_evk.c b/arch/arm/mach-mx5/mx53_evk.c
new file mode 100644
index 0000000..ae6c4b8
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_evk.c
@@ -0,0 +1,1680 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/regulator/consumer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <linux/fec.h>
+#include <linux/ahci_platform.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/keypad.h>
+#include <asm/mach/flash.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/iomux-mx53.h>
+
+#include "crm_regs.h"
+#include "devices.h"
+#include "usb.h"
+
+#define ARM2_SD1_CD			(0*32 + 1)	/* GPIO_1_1 */
+
+#define MX53_HP_DETECT			(1*32 + 5)	/* GPIO_2_5 */
+
+#define EVK_SD3_CD			(2*32 + 11)	/* GPIO_3_11 */
+#define EVK_SD3_WP			(2*32 + 12)	/* GPIO_3_12 */
+#define EVK_SD1_CD			(2*32 + 13)	/* GPIO_3_13 */
+#define EVK_SD1_WP			(2*32 + 14)	/* GPIO_3_14 */
+#define ARM2_OTG_VBUS			(2*32 + 22)	/* GPIO_3_22 */
+#define MX53_DVI_PD			(2*32 + 24)	/* GPIO_3_24 */
+#define EVK_TS_INT			(2*32 + 26)	/* GPIO_3_26 */
+#define MX53_DVI_I2C			(2*32 + 28)	/* GPIO_3_28 */
+#define MX53_DVI_DETECT		(2*32 + 31)	/* GPIO_3_31 */
+
+#define MX53_CAM_RESET			(3*32 + 0)	/* GPIO_4_0 */
+#define MX53_ESAI_RESET			(3*32 + 2)	/* GPIO_4_2 */
+#define MX53_CAN2_EN2			(3*32 + 4)	/* GPIO_4_4 */
+#define MX53_12V_EN			(3*32 + 5)	/* GPIO_4_5 */
+#define ARM2_LCD_CONTRAST		(3*32 + 20)	/* GPIO_4_20 */
+
+#define MX53_DVI_RESET			(4*32 + 0)	/* GPIO_5_0 */
+#define EVK_USB_HUB_RESET		(4*32 + 20)	/* GPIO_5_20 */
+#define MX53_TVIN_PWR			(4*32 + 23)	/* GPIO_5_23 */
+#define MX53_CAN2_EN1			(4*32 + 24)	/* GPIO_5_24 */
+#define MX53_TVIN_RESET			(4*32 + 25)	/* GPIO_5_25 */
+
+#define EVK_OTG_VBUS			(5*32 + 6)	/* GPIO_6_6 */
+
+#define EVK_FEC_PHY_RESET		(6*32 + 6)	/* GPIO_7_6 */
+#define EVK_USBH1_VBUS			(6*32 + 8)	/* GPIO_7_8 */
+#define MX53_PMIC_INT			(6*32 + 11)	/* GPIO_7_11 */
+#define MX53_CAN1_EN1			(6*32 + 12)	/* GPIO_7_12 */
+#define MX53_CAN1_EN2			(6*32 + 13)	/* GPIO_7_13 */
+
+/*!
+ * @file mach-mx53/mx53_evk.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX53
+ */
+extern int __init mx53_evk_init_mc13892(void);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+extern void (*set_num_cpu_wp)(int num);
+static int num_cpu_wp = 3;
+
+static struct pad_desc mx53common_pads[] = {
+	MX53_PAD_EIM_WAIT__GPIO_5_0,
+
+	MX53_PAD_EIM_OE__DI1_PIN7,
+	MX53_PAD_EIM_RW__DI1_PIN8,
+
+	MX53_PAD_EIM_A25__DI0_D1_CS,
+
+	MX53_PAD_EIM_D16__CSPI1_SCLK,
+	MX53_PAD_EIM_D17__CSPI1_MISO,
+	MX53_PAD_EIM_D18__CSPI1_MOSI,
+
+	MX53_PAD_EIM_D20__SER_DISP0_CS,
+
+	MX53_PAD_EIM_D23__DI0_D0_CS,
+
+	MX53_PAD_EIM_D24__GPIO_3_24,
+	MX53_PAD_EIM_D26__GPIO_3_26,
+
+	MX53_PAD_EIM_D29__DISPB0_SER_RS,
+
+	MX53_PAD_EIM_D30__DI0_PIN11,
+	MX53_PAD_EIM_D31__DI0_PIN12,
+
+	MX53_PAD_ATA_DA_1__GPIO_7_7,
+	MX53_PAD_ATA_DATA4__GPIO_2_4,
+	MX53_PAD_ATA_DATA5__GPIO_2_5,
+	MX53_PAD_ATA_DATA6__GPIO_2_6,
+
+	MX53_PAD_SD2_CLK__SD2_CLK,
+	MX53_PAD_SD2_CMD__SD2_CMD,
+	MX53_PAD_SD2_DATA0__SD2_DAT0,
+	MX53_PAD_SD2_DATA1__SD2_DAT1,
+	MX53_PAD_SD2_DATA2__SD2_DAT2,
+	MX53_PAD_SD2_DATA3__SD2_DAT3,
+	MX53_PAD_ATA_DATA12__SD2_DAT4,
+	MX53_PAD_ATA_DATA13__SD2_DAT5,
+	MX53_PAD_ATA_DATA14__SD2_DAT6,
+	MX53_PAD_ATA_DATA15__SD2_DAT7,
+
+	MX53_PAD_CSI0_D10__UART1_TXD,
+	MX53_PAD_CSI0_D11__UART1_RXD,
+
+	MX53_PAD_ATA_BUFFER_EN__UART2_RXD,
+	MX53_PAD_ATA_DMARQ__UART2_TXD,
+	MX53_PAD_ATA_DIOR__UART2_RTS,
+	MX53_PAD_ATA_INTRQ__UART2_CTS,
+
+	MX53_PAD_ATA_CS_0__UART3_TXD,
+	MX53_PAD_ATA_CS_1__UART3_RXD,
+
+	MX53_PAD_KEY_COL0__AUD5_TXC,
+	MX53_PAD_KEY_ROW0__AUD5_TXD,
+	MX53_PAD_KEY_COL1__AUD5_TXFS,
+	MX53_PAD_KEY_ROW1__AUD5_RXD,
+
+	MX53_PAD_CSI0_D7__GPIO_5_25,
+
+	MX53_PAD_GPIO_2__MLBDAT,
+	MX53_PAD_GPIO_3__MLBCLK,
+
+	MX53_PAD_GPIO_6__MLBSIG,
+
+	MX53_PAD_GPIO_4__GPIO_1_4,
+	MX53_PAD_GPIO_7__GPIO_1_7,
+	MX53_PAD_GPIO_8__GPIO_1_8,
+
+	MX53_PAD_GPIO_10__GPIO_4_0,
+
+	MX53_PAD_KEY_COL2__TXCAN1,
+	MX53_PAD_KEY_ROW2__RXCAN1,
+
+	/* CAN1 -- EN */
+	MX53_PAD_GPIO_18__GPIO_7_13,
+	/* CAN1 -- STBY */
+	MX53_PAD_GPIO_17__GPIO_7_12,
+	/* CAN1 -- NERR */
+	MX53_PAD_GPIO_5__GPIO_1_5,
+
+	MX53_PAD_KEY_COL4__TXCAN2,
+	MX53_PAD_KEY_ROW4__RXCAN2,
+
+	/* CAN2 -- EN */
+	MX53_PAD_CSI0_D6__GPIO_5_24,
+	/* CAN2 -- STBY */
+	MX53_PAD_GPIO_14__GPIO_4_4,
+	/* CAN2 -- NERR */
+	MX53_PAD_CSI0_D4__GPIO_5_22,
+
+	MX53_PAD_GPIO_11__GPIO_4_1,
+	MX53_PAD_GPIO_12__GPIO_4_2,
+	MX53_PAD_GPIO_13__GPIO_4_3,
+	MX53_PAD_GPIO_16__GPIO_7_11,
+	MX53_PAD_GPIO_19__GPIO_4_5,
+
+	/* DI0 display clock */
+	MX53_PAD_DI0_DISP_CLK__DI0_DISP_CLK,
+
+	/* DI0 data enable */
+	MX53_PAD_DI0_PIN15__DI0_PIN15,
+	/* DI0 HSYNC */
+	MX53_PAD_DI0_PIN2__DI0_PIN2,
+	/* DI0 VSYNC */
+	MX53_PAD_DI0_PIN3__DI0_PIN3,
+
+	MX53_PAD_DISP0_DAT0__DISP0_DAT0,
+	MX53_PAD_DISP0_DAT1__DISP0_DAT1,
+	MX53_PAD_DISP0_DAT2__DISP0_DAT2,
+	MX53_PAD_DISP0_DAT3__DISP0_DAT3,
+	MX53_PAD_DISP0_DAT4__DISP0_DAT4,
+	MX53_PAD_DISP0_DAT5__DISP0_DAT5,
+	MX53_PAD_DISP0_DAT6__DISP0_DAT6,
+	MX53_PAD_DISP0_DAT7__DISP0_DAT7,
+	MX53_PAD_DISP0_DAT8__DISP0_DAT8,
+	MX53_PAD_DISP0_DAT9__DISP0_DAT9,
+	MX53_PAD_DISP0_DAT10__DISP0_DAT10,
+	MX53_PAD_DISP0_DAT11__DISP0_DAT11,
+	MX53_PAD_DISP0_DAT12__DISP0_DAT12,
+	MX53_PAD_DISP0_DAT13__DISP0_DAT13,
+	MX53_PAD_DISP0_DAT14__DISP0_DAT14,
+	MX53_PAD_DISP0_DAT15__DISP0_DAT15,
+	MX53_PAD_DISP0_DAT16__DISP0_DAT16,
+	MX53_PAD_DISP0_DAT17__DISP0_DAT17,
+	MX53_PAD_DISP0_DAT18__DISP0_DAT18,
+	MX53_PAD_DISP0_DAT19__DISP0_DAT19,
+	MX53_PAD_DISP0_DAT20__DISP0_DAT20,
+	MX53_PAD_DISP0_DAT21__DISP0_DAT21,
+	MX53_PAD_DISP0_DAT22__DISP0_DAT22,
+	MX53_PAD_DISP0_DAT23__DISP0_DAT23,
+
+	MX53_PAD_LVDS0_TX3_P__LVDS0_TX3,
+	MX53_PAD_LVDS0_CLK_P__LVDS0_CLK,
+	MX53_PAD_LVDS0_TX2_P__LVDS0_TX2,
+	MX53_PAD_LVDS0_TX1_P__LVDS0_TX1,
+	MX53_PAD_LVDS0_TX0_P__LVDS0_TX0,
+
+	MX53_PAD_LVDS1_TX3_P__LVDS1_TX3,
+	MX53_PAD_LVDS1_CLK_P__LVDS1_CLK,
+	MX53_PAD_LVDS1_TX2_P__LVDS1_TX2,
+	MX53_PAD_LVDS1_TX1_P__LVDS1_TX1,
+	MX53_PAD_LVDS1_TX0_P__LVDS1_TX0,
+
+	/* audio and CSI clock out */
+	MX53_PAD_GPIO_0__SSI_EXT1_CLK,
+
+	MX53_PAD_CSI0_D12__CSI0_D12,
+	MX53_PAD_CSI0_D13__CSI0_D13,
+	MX53_PAD_CSI0_D14__CSI0_D14,
+	MX53_PAD_CSI0_D15__CSI0_D15,
+	MX53_PAD_CSI0_D16__CSI0_D16,
+	MX53_PAD_CSI0_D17__CSI0_D17,
+	MX53_PAD_CSI0_D18__CSI0_D18,
+	MX53_PAD_CSI0_D19__CSI0_D19,
+
+	MX53_PAD_CSI0_VSYNC__CSI0_VSYNC,
+	MX53_PAD_CSI0_MCLK__CSI0_HSYNC,
+	MX53_PAD_CSI0_PIXCLK__CSI0_PIXCLK,
+	/* Camera low power */
+	MX53_PAD_CSI0_D5__GPIO_5_23,
+
+	/* esdhc1 */
+	MX53_PAD_SD1_CMD__SD1_CMD,
+	MX53_PAD_SD1_CLK__SD1_CLK,
+	MX53_PAD_SD1_DATA0__SD1_DATA0,
+	MX53_PAD_SD1_DATA1__SD1_DATA1,
+	MX53_PAD_SD1_DATA2__SD1_DATA2,
+	MX53_PAD_SD1_DATA3__SD1_DATA3,
+
+	/* esdhc3 */
+	MX53_PAD_ATA_DATA8__SD3_DAT0,
+	MX53_PAD_ATA_DATA9__SD3_DAT1,
+	MX53_PAD_ATA_DATA10__SD3_DAT2,
+	MX53_PAD_ATA_DATA11__SD3_DAT3,
+	MX53_PAD_ATA_DATA0__SD3_DAT4,
+	MX53_PAD_ATA_DATA1__SD3_DAT5,
+	MX53_PAD_ATA_DATA2__SD3_DAT6,
+	MX53_PAD_ATA_DATA3__SD3_DAT7,
+	MX53_PAD_ATA_RESET_B__SD3_CMD,
+	MX53_PAD_ATA_IORDY__SD3_CLK,
+
+	/* FEC pins */
+	MX53_PAD_FEC_MDIO__FEC_MDIO,
+	MX53_PAD_FEC_REF_CLK__FEC_REF_CLK,
+	MX53_PAD_FEC_RX_ER__FEC_RX_ER,
+	MX53_PAD_FEC_CRS_DV__FEC_CRS_DV,
+	MX53_PAD_FEC_RXD1__FEC_RXD1,
+	MX53_PAD_FEC_RXD0__FEC_RXD0,
+	MX53_PAD_FEC_TX_EN__FEC_TX_EN,
+	MX53_PAD_FEC_TXD1__FEC_TXD1,
+	MX53_PAD_FEC_TXD0__FEC_TXD0,
+	MX53_PAD_FEC_MDC__FEC_MDC,
+
+	MX53_PAD_CSI0_D8__I2C1_SDA,
+	MX53_PAD_CSI0_D9__I2C1_SCL,
+
+	MX53_PAD_KEY_COL3__I2C2_SCL,
+	MX53_PAD_KEY_ROW3__I2C2_SDA,
+};
+
+static struct pad_desc mx53evk_pads[] = {
+	/* USB OTG USB_OC */
+	MX53_PAD_EIM_A24__GPIO_5_4,
+
+	/* USB OTG USB_PWR */
+	MX53_PAD_EIM_A23__GPIO_6_6,
+
+	/* DISPB0_SER_CLK */
+	MX53_PAD_EIM_D21__DISPB0_SER_CLK,
+
+	/* DI0_PIN1 */
+	MX53_PAD_EIM_D22__DISPB0_SER_DIN,
+
+	/* DVI I2C ENABLE */
+	MX53_PAD_EIM_D28__GPIO_3_28,
+
+	/* DVI DET */
+	MX53_PAD_EIM_D31__GPIO_3_31,
+
+	/* SDHC1 SD_CD */
+	MX53_PAD_EIM_DA13__GPIO_3_13,
+
+	/* SDHC1 SD_WP */
+	MX53_PAD_EIM_DA14__GPIO_3_14,
+
+	/* SDHC3 SD_CD */
+	MX53_PAD_EIM_DA11__GPIO_3_11,
+
+	/* SDHC3 SD_WP */
+	MX53_PAD_EIM_DA12__GPIO_3_12,
+
+	/* PWM backlight */
+	MX53_PAD_GPIO_1__PWMO,
+
+	/* USB HOST USB_PWR */
+	MX53_PAD_ATA_DA_2__GPIO_7_8,
+
+	/* USB HOST USB_RST */
+	MX53_PAD_CSI0_DATA_EN__GPIO_5_20,
+
+	/* USB HOST CARD_ON */
+	MX53_PAD_EIM_DA15__GPIO_3_15,
+
+	/* USB HOST CARD_RST */
+	MX53_PAD_ATA_DATA7__GPIO_2_7,
+
+	/* USB HOST WAN_WAKE */
+	MX53_PAD_EIM_D25__GPIO_3_25,
+
+	/* FEC_RST */
+	MX53_PAD_ATA_DA_0__GPIO_7_6,
+};
+
+static struct pad_desc mx53arm2_pads[] = {
+	/* USB OTG USB_OC */
+	MX53_PAD_EIM_D21__GPIO_3_21,
+
+	/* USB OTG USB_PWR */
+	MX53_PAD_EIM_D22__GPIO_3_22,
+
+	/* SDHC1 SD_CD */
+	MX53_PAD_GPIO_1__GPIO_1_1,
+
+	/* gpio backlight */
+	MX53_PAD_DI0_PIN4__GPIO_4_20,
+};
+
+static struct pad_desc mx53_nand_pads[] = {
+	MX53_PAD_NANDF_CLE__NANDF_CLE,
+	MX53_PAD_NANDF_ALE__NANDF_ALE,
+	MX53_PAD_NANDF_WP_B__NANDF_WP_B,
+	MX53_PAD_NANDF_WE_B__NANDF_WE_B,
+	MX53_PAD_NANDF_RE_B__NANDF_RE_B,
+	MX53_PAD_NANDF_RB0__NANDF_RB0,
+	MX53_PAD_NANDF_CS0__NANDF_CS0,
+	MX53_PAD_NANDF_CS1__NANDF_CS1	,
+	MX53_PAD_NANDF_CS2__NANDF_CS2,
+	MX53_PAD_NANDF_CS3__NANDF_CS3	,
+	MX53_PAD_EIM_DA0__EIM_DA0,
+	MX53_PAD_EIM_DA1__EIM_DA1,
+	MX53_PAD_EIM_DA2__EIM_DA2,
+	MX53_PAD_EIM_DA3__EIM_DA3,
+	MX53_PAD_EIM_DA4__EIM_DA4,
+	MX53_PAD_EIM_DA5__EIM_DA5,
+	MX53_PAD_EIM_DA6__EIM_DA6,
+	MX53_PAD_EIM_DA7__EIM_DA7,
+};
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1150000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1050000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 160000000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+static struct fb_videomode video_modes[] = {
+	{
+	 /* NTSC TV output */
+	 "TV-NTSC", 60, 720, 480, 74074,
+	 122, 15,
+	 18, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED,
+	 0,},
+	{
+	 /* PAL TV output */
+	 "TV-PAL", 50, 720, 576, 74074,
+	 132, 11,
+	 22, 26,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 FB_VMODE_INTERLACED | FB_VMODE_ODD_FLD_FIRST,
+	 0,},
+	{
+	 "720P60", 60, 1280, 720, 13468,
+	 260, 109,
+	 25, 4,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT |
+			FB_SYNC_EXT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	 /* 800x480 @ 57 Hz , pixel clk @ 27MHz */
+	 "CLAA-WVGA", 57, 800, 480, 37037, 40, 60, 10, 10, 20, 10,
+	 FB_SYNC_CLK_LAT_FALL,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	/* 1600x1200 @ 60 Hz 162M pixel clk*/
+	"UXGA", 60, 1600, 1200, 6172,
+	304, 64,
+	1, 46,
+	192, 3,
+	FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT |
+	FB_SYNC_EXT,
+	FB_VMODE_NONINTERLACED,
+	0,},
+	{
+	 "1080P60", 60, 1920, 1080, 7692,
+	 100, 40,
+	 30, 3,
+	 10, 2,
+	 FB_SYNC_EXT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+	{
+	 "XGA", 60, 1024, 768, 15385,
+	 220, 40,
+	 21, 7,
+	 60, 10,
+	 FB_SYNC_EXT,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+struct cpu_wp *mx53_evk_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+void mx53_evk_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static struct mxc_w1_config mxc_w1_data = {
+	.search_rom_accelerator = 1,
+};
+
+static struct platform_pwm_backlight_data mxc_pwm_backlight_data = {
+	.pwm_id = 1,
+	.max_brightness = 255,
+	.dft_brightness = 128,
+	.pwm_period_ns = 78770,
+};
+
+static void flexcan_xcvr_enable(int id, int en)
+{
+	static int pwdn;
+	if (id < 0 || id > 1)
+		return;
+
+	if (en) {
+		if (!(pwdn++))
+			gpio_set_value(MX53_12V_EN, 1);
+
+		if (id == 0) {
+			gpio_set_value(MX53_CAN1_EN1, 1);
+			gpio_set_value(MX53_CAN1_EN2, 1);
+		} else {
+			gpio_set_value(MX53_CAN2_EN1, 1);
+			gpio_set_value(MX53_CAN2_EN2, 1);
+		}
+
+	} else {
+		if (!(--pwdn))
+			gpio_set_value(MX53_12V_EN, 0);
+
+		if (id == 0) {
+			gpio_set_value(MX53_CAN1_EN1, 0);
+			gpio_set_value(MX53_CAN1_EN2, 0);
+		} else {
+			gpio_set_value(MX53_CAN2_EN1, 0);
+			gpio_set_value(MX53_CAN2_EN2, 0);
+		}
+	}
+}
+
+static struct flexcan_platform_data flexcan0_data = {
+	.core_reg = NULL,
+	.io_reg = NULL,
+	.xcvr_enable = flexcan_xcvr_enable,
+	.br_clksrc = 1,
+	.br_rjw = 2,
+	.br_presdiv = 5,
+	.br_propseg = 5,
+	.br_pseg1 = 4,
+	.br_pseg2 = 7,
+	.bcc = 1,
+	.srx_dis = 1,
+	.smp = 1,
+	.boff_rec = 1,
+	.ext_msg = 1,
+	.std_msg = 1,
+};
+static struct flexcan_platform_data flexcan1_data = {
+	.core_reg = NULL,
+	.io_reg = NULL,
+	.xcvr_enable = flexcan_xcvr_enable,
+	.br_clksrc = 1,
+	.br_rjw = 2,
+	.br_presdiv = 5,
+	.br_propseg = 5,
+	.br_pseg1 = 4,
+	.br_pseg2 = 7,
+	.bcc = 1,
+	.srx_dis = 1,
+	.boff_rec = 1,
+	.ext_msg = 1,
+	.std_msg = 1,
+};
+
+
+extern void mx5_ipu_reset(void);
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 3,
+	.reset = mx5_ipu_reset,
+};
+
+extern void mx5_vpu_reset(void);
+static struct mxc_vpu_platform_data mxc_vpu_data = {
+	.reset = mx5_vpu_reset,
+};
+
+static struct fec_platform_data fec_data = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+/* workaround for ecspi chipselect pin may not keep correct level when idle */
+static void mx53_evk_gpio_spi_chipselect_active(int cspi_mode, int status,
+					     int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			{
+			struct pad_desc eim_d19_gpio = MX53_PAD_EIM_D19__GPIO_3_19;
+			struct pad_desc cspi_ss0 = MX53_PAD_EIM_EB2__CSPI_SS0;
+
+			/* de-select SS1 of instance: ecspi1. */
+			mxc_iomux_v3_setup_pad(&eim_d19_gpio);
+			mxc_iomux_v3_setup_pad(&cspi_ss0);
+			}
+			break;
+		case 0x2:
+			{
+			struct pad_desc eim_eb2_gpio = MX53_PAD_EIM_EB2__GPIO_2_30;
+			struct pad_desc cspi_ss1 = MX53_PAD_EIM_D19__CSPI_SS1;
+
+			/* de-select SS0 of instance: ecspi1. */
+			mxc_iomux_v3_setup_pad(&eim_eb2_gpio);
+			mxc_iomux_v3_setup_pad(&cspi_ss1);
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static void mx53_evk_gpio_spi_chipselect_inactive(int cspi_mode, int status,
+					       int chipselect)
+{
+	switch (cspi_mode) {
+	case 1:
+		switch (chipselect) {
+		case 0x1:
+			break;
+		case 0x2:
+			break;
+		default:
+			break;
+		}
+		break;
+	case 2:
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+}
+
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect = 4,
+	.spi_version = 23,
+	.chipselect_active = mx53_evk_gpio_spi_chipselect_active,
+	.chipselect_inactive = mx53_evk_gpio_spi_chipselect_inactive,
+};
+
+static struct mxc_i2c_platform_data mxci2c_data = {
+	.i2c_clk = 100000,
+};
+
+static struct mxc_srtc_platform_data srtc_data = {
+	.srtc_sec_mode_addr = 0x83F98840,
+};
+
+static struct mxc_dvfs_platform_data dvfs_core_data = {
+	.reg_id = "SW1",
+	.clk1_id = "cpu_clk",
+	.clk2_id = "gpc_dvfs_clk",
+	.gpc_cntr_reg_addr = MXC_GPC_CNTR,
+	.gpc_vcr_reg_addr = MXC_GPC_VCR,
+	.ccm_cdcr_reg_addr = MXC_CCM_CDCR,
+	.ccm_cacrr_reg_addr = MXC_CCM_CACRR,
+	.ccm_cdhipr_reg_addr = MXC_CCM_CDHIPR,
+	.prediv_mask = 0x1F800,
+	.prediv_offset = 11,
+	.prediv_val = 3,
+	.div3ck_mask = 0xE0000000,
+	.div3ck_offset = 29,
+	.div3ck_val = 2,
+	.emac_val = 0x08,
+	.upthr_val = 25,
+	.dnthr_val = 9,
+	.pncthr_val = 33,
+	.upcnt_val = 10,
+	.dncnt_val = 10,
+	.delay_time = 30,
+	.num_wp = 3,
+};
+
+static struct tve_platform_data tve_data = {
+	.dac_reg = "VVIDEO",
+};
+
+static struct ldb_platform_data ldb_data = {
+	.lvds_bg_reg = "VAUDIO",
+	.ext_ref = 1,
+};
+
+static struct pad_desc mx53esai_pads[] = {
+	MX53_PAD_FEC_MDIO__ESAI_SCKR,
+	MX53_PAD_FEC_REF_CLK__ESAI_FSR,
+	MX53_PAD_FEC_RX_ER__ESAI_HCKR,
+	MX53_PAD_FEC_CRS_DV__ESAI_SCKT,
+	MX53_PAD_FEC_RXD1__ESAI_FST,
+	MX53_PAD_FEC_RXD0__ESAI_HCKT,
+	MX53_PAD_FEC_TX_EN__ESAI_TX3_RX2,
+	MX53_PAD_FEC_TXD1__ESAI_TX2_RX3,
+	MX53_PAD_FEC_TXD0__ESAI_TX4_RX1,
+	MX53_PAD_FEC_MDC__ESAI_TX5_RX0,
+	MX53_PAD_NANDF_CS2__ESAI_TX0,
+	MX53_PAD_NANDF_CS3__ESAI_TX1,
+};
+
+void gpio_activate_esai_ports(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx53esai_pads,
+					ARRAY_SIZE(mx53esai_pads));
+}
+
+static struct mxc_esai_platform_data esai_data = {
+	.activate_esai_ports = gpio_activate_esai_ports,
+};
+
+void gpio_cs42888_pdwn(int pdwn)
+{
+	if (pdwn)
+		gpio_set_value(MX53_ESAI_RESET, 0);
+	else
+		gpio_set_value(MX53_ESAI_RESET, 1);
+}
+EXPORT_SYMBOL(gpio_cs42888_pdwn);
+
+static void gpio_usbotg_vbus_active(void)
+{
+	if (board_is_mx53_arm2()) {
+		/* MX53 ARM2 CPU board */
+		/* Enable OTG VBus with GPIO low */
+		gpio_set_value(ARM2_OTG_VBUS, 0);
+	} else  if (board_is_mx53_evk_a()) {
+		/* MX53 EVK board ver A*/
+		/* Enable OTG VBus with GPIO low */
+		gpio_set_value(EVK_OTG_VBUS, 0);
+	} else  if (board_is_mx53_evk_b()) {
+		/* MX53 EVK board ver B*/
+		/* Enable OTG VBus with GPIO high */
+		gpio_set_value(EVK_OTG_VBUS, 1);
+	}
+}
+
+static void gpio_usbotg_vbus_inactive(void)
+{
+	if (board_is_mx53_arm2()) {
+		/* MX53 ARM2 CPU board */
+		/* Disable OTG VBus with GPIO high */
+		gpio_set_value(ARM2_OTG_VBUS, 1);
+	} else  if (board_is_mx53_evk_a()) {
+		/* MX53 EVK board ver A*/
+		/* Disable OTG VBus with GPIO high */
+		gpio_set_value(EVK_OTG_VBUS, 1);
+	} else  if (board_is_mx53_evk_b()) {
+		/* MX53 EVK board ver B*/
+		/* Disable OTG VBus with GPIO low */
+		gpio_set_value(EVK_OTG_VBUS, 0);
+	}
+}
+
+static void mx53_gpio_usbotg_driver_vbus(bool on)
+{
+	if (on)
+		gpio_usbotg_vbus_active();
+	else
+		gpio_usbotg_vbus_inactive();
+}
+
+static void mx53_gpio_host1_driver_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(EVK_USBH1_VBUS, 1);
+	else
+		gpio_set_value(EVK_USBH1_VBUS, 0);
+}
+
+static void adv7180_pwdn(int pwdn)
+{
+	gpio_request(MX53_TVIN_PWR, "tvin-pwr");
+	gpio_direction_output(MX53_TVIN_PWR, 0);
+	if (pwdn)
+		gpio_set_value(MX53_TVIN_PWR, 0);
+	else
+		gpio_set_value(MX53_TVIN_PWR, 1);
+}
+
+static struct mxc_tvin_platform_data adv7180_data = {
+	.dvddio_reg = NULL,
+	.dvdd_reg = NULL,
+	.avdd_reg = NULL,
+	.pvdd_reg = NULL,
+	.pwdn = adv7180_pwdn,
+	.reset = NULL,
+};
+
+static struct resource mxcfb_resources[] = {
+	[0] = {
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB565,
+	 .mode_str = "CLAA-WVGA",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_BGR24,
+	 .mode_str = "1024x768M-16@60",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+};
+
+extern int primary_di;
+static int __init mxc_init_fb(void)
+{
+	if (!machine_is_mx53_evk())
+		return 0;
+
+	if (primary_di) {
+		printk(KERN_INFO "DI1 is primary\n");
+		/* DI1 -> DP-BG channel: */
+		mxc_fb_devices[1].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[1].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+
+		/* DI0 -> DC channel: */
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+	} else {
+		printk(KERN_INFO "DI0 is primary\n");
+
+		/* DI0 -> DP-BG channel: */
+		mxc_fb_devices[0].num_resources = ARRAY_SIZE(mxcfb_resources);
+		mxc_fb_devices[0].resource = mxcfb_resources;
+		mxc_register_device(&mxc_fb_devices[0], &fb_data[0]);
+
+		/* DI1 -> DC channel: */
+		mxc_register_device(&mxc_fb_devices[1], &fb_data[1]);
+	}
+
+	/*
+	 * DI0/1 DP-FG channel:
+	 */
+	mxc_register_device(&mxc_fb_devices[2], NULL);
+
+	return 0;
+}
+device_initcall(mxc_init_fb);
+
+static void camera_pwdn(int pwdn)
+{
+	gpio_request(MX53_TVIN_PWR, "tvin-pwr");
+	gpio_direction_output(MX53_TVIN_PWR, 0);
+	gpio_set_value(MX53_TVIN_PWR, pwdn);
+}
+
+static struct mxc_camera_platform_data camera_data = {
+	.analog_regulator = "VSD",
+	.mclk = 24000000,
+	.csi = 0,
+	.pwdn = camera_pwdn,
+};
+
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+	{
+	.type = "ov3640",
+	.addr = 0x3C,
+	.platform_data = (void *)&camera_data,
+	 },
+	{
+	.type = "adv7180",
+	.addr = 0x21,
+	.platform_data = (void *)&adv7180_data,
+	 },
+	{
+	 .type = "cs42888",
+	 .addr = 0x48,
+	 },
+};
+
+/* TO DO add platform data */
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "tsc2007",
+	 .addr = 0x48,
+	 .irq  = IOMUX_TO_IRQ_V3(EVK_TS_INT),
+	},
+	{
+	 .type = "backlight-i2c",
+	 .addr = 0x2c,
+	 },
+	{
+	 .type = "vga-ddc",
+	 .addr = 0x1f,
+	 },
+	{
+	 .type = "eeprom",
+	 .addr = 0x50,
+	 },
+};
+
+static struct mtd_partition mxc_dataflash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 0x000100000,},
+	{
+	 .name = "kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,},
+};
+
+static struct flash_platform_data mxc_spi_flash_data[] = {
+	{
+	 .name = "mxc_dataflash",
+	 .parts = mxc_dataflash_partitions,
+	 .nr_parts = ARRAY_SIZE(mxc_dataflash_partitions),
+	 .type = "at45db321d",}
+};
+
+
+static struct spi_board_info mxc_dataflash_device[] __initdata = {
+	{
+	 .modalias = "mxc_dataflash",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 1,
+	 .chip_select = 1,
+	 .platform_data = &mxc_spi_flash_data[0],},
+};
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (!board_is_mx53_arm2()) {
+		if (to_platform_device(dev)->id == 0)
+			rc = gpio_get_value(EVK_SD1_WP);
+		else
+			rc = gpio_get_value(EVK_SD3_WP);
+	}
+
+	return rc;
+}
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+	if (board_is_mx53_arm2()) {
+		if (to_platform_device(dev)->id == 0)
+			ret = gpio_get_value(ARM2_SD1_CD);
+		else
+			ret = 1;
+	} else {
+		if (to_platform_device(dev)->id == 0) {
+			ret = gpio_get_value(EVK_SD1_CD);
+		} else{		/* config the det pin for SDHC3 */
+			ret = gpio_get_value(EVK_SD3_CD);
+			}
+	}
+
+	return ret;
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+
+static struct mxc_mmc_platform_data mmc3_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30
+		| MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA
+		| MMC_CAP_DATA_DDR,
+	.min_clk = 400000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+/* return value 1 failure, 0 success */
+static int write_phy_ctl_ack_polling(u32 data, void __iomem *mmio,
+		int max_iterations, u32 exp_val)
+{
+	enum {
+		PORT_PHY_CTL 		= 0x178, /* Port0 PHY Control */
+		PORT_PHY_SR 		= 0x17c, /* Port0 PHY Status */
+		/* PORT_PHY_SR */
+		PORT_PHY_STAT_DATA_LOC 	= 0,
+		PORT_PHY_STAT_ACK_LOC 	= 18,
+	};
+	int i;
+	u32 val;
+
+	writel(data, mmio + PORT_PHY_CTL);
+
+	for (i = 0; i < max_iterations + 1; i++) {
+		val = readl(mmio + PORT_PHY_SR);
+		val =  (val >> PORT_PHY_STAT_ACK_LOC) & 0x1;
+		if (val == exp_val)
+			return 0;
+		if (i == max_iterations) {
+			printk(KERN_ERR "Wait for CR ACK error!\n");
+			return 1;
+		}
+		msleep(1);
+	}
+	return 0;
+}
+
+/* HW Initialization, if return 1, initialization is failed. */
+static int sata_init(struct device *dev)
+{
+	enum {
+		HOST_CAP		= 0x00,
+		HOST_CAP_SSS		= (1 << 27), /* Staggered Spin-up */
+		HOST_PORTS_IMPL		= 0x0c,
+		HOST_TIMER1MS 		= 0xe0, /* Timer 1-ms */
+		/* Offest used to control the MPLL input clk */
+		PHY_CR_CLOCK_FREQ_OVRD 	= 0x12,
+
+		PORT_PHY_CTL 		= 0x178, /* Port0 PHY Control */
+		/* PORT_PHY_CTL bits */
+		PORT_PHY_CTL_CAP_ADR_LOC 	= 0x10000,
+		PORT_PHY_CTL_CAP_DAT_LOC 	= 0x20000,
+		PORT_PHY_CTL_WRITE_LOC 		= 0x40000,
+	};
+	void __iomem *mmio;
+	struct clk *clk;
+	int rc = 0;
+	u32 tmpdata;
+
+	clk = clk_get(dev, "sata_clk");
+	clk_enable(clk);
+
+	mmio = ioremap(MX53_SATA_BASE_ADDR, SZ_4K);
+
+	tmpdata = readl(mmio + HOST_CAP);
+	if (!(tmpdata & HOST_CAP_SSS)) {
+		tmpdata |= HOST_CAP_SSS;
+		writel(tmpdata, mmio + HOST_CAP);
+	}
+
+	if (!(readl(mmio + HOST_PORTS_IMPL) & 0x1))
+		writel((readl(mmio + HOST_PORTS_IMPL) | 0x1),
+			mmio + HOST_PORTS_IMPL);
+
+	/* Get the AHB clock rate, and configure the TIMER1MS reg */
+	clk = clk_get(NULL, "ahb_clk");
+	tmpdata = clk_get_rate(clk) / 1000;
+	writel(tmpdata, mmio + HOST_TIMER1MS);
+
+	/* write addr */
+	tmpdata = PHY_CR_CLOCK_FREQ_OVRD;
+	writel(tmpdata, mmio + PORT_PHY_CTL);
+	/* capture addr */
+	tmpdata |= PORT_PHY_CTL_CAP_ADR_LOC;
+	/* Wait for ack */
+	if (write_phy_ctl_ack_polling(tmpdata, mmio, 100, 1)) {
+		rc = 1;
+		goto err0;
+	}
+
+	/* deassert cap data */
+	tmpdata &= 0xFFFF;
+	/* wait for ack de-assertion */
+	if (write_phy_ctl_ack_polling(tmpdata, mmio, 100, 0)) {
+		rc = 1;
+		goto err0;
+	}
+
+	/* write data */
+	/* Configure the PHY CLK input refer to different OSC
+	 * For 25MHz, pre[13,14]:01, ncy[12,8]:06,
+	 * ncy5[7,6]:02, int_ctl[5,3]:0, prop_ctl[2,0]:7.
+	 * For 50MHz, pre:00, ncy:06, ncy5:02, int_ctl:0, prop_ctl:7.
+	 */
+	/* EVK revA */
+	if (board_is_mx53_evk_a())
+		tmpdata = (0x1 << 15) | (0x1 << 13) | (0x6 << 8)
+			| (0x2 << 6) | 0x7;
+	/* EVK revB */
+	else if (board_is_mx53_evk_b())
+		tmpdata = (0x1 << 15) | (0x0 << 13) | (0x6 << 8)
+			| (0x2 << 6) | 0x7;
+
+	writel(tmpdata, mmio + PORT_PHY_CTL);
+	/* capture data */
+	tmpdata |= PORT_PHY_CTL_CAP_DAT_LOC;
+	/* wait for ack */
+	if (write_phy_ctl_ack_polling(tmpdata, mmio, 100, 1)) {
+		rc = 1;
+		goto err0;
+	}
+
+	/* deassert cap data */
+	tmpdata &= 0xFFFF;
+	/* wait for ack de-assertion */
+	if (write_phy_ctl_ack_polling(tmpdata, mmio, 100, 0)) {
+		rc = 1;
+		goto err0;
+	}
+
+	/* assert wr signal and wait for ack */
+	if (write_phy_ctl_ack_polling(PORT_PHY_CTL_WRITE_LOC, mmio, 100, 1)) {
+		rc = 1;
+		goto err0;
+	}
+	/* deassert rd _signal and wait for ack de-assertion */
+	if (write_phy_ctl_ack_polling(0, mmio, 100, 0)) {
+		rc = 1;
+		goto err0;
+	}
+
+	msleep(10);
+
+err0:
+	iounmap(mmio);
+	return rc;
+}
+
+static void sata_exit(struct device *dev)
+{
+	struct clk *clk;
+
+	clk = clk_get(dev, "sata_clk");
+	clk_disable(clk);
+	clk_put(clk);
+}
+
+static struct ahci_platform_data sata_data = {
+	.init = sata_init,
+	.exit = sata_exit,
+};
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+/* TO DO */
+return 0;
+}
+
+static int headphone_det_status(void)
+{
+	return (gpio_get_value(MX53_HP_DETECT) == 0);
+}
+
+static int mxc_sgtl5000_init(void);
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 5,
+	.hp_irq = IOMUX_TO_IRQ(MX53_HP_DETECT),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.init = mxc_sgtl5000_init,
+};
+
+static int mxc_sgtl5000_init(void)
+{
+	struct clk *ssi_ext1;
+	int rate;
+
+	if (board_is_mx53_arm2()) {
+		sgtl5000_data.sysclk = 12000000;
+	} else {
+		ssi_ext1 = clk_get(NULL, "ssi_ext1_clk");
+		if (IS_ERR(ssi_ext1))
+			return -1;
+
+		rate = clk_round_rate(ssi_ext1, 24000000);
+		if (rate < 8000000 || rate > 27000000) {
+			printk(KERN_ERR "Error: SGTL5000 mclk freq %d out of range!\n",
+			       rate);
+			clk_put(ssi_ext1);
+			return -1;
+		}
+
+		clk_set_rate(ssi_ext1, rate);
+		clk_enable(ssi_ext1);
+		sgtl5000_data.sysclk = rate;
+	}
+
+	return 0;
+}
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+};
+
+static struct mxc_mlb_platform_data mlb_data = {
+	.reg_nvcc = "VCAM",
+	.mlb_clk = "mlb_clk",
+};
+
+/* NAND Flash Partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition nand_flash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 3 * 1024 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 5 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs1",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs2",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+#endif
+
+static int nand_init(void)
+{
+	u32 i, reg;
+	void __iomem *base;
+
+	#define M4IF_GENP_WEIM_MM_MASK          0x00000001
+	#define WEIM_GCR2_MUX16_BYP_GRANT_MASK  0x00001000
+
+	base = ioremap(MX53_BASE_ADDR(M4IF_BASE_ADDR), SZ_4K);
+	reg = __raw_readl(base + 0xc);
+	reg &= ~M4IF_GENP_WEIM_MM_MASK;
+	__raw_writel(reg, base + 0xc);
+
+	iounmap(base);
+
+	base = ioremap(MX53_BASE_ADDR(WEIM_BASE_ADDR), SZ_4K);
+	for (i = 0x4; i < 0x94; i += 0x18) {
+		reg = __raw_readl((u32)base + i);
+		reg &= ~WEIM_GCR2_MUX16_BYP_GRANT_MASK;
+		__raw_writel(reg, (u32)base + i);
+	}
+
+	iounmap(base);
+
+	return 0;
+}
+
+static struct flash_platform_data mxc_nand_data = {
+#ifdef CONFIG_MTD_PARTITIONS
+	.parts = nand_flash_partitions,
+	.nr_parts = ARRAY_SIZE(nand_flash_partitions),
+#endif
+	.width = 1,
+	.init = nand_init,
+};
+
+static struct mxc_spdif_platform_data mxc_spdif_data = {
+	.spdif_tx = 1,
+	.spdif_rx = 0,
+	.spdif_clk_44100 = 0,	/* Souce from CKIH1 for 44.1K */
+	.spdif_clk_48000 = 7,	/* Source from CKIH2 for 48k and 32k */
+	.spdif_clkid = 0,
+	.spdif_clk = NULL,	/* spdif bus clk */
+};
+
+static struct mxc_audio_platform_data mxc_surround_audio_data = {
+	.ext_ram = 1,
+};
+
+
+static struct platform_device mxc_alsa_surround_device = {
+	.name = "imx-3stack-cs42888",
+};
+
+static int __initdata mxc_apc_on = { 0 };	/* OFF: 0 (default), ON: 1 */
+static int __init apc_setup(char *__unused)
+{
+	mxc_apc_on = 1;
+	printk(KERN_INFO "Automotive Port Card is Plugged on\n");
+	return 1;
+}
+__setup("apc", apc_setup);
+
+static int __initdata enable_w1 = { 0 };
+static int __init w1_setup(char *__unused)
+{
+	enable_w1 = 1;
+	return cpu_is_mx53();
+}
+__setup("w1", w1_setup);
+
+
+static int __initdata enable_spdif = { 0 };
+static int __init spdif_setup(char *__unused)
+{
+	enable_spdif = 1;
+	return 1;
+}
+__setup("spdif", spdif_setup);
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	struct tag *t;
+	struct tag *mem_tag = 0;
+	int total_mem = SZ_1G;
+	int left_mem = 0;
+	int gpu_mem = SZ_128M;
+	int fb_mem = SZ_32M;
+	char *str;
+
+	mxc_set_cpu_type(MXC_CPU_MX53);
+
+	get_cpu_wp = mx53_evk_get_cpu_wp;
+	set_num_cpu_wp = mx53_evk_set_num_cpu_wp;
+
+	for_each_tag(mem_tag, tags) {
+		if (mem_tag->hdr.tag == ATAG_MEM) {
+			total_mem = mem_tag->u.mem.size;
+			left_mem = total_mem - gpu_mem - fb_mem;
+			break;
+		}
+	}
+
+	for_each_tag(t, tags) {
+		if (t->hdr.tag == ATAG_CMDLINE) {
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "mem=");
+			if (str != NULL) {
+				str += 4;
+				left_mem = memparse(str, &str);
+				if (left_mem == 0 || left_mem > total_mem)
+					left_mem = total_mem - gpu_mem - fb_mem;
+			}
+
+			str = t->u.cmdline.cmdline;
+			str = strstr(str, "gpu_memory=");
+			if (str != NULL) {
+				str += 11;
+				gpu_mem = memparse(str, &str);
+			}
+
+			break;
+		}
+	}
+
+	if (mem_tag) {
+		fb_mem = total_mem - left_mem - gpu_mem;
+		if (fb_mem < 0) {
+			gpu_mem = total_mem - left_mem;
+			fb_mem = 0;
+		}
+		mem_tag->u.mem.size = left_mem;
+
+		/*reserve memory for gpu*/
+		gpu_device.resource[5].start =
+				mem_tag->u.mem.start + left_mem;
+		gpu_device.resource[5].end =
+				gpu_device.resource[5].start + gpu_mem - 1;
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+		if (fb_mem) {
+			mxcfb_resources[0].start =
+				gpu_device.resource[5].end + 1;
+			mxcfb_resources[0].end =
+				mxcfb_resources[0].start + fb_mem - 1;
+		} else {
+			mxcfb_resources[0].start = 0;
+			mxcfb_resources[0].end = 0;
+		}
+#endif
+	}
+}
+
+static void __init mx53_evk_io_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx53common_pads,
+					ARRAY_SIZE(mx53common_pads));
+
+	if (board_is_mx53_arm2()) {
+		/* MX53 ARM2 CPU board */
+		pr_info("MX53 ARM2 board \n");
+		mxc_iomux_v3_setup_multiple_pads(mx53arm2_pads,
+					ARRAY_SIZE(mx53arm2_pads));
+
+		/* Config GPIO for OTG VBus */
+		gpio_request(ARM2_OTG_VBUS, "otg-vbus");
+		gpio_direction_output(ARM2_OTG_VBUS, 1);
+
+		gpio_request(ARM2_SD1_CD, "sdhc1-cd");
+		gpio_direction_input(ARM2_SD1_CD);	/* SD1 CD */
+
+		gpio_request(ARM2_LCD_CONTRAST, "lcd-contrast");
+		gpio_direction_output(ARM2_LCD_CONTRAST, 1);
+	} else {
+		/* MX53 EVK board */
+		pr_info("MX53 EVK board \n");
+		mxc_iomux_v3_setup_multiple_pads(mx53evk_pads,
+					ARRAY_SIZE(mx53evk_pads));
+
+		/* Host1 Vbus with GPIO high */
+		gpio_request(EVK_USBH1_VBUS, "usbh1-vbus");
+		gpio_direction_output(EVK_USBH1_VBUS, 1);
+		/* shutdown the Host1 Vbus when system bring up,
+		* Vbus will be opened in Host1 driver's probe function */
+		gpio_set_value(EVK_USBH1_VBUS, 0);
+
+		/* USB HUB RESET - De-assert USB HUB RESET_N */
+		gpio_request(EVK_USB_HUB_RESET, "usb-hub-reset");
+		gpio_direction_output(EVK_USB_HUB_RESET, 0);
+		msleep(1);
+		gpio_set_value(EVK_USB_HUB_RESET, 1);
+
+		/* Config GPIO for OTG VBus */
+		gpio_request(EVK_OTG_VBUS, "otg-vbus");
+		gpio_direction_output(EVK_OTG_VBUS, 0);
+		if (board_is_mx53_evk_a()) /*rev A,"1" disable, "0" enable vbus*/
+			gpio_set_value(EVK_OTG_VBUS, 1);
+		else if (board_is_mx53_evk_b()) /* rev B,"0" disable,"1" enable Vbus*/
+			gpio_set_value(EVK_OTG_VBUS, 0);
+
+		gpio_request(EVK_SD1_CD, "sdhc1-cd");
+		gpio_direction_input(EVK_SD1_CD);	/* SD1 CD */
+		gpio_request(EVK_SD1_WP, "sdhc1-wp");
+		gpio_direction_input(EVK_SD1_WP);	/* SD1 WP */
+
+		/* SD3 CD */
+		gpio_request(EVK_SD3_CD, "sdhc3-cd");
+		gpio_direction_input(EVK_SD3_CD);
+
+		/* SD3 WP */
+		gpio_request(EVK_SD3_WP, "sdhc3-wp");
+		gpio_direction_input(EVK_SD3_WP);
+
+		/* reset FEC PHY */
+		gpio_request(EVK_FEC_PHY_RESET, "fec-phy-reset");
+		gpio_direction_output(EVK_FEC_PHY_RESET, 0);
+		msleep(1);
+		gpio_set_value(EVK_FEC_PHY_RESET, 1);
+
+		gpio_request(MX53_ESAI_RESET, "fesai-reset");
+		gpio_direction_output(MX53_ESAI_RESET, 0);
+	}
+
+	/* DVI Detect */
+	gpio_request(MX53_DVI_DETECT, "dvi-detect");
+	gpio_direction_input(MX53_DVI_DETECT);
+	/* DVI Reset - Assert for i2c disabled mode */
+	gpio_request(MX53_DVI_RESET, "dvi-reset");
+	gpio_set_value(MX53_DVI_RESET, 0);
+
+	/* DVI Power-down */
+	gpio_request(MX53_DVI_PD, "dvi-pd");
+	gpio_direction_output(MX53_DVI_PD, 1);
+
+	/* DVI I2C enable */
+	gpio_request(MX53_DVI_I2C, "dvi-i2c");
+	gpio_direction_output(MX53_DVI_I2C, 0);
+
+	mxc_iomux_v3_setup_multiple_pads(mx53_nand_pads,
+					ARRAY_SIZE(mx53_nand_pads));
+
+	gpio_request(MX53_PMIC_INT, "pmic-int");
+	gpio_direction_input(MX53_PMIC_INT);	/*PMIC_INT*/
+
+	/* headphone_det_b */
+	gpio_request(MX53_HP_DETECT, "hp-detect");
+	gpio_direction_input(MX53_HP_DETECT);
+
+	/* power key */
+
+	/* LCD related gpio */
+
+	/* Camera reset */
+	gpio_request(MX53_CAM_RESET, "cam-reset");
+	gpio_direction_output(MX53_CAM_RESET, 1);
+
+	/* TVIN reset */
+	gpio_request(MX53_TVIN_RESET, "tvin-reset");
+	gpio_direction_output(MX53_TVIN_RESET, 0);
+	msleep(5);
+	gpio_set_value(MX53_TVIN_RESET, 1);
+
+	/* CAN1 enable GPIO*/
+	gpio_request(MX53_CAN1_EN1, "can1-en1");
+	gpio_direction_output(MX53_CAN1_EN1, 0);
+
+	gpio_request(MX53_CAN1_EN2, "can1-en2");
+	gpio_direction_output(MX53_CAN1_EN2, 0);
+
+	/* CAN2 enable GPIO*/
+	gpio_request(MX53_CAN2_EN1, "can2-en1");
+	gpio_direction_output(MX53_CAN2_EN1, 0);
+
+	gpio_request(MX53_CAN2_EN2, "can2-en2");
+	gpio_direction_output(MX53_CAN2_EN2, 0);
+
+	if (enable_spdif) {
+		struct pad_desc spdif_pin = MX53_PAD_GPIO_19__SPDIF_TX1;
+		mxc_iomux_v3_setup_pad(&spdif_pin);
+	} else {
+		/* GPIO for 12V */
+		gpio_request(MX53_12V_EN, "12v-en");
+		gpio_direction_output(MX53_12V_EN, 0);
+	}
+}
+
+extern void mx53_gpio_usbotg_driver_vbus(bool on);
+extern void mx53_gpio_host1_driver_vbus(bool on);
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
+	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
+	mxc_ipu_data.csi_clk[0] = clk_get(NULL, "ssi_ext_clk1");
+	mxc_spdif_data.spdif_core_clk = clk_get(NULL, "spdif_xtal_clk");
+	clk_put(mxc_spdif_data.spdif_core_clk);
+
+	/* SD card detect irqs */
+	if (board_is_mx53_arm2()) {
+		mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ_V3(ARM2_SD1_CD);
+		mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ_V3(ARM2_SD1_CD);
+		mmc3_data.card_inserted_state = 1;
+		mmc3_data.status = NULL;
+		mmc3_data.wp_status = NULL;
+		mmc1_data.wp_status = NULL;
+	} else {
+		mxcsdhc3_device.resource[2].start = IOMUX_TO_IRQ_V3(EVK_SD3_CD);
+		mxcsdhc3_device.resource[2].end = IOMUX_TO_IRQ_V3(EVK_SD3_CD);
+		mxcsdhc1_device.resource[2].start = IOMUX_TO_IRQ_V3(EVK_SD1_CD);
+		mxcsdhc1_device.resource[2].end = IOMUX_TO_IRQ_V3(EVK_SD1_CD);
+	}
+
+	mxc_cpu_common_init();
+	mx53_evk_io_init();
+
+	mxc_register_device(&mxc_dma_device, NULL);
+	mxc_register_device(&mxc_wdt_device, NULL);
+	mxc_register_device(&mxcspi1_device, &mxcspi1_data);
+	mxc_register_device(&mxci2c_devices[0], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[1], &mxci2c_data);
+	mxc_register_device(&mxci2c_devices[2], &mxci2c_data);
+
+	mxc_register_device(&mxc_rtc_device, &srtc_data);
+	mxc_register_device(&mxc_w1_master_device, &mxc_w1_data);
+	mxc_register_device(&mxc_ipu_device, &mxc_ipu_data);
+	mxc_register_device(&mxc_ldb_device, &ldb_data);
+	mxc_register_device(&mxc_tve_device, &tve_data);
+	mxc_register_device(&mxcvpu_device, &mxc_vpu_data);
+	mxc_register_device(&gpu_device, NULL);
+	mxc_register_device(&mxcscc_device, NULL);
+	/*
+	mxc_register_device(&mx53_lpmode_device, NULL);
+	mxc_register_device(&busfreq_device, NULL);
+	mxc_register_device(&sdram_autogating_device, NULL);
+	*/
+	mxc_register_device(&mxc_dvfs_core_device, &dvfs_core_data);
+	mxc_register_device(&busfreq_device, NULL);
+
+	/*
+	mxc_register_device(&mxc_dvfs_per_device, &dvfs_per_data);
+	*/
+
+	mxc_register_device(&mxc_iim_device, NULL);
+	if (!board_is_mx53_arm2()) {
+		mxc_register_device(&mxc_pwm2_device, NULL);
+		mxc_register_device(&mxc_pwm_backlight_device, &mxc_pwm_backlight_data);
+	}
+	mxc_register_device(&mxc_flexcan0_device, &flexcan0_data);
+	mxc_register_device(&mxc_flexcan1_device, &flexcan1_data);
+
+/*	mxc_register_device(&mxc_keypad_device, &keypad_plat_data); */
+
+	mxc_register_device(&mxcsdhc1_device, &mmc1_data);
+	mxc_register_device(&mxcsdhc3_device, &mmc3_data);
+	mxc_register_device(&mxc_ssi1_device, NULL);
+	mxc_register_device(&mxc_ssi2_device, NULL);
+	mxc_register_device(&ahci_fsl_device, &sata_data);
+	mxc_register_device(&mxc_alsa_spdif_device, &mxc_spdif_data);
+	if (!mxc_apc_on)
+		mxc_register_device(&mxc_fec_device, &fec_data);
+	spi_register_board_info(mxc_dataflash_device,
+				ARRAY_SIZE(mxc_dataflash_device));
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+				ARRAY_SIZE(mxc_i2c0_board_info));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+
+	mx53_evk_init_mc13892();
+/*
+	pm_power_off = mxc_power_off;
+	*/
+	mxc_register_device(&mxc_sgtl5000_device, &sgtl5000_data);
+	mxc_register_device(&mxc_mlb_device, &mlb_data);
+	mx5_set_otghost_vbus_func(mx53_gpio_usbotg_driver_vbus);
+	mx5_usb_dr_init();
+	mx5_set_host1_vbus_func(mx53_gpio_host1_driver_vbus);
+	mx5_usbh1_init();
+	mxc_register_device(&mxc_nandv2_mtd_device, &mxc_nand_data);
+	if (mxc_apc_on) {
+		mxc_register_device(&mxc_esai_device, &esai_data);
+		mxc_register_device(&mxc_alsa_surround_device,
+			&mxc_surround_audio_data);
+	}
+	mxc_register_device(&mxc_v4l2_device, NULL);
+	mxc_register_device(&mxc_v4l2out_device, NULL);
+}
+
+static void __init mx53_evk_timer_init(void)
+{
+	struct clk *uart_clk;
+
+	mx53_clocks_init(32768, 24000000, 22579200, 24576000);
+
+	uart_clk = clk_get_sys("mxcintuart.0", NULL);
+	early_console_setup(MX53_BASE_ADDR(UART1_BASE_ADDR), uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx53_evk_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX53_EVK data structure.
+ */
+MACHINE_START(MX53_EVK, "Freescale MX53 EVK Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.fixup = fixup_mxc_board,
+	.map_io = mx5_map_io,
+	.init_irq = mx5_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c b/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c
new file mode 100644
index 0000000..445ab10
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_evk_pmic_mc13892.c
@@ -0,0 +1,347 @@
+/*
+ * mx53-evk-pmic-mc13892.c  --  i.MX53 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+
+#include <mach/iomux-mx53.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define STANDBYSECINV_LSH 11
+#define STANDBYSECINV_WID 1
+
+/* Coin cell charger enable */
+#define COINCHEN_LSH	23
+#define COINCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+/*!
+ * the event handler for power on event
+ */
+static void power_on_evt_handler(void)
+{
+	pr_info("pwr on event1 is received \n");
+}
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value;
+	pmic_event_callback_t power_key_event;
+	int register_mask;
+
+	pr_info("Initializing regulators for MX53 EVK \n");
+
+	/* subscribe PWRON1 event to enable ON_OFF key */
+	power_key_event.param = NULL;
+	power_key_event.func = (void *)power_on_evt_handler;
+	pmic_event_subscribe(EVENT_PWRONI, power_key_event);
+
+	/* Bit 4 DRM: keep VSRTC and CLK32KMCU on for all states */
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+	/* Set the STANDBYSECINV bit, so that STANDBY pin is
+	 * interpreted as active low.
+	 */
+	value = BITFVAL(STANDBYSECINV, 1);
+	register_mask = BITFMASK(STANDBYSECINV);
+	pmic_write_reg(REG_POWER_CTL2, value, register_mask);
+
+	/* Disable coin cell charger since the cell is not rechargeable */
+	value = BITFVAL(COINCHEN, 0) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(COINCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq = IOMUX_TO_IRQ_V3(203),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx53_evk_init_mc13892(void)
+{
+	return i2c_register_board_info(1, &mc13892_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx5/pm.c b/arch/arm/mach-mx5/pm.c
new file mode 100644
index 0000000..f9a1988
--- /dev/null
+++ b/arch/arm/mach-mx5/pm.c
@@ -0,0 +1,251 @@
+/*
+ *  Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include <linux/proc_fs.h>
+#include <linux/cpufreq.h>
+#include <linux/iram_alloc.h>
+#include <asm/cacheflush.h>
+#include <asm/tlb.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
+
+#define MXC_SRPG_EMPGC0_SRPGCR	(IO_ADDRESS(GPC_BASE_ADDR) + 0x2C0)
+#define MXC_SRPG_EMPGC1_SRPGCR	(IO_ADDRESS(GPC_BASE_ADDR) + 0x2D0)
+#define DATABAHN_CTL_REG0	0
+#define DATABAHN_CTL_REG19	0x4c
+#define DATABAHN_CTL_REG79	0x13c
+#define DATABAHN_PHY_REG25	0x264
+
+static struct cpu_wp *cpu_wp_tbl;
+static struct clk *cpu_clk;
+
+#if defined(CONFIG_CPU_FREQ)
+static int org_freq;
+extern int cpufreq_suspended;
+extern int set_cpu_freq(int wp);
+#endif
+
+
+static struct device *pm_dev;
+struct clk *gpc_dvfs_clk;
+extern void cpu_do_suspend_workaround(u32 sdclk_iomux_addr);
+extern void mx50_suspend(u32 databahn_addr);
+extern struct cpu_wp *(*get_cpu_wp)(int *wp);
+
+extern int iram_ready;
+void *suspend_iram_base;
+void (*suspend_in_iram)(void *sdclk_iomux_addr) = NULL;
+void __iomem *suspend_param1;
+u32 *suspend_param;
+
+static int mx5_suspend_enter(suspend_state_t state)
+{
+	if (gpc_dvfs_clk == NULL)
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	/* gpc clock is needed for SRPG */
+	clk_enable(gpc_dvfs_clk);
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (tzic_enable_wake(0) != 0)
+		return -EAGAIN;
+
+	if (state == PM_SUSPEND_MEM) {
+		local_flush_tlb_all();
+		flush_cache_all();
+
+		if (cpu_is_mx51()) {
+			/* Run the suspend code from iRAM. */
+			suspend_in_iram(suspend_param1);
+
+			/*clear the EMPGC0/1 bits */
+			__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
+			__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+		} else
+			local_flush_tlb_all();
+			flush_cache_all();
+
+			suspend_in_iram(suspend_param);
+	} else {
+			cpu_do_idle();
+	}
+	clk_disable(gpc_dvfs_clk);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx5_suspend_prepare(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+	struct cpufreq_freqs freqs;
+	org_freq = clk_get_rate(cpu_clk);
+	freqs.old = org_freq / 1000;
+	freqs.new = cpu_wp_tbl[0].cpu_rate / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+	cpufreq_suspended = 1;
+	if (clk_get_rate(cpu_clk) != cpu_wp_tbl[0].cpu_rate) {
+		set_cpu_freq(cpu_wp_tbl[0].cpu_rate);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Called before devices are re-setup.
+ */
+static void mx5_suspend_finish(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+	struct cpufreq_freqs freqs;
+
+	freqs.old = clk_get_rate(cpu_clk) / 1000;
+	freqs.new = org_freq / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+	cpufreq_suspended = 0;
+
+	if (org_freq != clk_get_rate(cpu_clk)) {
+		set_cpu_freq(org_freq);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx5_suspend_end(void)
+{
+}
+
+static int mx5_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx5_suspend_ops = {
+	.valid = mx5_pm_valid,
+	.prepare = mx5_suspend_prepare,
+	.enter = mx5_suspend_enter,
+	.finish = mx5_suspend_finish,
+	.end = mx5_suspend_end,
+};
+
+
+static int __devinit mx5_pm_probe(struct platform_device *pdev)
+{
+	pm_dev = &pdev->dev;
+	return 0;
+}
+
+static struct platform_driver mx5_pm_driver = {
+	.driver = {
+		   .name = "mx5_pm",
+		   },
+	.probe = mx5_pm_probe,
+};
+
+static int __init pm_init(void)
+{
+	int cpu_wp_nr;
+	unsigned long iram_paddr, iram_paddr1;
+
+	pr_info("Static Power Management for Freescale i.MX5\n");
+	if (platform_driver_register(&mx5_pm_driver) != 0) {
+		printk(KERN_ERR "mx5_pm_driver register failed\n");
+		return -ENODEV;
+	}
+	suspend_set_ops(&mx5_suspend_ops);
+	/* Move suspend routine into iRAM */
+	iram_alloc(SZ_4K, &iram_paddr);
+	/* Need to remap the area here since we want the memory region
+		 to be executable. */
+	suspend_iram_base = __arm_ioremap(iram_paddr, SZ_4K,
+					  MT_HIGH_VECTORS);
+	suspend_param = (u32 *)iram_alloc(SZ_4K, &iram_paddr1);
+
+	if (cpu_is_mx51()) {
+		suspend_param1 = IO_ADDRESS(IOMUXC_BASE_ADDR + 0x4b8);
+		memcpy(suspend_iram_base, cpu_do_suspend_workaround,
+				SZ_4K);
+	} else if (cpu_is_mx50()) {
+		/*
+		 * Need to run the suspend code from IRAM as the DDR needs
+		 * to be put into self refresh mode manually.
+		 */
+		memcpy(suspend_iram_base, mx50_suspend, SZ_4K);
+		suspend_param1 = ioremap(MX50_DATABAHN_BASE_ADDR, SZ_4K);
+		/* DDR Controller [0] */
+		*suspend_param = (u32)suspend_param1 +
+								DATABAHN_CTL_REG0;
+		/* DDR Controller [19] */
+		*(suspend_param + 1) = (u32)suspend_param1 +
+								DATABAHN_CTL_REG19;
+		/* DDR Controller [79] */
+		*(suspend_param + 2) = (u32)suspend_param1 +
+								DATABAHN_CTL_REG79;
+		/* DDR Controller PHY [25] */
+		*(suspend_param + 3) = (u32)suspend_param1 +
+								DATABAHN_PHY_REG25;
+	}
+	suspend_in_iram = (void *)suspend_iram_base;
+
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+	printk(KERN_INFO "PM driver module loaded\n");
+
+	return 0;
+}
+
+
+static void __exit pm_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx5_pm_driver);
+}
+
+module_init(pm_init);
+module_exit(pm_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("PM driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/sdma_script_code.h b/arch/arm/mach-mx5/sdma_script_code.h
new file mode 100644
index 0000000..2accca7
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS15_ELVIS"
+
+*******************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR	0
+#define start_SIZE	24
+
+#define core_ADDR	80
+#define core_SIZE	232
+
+#define common_ADDR	312
+#define common_SIZE	330
+
+#define ap_2_ap_ADDR	642
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	683
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	747
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	817
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	892
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	961
+#define mcu_2_shp_SIZE	72
+
+#define app_2_per_ADDR	1033
+#define app_2_per_SIZE	66
+
+#define per_2_app_ADDR	1099
+#define per_2_app_SIZE	74
+
+#define per_2_shp_ADDR	1173
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1251
+#define shp_2_per_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1323
+#define uartsh_2_mcu_SIZE	69
+
+#define mcu_2_ata_ADDR	1392
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1473
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1569
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1796
+#define test_SIZE	63
+
+#define signature_ADDR	1023
+#define signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define ext_mem__ipu_ram_ADDR	6144
+#define ext_mem__ipu_ram_SIZE	123
+
+#define mcu_2_spdif_ADDR	6267
+#define mcu_2_spdif_SIZE	59
+
+#define uart_2_per_ADDR	6326
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6399
+#define uartsh_2_per_SIZE	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			322
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0x0e70, 0x0611, 0x5616, 0xc13c, 0x7d2a, 0x5ade, 0x008e, 0xc14e,
+	0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5,
+	0xd84f, 0x982b, 0x6b05, 0xc681, 0x7e27, 0x7f29, 0x982b, 0x6d01,
+	0x03df, 0x7d05, 0x6bd5, 0xc6ab, 0x7e18, 0x7f1a, 0x982b, 0x6b05,
+	0xc621, 0x7e07, 0x7f06, 0x52de, 0x53e6, 0xc159, 0x7dd7, 0x0200,
+	0x9803, 0x0007, 0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc256,
+	0x048b, 0x0498, 0x0454, 0x068a, 0x982b, 0x0207, 0x680c, 0x6ddf,
+	0x0107, 0x68ff, 0x60d0, 0x9834, 0x0207, 0x68ff, 0x6d28, 0x0107,
+	0x6004, 0x680c, 0x9834, 0x0007, 0x68ff, 0x60d0, 0x9834, 0x0288,
+	0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da,
+	0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804,
+	0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf,
+	0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb,
+	0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3,
+	0x65ff, 0x7ed1, 0x0006, 0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a01,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x56fb, 0x0478,
+	0x7d28, 0x0479, 0x7c16, 0x0015, 0x0015, 0x0388, 0x620a, 0x0808,
+	0x7801, 0x0217, 0x5a06, 0x7f1d, 0x620a, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f17, 0x2301, 0x4b00, 0x7cf1, 0x0b70, 0x0311, 0x5313,
+	0x98aa, 0x0015, 0x0015, 0x0015, 0x7804, 0x620b, 0x5a06, 0x620b,
+	0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa, 0x57db,
+	0x9880, 0x0007, 0x680c, 0xc213, 0xc20a, 0x987d, 0xc1e3, 0x57db,
+	0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269,
+	0x7d1e, 0x1e94, 0x6ee3, 0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3,
+	0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27,
+	0x6ac8, 0x7f23, 0x2501, 0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3,
+	0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x62d0, 0xc27a, 0x98fb, 0x6ee3,
+	0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e,
+	0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000,
+	0x4d00, 0x7d09, 0xc1fa, 0x57db, 0x98ba, 0x0007, 0x6aff, 0x62d0,
+	0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff8, 0xc20a, 0x98b7, 0xc1d9,
+	0xc1e3, 0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202,
+	0x0269, 0x7d17, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694, 0x5206,
+	0x026e, 0x7d26, 0x6ac8, 0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e,
+	0x1a98, 0x5202, 0x0260, 0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc27a,
+	0x993e, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06,
+	0x0000, 0x4d00, 0x7d0b, 0xc1fa, 0x57db, 0x9904, 0x0007, 0x6aff,
+	0x6add, 0x7ffc, 0x62d0, 0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff6,
+	0xc20a, 0x9901
+};
+#endif
diff --git a/arch/arm/mach-mx5/sdma_script_code_mx50.h b/arch/arm/mach-mx5/sdma_script_code_mx50.h
new file mode 100644
index 0000000..49a7921
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code_mx50.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+		SDMA RELEASE LABEL:     "SDMA_CODEX.01.00.00"
+
+*******************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_MX50_H
+#define SDMA_SCRIPT_CODE_MX50_H
+
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_MX50   0
+#define start_SIZE_MX50   18
+
+#define core_ADDR_MX50   80
+#define core_SIZE_MX50   232
+
+#define common_ADDR_MX50   312
+#define common_SIZE_MX50   330
+
+#define ap_2_ap_ADDR_MX50   642
+#define ap_2_ap_SIZE_MX50   41
+
+#define app_2_mcu_ADDR_MX50   683
+#define app_2_mcu_SIZE_MX50   64
+
+#define mcu_2_app_ADDR_MX50   747
+#define mcu_2_app_SIZE_MX50   70
+
+#define uart_2_mcu_ADDR_MX50   817
+#define uart_2_mcu_SIZE_MX50   74
+
+#define shp_2_mcu_ADDR_MX50   891
+#define shp_2_mcu_SIZE_MX50   69
+
+#define mcu_2_shp_ADDR_MX50   960
+#define mcu_2_shp_SIZE_MX50   72
+
+#define uartsh_2_mcu_ADDR_MX50   1032
+#define uartsh_2_mcu_SIZE_MX50   68
+
+#define loop_DMAs_routines_ADDR_MX50   1100
+#define loop_DMAs_routines_SIZE_MX50   227
+
+#define test_ADDR_MX50   1327
+#define test_SIZE_MX50   63
+
+#define signature_ADDR_MX50   1023
+#define signature_SIZE_MX50   1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define mcu_2_ssiapp_ADDR_MX50   6144
+#define mcu_2_ssiapp_SIZE_MX50   96
+
+#define mcu_2_ssish_ADDR_MX50   6240
+#define mcu_2_ssish_SIZE_MX50   95
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_MX50     6144
+#define RAM_CODE_SIZE_MX50           191
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+static const short sdma_code_mx50[] = {
+0xc1e3, 0x57db, 0x52f3, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d,
+0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2c, 0x7c36, 0x0479,
+0x7c1f, 0x56ee, 0x0f00, 0x0660, 0x7d05, 0x6509, 0x7e43, 0x620a,
+0x7e41, 0x981e, 0x620a, 0x7e3e, 0x6509, 0x7e3c, 0x0512, 0x0512,
+0x02ad, 0x0760, 0x7d03, 0x55fb, 0x6dd3, 0x9829, 0x55fb, 0x1d04,
+0x6dd3, 0x6ac8, 0x7f2f, 0x1f01, 0x2003, 0x4800, 0x7ce4, 0x9851,
+0x55fb, 0x6dd7, 0x0015, 0x7805, 0x6209, 0x6ac8, 0x6209, 0x6ac8,
+0x6dd7, 0x9850, 0x55fb, 0x6dd7, 0x0015, 0x0015, 0x7805, 0x620a,
+0x6ac8, 0x620a, 0x6ac8, 0x6dd7, 0x9850, 0x55fb, 0x6dd7, 0x0015,
+0x0015, 0x0015, 0x7805, 0x620b, 0x6ac8, 0x620b, 0x6ac8, 0x6dd7,
+0x7c09, 0x6ddf, 0x7f07, 0x0000, 0x55eb, 0x4d00, 0x7d07, 0xc1fa,
+0x57db, 0x9804, 0x0007, 0x68cc, 0x680c, 0xc213, 0xc20a, 0x9801,
+0xc1d9, 0xc1e3, 0x57db, 0x52f3, 0x6a21, 0x008f, 0x00d5, 0x7d01,
+0x008d, 0x05a0, 0x5deb, 0x56fb, 0x0478, 0x7d03, 0x0479, 0x7d32,
+0x7c39, 0x0479, 0x7c28, 0x0b70, 0x0311, 0x53eb, 0x0f00, 0x0360,
+0x7d05, 0x6509, 0x7e3f, 0x620a, 0x7e3d, 0x9882, 0x620a, 0x7e3a,
+0x6509, 0x7e38, 0x0512, 0x0512, 0x02ad, 0x0760, 0x7d0a, 0x5a06,
+0x7f31, 0x1f01, 0x2003, 0x4800, 0x7cea, 0x0b70, 0x0311, 0x5313,
+0x98b3, 0x5a26, 0x7f27, 0x1f01, 0x2003, 0x4800, 0x7ce0, 0x0b70,
+0x0311, 0x5313, 0x98b3, 0x0015, 0x7804, 0x6209, 0x5a06, 0x6209,
+0x5a26, 0x98b2, 0x0015, 0x0015, 0x7804, 0x620a, 0x5a06, 0x620a,
+0x5a26, 0x98b2, 0x0015, 0x0015, 0x0015, 0x7804, 0x620b, 0x5a06,
+0x620b, 0x5a26, 0x7c07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa,
+0x57db, 0x9865, 0x0007, 0x680c, 0xc213, 0xc20a, 0x9862
+};
+#endif
diff --git a/arch/arm/mach-mx5/sdma_script_code_mx53.h b/arch/arm/mach-mx5/sdma_script_code_mx53.h
new file mode 100644
index 0000000..25f192d
--- /dev/null
+++ b/arch/arm/mach-mx5/sdma_script_code_mx53.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/************************************************************************************
+
+	SDMA RELEASE LABEL:     "SDMA_RITA.01.00.00"
+
+*************************************************************************************/
+
+#ifndef __SDMA_SCRIPT_CODE_MX53_H__
+#define __SDMA_SCRIPT_CODE_MX53_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define start_ADDR_MX53   0
+#define start_SIZE_MX53   22
+
+#define core_ADDR_MX53   80
+#define core_SIZE_MX53   232
+
+#define common_ADDR_MX53   312
+#define common_SIZE_MX53   330
+
+#define ap_2_ap_ADDR_MX53   642
+#define ap_2_ap_SIZE_MX53   41
+
+#define app_2_mcu_ADDR_MX53   683
+#define app_2_mcu_SIZE_MX53   64
+
+#define mcu_2_app_ADDR_MX53   747
+#define mcu_2_app_SIZE_MX53   70
+
+#define uart_2_mcu_ADDR_MX53   817
+#define uart_2_mcu_SIZE_MX53   74
+
+#define shp_2_mcu_ADDR_MX53   891
+#define shp_2_mcu_SIZE_MX53   69
+
+#define mcu_2_shp_ADDR_MX53   960
+#define mcu_2_shp_SIZE_MX53   72
+
+#define uartsh_2_mcu_ADDR_MX53   1032
+#define uartsh_2_mcu_SIZE_MX53   68
+
+#define spdif_2_mcu_ADDR_MX53   1100
+#define spdif_2_mcu_SIZE_MX53   34
+
+#define mcu_2_spdif_ADDR_MX53   1134
+#define mcu_2_spdif_SIZE_MX53   59
+
+#define firi_2_mcu_ADDR_MX53   1193
+#define firi_2_mcu_SIZE_MX53   97
+
+#define mcu_2_firi_ADDR_MX53  1290
+#define mcu_2_firi_SIZE_MX53   79
+
+#define loop_DMAs_routines_ADDR_MX53   1369
+#define loop_DMAs_routines_SIZE_MX53   227
+
+#define test_ADDR_MX53   1596
+#define test_SIZE_MX53   63
+
+#define signature_ADDR_MX53   1023
+#define signature_SIZE_MX53   1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define asrc__mcu_ADDR_MX53   6144
+#define asrc__mcu_SIZE_MX53   114
+
+#define mcu_2_ssiapp_ADDR_MX53   6258
+#define mcu_2_ssiapp_SIZE_MX53   96
+
+#define p_2_p_ADDR_MX53   6354
+#define p_2_p_SIZE_MX53   254
+
+#define ssiapp_2_mcu_ADDR_MX53   6608
+#define ssiapp_2_mcu_SIZE_MX53   93
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define RAM_CODE_START_ADDR_MX53     6144
+#define RAM_CODE_SIZE_MX53           557
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code_mx53[] = {
+	0xc1d9, 0xc1e3, 0x56f3, 0x57db, 0x047a, 0x7d07, 0x072f, 0x076e,
+	0x7d02, 0x6ec7, 0x9813, 0x6ed7, 0x9813, 0x074f, 0x076e, 0x7d02,
+	0x6e01, 0x9813, 0x6e05, 0x5ce3, 0x048f, 0x0410, 0x3c0f, 0x5c93,
+	0x0eff, 0x06bf, 0x06d5, 0x7d01, 0x068d, 0x05a6, 0x5deb, 0x55fb,
+	0x008e, 0x0768, 0x7d02, 0x0769, 0x7c04, 0x06d4, 0x7d01, 0x008c,
+	0x04a0, 0x06a0, 0x076f, 0x7d0c, 0x076e, 0x7d05, 0x7802, 0x62c8,
+	0x5a05, 0x7c2b, 0x9845, 0x7802, 0x5205, 0x6ac8, 0x7c26, 0x9845,
+	0x076e, 0x7d05, 0x7802, 0x620b, 0x5a05, 0x7c21, 0x9845, 0x7802,
+	0x5205, 0x6a0b, 0x7c1c, 0x6a28, 0x7f1a, 0x0768, 0x7d02, 0x0769,
+	0x7c0a, 0x4c00, 0x7c08, 0x0768, 0x7d03, 0x5a05, 0x7f11, 0x9852,
+	0x5205, 0x7e0e, 0x5493, 0x4e00, 0x7ccb, 0x0000, 0x54e3, 0x55eb,
+	0x4d00, 0x7d0a, 0xc1fa, 0x57db, 0x9814, 0x68cc, 0x9860, 0x680c,
+	0x009e, 0x0007, 0x54e3, 0xd866, 0xc20a, 0x9802, 0x55eb, 0x009d,
+	0x058c, 0x0aff, 0x0211, 0x1aff, 0x05ba, 0x05a0, 0x04b2, 0x04ad,
+	0x0454, 0x0006, 0xc1e3, 0x57db, 0x52f3, 0x6a01, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2c,
+	0x7c36, 0x0479, 0x7c1f, 0x56ee, 0x0f00, 0x0660, 0x7d05, 0x6509,
+	0x7e43, 0x620a, 0x7e41, 0x9890, 0x620a, 0x7e3e, 0x6509, 0x7e3c,
+	0x0512, 0x0512, 0x02ad, 0x0760, 0x7d03, 0x55fb, 0x6dd3, 0x989b,
+	0x55fb, 0x1d04, 0x6dd3, 0x6ac8, 0x7f2f, 0x1f01, 0x2003, 0x4800,
+	0x7ce4, 0x98c3, 0x55fb, 0x6dd7, 0x0015, 0x7805, 0x6209, 0x6ac8,
+	0x6209, 0x6ac8, 0x6dd7, 0x98c2, 0x55fb, 0x6dd7, 0x0015, 0x0015,
+	0x7805, 0x620a, 0x6ac8, 0x620a, 0x6ac8, 0x6dd7, 0x98c2, 0x55fb,
+	0x6dd7, 0x0015, 0x0015, 0x0015, 0x7805, 0x620b, 0x6ac8, 0x620b,
+	0x6ac8, 0x6dd7, 0x7c09, 0x6ddf, 0x7f07, 0x0000, 0x55eb, 0x4d00,
+	0x7d07, 0xc1fa, 0x57db, 0x9876, 0x0007, 0x68cc, 0x680c, 0xc213,
+	0xc20a, 0x9873, 0x0b70, 0x0311, 0x5313, 0x076c, 0x7c01, 0xc1d9,
+	0x5efb, 0x068a, 0x076b, 0x7c01, 0xc1d9, 0x5ef3, 0x59db, 0x58d3,
+	0x018f, 0x0110, 0x390f, 0x008b, 0xc13c, 0x7d2b, 0x5ac0, 0x5bc8,
+	0xc14e, 0x7c27, 0x0388, 0x0689, 0x5ce3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x073e, 0x4d00, 0x7d18, 0x0870, 0x0011, 0x077e, 0x7d09,
+	0x077d, 0x7d02, 0x5228, 0x98fd, 0x52f8, 0x54db, 0x02bc, 0x02cc,
+	0x7c09, 0x077c, 0x7d02, 0x5228, 0x9906, 0x52f8, 0x54d3, 0x02bc,
+	0x02cc, 0x7d09, 0x0400, 0x98f4, 0x008b, 0x52c0, 0x53c8, 0xc159,
+	0x7dd6, 0x0200, 0x98e4, 0x08ff, 0x00bf, 0x077f, 0x7d15, 0x0488,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb, 0x028f, 0x0212, 0x0212,
+	0x3aff, 0x05da, 0x7c02, 0x073e, 0x992f, 0x02a4, 0x02dd, 0x7d02,
+	0x073e, 0x992f, 0x075e, 0x992f, 0x55eb, 0x0598, 0x5deb, 0x52f3,
+	0x54fb, 0x076a, 0x7d26, 0x076c, 0x7d01, 0x996c, 0x076b, 0x7c57,
+	0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9946, 0x5893, 0x00d6,
+	0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502,
+	0x5d04, 0x7c1d, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e17,
+	0x9953, 0x5d04, 0x7f14, 0x0689, 0x5093, 0x4800, 0x7d01, 0x993e,
+	0x99b7, 0x0015, 0x7806, 0x5502, 0x5d04, 0x074f, 0x5502, 0x5d24,
+	0x072f, 0x7c01, 0x99b7, 0x0017, 0x076f, 0x7c01, 0x2001, 0x5593,
+	0x009d, 0x0007, 0xd9be, 0x990c, 0x6cd3, 0x0769, 0x7d04, 0x0768,
+	0x7d02, 0x0e01, 0x997b, 0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593,
+	0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502, 0x6dc8, 0x7c0f, 0x4e00,
+	0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e09, 0x9988, 0x6dc8, 0x7f06,
+	0x0689, 0x5093, 0x4800, 0x7d01, 0x9973, 0x99b7, 0x99b1, 0x6ac3,
+	0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x999e, 0x5893, 0x00d6,
+	0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x65c8,
+	0x5d04, 0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x65c8, 0x7e09,
+	0x99ab, 0x5d04, 0x7f06, 0x0689, 0x5093, 0x4800, 0x7d01, 0x9996,
+	0x99b7, 0x5593, 0x009d, 0x0007, 0x6cff, 0xd9be, 0x990c, 0x0000,
+	0x54e3, 0x55eb, 0x4d00, 0x7c01, 0x990c, 0x98f4, 0x54e3, 0x55eb,
+	0x0aff, 0x0211, 0x1aff, 0x077f, 0x7c02, 0x05a0, 0x99cb, 0x009d,
+	0x058c, 0x05ba, 0x05a0, 0x0210, 0x04ba, 0x04ad, 0x0454, 0x0006,
+	0xc1e3, 0x57db, 0x52fb, 0x6ac3, 0x52f3, 0x6a05, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5deb, 0x0478, 0x7d03, 0x0479, 0x7d2b,
+	0x7c1e, 0x0479, 0x7c33, 0x56ee, 0x0f00, 0x55fb, 0x0760, 0x7d02,
+	0x6dc3, 0x99ec, 0x1d04, 0x6dc3, 0x62c8, 0x7e3b, 0x0660, 0x7d02,
+	0x0210, 0x0212, 0x6a09, 0x7f35, 0x0212, 0x6a09, 0x7f32, 0x0212,
+	0x6a09, 0x7f2f, 0x1f01, 0x2003, 0x4800, 0x7ce7, 0x9a20, 0x55fb,
+	0x6dc7, 0x0015, 0x0015, 0x0015, 0x7805, 0x62c8, 0x6a0b, 0x62c8,
+	0x6a0b, 0x6dc7, 0x9a1f, 0x55fb, 0x6dc7, 0x0015, 0x0015, 0x7805,
+	0x62c8, 0x6a0a, 0x62c8, 0x6a0a, 0x6dc7, 0x9a1f, 0x55fb, 0x6dc7,
+	0x0015, 0x7805, 0x62c8, 0x6a09, 0x62c8, 0x6a09, 0x6dc7, 0x7c09,
+	0x6a28, 0x7f07, 0x0000, 0x55eb, 0x4d00, 0x7d05, 0xc1fa, 0x57db,
+	0x99d6, 0xc277, 0x0454, 0xc20a, 0x99d1
+};
+#endif
diff --git a/arch/arm/mach-mx5/sdram_autogating.c b/arch/arm/mach-mx5/sdram_autogating.c
new file mode 100644
index 0000000..0b05d79
--- /dev/null
+++ b/arch/arm/mach-mx5/sdram_autogating.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sdram_autogating.c
+ *
+ * @brief Enable auto clock gating of the EMI_FAST clock using M4IF.
+ *
+ * The APIs are for enabling and disabling automatic clock gating of EMI_FAST.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/sdram_autogating.h>
+#include "crm_regs.h"
+
+static struct device *sdram_autogating_dev;
+#define M4IF_CNTL_REG0		0x8c
+#define M4IF_CNTL_REG1		0x90
+
+/* Flag used to indicate if SDRAM M4IF autoclock gating feature is active. */
+static int sdram_autogating_is_active;
+static int sdram_autogating_paused;
+static void __iomem *m4if_base;
+
+void start_sdram_autogating(void);
+void stop_sdram_autogating(void);
+int sdram_autogating_active(void);
+
+static void enable(void)
+{
+	u32 reg;
+
+	/* Set the Fast arbitration Power saving timer */
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG1);
+	reg &= ~0xFF;
+	reg |= 0x09;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG1);
+	/*Allow for automatic gating of the EMI internal clock.
+	 * If this is done, emi_intr CCGR bits should be set to 11.
+	 */
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG0);
+	reg &= ~0x5;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG0);
+
+	sdram_autogating_is_active = 1;
+}
+
+static void disable(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG0);
+	reg |= 0x4;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG0);
+	sdram_autogating_is_active = 0;
+}
+
+int sdram_autogating_active()
+{
+	return sdram_autogating_is_active;
+}
+
+void start_sdram_autogating()
+{
+	if (cpu_is_mx50())
+		return;
+	if (sdram_autogating_paused) {
+		enable();
+		sdram_autogating_paused = 0;
+	}
+}
+
+void  stop_sdram_autogating()
+{
+	if (cpu_is_mx50())
+		return;
+
+	if (sdram_autogating_is_active) {
+		sdram_autogating_paused = 1;
+		disable();
+	}
+}
+
+static ssize_t sdram_autogating_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (sdram_autogating_is_active)
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST enabled\n");
+	else
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST disabled\n");
+}
+
+static ssize_t sdram_autogating_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL)
+		enable();
+	else if (strstr(buf, "0") != NULL) {
+		if (sdram_autogating_is_active)
+			disable();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, sdram_autogating_enable_show,
+			sdram_autogating_enable_store);
+
+/*!
+ * This is the probe routine for the auto clockgating of sdram driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit sdram_autogating_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int err = 0;
+
+	sdram_autogating_dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		return -ENOMEM;
+	}
+	m4if_base = ioremap(res->start, res->end - res->start + 1);
+
+	err = sysfs_create_file(&sdram_autogating_dev->kobj,
+							&dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for sdram_autogating");
+		return err;
+	}
+
+	sdram_autogating_is_active = 0;
+
+	return 0;
+}
+
+static struct platform_driver sdram_autogating_driver = {
+	.driver = {
+		   .name = "sdram_autogating",
+		},
+	.probe = sdram_autogating_probe,
+};
+
+/*!
+ * Initialise the sdram_autogating_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init sdram_autogating_init(void)
+{
+	if (platform_driver_register(&sdram_autogating_driver) != 0) {
+		printk(KERN_ERR "sdram_autogating_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "sdram autogating driver module loaded\n");
+	return 0;
+}
+
+static void __exit sdram_autogating_cleanup(void)
+{
+	sysfs_remove_file(&sdram_autogating_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&sdram_autogating_driver);
+}
+
+module_init(sdram_autogating_init);
+module_exit(sdram_autogating_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("sdram_autogating driver");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-mx5/serial.c b/arch/arm/mach-mx5/serial.c
new file mode 100644
index 0000000..123db39
--- /dev/null
+++ b/arch/arm/mach-mx5/serial.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file mach-mx51/serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup MSL_MX51
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <mach/hardware.h>
+#include <mach/mxc_uart.h>
+#include "serial.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = 1,
+	       .mode = MODE_DCE,
+	       .ir_mode = NO_IRDA,
+	       .enabled = 1,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = 1,
+	       .mode = MODE_DCE,
+	       .ir_mode = NO_IRDA,
+	       .enabled = 1,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[2] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = 1,
+	       .mode = MODE_DCE,
+	       .ir_mode = NO_IRDA,
+	       .enabled = 1,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = 1,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[3] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = 1,
+	       .mode = MODE_DCE,
+	       .ir_mode = NO_IRDA,
+	       .enabled = 1,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[4] = {
+	       .port = {
+			.iotype = SERIAL_IO_MEM,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = 1,
+	       .mode = MODE_DCE,
+	       .ir_mode = NO_IRDA,
+	       .enabled = 1,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+};
+
+static struct resource mxc_uart_resources1[] = {
+	{
+		.start = UART1_BASE_ADDR,
+		.end = UART1_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_UART1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_uart_resources1),
+	.resource = mxc_uart_resources1,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct resource mxc_uart_resources2[] = {
+	{
+		.start = UART2_BASE_ADDR,
+		.end = UART2_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_UART2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources2),
+	.resource = mxc_uart_resources2,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+static struct resource mxc_uart_resources3[] = {
+	{
+		.start = UART3_BASE_ADDR,
+		.end = UART3_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_UART3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources3),
+	.resource = mxc_uart_resources3,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+
+static struct resource mxc_uart_resources4[] = {
+	{
+		.start = UART4_BASE_ADDR,
+		.end = UART4_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_UART4,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources4),
+	.resource = mxc_uart_resources4,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+
+static struct resource mxc_uart_resources5[] = {
+	{
+		.start = UART5_BASE_ADDR,
+		.end = UART5_BASE_ADDR + 0x0B5,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_UART5,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+       .num_resources = ARRAY_SIZE(mxc_uart_resources5),
+	.resource = mxc_uart_resources5,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+
+static int __init mxc_init_uart(void)
+{
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_uart_resources1[0].start -= 0x20000000;
+		mxc_uart_resources1[0].end -= 0x20000000;
+		mxc_uart_resources2[0].start -= 0x20000000;
+		mxc_uart_resources2[0].end -= 0x20000000;
+		mxc_uart_resources3[0].start -= 0x20000000;
+		mxc_uart_resources3[0].end -= 0x20000000;
+		mxc_uart_resources4[0].start -= 0x20000000;
+		mxc_uart_resources4[0].end -= 0x20000000;
+		mxc_uart_resources5[0].start -= 0x20000000;
+		mxc_uart_resources5[0].end -= 0x20000000;
+	}
+
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+	platform_device_register(&mxc_uart_device3);
+	if (cpu_is_mx53()) {
+		platform_device_register(&mxc_uart_device4);
+		platform_device_register(&mxc_uart_device5);
+	}
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
diff --git a/arch/arm/mach-mx5/serial.h b/arch/arm/mach-mx5/serial.h
new file mode 100644
index 0000000..d487a96
--- /dev/null
+++ b/arch/arm/mach-mx5/serial.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX51_SERIAL_H__
+#define __ARCH_ARM_MACH_MX51_SERIAL_H__
+
+/* UART 1 configuration */
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_UCR4_CTSTL        -1
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_UCR4_CTSTL        -1
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+
+#endif				/* __ARCH_ARM_MACH_MX51_SERIAL_H__ */
diff --git a/arch/arm/mach-mx5/suspend.S b/arch/arm/mach-mx5/suspend.S
new file mode 100644
index 0000000..f5aa1cc
--- /dev/null
+++ b/arch/arm/mach-mx5/suspend.S
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_CTRL_ICACHE  1 << 12
+#define ARM_AUXCR_L2EN   1 << 1
+
+
+/*
+ *	cpu_do_suspend_workaround()
+ *
+ *	Suspend the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_do_suspend_workaround)
+    stmfd   sp!, {r4,r5,r6,r7,r9,r10,r11}     @ Save registers
+
+   mov    r6, r0                       @save iomux address
+    /* Disable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    bic     r0, r0, #ARM_CTRL_ICACHE @ Disable ICache
+    bic     r0, r0, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000       @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedClean
+    mov     r10, #0
+Loop1Clean:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipClean                @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7             @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Clean:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Clean:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c14, 2 @ Clean and invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Clean
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Clean
+SkipClean:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Clean
+
+FinishedClean:
+
+    /* Disable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    bic     r0, r0, #ARM_AUXCR_L2EN @ Disable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+	/*Set the DDR drive strength to low */
+	ldr        r10, [r6]
+	and       r10, r10, #0xF1        @ clear bits 2-1
+	str        r10, [r6]
+
+    .long     0xe320f003              @ Opcode for WFI
+
+	/*Set the DDR drive strength to max */
+	orr       r10, r10, #0x06        @ set bits 2-1
+	str        r10, [r6]
+
+    mov     r0, #0
+    mcr     p15, 0, r0, c7, c5, 0   @ Invalidate inst cache
+
+    /* Invalidate data caches */
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000      @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedInvalidate
+    mov     r10, #0
+Loop1Invalidate:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipInvalidate          @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7              @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Invalidate:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Invalidate:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c6, 2  @ Invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Invalidate
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Invalidate
+SkipInvalidate:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Invalidate
+
+FinishedInvalidate:
+
+    /* Enable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    orr     r0, r0, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    /* Enable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    orr     r0, r0, #ARM_CTRL_ICACHE @ Enable ICache
+    orr     r0, r0, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    /* Restore registers */
+    ldmfd sp!, {r4,r5,r6,r7,r9,r10,r11}
+    mov		pc, lr
+
+	.type	cpu_do_suspend, #object
+ENTRY(cpu_do_suspend)
+	.word	cpu_do_suspend_workaround
+	.size	cpu_do_suspend_workaround, . - cpu_do_suspend_workaround
diff --git a/arch/arm/mach-mx5/system.c b/arch/arm/mach-mx5/system.c
new file mode 100644
index 0000000..ba9989b
--- /dev/null
+++ b/arch/arm/mach-mx5/system.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX51 i.MX51 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx51/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX51
+ */
+
+extern int mxc_jtag_enabled;
+extern int iram_ready;
+static struct clk *gpc_dvfs_clk;
+
+/* set cpu low power mode before WFI instruction */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	u32 plat_lpc, arm_srpgcr, ccm_clpcr;
+	u32 empgc0, empgc1;
+	int stop_mode = 0;
+
+	/* always allow platform to issue a deep sleep mode request */
+	plat_lpc = __raw_readl(MXC_CORTEXA8_PLAT_LPC) &
+	    ~(MXC_CORTEXA8_PLAT_LPC_DSM);
+	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR) & ~(MXC_CCM_CLPCR_LPM_MASK);
+	arm_srpgcr = __raw_readl(MXC_SRPG_ARM_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc0 = __raw_readl(MXC_SRPG_EMPGC0_SRPGCR) & ~(MXC_SRPGCR_PCR);
+	empgc1 = __raw_readl(MXC_SRPG_EMPGC1_SRPGCR) & ~(MXC_SRPGCR_PCR);
+
+	switch (mode) {
+	case WAIT_CLOCKED:
+		break;
+	case WAIT_UNCLOCKED:
+		ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	case WAIT_UNCLOCKED_POWER_OFF:
+	case STOP_POWER_OFF:
+		plat_lpc |= MXC_CORTEXA8_PLAT_LPC_DSM
+			    | MXC_CORTEXA8_PLAT_LPC_DBG_DSM;
+		if (mode == WAIT_UNCLOCKED_POWER_OFF) {
+			ccm_clpcr |= (0x1 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr &= ~MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr &= ~MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 0;
+		} else {
+			ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+			ccm_clpcr |= (0x3 << MXC_CCM_CLPCR_STBY_COUNT_OFFSET);
+			ccm_clpcr |= MXC_CCM_CLPCR_VSTBY;
+			ccm_clpcr |= MXC_CCM_CLPCR_SBYOS;
+			stop_mode = 1;
+		}
+
+		arm_srpgcr |= MXC_SRPGCR_PCR;
+		if (stop_mode) {
+			empgc0 |= MXC_SRPGCR_PCR;
+			empgc1 |= MXC_SRPGCR_PCR;
+		}
+
+		if (tzic_enable_wake(1) != 0)
+			return;
+		break;
+	case STOP_POWER_ON:
+		ccm_clpcr |= (0x2 << MXC_CCM_CLPCR_LPM_OFFSET);
+		break;
+	default:
+		printk(KERN_WARNING "UNKNOWN cpu power mode: %d\n", mode);
+		return;
+	}
+
+	__raw_writel(plat_lpc, MXC_CORTEXA8_PLAT_LPC);
+	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	/* Need to fix this for MX53 and MX508 */
+	if (cpu_is_mx51())
+		__raw_writel(arm_srpgcr, MXC_SRPG_ARM_SRPGCR);
+	__raw_writel(arm_srpgcr, MXC_SRPG_NEON_SRPGCR);
+	if (stop_mode) {
+		__raw_writel(empgc0, MXC_SRPG_EMPGC0_SRPGCR);
+		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
+	}
+}
+
+void mxc_pg_enable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_IPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(MXC_PGCR_PCR, MXC_PGC_VPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+
+EXPORT_SYMBOL(mxc_pg_enable);
+
+void mxc_pg_disable(struct platform_device *pdev)
+{
+	if (pdev == NULL)
+		return;
+
+	if (strcmp(pdev->name, "mxc_ipu") == 0) {
+		__raw_writel(0x0, MXC_PGC_IPU_PGCR);
+		if (__raw_readl(MXC_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_IPU_PGSR);
+	} else if (strcmp(pdev->name, "mxc_vpu") == 0) {
+		__raw_writel(0x0, MXC_PGC_VPU_PGCR);
+		if (__raw_readl(MXC_PGC_VPU_PGSR) & MXC_PGSR_PSR)
+			dev_dbg(&pdev->dev, "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MXC_PGC_VPU_PGSR);
+	}
+}
+
+EXPORT_SYMBOL(mxc_pg_disable);
+
+/* To change the idle power mode, need to set arch_idle_mode to a different
+ * power mode as in enum mxc_cpu_pwr_mode.
+ * May allow dynamically changing the idle mode.
+ */
+static int arch_idle_mode = WAIT_UNCLOCKED_POWER_OFF;
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void mx51_idle(void)
+{
+/*	if (likely(!mxc_jtag_enabled))*/ {
+		if (gpc_dvfs_clk == NULL)
+			gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+		/* gpc clock is needed for SRPG */
+		clk_enable(gpc_dvfs_clk);
+		mxc_cpu_lp_set(arch_idle_mode);
+		cpu_do_idle();
+		clk_disable(gpc_dvfs_clk);
+	}
+}
diff --git a/arch/arm/mach-mx5/usb.h b/arch/arm/mach-mx5/usb.h
new file mode 100644
index 0000000..6115d33
--- /dev/null
+++ b/arch/arm/mach-mx5/usb.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <mach/common.h>
+#include "devices.h"
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+
+extern void __init mx5_usb_dr_init(void);
+extern void __init mx5_usbh1_init(void);
+extern void __init mx5_usbh2_init(void);
+
+typedef void (*driver_vbus_func)(bool);
+extern void mx5_set_host1_vbus_func(driver_vbus_func);
+extern void mx5_set_otghost_vbus_func(driver_vbus_func);
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
diff --git a/arch/arm/mach-mx5/usb_dr.c b/arch/arm/mach-mx5/usb_dr.c
new file mode 100644
index 0000000..0286c7a
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_dr.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include "usb.h"
+
+
+static int usbotg_init_ext(struct platform_device *pdev);
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata);
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable);
+static void usbotg_clock_gate(bool on);
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init_ext,
+	.platform_uninit   = usbotg_uninit_ext,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.gpio_usb_active   = gpio_usbotg_hs_active,
+	.gpio_usb_inactive = gpio_usbotg_hs_inactive,
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.wake_up_enable = _wake_up_enable,
+	.transceiver       = "utmi",
+};
+
+/* Notes: configure USB clock*/
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(&pdev->dev, "usb_phy1_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	/*derive clock from oscillator */
+	usb_clk = clk_get(NULL, "usb_utmi_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	return usbotg_init(pdev);
+}
+
+static void usbotg_uninit_ext(struct fsl_usb2_platform_data *pdata)
+{
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usb_clk = clk_get(&pdata->pdev->dev, "usb_phy1_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	usbotg_uninit(pdata);
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (get_usb_mode(pdata) == FSL_USB_DR_DEVICE) {
+		if (enable) {
+			USBCTRL |= UCTRL_OWIE;
+			USBCTRL_HOST2 |= UCTRL_H2OVBWK_EN;
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_CONF2;
+		} else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL_HOST2 &= ~UCTRL_H2OVBWK_EN;
+			USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CONF2;
+		}
+	} else {
+		if (enable) {
+			USBCTRL |= UCTRL_OWIE;
+			USBCTRL_HOST2 |= (1 << 5);
+		} else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL_HOST2 &= ~(1 << 5);
+		}
+	}
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	struct clk *usb_clk;
+
+	if (on) {
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_phy1_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		/*derive clock from oscillator */
+		usb_clk = clk_get(NULL, "usb_utmi_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	} else {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_phy1_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+}
+
+void mx5_set_otghost_vbus_func(driver_vbus_func driver_vbus)
+{
+	dr_utmi_config.platform_driver_vbus = driver_vbus;
+}
+
+void __init mx5_usb_dr_init(void)
+{
+#ifdef CONFIG_USB_OTG
+	dr_utmi_config.operating_mode = FSL_USB2_DR_OTG;
+	platform_device_add_data(&mxc_usbdr_otg_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	platform_device_register(&mxc_usbdr_otg_device);
+#endif
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+	dr_utmi_config.operating_mode = DR_HOST_MODE;
+	platform_device_add_data(&mxc_usbdr_host_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	platform_device_register(&mxc_usbdr_host_device);
+#endif
+#ifdef CONFIG_USB_GADGET_ARC
+	dr_utmi_config.operating_mode = DR_UDC_MODE;
+	platform_device_add_data(&mxc_usbdr_udc_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	platform_device_register(&mxc_usbdr_udc_device);
+#endif
+}
diff --git a/arch/arm/mach-mx5/usb_h1.c b/arch/arm/mach-mx5/usb_h1.c
new file mode 100644
index 0000000..52a2bca
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h1.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "usb.h"
+#include "iomux.h"
+#include "mx51_pins.h"
+
+/*
+ * USB Host1 HS port
+ */
+static int gpio_usbh1_active(void)
+{
+	/* Set USBH1_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO |
+			  IOMUX_CONFIG_SION);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), "usbh1_stp");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP), 1);
+
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		mxc_request_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_ALT1);
+		mxc_iomux_set_pad(MX51_PIN_EIM_D17, PAD_CTL_DRV_HIGH |
+			  PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+			  PAD_CTL_100K_PU | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
+		gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), "eim_d17");
+		gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), 0);
+		gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D17), 1);
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+static void gpio_usbh1_inactive(void)
+{
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		gpio_free(IOMUX_TO_GPIO(MX51_PIN_EIM_D17));
+		mxc_free_iomux(MX51_PIN_EIM_D17, IOMUX_CONFIG_GPIO);
+	}
+
+	mxc_free_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_GPIO);
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP));
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (enable)
+		USBCTRL |= UCTRL_H1WIE;
+	else
+		USBCTRL &= ~UCTRL_H1WIE;
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	struct clk *usb_clk;
+	if (on) {
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+	} else {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+
+	if (cpu_is_mx53()) {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(&pdev->dev, "usb_phy2_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		/*derive clock from oscillator */
+		usb_clk = clk_get(NULL, "usb_utmi_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	} else if (cpu_is_mx50()) {
+		usb_clk = clk_get(&pdev->dev, "usb_phy2_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+	}
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret)
+		return ret;
+
+	if (cpu_is_mx51()) {
+		/* setback USBH1_STP to be function */
+		mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_USBH1_STP, PAD_CTL_SRE_FAST |
+				  PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+				  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS |
+				  PAD_CTL_DRV_VOT_LOW);
+		gpio_free(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP));
+	}
+
+	/* disable remote wakeup irq */
+	USBCTRL &= ~UCTRL_H1WIE;
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct fsl_usb2_platform_data *pdata)
+{
+	struct clk *usb_clk;
+
+	if (cpu_is_mx53()) {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(&pdata->pdev->dev, "usb_phy2_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	} else if (cpu_is_mx50()) {
+		usb_clk = clk_get(&pdata->pdev->dev, "usb_phy2_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+
+	fsl_usb_host_uninit(pdata);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name = "Host 1",
+	.platform_init = fsl_usb_host_init_ext,
+	.platform_uninit = fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.transceiver = "utmi",
+};
+
+void mx5_set_host1_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh1_config.platform_driver_vbus = driver_vbus;
+}
+void __init mx5_usbh1_init(void)
+{
+	if (cpu_is_mx51()) {
+		usbh1_config.phy_mode = FSL_USB2_PHY_ULPI;
+		usbh1_config.transceiver = "isp1504";
+		usbh1_config.gpio_usb_active = gpio_usbh1_active;
+		usbh1_config.gpio_usb_inactive = gpio_usbh1_inactive;
+	}
+	mxc_register_device(&mxc_usbh1_device, &usbh1_config);
+}
+
diff --git a/arch/arm/mach-mx5/usb_h2.c b/arch/arm/mach-mx5/usb_h2.c
new file mode 100644
index 0000000..c3279e5
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h2.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include "usb.h"
+#include "iomux.h"
+#include "mx51_pins.h"
+
+/*
+ * USB Host2 HS port
+ */
+static int gpio_usbh2_active(void)
+{
+	/* Set USBH2_STP to GPIO and toggle it */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), "eim_a26");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A26), 1);
+
+	msleep(100);
+
+	return 0;
+}
+
+static void gpio_usbh2_inactive(void)
+{
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_EIM_A26));
+	mxc_free_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_GPIO);
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret = fsl_usb_host_init(pdev);
+	if (ret)
+		return ret;
+
+	/* setback USBH2_STP to be function */
+	mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT2);
+
+	return 0;
+}
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name = "Host 2",
+	.platform_init = fsl_usb_host_init_ext,
+	.platform_uninit = fsl_usb_host_uninit,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.gpio_usb_active = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver = "isp1504",
+};
+
+void __init mx51_usbh2_init(void)
+{
+	mxc_register_device(&mxc_usbh2_device, &usbh2_config);
+}
+
diff --git a/arch/arm/mach-mx5/wfi.S b/arch/arm/mach-mx5/wfi.S
new file mode 100644
index 0000000..a6e373f
--- /dev/null
+++ b/arch/arm/mach-mx5/wfi.S
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_AUXCR_L2EN   1 << 1
+/*
+ *	cpu_cortexa8_do_idle()
+ *
+ *	Idle the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_cortexa8_do_idle)
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    ands    r2, r1, #ARM_AUXCR_L2EN @ Check if L2 is disabled
+    beq     SkipL2Access
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    bic     r2, r2, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    bic     r1, r1, #ARM_AUXCR_L2EN  @ Disable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1    @ Update aux control reg
+
+    ldr     r1, =(0x0 << 6)          @ A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2   @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0   @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x00]          @ Save tag info
+
+    ldr     r1, =(0x1 << 6)          @ A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x04]         @ Save tag info
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x08]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x0C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x10]         @ Store data info
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x14]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x18]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x1C]         @ Store data info
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x20]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x24]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x28]         @ Store data info
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x2C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x30]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x34]         @ Store data info
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x38]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x3C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x40]         @ Store data info
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x44]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x48]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x4C]         @ Store data info
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x50]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x54]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x58]         @ Store data info
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x5C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x60]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x64]         @ Store data info
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x68]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x6C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x70]         @ Store data info
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x74]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x78]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x7C]         @ Store data info
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x80]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x84]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x88]         @ Store data info
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x8C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x90]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0x94]         @ Store data info
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0x98]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0x9C]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xA0]         @ Store data info
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xA4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xA8]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xAC]         @ Store data info
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xB0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xB4]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xB8]         @ Store data info
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    mcr     p15, 0, r1, c15, c9, 3  @ Read L2 Data RAM into L2 data 0-2 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xBC]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 1  @ Move L2 data 1 register to R2
+    str     r2, [r0, #0xC0]         @ Store data info
+    mrc     p15, 0, r2, c15, c8, 5  @ Move L2 data 2 register to R2
+    str     r2, [r0, #0xC4]         @ Store data info
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xC8]         @ Save tag info
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xCC]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD0]         @ Save tag info
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD4]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xD8]         @ Save tag info
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    mcr     p15, 0, r1, c15, c9, 2  @ Read L2 tag RAM into L2 data 0 register
+    mrc     p15, 0, r2, c15, c8, 0  @ Move L2 data 0 register to R2
+    str     r2, [r0, #0xDC]         @ Save tag info
+
+    .long     0xe320f003              @ Opcode for WFI
+
+    ldr     r1, =(0x0 << 6)         @ A[6] = 0
+    ldr     r2, [r0, #0x00]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x1 << 6)         @ A[6] = 1
+    ldr     r2, [r0, #0x04]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x0 << 3)         @ A[6:3] = b0000
+    ldr     r2, [r0, #0x08]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x0C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x10]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x1 << 3)         @ A[6:3] = b0001
+    ldr     r2, [r0, #0x14]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x18]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x1C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 3)         @ A[6:3] = b0010
+    ldr     r2, [r0, #0x20]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x24]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x28]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x3 << 3)         @ A[6:3] = b0011
+    ldr     r2, [r0, #0x2C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x30]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x34]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x4 << 3)         @ A[6:3] = b0100
+    ldr     r2, [r0, #0x38]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x3C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x40]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x5 << 3)         @ A[6:3] = b0101
+    ldr     r2, [r0, #0x44]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x48]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x4C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x6 << 3)         @ A[6:3] = b0110
+    ldr     r2, [r0, #0x50]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x54]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x58]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x7 << 3)         @ A[6:3] = b0111
+    ldr     r2, [r0, #0x5C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x60]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x64]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x8 << 3)         @ A[6:3] = b1000
+    ldr     r2, [r0, #0x68]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x6C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x70]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x9 << 3)         @ A[6:3] = b1001
+    ldr     r2, [r0, #0x74]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x78]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x7C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xA << 3)         @ A[6:3] = b1010
+    ldr     r2, [r0, #0x80]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x84]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x88]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xB << 3)         @ A[6:3] = b1011
+    ldr     r2, [r0, #0x8C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x90]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0x94]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xC << 3)         @ A[6:3] = b1100
+    ldr     r2, [r0, #0x98]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0x9C]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xA0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xD << 3)         @ A[6:3] = b1101
+    ldr     r2, [r0, #0xA4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xA8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xAC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xE << 3)         @ A[6:3] = b1110
+    ldr     r2, [r0, #0xB0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xB4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xB8]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0xF << 3)         @ A[6:3] = b1111
+    ldr     r2, [r0, #0xBC]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    ldr     r2, [r0, #0xC0]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 1  @ Move R2 to L2 data 1 register
+    ldr     r2, [r0, #0xC4]         @ Load data info
+    mcr     p15, 0, r2, c15, c8, 5  @ Move R2 to L2 data 2 register
+    mcr     p15, 0, r1, c15, c8, 3  @ Write L2 data 0-2 registers to L2 data RAM
+
+    ldr     r1, =(0x2 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 2, A[6] = 0
+    ldr     r2, [r0, #0xC8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x2 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 2, A[6] = 1
+    ldr     r2, [r0, #0xCC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 4, A[6] = 0
+    ldr     r2, [r0, #0xD0]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x4 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 4, A[6] = 1
+    ldr     r2, [r0, #0xD4]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x0 << 6)   @ WAY = A[31:29] = 6, A[6] = 0
+    ldr     r2, [r0, #0xD8]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    ldr     r1, =(0x6 << 29) | (0x1 << 6)   @ WAY = A[31:29] = 6, A[6] = 1
+    ldr     r2, [r0, #0xDC]         @ Load tag info
+    mcr     p15, 0, r2, c15, c8, 0  @ Move R2 to L2 data 0 register
+    mcr     p15, 0, r1, c15, c8, 2  @ Write L2 data 0 register to L2 tag RAM
+
+    mrc     p15, 0, r1, c1, c0, 1   @ R1 = auxiliary control reg
+    orr     r1, r1, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r1, c1, c0, 1   @ Update aux control reg
+
+    mrc     p15, 0, r2, c1, c0, 0    @ R2 = system control reg
+    orr     r2, r2, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r2, c1, c0, 0    @ Update system control reg
+
+    b       Done
+
+SkipL2Access:
+    .long     0xe320f003              @ Opcode for WFI
+
+Done:
+    mov		pc, lr
+
+	.type	cortexa8_idle_workaround, #object
+ENTRY(cortexa8_idle_workaround)
+	.word	cpu_cortexa8_do_idle
+	.size	cortexa8_idle_workaround, . - cortexa8_idle_workaround
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
index c5298f1..53fa511 100644
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -59,7 +59,6 @@ source "arch/arm/mach-mx3/Kconfig"
 source "arch/arm/mach-mx25/Kconfig"
 source "arch/arm/mach-mxc91231/Kconfig"
 source "arch/arm/mach-mx5/Kconfig"
-source "arch/arm/mach-mx37/Kconfig"
 
 endmenu
 
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
index 19eca93..c6d334f 100644
--- a/arch/arm/plat-mxc/include/mach/arc_otg.h
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -147,6 +147,7 @@
 #define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
 #define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
 #define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)      /* USB Clock on/off Control Register */
 
 /*
  * register bits
@@ -245,6 +246,7 @@
 #define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
 #define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
 #define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
 #define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
 #define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
 #define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
@@ -329,6 +331,7 @@
 #define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
 #define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
 #define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
 /* USB_PHY_CTRL_FUNC2*/
 #define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
 #define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
@@ -355,6 +358,8 @@
 #define ULPIVW_WDATA_SHIFT	0
 
 #define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
-
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
 extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index f871879..75b739d 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -21,8 +21,7 @@ extern void mx27_map_io(void);
 extern void mx31_map_io(void);
 extern void mx35_map_io(void);
 extern void mx37_map_io(void);
-extern void mx51_map_io(void);
-extern void mx53_map_io(void);
+extern void mx5_map_io(void);
 extern void mxc91231_map_io(void);
 extern void mxc_init_irq(void __iomem *);
 extern void tzic_init_irq(void __iomem *);
@@ -32,9 +31,9 @@ extern void mx25_init_irq(void);
 extern void mx27_init_irq(void);
 extern void mx31_init_irq(void);
 extern void mx35_init_irq(void);
-extern void mx51_init_irq(void);
-extern void mx53_init_irq(void);
+extern void mx5_init_irq(void);
 extern void mxc91231_init_irq(void);
+extern void mxc_tzic_init_irq(unsigned long);
 extern void mxc_timer_init(struct clk *timer_clk, void __iomem *, int);
 extern int mx1_clocks_init(unsigned long fref);
 extern int mx21_clocks_init(unsigned long lref, unsigned long fref);
@@ -43,9 +42,11 @@ extern int mx27_clocks_init(unsigned long fref);
 extern int mx31_clocks_init(unsigned long fref);
 extern int mx35_clocks_init(void);
 extern int mx37_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
+extern int mx50_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih);
 extern int mx51_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
-extern int mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2);
+extern int mx53_clocks_init(unsigned long ckil, unsigned long osc,
+			unsigned long ckih1, unsigned long ckih2);
 extern int mxc91231_clocks_init(unsigned long fref);
 extern void mxc_cpu_init(void);
 extern void mxc_cpu_common_init(void);
diff --git a/arch/arm/plat-mxc/include/mach/hardware.h b/arch/arm/plat-mxc/include/mach/hardware.h
index 8905467..9f6b617 100644
--- a/arch/arm/plat-mxc/include/mach/hardware.h
+++ b/arch/arm/plat-mxc/include/mach/hardware.h
@@ -41,6 +41,7 @@
 
 #define BOARD_REV_1		0x000
 #define BOARD_REV_2		0x100
+#define BOARD_REV_3		0x200
 
 #define IMX_IO_ADDRESS(addr, module)					\
 	((void __force __iomem *)					\
@@ -90,6 +91,8 @@ extern unsigned int system_rev;
 
 #ifdef CONFIG_ARCH_MX5
 #define board_is_mx53_arm2() (cpu_is_mx53() && board_is_rev(BOARD_REV_2))
+#define board_is_mx53_evk_a()    (cpu_is_mx53() && board_is_rev(BOARD_REV_1))
+#define board_is_mx53_evk_b()    (cpu_is_mx53() && board_is_rev(BOARD_REV_3))
 #endif
 
 #include <mach/mxc.h>
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx50.h b/arch/arm/plat-mxc/include/mach/iomux-mx50.h
new file mode 100644
index 0000000..8e4a33c
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx50.h
@@ -0,0 +1,513 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __MACH_IOMUX_MX50_H__
+#define __MACH_IOMUX_MX50_H__
+
+#include <mach/iomux-v3.h>
+
+/*
+ * various IOMUX alternate output functions (1-7)
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,
+	IOMUX_CONFIG_ALT1,
+	IOMUX_CONFIG_ALT2,
+	IOMUX_CONFIG_ALT3,
+	IOMUX_CONFIG_ALT4,
+	IOMUX_CONFIG_ALT5,
+	IOMUX_CONFIG_ALT6,
+	IOMUX_CONFIG_ALT7,
+	IOMUX_CONFIG_GPIO,	/* added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/* LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+#define NON_MUX_I	0x3FF
+#define NON_PAD_I	0x7FF
+
+#define IOMUX_TO_IRQ_V3(pin)		(MXC_GPIO_IRQ_START + pin)
+
+#define MX50_ELCDIF_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_DSE_HIGH)
+
+#define MX50_WVGA_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_HIGH)
+
+#define MX50_SD_PAD_CTRL		(PAD_CTL_DSE_HIGH | \
+					PAD_CTL_PUS_47K_UP | PAD_CTL_SRE_FAST)
+
+#define MX50_SD3_PAD_DAT	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_HIGH)
+#define MX50_SD3_PAD_CMD	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_HIGH)
+#define MX50_SD3_PAD_CLK	(PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_HIGH)
+#define MX50_UART_PAD_CTRL	(PAD_CTL_DSE_HIGH | PAD_CTL_PKE)
+#define MX50_I2C_PAD_CTRL	(PAD_CTL_ODE | PAD_CTL_DSE_HIGH | \
+					PAD_CTL_PUS_100K_UP | PAD_CTL_HYS)
+#define MX50_USB_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_DSE_HIGH | PAD_CTL_PUS_47K_UP)
+
+#define MX50_FEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | \
+					PAD_CTL_DSE_HIGH)
+
+#define MX50_OWIRE_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+					PAD_CTL_PUS_100K_UP | PAD_CTL_ODE | \
+					PAD_CTL_DSE_HIGH | PAD_CTL_SRE_FAST)
+
+#define MX50_PAD_KEY_COL0__GPIO_4_0	IOMUX_PAD(0x2CC, 0x20, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_ROW0__GPIO_4_1	IOMUX_PAD(0x2D0, 0x24, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_COL1__GPIO_4_2	IOMUX_PAD(0x2D4, 0x28, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_ROW1__GPIO_4_3	IOMUX_PAD(0x2D8, 0x2C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_COL2__GPIO_4_4	IOMUX_PAD(0x2DC, 0x30, 1, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_KEY_ROW2__GPIO_4_5	IOMUX_PAD(0x2E0, 0x34, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_COL3__GPIO_4_6	IOMUX_PAD(0x2E4, 0x38, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_KEY_ROW3__GPIO_4_7	IOMUX_PAD(0x2E8, 0x3C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C1_SCL__GPIO_6_18	IOMUX_PAD(0x2EC, 0x40, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C1_SDA__GPIO_6_19	IOMUX_PAD(0x2F0, 0x44, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C2_SCL__GPIO_6_20	IOMUX_PAD(0x2F4, 0x48, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C2_SDA__GPIO_6_21	IOMUX_PAD(0x2F8, 0x4C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C3_SCL__GPIO_6_22	IOMUX_PAD(0x2FC, 0x50, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_I2C3_SDA__GPIO_6_23	IOMUX_PAD(0x300, 0x54, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PWM1__GPIO_6_24	IOMUX_PAD(0x304, 0x58, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PWM2__GPIO_6_25	IOMUX_PAD(0x308, 0x5C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_OWIRE__GPIO_6_26	IOMUX_PAD(0x30C, 0x60, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPITO__GPIO_6_27	IOMUX_PAD(0x310, 0x64, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_WDOG__GPIO_6_28	IOMUX_PAD(0x314, 0x68, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_TXFS__GPIO_6_0	IOMUX_PAD(0x318, 0x6C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_TXC__GPIO_6_1	IOMUX_PAD(0x31C, 0x70, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_TXD__GPIO_6_2	IOMUX_PAD(0x320, 0x74, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_RXD__GPIO_6_3	IOMUX_PAD(0x324, 0x78, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_RXFS__GPIO_6_4	IOMUX_PAD(0x328, 0x7C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SSI_RXC__GPIO_6_5	IOMUX_PAD(0x32C, 0x80, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART1_TXD__GPIO_6_6	IOMUX_PAD(0x330, 0x84, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART1_RXD__GPIO_6_7	IOMUX_PAD(0x334, 0x88, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART1_CTS__GPIO_6_8	IOMUX_PAD(0x338, 0x8C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART1_RTS__GPIO_6_9	IOMUX_PAD(0x33C, 0x90, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART2_TXD__GPIO_6_10	IOMUX_PAD(0x340, 0x94, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART2_RXD__GPIO_6_11	IOMUX_PAD(0x344, 0x98, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART2_CTS__GPIO_6_12	IOMUX_PAD(0x348, 0x9C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART2_RTS__GPIO_6_13	IOMUX_PAD(0x34C, 0xA0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART3_TXD__GPIO_6_14	IOMUX_PAD(0x350, 0xA4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART3_RXD__GPIO_6_15	IOMUX_PAD(0x354, 0xA8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART4_TXD__GPIO_6_16	IOMUX_PAD(0x358, 0xAC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_UART4_RXD__GPIO_6_17	IOMUX_PAD(0x35C, 0xB0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_CSPI_SCLK__GPIO_4_8	IOMUX_PAD(0x360, 0xB4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_CSPI_MOSI__GPIO_4_9	IOMUX_PAD(0x364, 0xB8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_CSPI_MISO__GPIO_4_10	IOMUX_PAD(0x368, 0xBC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_CSPI_SS0__GPIO_4_11	IOMUX_PAD(0x36C, 0xC0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_ECSPI1_SCLK__GPIO_4_12	IOMUX_PAD(0x370, 0xC4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_ECSPI1_MOSI__GPIO_4_13	IOMUX_PAD(0x374, 0xC8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_ECSPI1_MISO__GPIO_4_14	IOMUX_PAD(0x378, 0xCC, 1, 0x0, 0, NO_PAD_CTRL)
+
+/* HP detect */
+#define MX50_PAD_ECSPI1_SS0__GPIO_4_15	IOMUX_PAD(0x37C, 0xD0, 1, 0x0, 0, \
+							PAD_CTL_PUS_100K_UP)
+#define MX50_PAD_ECSPI2_SCLK__GPIO_4_16	IOMUX_PAD(0x380, 0xD4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_ECSPI2_MOSI__GPIO_4_17	IOMUX_PAD(0x384, 0xD8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_ECSPI2_MISO__GPIO_4_18	IOMUX_PAD(0x388, 0xDC, 1, 0x0, 0, \
+							PAD_CTL_PUS_100K_UP)
+#define MX50_PAD_ECSPI2_SS0__GPIO_4_19	IOMUX_PAD(0x38C, 0xE0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_CLK__GPIO_5_0	IOMUX_PAD(0x390, 0xE4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_CMD__GPIO_5_1	IOMUX_PAD(0x394, 0xE8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_D0__GPIO_5_2	IOMUX_PAD(0x398, 0xEC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_D1__GPIO_5_3	IOMUX_PAD(0x39C, 0xF0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_D2__GPIO_5_4	IOMUX_PAD(0x3A0, 0xF4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD1_D3__GPIO_5_5	IOMUX_PAD(0x3A4, 0xF8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_CLK__GPIO_5_6	IOMUX_PAD(0x3A8, 0xFC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_CMD__GPIO_5_7	IOMUX_PAD(0x3AC, 0x100, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D0__GPIO_5_8	IOMUX_PAD(0x3B0, 0x104, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D1__GPIO_5_9	IOMUX_PAD(0x3B4, 0x108, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D2__GPIO_5_10	IOMUX_PAD(0x3B8, 0x10C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D3__GPIO_5_11	IOMUX_PAD(0x3BC, 0x110, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D4__GPIO_5_12	IOMUX_PAD(0x3C0, 0x114, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D5__GPIO_5_13	IOMUX_PAD(0x3C4, 0x118, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D6__GPIO_5_14	IOMUX_PAD(0x3C8, 0x11C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_D7__GPIO_5_15	IOMUX_PAD(0x3CC, 0x120, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_WP__GPIO_5_16	IOMUX_PAD(0x3D0, 0x124, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD2_CD__GPIO_5_17	IOMUX_PAD(0x3D4, 0x128, 1, 0x0, 0, NO_PAD_CTRL)
+
+#define MX50_PAD_PMIC_ON_REQ__PMIC_ON_REQ	IOMUX_PAD(0x3D8, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_STBY_REQ__PMIC_STBY_REQ	IOMUX_PAD(0x3DC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_PORT_B__PMIC_PORT_B	IOMUX_PAD(0x3E0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_BOOT_MODE1__PMIC_BOOT_MODE1	IOMUX_PAD(0x3E4, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_RESET_IN_B__PMIC_RESET_IN_B	IOMUX_PAD(0x3E8, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_BOOT_MODE0__PMIC_BOOT_MODE0	IOMUX_PAD(0x3EC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_TEST_MODE__PMIC_TEST_MODE	IOMUX_PAD(0x3F0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_TMS__PMIC_JTAG_TMS	IOMUX_PAD(0x3F4, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_MOD__PMIC_JTAG_MOD	IOMUX_PAD(0x3F8, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_TRSTB__PMIC_JTAG_TRSTB	IOMUX_PAD(0x3FC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_TDI__PMIC_JTAG_TDI	IOMUX_PAD(0x400, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_TCK__PMIC_JTAG_TCK	IOMUX_PAD(0x404, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_PMIC_JTAG_TDO__PMIC_JTAG_TDO	IOMUX_PAD(0x408, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+
+#define MX50_PAD_DISP_D0__GPIO_2_0	IOMUX_PAD(0x40C, 0x12C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D1__GPIO_2_1	IOMUX_PAD(0x410, 0x130, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D2__GPIO_2_2	IOMUX_PAD(0x414, 0x134, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D3__GPIO_2_3	IOMUX_PAD(0x418, 0x138, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D4__GPIO_2_4	IOMUX_PAD(0x41C, 0x13C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D5__GPIO_2_5	IOMUX_PAD(0x420, 0x140, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D6__GPIO_2_6	IOMUX_PAD(0x424, 0x144, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D7__GPIO_2_7	IOMUX_PAD(0x428, 0x148, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_WR__GPIO_2_16	IOMUX_PAD(0x42C, 0x14C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_RD__GPIO_2_19	IOMUX_PAD(0x430, 0x150, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_RS__GPIO_2_17	IOMUX_PAD(0x434, 0x154, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_CS__GPIO_2_21	IOMUX_PAD(0x438, 0x158, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_BUSY__GPIO_2_18	IOMUX_PAD(0x43C, 0x15C, 1, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_RESET__GPIO_2_20	IOMUX_PAD(0x440, 0x160, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_CMD__GPIO_5_18	IOMUX_PAD(0x444, 0x164, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_CLK__GPIO_5_19	IOMUX_PAD(0x448, 0x168, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D0__GPIO_5_20	IOMUX_PAD(0x44C, 0x16C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D1__GPIO_5_21	IOMUX_PAD(0x450, 0x170, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D2__GPIO_5_22	IOMUX_PAD(0x454, 0x174, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D3__GPIO_5_23	IOMUX_PAD(0x458, 0x178, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D4__GPIO_5_24	IOMUX_PAD(0x45C, 0x17C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D5__GPIO_5_25	IOMUX_PAD(0x460, 0x180, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D6__GPIO_5_26	IOMUX_PAD(0x464, 0x184, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_D7__GPIO_5_27	IOMUX_PAD(0x468, 0x188, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_SD3_WP__GPIO_5_28	IOMUX_PAD(0x46C, 0x18C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D8__GPIO_2_8	IOMUX_PAD(0x470, 0x190, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D9__GPIO_2_9	IOMUX_PAD(0x474, 0x194, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D10__GPIO_2_10	IOMUX_PAD(0x478, 0x198, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D11__GPIO_2_11	IOMUX_PAD(0x47C, 0x19C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D12__GPIO_2_12	IOMUX_PAD(0x480, 0x1A0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D13__GPIO_2_13	IOMUX_PAD(0x484, 0x1A4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D14__GPIO_2_14	IOMUX_PAD(0x488, 0x1A8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_DISP_D15__GPIO_2_15	IOMUX_PAD(0x48C, 0x1AC, 1, 0x0, 0, NO_PAD_CTRL)
+
+#define MX50_PAD_EPDC_D0__GPIO_3_0	IOMUX_PAD(0x54C, 0x1B0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D1__GPIO_3_1	IOMUX_PAD(0x550, 0x1B4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D2__GPIO_3_2	IOMUX_PAD(0x554, 0x1B8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D3__GPIO_3_3	IOMUX_PAD(0x558, 0x1BC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D4__GPIO_3_4	IOMUX_PAD(0x55C, 0x1C0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D5__GPIO_3_5	IOMUX_PAD(0x560, 0x1C4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D6__GPIO_3_6	IOMUX_PAD(0x564, 0x1C8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D7__GPIO_3_7	IOMUX_PAD(0x568, 0x1CC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D8__GPIO_3_8	IOMUX_PAD(0x56C, 0x1D0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D9__GPIO_3_9	IOMUX_PAD(0x570, 0x1D4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D10__GPIO_3_10	IOMUX_PAD(0x574, 0x1D8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D11__GPIO_3_11	IOMUX_PAD(0x578, 0x1DC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D12__GPIO_3_12	IOMUX_PAD(0x57C, 0x1E0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D13__GPIO_3_13	IOMUX_PAD(0x580, 0x1E4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D14__GPIO_3_14	IOMUX_PAD(0x584, 0x1E8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D15__GPIO_3_15	IOMUX_PAD(0x588, 0x1EC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDCLK__GPIO_3_16	IOMUX_PAD(0x58C, 0x1F0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDSP__GPIO_3_17	IOMUX_PAD(0x590, 0x1F4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDOE__GPIO_3_18	IOMUX_PAD(0x594, 0x1F8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDRL__GPIO_3_19	IOMUX_PAD(0x598, 0x1FC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCLK__GPIO_3_20	IOMUX_PAD(0x59C, 0x200, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDOEZ__GPIO_3_21	IOMUX_PAD(0x5A0, 0x204, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDOED__GPIO_3_22	IOMUX_PAD(0x5A4, 0x208, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDOE__GPIO_3_23	IOMUX_PAD(0x5A8, 0x20C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDLE__GPIO_3_24	IOMUX_PAD(0x5AC, 0x210, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCLKN__GPIO_3_25	IOMUX_PAD(0x5B0, 0x214, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDSHR__GPIO_3_26	IOMUX_PAD(0x5B4, 0x218, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRCOM__GPIO_3_27	IOMUX_PAD(0x5B8, 0x21C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRSTAT__GPIO_3_28	IOMUX_PAD(0x5BC, 0x220, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRCTRL0__GPIO_3_29	IOMUX_PAD(0x5C0, 0x224, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRCTRL1__GPIO_3_30	IOMUX_PAD(0x5C4, 0x228, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRCTRL2__GPIO_3_31	IOMUX_PAD(0x5C8, 0x22C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_PWRCTRL3__GPIO_4_20	IOMUX_PAD(0x5CC, 0x230, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_VCOM0__GPIO_4_21	IOMUX_PAD(0x5D0, 0x234, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_VCOM1__GPIO_4_22	IOMUX_PAD(0x5D4, 0x238, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_BDR0__GPIO_4_23	IOMUX_PAD(0x5D8, 0x23C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_BDR1__GPIO_4_24	IOMUX_PAD(0x5DC, 0x240, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE0__GPIO_4_25	IOMUX_PAD(0x5E0, 0x244, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE1__GPIO_4_26	IOMUX_PAD(0x5E4, 0x248, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE2__GPIO_4_27	IOMUX_PAD(0x5E8, 0x24C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE3__GPIO_4_28	IOMUX_PAD(0x5EC, 0x250, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE4__GPIO_4_29	IOMUX_PAD(0x5F0, 0x254, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE5__GPIO_4_30	IOMUX_PAD(0x5F4, 0x258, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA0__GPIO_1_0	IOMUX_PAD(0x5F8, 0x25C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA1__GPIO_1_1	IOMUX_PAD(0x5FC, 0x260, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA2__GPIO_1_2	IOMUX_PAD(0x600, 0x264, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA3__GPIO_1_3	IOMUX_PAD(0x604, 0x268, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA4__GPIO_1_4	IOMUX_PAD(0x608, 0x26C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA5__GPIO_1_5	IOMUX_PAD(0x60C, 0x270, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA6__GPIO_1_6	IOMUX_PAD(0x610, 0x274, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA7__GPIO_1_7	IOMUX_PAD(0x614, 0x278, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA8__GPIO_1_8	IOMUX_PAD(0x618, 0x27C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA9__GPIO_1_9	IOMUX_PAD(0x61C, 0x280, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA10__GPIO_1_10	IOMUX_PAD(0x620, 0x284, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA11__GPIO_1_11	IOMUX_PAD(0x624, 0x288, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA12__GPIO_1_12	IOMUX_PAD(0x628, 0x28C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA13__GPIO_1_13	IOMUX_PAD(0x62C, 0x290, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA14__GPIO_1_14	IOMUX_PAD(0x630, 0x294, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_DA15__GPIO_1_15	IOMUX_PAD(0x634, 0x298, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_CS2__GPIO_1_16	IOMUX_PAD(0x638, 0x29C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_CS1__GPIO_1_17	IOMUX_PAD(0x63C, 0x2A0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_CS0__GPIO_1_18	IOMUX_PAD(0x640, 0x2A4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_EB0__GPIO_1_19	IOMUX_PAD(0x644, 0x2A8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_EB1__GPIO_1_20	IOMUX_PAD(0x648, 0x2AC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_WAIT__GPIO_1_21	IOMUX_PAD(0x64C, 0x2B0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_BCLK__GPIO_1_22	IOMUX_PAD(0x650, 0x2B4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_RDY__GPIO_1_23	IOMUX_PAD(0x654, 0x2B8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_OE__GPIO_1_24	IOMUX_PAD(0x658, 0x2BC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_RW__GPIO_1_25	IOMUX_PAD(0x65C, 0x2C0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_LBA__GPIO_1_26	IOMUX_PAD(0x660, 0x2C4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX50_PAD_EIM_CRE__GPIO_1_27	IOMUX_PAD(0x664, 0x2C8, 1, 0x0, 0, NO_PAD_CTRL)
+
+
+/* SD1 */
+#define MX50_PAD_SD1_CMD__SD1_CMD	IOMUX_PAD(0x394, 0xE8, \
+					IOMUX_CONFIG_SION, 0x0, 0, \
+					MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD1_CLK__SD1_CLK	IOMUX_PAD(0x390, 0xE4, \
+					IOMUX_CONFIG_SION, 0x0, 0, \
+					MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD1_D0__SD1_D0	IOMUX_PAD(0x398, 0xEC, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD1_D1__SD1_D1	IOMUX_PAD(0x39C, 0xF0, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD1_D2__SD1_D2	IOMUX_PAD(0x3A0, 0xF4, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD1_D3__SD1_D3	IOMUX_PAD(0x3A4, 0xF8, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+
+/* SD2 */
+#define MX50_PAD_SD2_CLK__SD2_CLK	IOMUX_PAD(0x3A8, 0xFC, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_CMD__SD2_CMD	IOMUX_PAD(0x3AC, 0x100, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D0__SD2_D0	IOMUX_PAD(0x3B0, 0x104, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D1__SD2_D1	IOMUX_PAD(0x3B4, 0x108, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D2__SD2_D2	IOMUX_PAD(0x3B8, 0x10C, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D3__SD2_D3	IOMUX_PAD(0x3BC, 0x110, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D4__SD2_D4	IOMUX_PAD(0x3C0, 0x114, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D5__SD2_D5	IOMUX_PAD(0x3C4, 0x118, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D6__SD2_D6	IOMUX_PAD(0x3C8, 0x11C, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+#define MX50_PAD_SD2_D7__SD2_D7	IOMUX_PAD(0x3CC, 0x120, 0, 0x0, 0, \
+						MX50_SD_PAD_CTRL)
+
+/* SD3 */
+#define MX50_PAD_SD3_CMD__SD3_CMD	IOMUX_PAD(0x444, 0x164, 0, 0x0, 0, \
+						MX50_SD3_PAD_CMD)
+#define MX50_PAD_SD3_CLK__SD3_CLK	IOMUX_PAD(0x448, 0x168, 0, 0x0, 0, \
+						MX50_SD3_PAD_CLK)
+#define MX50_PAD_SD3_D0__SD3_D0	IOMUX_PAD(0x44C, 0x16C, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D1__SD3_D1	IOMUX_PAD(0x450, 0x170, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D2__SD3_D2	IOMUX_PAD(0x454, 0x174, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D3__SD3_D3	IOMUX_PAD(0x458, 0x178, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D4__SD3_D4	IOMUX_PAD(0x45C, 0x17C, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D5__SD3_D5	IOMUX_PAD(0x460, 0x180, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D6__SD3_D6	IOMUX_PAD(0x464, 0x184, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+#define MX50_PAD_SD3_D7__SD3_D7	IOMUX_PAD(0x468, 0x188, 0, 0x0, 0, \
+						MX50_SD3_PAD_DAT)
+
+/* OWIRE */
+#define MX50_PAD_OWIRE__OWIRE	IOMUX_PAD(0x30C, 0x60, 0, 0x0, 0, \
+						MX50_OWIRE_PAD_CTRL)
+
+/* SSI */
+#define MX50_PAD_SSI_TXFS__SSI_TXFS	IOMUX_PAD(0x318, 0x6C, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_SSI_TXC__SSI_TXC	IOMUX_PAD(0x31C, 0x70, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_SSI_TXD__SSI_TXD	IOMUX_PAD(0x320, 0x74, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_SSI_RXD__SSI_RXD	IOMUX_PAD(0x324, 0x78, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+
+/* UART1 and UART2 */
+#define MX50_PAD_UART1_TXD__UART1_TXD	IOMUX_PAD(0x330, 0x84, 0, 0x0, 0, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART1_RXD__UART1_RXD	IOMUX_PAD(0x334, 0x88, 0, 0x7c4, 1, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART1_CTS__UART1_CTS	IOMUX_PAD(0x338, 0x8C, 0, 0x0, 0, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART1_RTS__UART1_RTS	IOMUX_PAD(0x33C, 0x90, 0, 0x7c0, 1, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART2_TXD__UART2_TXD	IOMUX_PAD(0x340, 0x94, 0, 0x0, 0, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART2_RXD__UART2_RXD	IOMUX_PAD(0x344, 0x98, 0, 0x7cc, 3, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART2_CTS__UART2_CTS	IOMUX_PAD(0x348, 0x9C, 0, 0x0, 0, \
+						MX50_UART_PAD_CTRL)
+#define MX50_PAD_UART2_RTS__UART2_RTS	IOMUX_PAD(0x34C, 0xA0, 0, 0x7c8, 3, \
+						MX50_UART_PAD_CTRL)
+
+/* I2C1, I2C2, I2C3 */
+#define MX50_PAD_I2C1_SCL__I2C1_SCL	IOMUX_PAD(0x2EC, 0x40, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+#define MX50_PAD_I2C1_SDA__I2C1_SDA	IOMUX_PAD(0x2F0, 0x44, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+#define MX50_PAD_I2C2_SCL__I2C2_SCL	IOMUX_PAD(0x2F4, 0x48, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+#define MX50_PAD_I2C2_SDA__I2C2_SDA	IOMUX_PAD(0x2F8, 0x4C, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+#define MX50_PAD_I2C3_SCL__I2C3_SCL	IOMUX_PAD(0x2FC, 0x50, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+#define MX50_PAD_I2C3_SDA__I2C3_SDA	IOMUX_PAD(0x300, 0x54, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX50_I2C_PAD_CTRL)
+
+/* EPDC */
+#define MX50_PAD_EPDC_D0__EPDC_D0	IOMUX_PAD(0x54C, 0x1B0, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D1__EPDC_D1	IOMUX_PAD(0x550, 0x1B4, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D2__EPDC_D2	IOMUX_PAD(0x554, 0x1B8, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D3__EPDC_D3	IOMUX_PAD(0x558, 0x1BC, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D4__EPDC_D4	IOMUX_PAD(0x55C, 0x1C0, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D5__EPDC_D5	IOMUX_PAD(0x560, 0x1C4, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D6__EPDC_D6	IOMUX_PAD(0x564, 0x1C8, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_D7__EPDC_D7	IOMUX_PAD(0x568, 0x1CC, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDCLK__EPDC_GDCLK	IOMUX_PAD(0x58C, 0x1F0, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDSP__EPDC_GDSP	IOMUX_PAD(0x590, 0x1F4, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDOE__EPDC_GDOE	IOMUX_PAD(0x594, 0x1F8, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_GDRL__EPDC_GDRL	IOMUX_PAD(0x598, 0x1FC, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCLK__EPDC_SDCLK	IOMUX_PAD(0x59C, 0x200, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDOE__EPDC_SDOE	IOMUX_PAD(0x5A8, 0x20C, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDLE__EPDC_SDLE	IOMUX_PAD(0x5AC, 0x210, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDSHR__EPDC_SDSHR	IOMUX_PAD(0x5B4, 0x218, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_BDR0__EPDC_BDR0	IOMUX_PAD(0x5D8, 0x23C, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE0__EPDC_SDCE0	IOMUX_PAD(0x5E0, 0x244, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE1__EPDC_SDCE1	IOMUX_PAD(0x5E4, 0x248, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_EPDC_SDCE2__EPDC_SDCE2	IOMUX_PAD(0x5E8, 0x24C, 0, 0x0, 0, \
+							NO_PAD_CTRL)
+#define MX50_PAD_DISP_D8__DISP_D8	IOMUX_PAD(0x470, 0x190, 0, \
+					0x0, 0, MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D9__DISP_D9	IOMUX_PAD(0x474, 0x194, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D10__DISP_D10	IOMUX_PAD(0x478, 0x198, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D11__DISP_D11	IOMUX_PAD(0x47C, 0x19C, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D12__DISP_D12	IOMUX_PAD(0x480, 0x1A0, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D13__DISP_D13	IOMUX_PAD(0x484, 0x1A4, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D14__DISP_D14	IOMUX_PAD(0x488, 0x1A8, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_D15__DISP_D15	IOMUX_PAD(0x48C, 0x1AC, 0, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_RS__ELCDIF_VSYNC	IOMUX_PAD(0x434, 0x154, 2, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_CS__ELCDIF_HSYNC	IOMUX_PAD(0x438, 0x158, 2, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_RD__ELCDIF_EN	IOMUX_PAD(0x430, 0x150, 2, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+#define MX50_PAD_DISP_WR__ELCDIF_PIXCLK	IOMUX_PAD(0x42C, 0x14C, 2, 0x0, 0, \
+						MX50_ELCDIF_PAD_CTRL)
+
+/* USB */
+#define MX50_PAD_EPITO__USBH1_PWR	IOMUX_PAD(0x310, 0x64, 2, 0x0, 0, \
+						PAD_CTL_PKE | PAD_CTL_DSE_HIGH)
+#define MX50_PAD_OWIRE__USBH1_OC	IOMUX_PAD(0x30C, 0x60, 2, 0x0, 0, \
+						MX50_USB_PAD_CTRL)
+#define MX50_PAD_PWM2__USBOTG_PWR	IOMUX_PAD(0x308, 0x5C, 2, 0x0, 0, \
+						PAD_CTL_PKE | PAD_CTL_DSE_HIGH)
+#define MX50_PAD_PWM1__USBOTG_OC	IOMUX_PAD(0x304, 0x58, 2, 0x7E8, 1, \
+						MX50_USB_PAD_CTRL)
+
+/* FEC */
+#define MX50_PAD_SSI_RXC__FEC_MDIO	IOMUX_PAD(0x32C, 0x80, 6, 0x774, 1, \
+						MX50_FEC_PAD_CTRL)
+#define MX50_PAD_DISP_D0__FEC_TXCLK	IOMUX_PAD(0x40C, 0x12C, 2, 0x0, 0, \
+						PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX50_PAD_DISP_D1__FEC_RX_ER	IOMUX_PAD(0x410, 0x130, 2, 0x788, 0, \
+						PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX50_PAD_DISP_D2__FEC_RX_DV	IOMUX_PAD(0x414, 0x134, 2, 0x784, 0, \
+						PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX50_PAD_DISP_D3__FEC_RXD1	IOMUX_PAD(0x418, 0x138, 2, 0x77C, 0, \
+						PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX50_PAD_DISP_D4__FEC_RXD0	IOMUX_PAD(0x41C, 0x13C, 2, 0x778, 0, \
+						PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX50_PAD_DISP_D5__FEC_TX_EN	IOMUX_PAD(0x420, 0x140, 2, 0x0, 0, \
+						PAD_CTL_DSE_HIGH)
+#define MX50_PAD_DISP_D6__FEC_TXD1	IOMUX_PAD(0x424, 0x144, 2, 0x0, 0, \
+						PAD_CTL_DSE_HIGH)
+#define MX50_PAD_DISP_D7__FEC_TXD0	IOMUX_PAD(0x428, 0x148, 2, 0x0, 0, \
+						PAD_CTL_DSE_HIGH)
+#define MX50_PAD_SSI_RXFS__FEC_MDC	IOMUX_PAD(0x328, 0x7C, 6, 0x0, 0, \
+						PAD_CTL_DSE_HIGH)
+
+/* WVGA */
+#define MX50_PAD_DISP_D0__DISP_D0	IOMUX_PAD(0x40C, 0x12C, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D1__DISP_D1	IOMUX_PAD(0x410, 0x130, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D2__DISP_D2	IOMUX_PAD(0x414, 0x134, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D3__DISP_D3	IOMUX_PAD(0x418, 0x138, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D4__DISP_D4	IOMUX_PAD(0x41C, 0x13C, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D5__DISP_D5	IOMUX_PAD(0x420, 0x140, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D6__DISP_D6	IOMUX_PAD(0x424, 0x144, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+#define MX50_PAD_DISP_D7__DISP_D7	IOMUX_PAD(0x428, 0x148, 0, 0x0, 0, \
+						MX50_WVGA_PAD_CTRL)
+
+/* CSPI */
+#define MX50_PAD_CSPI_SS0__CSPI_SS0	IOMUX_PAD(0x36C, 0xC0, 0, 0x0, 0, \
+						PAD_CTL_PKE | PAD_CTL_PUE | \
+						PAD_CTL_DSE_HIGH)
+#define MX50_PAD_ECSPI1_MOSI__CSPI_SS1	IOMUX_PAD(0x374, 0xC8, 2, 0x0, 0, \
+						PAD_CTL_PKE | PAD_CTL_PUE | \
+						PAD_CTL_PUS_22K_UP | \
+						PAD_CTL_DSE_HIGH)
+#define MX50_PAD_CSPI_MOSI__CSPI_MOSI	IOMUX_PAD(0x364, 0xB8, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+#define MX50_PAD_CSPI_MISO__CSPI_MISO	IOMUX_PAD(0x368, 0xBC, 0, 0x0, 0, \
+						NO_PAD_CTRL)
+
+
+#endif /* __MACH_IOMUX_MX53_H__ */
+
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx51.h b/arch/arm/plat-mxc/include/mach/iomux-mx51.h
index ab0f95d..9c0339c 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx51.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx51.h
@@ -31,6 +31,8 @@ typedef enum iomux_config {
 	IOMUX_CONFIG_SION = 0x1 << 4,	/* LOOPBACK:MUX SION bit */
 } iomux_pin_cfg_t;
 
+#define IOMUX_TO_IRQ_V3(pin)	(MXC_GPIO_IRQ_START + pin)
+
 /* Pad control groupings */
 #define MX51_UART1_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
 				PAD_CTL_DSE_HIGH)
@@ -38,36 +40,79 @@ typedef enum iomux_config {
 				PAD_CTL_SRE_FAST)
 #define MX51_UART3_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_DSE_HIGH | \
 				PAD_CTL_SRE_FAST)
+#define MX51_I2C_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_ODE | \
+						PAD_CTL_DSE_HIGH | PAD_CTL_PUS_100K_UP | PAD_CTL_HYS)
 #define MX51_USBH1_PAD_CTRL	(PAD_CTL_SRE_FAST | PAD_CTL_DSE_HIGH | \
 				PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
 				PAD_CTL_PKE | PAD_CTL_HYS)
 #define MX51_GPIO_PAD_CTRL		(PAD_CTL_DSE_HIGH | PAD_CTL_PKE | \
 				PAD_CTL_SRE_FAST)
 
+#define MX51_PAD_CTRL_1	(PAD_CTL_SRE_FAST | PAD_CTL_DSE_HIGH | \
+					PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_HYS)
+#define MX51_PAD_CTRL_2	(PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX51_PAD_CTRL_3	(PAD_CTL_PKE | PAD_CTL_PUS_100K_UP)
+#define MX51_PAD_CTRL_4	(PAD_CTL_DVS | PAD_CTL_HYS | PAD_CTL_PKE)
+#define MX51_PAD_CTRL_5	(PAD_CTL_DVS | PAD_CTL_DSE_HIGH)
+
+#define MX51_PAD_CTRL_6	(PAD_CTL_SRE_SLOW | PAD_CTL_DSE_MED | \
+				PAD_CTL_PUS_100K_UP | PAD_CTL_HYS | PAD_CTL_DVS)
+#define MX51_PAD_CTRL_7	MX51_UART2_PAD_CTRL
+#define MX51_PAD_CTRL_8	(PAD_CTL_HYS | PAD_CTL_PKE | \
+							PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_HIGH)
+#define MX51_PAD_CTRL_9	(PAD_CTL_HYS | PAD_CTL_PUS_100K_UP)
+#define MX51_PAD_CTRL_10	(PAD_CTL_SRE_FAST | PAD_CTL_DSE_HIGH | \
+							PAD_CTL_PUS_100K_UP)
+#define MX51_PAD_CTRL_11	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_DSE_HIGH | \
+							PAD_CTL_SRE_FAST)
+#define MX51_PAD_CTRL_12	(PAD_CTL_PKE | PAD_CTL_DSE_LOW | PAD_CTL_SRE_SLOW)
+#define MX51_PAD_CTRL_13	(PAD_CTL_PKE | PAD_CTL_PUE)
+
+#define MX51_SD_PAD_CTRL	(PAD_CTL_DSE_MAX | PAD_CTL_DVS | \
+				PAD_CTL_PUS_22K_UP | PAD_CTL_PUE | \
+				PAD_CTL_PKE | PAD_CTL_SRE_FAST)
+
+
 /*
  * The naming convention for the pad modes is MX51_PAD_<padname>__<padmode>
  * If <padname> or <padmode> refers to a GPIO, it is named
  * GPIO_<unit>_<num> see also iomux-v3.h
  */
 
-/*
- * FIXME: This was converted using scripts from existing Freescale code to
- * this form used upstream. Need to verify the name format.
- */
-
 /*						PAD      MUX   ALT INPSE PATH PADCTRL */
+/* EIM */
+#define MX51_PAD_EIM_DA0__EIM_DA0	IOMUX_PAD(0x7a8, 0x01c, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA1__EIM_DA1	IOMUX_PAD(0x7a8, 0x020, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA2__EIM_DA2	IOMUX_PAD(0x7a8, 0x024, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA3__EIM_DA3	IOMUX_PAD(0x7a8, 0x028, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA4__EIM_DA4	IOMUX_PAD(0x7ac, 0x02c, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA5__EIM_DA5	IOMUX_PAD(0x7ac, 0x030, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA6__EIM_DA6	IOMUX_PAD(0x7ac, 0x034, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA7__EIM_DA7	IOMUX_PAD(0x7ac, 0x038, 0, 0x0,   0, NO_PAD_CTRL)
+
+#define MX51_PAD_EIM_DA8__EIM_DA8	IOMUX_PAD(0x7b0, 0x03c, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA9__EIM_DA9	IOMUX_PAD(0x7b0, 0x040, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA10__EIM_DA10	IOMUX_PAD(0x7b0, 0x044, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA11__EIM_DA11	IOMUX_PAD(0x7b0, 0x048, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA12__EIM_DA12	IOMUX_PAD(0x7bc, 0x04c, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA13__EIM_DA13	IOMUX_PAD(0x7bc, 0x050, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA14__EIM_DA14	IOMUX_PAD(0x7bc, 0x054, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DA15__EIM_DA15	IOMUX_PAD(0x7bc, 0x058, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_D16__GPIO_2_0              IOMUX_PAD(0x3f0, 0x05c, 1, 0x0,   0, NO_PAD_CTRL)
 
-#define MX51_PAD_GPIO_2_0__EIM_D16	IOMUX_PAD(0x3f0, 0x05c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_1__EIM_D17	IOMUX_PAD(0x3f4, 0x060, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_2__EIM_D18	IOMUX_PAD(0x3f8, 0x064, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_3__EIM_D19	IOMUX_PAD(0x3fc, 0x068, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_4__EIM_D20	IOMUX_PAD(0x400, 0x06c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_5__EIM_D21	IOMUX_PAD(0x404, 0x070, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_D21__GPIO_2_5	IOMUX_PAD(0x404, 0x070, IOMUX_CONFIG_ALT1, 0x0,   0, MX51_GPIO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_6__EIM_D22	IOMUX_PAD(0x408, 0x074, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_7__EIM_D23	IOMUX_PAD(0x40c, 0x078, 1, 0x0,   0, NO_PAD_CTRL)
-
-/* Babbage UART3 */
+#define MX51_PAD_EIM_D16__I2C1_SDA	IOMUX_PAD(0x3f0, 0x05c, IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION, \
+										0x9b4, 0, MX51_I2C_PAD_CTRL)
+#define MX51_PAD_EIM_D17__GPIO_2_1	IOMUX_PAD(0x3f4, 0x060, 1, 0x0, 0, MX51_GPIO_PAD_CTRL)
+#define MX51_PAD_EIM_D18__GPIO_2_2	IOMUX_PAD(0x3f8, 0x064, 1, 0x0, 0, MX51_PAD_CTRL_10 | MX51_PAD_CTRL_13)
+#define MX51_PAD_EIM_D19__GPIO_2_3	IOMUX_PAD(0x3fc, 0x068, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_D19__I2C1_SCL	IOMUX_PAD(0x3fc, 0x068, IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION, \
+										0x9b0, 0, MX51_I2C_PAD_CTRL)
+#define MX51_PAD_EIM_D20__GPIO_2_4	IOMUX_PAD(0x400, 0x06c, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_D21__GPIO_2_5	IOMUX_PAD(0x404, 0x070, 1, 0x0, 0, MX51_PAD_CTRL_10 | MX51_PAD_CTRL_13)
+#define MX51_PAD_EIM_D22__GPIO_2_6	IOMUX_PAD(0x408, 0x074, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_D23__GPIO_2_7	IOMUX_PAD(0x40c, 0x078, 1, 0x0, 0, MX51_PAD_CTRL_7)
+
+/* UART3 */
 #define MX51_PAD_EIM_D24__UART3_CTS	IOMUX_PAD(0x410, 0x07c, IOMUX_CONFIG_ALT3, 0x0, 0, MX51_UART3_PAD_CTRL)
 #define MX51_PAD_EIM_D25__UART3_RXD	IOMUX_PAD(0x414, 0x080, IOMUX_CONFIG_ALT3, 0x9f4, 0, MX51_UART3_PAD_CTRL)
 #define MX51_PAD_EIM_D26__UART3_TXD	IOMUX_PAD(0x418, 0x084, IOMUX_CONFIG_ALT3, 0x0, 0, MX51_UART3_PAD_CTRL)
@@ -78,80 +123,96 @@ typedef enum iomux_config {
 #define MX51_PAD_EIM_D30__EIM_D30	IOMUX_PAD(0x428, 0x094, 0, 0x0,   0, NO_PAD_CTRL)
 #define MX51_PAD_EIM_D31__EIM_D31	IOMUX_PAD(0x42c, 0x09c, 0, 0x0,   0, NO_PAD_CTRL)
 
-#define MX51_PAD_GPIO_2_10__EIM_A16	IOMUX_PAD(0x430, 0x09c, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_11__EIM_A17	IOMUX_PAD(0x434, 0x0a0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_12__EIM_A18	IOMUX_PAD(0x438, 0x0a4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_13__EIM_A19	IOMUX_PAD(0x43c, 0x0a8, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_14__EIM_A20	IOMUX_PAD(0x440, 0x0ac, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_15__EIM_A21	IOMUX_PAD(0x444, 0x0b0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_16__EIM_A22	IOMUX_PAD(0x448, 0x0b4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_17__EIM_A23	IOMUX_PAD(0x44c, 0x0b8, 1, 0x0,   0, NO_PAD_CTRL)
-
-#define MX51_PAD_GPIO_2_18__EIM_A24	IOMUX_PAD(0x450, 0x0bc, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_19__EIM_A25	IOMUX_PAD(0x454, 0x0c0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_20__EIM_A26	IOMUX_PAD(0x458, 0x0c4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_21__EIM_A27	IOMUX_PAD(0x45c, 0x0c8, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A16__GPIO_2_10	IOMUX_PAD(0x430, 0x09c, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A17__GPIO_2_11	IOMUX_PAD(0x434, 0x0a0, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A18__GPIO_2_12	IOMUX_PAD(0x438, 0x0a4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A19__GPIO_2_13	IOMUX_PAD(0x43c, 0x0a8, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A20__GPIO_2_14	IOMUX_PAD(0x440, 0x0ac, 1, 0x0,   0, PAD_CTL_PKE)
+#define MX51_PAD_EIM_A21__GPIO_2_15	IOMUX_PAD(0x444, 0x0b0, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A22__GPIO_2_16	IOMUX_PAD(0x448, 0x0b4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A23__GPIO_2_17	IOMUX_PAD(0x44c, 0x0b8, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A24__GPIO_2_18	IOMUX_PAD(0x450, 0x0bc, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A25__GPIO_2_19	IOMUX_PAD(0x454, 0x0c0, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A26__GPIO_2_20	IOMUX_PAD(0x458, 0x0c4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_A27__GPIO_2_21	IOMUX_PAD(0x45c, 0x0c8, 1, 0x0,   0, MX51_PAD_CTRL_10)
+#define MX51_PAD_EIM_EB2__GPIO_2_22	IOMUX_PAD(0x468, 0x0d4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_EB3__GPIO_2_23	IOMUX_PAD(0x46c, 0x0d8, 1, 0x0,   0, NO_PAD_CTRL)
 #define MX51_PAD_EIM_EB0__EIM_EB0	IOMUX_PAD(0x460, 0x0cc, 0, 0x0,   0, NO_PAD_CTRL)
 #define MX51_PAD_EIM_EB1__EIM_EB1	IOMUX_PAD(0x464, 0x0d0, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_22__EIM_EB2	IOMUX_PAD(0x468, 0x0d4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_23__EIM_EB3	IOMUX_PAD(0x46c, 0x0d8, 1, 0x0,   0, NO_PAD_CTRL)
-
-#define MX51_PAD_GPIO_2_24__EIM_OE	IOMUX_PAD(0x470, 0x0dc, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_25__EIM_CS0	IOMUX_PAD(0x474, 0x0e0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_26__EIM_CS1	IOMUX_PAD(0x478, 0x0e4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_27__EIM_CS2	IOMUX_PAD(0x47c, 0x0e8, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_28__EIM_CS3	IOMUX_PAD(0x480, 0x0ec, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_29__EIM_CS4	IOMUX_PAD(0x484, 0x0f0, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_30__EIM_CS5	IOMUX_PAD(0x488, 0x0f4, 1, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_2_31__EIM_DTACK	IOMUX_PAD(0x48c, 0x0f8, 1, 0x0,   0, NO_PAD_CTRL)
-
-#define MX51_PAD_GPIO_3_1__EIM_LBA	IOMUX_PAD(0x494, 0xFC, 1, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_2__EIM_CRE	IOMUX_PAD(0x4A0, 0x100, 1, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DRAM_CS1__DRAM_CS1	IOMUX_PAD(0x4D0, 0x104, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_3__NANDF_WE_B	IOMUX_PAD(0x4E4, 0x108, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_4__NANDF_RE_B	IOMUX_PAD(0x4E8, 0x10C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_5__NANDF_ALE	IOMUX_PAD(0x4EC, 0x110, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_6__NANDF_CLE	IOMUX_PAD(0x4F0, 0x114, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_7__NANDF_WP_B	IOMUX_PAD(0x4F4, 0x118, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_8__NANDF_RB0	IOMUX_PAD(0x4F8, 0x11C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_9__NANDF_RB1	IOMUX_PAD(0x4FC, 0x120, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_10__NANDF_RB2	IOMUX_PAD(0x500, 0x124, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_11__NANDF_RB3	IOMUX_PAD(0x504, 0x128, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_12__GPIO_NAND	IOMUX_PAD(0x514, 0x12C, 3, 0x0, 0, NO_PAD_CTRL)
-/* REVISIT: Not sure of these values
-
-  #define MX51_PAD_GPIO_1___NANDF_RB4	IOMUX_PAD(, , , 0x0, 0, NO_PAD_CTRL)
-  #define MX51_PAD_GPIO_3_13__NANDF_RB5	IOMUX_PAD(0x5D8, 0x130, 3, 0x0, 0, NO_PAD_CTRL)
-  #define MX51_PAD_GPIO_3_15__NANDF_RB7	IOMUX_PAD(0x5E0, 0x138, 3, 0x0, 0, NO_PAD_CTRL)
-*/
-#define MX51_PAD_GPIO_3_14__NANDF_RB6	IOMUX_PAD(0x5DC, 0x134, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_16__NANDF_CS0	IOMUX_PAD(0x518, 0x130, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_17__NANDF_CS1	IOMUX_PAD(0x51C, 0x134, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_18__NANDF_CS2	IOMUX_PAD(0x520, 0x138, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_19__NANDF_CS3	IOMUX_PAD(0x524, 0x13C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_20__NANDF_CS4	IOMUX_PAD(0x528, 0x140, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_21__NANDF_CS5	IOMUX_PAD(0x52C, 0x144, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_22__NANDF_CS6	IOMUX_PAD(0x530, 0x148, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_23__NANDF_CS7	IOMUX_PAD(0x534, 0x14C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_24__NANDF_RDY_INT	IOMUX_PAD(0x538, 0x150, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_25__NANDF_D15	IOMUX_PAD(0x53C, 0x154, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_26__NANDF_D14	IOMUX_PAD(0x540, 0x158, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_27__NANDF_D13	IOMUX_PAD(0x544, 0x15C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_28__NANDF_D12	IOMUX_PAD(0x548, 0x160, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_29__NANDF_D11	IOMUX_PAD(0x54C, 0x164, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_30__NANDF_D10	IOMUX_PAD(0x550, 0x168, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_31__NANDF_D9	IOMUX_PAD(0x554, 0x16C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_0__NANDF_D8	IOMUX_PAD(0x558, 0x170, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_1__NANDF_D7	IOMUX_PAD(0x55C, 0x174, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_2__NANDF_D6	IOMUX_PAD(0x560, 0x178, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_3__NANDF_D5	IOMUX_PAD(0x564, 0x17C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_4__NANDF_D4	IOMUX_PAD(0x568, 0x180, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_5__NANDF_D3	IOMUX_PAD(0x56C, 0x184, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_6__NANDF_D2	IOMUX_PAD(0x570, 0x188, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_7__NANDF_D1	IOMUX_PAD(0x574, 0x18C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_8__NANDF_D0	IOMUX_PAD(0x578, 0x190, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_12__CSI1_D8	IOMUX_PAD(0x57C, 0x194, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_13__CSI1_D9	IOMUX_PAD(0x580, 0x198, 3, 0x0, 0, NO_PAD_CTRL)
+
+#define MX51_PAD_EIM_OE__GPIO_2_24	IOMUX_PAD(0x470, 0x0dc, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS0__GPIO_2_25	IOMUX_PAD(0x474, 0x0e0, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS1__GPIO_2_26	IOMUX_PAD(0x478, 0x0e4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS2__GPIO_2_27	IOMUX_PAD(0x47c, 0x0e8, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS3__GPIO_2_28	IOMUX_PAD(0x480, 0x0ec, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS4__GPIO_2_29	IOMUX_PAD(0x484, 0x0f0, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CS5__GPIO_2_30	IOMUX_PAD(0x488, 0x0f4, 1, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_DTACK__GPIO_2_31	IOMUX_PAD(0x48c, 0x0f8, 1, 0x0,   0, MX51_PAD_CTRL_3)
+
+#define MX51_PAD_EIM_LBA__GPIO_3_1		IOMUX_PAD(0x494, 0xFC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_EIM_CRE__GPIO_3_2		IOMUX_PAD(0x4A0, 0x100, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DRAM_CS1__DRAM_CS1		IOMUX_PAD(0x4D0, 0x104, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_WE_B__GPIO_3_3	IOMUX_PAD(0x4E4, 0x108, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RE_B__GPIO_3_4	IOMUX_PAD(0x4E8, 0x10C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_ALE__GPIO_3_5		IOMUX_PAD(0x4EC, 0x110, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CLE__GPIO_3_6		IOMUX_PAD(0x4F0, 0x114, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_WP_B__GPIO_3_7	IOMUX_PAD(0x4F4, 0x118, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RB0__GPIO_3_8		IOMUX_PAD(0x4F8, 0x11C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RB1__GPIO_3_9		IOMUX_PAD(0x4FC, 0x120, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RB2__GPIO_3_10	IOMUX_PAD(0x500, 0x124, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RB3__GPIO_3_11	IOMUX_PAD(0x504, 0x128, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_GPIO_NAND__GPIO_3_12	IOMUX_PAD(0x514, 0x12C, 3, 0x0,   0, NO_PAD_CTRL)
+
+#define MX51_PAD_GPIO_NAND__PATA_INTRQ	IOMUX_PAD(0x514, 0x12C, 1, 0x0, 0, MX51_PAD_CTRL_2)
+
+#define MX51_PAD_NANDF_RB5__GPIO_3_13	IOMUX_PAD(0x5D8, 0x130, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS0__GPIO_3_16	IOMUX_PAD(0x518, 0x130, 3, 0x0, 0, PAD_CTL_PUS_100K_UP)
+#define MX51_PAD_NANDF_CS1__GPIO_3_17	IOMUX_PAD(0x51C, 0x134, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS2__GPIO_3_18	IOMUX_PAD(0x520, 0x138, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS3__GPIO_3_19	IOMUX_PAD(0x524, 0x13C, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS4__GPIO_3_20	IOMUX_PAD(0x528, 0x140, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS5__GPIO_3_21	IOMUX_PAD(0x52C, 0x144, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS6__GPIO_3_22	IOMUX_PAD(0x530, 0x148, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_CS7__GPIO_3_23	IOMUX_PAD(0x534, 0x14C, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_RDY_INT__GPIO_3_24	IOMUX_PAD(0x538, 0x150, 3, 0x0,   0, NO_PAD_CTRL)
+
+/* FEC */
+#define MX51_PAD_EIM_EB2__FEC_MDIO	IOMUX_PAD(0x468, 0x0d4, 3, 0x0,   0, MX51_PAD_CTRL_1 | PAD_CTL_PUS_22K_UP)
+#define MX51_PAD_EIM_EB3__FEC_RDAT1	IOMUX_PAD(0x46c, 0x0d8, 3, 0x0,   0, MX51_PAD_CTRL_2)
+#define MX51_PAD_EIM_CS2__FEC_RDAT2	IOMUX_PAD(0x47c, 0x0e8, 3, 0x0,   0, MX51_PAD_CTRL_2)
+#define MX51_PAD_EIM_CS3__FEC_RDAT3	IOMUX_PAD(0x480, 0x0ec, 3, 0x0,   0, MX51_PAD_CTRL_2)
+#define MX51_PAD_EIM_CS4__FEC_RX_ER	IOMUX_PAD(0x484, 0x0f0, 3, 0x0,   0, MX51_PAD_CTRL_2)
+#define MX51_PAD_EIM_CS5__FEC_CRS	IOMUX_PAD(0x488, 0x0f4, 3, 0x0,   0, MX51_PAD_CTRL_2)
+#define MX51_PAD_NANDF_RB2__FEC_COL	IOMUX_PAD(0x500, 0x124, 1, 0x0, 0, MX51_PAD_CTRL_2)
+#define MX51_PAD_NANDF_RB3__FEC_RXCLK	IOMUX_PAD(0x504, 0x128, 1, 0x0, 0, MX51_PAD_CTRL_2)
+#define MX51_PAD_NANDF_RB7__FEC_TDAT0	IOMUX_PAD(0x5E0, 0x138, 1, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_RB6__FEC_RDAT0	IOMUX_PAD(0x5DC, 0x134, 1, 0x0, 0, MX51_PAD_CTRL_4)
+#define MX51_PAD_NANDF_CS2__FEC_TX_ER	IOMUX_PAD(0x520, 0x138, 2, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_CS3__FEC_MDC		IOMUX_PAD(0x524, 0x13C, 2, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_CS4__FEC_TDAT1	IOMUX_PAD(0x528, 0x140, 2, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_CS5__FEC_TDAT2	IOMUX_PAD(0x52C, 0x144, 2, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_CS6__FEC_TDAT3	IOMUX_PAD(0x530, 0x148, 2, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_CS7__FEC_TX_EN	IOMUX_PAD(0x534, 0x14C, 1, 0x0, 0, MX51_PAD_CTRL_5)
+#define MX51_PAD_NANDF_RDY_INT__FEC_TX_CLK	IOMUX_PAD(0x538, 0x150, 1, 0x0, 0, MX51_PAD_CTRL_4)
+
+#define MX51_PAD_NANDF_D15__GPIO_3_25	IOMUX_PAD(0x53C, 0x154, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D14__GPIO_3_26	IOMUX_PAD(0x540, 0x158, 3, 0x0, 0, PAD_CTL_PUS_100K_UP)
+#define MX51_PAD_NANDF_D13__GPIO_3_27	IOMUX_PAD(0x544, 0x15C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D12__GPIO_3_28	IOMUX_PAD(0x548, 0x160, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D11__GPIO_3_29	IOMUX_PAD(0x54C, 0x164, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D10__GPIO_3_30	IOMUX_PAD(0x550, 0x168, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D9__GPIO_3_31		IOMUX_PAD(0x554, 0x16C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D8__GPIO_4_0	IOMUX_PAD(0x558, 0x170, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D7__GPIO_4_1	IOMUX_PAD(0x55C, 0x174, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D6__GPIO_4_2	IOMUX_PAD(0x560, 0x178, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D5__GPIO_4_3	IOMUX_PAD(0x564, 0x17C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D4__GPIO_4_4	IOMUX_PAD(0x568, 0x180, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D3__GPIO_4_5	IOMUX_PAD(0x56C, 0x184, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D2__GPIO_4_6	IOMUX_PAD(0x570, 0x188, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D1__GPIO_4_7	IOMUX_PAD(0x574, 0x18C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_NANDF_D0__GPIO_4_8	IOMUX_PAD(0x578, 0x190, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI1_D8__GPIO_3_12	IOMUX_PAD(0x57C, 0x194, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI1_D9__GPIO_3_13	IOMUX_PAD(0x580, 0x198, 3, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_D10__CSI1_D10	IOMUX_PAD(0x584, 0x19C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_D11__CSI1_D11	IOMUX_PAD(0x588, 0x1A0, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_D12__CSI1_D12	IOMUX_PAD(0x58C, 0x1A4, 0, 0x0, 0, NO_PAD_CTRL)
@@ -162,37 +223,54 @@ typedef enum iomux_config {
 #define MX51_PAD_CSI1_D17__CSI1_D17	IOMUX_PAD(0x5A0, 0x1B8, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_D18__CSI1_D18	IOMUX_PAD(0x5A4, 0x1BC, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_D19__CSI1_D19	IOMUX_PAD(0x5A8, 0x1C0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_CSI1_VSYNC__CSI1_VSYNC	IOMUX_PAD(0x5AC, 0x1C4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_CSI1_HSYNC__CSI1_HSYNC	IOMUX_PAD(0x5B0, 0x1C8, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI1_VSYNC__CSI1_VSYNC	IOMUX_PAD(0x5AC, 0x1C4, 0, 0x0, 0, PAD_CTL_SRE_SLOW)
+#define MX51_PAD_CSI1_HSYNC__CSI1_HSYNC	IOMUX_PAD(0x5B0, 0x1C8, 0, 0x0, 0, PAD_CTL_SRE_SLOW)
 #define MX51_PAD_CSI1_PIXCLK__CSI1_PIXCLK	IOMUX_PAD(0x5B4, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_CSI1_MCLK__CSI1_MCLK	IOMUX_PAD(0x5B8, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_CSI1_PKE0__CSI1_PKE0	IOMUX_PAD(0x860, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_9__CSI2_D12	IOMUX_PAD(0x5BC, 0x1CC, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_10__CSI2_D13	IOMUX_PAD(0x5C0, 0x1D0, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_11__CSI2_D14	IOMUX_PAD(0x5C4, 0x1D4, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_12__CSI2_D15	IOMUX_PAD(0x5C8, 0x1D8, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_11__CSI2_D16	IOMUX_PAD(0x5CC, 0x1DC, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_12__CSI2_D17	IOMUX_PAD(0x5D0, 0x1E0, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_11__CSI2_D18	IOMUX_PAD(0x5D4, 0x1E4, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_12__CSI2_D19	IOMUX_PAD(0x5D8, 0x1E8, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_13__CSI2_VSYNC	IOMUX_PAD(0x5DC, 0x1EC, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_14__CSI2_HSYNC	IOMUX_PAD(0x5E0, 0x1F0, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_15__CSI2_PIXCLK	IOMUX_PAD(0x5E4, 0x1F4, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_CSI2_PKE0__CSI2_PKE0	IOMUX_PAD(0x81C, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_16__I2C1_CLK	IOMUX_PAD(0x5E8, 0x1F8, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_17__I2C1_DAT	IOMUX_PAD(0x5EC, 0x1FC, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_18__AUD3_BB_TXD	IOMUX_PAD(0x5F0, 0x200, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_19__AUD3_BB_RXD	IOMUX_PAD(0x5F4, 0x204, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_20__AUD3_BB_CK	IOMUX_PAD(0x5F8, 0x208, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_21__AUD3_BB_FS	IOMUX_PAD(0x5FC, 0x20C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_22__CSPI1_MOSI	IOMUX_PAD(0x600, 0x210, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_23__CSPI1_MISO	IOMUX_PAD(0x604, 0x214, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_24__CSPI1_SS0	IOMUX_PAD(0x608, 0x218, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_25__CSPI1_SS1	IOMUX_PAD(0x60C, 0x21C, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_26__CSPI1_RDY	IOMUX_PAD(0x610, 0x220, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_4_27__CSPI1_SCLK	IOMUX_PAD(0x614, 0x224, 3, 0x0, 0, NO_PAD_CTRL)
-
-/* Babbage UART1 */
+#define MX51_PAD_CSI1_PKE0__CSI1_PKE0		IOMUX_PAD(0x860, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D12__GPIO_4_9		IOMUX_PAD(0x5BC, 0x1CC, 3, 0x0, 0, MX51_PAD_CTRL_7)
+#define MX51_PAD_CSI2_D13__GPIO_4_10		IOMUX_PAD(0x5C0, 0x1D0, 3, 0x0, 0, MX51_PAD_CTRL_7)
+#define MX51_PAD_CSI2_D14__GPIO_4_11		IOMUX_PAD(0x5C4, 0x1D4, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D15__GPIO_4_12		IOMUX_PAD(0x5C8, 0x1D8, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D16__GPIO_4_11		IOMUX_PAD(0x5CC, 0x1DC, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D17__GPIO_4_12		IOMUX_PAD(0x5D0, 0x1E0, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D18__GPIO_4_11		IOMUX_PAD(0x5D4, 0x1E4, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_D19__GPIO_4_12		IOMUX_PAD(0x5D8, 0x1E8, 3, 0x0, 0, MX51_PAD_CTRL_12)
+#define MX51_PAD_CSI2_VSYNC__GPIO_4_13	IOMUX_PAD(0x5DC, 0x1EC, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSI2_HSYNC__GPIO_4_14	IOMUX_PAD(0x5E0, 0x1F0, 3, 0x0, 0, MX51_GPIO_PAD_CTRL)
+#define MX51_PAD_CSI2_PIXCLK__GPIO_4_15	IOMUX_PAD(0x5E4, 0x1F4, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_I2C1_CLK__GPIO_4_16		IOMUX_PAD(0x5E8, 0x1F8, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_I2C1_DAT__GPIO_4_17		IOMUX_PAD(0x5EC, 0x1FC, 3, 0x0,   0, NO_PAD_CTRL)
+
+#define MX51_PAD_CSI2_PKE0__CSI2_PKE0		IOMUX_PAD(0x81C, 0x0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_I2C1_CLK__HSI2C_CLK		IOMUX_PAD(0x5E8, 0x1F8, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX51_PAD_CTRL_8)
+#define MX51_PAD_I2C1_DAT__HSI2C_DAT		IOMUX_PAD(0x5EC, 0x1FC, \
+						IOMUX_CONFIG_SION, \
+						0x0, 0, MX51_PAD_CTRL_8)
+
+/* Audio */
+#define MX51_PAD_AUD3_BB_TXD__AUD3_BB_TXD	IOMUX_PAD(0x5F0, 0x200, 0, 0x0, 0, MX51_PAD_CTRL_10)
+#define MX51_PAD_AUD3_BB_RXD__AUD3_BB_RXD	IOMUX_PAD(0x5F4, 0x204, 0, 0x0, 0, MX51_PAD_CTRL_10)
+#define MX51_PAD_AUD3_BB_CK__AUD3_BB_CK	IOMUX_PAD(0x5F8, 0x208, 0, 0x0, 0, MX51_PAD_CTRL_10)
+#define MX51_PAD_AUD3_BB_FS__AUD3_BB_FS	IOMUX_PAD(0x5FC, 0x20C, 0, 0x0, 0, MX51_PAD_CTRL_10)
+
+/* CSPI */
+#define MX51_PAD_CSPI1_SS0__CSPI1_SS0		IOMUX_PAD(0x608, 0x218, 0, 0x0, 0, MX51_PAD_CTRL_11)
+#define MX51_PAD_CSPI1_SS1__CSPI1_SS1		IOMUX_PAD(0x60C, 0x21C, 0, 0x0, 0, MX51_PAD_CTRL_11)
+
+#define MX51_PAD_AUD3_BB_TXD__GPIO_4_18		IOMUX_PAD(0x5F0, 0x200, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_AUD3_BB_RXD__GPIO_4_19		IOMUX_PAD(0x5F4, 0x204, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_AUD3_BB_CK__GPIO_4_20		IOMUX_PAD(0x5F8, 0x208, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_AUD3_BB_FS__GPIO_4_21		IOMUX_PAD(0x5FC, 0x20C, 3, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_CSPI1_MOSI__GPIO_4_22	IOMUX_PAD(0x600, 0x210, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSPI1_MISO__GPIO_4_23	IOMUX_PAD(0x604, 0x214, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSPI1_SS0__GPIO_4_24	IOMUX_PAD(0x608, 0x218, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_CSPI1_RDY__GPIO_4_26	IOMUX_PAD(0x610, 0x220, 3, 0x0, 0, MX51_PAD_CTRL_10 | MX51_PAD_CTRL_13)
+#define MX51_PAD_CSPI1_SCLK__GPIO_4_27	IOMUX_PAD(0x614, 0x224, 3, 0x0, 0, NO_PAD_CTRL)
+
+/* UART1 */
 #define MX51_PAD_UART1_RXD__UART1_RXD	IOMUX_PAD(0x618, 0x228,	IOMUX_CONFIG_ALT0, 0x9e4, 0, MX51_UART1_PAD_CTRL | PAD_CTL_SRE_FAST)
 #define MX51_PAD_UART1_TXD__UART1_TXD	IOMUX_PAD(0x61C, 0x22C, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_UART1_PAD_CTRL | PAD_CTL_SRE_FAST)
 #define MX51_PAD_UART1_RTS__UART1_RTS	IOMUX_PAD(0x620, 0x230, IOMUX_CONFIG_ALT0, 0x9e0, 0, MX51_UART1_PAD_CTRL)
@@ -202,19 +280,29 @@ typedef enum iomux_config {
 #define MX51_PAD_UART2_RXD__UART2_RXD	IOMUX_PAD(0x628, 0x238, IOMUX_CONFIG_ALT0, 0x9ec, 2, MX51_UART2_PAD_CTRL)
 #define MX51_PAD_UART2_TXD__UART2_TXD	IOMUX_PAD(0x62C, 0x23C, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_UART2_PAD_CTRL)
 
-#define MX51_PAD_GPIO_1_22__UART3_RXD	IOMUX_PAD(0x630, 0x240, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_23__UART3_TXD	IOMUX_PAD(0x634, 0x244, 3, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_24__OWIRE_LINE	IOMUX_PAD(0x638, 0x248, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_UART3_RXD__GPIO_1_22	IOMUX_PAD(0x630, 0x240, 3, 0x0, 0, MX51_PAD_CTRL_1)
+#define MX51_PAD_UART3_TXD__GPIO_1_23	IOMUX_PAD(0x634, 0x244, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_OWIRE_LINE__GPIO_1_24	IOMUX_PAD(0x638, 0x248, 3, 0x0,   0, NO_PAD_CTRL)
+
+#define MX51_PAD_OWIRE_LINE__SPDIF_OUT1	IOMUX_PAD(0x638, 0x248, 6, 0x0, 0, MX51_PAD_CTRL_10 | MX51_PAD_CTRL_13)
+#define MX51_PAD_OWIRE_LINE__OWIRE_LINE	IOMUX_PAD(0x638, 0x248, 0, 0x0, 0, MX51_I2C_PAD_CTRL | MX51_PAD_CTRL_13)
 #define MX51_PAD_KEY_ROW0__KEY_ROW0	IOMUX_PAD(0x63C, 0x24C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_KEY_ROW1__KEY_ROW1	IOMUX_PAD(0x640, 0x250, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_KEY_ROW2__KEY_ROW2	IOMUX_PAD(0x644, 0x254, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_KEY_ROW3__KEY_ROW3	IOMUX_PAD(0x648, 0x258, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL0__KEY_COL0	IOMUX_PAD(0x64C, 0x25C, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL1__KEY_COL1	IOMUX_PAD(0x650, 0x260, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL2__KEY_COL2	IOMUX_PAD(0x654, 0x264, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL3__KEY_COL3	IOMUX_PAD(0x658, 0x268, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL4__KEY_COL4	IOMUX_PAD(0x65C, 0x26C, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_KEY_COL5__KEY_COL5	IOMUX_PAD(0x660, 0x270, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL0__KEY_COL0		IOMUX_PAD(0x64C, 0x25C, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL1__KEY_COL1		IOMUX_PAD(0x650, 0x260, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL2__KEY_COL2		IOMUX_PAD(0x654, 0x264, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL3__KEY_COL3		IOMUX_PAD(0x658, 0x268, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL4__KEY_COL4		IOMUX_PAD(0x65C, 0x26C, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_KEY_COL5__KEY_COL5		IOMUX_PAD(0x660, 0x270, 0, 0x0,   0, NO_PAD_CTRL)
+
+/* I2C2 */
+#define MX51_PAD_KEY_COL4__I2C2_SCL	IOMUX_PAD(0x65C, 0x26C, IOMUX_CONFIG_ALT3 | IOMUX_CONFIG_SION, \
+										0x09b8, 1, MX51_I2C_PAD_CTRL)
+#define MX51_PAD_KEY_COL5__I2C2_SDA	IOMUX_PAD(0x660, 0x270, IOMUX_CONFIG_ALT3 | IOMUX_CONFIG_SION, \
+										0x9bc, 1, MX51_I2C_PAD_CTRL)
+
 #define MX51_PAD_USBH1_CLK__USBH1_CLK	IOMUX_PAD(0x678, 0x278, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
 #define MX51_PAD_USBH1_DIR__USBH1_DIR	IOMUX_PAD(0x67C, 0x27C, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
 #define MX51_PAD_USBH1_STP__USBH1_STP	IOMUX_PAD(0x680, 0x280, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
@@ -228,25 +316,25 @@ typedef enum iomux_config {
 #define MX51_PAD_USBH1_DATA5__USBH1_DATA5	IOMUX_PAD(0x69C, 0x29C, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
 #define MX51_PAD_USBH1_DATA6__USBH1_DATA6	IOMUX_PAD(0x6A0, 0x2A0, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
 #define MX51_PAD_USBH1_DATA7__USBH1_DATA7	IOMUX_PAD(0x6A4, 0x2A4, IOMUX_CONFIG_ALT0, 0x0, 0, MX51_USBH1_PAD_CTRL)
-#define MX51_PAD_GPIO_3_0__DI1_PIN11	IOMUX_PAD(0x6A8, 0x2A8, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_1__DI1_PIN12	IOMUX_PAD(0x6AC, 0x2AC, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_2__DI1_PIN13	IOMUX_PAD(0x6B0, 0x2B0, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_3__DI1_D0_CS	IOMUX_PAD(0x6B4, 0x2B4, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_4__DI1_D1_CS	IOMUX_PAD(0x6B8, 0x2B8, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_5__DISPB2_SER_DIN	IOMUX_PAD(0x6BC, 0x2BC, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_6__DISPB2_SER_DIO	IOMUX_PAD(0x6C0, 0x2C0, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_7__DISPB2_SER_CLK	IOMUX_PAD(0x6C4, 0x2C4, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_3_8__DISPB2_SER_RS	IOMUX_PAD(0x6C8, 0x2C8, 4, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT0__DISP1_DAT0	IOMUX_PAD(0x6CC, 0x2CC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT1__DISP1_DAT1	IOMUX_PAD(0x6D0, 0x2D0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT2__DISP1_DAT2	IOMUX_PAD(0x6D4, 0x2D4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT3__DISP1_DAT3	IOMUX_PAD(0x6D8, 0x2D8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT4__DISP1_DAT4	IOMUX_PAD(0x6DC, 0x2DC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT5__DISP1_DAT5	IOMUX_PAD(0x6E0, 0x2E0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT6__DISP1_DAT6	IOMUX_PAD(0x6E4, 0x2E4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT7__DISP1_DAT7	IOMUX_PAD(0x6E8, 0x2E8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT8__DISP1_DAT8	IOMUX_PAD(0x6EC, 0x2EC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT9__DISP1_DAT9	IOMUX_PAD(0x6F0, 0x2F0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DI1_PIN11__GPIO_3_0		IOMUX_PAD(0x6A8, 0x2A8, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DI1_PIN12__GPIO_3_1		IOMUX_PAD(0x6AC, 0x2AC, 4, 0x0, 0, MX51_GPIO_PAD_CTRL)
+#define MX51_PAD_DI1_PIN13__GPIO_3_2		IOMUX_PAD(0x6B0, 0x2B0, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DI1_D0_CS__GPIO_3_3		IOMUX_PAD(0x6B4, 0x2B4, 4, 0x0, 0, MX51_PAD_CTRL_7)
+#define MX51_PAD_DI1_D1_CS__GPIO_3_4		IOMUX_PAD(0x6B8, 0x2B8, 4, 0x984, 1, MX51_PAD_CTRL_7)
+#define MX51_PAD_DISPB2_SER_DIN__GPIO_3_5	IOMUX_PAD(0x6BC, 0x2BC, 4, 0x988, 1, NO_PAD_CTRL)
+#define MX51_PAD_DISPB2_SER_DIO__GPIO_3_6	IOMUX_PAD(0x6C0, 0x2C0, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISPB2_SER_CLK__GPIO_3_7	IOMUX_PAD(0x6C4, 0x2C4, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISPB2_SER_RS__GPIO_3_8		IOMUX_PAD(0x6C8, 0x2C8, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT0__DISP1_DAT0		IOMUX_PAD(0x6CC, 0x2CC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT1__DISP1_DAT1		IOMUX_PAD(0x6D0, 0x2D0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT2__DISP1_DAT2		IOMUX_PAD(0x6D4, 0x2D4, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT3__DISP1_DAT3		IOMUX_PAD(0x6D8, 0x2D8, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT4__DISP1_DAT4		IOMUX_PAD(0x6DC, 0x2DC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT5__DISP1_DAT5		IOMUX_PAD(0x6E0, 0x2E0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT6__DISP1_DAT6		IOMUX_PAD(0x6E4, 0x2E4, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT7__DISP1_DAT7		IOMUX_PAD(0x6E8, 0x2E8, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT8__DISP1_DAT8		IOMUX_PAD(0x6EC, 0x2EC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT9__DISP1_DAT9		IOMUX_PAD(0x6F0, 0x2F0, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP1_DAT10__DISP1_DAT10	IOMUX_PAD(0x6F4, 0x2F4, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP1_DAT11__DISP1_DAT11	IOMUX_PAD(0x6F8, 0x2F8, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP1_DAT12__DISP1_DAT12	IOMUX_PAD(0x6FC, 0x2FC, 0, 0x0, 0, NO_PAD_CTRL)
@@ -259,76 +347,69 @@ typedef enum iomux_config {
 #define MX51_PAD_DISP1_DAT19__DISP1_DAT19	IOMUX_PAD(0x718, 0x318, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP1_DAT20__DISP1_DAT20	IOMUX_PAD(0x71C, 0x31C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP1_DAT21__DISP1_DAT21	IOMUX_PAD(0x720, 0x320, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT22__DISP1_DAT22	IOMUX_PAD(0x724, 0x324, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DISP1_DAT23__DISP1_DAT23	IOMUX_PAD(0x728, 0x328, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT22__DISP1_DAT22	IOMUX_PAD(0x724, 0x324, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT23__DISP1_DAT23	IOMUX_PAD(0x728, 0x328, 0, 0x0,   0, NO_PAD_CTRL)
+
+#define MX51_PAD_DISP1_DAT22__DISP2_DAT16	IOMUX_PAD(0x724, 0x324, 5, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP1_DAT23__DISP2_DAT17	IOMUX_PAD(0x728, 0x328, 5, 0x0, 0, NO_PAD_CTRL)
+
 #define MX51_PAD_DI1_PIN3__DI1_PIN3	IOMUX_PAD(0x72C, 0x32C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI1_PIN2__DI1_PIN2	IOMUX_PAD(0x734, 0x330, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI_GP1__DI_GP1	IOMUX_PAD(0x73C, 0x334, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI_GP2__DI_GP2	IOMUX_PAD(0x740, 0x338, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DI_GP3__CSI1_DATA_EN	IOMUX_PAD(0x744, 0x33C, 3, 0x9a0, 1, MX51_PAD_CTRL_7)
 #define MX51_PAD_DI_GP3__DI_GP3	IOMUX_PAD(0x744, 0x33C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI2_PIN4__DI2_PIN4	IOMUX_PAD(0x748, 0x340, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI2_PIN2__DI2_PIN2	IOMUX_PAD(0x74C, 0x344, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI2_PIN3__DI2_PIN3	IOMUX_PAD(0x750, 0x348, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DI2_DISP_CLK__DI2_DISP_CLK	IOMUX_PAD(0x754, 0x34C, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_DI_GP4__DI_GP4	IOMUX_PAD(0x758, 0x350, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DI_GP4__DI_GP4		IOMUX_PAD(0x758, 0x350, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_DI_GP4__DI2_PIN15	IOMUX_PAD(0x758, 0x350, 4, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT0__DISP2_DAT0	IOMUX_PAD(0x75C, 0x354, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT1__DISP2_DAT1	IOMUX_PAD(0x760, 0x358, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT2__DISP2_DAT2	IOMUX_PAD(0x764, 0x35C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT3__DISP2_DAT3	IOMUX_PAD(0x768, 0x360, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT4__DISP2_DAT4	IOMUX_PAD(0x76C, 0x364, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT5__DISP2_DAT5	IOMUX_PAD(0x770, 0x368, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_19__DISP2_DAT6	IOMUX_PAD(0x774, 0x36C, 5, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_29__DISP2_DAT7	IOMUX_PAD(0x778, 0x370, 5, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_30__DISP2_DAT8	IOMUX_PAD(0x77C, 0x374, 5, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_31__DISP2_DAT9	IOMUX_PAD(0x780, 0x378, 5, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP2_DAT6__GPIO_1_19	IOMUX_PAD(0x774, 0x36C, 5, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP2_DAT7__GPIO_1_29	IOMUX_PAD(0x778, 0x370, 5, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP2_DAT8__GPIO_1_30	IOMUX_PAD(0x77C, 0x374, 5, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_DISP2_DAT9__GPIO_1_31	IOMUX_PAD(0x780, 0x378, 5, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT10__DISP2_DAT10	IOMUX_PAD(0x784, 0x37C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT11__DISP2_DAT11	IOMUX_PAD(0x788, 0x380, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT12__DISP2_DAT12	IOMUX_PAD(0x78C, 0x384, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT13__DISP2_DAT13	IOMUX_PAD(0x790, 0x388, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT14__DISP2_DAT14	IOMUX_PAD(0x794, 0x38C, 0, 0x0, 0, NO_PAD_CTRL)
 #define MX51_PAD_DISP2_DAT15__DISP2_DAT15	IOMUX_PAD(0x798, 0x390, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_CMD__SD1_CMD	IOMUX_PAD(0x79C, 0x394, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_CLK__SD1_CLK	IOMUX_PAD(0x7A0, 0x398, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_DATA0__SD1_DATA0	IOMUX_PAD(0x7A4, 0x39C, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_DATA1__SD1_DATA1	IOMUX_PAD(0x7A8, 0x3A0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_DATA2__SD1_DATA2	IOMUX_PAD(0x7AC, 0x3A4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD1_DATA3__SD1_DATA3	IOMUX_PAD(0x7B0, 0x3A8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_0__GPIO1_0	IOMUX_PAD(0x7B4, 0x3AC, 1, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_1__GPIO1_1	IOMUX_PAD(0x7B8, 0x3B0, 1, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_CMD__SD2_CMD	IOMUX_PAD(0x7BC, 0x3B4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_CLK__SD2_CLK	IOMUX_PAD(0x7C0, 0x3B8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_DATA0__SD2_DATA0	IOMUX_PAD(0x7C4, 0x3BC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_DATA1__SD2_DATA1	IOMUX_PAD(0x7C8, 0x3C0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_DATA2__SD2_DATA2	IOMUX_PAD(0x7CC, 0x3C4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_SD2_DATA3__SD2_DATA3	IOMUX_PAD(0x7D0, 0x3C8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_2__GPIO1_2	IOMUX_PAD(0x7D4, 0x3CC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_3__GPIO1_3	IOMUX_PAD(0x7D8, 0x3D0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_PMIC_INT_REQ__PMIC_INT_REQ	IOMUX_PAD(0x7FC, 0x3D4, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_4__GPIO1_4	IOMUX_PAD(0x804, 0x3D8, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_5__GPIO1_5	IOMUX_PAD(0x808, 0x3DC, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_6__GPIO1_6	IOMUX_PAD(0x80C, 0x3E0, 0, 0x0, 0, NO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_7__GPIO1_7	IOMUX_PAD(0x810, 0x3E4, 0, 0x0, 0, MX51_GPIO_PAD_CTRL)
-#define MX51_PAD_GPIO_1_8__GPIO1_8	IOMUX_PAD(0x814, 0x3E8, 0, 0x0, 1, \
-						(PAD_CTL_SRE_SLOW | PAD_CTL_DSE_MED | PAD_CTL_PUS_100K_UP |  PAD_CTL_HYS))
-#define MX51_PAD_GPIO_1_9__GPIO1_9	IOMUX_PAD(0x818, 0x3EC, 0, 0x0, 0, NO_PAD_CTRL)
 
-/* EIM */
-#define MX51_PAD_EIM_DA0__EIM_DA0	IOMUX_PAD(0x7a8, 0x01c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA1__EIM_DA1	IOMUX_PAD(0x7a8, 0x020, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA2__EIM_DA2	IOMUX_PAD(0x7a8, 0x024, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA3__EIM_DA3	IOMUX_PAD(0x7a8, 0x028, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA4__EIM_DA4	IOMUX_PAD(0x7ac, 0x02c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA5__EIM_DA5	IOMUX_PAD(0x7ac, 0x030, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA6__EIM_DA6	IOMUX_PAD(0x7ac, 0x034, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA7__EIM_DA7	IOMUX_PAD(0x7ac, 0x038, 0, 0x0,   0, NO_PAD_CTRL)
+/* SD1 */
+#define MX51_PAD_SD1_CMD__SD1_CMD	IOMUX_PAD(0x79C, 0x394, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD1_CLK__SD1_CLK	IOMUX_PAD(0x7A0, 0x398, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD1_DATA0__SD1_DATA0	IOMUX_PAD(0x7A4, 0x39C, 0, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD1_DATA1__SD1_DATA1	IOMUX_PAD(0x7A8, 0x3A0, 0, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD1_DATA2__SD1_DATA2	IOMUX_PAD(0x7AC, 0x3A4, 0, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD1_DATA3__SD1_DATA3	IOMUX_PAD(0x7B0, 0x3A8, 0, 0x0, 0, MX51_SD_PAD_CTRL)
 
-#define MX51_PAD_EIM_DA8__EIM_DA8	IOMUX_PAD(0x7b0, 0x03c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA9__EIM_DA9	IOMUX_PAD(0x7b0, 0x040, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA10__EIM_DA10	IOMUX_PAD(0x7b0, 0x044, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA11__EIM_DA11	IOMUX_PAD(0x7b0, 0x048, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA12__EIM_DA12	IOMUX_PAD(0x7bc, 0x04c, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA13__EIM_DA13	IOMUX_PAD(0x7bc, 0x050, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA14__EIM_DA14	IOMUX_PAD(0x7bc, 0x054, 0, 0x0,   0, NO_PAD_CTRL)
-#define MX51_PAD_EIM_DA15__EIM_DA15	IOMUX_PAD(0x7bc, 0x058, 0, 0x0,   0, NO_PAD_CTRL)
+/* SD2 */
+#define MX51_PAD_GPIO_1_0__GPIO_1_0	IOMUX_PAD(0x7B4, 0x3AC, 1 | IOMUX_CONFIG_SION, 0x0, 0, MX51_PAD_CTRL_9)
+#define MX51_PAD_GPIO_1_1__GPIO_1_1	IOMUX_PAD(0x7B8, 0x3B0, 1, 0x0, 0, MX51_PAD_CTRL_9)
+#define MX51_PAD_SD2_CMD__SD2_CMD	IOMUX_PAD(0x7BC, 0x3B4, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD2_CLK__SD2_CLK	IOMUX_PAD(0x7C0, 0x3B8, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD2_DATA0__SD2_DATA0	IOMUX_PAD(0x7C4, 0x3BC, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD2_DATA1__SD2_DATA1	IOMUX_PAD(0x7C8, 0x3C0, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD2_DATA2__SD2_DATA2	IOMUX_PAD(0x7CC, 0x3C4, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+#define MX51_PAD_SD2_DATA3__SD2_DATA3	IOMUX_PAD(0x7D0, 0x3C8, IOMUX_CONFIG_SION, 0x0, 0, MX51_SD_PAD_CTRL)
+
+#define MX51_PAD_GPIO_1_2__PWM_PWMO	IOMUX_PAD(0x7D4, 0x3CC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_GPIO_1_3__I2C2_SDA		IOMUX_PAD(0x7D8, 0x3D0, 2 | IOMUX_CONFIG_SION, 0x9bc, 3, MX51_I2C_PAD_CTRL)
+#define MX51_PAD_GPIO_1_2__GPIO_1_2		IOMUX_PAD(0x7D4, 0x3CC, 0, 0x0,   0, NO_PAD_CTRL)
+#define MX51_PAD_GPIO_1_3__GPIO_1_3		IOMUX_PAD(0x7D8, 0x3D0, 0, 0x0, 0, MX51_UART3_PAD_CTRL)
+#define MX51_PAD_PMIC_INT_REQ__PMIC_INT_REQ	IOMUX_PAD(0x7FC, 0x3D4, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX51_PAD_GPIO_1_4__GPIO_1_4	IOMUX_PAD(0x804, 0x3D8, IOMUX_CONFIG_SION, 0x0, 0, MX51_PAD_CTRL_9)
+#define MX51_PAD_GPIO_1_5__GPIO_1_5	IOMUX_PAD(0x808, 0x3DC, IOMUX_CONFIG_SION, 0x0, 0, MX51_PAD_CTRL_9)
+#define MX51_PAD_GPIO_1_6__GPIO_1_6	IOMUX_PAD(0x80C, 0x3E0, IOMUX_CONFIG_SION, 0x0, 0, MX51_PAD_CTRL_9)
+#define MX51_PAD_GPIO_1_7__GPIO_1_7	IOMUX_PAD(0x810, 0x3E4, 0, 0x0, 0, MX51_GPIO_PAD_CTRL)
+#define MX51_PAD_GPIO_1_8__GPIO_1_8	IOMUX_PAD(0x814, 0x3E8, IOMUX_CONFIG_SION, 0x0 , 1, MX51_PAD_CTRL_6)
+#define MX51_PAD_GPIO_1_9__GPIO_1_9	IOMUX_PAD(0x818, 0x3EC, 0, 0x0, 0, NO_PAD_CTRL)
 
 #endif /* __MACH_IOMUX_MX51_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx53.h b/arch/arm/plat-mxc/include/mach/iomux-mx53.h
new file mode 100644
index 0000000..864ac02
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx53.h
@@ -0,0 +1,577 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __MACH_IOMUX_MX53_H__
+#define __MACH_IOMUX_MX53_H__
+
+#include <mach/iomux-v3.h>
+
+/*
+ * various IOMUX alternate output functions (1-7)
+ */
+typedef enum iomux_config {
+	IOMUX_CONFIG_ALT0,
+	IOMUX_CONFIG_ALT1,
+	IOMUX_CONFIG_ALT2,
+	IOMUX_CONFIG_ALT3,
+	IOMUX_CONFIG_ALT4,
+	IOMUX_CONFIG_ALT5,
+	IOMUX_CONFIG_ALT6,
+	IOMUX_CONFIG_ALT7,
+	IOMUX_CONFIG_GPIO,	/* added to help user use GPIO mode */
+	IOMUX_CONFIG_SION = 0x1 << 4,	/* LOOPBACK:MUX SION bit */
+} iomux_pin_cfg_t;
+
+#define IOMUX_TO_IRQ_V3(pin)	(MXC_GPIO_IRQ_START + pin)
+
+#define NON_MUX_I	0x3FF
+#define NON_PAD_I	0x7FF
+
+#define MX53_UART_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_HIGH | \
+				PAD_CTL_SRE_FAST | PAD_CTL_HYS)
+#define MX53_SDHC_PAD_CTRL	(PAD_CTL_DSE_MAX | PAD_CTL_PUS_22K_UP | \
+				PAD_CTL_SRE_FAST | PAD_CTL_DVS | \
+				PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_HYS)
+#define MX53_FEC_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+			PAD_CTL_PUS_22K_UP | PAD_CTL_ODE | PAD_CTL_DSE_HIGH)
+#define PAD_CTRL_1	(PAD_CTL_HYS | PAD_CTL_DSE_HIGH)
+#define PAD_CTRL_2	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_HIGH)
+#define PAD_CTRL_3	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_HIGH | \
+					PAD_CTL_HYS)
+#define PAD_CTRL_4	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_DSE_HIGH | \
+					PAD_CTL_HYS | PAD_CTL_PUS_100K_UP)
+#define PAD_CTRL_5	(PAD_CTL_DSE_HIGH | PAD_CTL_SRE_FAST)
+
+#define PAD_CTRL_6	(PAD_CTL_DSE_LOW | PAD_CTL_SRE_SLOW)
+#define PAD_CTRL_7	(PAD_CTL_DSE_HIGH | PAD_CTL_SRE_SLOW)
+#define PAD_CTRL_8	(PAD_CTL_HYS | PAD_CTL_PKE)
+
+#define PAD_CTRL_9	(PAD_CTL_SRE_FAST | PAD_CTL_ODE | \
+				PAD_CTL_DSE_HIGH | PAD_CTL_PUS_100K_UP | \
+				PAD_CTL_HYS)
+
+#define PAD_CTRL_10	(PAD_CTL_PKE | PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_HIGH)
+
+#define PAD_CTRL_11	(PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+
+#define PAD_CTRL_12	(PAD_CTL_DSE_HIGH | PAD_CTL_PKE | PAD_CTL_SRE_FAST)
+
+
+#define MX53_PAD_GPIO_19__GPIO_4_5		IOMUX_PAD(0x348, 0x20, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL0__GPIO_4_6		IOMUX_PAD(0x34C, 0x24, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW0__GPIO_4_7		IOMUX_PAD(0x350, 0x28, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL1__GPIO_4_8		IOMUX_PAD(0x354, 0x2C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW1__GPIO_4_9		IOMUX_PAD(0x358, 0x30, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL2__GPIO_4_10		IOMUX_PAD(0x35C, 0x34, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW2__GPIO_4_11	IOMUX_PAD(0x360, 0x38, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL3__GPIO_4_12		IOMUX_PAD(0x364, 0x3C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW3__GPIO_4_13	IOMUX_PAD(0x368, 0x40, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL4__GPIO_4_14		IOMUX_PAD(0x36C, 0x44, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW4__GPIO_4_15	IOMUX_PAD(0x370, 0x48, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_KEYPAD__NVCC_KEYPAD	IOMUX_PAD(0x374, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DI0_DISP_CLK__GPIO_4_16	IOMUX_PAD(0x378, 0x4C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DI0_PIN15__GPIO_4_17	IOMUX_PAD(0x37C, 0x50, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DI0_PIN2__GPIO_4_18		IOMUX_PAD(0x380, 0x54, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DI0_PIN3__GPIO_4_19		IOMUX_PAD(0x384, 0x58, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DI0_PIN4__GPIO_4_20		IOMUX_PAD(0x388, 0x5C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT0__GPIO_4_21	IOMUX_PAD(0x38C, 0x60, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT1__GPIO_4_22	IOMUX_PAD(0x390, 0x64, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT2__GPIO_4_23	IOMUX_PAD(0x394, 0x68, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT3__GPIO_4_24	IOMUX_PAD(0x398, 0x6C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT4__GPIO_4_25	IOMUX_PAD(0x39C, 0x70, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT5__GPIO_4_26	IOMUX_PAD(0x3A0, 0x74, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT6__GPIO_4_27	IOMUX_PAD(0x3A4, 0x78, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT7__GPIO_4_28	IOMUX_PAD(0x3A8, 0x7C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT8__GPIO_4_29	IOMUX_PAD(0x3AC, 0x80, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT9__GPIO_4_30	IOMUX_PAD(0x3B0, 0x84, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT10__GPIO_4_31	IOMUX_PAD(0x3B4, 0x88, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT11__GPIO_5_5	IOMUX_PAD(0x3B8, 0x8C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT12__GPIO_5_6	IOMUX_PAD(0x3BC, 0x90, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT13__GPIO_5_7	IOMUX_PAD(0x3C0, 0x94, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT14__GPIO_5_8	IOMUX_PAD(0x3C4, 0x98, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT15__GPIO_5_9	IOMUX_PAD(0x3C8, 0x9C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT16__GPIO_5_10	IOMUX_PAD(0x3CC, 0xA0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT17__GPIO_5_11	IOMUX_PAD(0x3D0, 0xA4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT18__GPIO_5_12	IOMUX_PAD(0x3D4, 0xA8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT19__GPIO_5_13	IOMUX_PAD(0x3D8, 0xAC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT20__GPIO_5_14	IOMUX_PAD(0x3DC, 0xB0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT21__GPIO_5_15	IOMUX_PAD(0x3E0, 0xB4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT22__GPIO_5_16	IOMUX_PAD(0x3E4, 0xB8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DISP0_DAT23__GPIO_5_17	IOMUX_PAD(0x3E8, 0xBC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_PIXCLK__GPIO_5_18	IOMUX_PAD(0x3EC, 0xC0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_MCLK__GPIO_5_19	IOMUX_PAD(0x3F0, 0xC4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_DATA_EN__GPIO_5_20		IOMUX_PAD(0x3F4, 0xC8, 1, 0x0, 0, PAD_CTRL_12)
+#define MX53_PAD_CSI0_VSYNC__GPIO_5_21	IOMUX_PAD(0x3F8, 0xCC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D4__GPIO_5_22		IOMUX_PAD(0x3FC, 0xD0, 1, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_CSI0_D5__GPIO_5_23		IOMUX_PAD(0x400, 0xD4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D6__GPIO_5_24		IOMUX_PAD(0x404, 0xD8, 1, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_CSI0_D7__GPIO_5_25		IOMUX_PAD(0x408, 0xDC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D8__GPIO_5_26		IOMUX_PAD(0x40C, 0xE0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D9__GPIO_5_27		IOMUX_PAD(0x410, 0xE4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D10__GPIO_5_28		IOMUX_PAD(0x414, 0xE8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D11__GPIO_5_29		IOMUX_PAD(0x418, 0xEC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D12__GPIO_5_30		IOMUX_PAD(0x41C, 0xF0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D13__GPIO_5_31		IOMUX_PAD(0x420, 0xF4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D14__GPIO_6_0		IOMUX_PAD(0x424, 0xF8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D15__GPIO_6_1		IOMUX_PAD(0x428, 0xFC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D16__GPIO_6_2		IOMUX_PAD(0x42C, 0x100, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D17__GPIO_6_3		IOMUX_PAD(0x430, 0x104, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D18__GPIO_6_4		IOMUX_PAD(0x434, 0x108, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D19__GPIO_6_5		IOMUX_PAD(0x438, 0x10C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_CSI0__NVCC_CSI0	IOMUX_PAD(0x43C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_TMS__JTAG_TMS		IOMUX_PAD(0x440, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_MOD__JTAG_MOD		IOMUX_PAD(0x444, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_TRSTB__JTAG_TRSTB	IOMUX_PAD(0x448, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_TDI__JTAG_TDI		IOMUX_PAD(0x44C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_TCK__JTAG_TCK		IOMUX_PAD(0x450, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_JTAG_TDO__JTAG_TDO		IOMUX_PAD(0x454, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A25__GPIO_5_2		IOMUX_PAD(0x458, 0x110, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_EB2__GPIO_2_30		IOMUX_PAD(0x45C, 0x114, 1, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_EIM_D16__GPIO_3_16		IOMUX_PAD(0x460, 0x118, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D17__GPIO_3_17		IOMUX_PAD(0x464, 0x11C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D18__GPIO_3_18		IOMUX_PAD(0x468, 0x120, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D19__GPIO_3_19		IOMUX_PAD(0x46C, 0x124, 1, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_EIM_D20__GPIO_3_20		IOMUX_PAD(0x470, 0x128, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D21__GPIO_3_21		IOMUX_PAD(0x474, 0x12C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D22__GPIO_3_22		IOMUX_PAD(0x478, 0x130, 1, 0x0, 0, PAD_CTRL_12)
+#define MX53_PAD_EIM_D23__GPIO_3_23		IOMUX_PAD(0x47C, 0x134, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_EB3__GPIO_2_31		IOMUX_PAD(0x480, 0x138, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D24__GPIO_3_24		IOMUX_PAD(0x484, 0x13C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D25__GPIO_3_25		IOMUX_PAD(0x488, 0x140, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D26__GPIO_3_26		IOMUX_PAD(0x48C, 0x144, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D27__GPIO_3_27		IOMUX_PAD(0x490, 0x148, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D28__GPIO_3_28		IOMUX_PAD(0x494, 0x14C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D29__GPIO_3_29		IOMUX_PAD(0x498, 0x150, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D30__GPIO_3_30		IOMUX_PAD(0x49C, 0x154, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D31__GPIO_3_31		IOMUX_PAD(0x4A0, 0x158, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_EIM1__NVCC_EIM1	IOMUX_PAD(0x4A4, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A24__GPIO_5_4		IOMUX_PAD(0x4A8, 0x15C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A23__GPIO_6_6		IOMUX_PAD(0x4AC, 0x160, 1, 0x0, 0, PAD_CTRL_12)
+#define MX53_PAD_EIM_A22__GPIO_2_16		IOMUX_PAD(0x4B0, 0x164, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A21__GPIO_2_17		IOMUX_PAD(0x4B4, 0x168, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A20__GPIO_2_18		IOMUX_PAD(0x4B8, 0x16C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A19__GPIO_2_19		IOMUX_PAD(0x4BC, 0x170, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A18__GPIO_2_20		IOMUX_PAD(0x4C0, 0x174, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A17__GPIO_2_21		IOMUX_PAD(0x4C4, 0x178, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A16__GPIO_2_22		IOMUX_PAD(0x4C8, 0x17C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_CS0__GPIO_2_23		IOMUX_PAD(0x4CC, 0x180, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_CS1__GPIO_2_24		IOMUX_PAD(0x4D0, 0x184, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_OE__GPIO_2_25		IOMUX_PAD(0x4D4, 0x188, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_RW__GPIO_2_26		IOMUX_PAD(0x4D8, 0x18C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_LBA__GPIO_2_27		IOMUX_PAD(0x4DC, 0x190, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_EIM4__NVCC_EIM4	IOMUX_PAD(0x4E0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_EB0__GPIO_2_28		IOMUX_PAD(0x4E4, 0x194, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_EB1__GPIO_2_29		IOMUX_PAD(0x4E8, 0x198, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA0__GPIO_3_0		IOMUX_PAD(0x4EC, 0x19C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA1__GPIO_3_1		IOMUX_PAD(0x4F0, 0x1A0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA2__GPIO_3_2		IOMUX_PAD(0x4F4, 0x1A4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA3__GPIO_3_3		IOMUX_PAD(0x4F8, 0x1A8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA4__GPIO_3_4		IOMUX_PAD(0x4FC, 0x1AC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA5__GPIO_3_5		IOMUX_PAD(0x500, 0x1B0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA6__GPIO_3_6		IOMUX_PAD(0x504, 0x1B4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA7__GPIO_3_7		IOMUX_PAD(0x508, 0x1B8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA8__GPIO_3_8		IOMUX_PAD(0x50C, 0x1BC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA9__GPIO_3_9		IOMUX_PAD(0x510, 0x1C0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA10__GPIO_3_10		IOMUX_PAD(0x514, 0x1C4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA11__GPIO_3_11		IOMUX_PAD(0x518, 0x1C8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA12__GPIO_3_12		IOMUX_PAD(0x51C, 0x1CC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA13__GPIO_3_13		IOMUX_PAD(0x520, 0x1D0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA14__GPIO_3_14		IOMUX_PAD(0x524, 0x1D4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_DA15__GPIO_3_15		IOMUX_PAD(0x528, 0x1D8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_WE_B__GPIO_6_12	IOMUX_PAD(0x52C, 0x1DC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_RE_B__GPIO_6_13	IOMUX_PAD(0x530, 0x1E0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_WAIT__GPIO_5_0		IOMUX_PAD(0x534, 0x1E4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_BCLK__EIM_BCLK		IOMUX_PAD(0x538, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_EIM7__NVCC_EIM7	IOMUX_PAD(0x53C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX3_P__GPIO_6_22	IOMUX_PAD(NON_PAD_I, 0x1EC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX2_P__GPIO_6_24	IOMUX_PAD(NON_PAD_I, 0x1F0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_CLK_P__GPIO_6_26	IOMUX_PAD(NON_PAD_I, 0x1F4, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX1_P__GPIO_6_28	IOMUX_PAD(NON_PAD_I, 0x1F8, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX0_P__GPIO_6_30	IOMUX_PAD(NON_PAD_I, 0x1FC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX3_P__GPIO_7_22	IOMUX_PAD(NON_PAD_I, 0x200, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_CLK_P__GPIO_7_24	IOMUX_PAD(NON_PAD_I, 0x204, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX2_P__GPIO_7_26	IOMUX_PAD(NON_PAD_I, 0x208, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX1_P__GPIO_7_28	IOMUX_PAD(NON_PAD_I, 0x20C, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX0_P__GPIO_7_30	IOMUX_PAD(NON_PAD_I, 0x210, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_10__GPIO_4_0	IOMUX_PAD(0x540, 0x214, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_11__GPIO_4_1	IOMUX_PAD(0x544, 0x218, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_12__GPIO_4_2	IOMUX_PAD(0x548, 0x21C, 0, 0x0, 0, \
+					PAD_CTRL_9 | PAD_CTRL_2)
+#define MX53_PAD_GPIO_13__GPIO_4_3	IOMUX_PAD(0x54C, 0x220, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_14__GPIO_4_4	IOMUX_PAD(0x550, 0x224, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_DQM3__DRAM_DQM3	IOMUX_PAD(0x554, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDQS3__DRAM_SDQS3	IOMUX_PAD(0x558, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDCKE1__DRAM_SDCKE1	IOMUX_PAD(0x55C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_DQM2__DRAM_DQM2	IOMUX_PAD(0x560, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDODT1__DRAM_SDODT1	IOMUX_PAD(0x564, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDQS2__DRAM_SDQS2	IOMUX_PAD(0x568, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_RESET__DRAM_RESET	IOMUX_PAD(0x56C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDCLK1__DRAM_SDCLK1	IOMUX_PAD(0x570, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_CAS__DRAM_CAS	IOMUX_PAD(0x574, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDCLK0__DRAM_SDCLK0	IOMUX_PAD(0x578, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDQS0__DRAM_SDQS0	IOMUX_PAD(0x57C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDODT0__DRAM_SDODT0	IOMUX_PAD(0x580, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_DQM0__DRAM_DQM0	IOMUX_PAD(0x584, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_RAS__DRAM_RAS	IOMUX_PAD(0x588, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDCKE0__DRAM_SDCKE0	IOMUX_PAD(0x58C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_SDQS1__DRAM_SDQS1	IOMUX_PAD(0x590, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_DRAM_DQM1__DRAM_DQM1	IOMUX_PAD(0x594, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_PMIC_ON_REQ__PMIC_ON_REQ	IOMUX_PAD(0x598, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_PMIC_STBY_REQ__PMIC_STBY_REQ	IOMUX_PAD(0x59C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_CLE__GPIO_6_7	IOMUX_PAD(0x5A0, 0x228, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_ALE__GPIO_6_8	IOMUX_PAD(0x5A4, 0x22C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_WP_B__GPIO_6_9	IOMUX_PAD(0x5A8, 0x230, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_RB0__GPIO_6_10	IOMUX_PAD(0x5AC, 0x234, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_CS0__GPIO_6_11	IOMUX_PAD(0x5B0, 0x238, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_CS1__GPIO_6_14	IOMUX_PAD(0x5B4, 0x23C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_CS2__GPIO_6_15	IOMUX_PAD(0x5B8, 0x240, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NANDF_CS3__GPIO_6_16	IOMUX_PAD(0x5BC, 0x244, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_NANDF__NVCC_NANDF	IOMUX_PAD(0x5C0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_MDIO__GPIO_1_22	IOMUX_PAD(0x5C4, 0x248, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_REF_CLK__GPIO_1_23	IOMUX_PAD(0x5C8, 0x24C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_RX_ER__GPIO_1_24	IOMUX_PAD(0x5CC, 0x250, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_CRS_DV__GPIO_1_25	IOMUX_PAD(0x5D0, 0x254, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_RXD1__GPIO_1_26	IOMUX_PAD(0x5D4, 0x258, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_RXD0__GPIO_1_27	IOMUX_PAD(0x5D8, 0x25C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_TX_EN__GPIO_1_28	IOMUX_PAD(0x5DC, 0x260, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_TXD1__GPIO_1_29	IOMUX_PAD(0x5E0, 0x264, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_TXD0__GPIO_1_30	IOMUX_PAD(0x5E4, 0x268, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_FEC_MDC__GPIO_1_31	IOMUX_PAD(0x5E8, 0x26C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_FEC__NVCC_FEC	IOMUX_PAD(0x5EC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DIOW__GPIO_6_17	IOMUX_PAD(0x5F0, 0x270, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DMACK__GPIO_6_18	IOMUX_PAD(0x5F4, 0x274, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DMARQ__GPIO_7_0	IOMUX_PAD(0x5F8, 0x278, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_BUFFER_EN__GPIO_7_1	IOMUX_PAD(0x5FC, 0x27C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_INTRQ__GPIO_7_2	IOMUX_PAD(0x600, 0x280, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DIOR__GPIO_7_3	IOMUX_PAD(0x604, 0x284, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_RESET_B__GPIO_7_4	IOMUX_PAD(0x608, 0x288, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_IORDY__GPIO_7_5	IOMUX_PAD(0x60C, 0x28C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DA_0__GPIO_7_6	IOMUX_PAD(0x610, 0x290, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DA_1__GPIO_7_7	IOMUX_PAD(0x614, 0x294, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DA_2__GPIO_7_8	IOMUX_PAD(0x618, 0x298, 1, 0x0, 0, PAD_CTRL_12)
+#define MX53_PAD_ATA_CS_0__GPIO_7_9	IOMUX_PAD(0x61C, 0x29C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_CS_1__GPIO_7_10	IOMUX_PAD(0x620, 0x2A0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_ATA2__NVCC_ATA2	IOMUX_PAD(0x624, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA0__GPIO_2_0	IOMUX_PAD(0x628, 0x2A4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA1__GPIO_2_1	IOMUX_PAD(0x62C, 0x2A8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA2__GPIO_2_2	IOMUX_PAD(0x630, 0x2AC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA3__GPIO_2_3	IOMUX_PAD(0x634, 0x2B0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA4__GPIO_2_4	IOMUX_PAD(0x638, 0x2B4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA5__GPIO_2_5	IOMUX_PAD(0x63C, 0x2B8, 1, 0x0, 0, PAD_CTL_PUS_100K_UP)
+#define MX53_PAD_ATA_DATA6__GPIO_2_6	IOMUX_PAD(0x640, 0x2BC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA7__GPIO_2_7	IOMUX_PAD(0x644, 0x2C0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA8__GPIO_2_8	IOMUX_PAD(0x648, 0x2C4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA9__GPIO_2_9	IOMUX_PAD(0x64C, 0x2C8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA10__GPIO_2_10	IOMUX_PAD(0x650, 0x2CC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA11__GPIO_2_11	IOMUX_PAD(0x654, 0x2D0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA12__GPIO_2_12	IOMUX_PAD(0x658, 0x2D4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA13__GPIO_2_13	IOMUX_PAD(0x65C, 0x2D8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA14__GPIO_2_14	IOMUX_PAD(0x660, 0x2DC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA15__GPIO_2_15	IOMUX_PAD(0x664, 0x2E0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_ATA0__NVCC_ATA0	IOMUX_PAD(0x668, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_DATA0__GPIO_1_16	IOMUX_PAD(0x66C, 0x2E4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_DATA1__GPIO_1_17	IOMUX_PAD(0x670, 0x2E8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_CMD__GPIO_1_18	IOMUX_PAD(0x674, 0x2EC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_DATA2__GPIO_1_19	IOMUX_PAD(0x678, 0x2F0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_CLK__GPIO_1_20	IOMUX_PAD(0x67C, 0x2F4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD1_DATA3__GPIO_1_21	IOMUX_PAD(0x680, 0x2F8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_SD1__NVCC_SD1	IOMUX_PAD(0x684, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_CLK__GPIO_1_10	IOMUX_PAD(0x688, 0x2FC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_CMD__GPIO_1_11	IOMUX_PAD(0x68C, 0x300, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA3__GPIO_1_12	IOMUX_PAD(0x690, 0x304, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA2__GPIO_1_13	IOMUX_PAD(0x694, 0x308, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA1__GPIO_1_14	IOMUX_PAD(0x698, 0x30C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA0__GPIO_1_15	IOMUX_PAD(0x69C, 0x310, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_SD2__NVCC_SD2	IOMUX_PAD(0x6A0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_0__GPIO_1_0	IOMUX_PAD(0x6A4, 0x314, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_1__GPIO_1_1	IOMUX_PAD(0x6A8, 0x318, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_9__GPIO_1_9	IOMUX_PAD(0x6AC, 0x31C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_3__GPIO_1_3	IOMUX_PAD(0x6B0, 0x320, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_6__GPIO_1_6	IOMUX_PAD(0x6B4, 0x324, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_2__GPIO_1_2	IOMUX_PAD(0x6B8, 0x328, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_4__GPIO_1_4	IOMUX_PAD(0x6BC, 0x32C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_5__GPIO_1_5	IOMUX_PAD(0x6C0, 0x330, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_7__GPIO_1_7	IOMUX_PAD(0x6C4, 0x334, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_8__GPIO_1_8	IOMUX_PAD(0x6C8, 0x338, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_16__GPIO_7_11	IOMUX_PAD(0x6CC, 0x33C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_17__GPIO_7_12	IOMUX_PAD(0x6D0, 0x340, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GPIO_18__GPIO_7_13	IOMUX_PAD(0x6D4, 0x344, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_NVCC_GPIO__NVCC_GPIO	IOMUX_PAD(0x6D8, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_POR_B__POR_B	IOMUX_PAD(0x6DC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_BOOT_MODE1__BOOT_MODE1	IOMUX_PAD(0x6E0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_RESET_IN_B__RESET_IN_B	IOMUX_PAD(0x6E4, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_BOOT_MODE0__BOOT_MODE0	IOMUX_PAD(0x6E8, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_TEST_MODE__TEST_MODE	IOMUX_PAD(0x6EC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_ADDDS__GRP_ADDDS	IOMUX_PAD(0x6F0, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDRMODE_CTL__GRP_DDRMODE_CTL	IOMUX_PAD(0x6F4, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDRPKE__GRP_DDRPKE	IOMUX_PAD(0x6FC, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDRPK__GRP_DDRPK	IOMUX_PAD(0x708, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_TERM_CTL3__GRP_TERM_CTL3	IOMUX_PAD(0x70C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDRHYS__GRP_DDRHYS	IOMUX_PAD(0x710, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDRMODE__GRP_DDRMODE	IOMUX_PAD(0x714, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_B0DS__GRP_B0DS	IOMUX_PAD(0x718, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_B1DS__GRP_B1DS	IOMUX_PAD(0x71C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_CTLDS__GRP_CTLDS	IOMUX_PAD(0x720, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_DDR_TYPE__GRP_DDR_TYPE	IOMUX_PAD(0x724, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_B2DS__GRP_B2DS	IOMUX_PAD(0x728, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_GRP_B3DS__GRP_B3DS	IOMUX_PAD(0x72C, NON_MUX_I, 0, 0x0, 0, NO_PAD_CTRL)
+
+/* NAND */
+#define MX53_PAD_NANDF_CLE__NANDF_CLE	IOMUX_PAD(0x5A0, 0x228, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_ALE__NANDF_ALE		IOMUX_PAD(0x5A4, 0x22C, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_WP_B__NANDF_WP_B	IOMUX_PAD(0x5A8, 0x230, 0, 0x0, 0, PAD_CTRL_11)
+#define MX53_PAD_NANDF_WE_B__NANDF_WE_B	IOMUX_PAD(0x52C, 0x1DC, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_RE_B__NANDF_RE_B		IOMUX_PAD(0x530, 0x1E0, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_RB0__NANDF_RB0	IOMUX_PAD(0x5AC, 0x234, 0, 0x0, 0, PAD_CTRL_11)
+#define MX53_PAD_NANDF_CS0__NANDF_CS0	IOMUX_PAD(0x5B0, 0x238, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_CS1__NANDF_CS1	IOMUX_PAD(0x5B4, 0x23C, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_CS2__NANDF_CS2	IOMUX_PAD(0x5B8, 0x240, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_NANDF_CS3__NANDF_CS3	IOMUX_PAD(0x5BC, 0x244, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_EIM_DA0__EIM_DA0	IOMUX_PAD(0x4EC, 0x19C, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA1__EIM_DA1	IOMUX_PAD(0x4F0, 0x1A0, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA2__EIM_DA2	IOMUX_PAD(0x4F4, 0x1A4, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA3__EIM_DA3	IOMUX_PAD(0x4F8, 0x1A8, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA4__EIM_DA4	IOMUX_PAD(0x4FC, 0x1AC, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA5__EIM_DA5	IOMUX_PAD(0x500, 0x1B0, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA6__EIM_DA6	IOMUX_PAD(0x504, 0x1B4, 0, 0x0, 0, PAD_CTRL_10)
+#define MX53_PAD_EIM_DA7__EIM_DA7	IOMUX_PAD(0x508, 0x1B8, 0, 0x0, 0, PAD_CTRL_10)
+
+/* SPI */
+#define MX53_PAD_EIM_EB2__CSPI_SS0		IOMUX_PAD(0x45C, 0x114, 4, 0x7A8, 3, PAD_CTRL_1)
+#define MX53_PAD_EIM_D19__CSPI_SS1		IOMUX_PAD(0x46C, 0x124, 4, 0x7AC, 3, PAD_CTRL_1)
+
+/* PWM */
+#define MX53_PAD_GPIO_1__PWMO	IOMUX_PAD(0x6A8, 0x318, 4, 0x0, 0, NO_PAD_CTRL)
+
+/* Camera */
+#define MX53_PAD_CSI0_VSYNC__CSI0_VSYNC	IOMUX_PAD(0x3F8, 0xCC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_PIXCLK__CSI0_PIXCLK	IOMUX_PAD(0x3EC, 0xC0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_MCLK__CSI0_HSYNC	IOMUX_PAD(0x3F0, 0xC4, 0, 0x0, 0, NO_PAD_CTRL)
+
+/* IPU */
+#define MX53_PAD_CSI0_D12__CSI0_D12		IOMUX_PAD(0x41C, 0xF0, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D13__CSI0_D13		IOMUX_PAD(0x420, 0xF4, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D14__CSI0_D14		IOMUX_PAD(0x424, 0xF8, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D15__CSI0_D15		IOMUX_PAD(0x428, 0xFC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D16__CSI0_D16		IOMUX_PAD(0x42C, 0x100, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D17__CSI0_D17		IOMUX_PAD(0x430, 0x104, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D18__CSI0_D18		IOMUX_PAD(0x434, 0x108, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_CSI0_D19__CSI0_D19		IOMUX_PAD(0x438, 0x10C, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D20__SER_DISP0_CS	IOMUX_PAD(0x470, 0x128, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D29__DISPB0_SER_RS	IOMUX_PAD(0x498, 0x150, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D30__DI0_PIN11		IOMUX_PAD(0x49C, 0x154, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D31__DI0_PIN12		IOMUX_PAD(0x4A0, 0x158, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D23__DI0_D0_CS		IOMUX_PAD(0x47C, 0x134, 4, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_A25__DI0_D1_CS		IOMUX_PAD(0x458, 0x110, 6, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_OE__DI1_PIN7			IOMUX_PAD(0x4D4, 0x188, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_RW__DI1_PIN8			IOMUX_PAD(0x4D8, 0x18C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D21__DISPB0_SER_CLK		IOMUX_PAD(0x474, 0x12C, 3, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_EIM_D22__DISPB0_SER_DIN		IOMUX_PAD(0x478, 0x130, 3, 0x0, 0, NO_PAD_CTRL)
+
+/* Display */
+#define MX53_PAD_DI0_DISP_CLK__DI0_DISP_CLK	IOMUX_PAD(0x378, 0x4C, 0, 0x0, 0, PAD_CTRL_5)
+#define MX53_PAD_DI0_PIN15__DI0_PIN15		IOMUX_PAD(0x37C, 0x50, 0, 0x0, 0, PAD_CTRL_6)
+#define MX53_PAD_DI0_PIN2__DI0_PIN2		IOMUX_PAD(0x380, 0x54, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DI0_PIN3__DI0_PIN3		IOMUX_PAD(0x384, 0x58, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT0__DISP0_DAT0	IOMUX_PAD(0x38C, 0x60, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT1__DISP0_DAT1	IOMUX_PAD(0x390, 0x64, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT2__DISP0_DAT2	IOMUX_PAD(0x394, 0x68, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT3__DISP0_DAT3	IOMUX_PAD(0x398, 0x6C, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT4__DISP0_DAT4	IOMUX_PAD(0x39C, 0x70, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT5__DISP0_DAT5	IOMUX_PAD(0x3A0, 0x74, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT6__DISP0_DAT6	IOMUX_PAD(0x3A4, 0x78, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT7__DISP0_DAT7	IOMUX_PAD(0x3A8, 0x7C, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT8__DISP0_DAT8	IOMUX_PAD(0x3AC, 0x80, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT9__DISP0_DAT9	IOMUX_PAD(0x3B0, 0x84, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT10__DISP0_DAT10	IOMUX_PAD(0x3B4, 0x88, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT11__DISP0_DAT11	IOMUX_PAD(0x3B8, 0x8C, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT12__DISP0_DAT12	IOMUX_PAD(0x3BC, 0x90, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT13__DISP0_DAT13	IOMUX_PAD(0x3C0, 0x94, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT14__DISP0_DAT14	IOMUX_PAD(0x3C4, 0x98, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT15__DISP0_DAT15	IOMUX_PAD(0x3C8, 0x9C, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT16__DISP0_DAT16	IOMUX_PAD(0x3CC, 0xA0, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT17__DISP0_DAT17	IOMUX_PAD(0x3D0, 0xA4, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT18__DISP0_DAT18	IOMUX_PAD(0x3D4, 0xA8, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT19__DISP0_DAT19	IOMUX_PAD(0x3D8, 0xAC, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT20__DISP0_DAT20	IOMUX_PAD(0x3DC, 0xB0, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT21__DISP0_DAT21	IOMUX_PAD(0x3E0, 0xB4, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT22__DISP0_DAT22	IOMUX_PAD(0x3E4, 0xB8, 0, 0x0, 0, PAD_CTRL_7)
+#define MX53_PAD_DISP0_DAT23__DISP0_DAT23	IOMUX_PAD(0x3E8, 0xBC, 0, 0x0, 0, PAD_CTRL_7)
+
+/* CAN*/
+#define MX53_PAD_KEY_COL2__TXCAN1			IOMUX_PAD(0x35C, 0x34, 2, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_KEY_ROW2__RXCAN1		IOMUX_PAD(0x360, 0x38, 2, 0x760, 0, PAD_CTRL_3)
+#define MX53_PAD_KEY_COL4__TXCAN2			IOMUX_PAD(0x36C, 0x44, 2, 0x0, 0, PAD_CTRL_4)
+#define MX53_PAD_KEY_ROW4__RXCAN2		IOMUX_PAD(0x370, 0x48, 2, 0x764, 0, PAD_CTRL_3)
+
+/* AUD5 */
+#define MX53_PAD_KEY_COL0__AUD5_TXC		IOMUX_PAD(0x34C, 0x24, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW0__AUD5_TXD		IOMUX_PAD(0x350, 0x28, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_COL1__AUD5_TXFS		IOMUX_PAD(0x354, 0x2C, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_KEY_ROW1__AUD5_RXD		IOMUX_PAD(0x358, 0x30, 2, 0x0, 0, NO_PAD_CTRL)
+
+/* I2C1 */
+#define MX53_PAD_CSI0_D8__I2C1_SDA		IOMUX_PAD(0x40C, 0xE0, 5 | IOMUX_CONFIG_SION, 0x818, 0, PAD_CTRL_9)
+#define MX53_PAD_CSI0_D9__I2C1_SCL		IOMUX_PAD(0x410, 0xE4, 5 | IOMUX_CONFIG_SION, 0x814, 0, PAD_CTRL_9)
+
+/* I2C2 */
+#define MX53_PAD_KEY_COL3__I2C2_SCL		IOMUX_PAD(0x364, 0x3C, 4 | IOMUX_CONFIG_SION, 0x81C, 0, PAD_CTRL_9)
+#define MX53_PAD_KEY_ROW3__I2C2_SDA		IOMUX_PAD(0x368, 0x40, 4 | IOMUX_CONFIG_SION, 0x820, 0, PAD_CTRL_9)
+
+/* UART1 */
+#define MX53_PAD_CSI0_D10__UART1_TXD		IOMUX_PAD(0x414, 0xE8, 2, 0x0, 0, MX53_UART_PAD_CTRL)
+#define MX53_PAD_CSI0_D11__UART1_RXD		IOMUX_PAD(0x418, 0xEC, 2, 0x878, 1, MX53_UART_PAD_CTRL)
+
+/* UART2 */
+#define MX53_PAD_ATA_BUFFER_EN__UART2_RXD	IOMUX_PAD(0x5FC, 0x27C, 3, 0x880, 3, MX53_UART_PAD_CTRL)
+#define MX53_PAD_ATA_DMARQ__UART2_TXD	IOMUX_PAD(0x5F8, 0x278, 3, 0x0, 0, MX53_UART_PAD_CTRL)
+#define MX53_PAD_ATA_DIOR__UART2_RTS		IOMUX_PAD(0x604, 0x284, 3, 0x87C, 3, MX53_UART_PAD_CTRL)
+#define MX53_PAD_ATA_INTRQ__UART2_CTS		IOMUX_PAD(0x600, 0x280, 3, 0x0, 0, NO_PAD_CTRL)
+
+/* UART3 */
+#define MX53_PAD_ATA_CS_0__UART3_TXD		IOMUX_PAD(0x61C, 0x29C, 4, 0x0, 0, MX53_UART_PAD_CTRL)
+#define MX53_PAD_ATA_CS_1__UART3_RXD		IOMUX_PAD(0x620, 0x2A0, 4, 0x888, 3, MX53_UART_PAD_CTRL)
+
+/* CSPI */
+#define MX53_PAD_EIM_D16__CSPI1_SCLK		IOMUX_PAD(0x460, 0x118, 4, 0x79C, 3, PAD_CTRL_1)
+#define MX53_PAD_EIM_D17__CSPI1_MISO		IOMUX_PAD(0x464, 0x11C, 4, 0x7A0, 3, PAD_CTRL_1)
+#define MX53_PAD_EIM_D18__CSPI1_MOSI		IOMUX_PAD(0x468, 0x120, 4, 0x7A4, 3, PAD_CTRL_1)
+
+/* LVDS0 */
+#define MX53_PAD_LVDS0_TX3_P__LVDS0_TX3	IOMUX_PAD(NON_PAD_I, 0x200, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_CLK_P__LVDS0_CLK	IOMUX_PAD(NON_PAD_I, 0x204, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX2_P__LVDS0_TX2	IOMUX_PAD(NON_PAD_I, 0x208, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX1_P__LVDS0_TX1	IOMUX_PAD(NON_PAD_I, 0x20C, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS0_TX0_P__LVDS0_TX0	IOMUX_PAD(NON_PAD_I, 0x210, 1, 0x0, 0, NO_PAD_CTRL)
+
+/* LVDS1 */
+#define MX53_PAD_LVDS1_TX3_P__LVDS1_TX3	IOMUX_PAD(NON_PAD_I, 0x1EC, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX2_P__LVDS1_TX2	IOMUX_PAD(NON_PAD_I, 0x1F0, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_CLK_P__LVDS1_CLK	IOMUX_PAD(NON_PAD_I, 0x1F4, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX1_P__LVDS1_TX1	IOMUX_PAD(NON_PAD_I, 0x1F8, 1, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_LVDS1_TX0_P__LVDS1_TX0	IOMUX_PAD(NON_PAD_I, 0x1FC, 1, 0x0, 0, NO_PAD_CTRL)
+
+/* SD1 */
+#define MX53_PAD_SD1_DATA0__SD1_DATA0	IOMUX_PAD(0x66C, 0x2E4, 0, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_SD1_DATA1__SD1_DATA1	IOMUX_PAD(0x670, 0x2E8, 0, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_SD1_CMD__SD1_CMD		IOMUX_PAD(0x674, 0x2EC, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_SD1_DATA2__SD1_DATA2	IOMUX_PAD(0x678, 0x2F0, 0, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_SD1_CLK__SD1_CLK		IOMUX_PAD(0x67C, 0x2F4, \
+						IOMUX_CONFIG_SION, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_SD1_DATA3__SD1_DATA3	IOMUX_PAD(0x680, 0x2F8, 0, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+
+/* SD2 */
+#define MX53_PAD_SD2_CLK__SD2_CLK		IOMUX_PAD(0x688, 0x2FC, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_CMD__SD2_CMD		IOMUX_PAD(0x68C, 0x300, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA0__SD2_DAT0		IOMUX_PAD(0x69C, 0x310, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA1__SD2_DAT1		IOMUX_PAD(0x698, 0x30C, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA2__SD2_DAT2		IOMUX_PAD(0x694, 0x308, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_SD2_DATA3__SD2_DAT3		IOMUX_PAD(0x690, 0x304, 0, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA12__SD2_DAT4	IOMUX_PAD(0x658, 0x2D4, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA13__SD2_DAT5	IOMUX_PAD(0x65C, 0x2D8, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA14__SD2_DAT6	IOMUX_PAD(0x660, 0x2DC, 2, 0x0, 0, NO_PAD_CTRL)
+#define MX53_PAD_ATA_DATA15__SD2_DAT7	IOMUX_PAD(0x664, 0x2E0, 2, 0x0, 0, NO_PAD_CTRL)
+
+/* SD3 */
+#define MX53_PAD_ATA_DATA8__SD3_DAT0		IOMUX_PAD(0x648, 0x2C4, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA9__SD3_DAT1		IOMUX_PAD(0x64C, 0x2C8, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA10__SD3_DAT2	IOMUX_PAD(0x650, 0x2CC, 4, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA11__SD3_DAT3	IOMUX_PAD(0x654, 0x2D0, 4, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA0__SD3_DAT4		IOMUX_PAD(0x628, 0x2A4, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA1__SD3_DAT5		IOMUX_PAD(0x62C, 0x2A8, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA2__SD3_DAT6		IOMUX_PAD(0x630, 0x2AC, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_DATA3__SD3_DAT7		IOMUX_PAD(0x634, 0x2B0, 4, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_RESET_B__SD3_CMD	IOMUX_PAD(0x608, 0x288, 2, 0x0, 0, \
+						MX53_SDHC_PAD_CTRL)
+#define MX53_PAD_ATA_IORDY__SD3_CLK		IOMUX_PAD(0x60C, 0x28C, 2, \
+						0x0, 0, MX53_SDHC_PAD_CTRL)
+
+/* USB */
+#define MX53_PAD_EIM_A24__GPIO_5_4		IOMUX_PAD(0x4A8, 0x15C, 1, 0x0, 0, NO_PAD_CTRL)
+
+/* FEC */
+#define MX53_PAD_FEC_MDIO__FEC_MDIO		IOMUX_PAD(0x5C4, 0x248, 0, 0x804, 1, MX53_FEC_PAD_CTRL)
+#define MX53_PAD_FEC_REF_CLK__FEC_REF_CLK	IOMUX_PAD(0x5C8, 0x24C, 0, 0x0, 0, PAD_CTRL_8)
+#define MX53_PAD_FEC_RX_ER__FEC_RX_ER	IOMUX_PAD(0x5CC, 0x250, 0, 0x0, 0, PAD_CTRL_8)
+#define MX53_PAD_FEC_CRS_DV__FEC_CRS_DV	IOMUX_PAD(0x5D0, 0x254, 0, 0x0, 0, PAD_CTRL_8)
+#define MX53_PAD_FEC_RXD1__FEC_RXD1		IOMUX_PAD(0x5D4, 0x258, 0, 0x0, 0, PAD_CTRL_8)
+#define MX53_PAD_FEC_RXD0__FEC_RXD0		IOMUX_PAD(0x5D8, 0x25C, 0, 0x0, 0, PAD_CTRL_8)
+#define MX53_PAD_FEC_TX_EN__FEC_TX_EN	IOMUX_PAD(0x5DC, 0x260, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_FEC_TXD1__FEC_TXD1		IOMUX_PAD(0x5E0, 0x264, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_FEC_TXD0__FEC_TXD0		IOMUX_PAD(0x5E4, 0x268, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+#define MX53_PAD_FEC_MDC__FEC_MDC		IOMUX_PAD(0x5E8, 0x26C, 0, 0x0, 0, PAD_CTL_DSE_HIGH)
+
+#define MX53_PAD_GPIO_0__SSI_EXT1_CLK		IOMUX_PAD(0x6A4, 0x314, 3, 0x0, 0, NO_PAD_CTRL)
+
+/* MLB */
+#define MX53_PAD_GPIO_2__MLBDAT	IOMUX_PAD(0x6B8, 0x328, 7, 0x85C, 2, \
+					PAD_CTRL_2 | PAD_CTL_PUS_360K_DOWN | \
+					PAD_CTL_HYS)
+#define MX53_PAD_GPIO_3__MLBCLK	IOMUX_PAD(0x6B0, 0x320, 7, 0x858, 2, \
+					PAD_CTRL_2 | PAD_CTL_PUS_360K_DOWN | \
+					PAD_CTL_HYS)
+#define MX53_PAD_GPIO_6__MLBSIG	IOMUX_PAD(0x6B4, 0x324, 7, 0x860, 2, \
+					PAD_CTRL_2 | PAD_CTL_PUS_360K_DOWN | \
+					PAD_CTL_HYS)
+
+/* SPDIF */
+#define MX53_PAD_GPIO_19__SPDIF_TX1	IOMUX_PAD(0x348, 0x20, 3, 0x0, 0, \
+					PAD_CTRL_3 | PAD_CTL_PUS_100K_UP)
+
+/* ESAI */
+#define MX53_PAD_FEC_MDIO__ESAI_SCKR		IOMUX_PAD(0x5C4, 0x248, 2, \
+							0x7DC, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_REF_CLK__ESAI_FSR	IOMUX_PAD(0x5C8, 0x24C, 2, \
+							0x7CC, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_RX_ER__ESAI_HCKR	IOMUX_PAD(0x5CC, 0x250, 2, \
+							0x7D4, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_CRS_DV__ESAI_SCKT	IOMUX_PAD(0x5D0, 0x254, 2, \
+							0x7E0, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_RXD1__ESAI_FST		IOMUX_PAD(0x5D4, 0x258, 2, \
+							0x7D0, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_RXD0__ESAI_HCKT		IOMUX_PAD(0x5D8, 0x25C, 2, \
+							0x7D8, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_TX_EN__ESAI_TX3_RX2	IOMUX_PAD(0x5DC, 0x260, 2, \
+							0x7F0, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_TXD1__ESAI_TX2_RX3	IOMUX_PAD(0x5E0, 0x264, 2, \
+							0x7EC, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_TXD0__ESAI_TX4_RX1	IOMUX_PAD(0x5E4, 0x268, 2, \
+							0x7F4, 0, PAD_CTRL_9)
+#define MX53_PAD_FEC_MDC__ESAI_TX5_RX0	IOMUX_PAD(0x5E8, 0x26C, 2, \
+							0x7F8, 0, PAD_CTRL_9)
+#define MX53_PAD_NANDF_CS2__ESAI_TX0		IOMUX_PAD(0x5B8, 0x240, 3, \
+							0x7E4, 0, PAD_CTRL_9)
+#define MX53_PAD_NANDF_CS3__ESAI_TX1		IOMUX_PAD(0x5BC, 0x244, 3, \
+							0x7E8, 0, PAD_CTRL_9)
+
+#endif /* __MACH_IOMUX_MX53_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/iomux-v3.h b/arch/arm/plat-mxc/include/mach/iomux-v3.h
index f2f73d3..6beaf8c 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-v3.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-v3.h
@@ -75,7 +75,9 @@ struct pad_desc {
 #define PAD_CTL_PKE			(1 << 7)
 #define PAD_CTL_PUE			(1 << 6)
 #define PAD_CTL_PUS_100K_DOWN		(0 << 4)
+#define PAD_CTL_PUS_360K_DOWN		(0 << 4)
 #define PAD_CTL_PUS_47K_UP		(1 << 4)
+#define PAD_CTL_PUS_75K_UP		(1 << 4)
 #define PAD_CTL_PUS_100K_UP		(2 << 4)
 #define PAD_CTL_PUS_22K_UP		(3 << 4)
 
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index 459e389..83532f6 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -20,6 +20,7 @@
 #define MX27_PHYS_OFFSET	UL(0xa0000000)
 #define MX3x_PHYS_OFFSET	UL(0x80000000)
 #define MX37_PHYS_OFFSET	UL(0x40000000)
+#define MX50_PHYS_OFFSET	UL(0x70000000)
 #define MX51_PHYS_OFFSET	UL(0x90000000)
 #define MX53_PHYS_OFFSET	UL(0x70000000)
 #define MXC91231_PHYS_OFFSET	UL(0x90000000)
@@ -41,6 +42,8 @@
 #  define PHYS_OFFSET		MX51_PHYS_OFFSET
 # elif defined CONFIG_ARCH_MX53
 #  define PHYS_OFFSET		MX53_PHYS_OFFSET
+# elif defined CONFIG_ARCH_MX50
+#  define PHYS_OFFSET		MX50_PHYS_OFFSET
 # endif
 #endif
 
diff --git a/arch/arm/plat-mxc/include/mach/mx5x.h b/arch/arm/plat-mxc/include/mach/mx5x.h
new file mode 100644
index 0000000..b99e3a9
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mx5x.h
@@ -0,0 +1,645 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_MX5X_H__
+#define __ASM_ARCH_MXC_MX5X_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+/*!
+ * @file arch-mxc/mx5x.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup MSL_MX5
+ */
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*!
+ * This option is used to set or clear the dspdma bit in the SDMA config
+ * register.
+ */
+#define MXC_SDMA_DSPDMA         0
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
+#define MXC_SDMA_V2
+
+/*!
+ * The maximum frequency that the pixel clock can be at so as to
+ * activate DVFS-PER.
+ */
+#define DVFS_MAX_PIX_CLK	54000000
+
+
+/* IROM
+ */
+#define IROM_BASE_ADDR		0x0
+#define IROM_SIZE			SZ_64K
+
+ /*
+ * IRAM
+ */
+#define MX53_IRAM_BASE_ADDR		0xF8000000	/* internal ram */
+#define MX51_IRAM_BASE_ADDR		0x1FFE0000	/* internal ram */
+#define IRAM_PARTITIONS		16
+#define IRAM_SIZE		(IRAM_PARTITIONS*SZ_8K)	/* 128KB */
+
+#if defined(CONFIG_MXC_SECURITY_SCC2) \
+    || defined(CONFIG_MXC_SECURITY_SCC2_MODULE)
+#define SCC_RAM_SIZE  SZ_16K
+#else
+#define SCC_RAM_SIZE  0
+#endif
+
+/*
+ * SCC RAM BASE: last 2 partitions of IRAM on MX51, separate from IRAM on MX53
+ */
+#define MX51_SCC_RAM_BASE_ADDR	MX51_IRAM_BASE_ADDR
+#define MX53_SCC_RAM_BASE_ADDR	0x07000000
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE 0x6000
+#else
+#define SND_RAM_SIZE 0
+#endif
+
+#ifdef CONFIG_MXC_VPU_IRAM
+#define VPU_IRAM_SIZE  0x14000
+#else
+#define VPU_IRAM_SIZE 0
+#endif
+
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+#define USB_IRAM_SIZE	SZ_8K
+#else
+#define USB_IRAM_SIZE 0
+#endif
+
+/*
+ * NFC
+ */
+#define MX53_NFC_BASE_ADDR_AXI		0xF7FF0000	/* NAND flash AXI */
+#define MX51_NFC_BASE_ADDR_AXI		0xCFFF0000	/* NAND flash AXI */
+#define NFC_BASE_ADDR_AXI_VIRT	0xF9000000
+#define NFC_AXI_SIZE		SZ_64K
+
+/*
+ * Graphics Memory of GPU
+ */
+#define MX53_GPU_GMEM_BASE_ADDR		0xF8020000
+#define MX51_GPU_GMEM_BASE_ADDR		0x20000000
+#define GPU_BASE_ADDR			0x30000000
+#define MX53_GPU2D_BASE_ADDR		0x20000000
+#define MX51_GPU2D_BASE_ADDR		0xD0000000
+
+#define MX53_TZIC_BASE_ADDR		0x0FFFC000
+#define MX51_TZIC_BASE_ADDR_T01		0x8FFFC000
+#define MX51_TZIC_BASE_ADDR		0xE0000000
+#define TZIC_SIZE		SZ_16K
+
+/*
+ * AHCI SATA
+ */
+#define MX53_SATA_BASE_ADDR 		0x10000000
+
+/*
+ * Databahn MX50
+ */
+ #define MX50_DATABAHN_BASE_ADDR		0x14000000
+
+#define DEBUG_BASE_ADDR	0x40000000
+/*MX53 + 0x2000000 */
+#define DEBUG_SIZE		SZ_1M
+#define ETB_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00001000)
+#define ETM_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00002000)
+#define TPIU_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00003000)
+#define CTI0_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00004000)
+#define CTI1_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00005000)
+#define CTI2_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00006000)
+#define CTI3_BASE_ADDR		(DEBUG_BASE_ADDR + 0x00007000)
+#define CORTEX_DBG_BASE_ADDR	(DEBUG_BASE_ADDR + 0x00008000)
+
+#define APBHDMA_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01000000)
+#define OCOTP_CTRL_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01002000)
+#define DIGCTL_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01004000)
+#define GPMI_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01006000)
+#define BCH_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01008000)
+#define ELCDIF_BASE_ADDR	(DEBUG_BASE_ADDR + 0x0100A000)
+#define EPXP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x0100C000)
+#define DCP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x0100E000)
+#define EPDC_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01010000)
+#define QOSC_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01012000)
+#define PERFMON_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01014000)
+#define SSP_BASE_ADDR		(DEBUG_BASE_ADDR + 0x01016000)
+#define ANATOP_BASE_ADDR	(DEBUG_BASE_ADDR + 0x01018000)
+
+#define MX50_NIC_BASE_ADDR	(DEBUG_BASE_ADDR + 0x08000000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0x70000000
+#define SPBA0_BASE_ADDR_VIRT	0xFB100000
+#define SPBA0_SIZE		SZ_1M
+
+#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
+#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI1_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define ESAI_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00018000)
+#define MMC_SDHC3_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define MMC_SDHC4_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00024000)
+#define SPDIF_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00028000)
+#define ASRC_BASE_ADDR		(SPBA0_BASE_ADDR + 0x0002C000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00030000)
+#define SLIM_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00034000)
+#define HSI2C_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00038000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI1	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_ESAI	0x18
+#define SPBA_SDHC3	0x20
+#define SPBA_SDHC4	0x24
+#define SPBA_SPDIF	0x28
+#define SPBA_ASRC	0x2C
+#define SPBA_ATA	0x30
+#define SPBA_SLIM	0x34
+#define SPBA_HSI2C	0x38
+#define SPBA_CTRL	0x3C
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0x73F00000
+#define AIPS1_BASE_ADDR_VIRT	0xF7E00000
+#define AIPS1_SIZE		SZ_1M
+
+#define OTG_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00080000)
+#define GPIO1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00084000)
+#define GPIO2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00088000)
+#define GPIO3_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0008C000)
+#define GPIO4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00090000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00094000)
+#define WDOG1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00098000)
+#define WDOG2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0009C000)
+#define GPT1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define SRTC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A4000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000A8000)
+#define EPIT1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
+#define EPIT2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B0000)
+#define PWM1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B4000)
+#define PWM2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
+#define UART1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
+#define UART2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000C0000)
+#define CAN1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000C8000)
+#define CAN2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000CC000)
+#define SRC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D0000)
+#define CCM_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D4000)
+#define GPC_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000D8000)
+#define GPIO5_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000DC000)
+#define GPIO6_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E0000)
+#define GPIO7_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E4000)
+#define MX53_ATA_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000E8000)
+#define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000EC000)
+#define UART4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000F0000)
+#define RNGB_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000F8000) /* MX50 */
+
+#define DVFSCORE_BASE_ADDR 	(GPC_BASE_ADDR + 0x180)
+#define DVFSPER_BASE_ADDR 		(GPC_BASE_ADDR + 0x1C4)
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_IRAM         30
+#define MXC_DMA_CHANNEL_SPDIF_TX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SPDIF_RX        MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2		MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI2_TX  (MXC_DMA_CHANNEL_IRAM + 1)
+#else				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_SSI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#endif				/*CONFIG_SDMA_IRAM */
+#define MXC_DMA_CHANNEL_CSPI1_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCC_ESAI MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI1_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI1_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI2_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCA_SSI2_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI1_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI1_TX1 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI2_TX0 MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ASRCB_SSI2_TX1 MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR	0x83F00000
+#define AIPS2_BASE_ADDR_VIRT	0xF7D00000
+#define AIPS2_SIZE		SZ_1M
+
+#define PLL1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define PLL2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
+#define PLL3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00088000)
+#define PLL4_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
+#define UART5_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00090000)
+#define AHBMAX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x00094000)
+#define IIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define CSU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0009C000)
+#define ARM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A0000)
+#define OWIRE_BASE_ADDR 	(AIPS2_BASE_ADDR + 0x000A4000)
+#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A8000)
+#define CSPI2_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000AC000)
+#define SDMA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B0000)
+#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B4000)
+#define ROMCP_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000B8000)
+#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000BC000)
+#define CSPI3_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
+#define I2C2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C4000)
+#define I2C1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000C8000)
+#define SSI1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D0000)
+#define RTC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D4000)
+#define M4IF_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define ESDCTL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000D9000)
+#define WEIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DA000)
+#define NFC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DB000)
+#define EMI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DBF00)
+#define MIPI_HSC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000DC000)
+#define MLB_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000)
+#define SSI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E8000)
+#define ATA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000) /* MX51 */
+#define SIM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E4000) /* MX51 */
+#define FEC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
+#define TVE_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F0000)
+#define VPU_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000F4000)
+#define SAHARA_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000F8000)
+#define PTP_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000FC000)
+
+/*
+ * Memory regions and CS
+ */
+#define GPU_CTRL_BASE_ADDR	0x30000000
+#define MX51_IPU_CTRL_BASE_ADDR	0x40000000
+#define MX53_IPU_CTRL_BASE_ADDR	0x18000000
+#define CSD0_BASE_ADDR		0x90000000
+#define CSD1_BASE_ADDR		0xA0000000
+#define CS0_BASE_ADDR		0xB0000000
+#define CS1_BASE_ADDR		0xB8000000
+#define CS2_BASE_ADDR		0xC0000000
+#define CS3_BASE_ADDR		0xC8000000
+#define CS4_BASE_ADDR		0xCC000000
+#define CS5_BASE_ADDR		0xCE000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(void __force __iomem *) \
+	((((x) >= (unsigned long)SPBA0_BASE_ADDR) && \
+	  ((x) < (unsigned long)SPBA0_BASE_ADDR + SPBA0_SIZE)) ? \
+	   SPBA0_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS1_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS1_BASE_ADDR + AIPS1_SIZE)) ? \
+	   AIPS1_IO_ADDRESS(x) : \
+	(((x) >= (unsigned long)AIPS2_BASE_ADDR) && \
+	  ((x) < (unsigned long)AIPS2_BASE_ADDR + AIPS2_SIZE)) ? \
+	   AIPS2_IO_ADDRESS(x) : \
+	0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define MX53_BASE_ADDR(x) (cpu_is_mx53() || cpu_is_mx50() ? (x) - 0x20000000 : (x))
+
+#define IS_MEM_DEVICE_NONSHARED(x)		0
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_SSI3_TX1				47
+#define DMA_REQ_SSI3_RX1				46
+#define DMA_REQ_SSI3_TX2_MX53			45
+#define DMA_REQ_SPDIF_MX51			45
+#define DMA_REQ_SSI3_RX2				44
+#define DMA_REQ_UART3_TX_MX53		43
+#define DMA_REQ_UART3_RX_MX53		42
+#define DMA_REQ_SLIM_B_TX				42 /* MX51 */
+#define DMA_REQ_UART3_TX_MX51		44
+#define DMA_REQ_UART3_RX_MX51		43
+#define DMA_REQ_UART3_TX_MX50		43
+#define DMA_REQ_UART3_RX_MX50		42
+#define DMA_REQ_ESAI_TX				41
+#define DMA_REQ_SDHC4_MX51			41
+#define DMA_REQ_ESAI_RX				40
+#define DMA_REQ_SDHC3					40 /* MX51 */
+#define DMA_REQ_CSPI_TX				39
+#define DMA_REQ_CSPI_RX				38
+#define DMA_REQ_ASRC_DMA6				37
+#define DMA_REQ_SSI3_TX2_MX51			37 /* MX51 */
+#define DMA_REQ_ASRC_DMA5				36
+#define DMA_REQ_IPU_MX51				36
+#define DMA_REQ_ASRC_DMA4				35
+#define DMA_REQ_ASRC_DMA3				34
+
+#define DMA_REQ_EPIT2					34 /* MX51 */
+#define DMA_REQ_CTI2_1					33 /* MX51 */
+#define DMA_REQ_EMI_WR_MX51			32
+#define DMA_REQ_EMI_WR_MX53			31
+#define DMA_REQ_CTI2_0					31
+
+#define DMA_REQ_ASRC_DMA2				33
+#define DMA_REQ_ASRC_DMA1				32
+#define DMA_REQ_EMI_RD					30
+#define DMA_REQ_SSI1_TX1				29
+#define DMA_REQ_SSI1_RX1				28
+#define DMA_REQ_SSI1_TX2				27
+#define DMA_REQ_SSI1_RX2				26
+#define DMA_REQ_SSI2_TX1				25
+#define DMA_REQ_SSI2_RX1				24
+#define DMA_REQ_SSI2_TX2				23
+#define DMA_REQ_SSI2_RX2				22
+/* I2C2 is shared w/SDHC2 on MX53 */
+#define DMA_REQ_SDHC2					21
+/* I2C1 is shared w/SDHC1 on MX53 */
+#define DMA_REQ_SDHC1					20
+#define DMA_REQ_UART1_TX				19
+#define DMA_REQ_UART1_RX				18
+
+#define DMA_REQ_UART2_TX				17 /* MX51 */
+#define DMA_REQ_UART2_RX				16 /* MX51 */
+#define DMA_REQ_GPU					15 /* MX51 */
+#define DMA_REQ_EXTREQ1				14 /* MX51 */
+
+#define DMA_REQ_UART5_TX				17
+#define DMA_REQ_UART5_RX				16
+#define DMA_REQ_SPDIF_TX				15
+#define DMA_REQ_SPDIF_RX				14
+#define DMA_REQ_EXTREQ0_MX50				14
+#define DMA_REQ_EXTREQ1_MX50				15
+/* UART2 is shared w/FIRI on MX53 */
+#define DMA_REQ_FIRI_TX					13
+#define DMA_REQ_FIRI_RX				12
+#define DMA_REQ_UART2_TX_MX50				13
+#define DMA_REQ_UART2_RX_MX50				12
+#define DMA_REQ_SDHC4_MX53			11
+
+#define DMA_REQ_HS_I2C_RX				11 /* MX51 */
+#define DMA_REQ_HS_I2C_TX				10 /* MX51 */
+/* SDHC3 is shared w/I2C3 on MX53 */
+#define DMA_REQ_I2C3					10
+#define DMA_REQ_HS_I2C_RX				11 /* MX51 */
+#define DMA_REQ_HS_I2C_TX				10 /* MX51 */
+#define DMA_REQ_CSPI2_TX				9
+#define DMA_REQ_CSPI2_RX				8
+#define DMA_REQ_CSPI1_TX				7
+#define DMA_REQ_CSPI1_RX				6
+#define DMA_REQ_IPU_MX53				5
+#define DMA_REQ_SLIM_B					5 /* MX51 */
+#define DMA_REQ_ATA_TX_END			4
+#define DMA_REQ_ATA_TX					3
+#define DMA_REQ_UART4_TX_MX50				3
+#define DMA_REQ_ATA_RX					2
+#define DMA_REQ_UART4_RX_MX50				2
+#define DMA_REQ_GPC					1
+#define DMA_REQ_VPU					0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE		0
+#define MXC_INT_RESV0		0
+#define MXC_INT_MMC_SDHC1	1
+#define MXC_INT_MMC_SDHC2	2
+#define MXC_INT_MMC_SDHC3	3
+#define MXC_INT_MMC_SDHC4	4
+#define MXC_INT_DAP		5
+#define MXC_INT_SDMA		6
+#define MXC_INT_IOMUX		7
+#define MXC_INT_NFC		8
+#define MXC_INT_VPU		9
+#define MXC_INT_IPU_ERR	10
+#define MXC_INT_IPU_SYN	11
+#define MXC_INT_GPU		12
+#define MXC_INT_UART4		13
+#define MXC_INT_USB_H1		14
+#define MXC_INT_EMI		15
+#define MXC_INT_USB_H2		16
+#define MXC_INT_USB_H3		17
+#define MXC_INT_USB_OTG	18
+#define MXC_INT_SAHARA_H0	19
+#define MXC_INT_DATABAHN	19 /* MX50 */
+#define MXC_INT_SAHARA_H1	20
+#define MXC_INT_ELCDIF		20 /* MX50 */
+#define MXC_INT_SCC_SMN	21
+#define MXC_INT_EPXP		21 /* MX50 */
+#define MXC_INT_SCC_STZ	22
+#define MXC_INT_SCC_SCM	23
+#define MXC_INT_SRTC_NTZ	24
+#define MXC_INT_SRTC_TZ	25
+#define MXC_INT_RTIC		26
+#define MXC_INT_CSU		27
+#define MXC_INT_EPDC		27 /* MX50 */
+#define MXC_INT_SATA		28
+#define MXC_INT_SLIM_B		28 /* MX51 */
+#define MXC_INT_NIC		28 /* MX50 Perfmon IRQ */
+#define MXC_INT_SSI1		29
+#define MXC_INT_SSI2		30
+#define MXC_INT_UART1		31
+#define MXC_INT_UART2		32
+#define MXC_INT_UART3		33
+#define MXC_INT_RTC			34
+#define MXC_INT_PTP			35
+#define MXC_INT_CSPI1		36
+#define MXC_INT_CSPI2		37
+#define MXC_INT_CSPI		38
+#define MXC_INT_GPT			39
+#define MXC_INT_EPIT1		40
+#define MXC_INT_EPIT2		41
+#define MXC_INT_GPIO1_INT7	42
+#define MXC_INT_GPIO1_INT6	43
+#define MXC_INT_GPIO1_INT5	44
+#define MXC_INT_GPIO1_INT4	45
+#define MXC_INT_GPIO1_INT3	46
+#define MXC_INT_GPIO1_INT2	47
+#define MXC_INT_GPIO1_INT1	48
+#define MXC_INT_GPIO1_INT0	49
+#define MXC_INT_GPIO1_LOW	50
+#define MXC_INT_GPIO1_HIGH	51
+#define MXC_INT_GPIO2_LOW	52
+#define MXC_INT_GPIO2_HIGH	53
+#define MXC_INT_GPIO3_LOW	54
+#define MXC_INT_GPIO3_HIGH	55
+#define MXC_INT_GPIO4_LOW	56
+#define MXC_INT_GPIO4_HIGH	57
+#define MXC_INT_WDOG1		58
+#define MXC_INT_WDOG2		59
+#define MXC_INT_KPP		60
+#define MXC_INT_PWM1		61
+#define MXC_INT_I2C1		62
+#define MXC_INT_I2C2		63
+#define MXC_INT_I2C3		64
+#define MXC_INT_HS_I2C		64 /* MX51 */
+#define MXC_INT_MLB		65
+#define MXC_INT_ASRC		66
+#define MXC_INT_SPDIF_MX53	67
+#define MXC_INT_SIM_IPB		67
+#define MXC_INT_SIM_DAT		68
+#define MXC_INT_IIM		69
+#define MXC_INT_ANATOP1		66 /* MX50 what's it? */
+#define MXC_INT_ANATOP2		67
+#define MXC_INT_ANATOP3		68
+#define MXC_INT_ANATOP4		69
+#define MXC_INT_ATA		70
+#define MXC_INT_CCM1		71
+#define MXC_INT_CCM2		72
+#define MXC_INT_GPC1		73
+#define MXC_INT_GPC2		74
+#define MXC_INT_SRC		75
+#define MXC_INT_NM		76
+#define MXC_INT_PMU		77
+#define MXC_INT_CTI_IRQ		78
+#define MXC_INT_CTI1_TG0	79
+#define MXC_INT_CTI1_TG1	80
+#define MXC_INT_ESAI		81
+#define MXC_INT_CAN1		82
+#define MXC_INT_CAN2		83
+#define MXC_INT_MCG_ERR		81 /* MX51 */
+#define MXC_INT_MCG_TMR		82 /* MX51 */
+#define MXC_INT_MCG_FUNC		83 /* MX51 */
+#define MXC_INT_GPU2_IRQ	84
+#define MXC_INT_GPU2_BUSY	85
+#define MXC_INT_UART5		86
+#define MXC_INT_FEC		87
+#define MXC_INT_OWIRE		88
+#define MXC_INT_CTI1_TG2	89
+#define MXC_INT_SJC		90
+#define MXC_INT_SPDIF_MX51		91
+#define MXC_INT_DCP_CHAN1_3	91 /* MX50 */
+#define MXC_INT_TVE		92
+#define MXC_INT_DCP_CHAN0	92 /* MX50 */
+#define MXC_INT_FIRI		93
+#define MXC_INT_DCP_CHAN0_3_SEC	93 /* MX50 */
+#define MXC_INT_PWM2		94
+#define MXC_INT_SLIM_EXP		95
+#define MXC_INT_SSI3		96
+#define MXC_INT_EMI_BOOT		97
+#define MXC_INT_RNGB_BLOCK	97 /* MX50 */
+#define MXC_INT_CTI1_TG3	98
+#define MXC_INT_SMC_RX			99
+#define MXC_INT_VPU_IDLE	100
+#define MXC_INT_RAWNAND_BCH	100 /* MX50 */
+#define MXC_INT_EMI_NFC	101
+#define MXC_INT_GPU_IDLE	102
+#define MXC_INT_RAWNAND_GPMI	102 /* MX50 */
+#define MXC_INT_GPIO5_LOW	103
+#define MXC_INT_GPIO5_HIGH	104
+#define MXC_INT_GPIO6_LOW	105
+#define MXC_INT_GPIO6_HIGH	106
+#define MXC_INT_GPIO7_LOW	107
+#define MXC_INT_GPIO7_HIGH	108
+#define MXC_INT_MSHC		109 /* MX50 */
+#define MXC_INT_APBHDMA_CHAN0	110
+#define MXC_INT_APBHDMA_CHAN1	111
+#define MXC_INT_APBHDMA_CHAN2	112
+#define MXC_INT_APBHDMA_CHAN3	113
+#define MXC_INT_APBHDMA_CHAN4	114
+#define MXC_INT_APBHDMA_CHAN5	115
+#define MXC_INT_APBHDMA_CHAN6	116
+#define MXC_INT_APBHDMA_CHAN7	117
+#define MXC_INT_APBHDMA_CHAN8	118
+#define MXC_INT_APBHDMA_CHAN9	119
+#define MXC_INT_APBHDMA_CHAN10	120
+#define MXC_INT_APBHDMA_CHAN11	121
+#define MXC_INT_APBHDMA_CHAN12	122
+#define MXC_INT_APBHDMA_CHAN13	123
+#define MXC_INT_APBHDMA_CHAN14	124
+#define MXC_INT_APBHDMA_CHAN15	125
+
+#endif				/*  __ASM_ARCH_MXC_MX5X_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index a8ce41d..e1571ea 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -32,6 +32,7 @@
 #define MXC_CPU_MX32		32
 #define MXC_CPU_MX35		35
 #define MXC_CPU_MX37		37
+#define MXC_CPU_MX50		50
 #define MXC_CPU_MX51		51
 #define MXC_CPU_MX53		53
 #define MXC_CPU_MXC91231	91231
@@ -160,6 +161,18 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mxc91231()	(0)
 #endif
 
+#ifdef CONFIG_ARCH_MX50
+# ifdef mxc_cpu_type
+#  undef mxc_cpu_type
+#  define mxc_cpu_type __mxc_cpu_type
+# else
+#  define mxc_cpu_type MXC_CPU_MX50
+# endif
+# define cpu_is_mx50()		(mxc_cpu_type == MXC_CPU_MX50)
+#else
+# define cpu_is_mx50()		(0)
+#endif
+
 #define cpu_is_mx32()		(0)
 
 /*
@@ -603,6 +616,12 @@ struct mxc_sim_platform_data {
 #define DPTC_GP_ID 0
 #define DPTC_LP_ID 1
 
+#define MUX_IO_P		29
+#define MUX_IO_I		24
+#define IOMUX_TO_GPIO(pin) 	((((unsigned int)pin >> MUX_IO_P) * 32) + ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) - 1)))
+#define IOMUX_TO_IRQ(pin)	(MXC_GPIO_IRQ_START + IOMUX_TO_GPIO(pin))
+
+
 #ifndef __ASSEMBLY__
 
 struct cpu_wp {
@@ -648,7 +667,7 @@ void gpio_deactivate_esai_ports(void);
 #define CSCR_A(n) (IO_ADDRESS(WEIM_BASE_ADDR + n * 0x10 + 0x8))
 #endif
 
-#define cpu_is_mx5()	(cpu_is_mx51() || cpu_is_mx53())
+#define cpu_is_mx5()	(cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx50())
 #define cpu_is_mx3()	(cpu_is_mx31() || cpu_is_mx35() || cpu_is_mxc91231())
 #define cpu_is_mx2()	(cpu_is_mx21() || cpu_is_mx27())
 
diff --git a/arch/arm/plat-mxc/system.c b/arch/arm/plat-mxc/system.c
index 97f4279..65e945a 100644
--- a/arch/arm/plat-mxc/system.c
+++ b/arch/arm/plat-mxc/system.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1999 ARM Limited
  * Copyright (C) 2000 Deep Blue Solutions Ltd
- * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2006-2010 Freescale Semiconductor
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  * Copyright 2009 Ilya Yanok, Emcraft Systems Ltd, yanok@emcraft.com
  *
@@ -46,6 +46,15 @@ void arch_reset(char mode, const char *cmd)
 		return;
 	}
 #endif
+
+#ifdef CONFIG_ARCH_MX51
+	/* Workaround to reset NFC_CONFIG3 register
+	 * due to the chip warm reset does not reset it
+	 */
+	 if (cpu_is_mx51() || cpu_is_mx53())
+		__raw_writel(0x20600, IO_ADDRESS(NFC_BASE_ADDR) + 0x28);
+#endif
+
 	if (cpu_is_mx1()) {
 		wcr_enable = (1 << 0);
 	} else {
diff --git a/arch/arm/plat-mxc/tzic.c b/arch/arm/plat-mxc/tzic.c
index 16b5aab..857cc0c 100644
--- a/arch/arm/plat-mxc/tzic.c
+++ b/arch/arm/plat-mxc/tzic.c
@@ -14,11 +14,10 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/errno.h>
+#include <mach/hardware.h>
 #include <linux/io.h>
-
+#include <asm/irq.h>
 #include <asm/mach/irq.h>
-
-#include <mach/hardware.h>
 #include <mach/common.h>
 
 /*
@@ -26,39 +25,41 @@
  * TZIC Registers                        *
  *****************************************
  */
-
-#define TZIC_INTCNTL	0x0000	/* Control register */
-#define TZIC_INTTYPE	0x0004	/* Controller Type register */
-#define TZIC_IMPID	0x0008	/* Distributor Implementer Identification */
-#define TZIC_PRIOMASK	0x000C	/* Priority Mask Reg */
-#define TZIC_SYNCCTRL	0x0010	/* Synchronizer Control register */
-#define TZIC_DSMINT	0x0014	/* DSM interrupt Holdoffregister */
-#define TZIC_INTSEC0(i)	(0x0080 + ((i) << 2)) /* Interrupt Security Reg 0 */
-#define TZIC_ENSET0(i)	(0x0100 + ((i) << 2)) /* Enable Set Reg 0 */
-#define TZIC_ENCLEAR0(i) (0x0180 + ((i) << 2)) /* Enable Clear Reg 0 */
-#define TZIC_SRCSET0	0x0200	/* Source Set Register 0 */
-#define TZIC_SRCCLAR0	0x0280	/* Source Clear Register 0 */
-#define TZIC_PRIORITY0	0x0400	/* Priority Register 0 */
-#define TZIC_PND0	0x0D00	/* Pending Register 0 */
-#define TZIC_HIPND0	0x0D80	/* High Priority Pending Register */
-#define TZIC_WAKEUP0(i)	(0x0E00 + ((i) << 2))	/* Wakeup Config Register */
-#define TZIC_SWINT	0x0F00	/* Software Interrupt Rigger Register */
-#define TZIC_ID0	0x0FD0	/* Indentification Register 0 */
-
-void __iomem *tzic_base; /* Used as irq controller base in entry-macro.S */
+void __iomem *tzic_base;
+
+#define TZIC_BASE		(tzic_base)
+#define TZIC_INTCNTL            (TZIC_BASE + 0x0000)	/* control register */
+#define TZIC_INTTYPE            (TZIC_BASE + 0x0004)	/* Controller type register */
+#define TZIC_IMPID              (TZIC_BASE + 0x0008)	/* Distributor Implementer Identification Register */
+#define TZIC_PRIOMASK           (TZIC_BASE + 0x000C)	/* Priority Mask Reg */
+#define TZIC_SYNCCTRL           (TZIC_BASE + 0x0010)	/* Synchronizer Control register */
+#define TZIC_DSMINT             (TZIC_BASE + 0x0014)	/* DSM interrupt Holdoffregister */
+#define TZIC_INTSEC0            (TZIC_BASE + 0x0080)	/* interrupt security register 0 */
+#define TZIC_ENSET0             (TZIC_BASE + 0x0100)	/* Enable Set Register 0 */
+#define TZIC_ENCLEAR0		(TZIC_BASE + 0x0180)	/* Enable Clear Register 0 */
+#define TZIC_SRCSET0            (TZIC_BASE + 0x0200)	/* Source Set Register 0 */
+#define TZIC_SRCCLAR0           (TZIC_BASE + 0x0280)	/* Source Clear Register 0 */
+#define TZIC_PRIORITY0          (TZIC_BASE + 0x0400)	/* Priority Register 0 */
+#define TZIC_PND0               (TZIC_BASE + 0x0D00)	/* Pending Register 0 */
+#define TZIC_HIPND0             (TZIC_BASE + 0x0D80)	/* High Priority Pending Register */
+#define TZIC_WAKEUP0            (TZIC_BASE + 0x0E00)	/* Wakeup Config Register */
+#define TZIC_SWINT              (TZIC_BASE + 0x0F00)	/* Software Interrupt Rigger Register */
+#define TZIC_ID0                (TZIC_BASE + 0x0FD0)	/* Indentification Register 0 */
+
+#define TZIC_NUM_IRQS		128
 
 /**
  * tzic_mask_irq() - Disable interrupt number "irq" in the TZIC
  *
  * @param  irq          interrupt source number
  */
-static void tzic_mask_irq(unsigned int irq)
+static void mxc_mask_irq(unsigned int irq)
 {
 	int index, off;
 
 	index = irq >> 5;
 	off = irq & 0x1F;
-	__raw_writel(1 << off, tzic_base + TZIC_ENCLEAR0(index));
+	__raw_writel(1 << off, TZIC_ENCLEAR0 + (index << 2));
 }
 
 /**
@@ -66,13 +67,13 @@ static void tzic_mask_irq(unsigned int irq)
  *
  * @param  irq          interrupt source number
  */
-static void tzic_unmask_irq(unsigned int irq)
+static void mxc_unmask_irq(unsigned int irq)
 {
 	int index, off;
 
 	index = irq >> 5;
 	off = irq & 0x1F;
-	__raw_writel(1 << off, tzic_base + TZIC_ENSET0(index));
+	__raw_writel(1 << off, TZIC_ENSET0 + (index << 2));
 }
 
 static unsigned int wakeup_intr[4];
@@ -86,7 +87,7 @@ static unsigned int wakeup_intr[4];
  *
  * @return       This function returns 0 on success.
  */
-static int tzic_set_wake_irq(unsigned int irq, unsigned int enable)
+static int mxc_set_wake_irq(unsigned int irq, unsigned int enable)
 {
 	unsigned int index, off;
 
@@ -106,54 +107,58 @@ static int tzic_set_wake_irq(unsigned int irq, unsigned int enable)
 
 static struct irq_chip mxc_tzic_chip = {
 	.name = "MXC_TZIC",
-	.ack = tzic_mask_irq,
-	.mask = tzic_mask_irq,
-	.unmask = tzic_unmask_irq,
-	.set_wake = tzic_set_wake_irq,
+	.ack = mxc_mask_irq,
+	.mask = mxc_mask_irq,
+	.unmask = mxc_unmask_irq,
+	.set_wake = mxc_set_wake_irq,
 };
 
-/*
+/*!
  * This function initializes the TZIC hardware and disables all the
  * interrupts. It registers the interrupt enable and disable functions
  * to the kernel for each interrupt source.
  */
-void __init tzic_init_irq(void __iomem *irqbase)
+void __init mxc_tzic_init_irq(unsigned long base)
 {
 	int i;
 
-	tzic_base = irqbase;
+	tzic_base = ioremap(base, SZ_4K);
+
 	/* put the TZIC into the reset value with
 	 * all interrupts disabled
 	 */
-	i = __raw_readl(tzic_base + TZIC_INTCNTL);
-
-	__raw_writel(0x80010001, tzic_base + TZIC_INTCNTL);
-	__raw_writel(0x1f, tzic_base + TZIC_PRIOMASK);
-	__raw_writel(0x02, tzic_base + TZIC_SYNCCTRL);
-
-	for (i = 0; i < 4; i++)
-		__raw_writel(0xFFFFFFFF, tzic_base + TZIC_INTSEC0(i));
-
+	i = __raw_readl(TZIC_INTCNTL);
+
+	__raw_writel(0x80010001, TZIC_INTCNTL);
+	i = __raw_readl(TZIC_INTCNTL);
+	__raw_writel(0x1f, TZIC_PRIOMASK);
+	i = __raw_readl(TZIC_PRIOMASK);
+	__raw_writel(0x02, TZIC_SYNCCTRL);
+	i = __raw_readl(TZIC_SYNCCTRL);
+	for (i = 0; i < 4; i++) {
+		__raw_writel(0xFFFFFFFF, TZIC_INTSEC0 + i * 4);
+	}
 	/* disable all interrupts */
-	for (i = 0; i < 4; i++)
-		__raw_writel(0xFFFFFFFF, tzic_base + TZIC_ENCLEAR0(i));
+	for (i = 0; i < 4; i++) {
+		__raw_writel(0xFFFFFFFF, TZIC_ENCLEAR0 + i * 4);
+	}
 
 	/* all IRQ no FIQ Warning :: No selection */
 
-	for (i = 0; i < MXC_INTERNAL_IRQS; i++) {
+	for (i = 0; i < TZIC_NUM_IRQS; i++) {
 		set_irq_chip(i, &mxc_tzic_chip);
 		set_irq_handler(i, handle_level_irq);
 		set_irq_flags(i, IRQF_VALID);
 	}
 	mxc_register_gpios();
 
-	pr_info("TrustZone Interrupt Controller (TZIC) initialized\n");
+	printk(KERN_INFO "MXC IRQ initialized\n");
 }
 
-/**
- * tzic_enable_wake() - enable wakeup interrupt
+/*!
+ * enable wakeup interrupt
  *
- * @param is_idle		1 if called in idle loop (ENSET0 register);
+ * @param is_idle		1 if called in idle loop (enset registers);
  *				0 to be used when called from low power entry
  * @return			0 if successful; non-zero otherwise
  */
@@ -161,14 +166,20 @@ int tzic_enable_wake(int is_idle)
 {
 	unsigned int i, v;
 
-	__raw_writel(1, tzic_base + TZIC_DSMINT);
-	if (unlikely(__raw_readl(tzic_base + TZIC_DSMINT) == 0))
+	__raw_writel(1, TZIC_DSMINT);
+	if (unlikely(__raw_readl(TZIC_DSMINT) == 0))
 		return -EAGAIN;
 
+	if (likely(is_idle)) {
+		for (i = 0; i < 4; i++) {
+			v = __raw_readl(TZIC_ENSET0 + i * 4);
+			__raw_writel(v, TZIC_WAKEUP0 + i * 4);
+		}
+	} else {
 	for (i = 0; i < 4; i++) {
-		v = is_idle ? __raw_readl(tzic_base + TZIC_ENSET0(i)) : wakeup_intr[i];
-		__raw_writel(v, tzic_base + TZIC_WAKEUP0(i));
+			v = wakeup_intr[i];
+			__raw_writel(v, TZIC_WAKEUP0 + i * 4);
+		}
 	}
-
 	return 0;
 }
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index 9644387..0a94d72 100644
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -277,21 +277,25 @@ static void usbh1_set_utmi_xcvr(void)
 	while ((UH1_USBCMD) & (UCMD_RESET))
 		;
 
-	/* MX53 EVK is not using OC */
-	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS;
-
-	USBCTRL &= ~UCTRL_H1PM;	/* OTG Power Mask */
-	USBCTRL &= ~UCTRL_H1WIE;	/* OTG Wakeup Intr Disable */
-
-	/* Over current disable */
-	USB_PHY_CTR_FUNC |= (0x1 << 5);
-
+	/* For OC and PWR, it is board level setting
+	 * The default setting is for mx53 evk
+	 */
+	USBCTRL &= ~UCTRL_H1PM;	/* Host1 Power Mask */
+	USBCTRL &= ~UCTRL_H1WIE; /* Host1 Wakeup Intr Disable */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* Over current disable */
+
+	if (machine_is_mx50_arm2()) {
+		USBCTRL |= UCTRL_H1PM; /* Host1 Power Mask */
+		USB_PHY_CTR_FUNC &= ~USB_UH1_OC_DIS; /* Over current enable */
+		/* Over current polarity low active */
+		USB_PHY_CTR_FUNC |= USB_UH1_OC_POL;
+	}
 	/* set UTMI xcvr */
 	tmp = UH1_PORTSC1 & ~PORTSC_PTS_MASK;
 	tmp |= PORTSC_PTS_UTMI;
 	UH1_PORTSC1 = tmp;
 
-	/* Set the PHY clock to 19.2MHz */
+	/* Set the PHY clock to 24MHz */
 	USBH1_PHY_CTRL1 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
 	USBH1_PHY_CTRL1 |= 0x01;
 
@@ -484,6 +488,10 @@ int fsl_usb_host_init(struct platform_device *pdev)
 		clk_put(usboh3_clk);
 	}
 
+	if (cpu_is_mx50())
+		/* Turn on AHB CLK for H1*/
+		USB_CLKONOFF_CTRL &= ~H1_AHBCLK_OFF;
+
 	/* enable board power supply for xcvr */
 	if (pdata->xcvr_pwr) {
 		if (pdata->xcvr_pwr->regu1)
@@ -705,6 +713,11 @@ static void otg_set_utmi_xcvr(void)
 	} else if (cpu_is_mx25()) {
 		USBCTRL |= UCTRL_OCPOL;
 		USBCTRL &= ~UCTRL_PP;
+	} else if (cpu_is_mx50()) {
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+		if (machine_is_mx50_arm2())
+			/* OTG Power pin polarity low */
+			USBCTRL |= UCTRL_O_PWR_POL;
 	} else {
 		/* USBOTG_PWR low active */
 		USBCTRL &= ~UCTRL_PP;
@@ -716,8 +729,9 @@ static void otg_set_utmi_xcvr(void)
 			USBCTRL |= UCTRL_OLOCKD;
 	}
 
-	if (!cpu_is_mx53())
+	if (cpu_is_mx51())
 		USBCTRL &= ~UCTRL_OPM;	/* OTG Power Mask */
+
 	USBCTRL &= ~UCTRL_OWIE;	/* OTG Wakeup Intr Disable */
 
 	/* set UTMI xcvr */
@@ -799,6 +813,9 @@ int usbotg_init(struct platform_device *pdev)
 	if (!mxc_otg_used) {
 		if (fsl_check_usbclk() != 0)
 			return -EINVAL;
+		if (cpu_is_mx50())
+			/* Turn on AHB CLK for OTG*/
+			USB_CLKONOFF_CTRL &= ~OTG_AHBCLK_OFF;
 
 		pr_debug("%s: grab pins\n", __func__);
 		if (pdata->gpio_usb_active && pdata->gpio_usb_active())
-- 
1.5.4.4

