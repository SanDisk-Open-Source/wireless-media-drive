From 0b2f25689644929e654f07182d54a9ae4a36e30a Mon Sep 17 00:00:00 2001
From: Niu Xule <b23300@freescale.com>
Date: Wed, 12 May 2010 15:47:41 +0800
Subject: [PATCH] ENGR00123078 L2 Switch support

L2 Switch support for mx28

Signed-off-by: Niu Xule <b23300@freescale.com>
---
 drivers/net/Kconfig      |    7 +
 drivers/net/Makefile     |    1 +
 drivers/net/fec_switch.c | 3340 ++++++++++++++++++++++++++++++++++++++++++++++
 drivers/net/fec_switch.h |  989 ++++++++++++++
 4 files changed, 4337 insertions(+), 0 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2177842..aaae8b1 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1938,6 +1938,13 @@ config IN_BAND
 
 endchoice
 
+config FEC_L2SWITCH
+	bool "L2 Switch Ethernet Controller (of ColdFire CPUs)"
+	depends on ARCH_MX28 && !FEC
+	help
+	  Say Y here if you want to use the built-in 10/100 Ethernet Switch
+	  Controller on some Motorola ColdFire processors.
+
 config FEC2
 	bool "Second FEC ethernet controller (on some ColdFire CPUs)"
 	depends on FEC
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index c290857..d2c9afd 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_HP100) += hp100.o
 obj-$(CONFIG_SMC9194) += smc9194.o
 obj-$(CONFIG_FEC) += fec.o
 obj-$(CONFIG_FEC_1588) += imx_ptp.o
+obj-$(CONFIG_FEC_L2SWITCH) += fec_switch.o
 obj-$(CONFIG_FEC_MPC52xx) += fec_mpc52xx.o
 ifeq ($(CONFIG_FEC_MPC52xx_MDIO),y)
 	obj-$(CONFIG_FEC_MPC52xx) += fec_mpc52xx_phy.o
diff --git a/drivers/net/fec_switch.c b/drivers/net/fec_switch.c
new file mode 100644
index 0000000..e58289c
--- /dev/null
+++ b/drivers/net/fec_switch.c
@@ -0,0 +1,3340 @@
+/*
+ *  L2 switch Controller (Etheren switch) driver for Mx28.
+ *
+ *  Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *    Shrek Wu (B16972@freescale.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/fec.h>
+#include <linux/phy.h>
+
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/pgtable.h>
+#include <asm/cacheflush.h>
+
+#include "fec_switch.h"
+
+#define	SWITCH_MAX_PORTS	1
+
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_ARCH_MXS)
+#include <mach/hardware.h>
+#define FEC_ALIGNMENT   0xf
+#else
+#define FEC_ALIGNMENT   0x3
+#endif
+
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it it best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#define FEC_ENET_RX_PAGES       8
+#define FEC_ENET_RX_FRSIZE      2048
+#define FEC_ENET_RX_FRPPG       (PAGE_SIZE / FEC_ENET_RX_FRSIZE)
+#define FEC_ENET_TX_FRSIZE      2048
+#define FEC_ENET_TX_FRPPG       (PAGE_SIZE / FEC_ENET_TX_FRSIZE)
+#define TX_RING_SIZE            16      /* Must be power of two */
+#define TX_RING_MOD_MASK        15      /*   for this to work */
+
+#if (((RX_RING_SIZE + TX_RING_SIZE) * 8) > PAGE_SIZE)
+#error "FEC: descriptor ring size constants too large"
+#endif
+
+/* Interrupt events/masks */
+#define FEC_ENET_HBERR	((uint)0x80000000)	/* Heartbeat error */
+#define FEC_ENET_BABR	((uint)0x40000000)	/* Babbling receiver */
+#define FEC_ENET_BABT	((uint)0x20000000)	/* Babbling transmitter */
+#define FEC_ENET_GRA	((uint)0x10000000)	/* Graceful stop complete */
+#define FEC_ENET_TXF	((uint)0x08000000)	/* Full frame transmitted */
+#define FEC_ENET_TXB	((uint)0x04000000)	/* A buffer was transmitted */
+#define FEC_ENET_RXF	((uint)0x02000000)	/* Full frame received */
+#define FEC_ENET_RXB	((uint)0x01000000)	/* A buffer was received */
+#define FEC_ENET_MII	((uint)0x00800000)	/* MII interrupt */
+#define FEC_ENET_EBERR	((uint)0x00400000)	/* SDMA bus error */
+
+/* FEC MII MMFR bits definition */
+#define FEC_MMFR_ST             (1 << 30)
+#define FEC_MMFR_OP_READ        (2 << 28)
+#define FEC_MMFR_OP_WRITE       (1 << 28)
+#define FEC_MMFR_PA(v)          ((v & 0x1f) << 23)
+#define FEC_MMFR_RA(v)          ((v & 0x1f) << 18)
+#define FEC_MMFR_TA             (2 << 16)
+#define FEC_MMFR_DATA(v)        (v & 0xffff)
+
+#ifdef FEC_PHY
+static struct phy_device *g_phy_dev;
+static struct mii_bus *fec_mii_bus;
+#endif
+
+static int switch_enet_open(struct net_device *dev);
+static int switch_enet_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static irqreturn_t switch_enet_interrupt(int irq, void *dev_id);
+static void switch_enet_tx(struct net_device *dev);
+static void switch_enet_rx(struct net_device *dev);
+static int switch_enet_close(struct net_device *dev);
+static void set_multicast_list(struct net_device *dev);
+static void switch_restart(struct net_device *dev, int duplex);
+static void switch_stop(struct net_device *dev);
+static int switch_set_mac_address(struct net_device *dev, void *addr);
+
+#define		NMII	20
+
+/* Make MII read/write commands for the FEC */
+#define mk_mii_read(REG)	(0x60020000 | ((REG & 0x1f) << 18))
+#define mk_mii_write(REG, VAL)	(0x50020000 | ((REG & 0x1f) << 18) | \
+						(VAL & 0xffff))
+
+/* Transmitter timeout */
+#define TX_TIMEOUT (2*HZ)
+#define FEC_MII_TIMEOUT	10
+
+#ifdef CONFIG_ARCH_MXS
+static void *swap_buffer(void *bufaddr, int len)
+{
+	int i;
+	unsigned int *buf = bufaddr;
+
+	for (i = 0; i < (len + 3) / 4; i++, buf++)
+		*buf = __swab32(*buf);
+		return bufaddr;
+}
+#endif
+
+/*last read entry from learning interface*/
+struct eswPortInfo g_info;
+
+static unsigned char    switch_mac_default[] = {
+	0x00, 0x04, 0x9F, 0x00, 0xB3, 0x49,
+};
+
+static void switch_request_intrs(struct net_device *dev,
+	irqreturn_t switch_net_irq_handler(int irq, void *private),
+	void *irq_privatedata)
+{
+	struct switch_enet_private *fep;
+
+	fep = netdev_priv(dev);
+
+	/* Setup interrupt handlers */
+	if (request_irq(dev->irq,
+		switch_net_irq_handler, IRQF_DISABLED,
+		"mxs-l2switch", irq_privatedata) != 0)
+		printk(KERN_ERR "FEC: Could not alloc %s IRQ(%d)!\n",
+			dev->name, dev->irq);
+}
+
+static void switch_set_mii(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	struct switch_t *fecp;
+
+	fecp = (struct switch_t *)fep->hwp;
+
+	writel(MCF_FEC_RCR_PROM | MCF_FEC_RCR_RMII_MODE |
+			MCF_FEC_RCR_MAX_FL(1522) | MCF_FEC_RCR_CRC_FWD,
+			fep->enet_addr + MCF_FEC_RCR0);
+	writel(MCF_FEC_RCR_PROM | MCF_FEC_RCR_RMII_MODE |
+			MCF_FEC_RCR_MAX_FL(1522) | MCF_FEC_RCR_CRC_FWD,
+			fep->enet_addr + MCF_FEC_RCR1);
+	/* TCR */
+	writel(MCF_FEC_TCR_FDEN, fep->enet_addr + MCF_FEC_TCR0);
+	writel(MCF_FEC_TCR_FDEN, fep->enet_addr + MCF_FEC_TCR1);
+
+	/* ECR */
+#ifdef MODELO_ENHANCE_BUFFER
+	writel(MCF_FEC_ECR_ETHER_EN | MCF_FEC_ECR_ENA_1588,
+			fep->enet_addr + MCF_FEC_ECR0);
+	writel(MCF_FEC_ECR_ETHER_EN | MCF_FEC_ECR_ENA_1588,
+			fep->enet_addr + MCF_FEC_ECR1);
+#else /*legac buffer*/
+	writel(MCF_FEC_ECR_ETHER_EN, fep->enet_addr + MCF_FEC_ECR0);
+	writel(MCF_FEC_ECR_ETHER_EN, fep->enet_addr + MCF_FEC_ECR1);
+#endif
+	writel(FEC_ENET_TXF | FEC_ENET_RXF, fep->enet_addr + MCF_FEC_EIMR0);
+	writel(FEC_ENET_TXF | FEC_ENET_RXF, fep->enet_addr + MCF_FEC_EIMR1);
+
+	/*
+	* Set MII speed to 2.5 MHz
+	*/
+	writel(DIV_ROUND_UP(clk_get_rate(fep->clk), 5000000) << 1,
+			fep->enet_addr + MCF_FEC_MSCR0);
+	writel(DIV_ROUND_UP(clk_get_rate(fep->clk), 5000000) << 1,
+			fep->enet_addr + MCF_FEC_MSCR1);
+
+#ifdef CONFIG_ARCH_MXS
+	/* Can't get phy(8720) ID when set to 2.5M on MX28, lower it*/
+	writel((readl(fep->enet_addr + MCF_FEC_MSCR0) << 2),
+			fep->enet_addr + MCF_FEC_MSCR0);
+	writel((readl(fep->enet_addr + MCF_FEC_MSCR0) << 2),
+			fep->enet_addr + MCF_FEC_MSCR1);
+#endif
+
+}
+
+static void switch_get_mac(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	unsigned char *iap, tmpaddr[ETH_ALEN];
+	static int index;
+
+#ifdef CONFIG_M5272
+	if (FEC_FLASHMAC) {
+		/*
+		 * Get MAC address from FLASH.
+		 * If it is all 1's or 0's, use the default.
+		 */
+		iap = (unsigned char *)FEC_FLASHMAC;
+		if ((iap[0] == 0) && (iap[1] == 0) && (iap[2] == 0) &&
+		    (iap[3] == 0) && (iap[4] == 0) && (iap[5] == 0))
+			iap = switch_mac_default;
+		if ((iap[0] == 0xff) && (iap[1] == 0xff) && (iap[2] == 0xff) &&
+		    (iap[3] == 0xff) && (iap[4] == 0xff) && (iap[5] == 0xff))
+			iap = switch_mac_default;
+	}
+#else
+	if (is_valid_ether_addr(switch_mac_default))
+		iap = switch_mac_default;
+#endif
+	else {
+		*((unsigned long *) &tmpaddr[0]) =
+			be32_to_cpu(readl(fep->enet_addr
+			+ FEC_ADDR_LOW / sizeof(unsigned long)));
+		*((unsigned short *) &tmpaddr[4]) =
+			be16_to_cpu(readl(fep->enet_addr
+			+ FEC_ADDR_HIGH / sizeof(unsigned long)) >> 16);
+		iap = &tmpaddr[0];
+	}
+
+	memcpy(dev->dev_addr, iap, ETH_ALEN);
+
+	/* Adjust MAC if using default MAC address */
+	if (iap == switch_mac_default) {
+		dev->dev_addr[ETH_ALEN-1] =
+			switch_mac_default[ETH_ALEN-1] + index;
+		index++;
+	}
+}
+
+static void switch_enable_phy_intr(void)
+{
+}
+
+static void switch_disable_phy_intr(void)
+{
+}
+
+static void switch_phy_ack_intr(void)
+{
+}
+
+static void switch_localhw_setup(void)
+{
+}
+
+static void switch_uncache(unsigned long addr)
+{
+}
+
+static void switch_platform_flush_cache(void)
+{
+}
+
+/*
+ * Calculate Galois Field Arithmetic CRC for Polynom x^8+x^2+x+1.
+ * It omits the final shift in of 8 zeroes a "normal" CRC would do
+ * (getting the remainder).
+ *
+ *  Examples (hexadecimal values):<br>
+ *   10-11-12-13-14-15  => CRC=0xc2
+ *   10-11-cc-dd-ee-00  => CRC=0xe6
+ *
+ *   param: pmacaddress
+ *          A 6-byte array with the MAC address.
+ *          The first byte is the first byte transmitted
+ *   return The 8-bit CRC in bits 7:0
+ */
+int crc8_calc(unsigned char *pmacaddress)
+{
+	/* byte index */
+	int byt;
+	/* bit index */
+	int bit;
+	int inval;
+	int crc;
+	/* preset */
+	crc   = 0x12;
+	for (byt = 0; byt < 6; byt++) {
+		inval = (((int)pmacaddress[byt]) & 0xff);
+		/*
+		 * shift bit 0 to bit 8 so all our bits
+		 * travel through bit 8
+		 * (simplifies below calc)
+		 */
+		inval <<= 8;
+
+		for (bit = 0; bit < 8; bit++) {
+			/* next input bit comes into d7 after shift */
+			crc |= inval & 0x100;
+			if (crc & 0x01)
+				/* before shift  */
+				crc ^= 0x1c0;
+
+			crc >>= 1;
+			inval >>= 1;
+		}
+
+	}
+	/* upper bits are clean as we shifted in zeroes! */
+	return crc;
+}
+
+void read_atable(struct switch_enet_private *fep,
+	int index,
+	unsigned long *read_lo, unsigned long *read_hi)
+{
+	unsigned long atable_base = (unsigned long)fep->hwentry;
+
+	*read_lo = readl(atable_base + (index<<3));
+	*read_hi = readl(atable_base + (index<<3) + 4);
+}
+
+void write_atable(struct switch_enet_private *fep,
+	int index,
+	unsigned long write_lo, unsigned long write_hi)
+{
+	unsigned long atable_base = (unsigned long)fep->hwentry;
+
+	writel(write_lo, atable_base + (index<<3));
+	writel(write_hi, atable_base + (index<<3) + 4);
+}
+
+/*
+ * Check if the Port Info FIFO has data available
+ * for reading. 1 valid, 0 invalid
+ */
+int esw_portinfofifo_status(struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+	fecp = fep->hwp;
+	return fecp->ESW_LSR;
+}
+
+/* Initialize the Port Info FIFO */
+void esw_portinfofifo_initialize(
+	struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp;
+	fecp = fep->hwp;
+
+	/*disable all learn*/
+	fecp->switch_imask &= (~MCF_ESW_IMR_LRN);
+	/* remove all entries from FIFO */
+	while (esw_portinfofifo_status(fep)) {
+		/* read one data word */
+		tmp = fecp->ESW_LREC0;
+		tmp = fecp->ESW_LREC1;
+	}
+
+}
+
+/* Read one element from the HW receive FIFO (Queue)
+ * if available and return it.
+ * return ms_HwPortInfo or null if no data is available
+ */
+struct eswPortInfo *esw_portinfofifo_read(
+	struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp;
+
+	fecp = fep->hwp;
+	if (fecp->ESW_LSR == 0) {
+		printk(KERN_ERR "%s: ESW_LSR = %lx\n",
+			__func__, fecp->ESW_LSR);
+		return NULL;
+	}
+	/* read word from FIFO */
+	g_info.maclo = fecp->ESW_LREC0;
+	/* but verify that we actually did so
+	 * (0=no data available)
+	 */
+	if (g_info.maclo == 0) {
+		printk(KERN_ERR "%s: mac lo %x\n",
+			__func__, g_info.maclo);
+		return NULL;
+	}
+	/* read 2nd word from FIFO */
+	tmp = fecp->ESW_LREC1;
+	g_info.machi = tmp & 0xffff;
+	g_info.hash  = (tmp >> 16) & 0xff;
+	g_info.port  = (tmp >> 24) & 0xf;
+
+	return &g_info;
+}
+
+
+/*
+ * Clear complete MAC Look Up Table
+ */
+void esw_clear_atable(struct switch_enet_private *fep)
+{
+	int index;
+	for (index = 0; index < 2048; index++)
+		write_atable(fep, index, 0, 0);
+}
+
+void esw_dump_atable(struct switch_enet_private *fep)
+{
+	int index;
+	unsigned long read_lo, read_hi;
+	for (index = 0; index < 2048; index++) {
+		read_atable(fep, index, &read_lo, &read_hi);
+		printk(KERN_ERR "%s: index %d, lo %lu hi %lu\n",
+			__func__, index, read_lo, read_hi);
+	}
+
+}
+
+/*
+ * pdates MAC address lookup table with a static entry
+ * Searches if the MAC address is already there in the block and replaces
+ * the older entry with new one. If MAC address is not there then puts a
+ * new entry in the first empty slot available in the block
+ *
+ * mac_addr Pointer to the array containing MAC address to
+ *          be put as static entry
+ * port     Port bitmask numbers to be added in static entry,
+ *          valid values are 1-7
+ * priority Priority for the static entry in table
+ *
+ * return 0 for a successful update else -1  when no slot available
+ */
+int esw_update_atable_static(unsigned char *mac_addr,
+	unsigned int port, unsigned int priority,
+	struct switch_enet_private *fep)
+{
+	unsigned long block_index, entry, index_end;
+
+	unsigned long read_lo, read_hi;
+	unsigned long write_lo, write_hi;
+
+	write_lo = (unsigned long)((mac_addr[3] << 24) |
+			(mac_addr[2] << 16) |
+			(mac_addr[1] << 8) |
+			mac_addr[0]);
+	write_hi = (unsigned long)(0 |
+			(port << AT_SENTRY_PORTMASK_shift) |
+			(priority << AT_SENTRY_PRIO_shift) |
+			(AT_ENTRY_TYPE_STATIC << AT_ENTRY_TYPE_shift) |
+			(AT_ENTRY_RECORD_VALID << AT_ENTRY_VALID_shift) |
+			(mac_addr[5] << 8) | (mac_addr[4]));
+
+	block_index = GET_BLOCK_PTR(crc8_calc(mac_addr));
+	index_end = block_index + ATABLE_ENTRY_PER_SLOT;
+	/* Now search all the entries in the selected block */
+	for (entry = block_index; entry < index_end; entry++) {
+		read_atable(fep, entry, &read_lo, &read_hi);
+		/*
+		 * MAC address matched, so update the
+		 * existing entry
+		 * even if its a dynamic one
+		 */
+		if ((read_lo == write_lo) &&
+			((read_hi & 0x0000ffff) ==
+			 (write_hi & 0x0000ffff))) {
+			write_atable(fep, entry, write_lo, write_hi);
+			return 0;
+		} else if (!(read_hi & (1 << 16))) {
+			/*
+			 * Fill this empty slot (valid bit zero),
+			 * assuming no holes in the block
+			 */
+			write_atable(fep, entry, write_lo, write_hi);
+			fep->atCurrEntries++;
+			return 0;
+		}
+	}
+
+	/* No space available for this static entry */
+	return -1;
+}
+
+/* lookup entry in given Address Table slot and
+ * insert (learn) it if it is not found.
+ * return 0 if entry was found and updated.
+ *        1 if entry was not found and has been inserted (learned).
+ */
+int esw_update_atable_dynamic(unsigned char *mac_addr,
+	unsigned int port, unsigned int currTime,
+	struct switch_enet_private *fep)
+{
+	unsigned long block_index, entry, index_end;
+	unsigned long read_lo, read_hi;
+	unsigned long write_lo, write_hi;
+	unsigned long tmp;
+	int time, timeold, indexold;
+
+	/* prepare update port and timestamp */
+	write_hi = (mac_addr[5] << 8) | (mac_addr[4]);
+	write_lo = (unsigned long)((mac_addr[3] << 24) |
+			(mac_addr[2] << 16) |
+			(mac_addr[1] << 8) |
+			mac_addr[0]);
+	tmp = AT_ENTRY_RECORD_VALID << AT_ENTRY_VALID_shift;
+	tmp |= AT_ENTRY_TYPE_DYNAMIC << AT_ENTRY_TYPE_shift;
+	tmp |= currTime << AT_DENTRY_TIME_shift;
+	tmp |= port << AT_DENTRY_PORT_shift;
+	tmp |= write_hi;
+
+	/*
+	 * linear search through all slot
+	 * entries and update if found
+	 */
+	block_index = GET_BLOCK_PTR(crc8_calc(mac_addr));
+	index_end = block_index + ATABLE_ENTRY_PER_SLOT;
+	 /* Now search all the entries in the selected block */
+	for (entry = block_index; entry < index_end; entry++) {
+		read_atable(fep, entry, &read_lo, &read_hi);
+		if ((read_lo == write_lo) &&
+			((read_hi & 0x0000ffff) ==
+			(write_hi & 0x0000ffff))) {
+			/* found correct address,
+			 * update timestamp. */
+			write_atable(fep, entry, write_lo, tmp);
+			return 0;
+		} else if (!(read_hi & (1 << 16))) {
+			/* slot is empty, then use it
+			 * for new entry
+			 * Note: There are no holes,
+			 * therefore cannot be any
+			 * more that need to be compared.
+			 */
+			write_atable(fep, entry, write_lo, tmp);
+			/* statistics (we do it between writing
+			 * .hi an .lo due to
+			 * hardware limitation...
+			 */
+			fep->atCurrEntries++;
+			/* newly inserted */
+			return 1;
+		}
+	}
+
+	/*
+	 * no more entry available in blockk ...
+	 * overwrite oldest
+	 */
+	timeold = 0;
+	indexold = 0;
+	for (entry = block_index; entry < index_end; entry++) {
+		read_atable(fep, entry, &read_lo, &read_hi);
+		time = AT_EXTRACT_TIMESTAMP(read_hi);
+		time = TIMEDELTA(currTime, time);
+		if (time > timeold) {
+			/* is it older ?*/
+			timeold = time;
+			indexold = entry;
+		}
+	}
+
+	write_atable(fep, indexold, write_lo, tmp);
+	/* Statistics (do it inbetween
+	 * writing to .lo and .hi
+	 */
+	fep->atBlockOverflows++;
+	/* newly inserted */
+	return 1;
+
+}
+
+int esw_update_atable_dynamic1(unsigned long write_lo,
+	unsigned long write_hi, int block_index,
+	unsigned int port, unsigned int currTime,
+	struct switch_enet_private *fep)
+{
+	unsigned long entry, index_end;
+	unsigned long read_lo, read_hi;
+	unsigned long tmp;
+	int time, timeold, indexold;
+
+	/* prepare update port and timestamp */
+	tmp = AT_ENTRY_RECORD_VALID << AT_ENTRY_VALID_shift;
+	tmp |= AT_ENTRY_TYPE_DYNAMIC << AT_ENTRY_TYPE_shift;
+	tmp |= currTime << AT_DENTRY_TIME_shift;
+	tmp |= port << AT_DENTRY_PORT_shift;
+	tmp |= write_hi;
+
+	/*
+	* linear search through all slot
+	* entries and update if found
+	*/
+	index_end = block_index + ATABLE_ENTRY_PER_SLOT;
+	/* Now search all the entries in the selected block */
+	for (entry = block_index; entry < index_end; entry++) {
+		read_atable(fep, entry, &read_lo, &read_hi);
+		if ((read_lo == write_lo) &&
+			((read_hi & 0x0000ffff) ==
+			(write_hi & 0x0000ffff))) {
+			/* found correct address,
+			 * update timestamp.
+			 */
+			write_atable(fep, entry, write_lo, tmp);
+			return 0;
+		} else if (!(read_hi & (1 << 16))) {
+			/* slot is empty, then use it
+			 * for new entry
+			 * Note: There are no holes,
+			 * therefore cannot be any
+			 * more that need to be compared.
+			 */
+			write_atable(fep, entry, write_lo, tmp);
+			/* statistics (we do it between writing
+			 *  .hi an .lo due to
+			 * hardware limitation...
+			 */
+			fep->atCurrEntries++;
+			/* newly inserted */
+			return 1;
+		} else {
+		}
+			printk(KERN_ERR "%s: nothing to do\n", __func__);
+	}
+
+	/*
+	 * no more entry available in block ...
+	 * overwrite oldest
+	 */
+	timeold = 0;
+	indexold = 0;
+	for (entry = block_index; entry < index_end; entry++) {
+		read_atable(fep, entry, &read_lo, &read_hi);
+		time = AT_EXTRACT_TIMESTAMP(read_hi);
+		printk(KERN_ERR "%s : time %x currtime %x\n",
+			__func__, time, currTime);
+		time = TIMEDELTA(currTime, time);
+		if (time > timeold) {
+			/* is it older ? */
+			timeold = time;
+			indexold = entry;
+		}
+	}
+
+	write_atable(fep, indexold, write_lo, tmp);
+	/*
+	 * Statistics (do it inbetween
+	 *writing to .lo and .hi
+	 */
+	fep->atBlockOverflows++;
+	printk(KERN_ERR "%s update time, atBlockOverflows %x\n",
+		__func__, fep->atBlockOverflows);
+	/* newly inserted */
+	return 1;
+}
+
+/*
+ * Delete one dynamic entry within the given block
+ * of 64-bit entries.
+ * return number of valid entries in the block after deletion.
+ */
+int esw_del_atable_dynamic(struct switch_enet_private *fep,
+	int blockidx, int entryidx)
+{
+	unsigned long index_start, index_end;
+	int i;
+	unsigned long read_lo, read_hi;
+
+	/* the entry to delete */
+	index_start = blockidx + entryidx;
+	/* one after last */
+	index_end = blockidx + ATABLE_ENTRY_PER_SLOT;
+	/* Statistics */
+	fep->atCurrEntries--;
+
+	if (entryidx == (ATABLE_ENTRY_PER_SLOT - 1)) {
+		/*
+		 * if it is the very last entry,
+		 * just delete it without further efford
+		 */
+		write_atable(fep, index_start, 0, 0);
+		/*number of entries left*/
+		i = ATABLE_ENTRY_PER_SLOT - 1;
+		return i;
+	} else {
+		/*
+		 * not the last in the block, then
+		 * shift all that follow the one
+		 * that is deleted to avoid "holes".
+		 */
+		for (i = index_start; i < (index_end - 1); i++) {
+			read_atable(fep, i + 1, &read_lo, &read_hi);
+			/* move it down */
+			write_atable(fep, i, read_lo, read_hi);
+			if (!(read_hi & (1 << 16))) {
+				/* stop if we just copied the last */
+				return i - blockidx;
+			}
+		}
+
+		/*
+		 * moved all entries up to the last.
+		 * then set invalid flag in the last
+		 */
+		write_atable(fep, index_end - 1, 0, 0);
+		/* number of valid entries left */
+		return i - blockidx;
+	}
+
+}
+
+void esw_atable_dynamicms_del_entries_for_port(
+	struct switch_enet_private *fep,
+	int port_index)
+{
+	unsigned long read_lo, read_hi;
+
+	unsigned int port_idx;
+	int i;
+
+	for (i = 0; i < ESW_ATABLE_MEM_NUM_ENTRIES; i++) {
+		read_atable(fep, i, &read_lo, &read_hi);
+		if (read_hi & (1 << 16)) {
+			port_idx = AT_EXTRACT_PORT(read_hi);
+
+			if (port_idx == port_index) {
+				write_atable(fep, i, 0, 0);
+				printk(KERN_ERR "Deleted entry "
+					"is number %d\n", i);
+			}
+		}
+	}
+
+}
+
+/*
+ *  Scan one complete block (Slot) for outdated entries and delete them.
+ *  blockidx index of block of entries that should be analyzed.
+ *  return number of deleted entries, 0 if nothing was modified.
+ */
+int esw_atable_dynamicms_check_block_age(
+	struct switch_enet_private *fep, int blockidx) {
+
+	int i, tm, tdelta;
+	int deleted = 0, entries = 0;
+	unsigned long read_lo, read_hi;
+	/* Scan all entries from last down to
+	 * have faster deletion speed if necessary
+	 */
+	for (i = (blockidx + ATABLE_ENTRY_PER_SLOT - 1);
+		i >= blockidx; i--) {
+		read_atable(fep, i, &read_lo, &read_hi);
+
+		if (read_hi & (1 << 16)) {
+			/* the entry is valide */
+			tm = AT_EXTRACT_TIMESTAMP(read_hi);
+			tdelta = TIMEDELTA(fep->currTime, tm);
+			if (tdelta > fep->ageMax) {
+				esw_del_atable_dynamic(fep,
+					blockidx, i-blockidx);
+				deleted++;
+			} else {
+				/* statistics */
+				entries++;
+			}
+		}
+	}
+
+	/* update statistics */
+	if (fep->atMaxEntriesPerBlock < entries)
+		fep->atMaxEntriesPerBlock = entries;
+
+	return deleted;
+}
+
+/* scan the complete address table and find the most current entry.
+ * The time of the most current entry then is used as current time
+ * for the context structure.
+ * In addition the atCurrEntries value is updated as well.
+ * return time that has been set in the context.
+ */
+int esw_atable_dynamicms_find_set_latesttime(
+	struct switch_enet_private *fep) {
+
+	int tm_min, tm_max, tm;
+	int delta, current_val, i;
+	unsigned long read_lo, read_hi;
+
+	tm_min = (1 << AT_DENTRY_TIMESTAMP_WIDTH) - 1;
+	tm_max = 0;
+	current_val = 0;
+
+	for (i = 0; i < ESW_ATABLE_MEM_NUM_ENTRIES; i++) {
+		read_atable(fep, i, &read_lo, &read_hi);
+		if (read_hi & (1 << 16)) {
+			/* the entry is valid */
+			tm = AT_EXTRACT_TIMESTAMP(read_hi);
+			if (tm > tm_max)
+				tm_max = tm;
+			if (tm < tm_min)
+				tm_min = tm;
+			current_val++;
+		}
+	}
+
+	delta = TIMEDELTA(tm_max, tm_min);
+	if (delta < fep->ageMax) {
+		/* Difference must be in range */
+		fep->currTime = tm_max;
+	} else {
+		fep->currTime = tm_min;
+	}
+
+	fep->atCurrEntries = current_val;
+	return fep->currTime;
+}
+
+int esw_atable_dynamicms_get_port(
+	struct switch_enet_private *fep,
+	unsigned long write_lo,
+	unsigned long write_hi,
+	int block_index)
+{
+
+	int i, index_end;
+	unsigned long read_lo, read_hi, port;
+
+	index_end = block_index + ATABLE_ENTRY_PER_SLOT;
+	/* Now search all the entries in the selected block */
+	for (i = block_index; i < index_end; i++) {
+		read_atable(fep, i, &read_lo, &read_hi);
+
+		if ((read_lo == write_lo) &&
+			((read_hi & 0x0000ffff) ==
+			(write_hi & 0x0000ffff))) {
+			/* found correct address,*/
+			if (read_hi & (1 << 16)) {
+				/*
+				 * extract the port index
+				 * from the valid entry
+				 */
+				port = AT_EXTRACT_PORT(read_hi);
+				return port;
+			}
+		}
+	}
+
+	return -1;
+
+}
+
+
+/* Get the port index from the source MAC address
+ * of the received frame
+ * @return port index
+ */
+int esw_atable_dynamicms_get_portindex_from_mac(
+	struct switch_enet_private *fep,
+	unsigned char *mac_addr,
+	unsigned long write_lo,
+	unsigned long write_hi)
+{
+
+	int blockIdx;
+	int rc;
+	/* compute the block index */
+	blockIdx = GET_BLOCK_PTR(crc8_calc(mac_addr));
+	/* Get the ingress port index of the received BPDU */
+	rc = esw_atable_dynamicms_get_port(fep,
+		write_lo, write_hi, blockIdx);
+
+	return rc;
+
+}
+
+/* dynamicms MAC address table learn and migration */
+int esw_atable_dynamicms_learn_migration(
+	struct switch_enet_private *fep,
+	int currTime)
+{
+	struct eswPortInfo *pESWPortInfo;
+	int index;
+	int inserted = 0;
+
+	pESWPortInfo = esw_portinfofifo_read(fep);
+	/* Anything to learn */
+	if (pESWPortInfo != 0) {
+		/* get block index from lookup table */
+		index = GET_BLOCK_PTR(pESWPortInfo->hash);
+		inserted = esw_update_atable_dynamic1(
+			pESWPortInfo->maclo,
+			pESWPortInfo->machi, index,
+			pESWPortInfo->port, currTime, fep);
+	} else {
+		printk(KERN_ERR "%s:hav invalidate learned data \n", __func__);
+		return -1;
+	}
+
+	return 0;
+
+}
+
+void esw_basic_switching(struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
+}
+
+/*
+ * esw_forced_forward
+ * The frame is forwared to the forced destination ports.
+ * It only replace the MAC lookup function,
+ * all other filtering(eg.VLAN verification) act as normal
+ */
+int esw_forced_forward(struct switch_enet_private *fep,
+	int port1, int port2)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	/* Enable Deafault broadcast for port 0 */
+	writel(MCF_ESW_DBCR_P0, fecp + MCF_ESW_DBCR);
+
+	/* Enable Forced forwarding for port num */
+	tmp = MCF_ESW_P0FFEN_FEN;
+	if ((port1 == 1) && (port2 == 1))
+		tmp |= MCF_ESW_P0FFEN_FD(3);
+	else if (port1 == 1)
+		/* Enable Forced forwarding for port 1 only */
+		tmp |= MCF_ESW_P0FFEN_FD(1);
+	else if (port2 == 1)
+		/* Enable Forced forwarding for port 2 only */
+		tmp |= MCF_ESW_P0FFEN_FD(2);
+	else {
+		printk(KERN_ERR "%s:do not support "
+			"the forced forward mode"
+			"port1 %x port2 %x\n",
+			__func__, port1, port2);
+		return -1;
+	}
+
+	fecp->ESW_P0FFEN = tmp;
+	return 0;
+}
+
+/*
+ * enable or disable port n tx or rx
+ * tx_en 0 disable port n tx
+ * tx_en 1 enable  port n tx
+ * rx_en 0 disbale port n rx
+ * rx_en 1 enable  port n rx
+ */
+int esw_port_enable_config(struct switch_enet_private *fep,
+	int port, int tx_en, int rx_en)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	tmp = fecp->ESW_PER;
+	if (tx_en == 1) {
+		if (port == 1)
+			tmp |= MCF_ESW_PER_TE0;
+		else if (port == 2)
+			tmp |= MCF_ESW_PER_TE1;
+		else if (port == 3)
+			tmp |= MCF_ESW_PER_TE2;
+		else {
+			printk(KERN_ERR "%s:do not support the"
+				" port %x tx enable %d\n",
+				__func__, port, tx_en);
+			return -1;
+		}
+	} else if (tx_en == 0) {
+		if (port == 1)
+			tmp &= (~MCF_ESW_PER_TE0);
+		else if (port == 2)
+			tmp &= (~MCF_ESW_PER_TE1);
+		else if (port == 3)
+			tmp &= (~MCF_ESW_PER_TE2);
+		else {
+			printk(KERN_ERR "%s:do not support "
+				"the port %x tx disable %d\n",
+				__func__, port, tx_en);
+			return -2;
+		}
+	} else {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" tx op value %x\n",
+			__func__, port, tx_en);
+		return -3;
+	}
+
+	if (rx_en == 1) {
+		if (port == 1)
+			tmp |= MCF_ESW_PER_RE0;
+		else if (port == 2)
+			tmp |= MCF_ESW_PER_RE1;
+		else if (port == 3)
+			tmp |= MCF_ESW_PER_RE2;
+		else {
+			printk(KERN_ERR "%s:do not support the "
+				"port %x rx enable %d\n",
+				__func__, port, tx_en);
+			return -4;
+		}
+	} else if (rx_en == 0) {
+		if (port == 1)
+			tmp &= (~MCF_ESW_PER_RE0);
+		else if (port == 2)
+			tmp &= (~MCF_ESW_PER_RE1);
+		else if (port == 3)
+			tmp &= (~MCF_ESW_PER_RE2);
+		else {
+			printk(KERN_ERR "%s:do not support the "
+				"port %x rx disable %d\n",
+				__func__, port, rx_en);
+			return -5;
+		}
+	} else {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" rx op value %x\n",
+			__func__, port, tx_en);
+		return -6;
+	}
+
+	fecp->ESW_PER = tmp;
+	return 0;
+}
+
+int esw_port_broadcast_config(
+	struct switch_enet_private *fep,
+	int port, int enable)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if ((port > 2) || (port < 0)) {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" default broadcast\n",
+			__func__, port);
+		return -1;
+	}
+
+	tmp = fecp->ESW_DBCR;
+	if (enable == 1) {
+		if (port == 0)
+			tmp |= MCF_ESW_DBCR_P0;
+		else if (port == 1)
+			tmp |= MCF_ESW_DBCR_P1;
+		else if (port == 2)
+			tmp |= MCF_ESW_DBCR_P2;
+	} else if (enable == 0) {
+		if (port == 0)
+			tmp &= ~MCF_ESW_DBCR_P0;
+		else if (port == 1)
+			tmp &= ~MCF_ESW_DBCR_P1;
+		else if (port == 2)
+			tmp &= ~MCF_ESW_DBCR_P2;
+	}
+
+	fecp->ESW_DBCR = tmp;
+	return 0;
+}
+
+int esw_port_multicast_config(
+	struct switch_enet_private *fep,
+	int port, int enable)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if ((port > 2) || (port < 0)) {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" default broadcast\n",
+			__func__, port);
+		return -1;
+	}
+
+	tmp = fecp->ESW_DMCR;
+	if (enable == 1) {
+		if (port == 0)
+			tmp |= MCF_ESW_DMCR_P0;
+		else if (port == 1)
+			tmp |= MCF_ESW_DMCR_P1;
+		else if (port == 2)
+			tmp |= MCF_ESW_DMCR_P2;
+	} else if (enable == 0) {
+		if (port == 0)
+			tmp &= ~MCF_ESW_DMCR_P0;
+		else if (port == 1)
+			tmp &= ~MCF_ESW_DMCR_P1;
+		else if (port == 2)
+			tmp &= ~MCF_ESW_DMCR_P2;
+	}
+
+	fecp->ESW_DMCR = tmp;
+	return 0;
+}
+
+int esw_port_blocking_config(
+	struct switch_enet_private *fep,
+	int port, int enable)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if ((port > 2) || (port < 0)) {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" default broadcast\n",
+			__func__, port);
+		return -1;
+	}
+
+	tmp = fecp->ESW_BKLR;
+	if (enable == 1) {
+		if (port == 0)
+			tmp |= MCF_ESW_BKLR_BE0;
+		else if (port == 1)
+			tmp |= MCF_ESW_BKLR_BE1;
+		else if (port == 2)
+			tmp |= MCF_ESW_BKLR_BE2;
+	} else if (enable == 0) {
+		if (port == 0)
+			tmp &= ~MCF_ESW_BKLR_BE0;
+		else if (port == 1)
+			tmp &= ~MCF_ESW_BKLR_BE1;
+		else if (port == 2)
+			tmp &= ~MCF_ESW_BKLR_BE2;
+	}
+
+	fecp->ESW_BKLR = tmp;
+	return 0;
+}
+
+int esw_port_learning_config(
+	struct switch_enet_private *fep,
+	int port, int disable)
+{
+	unsigned long tmp = 0;
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if ((port > 2) || (port < 0)) {
+		printk(KERN_ERR "%s:do not support the port %x"
+			" default broadcast\n",
+			__func__, port);
+		return -1;
+	}
+
+	tmp = fecp->ESW_BKLR;
+	if (disable == 1) {
+		if (port == 0)
+			tmp |= MCF_ESW_BKLR_LD0;
+		else if (port == 1)
+			tmp |= MCF_ESW_BKLR_LD1;
+		else if (port == 2)
+			tmp |= MCF_ESW_BKLR_LD2;
+	} else if (disable == 0) {
+		if (port == 0)
+			tmp &= ~MCF_ESW_BKLR_LD0;
+		else if (port == 1)
+			tmp &= ~MCF_ESW_BKLR_LD1;
+		else if (port == 2)
+			tmp &= ~MCF_ESW_BKLR_LD2;
+	}
+
+	fecp->ESW_BKLR = tmp;
+	return 0;
+}
+
+/*
+ * Checks IP Snoop options of handling the snooped frame.
+ * mode 0 : The snooped frame is forward only to management port
+ * mode 1 : The snooped frame is copy to management port and
+ *              normal forwarding is checked.
+ * mode 2 : The snooped frame is discarded.
+ *
+ * ip_header_protocol : the IP header protocol field
+ */
+int esw_ip_snoop_config(struct switch_enet_private *fep,
+	int num, int mode, unsigned long ip_header_protocol)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp, protocol_type;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x50003;
+	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
+
+	/* Enable IP Snooping */
+	tmp = MCF_ESW_IPSNP_EN;
+	if (mode == 0)
+		tmp |= MCF_ESW_IPSNP_MODE(0);/* For Forward */
+	else if (mode == 1)/* For Forward and copy_to_mangmnt_port */
+		tmp |= MCF_ESW_IPSNP_MODE(1);
+	else if (mode == 2)
+		tmp |= MCF_ESW_IPSNP_MODE(2);/* discard */
+	else {
+		printk(KERN_ERR "%s: the mode %d "
+			"we do not support\n", __func__, mode);
+		return -1;
+	}
+
+	protocol_type = ip_header_protocol;
+	fecp->ESW_IPSNP[num] =
+		tmp | MCF_ESW_IPSNP_PROTOCOL(protocol_type);
+
+	return 0;
+}
+
+/*
+ * Checks TCP/UDP Port Snoop options of handling the snooped frame.
+ * mode 0 : The snooped frame is forward only to management port
+ * mode 1 : The snooped frame is copy to management port and
+ *              normal forwarding is checked.
+ * mode 2 : The snooped frame is discarded.
+ * compare_port : port number in the TCP/UDP header
+ * compare_num 1: TCP/UDP source port number is compared
+ * compare_num 2: TCP/UDP destination port number is compared
+ * compare_num 3: TCP/UDP source and destination port number is compared
+ */
+int esw_tcpudp_port_snoop_config(struct switch_enet_private *fep,
+	int num, int mode, int compare_port, int compare_num)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp = 0;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x50003;
+	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
+
+	/* Enable TCP/UDP port Snooping */
+	tmp = MCF_ESW_PSNP_EN |
+		MCF_ESW_PSNP_PORT_COMPARE(compare_port);
+	if (mode == 0)
+		tmp |= MCF_ESW_PSNP_MODE(0);/* For Forward */
+	else if (mode == 1)/* For Forward and copy_to_mangmnt_port */
+		tmp |= MCF_ESW_PSNP_MODE(1);
+	else if (mode == 2)
+		tmp |= MCF_ESW_PSNP_MODE(2);/* discard */
+	else {
+		printk(KERN_ERR "%s: the mode %x we do not support\n",
+			__func__, mode);
+		return -1;
+	}
+
+	if (compare_num == 1)
+		tmp |= MCF_ESW_PSNP_CS;
+	else if (compare_num == 2)
+		tmp |= MCF_ESW_PSNP_CD;
+	else if (compare_num == 3)
+		tmp |= MCF_ESW_PSNP_CD | MCF_ESW_PSNP_CS;
+	else {
+		printk(KERN_ERR "%s: the compare port address %x"
+			" we do not support\n",
+			__func__, compare_num);
+		return -1;
+	}
+
+	fecp->ESW_PSNP[num] = tmp |
+		MCF_ESW_PSNP_PORT_COMPARE(compare_port);
+
+	return 0;
+}
+
+int esw_port_mirroring_config(struct switch_enet_private *fep,
+	int mirror_port, int port,
+	unsigned char *src_mac, unsigned char *des_mac,
+	int egress_en, int ingress_en,
+	int egress_mac_src_en, int egress_mac_des_en,
+	int ingress_mac_src_en, int ingress_mac_des_en)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp = 0;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x50003;
+	writel(0, fecp + MCF_ESW_DBCR);
+	fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN);
+
+	/* Enable TCP/UDP port Snooping */
+
+	/* mirroring config */
+	tmp = MCF_ESW_MCR_MEN | MCF_ESW_MCR_PORT(mirror_port);
+	if (egress_en == 1) {
+		tmp |= MCF_ESW_MCR_EGMAP;
+		if (port == 0)
+			fecp->ESW_EGMAP = MCF_ESW_EGMAP_EG0;
+		else if (port == 1)
+			fecp->ESW_EGMAP = MCF_ESW_EGMAP_EG1;
+		else if (port == 2)
+			fecp->ESW_EGMAP = MCF_ESW_EGMAP_EG2;
+		else {
+			printk(KERN_ERR "%s: the port %x we do not support\n",
+					__func__, port);
+			return -1;
+		}
+	} else if (egress_en != 0) {
+		printk(KERN_ERR "%s: egress_en %x we do not support\n",
+			__func__, egress_en);
+		return -1;
+	}
+
+	if (ingress_en == 1) {
+		tmp |= MCF_ESW_MCR_INGMAP;
+		if (port == 0)
+			fecp->ESW_INGMAP = MCF_ESW_INGMAP_ING0;
+		else if (port == 1)
+			fecp->ESW_INGMAP = MCF_ESW_INGMAP_ING1;
+		else if (port == 2)
+			fecp->ESW_INGMAP = MCF_ESW_INGMAP_ING2;
+		else {
+			printk(KERN_ERR "%s: the port %x we do not support\n",
+				__func__, port);
+			return -1;
+		}
+	} else if (ingress_en != 0) {
+		printk(KERN_ERR "%s: ingress_en %x we do not support\n",
+				__func__, ingress_en);
+		return -1;
+	}
+
+	if (egress_mac_src_en == 1) {
+		tmp |= MCF_ESW_MCR_EGSA;
+		fecp->ESW_ENGSAH = (src_mac[5] << 8) | (src_mac[4]);
+		fecp->ESW_ENGSAL = (unsigned long)((src_mac[3] << 24) |
+					(src_mac[2] << 16) |
+					(src_mac[1] << 8) |
+					src_mac[0]);
+	} else if (egress_mac_src_en != 0) {
+		printk(KERN_ERR "%s: egress_mac_src_en  %x we do not support\n",
+			__func__, egress_mac_src_en);
+		return -1;
+	}
+
+	if (egress_mac_des_en == 1) {
+		tmp |= MCF_ESW_MCR_EGDA;
+		fecp->ESW_ENGDAH = (des_mac[5] << 8) | (des_mac[4]);
+		fecp->ESW_ENGDAL = (unsigned long)((des_mac[3] << 24) |
+					(des_mac[2] << 16) |
+					(des_mac[1] << 8) |
+					des_mac[0]);
+	} else if (egress_mac_des_en != 0) {
+		printk(KERN_ERR "%s: egress_mac_des_en  %x we do not support\n",
+			__func__, egress_mac_des_en);
+		return -1;
+	}
+
+	if (ingress_mac_src_en == 1) {
+		tmp |= MCF_ESW_MCR_INGSA;
+		fecp->ESW_INGSAH = (src_mac[5] << 8) | (src_mac[4]);
+		fecp->ESW_INGSAL = (unsigned long)((src_mac[3] << 24) |
+					(src_mac[2] << 16) |
+					(src_mac[1] << 8) |
+					src_mac[0]);
+	} else if (ingress_mac_src_en != 0) {
+		printk(KERN_ERR "%s: ingress_mac_src_en  %x we do not support\n",
+			__func__, ingress_mac_src_en);
+		return -1;
+	}
+
+	if (ingress_mac_des_en == 1) {
+		tmp |= MCF_ESW_MCR_INGDA;
+		fecp->ESW_INGSAH = (des_mac[5] << 8) | (des_mac[4]);
+		fecp->ESW_INGSAL = (unsigned long)((des_mac[3] << 24) |
+					(des_mac[2] << 16) |
+					(des_mac[1] << 8) |
+					des_mac[0]);
+	} else if (ingress_mac_des_en != 0) {
+		printk(KERN_ERR "%s: ingress_mac_des_en  %x we do not support\n",
+			__func__, ingress_mac_des_en);
+		return -1;
+	}
+
+	fecp->ESW_MCR = tmp;
+	fecp->ESW_MCVAL = MCF_ESW_MCVAL_COUNT(0);
+
+	return 0;
+}
+
+int esw_vlan_input_process(struct switch_enet_private *fep,
+	int port, int mode, unsigned short port_vlanid,
+	int vlan_verify_en, int vlan_domain_num,
+	int vlan_domain_port)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x70007;
+	fecp->ESW_DBCR = 0;
+	/* transmit packet */
+	/* fecp->ESW_P0FFEN = (MCF_ESW_P0FFEN_FD(1) | MCF_ESW_P0FFEN_FEN); */
+
+	/* we only support mode1 mode2 mode3 mode4 */
+	if ((mode < 1) || (mode > 4)) {
+		printk(KERN_ERR "%s: do not support the"
+			" VLAN input processing mode %d\n",
+			__func__, mode);
+		return -1;
+	}
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, mode);
+		return -2;
+	}
+
+	if ((vlan_verify_en == 1) && ((vlan_domain_num < 0)
+		|| (vlan_domain_num > 32))) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, mode);
+		return -3;
+	}
+
+	fecp->ESW_PID[port] = MCF_ESW_PID_VLANID(port_vlanid);
+	if (port == 0) {
+		if (vlan_verify_en == 1)
+			fecp->ESW_VRES[vlan_domain_num] =
+				MCF_ESW_VRES_VLANID(port_vlanid)
+				| MCF_ESW_VRES_P0;
+
+		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN0;
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM0(mode - 1);
+	} else if (port == 1) {
+		if (vlan_verify_en == 1)
+			fecp->ESW_VRES[vlan_domain_num] =
+				MCF_ESW_VRES_VLANID(port_vlanid)
+				| MCF_ESW_VRES_P1;
+
+		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN1;
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM1(mode - 1);
+	} else if (port == 2) {
+		if (vlan_verify_en == 1)
+			fecp->ESW_VRES[vlan_domain_num] =
+				MCF_ESW_VRES_VLANID(port_vlanid)
+				| MCF_ESW_VRES_P2;
+
+		fecp->ESW_VIMEN |= MCF_ESW_VIMEN_EN2;
+		fecp->ESW_VIMSEL |= MCF_ESW_VIMSEL_IM2(mode - 1);
+	} else {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -2;
+	}
+
+	return 0;
+}
+
+int esw_vlan_output_process(struct switch_enet_private *fep,
+	int port, int mode)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x70007;
+	fecp->ESW_DBCR = 0;
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, mode);
+		return -1;
+	}
+
+	if (port == 0) {
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM0(mode - 1);
+	} else if (port == 1) {
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM1(mode - 1);
+	} else if (port == 2) {
+		fecp->ESW_VOMSEL |= MCF_ESW_VOMSEL_OM2(mode - 1);
+	} else {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+	return 0;
+}
+
+/* frame calssify and priority resolution */
+/* vlan priority lookup */
+int esw_framecalssify_vlan_priority_lookup(
+	struct switch_enet_private *fep,
+	int port, int func_enable,
+	int vlan_pri_table_num,
+	int vlan_pri_table_value)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x70007;
+
+	/* Broadcast configure */
+	fecp->ESW_DBCR = 0;
+
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+
+	if (func_enable == 0) {
+		fecp->ESW_PRES[port] &= ~MCF_ESW_PRES_VLAN;
+		printk(KERN_ERR "%s: disable port %d VLAN priority "
+			"lookup function\n", __func__, port);
+		return 0;
+	}
+
+	if ((vlan_pri_table_num < 0) || (vlan_pri_table_num > 7)) {
+		printk(KERN_ERR "%s: do not support the priority %d\n",
+			__func__, vlan_pri_table_num);
+		return -1;
+	}
+
+	fecp->ESW_PVRES[port] |= ((vlan_pri_table_value & 0x3)
+		<< (vlan_pri_table_num*3));
+	/* enable port  VLAN priority lookup function */
+	fecp->ESW_PRES[port] |= MCF_ESW_PRES_VLAN;
+
+	return 0;
+}
+
+int esw_framecalssify_ip_priority_lookup(
+	struct switch_enet_private *fep,
+	int port, int func_enable, int ipv4_en,
+	int ip_priority_num,
+	int ip_priority_value)
+{
+	struct switch_t  *fecp;
+	unsigned long tmp = 0, tmp_prio = 0;
+
+	fecp = fep->hwp;
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0x70007;
+	/* Broadcast configure */
+	fecp->ESW_DBCR = 0;
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+
+	if (func_enable == 0) {
+		fecp->ESW_PRES[port] &= ~MCF_ESW_PRES_IP;
+		printk(KERN_ERR "%s: disable port %d ip priority "
+			"lookup function\n", __func__, port);
+		return 0;
+	}
+
+	/* IPV4 priority 64 entry table lookup */
+	/* IPv4 head 6 bit TOS field */
+	if (ipv4_en == 1) {
+		if ((ip_priority_num < 0) || (ip_priority_num > 63)) {
+			printk(KERN_ERR "%s: do not support the table entry %d\n",
+				__func__, ip_priority_num);
+			return -2;
+		}
+	} else { /* IPV6 priority 256 entry table lookup */
+		/* IPv6 head 8 bit COS field */
+		if ((ip_priority_num < 0) || (ip_priority_num > 255)) {
+			printk(KERN_ERR "%s: do not support the table entry %d\n",
+				__func__, ip_priority_num);
+			return -3;
+		}
+	}
+
+	/* IP priority  table lookup : address */
+	tmp = MCF_ESW_IPRES_ADDRESS(ip_priority_num);
+	/* IP priority  table lookup : ipv4sel */
+	if (ipv4_en == 1)
+		tmp = tmp | MCF_ESW_IPRES_IPV4SEL;
+	/* IP priority  table lookup : priority */
+	if (port == 0)
+		tmp |= MCF_ESW_IPRES_PRI0(ip_priority_value);
+	else if (port == 1)
+		tmp |= MCF_ESW_IPRES_PRI1(ip_priority_value);
+	else if (port == 2)
+		tmp |= MCF_ESW_IPRES_PRI2(ip_priority_value);
+
+	/* configure */
+	fecp->ESW_IPRES = MCF_ESW_IPRES_READ |
+		MCF_ESW_IPRES_ADDRESS(ip_priority_num);
+	tmp_prio = fecp->ESW_IPRES;
+
+	fecp->ESW_IPRES = tmp | tmp_prio;
+
+	fecp->ESW_IPRES = MCF_ESW_IPRES_READ |
+		MCF_ESW_IPRES_ADDRESS(ip_priority_num);
+	tmp_prio = fecp->ESW_IPRES;
+
+	/* enable port  IP priority lookup function */
+	fecp->ESW_PRES[port] |= MCF_ESW_PRES_IP;
+
+	return 0;
+}
+
+int esw_framecalssify_mac_priority_lookup(
+	struct switch_enet_private *fep,
+	int port)
+{
+	struct switch_t  *fecp;
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+
+	fecp = fep->hwp;
+	fecp->ESW_PRES[port] |= MCF_ESW_PRES_IP;
+
+	return 0;
+}
+
+int esw_frame_calssify_priority_init(
+	struct switch_enet_private *fep,
+	int port, unsigned char priority_value)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+	/* disable all priority lookup function */
+	fecp->ESW_PRES[port] = 0;
+	fecp->ESW_PRES[port] = MCF_ESW_PRES_DFLT_PRI(priority_value & 0x7);
+
+	return 0;
+}
+
+int esw_get_statistics_status(
+	struct switch_enet_private *fep,
+	struct esw_statistics_status *pStatistics)
+{
+	struct switch_t  *fecp;
+	fecp = fep->hwp;
+
+	pStatistics->ESW_DISCN   = fecp->ESW_DISCN;
+	pStatistics->ESW_DISCB   = fecp->ESW_DISCB;
+	pStatistics->ESW_NDISCN  = fecp->ESW_NDISCN;
+	pStatistics->ESW_NDISCB  = fecp->ESW_NDISCB;
+#ifdef debug_statistics
+	printk(KERN_ERR "%s:ESW_DISCN %x, ESW_DISCB %x,"
+		"ESW_NDISCN %x, ESW_NDISCB %x\n",
+		__func__, fecp->ESW_DISCN, fecp->ESW_DISCB,
+		fecp->ESW_NDISCN, fecp->ESW_NDISCB);
+#endif
+	return 0;
+}
+
+int esw_get_port_statistics_status(
+	struct switch_enet_private *fep,
+	int port,
+	struct esw_port_statistics_status *pPortStatistics)
+{
+	struct switch_t  *fecp;
+
+	if ((port < 0) || (port > 3)) {
+		printk(KERN_ERR "%s: do not support the port %d\n",
+			__func__, port);
+		return -1;
+	}
+
+	fecp = fep->hwp;
+
+	pPortStatistics->MCF_ESW_POQC   =
+		fecp->port_statistics_status[port].MCF_ESW_POQC;
+	pPortStatistics->MCF_ESW_PMVID  =
+		fecp->port_statistics_status[port].MCF_ESW_PMVID;
+	pPortStatistics->MCF_ESW_PMVTAG =
+		fecp->port_statistics_status[port].MCF_ESW_PMVTAG;
+	pPortStatistics->MCF_ESW_PBL    =
+		fecp->port_statistics_status[port].MCF_ESW_PBL;
+#ifdef DEBUG_PORT_STATISTICS
+	printk(KERN_ERR "%s : port[%d].MCF_ESW_POQC %x, MCF_ESW_PMVID %x,"
+		" MCF_ESW_PMVTAG %x, MCF_ESW_PBL %x\n",
+		__func__, port,
+		fecp->port_statistics_status[port].MCF_ESW_POQC,
+		fecp->port_statistics_status[port].MCF_ESW_PMVID,
+		fecp->port_statistics_status[port].MCF_ESW_PMVTAG,
+		fecp->port_statistics_status[port].MCF_ESW_PBL);
+#endif
+	return 0;
+}
+
+int esw_get_output_queue_status(
+	struct switch_enet_private *fep,
+	struct esw_output_queue_status *pOutputQueue)
+{
+	struct switch_t  *fecp;
+
+	fecp = fep->hwp;
+	pOutputQueue->ESW_MMSR  = fecp->ESW_MMSR;
+	pOutputQueue->ESW_LMT   = fecp->ESW_LMT;
+	pOutputQueue->ESW_LFC   = fecp->ESW_LFC;
+	pOutputQueue->ESW_IOSR  = fecp->ESW_IOSR;
+	pOutputQueue->ESW_PCSR  = fecp->ESW_PCSR;
+	pOutputQueue->ESW_QWT   = fecp->ESW_QWT;
+	pOutputQueue->ESW_P0BCT = fecp->ESW_P0BCT;
+#ifdef DEBUG_OUTPUT_QUEUE
+	printk(KERN_ERR "%s:ESW_MMSR %x, ESW_LMT %x, ESW_LFC %x, "
+		"ESW_IOSR %x, ESW_PCSR %x, ESW_QWT %x, ESW_P0BCT %x\n",
+		__func__, fecp->ESW_MMSR,
+		fecp->ESW_LMT, fecp->ESW_LFC,
+		fecp->ESW_IOSR,  fecp->ESW_PCSR,
+		fecp->ESW_QWT, fecp->ESW_P0BCT);
+#endif
+	return 0;
+}
+
+/* The timer should create an interrupt every 4 seconds */
+static void l2switch_aging_timer(unsigned long data)
+{
+	struct switch_enet_private *fep;
+
+	fep = (struct switch_enet_private *)data;
+
+	/* spin_lock_irqsave(&host->lock, flags); */
+	if (fep) {
+		TIMEINCREMENT(fep->currTime);
+		fep->timeChanged++;
+	}
+
+	/* switch_enet_dump(fep); */
+
+	mod_timer(&fep->timer_aging, jiffies + LEARNING_AGING_TIMER);
+	/* spin_unlock_irqrestore(&host->lock, flags); */
+}
+
+/* ----------------------------------------------------------------------- */
+void esw_check_rxb_txb_interrupt(struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+	fecp = fep->hwp;
+
+	/* Enable Forced forwarding for port 1 */
+	fecp->ESW_P0FFEN = MCF_ESW_P0FFEN_FEN |
+		MCF_ESW_P0FFEN_FD(1);
+	/* Disable learning for all ports */
+
+	writel(MCF_ESW_IMR_TXB | MCF_ESW_IMR_TXF
+			| MCF_ESW_IMR_LRN | MCF_ESW_IMR_RXB | MCF_ESW_IMR_RXF
+			, fecp + MCF_ESW_IMR);
+}
+
+static void esw_basic_switching_test(struct switch_enet_private *fep)
+{
+	unsigned char mac_addr0[6] = {0x00, 0x04, 0x9F, 0x00, 0xB3, 0x49};
+	unsigned char mac_addr1[6] = {0x00, 0x00, 0x45, 0x67, 0x89, 0xAB};
+	unsigned char mac_addr2[6] = {0x00, 0x0B, 0xDB, 0xD0, 0x25, 0x9A};
+	unsigned char mac_addr[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+	struct switch_t  *fecp;
+	fecp = fep->hwp;
+
+	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
+
+	esw_update_atable_static(mac_addr, 7, 7, fep);
+	/* port0 MAC is forwared to port1 and port2 */
+	esw_update_atable_static(mac_addr0, 7, 7, fep);
+	esw_update_atable_static(mac_addr1, 7, 7, fep);
+	/* port2 MAC is forwared to port0 and port1 */
+	esw_update_atable_static(mac_addr2, 7, 7, fep);
+}
+
+static void esw_test_main(struct switch_enet_private *fep)
+{
+	struct switch_t  *fecp;
+	fecp = fep->hwp;
+	esw_basic_switching_test(fep);
+	/* test case 1 */
+	/*
+	 * fecp->ESW_IPSNP[0] = (MCF_ESW_IPSNP_PROTOCOL(0x01) |
+	 * 	MCF_ESW_IPSNP_MODE(1)  |
+	 * 	MCF_ESW_IPSNP_EN);
+	 * fecp->ESW_PSNP[0] = (MCF_ESW_PSNP_PORT_COMPARE(1080) |
+	 * 	MCF_ESW_PSNP_CD |
+	 * 	MCF_ESW_PSNP_MODE(1) |
+	 * 	MCF_ESW_PSNP_EN);
+	 */
+
+	/* test case 2 */
+	fecp->ESW_BKLR = MCF_ESW_BKLR_LD0 | MCF_ESW_BKLR_LD1 |
+		MCF_ESW_BKLR_LD2;
+	/*
+	 * MCF_ESW_IMR = MCF_ESW_IMR_TXB | MCF_ESW_IMR_TXF |
+	 * 	MCF_ESW_IMR_LRN | MCF_ESW_IMR_RXB | MCF_ESW_IMR_RXF;
+	 */
+
+	/* test case 3 */
+	/*
+	 * writel(0x70007, fecp + MCF_ESW_PER);
+	 * fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
+	 * fecp->ESW_MCR = MCF_ESW_MCR_INGMAP | MCF_ESW_MCR_MEN |
+	 * 	MCF_ESW_MCR_PORT(0);
+	 * fecp->ESW_INGMAP = MCF_ESW_INGMAP_ING2;
+	 * fecp->ESW_MCVAL = MCF_ESW_MCVAL_COUNT(0);
+	 */
+
+	/* test case 4 */
+	writel(0x70007, fecp + MCF_ESW_PER);
+	/*
+	 * fecp->ESW_DBCR = MCF_ESW_DBCR_P1;
+	 * fecp->ESW_MCR = MCF_ESW_MCR_INGSA | MCF_ESW_MCR_INGMAP |
+	 * 	MCF_ESW_MCR_MEN | MCF_ESW_MCR_PORT(0);
+	 * fecp->ESW_INGMAP = MCF_ESW_INGMAP_ING2;
+	 * fecp->ESW_INGSAH = 0x00009A25;
+	 * fecp->ESW_INGSAL = 0xD0DB0B00;\
+	 * fecp->ESW_MCVAL = MCF_ESW_MCVAL_COUNT(0);
+	 */
+
+	/* test case 5 */
+	fecp->ESW_DBCR = MCF_ESW_DBCR_P1;/* 0 P0 P2 */
+}
+
+static int
+switch_enet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct switch_enet_private *fep;
+	struct switch_t	*fecp;
+	struct cbd_t	*bdp;
+	unsigned short	status;
+	unsigned long flags;
+
+	fep = netdev_priv(dev);
+	fecp = (struct switch_t *)fep->hwp;
+
+	spin_lock_irqsave(&fep->hw_lock, flags);
+	/* Fill in a Tx ring entry */
+	bdp = fep->cur_tx;
+
+	status = bdp->cbd_sc;
+
+	if (status & BD_ENET_TX_READY) {
+		/*
+		 * Ooops.  All transmit buffers are full.  Bail out.
+		 * This should not happen, since dev->tbusy should be set.
+		 */
+		printk(KERN_ERR "%s: tx queue full!.\n", dev->name);
+		spin_unlock_irqrestore(&fep->hw_lock, flags);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Clear all of the status flags */
+	status &= ~BD_ENET_TX_STATS;
+
+	/* Set buffer length and buffer pointer	*/
+	bdp->cbd_bufaddr = __pa(skb->data);
+	bdp->cbd_datlen = skb->len;
+	printk(KERN_ERR "%s: skb->len %u, dev->stats.tx_bytes %lx,"
+		" bdp->cbd_bufaddr %lx skb->data %lx\n",
+		__func__, skb->len, dev->stats.tx_bytes,
+		bdp->cbd_bufaddr, (unsigned long)skb->data);
+	/*
+	 * On some FEC implementations data must be aligned on
+	 * 4-byte boundaries. Use bounce buffers to copy data
+	 * and get it aligned. Ugh.
+	 */
+	if (bdp->cbd_bufaddr & FEC_ALIGNMENT) {
+		unsigned int index1;
+		index1 = bdp - fep->tx_bd_base;
+		printk(KERN_ERR "%s: bdp->cbd_bufaddr %lx\n",
+			__func__, bdp->cbd_bufaddr);
+		memcpy(fep->tx_bounce[index1],
+		       (void *)skb->data, bdp->cbd_datlen);
+		bdp->cbd_bufaddr = __pa(fep->tx_bounce[index1]);
+	}
+
+#ifdef CONFIG_ARCH_MXS
+	swap_buffer((void *)bdp->cbd_bufaddr, skb->len);
+#endif
+	/* Save skb pointer. */
+	fep->tx_skbuff[fep->skb_cur] = skb;
+
+	dev->stats.tx_bytes += skb->len;
+	fep->skb_cur = (fep->skb_cur+1) & TX_RING_MOD_MASK;
+
+	/*
+	 * Push the data cache so the CPM does not get stale memory
+	 * data.
+	 */
+	bdp->cbd_bufaddr = dma_map_single(&dev->dev, (void *)bdp->cbd_bufaddr,
+		FEC_ENET_TX_FRSIZE, DMA_TO_DEVICE);
+
+	/*
+	 * Send it on its way.  Tell FEC it's ready, interrupt when done,
+	 * it's the last BD of the frame, and to put the CRC on the end.
+	 */
+
+	status |= (BD_ENET_TX_READY | BD_ENET_TX_INTR
+			| BD_ENET_TX_LAST | BD_ENET_TX_TC);
+	bdp->cbd_sc = status;
+#ifdef MODELO_BUFFER
+	bdp->bdu = 0x00000000;
+	bdp->ebd_status = TX_BD_INT | TX_BD_TS;
+#endif
+	dev->trans_start = jiffies;
+
+	/* Trigger transmission start */
+	fecp->fec_x_des_active = MCF_ESW_TDAR_X_DES_ACTIVE;
+
+	/* If this was the last BD in the ring,
+	 * start at the beginning again.
+	 */
+	if (status & BD_ENET_TX_WRAP)
+		bdp = fep->tx_bd_base;
+	else
+		bdp++;
+
+	if (bdp == fep->dirty_tx) {
+		fep->tx_full = 1;
+		netif_stop_queue(dev);
+		printk(KERN_ERR "%s:  net stop\n", __func__);
+	}
+
+	fep->cur_tx = (struct cbd_t *)bdp;
+
+	spin_unlock_irqrestore(&fep->hw_lock, flags);
+
+	return 0;
+}
+
+static void
+switch_timeout(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+
+	printk(KERN_INFO "%s: transmit timed out.\n", dev->name);
+	dev->stats.tx_errors++;
+	{
+	int	i;
+	struct cbd_t	*bdp;
+
+	printk(KERN_INFO "Ring data dump: cur_tx %lx%s,"
+		"dirty_tx %lx cur_rx: %lx\n",
+		(unsigned long)fep->cur_tx, fep->tx_full ? " (full)" : "",
+		(unsigned long)fep->dirty_tx,
+		(unsigned long)fep->cur_rx);
+
+	bdp = fep->tx_bd_base;
+	printk(KERN_INFO " tx: %u buffers\n",  TX_RING_SIZE);
+	for (i = 0 ; i < TX_RING_SIZE; i++) {
+		printk(KERN_INFO "  %08x: %04x %04x %08x\n",
+		       (uint) bdp,
+		       bdp->cbd_sc,
+		       bdp->cbd_datlen,
+		       (int) bdp->cbd_bufaddr);
+		bdp++;
+	}
+
+	bdp = fep->rx_bd_base;
+	printk(KERN_INFO " rx: %lu buffers\n",
+			(unsigned long) RX_RING_SIZE);
+	for (i = 0 ; i < RX_RING_SIZE; i++) {
+		printk(KERN_INFO "  %08x: %04x %04x %08x\n",
+		       (uint) bdp,
+		       bdp->cbd_sc,
+		       bdp->cbd_datlen,
+		       (int) bdp->cbd_bufaddr);
+		bdp++;
+	}
+	}
+	switch_restart(dev, fep->full_duplex);
+	netif_wake_queue(dev);
+}
+
+/*
+ * The interrupt handler.
+ * This is called from the MPC core interrupt.
+ */
+static irqreturn_t
+switch_enet_interrupt(int irq, void *dev_id)
+{
+	struct	net_device *dev = dev_id;
+	struct switch_t *fecp;
+	uint	int_events;
+	irqreturn_t ret = IRQ_NONE;
+
+	fecp = (struct switch_t *)dev->base_addr;
+
+	/* Get the interrupt events that caused us to be here */
+	do {
+		int_events = fecp->switch_ievent;
+		fecp->switch_ievent = int_events;
+		/* switch_enet_dump(fep); */
+		/* Handle receive event in its own function. */
+
+		/* Transmit OK, or non-fatal error. Update the buffer
+		 * descriptors. FEC handles all errors, we just discover
+		 *  them as part of the transmit process.
+		 */
+		if (int_events & MCF_ESW_ISR_LRN) {
+			ret = IRQ_HANDLED;
+			printk(KERN_INFO "\n");
+		}
+
+		if (int_events & MCF_ESW_ISR_OD0)
+			ret = IRQ_HANDLED;
+
+		if (int_events & MCF_ESW_ISR_OD1)
+			ret = IRQ_HANDLED;
+
+		if (int_events & MCF_ESW_ISR_OD2)
+			ret = IRQ_HANDLED;
+
+		if (int_events & MCF_ESW_ISR_RXB)
+			ret = IRQ_HANDLED;
+
+		if (int_events & MCF_ESW_ISR_RXF) {
+			ret = IRQ_HANDLED;
+			switch_enet_rx(dev);
+		}
+
+		if (int_events & MCF_ESW_ISR_TXB)
+			ret = IRQ_HANDLED;
+
+		if (int_events & MCF_ESW_ISR_TXF) {
+			ret = IRQ_HANDLED;
+			switch_enet_tx(dev);
+		}
+
+	} while (int_events);
+
+	return ret;
+}
+
+
+static void
+switch_enet_tx(struct net_device *dev)
+{
+	struct	switch_enet_private *fep;
+	struct cbd_t	*bdp;
+	unsigned short status;
+	struct	sk_buff	*skb;
+
+	fep = netdev_priv(dev);
+	spin_lock(&fep->hw_lock);
+	bdp = fep->dirty_tx;
+
+	while (((status = bdp->cbd_sc) & BD_ENET_TX_READY) == 0) {
+		if (bdp == fep->cur_tx && fep->tx_full == 0)
+			break;
+
+		skb = fep->tx_skbuff[fep->skb_dirty];
+		/* Check for errors */
+		if (status & (BD_ENET_TX_HB | BD_ENET_TX_LC |
+				   BD_ENET_TX_RL | BD_ENET_TX_UN |
+				   BD_ENET_TX_CSL)) {
+			dev->stats.tx_errors++;
+			if (status & BD_ENET_TX_HB)  /* No heartbeat */
+				dev->stats.tx_heartbeat_errors++;
+			if (status & BD_ENET_TX_LC)  /* Late collision */
+				dev->stats.tx_window_errors++;
+			if (status & BD_ENET_TX_RL)  /* Retrans limit */
+				dev->stats.tx_aborted_errors++;
+			if (status & BD_ENET_TX_UN)  /* Underrun */
+				dev->stats.tx_fifo_errors++;
+			if (status & BD_ENET_TX_CSL) /* Carrier lost */
+				dev->stats.tx_carrier_errors++;
+		} else {
+			dev->stats.tx_packets++;
+		}
+
+		if (status & BD_ENET_TX_READY)
+			printk(KERN_ERR "HEY! "
+				"Enet xmit interrupt and TX_READY.\n");
+		/*
+		 * Deferred means some collisions occurred during transmit,
+		 * but we eventually sent the packet OK.
+		 */
+		if (status & BD_ENET_TX_DEF)
+			dev->stats.collisions++;
+
+		/* Free the sk buffer associated with this last transmit */
+		dev_kfree_skb_any(skb);
+		fep->tx_skbuff[fep->skb_dirty] = NULL;
+		fep->skb_dirty = (fep->skb_dirty + 1) & TX_RING_MOD_MASK;
+
+		/* Update pointer to next buffer descriptor to be transmitted */
+		if (status & BD_ENET_TX_WRAP)
+			bdp = fep->tx_bd_base;
+		else
+			bdp++;
+
+		/*
+		 * Since we have freed up a buffer, the ring is no longer
+		 * full.
+		 */
+		if (fep->tx_full) {
+			fep->tx_full = 0;
+			printk(KERN_ERR "%s: tx full is zero\n", __func__);
+			if (netif_queue_stopped(dev))
+				netif_wake_queue(dev);
+		}
+	}
+	fep->dirty_tx = (struct cbd_t *)bdp;
+	spin_unlock(&fep->hw_lock);
+}
+
+
+/*
+ * During a receive, the cur_rx points to the current incoming buffer.
+ * When we update through the ring, if the next incoming buffer has
+ * not been given to the system, we just set the empty indicator,
+ * effectively tossing the packet.
+ */
+static void
+switch_enet_rx(struct net_device *dev)
+{
+	struct	switch_enet_private *fep;
+	struct switch_t *fecp;
+	struct cbd_t *bdp;
+	unsigned short status;
+	struct	sk_buff	*skb;
+	ushort	pkt_len;
+	__u8 *data;
+
+#ifdef CONFIG_M532x
+	flush_cache_all();
+#endif
+
+	fep = netdev_priv(dev);
+	fecp = (struct switch_t *)fep->hwp;
+
+	spin_lock(&fep->hw_lock);
+	/*
+	 * First, grab all of the stats for the incoming packet.
+	 * These get messed up if we get called due to a busy condition.
+	 */
+	bdp = fep->cur_rx;
+#ifdef MODELO_BUFFER
+	printk(KERN_ERR "%s: cbd_sc %x cbd_datlen %x cbd_bufaddr %x "
+		"ebd_status %x bdu %x length_proto_type %x "
+		"payload_checksum %x\n",
+		__func__, bdp->cbd_sc, bdp->cbd_datlen,
+		bdp->cbd_bufaddr, bdp->ebd_status, bdp->bdu,
+		bdp->length_proto_type, bdp->payload_checksum);
+#endif
+
+while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) {
+
+	/*
+	 * Since we have allocated space to hold a complete frame,
+	 * the last indicator should be set.
+	 */
+	if ((status & BD_ENET_RX_LAST) == 0)
+		printk(KERN_INFO "SWITCH ENET: rcv is not +last\n");
+
+	if (!fep->opened)
+		goto rx_processing_done;
+
+	/* Check for errors. */
+	if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH | BD_ENET_RX_NO |
+			   BD_ENET_RX_CR | BD_ENET_RX_OV)) {
+		dev->stats.rx_errors++;
+		if (status & (BD_ENET_RX_LG | BD_ENET_RX_SH)) {
+			/* Frame too long or too short. */
+			dev->stats.rx_length_errors++;
+		}
+		if (status & BD_ENET_RX_NO)	/* Frame alignment */
+			dev->stats.rx_frame_errors++;
+		if (status & BD_ENET_RX_CR)	/* CRC Error */
+			dev->stats.rx_crc_errors++;
+		if (status & BD_ENET_RX_OV)	/* FIFO overrun */
+			dev->stats.rx_fifo_errors++;
+	}
+
+	/*
+	 * Report late collisions as a frame error.
+	 * On this error, the BD is closed, but we don't know what we
+	 * have in the buffer.  So, just drop this frame on the floor.
+	 */
+	if (status & BD_ENET_RX_CL) {
+		dev->stats.rx_errors++;
+		dev->stats.rx_frame_errors++;
+		goto rx_processing_done;
+	}
+
+	/* Process the incoming frame */
+	dev->stats.rx_packets++;
+	pkt_len = bdp->cbd_datlen;
+	dev->stats.rx_bytes += pkt_len;
+	data = (__u8 *)__va(bdp->cbd_bufaddr);
+
+	/*
+	 * This does 16 byte alignment, exactly what we need.
+	 * The packet length includes FCS, but we don't want to
+	 * include that when passing upstream as it messes up
+	 * bridging applications.
+	 */
+	/* skb = dev_alloc_skb(pkt_len - 4); */
+	skb = dev_alloc_skb(pkt_len);
+
+	if (skb == NULL) {
+		printk(KERN_ERR "%s: Memory squeeze, "
+			"dropping packet.\n", dev->name);
+		dev->stats.rx_dropped++;
+	} else {
+		/*
+		 * skb_put(skb, pkt_len -4);
+		 * skb_copy_to_linear_data(skb, data, pkt_len - 4);
+		 */
+		skb_put(skb, pkt_len);	/* Make room */
+		skb_copy_to_linear_data(skb, data, pkt_len);
+		skb->protocol = eth_type_trans(skb, dev);
+		netif_rx(skb);
+	}
+rx_processing_done:
+
+	/* Clear the status flags for this buffer */
+	status &= ~BD_ENET_RX_STATS;
+
+	/* Mark the buffer empty */
+	status |= BD_ENET_RX_EMPTY;
+	bdp->cbd_sc = status;
+
+	/* Update BD pointer to next entry */
+	if (status & BD_ENET_RX_WRAP)
+		bdp = fep->rx_bd_base;
+	else
+		bdp++;
+
+	/*
+	 * Doing this here will keep the FEC running while we process
+	 * incoming frames.  On a heavily loaded network, we should be
+	 * able to keep up at the expense of system resources.
+	 */
+	/* fecp->fec_r_des_active = MCF_ESW_RDAR_R_DES_ACTIVE; */
+   } /* while (!((status = bdp->cbd_sc) & BD_ENET_RX_EMPTY)) */
+	fep->cur_rx = (struct cbd_t *)bdp;
+
+#if 0
+	/* Doing this here will allow us to process all frames in the
+	 * ring before the FEC is allowed to put more there.  On a heavily
+	 * loaded network, some frames may be lost.  Unfortunately, this
+	 * increases the interrupt overhead since we can potentially work
+	 * our way back to the interrupt return only to come right back
+	 * here.
+	 */
+	fecp->fec_r_des_active = 0;
+#endif
+
+	spin_unlock(&fep->hw_lock);
+}
+
+#ifdef FEC_PHY
+static int fec_mdio_transfer(struct mii_bus *bus, int phy_id,
+	int reg, int regval)
+{
+	struct net_device *dev = bus->priv;
+	unsigned long   flags;
+	struct switch_enet_private *fep;
+	int tries = 100;
+	int retval = 0;
+
+	fep = netdev_priv(dev);
+	spin_lock_irqsave(&fep->mii_lock, flags);
+
+	regval |= phy_id << 23;
+	writel(regval, fep->enet_addr + MCF_FEC_MMFR0);
+
+	/* wait for it to finish, this takes about 23 us on lite5200b */
+	while (!(readl(fep->enet_addr + MCF_FEC_EIR0) & FEC_ENET_MII)
+			&& --tries)
+		udelay(5);
+
+	if (!tries) {
+		printk(KERN_ERR "%s timeout\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	writel(FEC_ENET_MII, fep->enet_addr + MCF_FEC_EIR0);
+	retval = readl(fep->enet_addr + MCF_FEC_MMFR0);
+	spin_unlock_irqrestore(&fep->mii_lock, flags);
+
+	return retval;
+}
+
+/*
+ * Phy section
+ */
+static void switch_adjust_link(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	struct phy_device *phy_dev = fep->phy_dev;
+	unsigned long flags;
+	int status_change = 0;
+
+	phy_dev = g_phy_dev;
+	spin_lock_irqsave(&fep->hw_lock, flags);
+
+	/* Prevent a state halted on mii error */
+	if (fep->mii_timeout && phy_dev->state == PHY_HALTED) {
+		phy_dev->state = PHY_RESUMING;
+		goto spin_unlock;
+	}
+
+	/* Duplex link change */
+	if (phy_dev->link) {
+		if (fep->full_duplex != phy_dev->duplex) {
+			switch_restart(dev, phy_dev->duplex);
+			status_change = 1;
+		}
+	}
+
+	/* Link on or off change */
+	if (phy_dev->link != fep->link) {
+		fep->link = phy_dev->link;
+		if (phy_dev->link)
+			switch_restart(dev, phy_dev->duplex);
+		else
+			switch_stop(dev);
+		status_change = 1;
+	}
+
+spin_unlock:
+	spin_unlock_irqrestore(&fep->hw_lock, flags);
+
+	if (status_change)
+		phy_print_status(phy_dev);
+}
+
+/*
+ * NOTE: a MII transaction is during around 25 us, so polling it...
+ */
+static int fec_enet_mdio_poll(struct switch_enet_private *fep)
+ {
+	int timeout = FEC_MII_TIMEOUT;
+	unsigned int reg = 0;
+
+	fep->mii_timeout = 0;
+
+	/* wait for end of transfer */
+	reg = readl(fep->hwp + FEC_IEVENT);
+	while (!(reg & FEC_ENET_MII)) {
+		msleep(1);
+		if (timeout-- < 0) {
+			fep->mii_timeout = 1;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int fec_enet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct switch_enet_private *fep = netdev_priv(bus->priv);
+
+
+	/* clear MII end of transfer bit */
+	writel(FEC_ENET_MII, fep->enet_addr + FEC_IEVENT
+			/ sizeof(unsigned long));
+
+	/* start a read op */
+	writel(FEC_MMFR_ST | FEC_MMFR_OP_READ |
+		FEC_MMFR_PA(mii_id) | FEC_MMFR_RA(regnum) |
+		FEC_MMFR_TA, fep->enet_addr + FEC_MII_DATA
+		/ sizeof(unsigned long));
+
+	fec_enet_mdio_poll(fep);
+
+	/* return value */
+	return FEC_MMFR_DATA(readl(fep->enet_addr + FEC_MII_DATA
+				/ sizeof(unsigned long)));
+}
+
+static int fec_enet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+			   u16 value)
+{
+	struct switch_enet_private *fep = netdev_priv(bus->priv);
+
+	/* clear MII end of transfer bit */
+	writel(FEC_ENET_MII, fep->enet_addr + FEC_IEVENT
+			/ sizeof(unsigned long));
+
+	/* start a read op */
+	writel(FEC_MMFR_ST | FEC_MMFR_OP_READ |
+		FEC_MMFR_PA(mii_id) | FEC_MMFR_RA(regnum) |
+		FEC_MMFR_TA | FEC_MMFR_DATA(value),
+		fep->enet_addr + FEC_MII_DATA / sizeof(unsigned long));
+
+	fec_enet_mdio_poll(fep);
+
+	return 0;
+}
+
+static int fec_enet_mdio_reset(struct mii_bus *bus)
+{
+	return 0;
+}
+
+static struct mii_bus *fec_enet_mii_init(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	int err = -ENXIO, i;
+
+	fep->mii_timeout = 0;
+	/*
+	 * Set MII speed to 2.5 MHz (= clk_get_rate() / 2 * phy_speed)
+	 */
+	fep->phy_speed = DIV_ROUND_UP(clk_get_rate(fep->clk), 5000000) << 1;
+#ifdef CONFIG_ARCH_MXS
+	/* Can't get phy(8720) ID when set to 2.5M on MX28, lower it */
+	fep->phy_speed <<= 2;
+#endif
+	writel(fep->phy_speed, fep->enet_addr + FEC_MII_SPEED
+			/ sizeof(unsigned long));
+
+	fep->mii_bus = mdiobus_alloc();
+	if (fep->mii_bus == NULL) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	fep->mii_bus->name = "fec_enet_mii_bus";
+	fep->mii_bus->read = fec_enet_mdio_read;
+	fep->mii_bus->write = fec_enet_mdio_write;
+	fep->mii_bus->reset = fec_enet_mdio_reset;
+	snprintf(fep->mii_bus->id, MII_BUS_ID_SIZE, "%x", fep->pdev->id);
+	fep->mii_bus->priv = dev;
+
+	fep->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!fep->mii_bus->irq) {
+		err = -ENOMEM;
+		goto err_out_free_mdiobus;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		fep->mii_bus->irq[i] = PHY_POLL;
+
+	if (mdiobus_register(fep->mii_bus)) {
+		printk(KERN_INFO "[%s][%d]err = %#x\n",
+				__func__, __LINE__, err);
+		goto err_out_free_mdio_irq;
+	}
+
+	return fep->mii_bus;
+
+err_out_free_mdio_irq:
+	kfree(fep->mii_bus->irq);
+err_out_free_mdiobus:
+	mdiobus_free(fep->mii_bus);
+err_out:
+	return ERR_PTR(err);
+}
+#endif
+
+static int fec_enet_get_settings(struct net_device *dev,
+				  struct ethtool_cmd *cmd)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	struct phy_device *phydev = fep->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int fec_enet_set_settings(struct net_device *dev,
+				 struct ethtool_cmd *cmd)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	struct phy_device *phydev = fep->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static void fec_enet_get_drvinfo(struct net_device *dev,
+				 struct ethtool_drvinfo *info)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+
+	strcpy(info->driver, fep->pdev->dev.driver->name);
+	strcpy(info->version, "Revision: 1.0");
+	strcpy(info->bus_info, dev_name(&dev->dev));
+}
+
+#ifdef FEC_PHY
+static int fec_switch_init_phy(struct net_device *dev)
+{
+	struct switch_enet_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = NULL;
+	int i;
+
+	/* search for connect PHY device */
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		struct phy_device *const tmp_phydev =
+			priv->mdio_bus->phy_map[i];
+
+		if (!tmp_phydev) {
+#ifdef FEC_DEBUG
+			printk(KERN_INFO "%s no PHY here at"
+				"mii_bus->phy_map[%d]\n",
+				__func__, i);
+#endif
+			continue; /* no PHY here... */
+		}
+
+#ifdef CONFIG_FEC_SHARED_PHY
+		if (priv->index == 0)
+			phydev = tmp_phydev;
+		else if (priv->index == 1) {
+			if (startnode == 1) {
+				phydev = tmp_phydev;
+				startnode = 0;
+			} else {
+				startnode++;
+				continue;
+			}
+		} else
+			printk(KERN_INFO "%s now we do not"
+				"support (%d) more than"
+				"2 phys shared "
+				"one mdio bus\n",
+				__func__, startnode);
+#else
+		phydev = tmp_phydev;
+#endif
+#ifdef FEC_DEBUG
+		printk(KERN_INFO "%s find PHY here at"
+			"mii_bus->phy_map[%d]\n",
+			__func__, i);
+#endif
+		break; /* found it */
+	}
+
+	/* now we are supposed to have a proper phydev, to attach to... */
+	if (!phydev) {
+		printk(KERN_INFO "%s: Don't found any phy device at all\n",
+			dev->name);
+		return -ENODEV;
+	}
+
+	priv->link = PHY_DOWN;
+	priv->old_link = PHY_DOWN;
+	priv->speed = 0;
+	priv->duplex = -1;
+
+	phydev = phy_connect(dev, dev_name(&phydev->dev),
+		&switch_adjust_link, 0, PHY_INTERFACE_MODE_MII);
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR " %s phy_connect failed\n", __func__);
+		return PTR_ERR(phydev);
+	}
+
+	printk(KERN_INFO "attached phy %i to driver %s\n",
+		phydev->addr, phydev->drv->name);
+
+	priv->phydev	= phydev;
+	g_phy_dev	= phydev;
+
+	return 0;
+}
+#endif
+
+static int
+switch_enet_open(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+	/* I should reset the ring buffers here, but I don't yet know
+	 * a simple way to do that.
+	 */
+	switch_set_mac_address(dev, NULL);
+
+	fep->link = 0;
+#ifdef FEC_PHY
+	clk_enable(fep->clk);
+	fec_switch_init_phy(dev);
+	phy_start(fep->phydev);
+#endif
+	fep->old_link = 0;
+	if (fep->phydev) {
+		/*
+		 * Set the initial link state to true. A lot of hardware
+		 * based on this device does not implement a PHY interrupt,
+		 * so we are never notified of link change.
+		 */
+		fep->link = 1;
+	} else {
+		fep->link = 1;
+		/* no phy,  go full duplex,  it's most likely a hub chip */
+		switch_restart(dev, 1);
+	}
+
+	/*
+	 * if the fec is the fist open, we need to do nothing
+	 * if the fec is not the fist open, we need to restart the FEC
+	 */
+	if (fep->sequence_done == 0)
+		switch_restart(dev, 1);
+	else
+		fep->sequence_done = 0;
+
+	fep->currTime = 0;
+	/* enable timer for Learning Aging Function */
+	/* add_timer(&fep->timer_aging); */
+
+	esw_test_main(fep);
+
+	netif_start_queue(dev);
+	fep->opened = 1;
+	return 0;
+}
+
+static int
+switch_enet_close(struct net_device *dev)
+{
+	struct switch_enet_private *fep = netdev_priv(dev);
+
+	fep->opened = 0;
+	netif_stop_queue(dev);
+	switch_stop(dev);
+#ifdef FEC_PHY
+	phy_disconnect(fep->phydev);
+	phy_stop(fep->phydev);
+	phy_write(fep->phydev, MII_BMCR, BMCR_PDOWN);
+#endif
+	return 0;
+}
+
+/*
+ * Set or clear the multicast filter for this adaptor.
+ * Skeleton taken from sunlance driver.
+ * The CPM Ethernet implementation allows Multicast as well as individual
+ * MAC address filtering.  Some of the drivers check to make sure it is
+ * a group multicast address, and discard those that are not.  I guess I
+ * will do the same for now, but just remove the test if you want
+ * individual filtering as well (do the upper net layers want or support
+ * this kind of feature?).
+ */
+
+/* bits in hash */
+#define HASH_BITS	6
+#define CRC32_POLY	0xEDB88320
+
+static void set_multicast_list(struct net_device *dev)
+{
+	struct switch_enet_private *fep;
+	struct switch_t *ep;
+	struct dev_mc_list *dmi;
+	unsigned int i, j, bit, data, crc;
+
+	fep = netdev_priv(dev);
+	ep = fep->hwp;
+
+	if (dev->flags & IFF_PROMISC) {
+		/* ep->fec_r_cntrl |= 0x0008; */
+		printk(KERN_INFO "%s IFF_PROMISC\n", __func__);
+	} else {
+
+		/* ep->fec_r_cntrl &= ~0x0008; */
+
+		if (dev->flags & IFF_ALLMULTI) {
+			/*
+			 * Catch all multicast addresses, so set the
+			 * filter to all 1's.
+			 */
+			printk(KERN_INFO "%s IFF_ALLMULTI\n", __func__);
+		} else {
+			/*
+			 * Clear filter and add the addresses
+			 * in hash register
+			 */
+			/*
+			 * ep->fec_grp_hash_table_high = 0;
+			 * ep->fec_grp_hash_table_low = 0;
+			 */
+
+			dmi = dev->mc_list;
+
+			for (j = 0; j < dev->mc_count;
+				j++, dmi = dmi->next) {
+				/* Only support group multicast for now */
+				if (!(dmi->dmi_addr[0] & 1))
+					continue;
+
+				/* calculate crc32 value of mac address	*/
+				crc = 0xffffffff;
+
+				for (i = 0; i < dmi->dmi_addrlen; i++) {
+					data = dmi->dmi_addr[i];
+					for (bit = 0; bit < 8; bit++,
+						data >>= 1) {
+						crc = (crc >> 1) ^
+						(((crc ^ data) & 1) ?
+						CRC32_POLY : 0);
+					}
+				}
+
+			}
+		}
+	}
+}
+
+/* Set a MAC change in hardware */
+static int
+switch_set_mac_address(struct net_device *dev, void *addr)
+{
+	return 0;
+}
+
+static struct ethtool_ops fec_enet_ethtool_ops = {
+	.get_settings           = fec_enet_get_settings,
+	.set_settings           = fec_enet_set_settings,
+	.get_drvinfo            = fec_enet_get_drvinfo,
+	.get_link               = ethtool_op_get_link,
+ };
+static const struct net_device_ops fec_netdev_ops = {
+       .ndo_open               = switch_enet_open,
+       .ndo_stop               = switch_enet_close,
+       .ndo_start_xmit         = switch_enet_start_xmit,
+       .ndo_set_multicast_list = set_multicast_list,
+       .ndo_tx_timeout         = switch_timeout,
+       .ndo_set_mac_address    = switch_set_mac_address,
+};
+
+/* Initialize the FEC Ethernet */
+int __init switch_enet_init(struct net_device *dev,
+	int slot, struct platform_device *pdev)
+{
+	struct switch_enet_private	*fep = netdev_priv(dev);
+	struct resource 	*r;
+	unsigned long		mem_addr;
+	struct cbd_t		*bdp;
+	struct cbd_t		*cbd_base;
+	struct switch_t	*fecp;
+	int	i, j;
+	struct switch_platform_data *plat = pdev->dev.platform_data;
+
+	/* Only allow us to be probed once. */
+	if (slot >= SWITCH_MAX_PORTS)
+		return -ENXIO;
+
+	/* Allocate memory for buffer descriptors */
+	mem_addr = __get_free_page(GFP_DMA);
+	if (mem_addr == 0) {
+		printk(KERN_ERR "Switch: allocate descriptor memory failed?\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&fep->hw_lock);
+	spin_lock_init(&fep->mii_lock);
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r)
+		return -ENXIO;
+
+	r = request_mem_region(r->start, resource_size(r), pdev->name);
+	if (!r)
+		return -EBUSY;
+
+	fep->enet_addr = ioremap(r->start, resource_size(r));
+
+	dev->irq = platform_get_irq(pdev, 0);
+
+	/*
+	 * Create an Ethernet device instance.
+	 * The switch lookup address memory start 0x800FC000
+	 */
+	fecp = (struct switch_t *)(fep->enet_addr + ENET_SWI_PHYS_ADDR_OFFSET
+		/ sizeof(unsigned long));
+	plat->switch_hw[1] = (unsigned long)fecp + MCF_ESW_LOOKUP_MEM_OFFSET;
+
+	fep->index = slot;
+	fep->hwp = fecp;
+	fep->hwentry = (struct eswAddrTable_t *)plat->switch_hw[1];
+	fep->netdev = dev;
+#ifdef CONFIG_FEC_SHARED_PHY
+	fep->phy_hwp = (struct switch_t *) plat->switch_hw[slot & ~1];
+#else
+	fep->phy_hwp = fecp;
+#endif
+
+	fep->clk = clk_get(&pdev->dev, "fec_clk");
+	if (IS_ERR(fep->clk))
+		return PTR_ERR(fep->clk);
+	clk_enable(fep->clk);
+
+
+	/* PHY reset should be done during clock on */
+	if (plat) {
+		fep->phy_interface = plat->fec_enet->phy;
+		if (plat->fec_enet->init && plat->fec_enet->init())
+			return -EIO;
+	} else
+		fep->phy_interface = PHY_INTERFACE_MODE_MII;
+
+	/*
+	 * SWITCH CONFIGURATION
+	 */
+	fecp->ESW_MODE = MCF_ESW_MODE_SW_RST;
+	udelay(10);
+
+	/* enable switch*/
+	fecp->ESW_MODE = MCF_ESW_MODE_STATRST;
+	fecp->ESW_MODE = MCF_ESW_MODE_SW_EN;
+
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0xffffffff;
+	/* Management port configuration,
+	 * make port 0 as management port
+	 */
+	fecp->ESW_BMPC = 0;
+
+	/* clear all switch irq */
+	fecp->switch_ievent = 0xffffffff;
+	fecp->switch_imask  = 0;
+	udelay(10);
+
+	plat->request_intrs = switch_request_intrs;
+	plat->set_mii = switch_set_mii;
+	plat->get_mac = switch_get_mac;
+	plat->enable_phy_intr = switch_enable_phy_intr;
+	plat->disable_phy_intr = switch_disable_phy_intr;
+	plat->phy_ack_intr = switch_phy_ack_intr;
+	plat->localhw_setup = switch_localhw_setup;
+	plat->uncache = switch_uncache;
+	plat->platform_flush_cache = switch_platform_flush_cache;
+
+	/*
+	 * Set the Ethernet address.  If using multiple Enets on the 8xx,
+	 * this needs some work to get unique addresses.
+	 *
+	 * This is our default MAC address unless the user changes
+	 * it via eth_mac_addr (our dev->set_mac_addr handler).
+	 */
+	if (plat && plat->get_mac)
+		plat->get_mac(dev);
+
+	cbd_base = (struct cbd_t *)mem_addr;
+	if (cbd_base == 0) {
+		printk(KERN_ERR "Switch: allocate memory failed?\n");
+		return -ENOMEM;
+	}
+	if (plat && plat->uncache)
+		plat->uncache(mem_addr);
+
+	/* Set receive and transmit descriptor base */
+	fep->rx_bd_base = cbd_base;
+	fep->tx_bd_base = cbd_base + RX_RING_SIZE;
+
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->cur_rx = fep->rx_bd_base;
+
+	fep->skb_cur = fep->skb_dirty = 0;
+
+	/* Initialize the receive buffer descriptors */
+	bdp = fep->rx_bd_base;
+	for (i = 0; i < SWITCH_ENET_RX_PAGES; i++) {
+
+		/* Allocate a page */
+		mem_addr = __get_free_page(GFP_DMA);
+		if (mem_addr == 0) {
+			printk(KERN_ERR "Switch: allocate memory failed?\n");
+			return -ENOMEM;
+		}
+
+		if (plat && plat->uncache)
+			plat->uncache(mem_addr);
+
+		/* Initialize the BD for every fragment in the page */
+		for (j = 0; j < SWITCH_ENET_RX_FRPPG; j++) {
+			bdp->cbd_sc = BD_ENET_RX_EMPTY;
+			bdp->cbd_bufaddr = __pa(mem_addr);
+#ifdef MODELO_BUFFER
+			bdp->bdu = 0x00000000;
+			bdp->ebd_status = RX_BD_INT;
+#endif
+			mem_addr += SWITCH_ENET_RX_FRSIZE;
+			bdp++;
+		}
+	}
+
+	/* Set the last buffer to wrap */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* ...and the same for transmmit */
+	bdp = fep->tx_bd_base;
+	for (i = 0, j = SWITCH_ENET_TX_FRPPG; i < TX_RING_SIZE; i++) {
+		if (j >= SWITCH_ENET_TX_FRPPG) {
+			mem_addr = __get_free_page(GFP_DMA);
+			j = 1;
+		} else {
+			mem_addr += SWITCH_ENET_TX_FRSIZE;
+			j++;
+		}
+		fep->tx_bounce[i] = (unsigned char *) mem_addr;
+
+		/* Initialize the BD for every fragment in the page */
+		bdp->cbd_sc = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* Set receive and transmit descriptor base */
+	fecp->fec_r_des_start = __pa((uint)(fep->rx_bd_base));
+	fecp->fec_x_des_start = __pa((uint)(fep->tx_bd_base));
+
+	/*
+	 * Install our interrupt handlers. This varies depending on
+	 * the architecture.
+	 */
+	if (plat && plat->request_intrs)
+		plat->request_intrs(dev, switch_enet_interrupt, dev);
+
+	/*
+	 * fecp->fec_grp_hash_table_high = 0;
+	 * fecp->fec_grp_hash_table_low = 0;
+	 */
+	fecp->fec_r_buff_size = RX_BUFFER_SIZE;
+	/* fecp->fec_r_buff_size = PKT_MAXBLR_SIZE; */
+	fecp->fec_r_des_active = MCF_ESW_RDAR_R_DES_ACTIVE;
+	/*
+	 * if (plat->hash_table == 0) {
+	 *	fecp->fec_hash_table_high = 0;
+	 *	fecp->fec_hash_table_low = 0;
+	 * }
+	 */
+
+	dev->base_addr = (unsigned long)fecp;
+
+	/* The FEC Ethernet specific entries in the device structure. */
+	dev->netdev_ops = &fec_netdev_ops;
+	dev->ethtool_ops = &fec_enet_ethtool_ops;
+
+	/* setup MII interface */
+	if (plat && plat->set_mii)
+		plat->set_mii(dev);
+
+	/* Clear and enable interrupts */
+	fecp->switch_ievent = 0xffffffff;
+	fecp->switch_imask  = MCF_ESW_IMR_RXB | MCF_ESW_IMR_TXB |
+		MCF_ESW_IMR_RXF | MCF_ESW_IMR_TXF;
+	esw_clear_atable(fep);
+
+#ifndef CONFIG_FEC_SHARED_PHY
+	fep->phy_addr = 0;
+#else
+	fep->phy_addr = fep->index;
+#endif
+
+	fep->sequence_done = 1;
+	return 0;
+}
+
+/*
+ * This function is called to start or restart the FEC during a link
+ * change.  This only happens when switching between half and full
+ * duplex.
+ */
+static void
+switch_restart(struct net_device *dev, int duplex)
+{
+	struct switch_enet_private *fep;
+	struct cbd_t *bdp;
+	struct switch_t *fecp;
+	int i;
+	struct switch_platform_data *plat;
+
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
+	plat = fep->pdev->dev.platform_data;
+	/*
+	 * Whack a reset.  We should wait for this.
+	 */
+	/* fecp->fec_ecntrl = 1; */
+	fecp->ESW_MODE = MCF_ESW_MODE_SW_RST;
+	udelay(10);
+	fecp->ESW_MODE = MCF_ESW_MODE_STATRST;
+	fecp->ESW_MODE = MCF_ESW_MODE_SW_EN;
+
+	/* Enable transmit/receive on all ports */
+	fecp->ESW_PER = 0xffffffff;
+	/*
+	 * Management port configuration,
+	 * make port 0 as management port
+	 */
+	fecp->ESW_BMPC = 0;
+
+	/* Clear any outstanding interrupt */
+	fecp->switch_ievent = 0xffffffff;
+	/*if (plat && plat->enable_phy_intr)
+	 *	plat->enable_phy_intr();
+	 */
+
+	/* Set station address */
+	switch_set_mac_address(dev, NULL);
+
+	/* Reset all multicast */
+	/*
+	 * fecp->fec_grp_hash_table_high = 0;
+	 *fecp->fec_grp_hash_table_low = 0;
+	 */
+
+	/* Set maximum receive buffer size */
+	fecp->fec_r_buff_size = PKT_MAXBLR_SIZE;
+
+	if (plat && plat->localhw_setup)
+		plat->localhw_setup();
+	/* Set receive and transmit descriptor base */
+	fecp->fec_r_des_start = __pa((uint)(fep->rx_bd_base));
+	fecp->fec_x_des_start = __pa((uint)(fep->tx_bd_base));
+
+	fep->dirty_tx = fep->cur_tx = fep->tx_bd_base;
+	fep->cur_rx = fep->rx_bd_base;
+
+	/* Reset SKB transmit buffers */
+	fep->skb_cur = fep->skb_dirty = 0;
+	for (i = 0; i <= TX_RING_MOD_MASK; i++) {
+		if (fep->tx_skbuff[i] != NULL) {
+			dev_kfree_skb_any(fep->tx_skbuff[i]);
+			fep->tx_skbuff[i] = NULL;
+		}
+	}
+
+	/* Initialize the receive buffer descriptors */
+	bdp = fep->rx_bd_base;
+	for (i = 0; i < RX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page */
+		bdp->cbd_sc = BD_ENET_RX_EMPTY;
+#ifdef MODELO_BUFFER
+		bdp->bdu = 0x00000000;
+		bdp->ebd_status = RX_BD_INT;
+#endif
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	/* ...and the same for transmmit */
+	bdp = fep->tx_bd_base;
+	for (i = 0; i < TX_RING_SIZE; i++) {
+
+		/* Initialize the BD for every fragment in the page */
+		bdp->cbd_sc = 0;
+		bdp->cbd_bufaddr = 0;
+		bdp++;
+	}
+
+	/* Set the last buffer to wrap */
+	bdp--;
+	bdp->cbd_sc |= BD_SC_WRAP;
+
+	fep->full_duplex = duplex;
+
+	/* And last, enable the transmit and receive processing */
+	fecp->fec_r_buff_size = RX_BUFFER_SIZE;
+	/* fecp->fec_r_buff_size = PKT_MAXBLR_SIZE; */
+	fecp->fec_r_des_active = MCF_ESW_RDAR_R_DES_ACTIVE;
+
+	/* Enable interrupts we wish to service */
+	fecp->switch_ievent = 0xffffffff;
+	fecp->switch_imask  = MCF_ESW_IMR_RXF | MCF_ESW_IMR_TXF |
+		MCF_ESW_IMR_RXB | MCF_ESW_IMR_TXB;
+
+#ifdef SWITCH_DEBUG
+	printk(KERN_INFO "%s: switch hw init over."
+		"isr %x mask %x rx_addr %x %x tx_addr %x %x."
+		"fec_r_buff_size %x\n", __func__,
+		fecp->switch_ievent, fecp->switch_imask, fecp->fec_r_des_start,
+		&fecp->fec_r_des_start, fecp->fec_x_des_start,
+		&fecp->fec_x_des_start, fecp->fec_r_buff_size);
+	printk(KERN_INFO "%s: fecp->ESW_DBCR %x, fecp->ESW_P0FFEN %x fecp->ESW_BKLR %x\n",
+		__func__, fecp->ESW_DBCR, fecp->ESW_P0FFEN, fecp->ESW_BKLR);
+
+	printk(KERN_INFO "fecp->portstats[0].MCF_ESW_POQC %x,"
+		"fecp->portstats[0].MCF_ESW_PMVID %x,"
+		"fecp->portstats[0].MCF_ESW_PMVTAG %x,"
+		"fecp->portstats[0].MCF_ESW_PBL %x\n",
+		fecp->port_statistics_status[0].MCF_ESW_POQC,
+		fecp->port_statistics_status[0].MCF_ESW_PMVID,
+		fecp->port_statistics_status[0].MCF_ESW_PMVTAG,
+		fecp->port_statistics_status[0].MCF_ESW_PBL);
+
+	printk(KERN_INFO "fecp->portstats[1].MCF_ESW_POQC %x,"
+		"fecp->portstats[1].MCF_ESW_PMVID %x,"
+		"fecp->portstats[1].MCF_ESW_PMVTAG %x,"
+		"fecp->portstats[1].MCF_ESW_PBL %x\n",
+		fecp->port_statistics_status[1].MCF_ESW_POQC,
+		fecp->port_statistics_status[1].MCF_ESW_PMVID,
+		fecp->port_statistics_status[1].MCF_ESW_PMVTAG,
+		fecp->port_statistics_status[1].MCF_ESW_PBL);
+
+	printk(KERN_INFO "fecp->portstats[2].MCF_ESW_POQC %x,"
+		"fecp->portstats[2].MCF_ESW_PMVID %x,"
+		"fecp->portstats[2].MCF_ESW_PMVTAG %x,"
+		"fecp->portstats[2].MCF_ESW_PBL %x\n",
+		fecp->port_statistics_status[2].MCF_ESW_POQC,
+		fecp->port_statistics_status[2].MCF_ESW_PMVID,
+		fecp->port_statistics_status[2].MCF_ESW_PMVTAG,
+		fecp->port_statistics_status[2].MCF_ESW_PBL);
+#endif
+}
+
+static void
+switch_stop(struct net_device *dev)
+{
+	struct switch_t *fecp;
+	struct switch_enet_private *fep;
+	struct switch_platform_data *plat;
+
+#ifdef SWITCH_DEBUG
+	printk(KERN_ERR "%s\n", __func__);
+#endif
+	fep = netdev_priv(dev);
+	fecp = fep->hwp;
+	plat = fep->pdev->dev.platform_data;
+	/* We cannot expect a graceful transmit stop without link !!! */
+	if (fep->link)
+		udelay(10);
+
+	/* Whack a reset.  We should wait for this */
+	udelay(10);
+}
+
+#ifdef FEC_PHY
+static int fec_mdio_register(struct net_device *dev,
+	int slot)
+{
+	int err = 0;
+	struct switch_enet_private *fep = netdev_priv(dev);
+
+	fep->mdio_bus = mdiobus_alloc();
+	if (!fep->mdio_bus) {
+		printk(KERN_ERR "ethernet switch mdiobus_alloc fail\n");
+		return -ENOMEM;
+	}
+
+	if (slot == 0) {
+		fep->mdio_bus->name = "FEC switch MII 0 Bus";
+		strcpy(fep->mdio_bus->id, "0");
+	} else if (slot == 1) {
+		fep->mdio_bus->name = "FEC switch MII 1 Bus";
+		strcpy(fep->mdio_bus->id, "1");
+	} else {
+		printk(KERN_ERR "Now Fec switch can not"
+			"support more than 2 mii bus\n");
+	}
+
+	fep->mdio_bus->read = &fec_enet_mdio_read;
+	fep->mdio_bus->write = &fec_enet_mdio_write;
+	fep->mdio_bus->priv = dev;
+	err = mdiobus_register(fep->mdio_bus);
+	if (err) {
+		mdiobus_free(fep->mdio_bus);
+		printk(KERN_ERR "%s: ethernet mdiobus_register fail\n",
+			dev->name);
+		return -EIO;
+	}
+
+	printk(KERN_INFO "mdiobus_register %s ok\n",
+		fep->mdio_bus->name);
+	return err;
+}
+#endif
+
+static int __init eth_switch_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	int i, err;
+	struct switch_enet_private *fep;
+	struct switch_platform_private *chip;
+
+	printk(KERN_INFO "Ethernet Switch Version 1.0\n");
+	chip = kzalloc(sizeof(struct switch_platform_private) +
+		sizeof(struct switch_enet_private *) * SWITCH_MAX_PORTS,
+		GFP_KERNEL);
+	if (!chip) {
+		err = -ENOMEM;
+		printk(KERN_ERR "%s: kzalloc fail %x\n", __func__,
+			(unsigned int)chip);
+		return err;
+	}
+
+	chip->pdev = pdev;
+	chip->num_slots = SWITCH_MAX_PORTS;
+	platform_set_drvdata(pdev, chip);
+
+	for (i = 0; (i < chip->num_slots); i++) {
+		dev = alloc_etherdev(sizeof(struct switch_enet_private));
+		if (!dev) {
+			printk(KERN_ERR "%s: ethernet switch\
+				 alloc_etherdev fail\n",
+				dev->name);
+			return -ENOMEM;
+		}
+
+		fep = netdev_priv(dev);
+		fep->pdev = pdev;
+		printk(KERN_ERR "%s: ethernet switch port %d init\n",
+			__func__, i);
+		err = switch_enet_init(dev, i, pdev);
+		if (err) {
+			free_netdev(dev);
+			platform_set_drvdata(pdev, NULL);
+			kfree(chip);
+			continue;
+		}
+
+		chip->fep_host[i] = fep;
+		/* disable mdio */
+#ifdef FEC_PHY
+#ifdef CONFIG_FEC_SHARED_PHY
+		if (i == 0)
+			err = fec_mdio_register(dev, 0);
+		else {
+			fep->mdio_bus = chip->fep_host[0]->mdio_bus;
+			printk(KERN_INFO "FEC%d SHARED the %s ok\n",
+				i, fep->mdio_bus->name);
+		}
+#else
+		err = fec_mdio_register(dev, i);
+#endif
+		if (err) {
+			printk(KERN_ERR "%s: ethernet switch fec_mdio_register\n",
+				dev->name);
+			free_netdev(dev);
+			platform_set_drvdata(pdev, NULL);
+			kfree(chip);
+			return -ENOMEM;
+		}
+#endif
+		/* setup timer for Learning  Aging function */
+		/*
+		 * setup_timer(&fep->timer_aging,
+		 *	l2switch_aging_timer, (unsigned long)fep);
+		 */
+		init_timer(&fep->timer_aging);
+		fep->timer_aging.function = l2switch_aging_timer;
+		fep->timer_aging.data = (unsigned long) fep;
+		fep->timer_aging.expires = jiffies + LEARNING_AGING_TIMER;
+
+		/* register network device */
+		if (register_netdev(dev) != 0) {
+			free_netdev(dev);
+			platform_set_drvdata(pdev, NULL);
+			kfree(chip);
+			printk(KERN_ERR "%s: ethernet switch register_netdev fail\n",
+				dev->name);
+			return -EIO;
+		}
+		printk(KERN_INFO "%s: ethernet switch %pM\n",
+				dev->name, dev->dev_addr);
+	}
+
+	return 0;
+}
+
+static int eth_switch_remove(struct platform_device *pdev)
+{
+	int i;
+	struct net_device *dev;
+	struct switch_enet_private *fep;
+	struct switch_platform_private *chip;
+
+	chip = platform_get_drvdata(pdev);
+	if (chip) {
+		for (i = 0; i < chip->num_slots; i++) {
+			fep = chip->fep_host[i];
+			dev = fep->netdev;
+			fep->sequence_done = 1;
+			unregister_netdev(dev);
+			free_netdev(dev);
+
+			del_timer_sync(&fep->timer_aging);
+		}
+
+		platform_set_drvdata(pdev, NULL);
+		kfree(chip);
+
+	} else
+		printk(KERN_ERR "%s: can not get the "
+			"switch_platform_private %x\n", __func__,
+			(unsigned int)chip);
+
+	return 0;
+}
+
+static struct platform_driver eth_switch_driver = {
+	.probe          = eth_switch_probe,
+	.remove         = eth_switch_remove,
+	.driver         = {
+		.name   = "mxs-l2switch",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init fec_l2switch_init(void)
+{
+	return platform_driver_register(&eth_switch_driver);;
+}
+
+static void __exit fec_l2_switch_exit(void)
+{
+	platform_driver_unregister(&eth_switch_driver);
+}
+
+module_init(fec_l2switch_init);
+module_exit(fec_l2_switch_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/fec_switch.h b/drivers/net/fec_switch.h
new file mode 100644
index 0000000..e1e8a4c
--- /dev/null
+++ b/drivers/net/fec_switch.h
@@ -0,0 +1,989 @@
+/****************************************************************************/
+
+/*
+ *	mcfswitch -- L2 Switch Controller for Modelo ColdFire SoC
+ *		   processors.
+ *
+ *      Copyright (C) 2010 Freescale Semiconductor,Inc.All rights reserved.
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or (at
+ *     your option) any later version.
+ *
+ */
+
+/****************************************************************************/
+#ifndef SWITCH_H
+#define	SWITCH_H
+/****************************************************************************/
+/* The Switch stores dest/src/type, data, and checksum for receive packets.
+ */
+#define PKT_MAXBUF_SIZE         1518
+#define PKT_MINBUF_SIZE         64
+#define PKT_MAXBLR_SIZE         1520
+
+/*
+ * The 5441x RX control register also contains maximum frame
+ * size bits.
+ */
+#define OPT_FRAME_SIZE  (PKT_MAXBUF_SIZE << 16)
+
+/*
+ * Some hardware gets it MAC address out of local flash memory.
+ * if this is non-zero then assume it is the address to get MAC from.
+ */
+#define FEC_FLASHMAC    0
+
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it it best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+#ifdef CONFIG_SWITCH_DMA_USE_SRAM
+#define SWITCH_ENET_RX_PAGES       6
+#else
+#define SWITCH_ENET_RX_PAGES       8
+#endif
+
+#define SWITCH_ENET_RX_FRSIZE      2048
+#define SWITCH_ENET_RX_FRPPG       (PAGE_SIZE / SWITCH_ENET_RX_FRSIZE)
+#define RX_RING_SIZE            (SWITCH_ENET_RX_FRPPG * SWITCH_ENET_RX_PAGES)
+#define SWITCH_ENET_TX_FRSIZE      2048
+#define SWITCH_ENET_TX_FRPPG       (PAGE_SIZE / SWITCH_ENET_TX_FRSIZE)
+
+#ifdef CONFIG_SWITCH_DMA_USE_SRAM
+#define TX_RING_SIZE            8      /* Must be power of two */
+#define TX_RING_MOD_MASK        7      /*   for this to work */
+#else
+#define TX_RING_SIZE            16      /* Must be power of two */
+#define TX_RING_MOD_MASK        15      /*   for this to work */
+#endif
+
+#if (((RX_RING_SIZE + TX_RING_SIZE) * 8) > PAGE_SIZE)
+#error "L2SWITCH: descriptor ring size constants too large"
+#endif
+/*-----------------------------------------------------------------------*/
+struct esw_output_queue_status {
+	unsigned long ESW_MMSR;
+	unsigned long ESW_LMT;
+	unsigned long ESW_LFC;
+	unsigned long ESW_PCSR;
+	unsigned long ESW_IOSR;
+	unsigned long ESW_QWT;
+	unsigned long esw_reserved;
+	unsigned long ESW_P0BCT;
+};
+struct esw_statistics_status {
+	/*
+	 * Total number of incoming frames processed
+	 * but discarded in switch
+	 */
+	unsigned long ESW_DISCN;
+	/*Sum of bytes of frames counted in ESW_DISCN*/
+	unsigned long ESW_DISCB;
+	/*
+	 * Total number of incoming frames processed
+	 * but not discarded in switch
+	 */
+	unsigned long ESW_NDISCN;
+	/*Sum of bytes of frames counted in ESW_NDISCN*/
+	unsigned long ESW_NDISCB;
+};
+
+struct esw_port_statistics_status {
+	/*outgoing frames discarded due to transmit queue congestion*/
+	unsigned long MCF_ESW_POQC;
+	/*incoming frames discarded due to VLAN domain mismatch*/
+	unsigned long MCF_ESW_PMVID;
+	/*incoming frames discarded due to untagged discard*/
+	unsigned long MCF_ESW_PMVTAG;
+	/*incoming frames discarded due port is in blocking state*/
+	unsigned long MCF_ESW_PBL;
+};
+
+struct switch_t {
+	unsigned long ESW_REVISION;
+	unsigned long ESW_SCRATCH;
+	unsigned long ESW_PER;
+	unsigned long reserved0[1];
+	unsigned long ESW_VLANV;
+	unsigned long ESW_DBCR;
+	unsigned long ESW_DMCR;
+	unsigned long ESW_BKLR;
+	unsigned long ESW_BMPC;
+	unsigned long ESW_MODE;
+	unsigned long ESW_VIMSEL;
+	unsigned long ESW_VOMSEL;
+	unsigned long ESW_VIMEN;
+	unsigned long ESW_VID;/*0x34*/
+	/*from 0x38 0x3C*/
+	unsigned long esw_reserved0[2];
+	unsigned long ESW_MCR;/*0x40*/
+	unsigned long ESW_EGMAP;
+	unsigned long ESW_INGMAP;
+	unsigned long ESW_INGSAL;
+	unsigned long ESW_INGSAH;
+	unsigned long ESW_INGDAL;
+	unsigned long ESW_INGDAH;
+	unsigned long ESW_ENGSAL;
+	unsigned long ESW_ENGSAH;
+	unsigned long ESW_ENGDAL;
+	unsigned long ESW_ENGDAH;
+	unsigned long ESW_MCVAL;/*0x6C*/
+	/*from 0x70--0x7C*/
+	unsigned long esw_reserved1[4];
+	unsigned long ESW_MMSR;/*0x80*/
+	unsigned long ESW_LMT;
+	unsigned long ESW_LFC;
+	unsigned long ESW_PCSR;
+	unsigned long ESW_IOSR;
+	unsigned long ESW_QWT;/*0x94*/
+	unsigned long esw_reserved2[1];/*0x98*/
+	unsigned long ESW_P0BCT;/*0x9C*/
+	/*from 0xA0-0xB8*/
+	unsigned long esw_reserved3[7];
+	unsigned long ESW_P0FFEN;/*0xBC*/
+	unsigned long ESW_PSNP[8];
+	unsigned long ESW_IPSNP[8];
+	unsigned long ESW_PVRES[3];
+	/*from 0x10C-0x13C*/
+	unsigned long esw_reserved4[13];
+	unsigned long ESW_IPRES;/*0x140*/
+	/*from 0x144-0x17C*/
+	unsigned long esw_reserved5[15];
+	unsigned long ESW_PRES[3];
+	/*from 0x18C-0x1FC*/
+	unsigned long esw_reserved6[29];
+	unsigned long ESW_PID[3];
+	/*from 0x20C-0x27C*/
+	unsigned long esw_reserved7[29];
+	unsigned long ESW_VRES[32];
+	unsigned long ESW_DISCN;/*0x300*/
+	unsigned long ESW_DISCB;
+	unsigned long ESW_NDISCN;
+	unsigned long ESW_NDISCB;/*0xFC0DC30C*/
+	struct esw_port_statistics_status port_statistics_status[3];
+	/*from 0x340-0x400*/
+	unsigned long esw_reserved8[48];
+
+	/*0xFC0DC400---0xFC0DC418*/
+	/*unsigned long MCF_ESW_ISR;*/
+	unsigned long   switch_ievent;             /* Interrupt event reg */
+	/*unsigned long MCF_ESW_IMR;*/
+	unsigned long   switch_imask;              /* Interrupt mask reg */
+	/*unsigned long MCF_ESW_RDSR;*/
+	unsigned long   fec_r_des_start;        /* Receive descriptor ring */
+	/*unsigned long MCF_ESW_TDSR;*/
+	unsigned long   fec_x_des_start;        /* Transmit descriptor ring */
+	/*unsigned long MCF_ESW_MRBR;*/
+	unsigned long   fec_r_buff_size;        /* Maximum receive buff size */
+	/*unsigned long MCF_ESW_RDAR;*/
+	unsigned long   fec_r_des_active;       /* Receive descriptor reg */
+	/*unsigned long MCF_ESW_TDAR;*/
+	unsigned long   fec_x_des_active;       /* Transmit descriptor reg */
+	/*from 0x420-0x4FC*/
+	unsigned long esw_reserved9[57];
+
+	/*0xFC0DC500---0xFC0DC508*/
+	unsigned long ESW_LREC0;
+	unsigned long ESW_LREC1;
+	unsigned long ESW_LSR;
+};
+
+struct  AddrTable64bEntry {
+	unsigned int lo;  /* lower 32 bits */
+	unsigned int hi;  /* upper 32 bits */
+};
+
+struct  eswAddrTable_t {
+	struct AddrTable64bEntry  eswTable64bEntry[2048];
+};
+
+#define MCF_ESW_LOOKUP_MEM_OFFSET      0x4000
+#define ENET_SWI_PHYS_ADDR_OFFSET	0x8000
+#define MCF_ESW_PER	(0x08 / sizeof(unsigned long))
+#define MCF_ESW_DBCR	(0x14 / sizeof(unsigned long))
+#define MCF_ESW_IMR	(0x404 / sizeof(unsigned long))
+
+#define MCF_FEC_BASE_ADDR	(fep->enet_addr)
+#define MCF_FEC_EIR0		(0x04 / sizeof(unsigned long))
+#define MCF_FEC_EIR1		(0x4004 / sizeof(unsigned long))
+#define MCF_FEC_EIMR0		(0x08 / sizeof(unsigned long))
+#define MCF_FEC_EIMR1		(0x4008 / sizeof(unsigned long))
+#define MCF_FEC_MMFR0		(0x40 / sizeof(unsigned long))
+#define MCF_FEC_MMFR1		(0x4040 / sizeof(unsigned long))
+#define MCF_FEC_MSCR0		(0x44 / sizeof(unsigned long))
+#define MCF_FEC_MSCR1		(0x4044 / sizeof(unsigned long))
+
+#define MCF_FEC_RCR0		(0x84 / sizeof(unsigned long))
+#define MCF_FEC_RCR1		(0x4084 / sizeof(unsigned long))
+#define MCF_FEC_TCR0		(0xC4 / sizeof(unsigned long))
+#define MCF_FEC_TCR1		(0x40C4 / sizeof(unsigned long))
+#define MCF_FEC_ECR0		(0x24 / sizeof(unsigned long))
+#define MCF_FEC_ECR1		(0x4024 / sizeof(unsigned long))
+
+#define MCF_FEC_RCR_PROM                     (0x00000008)
+#define MCF_FEC_RCR_RMII_MODE                (0x00000100)
+#define MCF_FEC_RCR_MAX_FL(x)                (((x)&0x00003FFF)<<16)
+#define MCF_FEC_RCR_CRC_FWD                  (0x00004000)
+
+#define MCF_FEC_TCR_FDEN                     (0x00000004)
+
+#define MCF_FEC_ECR_ETHER_EN                 (0x00000002)
+#define MCF_FEC_ECR_ENA_1588                 (0x00000010)
+
+/*-------------ioctl command ---------------------------------------*/
+#define ESW_SET_LEARNING_CONF               0x9101
+#define ESW_GET_LEARNING_CONF               0x9201
+#define ESW_SET_BLOCKING_CONF               0x9102
+#define ESW_GET_BLOCKING_CONF               0x9202
+#define ESW_SET_MULTICAST_CONF              0x9103
+#define ESW_GET_MULTICAST_CONF              0x9203
+#define ESW_SET_BROADCAST_CONF              0x9104
+#define ESW_GET_BROADCAST_CONF              0x9204
+#define ESW_SET_PORTENABLE_CONF             0x9105
+#define ESW_GET_PORTENABLE_CONF             0x9205
+#define ESW_SET_IP_SNOOP_CONF               0x9106
+#define ESW_GET_IP_SNOOP_CONF               0x9206
+#define ESW_SET_PORT_SNOOP_CONF             0x9107
+#define ESW_GET_PORT_SNOOP_CONF             0x9207
+#define ESW_SET_PORT_MIRROR_CONF            0x9108
+#define ESW_GET_PORT_MIRROR_CONF            0x9208
+#define ESW_SET_PIRORITY_VLAN               0x9109
+#define ESW_GET_PIRORITY_VLAN               0x9209
+#define ESW_SET_PIRORITY_IP                 0x910A
+#define ESW_GET_PIRORITY_IP                 0x920A
+#define ESW_SET_PIRORITY_MAC                0x910B
+#define ESW_GET_PIRORITY_MAC                0x920B
+#define ESW_SET_PIRORITY_DEFAULT            0x910C
+#define ESW_GET_PIRORITY_DEFAULT            0x920C
+
+#define ESW_GET_STATISTICS_STATUS           0x9221
+#define ESW_GET_PORT0_STATISTICS_STATUS     0x9222
+#define ESW_GET_PORT1_STATISTICS_STATUS     0x9223
+#define ESW_GET_PORT2_STATISTICS_STATUS     0x9224
+#define ESW_GET_OUTPUT_QUEUE_STATUS         0x9225
+
+struct eswIoctlPortConfig {
+	int port;
+	int enable;
+};
+
+struct  eswIoctlPortEnableConfig {
+	int port;
+	int tx_enable;
+	int rx_enable;
+};
+
+struct  eswIoctlIpsnoopConfig {
+	int num;
+	int mode;
+	unsigned long ip_header_protocol;
+};
+
+struct  eswIoctlPortsnoopConfig {
+     int num;
+     int mode;
+     int compare_port;
+     int compare_num;
+};
+
+struct  eswIoctlPortMirrorConfig {
+	int mirror_port;
+	int port;
+	unsigned char *src_mac;
+	unsigned char *des_mac;
+	int egress_en;
+	int ingress_en;
+	int egress_mac_src_en;
+	int egress_mac_des_en;
+	int ingress_mac_src_en;
+	int ingress_mac_des_en;
+};
+
+struct  eswIoctlPriorityVlanConfig {
+	int port;
+	int func_enable;
+	int vlan_pri_table_num;
+	int vlan_pri_table_value;
+};
+
+struct eswIoctlPriorityIPConfig {
+	int port;
+	int func_enable;
+	int ipv4_en;
+	int ip_priority_num;
+	int ip_priority_value;
+};
+
+struct  eswIoctlPriorityMacConfig {
+	int port;
+};
+
+struct  eswIoctlPriorityDefaultConfig{
+	int port;
+	unsigned char priority_value;
+};
+/*=============================================================*/
+#define LEARNING_AGING_TIMER (10 * HZ)
+/*
+ * Info received from Hardware Learning FIFO,
+ * holding MAC address and corresponding Hash Value and
+ * port number where the frame was received (disassembled).
+ */
+struct eswPortInfo {
+	/* MAC lower 32 bits (first byte is 7:0). */
+	unsigned int   maclo;
+	/* MAC upper 16 bits (47:32). */
+	unsigned int   machi;
+	/* the hash value for this MAC address. */
+	unsigned int   hash;
+	/* the port number this MAC address is associated with. */
+	unsigned int   port;
+};
+
+/*
+ * Hardware Look up Address Table 64-bit element.
+ */
+struct eswTable64bitEntry {
+	unsigned int lo;  /* lower 32 bits */
+	unsigned int hi;  /* upper 32 bits */
+};
+
+/*
+ * Disassembled element stored in Address Table.
+ */
+struct eswAddrTableDynamicEntry {
+	/* MAC lower 32 bits (first byte is 7:0). */
+	unsigned int maclo;
+	/* MAC upper 16 bits (47:32). */
+	unsigned int machi;
+	/* timestamp of this entry */
+	unsigned int timestamp;
+	/* the port number this MAC address is associated with */
+	unsigned int port;
+};
+
+struct eswAddrTableStaticEntry {
+	/* MAC lower 32 bits (first byte is 7:0). */
+	unsigned int maclo;
+	/* MAC upper 16 bits (47:32). */
+	unsigned int machi;
+	/* priority of this entry */
+	unsigned int priority;
+	/* the port bitmask this MAC address is associated with */
+	unsigned int portbitmask;
+};
+/*
+ *	Define the buffer descriptor structure.
+ */
+struct cbd_t {
+	unsigned short	cbd_sc;			/* Control and status info */
+	unsigned short	cbd_datlen;		/* Data length */
+	unsigned long	cbd_bufaddr;		/* Buffer address */
+#ifdef MODELO_BUFFER
+	unsigned long   ebd_status;
+	unsigned short  length_proto_type;
+	unsigned short  payload_checksum;
+	unsigned long   bdu;
+	unsigned long   timestamp;
+	unsigned long   reserverd_word1;
+	unsigned long   reserverd_word2;
+#endif
+};
+
+/* Forward declarations of some structures to support different PHYs
+ */
+struct phy_cmd_t {
+	uint mii_data;
+	void (*funct)(uint mii_reg, struct net_device *dev);
+};
+
+struct  phy_info_t {
+	uint id;
+	char *name;
+
+	const struct phy_cmd_t *config;
+	const struct phy_cmd_t *startup;
+	const struct phy_cmd_t *ack_int;
+	const struct phy_cmd_t *shutdown;
+};
+
+/* The switch buffer descriptors track the ring buffers.  The rx_bd_base and
+ * tx_bd_base always point to the base of the buffer descriptors.  The
+ * cur_rx and cur_tx point to the currently available buffer.
+ * The dirty_tx tracks the current buffer that is being sent by the
+ * controller.  The cur_tx and dirty_tx are equal under both completely
+ * empty and completely full conditions.  The empty/ready indicator in
+ * the buffer descriptor determines the actual condition.
+ */
+struct switch_enet_private {
+	/* Hardware registers of the switch device */
+	struct switch_t  *hwp;
+	struct eswAddrTable_t  *hwentry;
+	unsigned long *enet_addr;
+
+	struct net_device *netdev;
+	struct platform_device *pdev;
+	struct clk *clk;
+	/* The saved address of a sent-in-place packet/buffer, for skfree(). */
+	unsigned char *tx_bounce[TX_RING_SIZE];
+	struct  sk_buff *tx_skbuff[TX_RING_SIZE];
+	ushort  skb_cur;
+	ushort  skb_dirty;
+
+	/* CPM dual port RAM relative addresses.
+	 */
+	struct cbd_t   *rx_bd_base;	/* Address of Rx and Tx buffers. */
+	struct cbd_t   *tx_bd_base;
+	struct cbd_t   *cur_rx, *cur_tx;	/* The next free ring entry */
+	struct cbd_t   *dirty_tx;      /* The ring entries to be free()ed. */
+	uint    tx_full;
+	/* hold while accessing the HW like ringbuffer for tx/rx but not MAC */
+	spinlock_t hw_lock;
+
+	/* hold while accessing the mii_list_t() elements */
+	spinlock_t mii_lock;
+	struct mii_bus *mdio_bus;
+	struct phy_device *phydev;
+	phy_interface_t phy_interface;
+
+	uint    phy_id;
+	uint    phy_id_done;
+	uint    phy_status;
+	struct	phy_info_t const        *phy;
+	struct work_struct phy_task;
+	struct switch_t  *phy_hwp;
+
+	uint    sequence_done;
+	uint    mii_phy_task_queued;
+
+	uint    phy_addr;
+
+	int     opened;
+	int     old_link;
+	int     duplex;
+	int     speed;
+	int     msg_enable;
+
+	/* --------------Statistics--------------------------- */
+	/* when a new element deleted a element with in
+	 * a block due to lack of space */
+	int atBlockOverflows;
+	/* Peak number of valid entries in the address table */
+	int atMaxEntries;
+	/* current number of valid entries in the address table */
+	int atCurrEntries;
+	/* maximum entries within a block found
+	 * (updated within ageing)*/
+	int atMaxEntriesPerBlock;
+
+	/* -------------------ageing function------------------ */
+	/* maximum age allowed for an entry */
+	int ageMax;
+	/* last LUT entry to block that was
+	 * inspected by the Ageing task*/
+	int ageLutIdx;
+	/* last element within block inspected by the Ageing task */
+	int ageBlockElemIdx;
+	/* complete table has been processed by ageing process */
+	int ageCompleted;
+	/* delay setting */
+	int ageDelay;
+	/* current delay Counter */
+	int  ageDelayCnt;
+
+	/* ----------------timer related---------------------------- */
+	/* current time (for timestamping) */
+	int currTime;
+	/* flag set by timer when currTime changed
+	 * and cleared by serving function*/
+	int timeChanged;
+
+	/**/
+	/* Timer for Aging */
+	struct timer_list       timer_aging;
+	/* Phylib and MDIO interface */
+	struct  mii_bus *mii_bus;
+	struct  phy_device *phy_dev;
+	int     mii_timeout;
+	uint    phy_speed;
+	int     index;
+	int     link;
+	int     full_duplex;
+};
+
+struct switch_platform_private {
+	struct platform_device  *pdev;
+
+	unsigned long           quirks;
+	int                     num_slots;      /* Slots on controller */
+	struct switch_enet_private *fep_host[0];      /* Pointers to hosts */
+};
+
+/******************************************************************************/
+#define FEC_IEVENT		0x004 /* Interrupt event reg */
+#define FEC_IMASK		0x008 /* Interrupt mask reg */
+#define FEC_R_DES_ACTIVE	0x010 /* Receive descriptor reg */
+#define FEC_X_DES_ACTIVE	0x014 /* Transmit descriptor reg */
+#define FEC_ECNTRL		0x024 /* Ethernet control reg */
+#define FEC_MII_DATA		0x040 /* MII manage frame reg */
+#define FEC_MII_SPEED		0x044 /* MII speed control reg */
+#define FEC_MIB_CTRLSTAT	0x064 /* MIB control/status reg */
+#define FEC_R_CNTRL		0x084 /* Receive control reg */
+#define FEC_X_CNTRL		0x0c4 /* Transmit Control reg */
+#define FEC_ADDR_LOW		0x0e4 /* Low 32bits MAC address */
+#define FEC_ADDR_HIGH		0x0e8 /* High 16bits MAC address */
+#define FEC_OPD			0x0ec /* Opcode + Pause duration */
+#define FEC_HASH_TABLE_HIGH	0x118 /* High 32bits hash table */
+#define FEC_HASH_TABLE_LOW	0x11c /* Low 32bits hash table */
+#define FEC_GRP_HASH_TABLE_HIGH	0x120 /* High 32bits hash table */
+#define FEC_GRP_HASH_TABLE_LOW	0x124 /* Low 32bits hash table */
+#define FEC_X_WMRK		0x144 /* FIFO transmit water mark */
+#define FEC_R_BOUND		0x14c /* FIFO receive bound reg */
+#define FEC_R_FSTART		0x150 /* FIFO receive start reg */
+#define FEC_R_DES_START		0x180 /* Receive descriptor ring */
+#define FEC_X_DES_START		0x184 /* Transmit descriptor ring */
+#define FEC_R_BUFF_SIZE		0x188 /* Maximum receive buff size */
+#define FEC_MIIGSK_CFGR		0x300 /* MIIGSK config register */
+#define FEC_MIIGSK_ENR		0x308 /* MIIGSK enable register */
+
+/* Recieve is empty */
+#define BD_SC_EMPTY     ((unsigned short)0x8000)
+/* Transmit is ready */
+#define BD_SC_READY     ((unsigned short)0x8000)
+/* Last buffer descriptor */
+#define BD_SC_WRAP      ((unsigned short)0x2000)
+/* Interrupt on change */
+#define BD_SC_INTRPT    ((unsigned short)0x1000)
+/* Continous mode */
+#define BD_SC_CM        ((unsigned short)0x0200)
+/* Rec'd too many idles */
+#define BD_SC_ID        ((unsigned short)0x0100)
+/* xmt preamble */
+#define BD_SC_P         ((unsigned short)0x0100)
+/* Break received */
+#define BD_SC_BR        ((unsigned short)0x0020)
+/* Framing error */
+#define BD_SC_FR        ((unsigned short)0x0010)
+/* Parity error */
+#define BD_SC_PR        ((unsigned short)0x0008)
+/* Overrun */
+#define BD_SC_OV        ((unsigned short)0x0002)
+#define BD_SC_CD        ((unsigned short)0x0001)
+
+/* Buffer descriptor control/status used by Ethernet receive.
+*/
+#define BD_ENET_RX_EMPTY        ((unsigned short)0x8000)
+#define BD_ENET_RX_WRAP         ((unsigned short)0x2000)
+#define BD_ENET_RX_INTR         ((unsigned short)0x1000)
+#define BD_ENET_RX_LAST         ((unsigned short)0x0800)
+#define BD_ENET_RX_FIRST        ((unsigned short)0x0400)
+#define BD_ENET_RX_MISS         ((unsigned short)0x0100)
+#define BD_ENET_RX_LG           ((unsigned short)0x0020)
+#define BD_ENET_RX_NO           ((unsigned short)0x0010)
+#define BD_ENET_RX_SH           ((unsigned short)0x0008)
+#define BD_ENET_RX_CR           ((unsigned short)0x0004)
+#define BD_ENET_RX_OV           ((unsigned short)0x0002)
+#define BD_ENET_RX_CL           ((unsigned short)0x0001)
+/* All status bits */
+#define BD_ENET_RX_STATS        ((unsigned short)0x013f)
+
+/* Buffer descriptor control/status used by Ethernet transmit.
+*/
+#define BD_ENET_TX_READY        ((unsigned short)0x8000)
+#define BD_ENET_TX_PAD          ((unsigned short)0x4000)
+#define BD_ENET_TX_WRAP         ((unsigned short)0x2000)
+#define BD_ENET_TX_INTR         ((unsigned short)0x1000)
+#define BD_ENET_TX_LAST         ((unsigned short)0x0800)
+#define BD_ENET_TX_TC           ((unsigned short)0x0400)
+#define BD_ENET_TX_DEF          ((unsigned short)0x0200)
+#define BD_ENET_TX_HB           ((unsigned short)0x0100)
+#define BD_ENET_TX_LC           ((unsigned short)0x0080)
+#define BD_ENET_TX_RL           ((unsigned short)0x0040)
+#define BD_ENET_TX_RCMASK       ((unsigned short)0x003c)
+#define BD_ENET_TX_UN           ((unsigned short)0x0002)
+#define BD_ENET_TX_CSL          ((unsigned short)0x0001)
+/* All status bits */
+#define BD_ENET_TX_STATS        ((unsigned short)0x03ff)
+
+/*Copy from validation code */
+#define RX_BUFFER_SIZE 256
+#define TX_BUFFER_SIZE 256
+#define NUM_RXBDS 20
+#define NUM_TXBDS 20
+
+#define TX_BD_R                 0x8000
+#define TX_BD_TO1               0x4000
+#define TX_BD_W                 0x2000
+#define TX_BD_TO2               0x1000
+#define TX_BD_L                 0x0800
+#define TX_BD_TC                0x0400
+
+#define TX_BD_INT       0x40000000
+#define TX_BD_TS        0x20000000
+#define TX_BD_PINS      0x10000000
+#define TX_BD_IINS      0x08000000
+#define TX_BD_TXE       0x00008000
+#define TX_BD_UE        0x00002000
+#define TX_BD_EE        0x00001000
+#define TX_BD_FE        0x00000800
+#define TX_BD_LCE       0x00000400
+#define TX_BD_OE        0x00000200
+#define TX_BD_TSE       0x00000100
+#define TX_BD_BDU       0x80000000
+
+#define RX_BD_E                 0x8000
+#define RX_BD_R01               0x4000
+#define RX_BD_W                 0x2000
+#define RX_BD_R02               0x1000
+#define RX_BD_L                 0x0800
+#define RX_BD_M                 0x0100
+#define RX_BD_BC                0x0080
+#define RX_BD_MC                0x0040
+#define RX_BD_LG                0x0020
+#define RX_BD_NO                0x0010
+#define RX_BD_CR                0x0004
+#define RX_BD_OV                0x0002
+#define RX_BD_TR                0x0001
+
+#define RX_BD_ME               0x80000000
+#define RX_BD_PE               0x04000000
+#define RX_BD_CE               0x02000000
+#define RX_BD_UC               0x01000000
+#define RX_BD_INT              0x00800000
+#define RX_BD_ICE              0x00000020
+#define RX_BD_PCR              0x00000010
+#define RX_BD_VLAN             0x00000004
+#define RX_BD_IPV6             0x00000002
+#define RX_BD_FRAG             0x00000001
+#define RX_BD_BDU              0x80000000
+/****************************************************************************/
+
+/* Address Table size in bytes(2048 64bit entry ) */
+#define ESW_ATABLE_MEM_SIZE         (2048*8)
+/* How many 64-bit elements fit in the address table */
+#define ESW_ATABLE_MEM_NUM_ENTRIES  (2048)
+/* Address Table Maximum number of entries in each Slot */
+#define ATABLE_ENTRY_PER_SLOT 8
+/* log2(ATABLE_ENTRY_PER_SLOT)*/
+#define ATABLE_ENTRY_PER_SLOT_bits 3
+/* entry size in byte */
+#define ATABLE_ENTRY_SIZE     8
+/*  slot size in byte */
+#define ATABLE_SLOT_SIZE    (ATABLE_ENTRY_PER_SLOT * ATABLE_ENTRY_SIZE)
+/* width of timestamp variable (bits) within address table entry */
+#define AT_DENTRY_TIMESTAMP_WIDTH    10
+/* number of bits for port number storage */
+#define AT_DENTRY_PORT_WIDTH     4
+/* number of bits for port bitmask number storage */
+#define AT_SENTRY_PORT_WIDTH     11
+/* address table static entry port bitmask start address bit */
+#define AT_SENTRY_PORTMASK_shift     21
+/* address table static entry priority start address bit */
+#define AT_SENTRY_PRIO_shift     18
+/* address table dynamic entry port start address bit */
+#define AT_DENTRY_PORT_shift     28
+/* address table dynamic entry timestamp start address bit */
+#define AT_DENTRY_TIME_shift     18
+/* address table entry record type start address bit */
+#define AT_ENTRY_TYPE_shift     17
+/* address table entry record type bit: 1 static, 0 dynamic */
+#define AT_ENTRY_TYPE_STATIC      1
+#define AT_ENTRY_TYPE_DYNAMIC     0
+/* address table entry record valid start address bit */
+#define AT_ENTRY_VALID_shift     16
+#define AT_ENTRY_RECORD_VALID     1
+
+
+/* return block corresponding to the 8 bit hash value calculated */
+#define GET_BLOCK_PTR(hash)  (hash << 3)
+#define AT_EXTRACT_TIMESTAMP(x) \
+	((x >> AT_DENTRY_TIME_shift) & ((1 << AT_DENTRY_TIMESTAMP_WIDTH)-1))
+#define AT_EXTRACT_PORT(x)   \
+	((x >> AT_DENTRY_PORT_shift) & ((1 << AT_DENTRY_PORT_WIDTH)-1))
+#define TIMEDELTA(newtime, oldtime) \
+	 ((newtime - oldtime) & \
+	  ((1 << AT_DENTRY_TIMESTAMP_WIDTH)-1))
+/* increment time value respecting modulo. */
+#define TIMEINCREMENT(time) \
+	((time) = ((time)+1) & ((1 << AT_DENTRY_TIMESTAMP_WIDTH)-1))
+/* ------------------------------------------------------------------------- */
+/* Bit definitions and macros for MCF_ESW_REVISION */
+#define MCF_ESW_REVISION_CORE_REVISION(x)      (((x)&0x0000FFFF)<<0)
+#define MCF_ESW_REVISION_CUSTOMER_REVISION(x)  (((x)&0x0000FFFF)<<16)
+
+/* Bit definitions and macros for MCF_ESW_PER */
+#define MCF_ESW_PER_TE0                        (0x00000001)
+#define MCF_ESW_PER_TE1                        (0x00000002)
+#define MCF_ESW_PER_TE2                        (0x00000004)
+#define MCF_ESW_PER_RE0                        (0x00010000)
+#define MCF_ESW_PER_RE1                        (0x00020000)
+#define MCF_ESW_PER_RE2                        (0x00040000)
+
+/* Bit definitions and macros for MCF_ESW_VLANV */
+#define MCF_ESW_VLANV_VV0                      (0x00000001)
+#define MCF_ESW_VLANV_VV1                      (0x00000002)
+#define MCF_ESW_VLANV_VV2                      (0x00000004)
+#define MCF_ESW_VLANV_DU0                      (0x00010000)
+#define MCF_ESW_VLANV_DU1                      (0x00020000)
+#define MCF_ESW_VLANV_DU2                      (0x00040000)
+
+/* Bit definitions and macros for MCF_ESW_DBCR */
+#define MCF_ESW_DBCR_P0                        (0x00000001)
+#define MCF_ESW_DBCR_P1                        (0x00000002)
+#define MCF_ESW_DBCR_P2                        (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_DMCR */
+#define MCF_ESW_DMCR_P0                        (0x00000001)
+#define MCF_ESW_DMCR_P1                        (0x00000002)
+#define MCF_ESW_DMCR_P2                        (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_BKLR */
+#define MCF_ESW_BKLR_BE0                       (0x00000001)
+#define MCF_ESW_BKLR_BE1                       (0x00000002)
+#define MCF_ESW_BKLR_BE2                       (0x00000004)
+#define MCF_ESW_BKLR_LD0                       (0x00010000)
+#define MCF_ESW_BKLR_LD1                       (0x00020000)
+#define MCF_ESW_BKLR_LD2                       (0x00040000)
+
+/* Bit definitions and macros for MCF_ESW_BMPC */
+#define MCF_ESW_BMPC_PORT(x)                   (((x)&0x0000000F)<<0)
+#define MCF_ESW_BMPC_MSG_TX                    (0x00000020)
+#define MCF_ESW_BMPC_EN                        (0x00000040)
+#define MCF_ESW_BMPC_DIS                       (0x00000080)
+#define MCF_ESW_BMPC_PRIORITY(x)               (((x)&0x00000007)<<13)
+#define MCF_ESW_BMPC_PORTMASK(x)               (((x)&0x00000007)<<16)
+
+/* Bit definitions and macros for MCF_ESW_MODE */
+#define MCF_ESW_MODE_SW_RST                    (0x00000001)
+#define MCF_ESW_MODE_SW_EN                     (0x00000002)
+#define MCF_ESW_MODE_STOP                      (0x00000080)
+#define MCF_ESW_MODE_CRC_TRAN                  (0x00000100)
+#define MCF_ESW_MODE_P0CT                      (0x00000200)
+#define MCF_ESW_MODE_STATRST                   (0x80000000)
+
+/* Bit definitions and macros for MCF_ESW_VIMSEL */
+#define MCF_ESW_VIMSEL_IM0(x)                  (((x)&0x00000003)<<0)
+#define MCF_ESW_VIMSEL_IM1(x)                  (((x)&0x00000003)<<2)
+#define MCF_ESW_VIMSEL_IM2(x)                  (((x)&0x00000003)<<4)
+
+/* Bit definitions and macros for MCF_ESW_VOMSEL */
+#define MCF_ESW_VOMSEL_OM0(x)                  (((x)&0x00000003)<<0)
+#define MCF_ESW_VOMSEL_OM1(x)                  (((x)&0x00000003)<<2)
+#define MCF_ESW_VOMSEL_OM2(x)                  (((x)&0x00000003)<<4)
+
+/* Bit definitions and macros for MCF_ESW_VIMEN */
+#define MCF_ESW_VIMEN_EN0                      (0x00000001)
+#define MCF_ESW_VIMEN_EN1                      (0x00000002)
+#define MCF_ESW_VIMEN_EN2                      (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_VID */
+#define MCF_ESW_VID_TAG(x)                     (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_MCR */
+#define MCF_ESW_MCR_PORT(x)                    (((x)&0x0000000F)<<0)
+#define MCF_ESW_MCR_MEN                        (0x00000010)
+#define MCF_ESW_MCR_INGMAP                     (0x00000020)
+#define MCF_ESW_MCR_EGMAP                      (0x00000040)
+#define MCF_ESW_MCR_INGSA                      (0x00000080)
+#define MCF_ESW_MCR_INGDA                      (0x00000100)
+#define MCF_ESW_MCR_EGSA                       (0x00000200)
+#define MCF_ESW_MCR_EGDA                       (0x00000400)
+
+/* Bit definitions and macros for MCF_ESW_EGMAP */
+#define MCF_ESW_EGMAP_EG0                      (0x00000001)
+#define MCF_ESW_EGMAP_EG1                      (0x00000002)
+#define MCF_ESW_EGMAP_EG2                      (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_INGMAP */
+#define MCF_ESW_INGMAP_ING0                    (0x00000001)
+#define MCF_ESW_INGMAP_ING1                    (0x00000002)
+#define MCF_ESW_INGMAP_ING2                    (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_INGSAL */
+#define MCF_ESW_INGSAL_ADDLOW(x)               (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_INGSAH */
+#define MCF_ESW_INGSAH_ADDHIGH(x)              (((x)&0x0000FFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_INGDAL */
+#define MCF_ESW_INGDAL_ADDLOW(x)               (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_INGDAH */
+#define MCF_ESW_INGDAH_ADDHIGH(x)              (((x)&0x0000FFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_ENGSAL */
+#define MCF_ESW_ENGSAL_ADDLOW(x)               (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_ENGSAH */
+#define MCF_ESW_ENGSAH_ADDHIGH(x)              (((x)&0x0000FFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_ENGDAL */
+#define MCF_ESW_ENGDAL_ADDLOW(x)               (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_ENGDAH */
+#define MCF_ESW_ENGDAH_ADDHIGH(x)              (((x)&0x0000FFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_MCVAL */
+#define MCF_ESW_MCVAL_COUNT(x)                 (((x)&0x000000FF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_MMSR */
+#define MCF_ESW_MMSR_BUSY                      (0x00000001)
+#define MCF_ESW_MMSR_NOCELL                    (0x00000002)
+#define MCF_ESW_MMSR_MEMFULL                   (0x00000004)
+#define MCF_ESW_MMSR_MFLATCH                   (0x00000008)
+#define MCF_ESW_MMSR_DQ_GRNT                   (0x00000040)
+#define MCF_ESW_MMSR_CELLS_AVAIL(x)            (((x)&0x000000FF)<<16)
+
+/* Bit definitions and macros for MCF_ESW_LMT */
+#define MCF_ESW_LMT_THRESH(x)                  (((x)&0x000000FF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_LFC */
+#define MCF_ESW_LFC_COUNT(x)                   (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_PCSR */
+#define MCF_ESW_PCSR_PC0                       (0x00000001)
+#define MCF_ESW_PCSR_PC1                       (0x00000002)
+#define MCF_ESW_PCSR_PC2                       (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_IOSR */
+#define MCF_ESW_IOSR_OR0                       (0x00000001)
+#define MCF_ESW_IOSR_OR1                       (0x00000002)
+#define MCF_ESW_IOSR_OR2                       (0x00000004)
+
+/* Bit definitions and macros for MCF_ESW_QWT */
+#define MCF_ESW_QWT_Q0WT(x)                    (((x)&0x0000001F)<<0)
+#define MCF_ESW_QWT_Q1WT(x)                    (((x)&0x0000001F)<<8)
+#define MCF_ESW_QWT_Q2WT(x)                    (((x)&0x0000001F)<<16)
+#define MCF_ESW_QWT_Q3WT(x)                    (((x)&0x0000001F)<<24)
+
+/* Bit definitions and macros for MCF_ESW_P0BCT */
+#define MCF_ESW_P0BCT_THRESH(x)                (((x)&0x000000FF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_P0FFEN */
+#define MCF_ESW_P0FFEN_FEN                     (0x00000001)
+#define MCF_ESW_P0FFEN_FD(x)                   (((x)&0x00000003)<<2)
+
+/* Bit definitions and macros for MCF_ESW_PSNP */
+#define MCF_ESW_PSNP_EN                        (0x00000001)
+#define MCF_ESW_PSNP_MODE(x)                   (((x)&0x00000003)<<1)
+#define MCF_ESW_PSNP_CD                        (0x00000008)
+#define MCF_ESW_PSNP_CS                        (0x00000010)
+#define MCF_ESW_PSNP_PORT_COMPARE(x)           (((x)&0x0000FFFF)<<16)
+
+/* Bit definitions and macros for MCF_ESW_IPSNP */
+#define MCF_ESW_IPSNP_EN                       (0x00000001)
+#define MCF_ESW_IPSNP_MODE(x)                  (((x)&0x00000003)<<1)
+#define MCF_ESW_IPSNP_PROTOCOL(x)              (((x)&0x000000FF)<<8)
+
+/* Bit definitions and macros for MCF_ESW_PVRES */
+#define MCF_ESW_PVRES_PRI0(x)                  (((x)&0x00000007)<<0)
+#define MCF_ESW_PVRES_PRI1(x)                  (((x)&0x00000007)<<3)
+#define MCF_ESW_PVRES_PRI2(x)                  (((x)&0x00000007)<<6)
+#define MCF_ESW_PVRES_PRI3(x)                  (((x)&0x00000007)<<9)
+#define MCF_ESW_PVRES_PRI4(x)                  (((x)&0x00000007)<<12)
+#define MCF_ESW_PVRES_PRI5(x)                  (((x)&0x00000007)<<15)
+#define MCF_ESW_PVRES_PRI6(x)                  (((x)&0x00000007)<<18)
+#define MCF_ESW_PVRES_PRI7(x)                  (((x)&0x00000007)<<21)
+
+/* Bit definitions and macros for MCF_ESW_IPRES */
+#define MCF_ESW_IPRES_ADDRESS(x)               (((x)&0x000000FF)<<0)
+#define MCF_ESW_IPRES_IPV4SEL                  (0x00000100)
+#define MCF_ESW_IPRES_PRI0(x)                  (((x)&0x00000003)<<9)
+#define MCF_ESW_IPRES_PRI1(x)                  (((x)&0x00000003)<<11)
+#define MCF_ESW_IPRES_PRI2(x)                   (((x)&0x00000003)<<13)
+#define MCF_ESW_IPRES_READ                     (0x80000000)
+
+/* Bit definitions and macros for MCF_ESW_PRES */
+#define MCF_ESW_PRES_VLAN                      (0x00000001)
+#define MCF_ESW_PRES_IP                        (0x00000002)
+#define MCF_ESW_PRES_MAC                       (0x00000004)
+#define MCF_ESW_PRES_DFLT_PRI(x)               (((x)&0x00000007)<<4)
+
+/* Bit definitions and macros for MCF_ESW_PID */
+#define MCF_ESW_PID_VLANID(x)                  (((x)&0x0000FFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_VRES */
+#define MCF_ESW_VRES_P0                        (0x00000001)
+#define MCF_ESW_VRES_P1                        (0x00000002)
+#define MCF_ESW_VRES_P2                        (0x00000004)
+#define MCF_ESW_VRES_VLANID(x)                 (((x)&0x00000FFF)<<3)
+
+/* Bit definitions and macros for MCF_ESW_DISCN */
+#define MCF_ESW_DISCN_COUNT(x)                 (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_DISCB */
+#define MCF_ESW_DISCB_COUNT(x)                 (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_NDISCN */
+#define MCF_ESW_NDISCN_COUNT(x)                (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_NDISCB */
+#define MCF_ESW_NDISCB_COUNT(x)                (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_POQC */
+#define MCF_ESW_POQC_COUNT(x)                  (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_PMVID */
+#define MCF_ESW_PMVID_COUNT(x)                 (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_PMVTAG */
+#define MCF_ESW_PMVTAG_COUNT(x)                (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_PBL */
+#define MCF_ESW_PBL_COUNT(x)                   (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_ISR */
+#define MCF_ESW_ISR_EBERR                      (0x00000001)
+#define MCF_ESW_ISR_RXB                        (0x00000002)
+#define MCF_ESW_ISR_RXF                        (0x00000004)
+#define MCF_ESW_ISR_TXB                        (0x00000008)
+#define MCF_ESW_ISR_TXF                        (0x00000010)
+#define MCF_ESW_ISR_QM                         (0x00000020)
+#define MCF_ESW_ISR_OD0                        (0x00000040)
+#define MCF_ESW_ISR_OD1                        (0x00000080)
+#define MCF_ESW_ISR_OD2                        (0x00000100)
+#define MCF_ESW_ISR_LRN                        (0x00000200)
+
+/* Bit definitions and macros for MCF_ESW_IMR */
+#define MCF_ESW_IMR_EBERR                      (0x00000001)
+#define MCF_ESW_IMR_RXB                        (0x00000002)
+#define MCF_ESW_IMR_RXF                        (0x00000004)
+#define MCF_ESW_IMR_TXB                        (0x00000008)
+#define MCF_ESW_IMR_TXF                        (0x00000010)
+#define MCF_ESW_IMR_QM                         (0x00000020)
+#define MCF_ESW_IMR_OD0                        (0x00000040)
+#define MCF_ESW_IMR_OD1                        (0x00000080)
+#define MCF_ESW_IMR_OD2                        (0x00000100)
+#define MCF_ESW_IMR_LRN                        (0x00000200)
+
+/* Bit definitions and macros for MCF_ESW_RDSR */
+#define MCF_ESW_RDSR_ADDRESS(x)                (((x)&0x3FFFFFFF)<<2)
+
+/* Bit definitions and macros for MCF_ESW_TDSR */
+#define MCF_ESW_TDSR_ADDRESS(x)                (((x)&0x3FFFFFFF)<<2)
+
+/* Bit definitions and macros for MCF_ESW_MRBR */
+#define MCF_ESW_MRBR_SIZE(x)                   (((x)&0x000003FF)<<4)
+
+/* Bit definitions and macros for MCF_ESW_RDAR */
+#define MCF_ESW_RDAR_R_DES_ACTIVE              (0x01000000)
+
+/* Bit definitions and macros for MCF_ESW_TDAR */
+#define MCF_ESW_TDAR_X_DES_ACTIVE              (0x01000000)
+
+/* Bit definitions and macros for MCF_ESW_LREC0 */
+#define MCF_ESW_LREC0_MACADDR0(x)              (((x)&0xFFFFFFFF)<<0)
+
+/* Bit definitions and macros for MCF_ESW_LREC1 */
+#define MCF_ESW_LREC1_MACADDR1(x)              (((x)&0x0000FFFF)<<0)
+#define MCF_ESW_LREC1_HASH(x)                  (((x)&0x000000FF)<<16)
+#define MCF_ESW_LREC1_SWPORT(x)                (((x)&0x00000003)<<24)
+
+/* Bit definitions and macros for MCF_ESW_LSR */
+#define MCF_ESW_LSR_DA                         (0x00000001)
+
+#endif /* SWITCH_H */
-- 
1.5.4.4

