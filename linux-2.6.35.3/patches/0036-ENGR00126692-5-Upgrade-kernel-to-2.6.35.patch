From 6f6f1f967bfbefaca38e77e2d3b17fc9fd83a330 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <Dinh.Nguyen@freescale.com>
Date: Tue, 17 Aug 2010 16:46:40 -0500
Subject: [PATCH] ENGR00126692-5: Upgrade kernel to 2.6.35

This patch contains changes to /include/linux/ files
Contains all checkpatch and copyright fixes.

Acked-by: Rob Herring <r.herring@freescale.com>
Signed-off-by: Dinh Nguyen <Dinh.Nguyen@freescale.com>
---
 include/linux/fec.h                 |   22 +
 include/linux/fsl_devices.h         |  460 +++++++++++++-
 include/linux/gpmi-nfc.h            |  123 ++++
 include/linux/imx_adc.h             |  275 ++++++++
 include/linux/ipu.h                 | 1288 +++++++++++++++++++++++++++++++++++
 include/linux/iram_alloc.h          |   35 +
 include/linux/ldb.h                 |   88 +++
 include/linux/major.h               |    2 +
 include/linux/mfd/mc13783/core.h    |   72 ++
 include/linux/mfd/mc13892/core.h    |   77 +++
 include/linux/mfd/mc34704/core.h    |   84 +++
 include/linux/mfd/mc9s08dz60/core.h |   59 ++
 include/linux/mfd/mc9s08dz60/pmic.h |   82 +++
 include/linux/mfd/wm8350/audio.h    |    2 +
 include/linux/mfd/wm8350/bl.h       |   33 +
 include/linux/mxc_asrc.h            |  210 ++++++
 include/linux/mxc_mlb.h             |   51 ++
 include/linux/mxc_pf.h              |  125 ++++
 include/linux/mxc_scc2_driver.h     |  975 ++++++++++++++++++++++++++
 include/linux/mxc_scc_driver.h      | 1031 ++++++++++++++++++++++++++++
 include/linux/mxc_si4702.h          |   39 ++
 include/linux/mxc_sim_interface.h   |  108 +++
 include/linux/mxc_srtc.h            |   25 +
 include/linux/mxc_v4l2.h            |   48 ++
 include/linux/mxcfb.h               |  144 ++++
 include/linux/pmic_adc.h            |  455 ++++++++++++
 include/linux/pmic_battery.h        |  419 ++++++++++++
 include/linux/pmic_external.h       |  434 ++++++++++++
 include/linux/pmic_light.h          | 1082 +++++++++++++++++++++++++++++
 include/linux/pmic_rtc.h            |  153 +++++
 include/linux/pmic_status.h         |   82 +++
 include/linux/pxp_dma.h             |  222 ++++++
 include/linux/regulator/max17135.h  |   56 ++
 include/linux/soundcard.h           |    7 +
 include/linux/usb/fsl_xcvr.h        |   58 ++
 35 files changed, 8425 insertions(+), 1 deletions(-)

diff --git a/include/linux/fec.h b/include/linux/fec.h
index 5d3523d..5ebd1f4 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -1,6 +1,7 @@
 /* include/linux/fec.h
  *
  * Copyright (c) 2009 Orex Computed Radiography
+ * Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
  *   Baruch Siach <baruch@tkos.co.il>
  *
  * Header file for the FEC platform data
@@ -16,6 +17,27 @@
 
 struct fec_platform_data {
 	phy_interface_t phy;
+	int (*init)(void);
+	int (*uninit)(void);
+	struct regulator *vddio_reg;
+};
+
+struct switch_platform_data {
+	int	id;
+	int     hash_table;
+	unsigned int *switch_hw;
+	struct fec_platform_data *fec_enet;
+	void    (*request_intrs)(struct net_device *dev,
+		irqreturn_t (*)(int, void *),
+		void *irq_privatedata);
+	void    (*set_mii)(struct net_device *dev);
+	void    (*get_mac)(struct net_device *dev);
+	void    (*enable_phy_intr)(void);
+	void    (*disable_phy_intr)(void);
+	void    (*phy_ack_intr)(void);
+	void    (*localhw_setup)(void);
+	void    (*uncache)(unsigned long addr);
+	void    (*platform_flush_cache)(void);
 };
 
 #endif
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 28e33fe..e2a87fe 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -6,7 +6,7 @@
  *
  * Maintainer: Kumar Gala <galak@kernel.crashing.org>
  *
- * Copyright 2004 Freescale Semiconductor, Inc
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -50,6 +50,15 @@ enum fsl_usb2_operating_modes {
 	FSL_USB2_DR_OTG,
 };
 
+/* this used for usb port type */
+enum fsl_usb2_modes {
+	FSL_USB_DR_HOST,
+	FSL_USB_DR_DEVICE,
+	FSL_USB_MPH_HOST1,
+	FSL_USB_MPH_HOST2,
+	FSL_USB_UNKNOWN, /* unkonwn status */
+};
+
 enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_NONE,
 	FSL_USB2_PHY_ULPI,
@@ -58,11 +67,52 @@ enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_SERIAL,
 };
 
+struct platform_device;
 struct fsl_usb2_platform_data {
 	/* board specific information */
 	enum fsl_usb2_operating_modes	operating_mode;
 	enum fsl_usb2_phy_modes		phy_mode;
 	unsigned int			port_enables;
+
+	char *name;		/* pretty print */
+	int (*platform_init) (struct platform_device *);
+	void (*platform_uninit) (struct fsl_usb2_platform_data *);
+	void __iomem *regs;	/* ioremap'd register base */
+	u32 phy_regs;	/* usb phy register base */
+	u32 xcvr_type;		/* PORTSC_PTS_* */
+	char *transceiver;	/* transceiver name */
+	unsigned power_budget;	/* for hcd->power_budget */
+	struct platform_device *pdev;
+	struct fsl_xcvr_ops *xcvr_ops;
+	struct fsl_xcvr_power *xcvr_pwr;
+	int (*gpio_usb_active) (void);
+	void (*gpio_usb_inactive) (void);
+	void (*usb_clock_for_pm) (bool);
+	void (*platform_suspend)(struct fsl_usb2_platform_data *);
+	void (*platform_resume)(struct fsl_usb2_platform_data *);
+	void (*wake_up_enable)(struct fsl_usb2_platform_data *pdata, bool on);
+	void (*platform_driver_vbus)(bool on); /* platform special function for vbus shutdown/open */
+	unsigned			big_endian_mmio:1;
+	unsigned			big_endian_desc:1;
+	unsigned			es:1;	/* need USBMODE:ES */
+	unsigned			have_sysif_regs:1;
+	unsigned			le_setup_buf:1;
+	unsigned change_ahb_burst:1;
+	unsigned ahb_burst_mode:3;
+	unsigned			suspended:1;
+	unsigned			already_suspended:1;
+
+	u32				id_gpio;
+	/* register save area for suspend/resume */
+	u32				pm_command;
+	u32				pm_status;
+	u32				pm_intr_enable;
+	u32				pm_frame_index;
+	u32				pm_segment;
+	u32				pm_frame_list;
+	u32				pm_async_next;
+	u32				pm_configured_flag;
+	u32				pm_portsc;
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
@@ -86,6 +136,414 @@ struct fsl_spi_platform_data {
 	u32	sysclk;
 };
 
+struct fsl_ata_platform_data {
+       int     adma_flag;      /* AMDA mode is used or not, 1:used.*/
+       int     udma_mask;      /* UDMA modes h/w can handle */
+       int     mwdma_mask;      /* MDMA modes h/w can handle */
+       int     pio_mask;      /* PIO modes h/w can handle */
+       int     fifo_alarm;     /* value for fifo_alarm reg */
+       int     max_sg;         /* longest sglist h/w can handle */
+       int     (*init)(struct platform_device *pdev);
+       void    (*exit)(void);
+	   char    *io_reg;
+	   char    *core_reg;
+};
+
+/*!
+ * This structure is used to define the One wire platform data.
+ * It includes search rom accelerator.
+ */
+struct mxc_w1_config {
+	int search_rom_accelerator;
+};
+/*!
+ * This structure is used to define the SPI master controller's platform
+ * data. It includes the SPI  bus number and the maximum number of
+ * slaves/chips it supports.
+ */
+struct mxc_spi_master {
+	/*!
+	 * SPI Master's bus number.
+	 */
+	unsigned int bus_num;
+	/*!
+	 * SPI Master's maximum number of chip selects.
+	 */
+	unsigned int maxchipselect;
+	/*!
+	 * CSPI Hardware Version.
+	 */
+	unsigned int spi_version;
+	/*!
+	 * CSPI chipselect pin table.
+	 * Workaround for ecspi chipselect pin may not keep correct level when
+	 * idle.
+	 */
+	void (*chipselect_active) (int cspi_mode, int status, int chipselect);
+	void (*chipselect_inactive) (int cspi_mode, int status, int chipselect);
+};
+
+struct mxc_ipu_config {
+	int rev;
+	void (*reset) (void);
+	struct clk *di_clk[2];
+	struct clk *csi_clk[2];
+};
+
+struct mxc_ir_platform_data {
+	int uart_ir_mux;
+	int ir_rx_invert;
+	int ir_tx_invert;
+	struct clk *uart_clk;
+};
+
+struct mxc_i2c_platform_data {
+	u32 i2c_clk;
+};
+
+/*
+ * This struct is to define the number of SSIs on a platform,
+ * DAM source port config, DAM external port config,
+ * regulator names, and other stuff audio needs.
+ */
+struct mxc_audio_platform_data {
+	int ssi_num;
+	int src_port;
+	int ext_port;
+
+	int intr_id_hp;
+	int ext_ram;
+	struct clk *ssi_clk[2];
+
+	int hp_irq;
+	int (*hp_status) (void);
+
+	int sysclk;
+
+	int (*init) (void);	/* board specific init */
+	int (*amp_enable) (int enable);
+	int (*finit) (void);	/* board specific finit */
+	void *priv;		/* used by board specific functions */
+};
+
+struct mxc_spdif_platform_data {
+	int spdif_tx;
+	int spdif_rx;
+	int spdif_clk_44100;
+	int spdif_clk_48000;
+	int spdif_clkid;
+	struct clk *spdif_clk;
+	struct clk *spdif_core_clk;
+	struct clk *spdif_audio_clk;
+};
+
+struct mxc_asrc_platform_data {
+	struct clk *asrc_core_clk;
+	struct clk *asrc_audio_clk;
+	unsigned int channel_bits;
+};
+
+struct mxc_bt_platform_data {
+	char *bt_vdd;
+	char *bt_vdd_parent;
+	char *bt_vusb;
+	char *bt_vusb_parent;
+	void (*bt_reset) (void);
+};
+
+struct mxc_lightsensor_platform_data {
+	char *vdd_reg;
+	int rext;
+};
+
+struct mxc_fb_platform_data {
+	struct fb_videomode *mode;
+	int num_modes;
+	char *mode_str;
+	u32 interface_pix_fmt;
+};
+
+struct mxc_lcd_platform_data {
+	char *io_reg;
+	char *core_reg;
+	char *analog_reg;
+	void (*reset) (void);
+};
+
+
+struct mxc_tsc_platform_data {
+	char *vdd_reg;
+	int penup_threshold;
+	void (*active) (void);
+	void (*inactive) (void);
+};
+
+struct mxc_tvout_platform_data {
+	char *io_reg;
+	char *core_reg;
+	char *analog_reg;
+	u32 detect_line;
+};
+
+struct mxc_tvin_platform_data {
+	char *dvddio_reg;
+	char *dvdd_reg;
+	char *avdd_reg;
+	char *pvdd_reg;
+	void (*pwdn) (int pwdn);
+	void (*reset) (void);
+};
+
+/*! Platform data for the IDE drive structure. */
+struct mxc_ide_platform_data {
+	char *power_drive;	/*!< The power pointer */
+	char *power_io;		/*!< The power pointer */
+};
+
+struct mxc_camera_platform_data {
+	char *core_regulator;
+	char *io_regulator;
+	char *analog_regulator;
+	char *gpo_regulator;
+	u32 mclk;
+	u32 csi;
+	void (*pwdn)(int pwdn);
+};
+
+/*gpo1-3 is in fixed state by hardware design,
+ * only deal with reset pin and clock_enable pin
+ * only poll mode can be used to control the chip,
+ * interrupt mode is not supported by 3ds*/
+struct mxc_fm_platform_data {
+	char *reg_vio;
+	char *reg_vdd;
+	void (*gpio_get) (void);
+	void (*gpio_put) (void);
+	void (*reset) (void);
+	void (*clock_ctl) (int flag);
+	u8	sksnr; /*0,disable;1,most stop;0xf,fewest stop*/
+	u8	skcnt; /*0,disable;1,most stop;0xf,fewest stop*/
+	/*
+	00 = 87.5-108 MHz (USA,Europe) (Default).
+	01 = 76-108 MHz (Japan wide band).
+	10 = 76-90 MHz (Japan).
+	11 = Reserved.
+	*/
+	u8	band;
+	/*
+	00 = 200 kHz (USA, Australia) (default).
+	01 = 100 kHz (Europe, Japan).
+	10 = 50 kHz.
+	*/
+	u8	space;
+	u8	seekth;
+};
+
+struct mxc_mma7450_platform_data {
+	char *reg_dvdd_io;
+	char *reg_avdd;
+	void (*gpio_pin_get) (void);
+	void (*gpio_pin_put) (void);
+	int int1;
+	int int2;
+};
+
+struct mxc_keyp_platform_data {
+	u16 *matrix;
+	void (*active) (void);
+	void (*inactive) (void);
+	char *vdd_reg;
+};
+
+struct mxc_unifi_platform_data {
+	void (*hardreset) (int pin_level);
+	void (*enable) (int en);
+	/* power parameters */
+	char *reg_gpo1;
+	char *reg_gpo2;
+	char *reg_1v5_ana_bb;
+	char *reg_vdd_vpa;
+	char *reg_1v5_dd;
+
+	int host_id;
+
+	void *priv;
+};
+
+struct mxc_gps_platform_data {
+	char *core_reg;
+	char *analog_reg;
+	struct regulator *gps_regu_core;
+	struct regulator *gps_regu_analog;
+};
+
+struct mxc_mlb_platform_data {
+	u32 buf_address;
+	u32 phy_address;
+	char *reg_nvcc;
+	char *mlb_clk;
+};
+
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	void (*xcvr_enable) (int id, int en);
+	void (*active) (int id);
+	void (*inactive) (int id);
+	/* word 1 */
+	unsigned int br_presdiv:8;
+	unsigned int br_rjw:2;
+	unsigned int br_propseg:3;
+	unsigned int br_pseg1:3;
+	unsigned int br_pseg2:3;
+	unsigned int maxmb:6;
+	unsigned int xmit_maxmb:6;
+	unsigned int wd1_resv:1;
+
+	/* word 2 */
+	unsigned int fifo:1;
+	unsigned int wakeup:1;
+	unsigned int srx_dis:1;
+	unsigned int wak_src:1;
+	unsigned int bcc:1;
+	unsigned int lprio:1;
+	unsigned int abort:1;
+	unsigned int br_clksrc:1;
+	unsigned int loopback:1;
+	unsigned int smp:1;
+	unsigned int boff_rec:1;
+	unsigned int tsyn:1;
+	unsigned int listen:1;
+	unsigned int ext_msg:1;
+	unsigned int std_msg:1;
+};
+
+struct mxc_srtc_platform_data {
+	u32 srtc_sec_mode_addr;
+};
+
+struct tve_platform_data {
+	char *dac_reg;
+	char *dig_reg;
+};
+
+struct ldb_platform_data {
+	char *lvds_bg_reg;
+	u32 ext_ref;
+};
+
+ struct mxc_vpu_platform_data {
+	void (*reset) (void);
+};
+
+struct mxc_esai_platform_data {
+	void (*activate_esai_ports) (void);
+	void (*deactivate_esai_ports) (void);
+};
+
+/* The name that links the i.MX NAND Flash Controller driver to its devices. */
+
+#define IMX_NFC_DRIVER_NAME  ("imx_nfc")
+
+/* Resource names for the i.MX NAND Flash Controller driver. */
+
+#define IMX_NFC_BUFFERS_ADDR_RES_NAME         \
+			("i.MX NAND Flash Controller Buffer")
+#define IMX_NFC_PRIMARY_REGS_ADDR_RES_NAME    \
+			("i.MX NAND Flash Controller Primary Registers")
+#define IMX_NFC_SECONDARY_REGS_ADDR_RES_NAME  \
+			("i.MX NAND Flash Controller Secondary Registers")
+#define IMX_NFC_INTERRUPT_RES_NAME            \
+			("i.MX NAND Flash Controller Interrupt")
+
+/**
+ * struct imx_nfc_platform_data - i.MX NFC driver platform data.
+ *
+ * This structure communicates information to the i.MX NFC driver that can't be
+ * expressed as resources.
+ *
+ * @nfc_major_version:  The "major version" of the NFC hardware.
+ * @nfc_minor_version:  The "minor version" of the NFC hardware.
+ * @force_ce:           If true, this flag causes the driver to assert the
+ *                      hardware chip enable signal for the currently selected
+ *                      chip as long as the MTD NAND Flash HAL has the chip
+ *                      selected (not just when an I/O transaction is in
+ *                      progress).
+ * @target_cycle_in_ns: The target read and write cycle period, in nanoseconds.
+ *                      NAND Flash part data sheets give minimum times for read
+ *                      and write cycles in nanoseconds (usually tRC and tWC,
+ *                      respectively). Set this value to the maximum of these
+ *                      two parameters. The driver will set the NFC clock as
+ *                      close as possible without violating this value.
+ * @clock_name:         The name of the clock used by the NAND Flash controller.
+ * @init:               A pointer to a function the driver must call so the
+ *                      platform can prepare for this device to operate. This
+ *                      pointer may be NULL.
+ * @exit:               A pointer to a function the driver must call so the
+ *                      platform clean up after this device stops operating.
+ *                      This pointer may be NULL.
+ * @set_page_size:      A pointer to a function the driver can call to set the
+ *                      page size. This pointer may be NULL.
+ *
+ *                      For some i.MX SoC's, the NFC gets information about the
+ *                      page size from signals driven by a system register
+ *                      outside the NFC. The address and format of this external
+ *                      register varies across SoC's. In other SoC's, the NFC
+ *                      still receives this signal, but it is overridden by a
+ *                      page size register in the NFC itself.
+ *
+ *                      For SoC's where the page size *must* be set in an
+ *                      external register, the driver must rely on a platform-
+ *                      specific function, and this member must point to it.
+ *
+ *                      For SoC's where the NFC has its own page size register,
+ *                      the driver will set that register itself and ignore the
+ *                      external signals. In this case, there's no need for the
+ *                      platform-specific function and this member must be NULL.
+ *
+ *                      This function accepts the page size in bytes (MTD calls
+ *                      this the "writesize") discovered by the NAND Flash MTD
+ *                      base driver (e.g., 512, 2048, 4096). This size refers
+ *                      specifically to the the data bytes in the page, *not*
+ *                      including out-of-band bytes. The return value is zero if
+ *                      the operation succeeded. The driver does *not* view a
+ *                      non-zero value as an error code - only an indication of
+ *                      failure. The driver will decide for itself what error
+ *                      code to return to its caller.
+ * @interleave:         Indicates that the driver should "interleave" the NAND
+ *                      Flash chips it finds. If true, the driver will aggregate
+ *                      the chips "horizontally" such that MTD will see a single
+ *                      chip with a potentially very large page size. This can
+ *                      improve write performance for some applications.
+ * @partitions:         An optional pointer to an array of partitions. If this
+ *                      is NULL, the driver will create a single MTD that
+ *                      represents the entire medium.
+ * @partition_count:    The number of elements in the partition array.
+ */
+
+struct imx_nfc_platform_data {
+	unsigned int          nfc_major_version;
+	unsigned int          nfc_minor_version;
+	int                   force_ce;
+	unsigned int          target_cycle_in_ns;
+	char                  *clock_name;
+	int                   (*init)(void);
+	void                  (*exit)(void);
+	int                   (*set_page_size)(unsigned int data_size_in_bytes);
+	int                   interleave;
+	struct mtd_partition  *partitions;
+	unsigned int	      partition_count;
+};
+
+struct mxc_sim_platform_data {
+	unsigned int clk_rate;
+	char *clock_sim;
+	char *power_sim;
+	int (*init)(struct platform_device *pdev);
+	void (*exit)(void);
+	unsigned int detect; /* 1 have detect pin, 0 not */
+};
+
 struct mpc8xx_pcmcia_ops {
 	void(*hw_ctrl)(int slot, int enable);
 	int(*voltage_set)(int slot, int vcc, int vpp);
diff --git a/include/linux/gpmi-nfc.h b/include/linux/gpmi-nfc.h
new file mode 100644
index 0000000..2311fd6
--- /dev/null
+++ b/include/linux/gpmi-nfc.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __INCLUDE_LINUX_DEVICE_H
+#define __INCLUDE_LINUX_DEVICE_H
+
+/* The name that links together the GPMI NFC driver data structures. */
+
+#define GPMI_NFC_DRIVER_NAME  "gpmi-nfc"
+
+/* Resource names for the GPMI NFC driver. */
+
+#define GPMI_NFC_GPMI_REGS_ADDR_RES_NAME  "GPMI NFC GPMI Registers"
+#define GPMI_NFC_GPMI_INTERRUPT_RES_NAME  "GPMI NFC GPMI Interrupt"
+#define GPMI_NFC_BCH_REGS_ADDR_RES_NAME   "GPMI NFC BCH Registers"
+#define GPMI_NFC_BCH_INTERRUPT_RES_NAME   "GPMI NFC BCH Interrupt"
+#define GPMI_NFC_DMA_CHANNELS_RES_NAME    "GPMI NFC DMA Channels"
+#define GPMI_NFC_DMA_INTERRUPT_RES_NAME   "GPMI NFC DMA Interrupt"
+
+/**
+ * struct gpmi_nfc_platform_data - GPMI NFC driver platform data.
+ *
+ * This structure communicates platform-specific information to the GPMI NFC
+ * driver that can't be expressed as resources.
+ *
+ * @nfc_version:             The version of the NFC hardware. This single number
+ *                           represents a collection of NFC behaviors and
+ *                           attributes the driver must comprehend. See the
+ *                           driver code for details about what each version
+ *                           means.
+ * @boot_rom_version:        The version of the Boot ROM. This single number
+ *                           represents a collection of Boot ROM behaviors and
+ *                           attributes the driver must comprehend. See the
+ *                           driver code for details about what each version
+ *                           means.
+ * @clock_name:              The name of the clock that drives the NFC.
+ * @platform_init:           A pointer to a function the driver will call to
+ *                           initialize the platform (e.g., set up the pin mux).
+ *                           The max_chip_count parameter is the maximum number
+ *                           of chips the driver is to support. If the platform
+ *                           can't be configured to support this number, the
+ *                           function should print a message and return a
+ *                           non-zero value . The driver will only view this as
+ *                           an indication of failure and will choose its own
+ *                           error code to return.
+ * @platform_exit:           A pointer to a function the driver will call to
+ *                           exit the platform (e.g., free pins). The
+ *                           max_chip_count parameter is same value passed to
+ *                           the platform init function.
+ * @min_prop_delay_in_ns:    Minimum propagation delay of GPMI signals to and
+ *                           from the NAND Flash device, in nanoseconds.
+ * @max_prop_delay_in_ns:    Maximum propagation delay of GPMI signals to and
+ *                           from the NAND Flash device, in nanoseconds.
+ * @max_chip_count:          The maximum number of chips for which the driver
+ *                           should configure the hardware. This value most
+ *                           likely reflects the number of pins that are
+ *                           connected to a NAND Flash device. If this is
+ *                           greater than the SoC hardware can support, the
+ *                           driver will print a message and fail to initialize.
+ * @boot_area_size_in_bytes: The amount of space reserved for each boot area.
+ *                           Note that some Boot ROMs call for multiple boot
+ *                           areas. If this value is zero, the driver will not
+ *                           construct special partitions for boot areas.
+ * @partition_source_types:  An array of strings that name sources of
+ *                           partitioning information (e.g., the boot loader,
+ *                           kernel command line, etc.). The function
+ *                           parse_mtd_partitions() recognizes these names and
+ *                           applies the appropriate "plugins" to discover
+ *                           partitioning information. If any is found, it will
+ *                           be applied to the "general use" MTD (it will NOT
+ *                           override the boot area protection mechanism).
+ * @partitions:              An optional pointer to an array of partition
+ *                           descriptions. If the driver finds no other
+ *                           partitioning information, it will apply these
+ *                           partitions to the "general use" MTD (they do NOT
+ *                           override the boot area protection mechanism).
+ * @partition_count:         The number of elements in the partitions array.
+ */
+
+struct gpmi_nfc_platform_data {
+
+	/* Version information. */
+
+	unsigned int          nfc_version;
+	unsigned int          boot_rom_version;
+
+	/* SoC hardware information. */
+
+	char                  *clock_name;
+	int                   (*platform_init)(unsigned int max_chip_count);
+	void                  (*platform_exit)(unsigned int max_chip_count);
+
+	/* NAND Flash information. */
+
+	unsigned int          min_prop_delay_in_ns;
+	unsigned int          max_prop_delay_in_ns;
+	unsigned int          max_chip_count;
+
+	/* Medium information. */
+
+	uint32_t              boot_area_size_in_bytes;
+	const char            **partition_source_types;
+	struct mtd_partition  *partitions;
+	unsigned              partition_count;
+
+};
+
+#endif
diff --git a/include/linux/imx_adc.h b/include/linux/imx_adc.h
new file mode 100644
index 0000000..d04fa7d
--- /dev/null
+++ b/include/linux/imx_adc.h
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_IMX_ADC_H__
+#define __ASM_ARCH_IMX_ADC_H__
+
+/*!
+ * @defgroup IMX_ADC Digitizer Driver
+ * @ingroup IMX_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/imx_adc.h
+ * @brief This is the header of IMX ADC driver.
+ *
+ * @ingroup IMX_ADC
+ */
+
+#include <linux/ioctl.h>
+
+/*!
+ * @enum IMX_ADC_STATUS
+ * @brief Define return values for all IMX_ADC APIs.
+ *
+ * These return values are used by all of the IMX_ADC APIs.
+ *
+ * @ingroup IMX_ADC
+ */
+enum IMX_ADC_STATUS {
+	/*! The requested operation was successfully completed. */
+	IMX_ADC_SUCCESS = 0,
+	/*! The requested operation could not be completed due to an error. */
+	IMX_ADC_ERROR = -1,
+	/*!
+	 * The requested operation failed because one or more of the
+	 * parameters was invalid.
+	 */
+	IMX_ADC_PARAMETER_ERROR = -2,
+	/*!
+	 * The requested operation could not be completed because the ADC
+	 * hardware does not support it.
+	 */
+	IMX_ADC_NOT_SUPPORTED = -3,
+	/*! Error in malloc function */
+	IMX_ADC_MALLOC_ERROR = -5,
+	/*! Error in un-subscribe event */
+	IMX_ADC_UNSUBSCRIBE_ERROR = -6,
+	/*! Event occur and not subscribed */
+	IMX_ADC_EVENT_NOT_SUBSCRIBED = -7,
+	/*! Error - bad call back */
+	IMX_ADC_EVENT_CALL_BACK = -8,
+	/*!
+	 * The requested operation could not be completed because there
+	 * are too many ADC client requests
+	 */
+	IMX_ADC_CLIENT_NBOVERFLOW = -9,
+};
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != IMX_ADC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != IMX_ADC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0)
+
+#define MOD_NAME  "mxcadc"
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define IMX_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define IMX_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define IMX_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define IMX_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define IMX_ADC_DEVICE "/dev/imx_adc"
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch screen
+ */
+#define DELTA_Y_MAX             100
+#define DELTA_X_MAX             100
+
+/* Upon clearing the filter, this is the delay in restarting the filter */
+#define FILTER_MIN_DELAY        4
+
+/* Length of X and Y touch screen filters */
+#define FILTLEN                 3
+
+#define TS_X_MAX                1000
+#define TS_Y_MAX                1000
+
+#define TS_X_MIN                80
+#define TS_Y_MIN                80
+
+/*! @} */
+/*!
+ * This enumeration defines input channels for IMX ADC
+ */
+
+enum t_channel {
+	TS_X_POS,
+	TS_Y_POS,
+	GER_PURPOSE_ADC0,
+	GER_PURPOSE_ADC1,
+	GER_PURPOSE_ADC2,
+	GER_PURPOSE_MULTICHNNEL,
+};
+
+/*!
+ * This structure is used to report touch screen value.
+ */
+struct t_touch_screen {
+	/* Touch Screen X position */
+	unsigned int x_position;
+	/* Touch Screen X position1 */
+	unsigned int x_position1;
+	/* Touch Screen X position2 */
+	unsigned int x_position2;
+	/* Touch Screen X position3 */
+	unsigned int x_position3;
+	/* Touch Screen Y position */
+	unsigned int y_position;
+	/* Touch Screen Y position1 */
+	unsigned int y_position1;
+	/* Touch Screen Y position2 */
+	unsigned int y_position2;
+	/* Touch Screen Y position3 */
+	unsigned int y_position3;
+	/* Touch Screen contact value */
+	unsigned int contact_resistance;
+	/* Flag indicate the data usability */
+	unsigned int valid_flag;
+};
+
+/*!
+ * This structure is used with IOCTL code \a IMX_ADC_CONVERT,
+ * \a IMX_ADC_CONVERT_8X and \a IMX_ADC_CONVERT_MULTICHANNEL.
+ */
+
+struct t_adc_convert_param {
+	/* channel or channels to be sampled.  */
+	enum t_channel channel;
+	/* holds up to 16 sampling results */
+	unsigned short result[16];
+};
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/* Driver data */
+struct imx_adc_data {
+	u32 irq;
+	struct clk *adc_clk;
+};
+
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+
+enum IMX_ADC_STATUS imx_adc_convert(enum t_channel channel,
+				    unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+
+enum IMX_ADC_STATUS imx_adc_convert_multichnnel(enum t_channel channels,
+						unsigned short *result);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait_tsi     if true, we wait until interrupt occurs
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_get_touch_sample(struct t_touch_screen *ts_value,
+					     int wait_tsi);
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        touch_sample    return value of touch screen
+ * @param        wait_tsi        if true, we need wait until interrupt occurs
+ * @return       This function returns 0.
+ */
+enum IMX_ADC_STATUS imx_adc_read_ts(struct t_touch_screen *touch_sample,
+				    int wait_tsi);
+
+int is_imx_adc_ready(void);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_IMX_ADC_H__ */
diff --git a/include/linux/ipu.h b/include/linux/ipu.h
new file mode 100644
index 0000000..e060d37
--- /dev/null
+++ b/include/linux/ipu.h
@@ -0,0 +1,1288 @@
+/*
+ * Copyright 2005-2010 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file arch-mxc/ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+#else
+#ifndef __cplusplus
+typedef unsigned char bool;
+#endif
+#define irqreturn_t int
+#define dma_addr_t int
+#define u32 unsigned int
+#define __u32 u32
+#endif
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of Post Filter modes
+ */
+typedef enum {
+	PF_DISABLE_ALL = 0,
+	PF_MPEG4_DEBLOCK = 1,
+	PF_MPEG4_DERING = 2,
+	PF_MPEG4_DEBLOCK_DERING = 3,
+	PF_H264_DEBLOCK = 4,
+} pf_operation_t;
+
+/*!
+ * Enumeration of Synchronous (Memory-less) panel types
+ */
+typedef enum {
+	IPU_PANEL_SHARP_TFT,
+	IPU_PANEL_TFT,
+} ipu_panel_t;
+
+/*!
+ * Enumeration of VDI MOTION select
+ */
+typedef enum {
+	MED_MOTION = 0,
+	LOW_MOTION = 1,
+	HIGH_MOTION = 2,
+} ipu_motion_sel;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	 (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC fourcc('I', 'P', 'U', '0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 fourcc('I', 'P', 'U', '1')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS666 fourcc('L', 'V', 'D', '6')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_LVDS888 fourcc('L', 'V', 'D', '8')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define IPU_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define IPU_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define IPU_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define IPU_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define IPU_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define IPU_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define IPU_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define IPU_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define IPU_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define IPU_PIX_FMT_YVYU    fourcc('Y', 'V', 'Y', 'U')  /*!< 16 YVYU 4:2:2 */
+#define IPU_PIX_FMT_VYUY    fourcc('V', 'Y', 'U', 'Y')  /*!< 16 VYYU 4:2:2 */
+#define IPU_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define IPU_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define IPU_PIX_FMT_NV12    fourcc('N', 'V', '1', '2') /* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define IPU_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define IPU_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define IPU_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define IPU_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define IPU_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define IPU_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#ifdef CONFIG_MXC_IPU_V1
+#define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
+#define IPU_CHAN_ID(ch)         (ch >> 24)
+#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
+#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
+#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
+
+#else
+#define IPU_MAX_CH	32
+#define _MAKE_CHAN(num, v_in, g_in, a_in, out) \
+	((num << 24) | (v_in << 18) | (g_in << 12) | (a_in << 6) | out)
+#define _MAKE_ALT_CHAN(ch)		(ch | (IPU_MAX_CH << 24))
+#define IPU_CHAN_ID(ch)			(ch >> 24)
+#define IPU_CHAN_ALT(ch)		(ch & 0x02000000)
+#define IPU_CHAN_ALPHA_IN_DMA(ch)	((uint32_t) (ch >> 6) & 0x3F)
+#define IPU_CHAN_GRAPH_IN_DMA(ch)	((uint32_t) (ch >> 12) & 0x3F)
+#define IPU_CHAN_VIDEO_IN_DMA(ch)	((uint32_t) (ch >> 18) & 0x3F)
+#define IPU_CHAN_OUT_DMA(ch)		((uint32_t) (ch & 0x3F))
+#define NO_DMA 0x3F
+#define ALT	1
+#endif
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CHAN_NONE = -1,
+#ifdef CONFIG_MXC_IPU_V1
+	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),	/*!< Memory to IC Encoder PreProcessing to Memory */
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),	/*!< Memory to IC Encoder Rotation to Memory */
+
+	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to Memory */
+	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to ADC */
+	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to Memory */
+	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to ADC */
+	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),	/*!< Memory to IC Viewfinder Rotation to Memory */
+
+	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),	/*!< Memory to IC PostProcessing to Memory */
+	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),	/*!< Memory to IC PostProcessing Rotation to Memory */
+	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),	/*!< Memory to IC PostProcessing to ADC */
+
+	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),	/*!< Memory to SDC Background plane */
+	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
+	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
+
+	MEM_BG_SYNC = MEM_SDC_BG,
+	MEM_FG_SYNC = MEM_SDC_FG,
+
+	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
+	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
+
+	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),	/*!< Y and PF Memory to Post-filter to Y Memory */
+	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
+	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
+
+	MEM_DC_SYNC = CHAN_NONE,
+	DIRECT_ASYNC0 = CHAN_NONE,
+	DIRECT_ASYNC1 = CHAN_NONE,
+	MEM_VDI_PRP_VF_MEM_P = CHAN_NONE,
+	MEM_VDI_PRP_VF_MEM = CHAN_NONE,
+	MEM_VDI_PRP_VF_MEM_N = CHAN_NONE,
+#else
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(1, 45, NO_DMA, NO_DMA, 48),
+	MEM_ROT_VF_MEM = _MAKE_CHAN(2, 46, NO_DMA, NO_DMA, 49),
+	MEM_ROT_PP_MEM = _MAKE_CHAN(3, 47, NO_DMA, NO_DMA, 50),
+
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(4, 12, 14, 17, 20),
+	MEM_PRP_VF_MEM = _MAKE_CHAN(5, 12, 14, 17, 21),
+	MEM_PP_MEM = _MAKE_CHAN(6, 11, 15, 18, 22),
+
+	MEM_DC_SYNC = _MAKE_CHAN(7, 28, NO_DMA, NO_DMA, NO_DMA),
+	MEM_DC_ASYNC = _MAKE_CHAN(8, 41, NO_DMA, NO_DMA, NO_DMA),
+	MEM_BG_SYNC = _MAKE_CHAN(9, 23, NO_DMA, 51, NO_DMA),
+	MEM_FG_SYNC = _MAKE_CHAN(10, 27, NO_DMA, 31, NO_DMA),
+
+	MEM_BG_ASYNC0 = _MAKE_CHAN(11, 24, NO_DMA, 52, NO_DMA),
+	MEM_FG_ASYNC0 = _MAKE_CHAN(12, 29, NO_DMA, 33, NO_DMA),
+	MEM_BG_ASYNC1 = _MAKE_ALT_CHAN(MEM_BG_ASYNC0),
+	MEM_FG_ASYNC1 = _MAKE_ALT_CHAN(MEM_FG_ASYNC0),
+
+	DIRECT_ASYNC0 = _MAKE_CHAN(13, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+	DIRECT_ASYNC1 = _MAKE_CHAN(14, NO_DMA, NO_DMA, NO_DMA, NO_DMA),
+
+	CSI_MEM0 = _MAKE_CHAN(15, NO_DMA, NO_DMA, NO_DMA, 0),
+	CSI_MEM1 = _MAKE_CHAN(16, NO_DMA, NO_DMA, NO_DMA, 1),
+	CSI_MEM2 = _MAKE_CHAN(17, NO_DMA, NO_DMA, NO_DMA, 2),
+	CSI_MEM3 = _MAKE_CHAN(18, NO_DMA, NO_DMA, NO_DMA, 3),
+
+	CSI_MEM = CSI_MEM0,
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(19, NO_DMA, NO_DMA, NO_DMA, 20),
+	CSI_PRP_VF_MEM = _MAKE_CHAN(20, NO_DMA, NO_DMA, NO_DMA, 21),
+
+	MEM_VDI_PRP_VF_MEM_P = _MAKE_CHAN(21, 8, 14, 17, 21),
+	MEM_VDI_PRP_VF_MEM = _MAKE_CHAN(22, 9, 14, 17, 21),
+	MEM_VDI_PRP_VF_MEM_N = _MAKE_CHAN(23, 10, 14, 17, 21),
+
+	MEM_PP_ADC = CHAN_NONE,
+	ADC_SYS2 = CHAN_NONE,
+#endif
+
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_OUTPUT_BUFFER = 0,	/*!< Buffer for output from IPU */
+	IPU_ALPHA_IN_BUFFER = 1,	/*!< Buffer for input to IPU */
+	IPU_GRAPH_IN_BUFFER = 2,	/*!< Buffer for input to IPU */
+	IPU_VIDEO_IN_BUFFER = 3,	/*!< Buffer for input to IPU */
+	IPU_INPUT_BUFFER = IPU_VIDEO_IN_BUFFER,
+	IPU_SEC_INPUT_BUFFER = IPU_GRAPH_IN_BUFFER,
+} ipu_buffer_t;
+
+#define IPU_PANEL_SERIAL		1
+#define IPU_PANEL_PARALLEL		2
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t csi;
+		bool mipi_en;
+		uint32_t mipi_id;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t csi;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t csi;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+		ipu_motion_sel motion_sel;
+		enum v4l2_field field_fmt;
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		uint32_t outh_resize_ratio;
+		uint32_t outv_resize_ratio;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		uint32_t in_g_pixel_fmt;
+		uint8_t alpha;
+		uint32_t key_color;
+		bool alpha_chan_en;
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+	struct {
+		pf_operation_t operation;
+	} mem_pf_mem;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+	} mem_dc_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+		bool alpha_chan_en;
+	} mem_dp_bg_sync;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		uint32_t di;
+		bool interlaced;
+		uint32_t in_pixel_fmt;
+		uint32_t out_pixel_fmt;
+		bool alpha_chan_en;
+	} mem_dp_fg_sync;
+	struct {
+		uint32_t di;
+	} direct_async;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+#ifdef CONFIG_MXC_IPU_V1
+	IPU_IRQ_DC_FC_1 = -1,
+
+	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
+	IPU_IRQ_PRP_VF_OUT_EOF = 1,
+	IPU_IRQ_PP_OUT_EOF = 2,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
+	IPU_IRQ_PP_IN_EOF = 5,
+	IPU_IRQ_PRP_IN_EOF = 6,
+	IPU_IRQ_SENSOR_OUT_EOF = 7,
+	IPU_IRQ_CSI0_OUT_EOF = IPU_IRQ_SENSOR_OUT_EOF,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
+	IPU_IRQ_PP_ROT_OUT_EOF = 12,
+	IPU_IRQ_PP_ROT_IN_EOF = 13,
+	IPU_IRQ_BG_SYNC_EOF = 14,
+	IPU_IRQ_SDC_BG_EOF = IPU_IRQ_BG_SYNC_EOF,
+	IPU_IRQ_FG_SYNC_EOF = 15,
+	IPU_IRQ_SDC_FG_EOF = IPU_IRQ_FG_SYNC_EOF,
+	IPU_IRQ_SDC_MASK_EOF = 16,
+	IPU_IRQ_SDC_BG_PART_EOF = 17,
+	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
+	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
+	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
+	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
+	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
+	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
+	IPU_IRQ_PF_QP_IN_EOF = 24,
+	IPU_IRQ_PF_BSP_IN_EOF = 25,
+	IPU_IRQ_PF_Y_IN_EOF = 26,
+	IPU_IRQ_PF_U_IN_EOF = 27,
+	IPU_IRQ_PF_V_IN_EOF = 28,
+	IPU_IRQ_PF_Y_OUT_EOF = 29,
+	IPU_IRQ_PF_U_OUT_EOF = 30,
+	IPU_IRQ_PF_V_OUT_EOF = 31,
+
+	IPU_IRQ_PRP_ENC_OUT_NF = 32,
+	IPU_IRQ_PRP_VF_OUT_NF = 33,
+	IPU_IRQ_PP_OUT_NF = 34,
+	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
+	IPU_IRQ_PP_GRAPH_IN_NF = 36,
+	IPU_IRQ_PP_IN_NF = 37,
+	IPU_IRQ_PRP_IN_NF = 38,
+	IPU_IRQ_SENSOR_OUT_NF = 39,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
+	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
+	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
+	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
+	IPU_IRQ_PP_ROT_OUT_NF = 44,
+	IPU_IRQ_PP_ROT_IN_NF = 45,
+	IPU_IRQ_SDC_FG_NF = 46,
+	IPU_IRQ_SDC_BG_NF = 47,
+	IPU_IRQ_SDC_MASK_NF = 48,
+	IPU_IRQ_SDC_BG_PART_NF = 49,
+	IPU_IRQ_ADC_SYS1_WR_NF = 50,
+	IPU_IRQ_ADC_SYS2_WR_NF = 51,
+	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
+	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
+	IPU_IRQ_ADC_SYS1_RD_NF = 54,
+	IPU_IRQ_ADC_SYS2_RD_NF = 55,
+	IPU_IRQ_PF_QP_IN_NF = 56,
+	IPU_IRQ_PF_BSP_IN_NF = 57,
+	IPU_IRQ_PF_Y_IN_NF = 58,
+	IPU_IRQ_PF_U_IN_NF = 59,
+	IPU_IRQ_PF_V_IN_NF = 60,
+	IPU_IRQ_PF_Y_OUT_NF = 61,
+	IPU_IRQ_PF_U_OUT_NF = 62,
+	IPU_IRQ_PF_V_OUT_NF = 63,
+
+	IPU_IRQ_BREAKRQ = 64,
+	IPU_IRQ_SDC_BG_OUT_EOF = 65,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_SDC_BG_OUT_EOF,
+	IPU_IRQ_SDC_FG_OUT_EOF = 66,
+	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
+	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
+	IPU_IRQ_SENSOR_NF = 69,
+	IPU_IRQ_SENSOR_EOF = 70,
+	IPU_IRQ_SDC_DISP3_VSYNC = 80,
+	IPU_IRQ_ADC_DISP0_VSYNC = 81,
+	IPU_IRQ_ADC_DISP12_VSYNC = 82,
+	IPU_IRQ_ADC_PRP_EOF = 83,
+	IPU_IRQ_ADC_PP_EOF = 84,
+	IPU_IRQ_ADC_SYS1_EOF = 85,
+	IPU_IRQ_ADC_SYS2_EOF = 86,
+
+	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
+	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
+	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
+	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
+	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
+	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
+	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
+	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
+	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
+	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
+	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
+	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
+	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
+	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
+	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
+	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
+	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
+	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
+	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
+	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
+	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
+	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
+	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
+	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
+	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
+	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
+	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
+	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
+	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
+	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
+	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
+
+	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
+	IPU_IRQ_ENC_BUFOVF_ERR = 129,
+	IPU_IRQ_VF_BUFOVF_ERR = 130,
+	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
+	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
+	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
+	IPU_IRQ_SDC_BGD_ERR = 134,
+	IPU_IRQ_SDC_FGD_ERR = 135,
+	IPU_IRQ_SDC_MASKD_ERR = 136,
+	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
+	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
+	IPU_IRQ_VF_FRM_LOST_ERR = 139,
+	IPU_IRQ_ADC_LOCK_ERR = 140,
+	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
+	IPU_IRQ_AHB_M1_ERR = 142,
+	IPU_IRQ_AHB_M12_ERR = 143,
+#else
+	IPU_IRQ_CSI0_OUT_EOF = 0,
+	IPU_IRQ_CSI1_OUT_EOF = 1,
+	IPU_IRQ_CSI2_OUT_EOF = 2,
+	IPU_IRQ_CSI3_OUT_EOF = 3,
+	IPU_IRQ_VDI_P_IN_EOF = 8,
+	IPU_IRQ_VDI_C_IN_EOF = 9,
+	IPU_IRQ_VDI_N_IN_EOF = 10,
+	IPU_IRQ_PP_IN_EOF = 11,
+	IPU_IRQ_PRP_IN_EOF = 12,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
+	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
+	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
+	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
+	IPU_IRQ_PRP_VF_OUT_EOF = 21,
+	IPU_IRQ_PP_OUT_EOF = 22,
+	IPU_IRQ_BG_SYNC_EOF = 23,
+	IPU_IRQ_BG_ASYNC_EOF = 24,
+	IPU_IRQ_FG_SYNC_EOF = 27,
+	IPU_IRQ_DC_SYNC_EOF = 28,
+	IPU_IRQ_FG_ASYNC_EOF = 29,
+	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
+
+	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
+	IPU_IRQ_DC_READ_EOF = 40,
+	IPU_IRQ_DC_ASYNC_EOF = 41,
+	IPU_IRQ_DC_CMD1_EOF = 42,
+	IPU_IRQ_DC_CMD2_EOF = 43,
+	IPU_IRQ_DC_MASK_EOF = 44,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 45,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 46,
+	IPU_IRQ_PP_ROT_IN_EOF = 47,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 48,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 49,
+	IPU_IRQ_PP_ROT_OUT_EOF = 50,
+	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
+	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
+
+	IPU_IRQ_DP_SF_START = 448 + 2,
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_BG_SF_END = IPU_IRQ_DP_SF_END,
+	IPU_IRQ_DC_FC_0 = 448 + 8,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+	IPU_IRQ_DC_FC_2 = 448 + 10,
+	IPU_IRQ_DC_FC_3 = 448 + 11,
+	IPU_IRQ_DC_FC_4 = 448 + 12,
+	IPU_IRQ_DC_FC_6 = 448 + 13,
+	IPU_IRQ_VSYNC_PRE_0 = 448 + 14,
+	IPU_IRQ_VSYNC_PRE_1 = 448 + 15,
+#endif
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned ext_clk:1;
+	unsigned interlaced:1;
+	unsigned odd_field_first:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+
+typedef struct {
+	unsigned data_width:4;
+	unsigned clk_mode:3;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+	unsigned pack_tight:1;
+	unsigned force_eof:1;
+	unsigned data_en_pol:1;
+	unsigned data_fmt;
+	unsigned csi;
+	unsigned mclk;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4,
+	IPU_CSI_DATA_WIDTH_8,
+	IPU_CSI_DATA_WIDTH_10,
+	IPU_CSI_DATA_WIDTH_16,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR,
+	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR,
+};
+
+enum {
+	IPU_CSI_MIPI_DI0,
+	IPU_CSI_MIPI_DI1,
+	IPU_CSI_MIPI_DI2,
+	IPU_CSI_MIPI_DI3,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned rs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) (((rs) << 29) | ((fc) << 27) | \
+			((oc) << 24) | (dat))
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+/* Common IPU API */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t *params);
+void ipu_uninit_channel(ipu_channel_t channel);
+
+static inline bool ipu_can_rotate_in_place(ipu_rotate_mode_t rot)
+{
+#ifdef CONFIG_MXC_IPU_V3D
+	return (rot < IPU_ROTATE_HORIZ_FLIP);
+#else
+	return (rot < IPU_ROTATE_90_RIGHT);
+#endif
+}
+
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_update_channel_offset(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				uint32_t u, uint32_t v,
+				uint32_t vertical_offset, uint32_t horizontal_offset);
+
+int32_t ipu_select_buffer(ipu_channel_t channel,
+			  ipu_buffer_t type, uint32_t bufNum);
+int32_t ipu_select_multi_vdi_buffer(uint32_t bufNum);
+
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_is_channel_busy(ipu_channel_t channel);
+int32_t ipu_check_buffer_busy(ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t bufNum);
+void ipu_clear_buffer_ready(ipu_channel_t channel, ipu_buffer_t type,
+		uint32_t bufNum);
+uint32_t ipu_get_cur_buffer_idx(ipu_channel_t channel, ipu_buffer_t type);
+int32_t ipu_enable_channel(ipu_channel_t channel);
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
+int32_t ipu_swap_channel(ipu_channel_t from_ch, ipu_channel_t to_ch);
+
+int32_t ipu_enable_csi(uint32_t csi);
+int32_t ipu_disable_csi(uint32_t csi);
+
+int ipu_lowpwr_display_enable(void);
+int ipu_lowpwr_display_disable(void);
+
+void ipu_enable_irq(uint32_t irq);
+void ipu_disable_irq(uint32_t irq);
+void ipu_clear_irq(uint32_t irq);
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(uint32_t irq);
+void ipu_set_csc_coefficients(ipu_channel_t channel, int32_t param[][3]);
+
+/* SDC API */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t hStartWidth, uint16_t hSyncWidth,
+			   uint16_t hEndWidth, uint16_t vStartWidth,
+			   uint16_t vSyncWidth, uint16_t vEndWidth,
+			   ipu_di_signal_cfg_t sig);
+
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t colorKey);
+int32_t ipu_sdc_set_brightness(uint8_t value);
+
+int32_t ipu_init_sync_panel(int disp,
+			    uint32_t pixel_clk,
+			    uint16_t width, uint16_t height,
+			    uint32_t pixel_fmt,
+			    uint16_t h_start_width, uint16_t h_sync_width,
+			    uint16_t h_end_width, uint16_t v_start_width,
+			    uint16_t v_sync_width, uint16_t v_end_width,
+			    uint32_t v_to_h_sync, ipu_di_signal_cfg_t sig);
+
+int32_t ipu_disp_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+				int16_t y_pos);
+int32_t ipu_disp_get_window_pos(ipu_channel_t channel, int16_t *x_pos,
+				int16_t *y_pos);
+int32_t ipu_disp_set_global_alpha(ipu_channel_t channel, bool enable,
+				  uint8_t alpha);
+int32_t ipu_disp_set_color_key(ipu_channel_t channel, bool enable,
+			       uint32_t colorKey);
+int32_t ipu_disp_set_gamma_correction(ipu_channel_t channel, bool enable,
+				int constk[], int slopek[]);
+
+int ipu_init_async_panel(int disp, int type, uint32_t cycle_time,
+			 uint32_t pixel_fmt, ipu_adc_sig_cfg_t sig);
+void ipu_disp_direct_write(ipu_channel_t channel, u32 value, u32 offset);
+void ipu_reset_disp_panel(void);
+
+/* ADC API */
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t *pCmd,
+			       bool write);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t *size);
+
+int32_t ipu_adc_get_snooping_status(uint32_t *statl, uint32_t *stath);
+
+int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+			  uint32_t cmd, const uint32_t *params,
+			  uint16_t numParams);
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
+			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
+
+static inline int32_t ipu_csi_enable_mclk_if(int src, uint32_t csi,
+		bool flag, bool wait)
+{
+#ifdef CONFIG_MXC_IPU_V1
+	return ipu_csi_enable_mclk(src, flag, wait);
+#else
+	return ipu_csi_enable_mclk(csi, flag, wait);
+#endif
+}
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(uint32_t *width, uint32_t *height, uint32_t csi);
+
+void ipu_csi_set_window_size(uint32_t width, uint32_t height, uint32_t csi);
+
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top, uint32_t csi);
+
+/* Post Filter functions */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+/* New added for IPU-lib functionality*/
+int ipu_open(void);
+int ipu_register_generic_isr(int irq, void *dev);
+void ipu_close(void);
+
+/* two stripe calculations */
+struct stripe_param{
+	unsigned int input_width; /* width of the input stripe */
+	unsigned int output_width; /* width of the output stripe */
+	unsigned int input_column; /* the first column on the input stripe */
+	unsigned int output_column; /* the first column on the output stripe */
+	unsigned int idr;
+	/* inverse downisizing ratio parameter; expressed as a power of 2 */
+	unsigned int irr;
+	/* inverse resizing ratio parameter; expressed as a multiple of 2^-13 */
+};
+
+typedef struct _ipu_stripe_parm {
+	unsigned int input_width;
+	unsigned int output_width;
+	unsigned int maximal_stripe_width;
+	unsigned long long cirr;
+	unsigned int equal_stripes;
+	u32 input_pixelformat;
+	u32 output_pixelformat;
+	struct stripe_param left;
+	struct stripe_param right;
+} ipu_stripe_parm;
+
+typedef struct _ipu_channel_parm {
+	ipu_channel_t channel;
+	ipu_channel_params_t params;
+	bool flag;
+} ipu_channel_parm;
+
+typedef struct _ipu_channel_buf_parm {
+	ipu_channel_t channel;
+	ipu_buffer_t type;
+	uint32_t pixel_fmt;
+	uint16_t width;
+	uint16_t height;
+	uint16_t stride;
+	ipu_rotate_mode_t rot_mode;
+	dma_addr_t phyaddr_0;
+	dma_addr_t phyaddr_1;
+	uint32_t u_offset;
+	uint32_t v_offset;
+	uint32_t bufNum;
+} ipu_channel_buf_parm;
+
+typedef struct _ipu_buf_offset_parm {
+	ipu_channel_t channel;
+	ipu_buffer_t type;
+	uint32_t pixel_fmt;
+	uint16_t width;
+	uint16_t height;
+	uint16_t stride;
+	uint32_t u_offset;
+	uint32_t v_offset;
+	uint32_t vertical_offset;
+	uint32_t horizontal_offset;
+} ipu_buf_offset_parm;
+
+typedef struct _ipu_channel_link {
+	ipu_channel_t src_ch;
+	ipu_channel_t dest_ch;
+} ipu_channel_link;
+
+typedef struct _ipu_channel_info {
+	ipu_channel_t channel;
+	bool stop;
+} ipu_channel_info;
+
+typedef struct ipu_irq_info {
+	uint32_t irq;
+	 irqreturn_t(*handler) (int, void *);
+	uint32_t irq_flags;
+	char *devname;
+	void *dev_id;
+} ipu_irq_info;
+
+typedef struct _ipu_sdc_panel_info {
+	ipu_panel_t panel;
+	uint32_t pixel_clk;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint16_t hStartWidth;
+	uint16_t hSyncWidth;
+	uint16_t hEndWidth;
+	uint16_t vStartWidth;
+	uint16_t vSyncWidth;
+	uint16_t vEndWidth;
+	ipu_di_signal_cfg_t signal;
+} ipu_sdc_panel_info;
+
+typedef struct _ipu_sdc_window_pos {
+	ipu_channel_t channel;
+	int16_t x_pos;
+	int16_t y_pos;
+} ipu_sdc_window_pos;
+
+typedef struct _ipu_sdc_global_alpha {
+	bool enable;
+	uint8_t alpha;
+} ipu_sdc_global_alpha;
+
+typedef struct _ipu_sdc_color_key {
+	ipu_channel_t channel;
+	bool enable;
+	uint32_t colorKey;
+} ipu_sdc_color_key;
+
+typedef struct _ipu_adc_template {
+	display_port_t disp;
+	uint32_t *pCmd;
+	bool write;
+} ipu_adc_template;
+
+typedef struct _ipu_adc_update {
+	ipu_channel_t channel;
+	ipu_adc_update_mode_t mode;
+	uint32_t refresh_rate;
+	unsigned long addr;
+	uint32_t *size;
+} ipu_adc_update;
+
+typedef struct _ipu_adc_snoop {
+	uint32_t *statl;
+	uint32_t *stath;
+} ipu_adc_snoop;
+
+typedef struct _ipu_adc_cmd {
+	display_port_t disp;
+	cmddata_t type;
+	uint32_t cmd;
+	uint32_t *params;
+	uint16_t numParams;
+} ipu_adc_cmd;
+
+typedef struct _ipu_adc_panel {
+	display_port_t disp;
+	uint16_t width;
+	uint16_t height;
+	uint32_t pixel_fmt;
+	uint32_t stride;
+	ipu_adc_sig_cfg_t signal;
+	display_addressing_t addr;
+	uint32_t vsync_width;
+	vsync_t mode;
+} ipu_adc_panel;
+
+typedef struct _ipu_adc_ifc_timing {
+	display_port_t disp;
+	bool read;
+	uint32_t cycle_time;
+	uint32_t up_time;
+	uint32_t down_time;
+	uint32_t read_latch_time;
+	uint32_t pixel_clk;
+} ipu_adc_ifc_timing;
+
+typedef struct _ipu_csi_interface {
+	uint16_t width;
+	uint16_t height;
+	uint16_t pixel_fmt;
+	ipu_csi_signal_cfg_t signal;
+} ipu_csi_interface;
+
+typedef struct _ipu_csi_mclk {
+	int src;
+	bool flag;
+	bool wait;
+} ipu_csi_mclk;
+
+typedef struct _ipu_csi_window {
+	uint32_t left;
+	uint32_t top;
+} ipu_csi_window;
+
+typedef struct _ipu_csi_window_size {
+	uint32_t width;
+	uint32_t height;
+} ipu_csi_window_size;
+
+typedef struct _ipu_event_info {
+	int irq;
+	void *dev;
+} ipu_event_info;
+
+typedef struct _ipu_mem_info {
+	dma_addr_t paddr;
+	void *vaddr;
+	int size;
+} ipu_mem_info;
+
+typedef struct _ipu_csc_update {
+	ipu_channel_t channel;
+	int **param;
+} ipu_csc_update;
+
+/* IOCTL commands */
+
+#define IPU_INIT_CHANNEL              _IOW('I', 0x1, ipu_channel_parm)
+#define IPU_UNINIT_CHANNEL            _IOW('I', 0x2, ipu_channel_t)
+#define IPU_INIT_CHANNEL_BUFFER       _IOW('I', 0x3, ipu_channel_buf_parm)
+#define IPU_UPDATE_CHANNEL_BUFFER     _IOW('I', 0x4, ipu_channel_buf_parm)
+#define IPU_SELECT_CHANNEL_BUFFER     _IOW('I', 0x5, ipu_channel_buf_parm)
+#define IPU_LINK_CHANNELS             _IOW('I', 0x6, ipu_channel_link)
+#define IPU_UNLINK_CHANNELS           _IOW('I', 0x7, ipu_channel_link)
+#define IPU_ENABLE_CHANNEL            _IOW('I', 0x8, ipu_channel_t)
+#define IPU_DISABLE_CHANNEL           _IOW('I', 0x9, ipu_channel_info)
+#define IPU_ENABLE_IRQ                _IOW('I', 0xA, int)
+#define IPU_DISABLE_IRQ               _IOW('I', 0xB, int)
+#define IPU_CLEAR_IRQ                 _IOW('I', 0xC, int)
+#define IPU_FREE_IRQ                  _IOW('I', 0xD, ipu_irq_info)
+#define IPU_REQUEST_IRQ_STATUS        _IOW('I', 0xE, int)
+#define IPU_SDC_INIT_PANEL            _IOW('I', 0xF, ipu_sdc_panel_info)
+#define IPU_SDC_SET_WIN_POS           _IOW('I', 0x10, ipu_sdc_window_pos)
+#define IPU_SDC_SET_GLOBAL_ALPHA      _IOW('I', 0x11, ipu_sdc_global_alpha)
+#define IPU_SDC_SET_COLOR_KEY         _IOW('I', 0x12, ipu_sdc_color_key)
+#define IPU_SDC_SET_BRIGHTNESS        _IOW('I', 0x13, int)
+#define IPU_ADC_WRITE_TEMPLATE        _IOW('I', 0x14, ipu_adc_template)
+#define IPU_ADC_UPDATE                _IOW('I', 0x15, ipu_adc_update)
+#define IPU_ADC_SNOOP                 _IOW('I', 0x16, ipu_adc_snoop)
+#define IPU_ADC_CMD                   _IOW('I', 0x17, ipu_adc_cmd)
+#define IPU_ADC_INIT_PANEL            _IOW('I', 0x18, ipu_adc_panel)
+#define IPU_ADC_IFC_TIMING            _IOW('I', 0x19, ipu_adc_ifc_timing)
+#define IPU_CSI_INIT_INTERFACE        _IOW('I', 0x1A, ipu_csi_interface)
+#define IPU_CSI_ENABLE_MCLK           _IOW('I', 0x1B, ipu_csi_mclk)
+#define IPU_CSI_READ_MCLK_FLAG        _IOR('I', 0x1C, ipu_csi_mclk)
+#define IPU_CSI_FLASH_STROBE          _IOW('I', 0x1D, ipu_csi_mclk)
+#define IPU_CSI_GET_WIN_SIZE          _IOR('I', 0x1E, ipu_csi_window_size)
+#define IPU_CSI_SET_WIN_SIZE          _IOW('I', 0x1F, ipu_csi_window_size)
+#define IPU_CSI_SET_WINDOW            _IOW('I', 0x20, ipu_csi_window)
+#define IPU_PF_SET_PAUSE_ROW          _IOW('I', 0x21, uint32_t)
+#define IPU_REGISTER_GENERIC_ISR      _IOW('I', 0x22, ipu_event_info)
+#define IPU_GET_EVENT                 _IOWR('I', 0x23, ipu_event_info)
+#define IPU_ALOC_MEM		      _IOWR('I', 0x24, ipu_mem_info)
+#define IPU_FREE_MEM		      _IOW('I', 0x25, ipu_mem_info)
+#define IPU_IS_CHAN_BUSY	      _IOW('I', 0x26, ipu_channel_t)
+#define IPU_CALC_STRIPES_SIZE	      _IOWR('I', 0x27, ipu_stripe_parm)
+#define IPU_UPDATE_BUF_OFFSET         _IOW('I', 0x28, ipu_buf_offset_parm)
+#define IPU_CSC_UPDATE                _IOW('I', 0x29, ipu_csc_update)
+#define IPU_SELECT_MULTI_VDI_BUFFER   _IOW('I', 0x2A, uint32_t)
+
+int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
+				unsigned int output_frame_width,
+				const unsigned int maximal_stripe_width,
+				const unsigned long long cirr,
+				const unsigned int equal_stripes,
+				u32 input_pixelformat,
+				u32 output_pixelformat,
+				struct stripe_param *left,
+				struct stripe_param *right);
+#endif
diff --git a/include/linux/iram_alloc.h b/include/linux/iram_alloc.h
new file mode 100644
index 0000000..12881aa
--- /dev/null
+++ b/include/linux/iram_alloc.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301, USA.
+ */
+
+#ifdef CONFIG_IRAM_ALLOC
+int __init iram_init(unsigned long base, unsigned long size);
+void *iram_alloc(unsigned int size, unsigned long *dma_addr);
+void iram_free(unsigned long dma_addr, unsigned int size);
+#else
+static inline int __init iram_init(unsigned long base, unsigned long size)
+{
+	return -ENOMEM;
+}
+static inline void *iram_alloc(unsigned int size, unsigned long *dma_addr)
+{
+	return NULL;
+}
+static inline void iram_free(unsigned long base, unsigned long size) {}
+#endif
+
diff --git a/include/linux/ldb.h b/include/linux/ldb.h
new file mode 100644
index 0000000..6540694
--- /dev/null
+++ b/include/linux/ldb.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file include/linux/ldb.h
+ *
+ * @brief This file contains the LDB driver API declarations.
+ *
+ * @ingroup LDB
+ */
+
+#ifndef __MXC_LDB_H__
+#define __MXC_LDB_H__
+
+#include <linux/types.h>
+
+typedef enum {
+	LDB_INT_REF = 0,
+	LDB_EXT_REF = 1,
+} ldb_bgref_t;
+
+typedef enum {
+	LDB_VS_ACT_H = 0,
+	LDB_VS_ACT_L = 1,
+} ldb_vsync_t;
+
+typedef enum {
+	LDB_BIT_MAP_SPWG = 0,
+	LDB_BIT_MAP_JEIDA = 1,
+} ldb_bitmap_t;
+
+typedef enum {
+	LDB_CHAN_MODE_SIN = 0,
+	LDB_CHAN_MODE_SEP = 1,
+	LDB_CHAN_MODE_DUL = 2,
+	LDB_CHAN_MODE_SPL = 3,
+} ldb_channel_mode_t;
+
+typedef struct _ldb_bgref_parm {
+	ldb_bgref_t		bgref_mode;
+} ldb_bgref_parm;
+
+typedef struct _ldb_vsync_parm {
+	int			di;
+	ldb_vsync_t		vsync_mode;
+} ldb_vsync_parm;
+
+typedef struct _ldb_bitmap_parm {
+	int			channel;
+	ldb_bitmap_t		bitmap_mode;
+} ldb_bitmap_parm;
+
+typedef struct _ldb_data_width_parm {
+	int			channel;
+	int			data_width;
+} ldb_data_width_parm;
+
+typedef struct _ldb_chan_mode_parm {
+	int				di;
+	ldb_channel_mode_t		channel_mode;
+} ldb_chan_mode_parm;
+
+/* IOCTL commands */
+#define LDB_BGREF_RMODE			_IOW('L', 0x1, ldb_bgref_parm)
+#define LDB_VSYNC_POL			_IOW('L', 0x2, ldb_vsync_parm)
+#define LDB_BIT_MAP			_IOW('L', 0x3, ldb_bitmap_parm)
+#define LDB_DATA_WIDTH			_IOW('L', 0x4, ldb_data_width_parm)
+#define LDB_CHAN_MODE			_IOW('L', 0x5, ldb_chan_mode_parm)
+#define LDB_ENABLE			_IOW('L', 0x6, int)
+#define LDB_DISABLE			_IOW('L', 0x7, int)
+#endif
diff --git a/include/linux/major.h b/include/linux/major.h
index 6a8ca98..052b053 100644
--- a/include/linux/major.h
+++ b/include/linux/major.h
@@ -171,6 +171,8 @@
 
 #define VIOTAPE_MAJOR		230
 
+#define LBA_MAJOR		240
+
 #define BLOCK_EXT_MAJOR		259
 #define SCSI_OSD_MAJOR		260	/* open-osd's OSD scsi device */
 
diff --git a/include/linux/mfd/mc13783/core.h b/include/linux/mfd/mc13783/core.h
new file mode 100644
index 0000000..3a06891
--- /dev/null
+++ b/include/linux/mfd/mc13783/core.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13783_CORE_H_
+#define __LINUX_MFD_MC13783_CORE_H_
+
+#include <linux/kernel.h>
+
+/*!
+ * brief PMIC regulators.
+ */
+#define MC13783_SW1A 0
+#define MC13783_SW1B 1
+#define MC13783_SW2A 2
+#define MC13783_SW2B 3
+#define MC13783_SW3 4
+#define MC13783_VAUDIO 5
+#define MC13783_VIOHI 6
+#define MC13783_VIOLO 7
+#define MC13783_VDIG 8
+#define MC13783_VGEN 9
+#define MC13783_VRFDIG 10
+#define MC13783_VRFREF 11
+#define MC13783_VRFCP 12
+#define MC13783_VSIM 13
+#define MC13783_VESIM 14
+#define MC13783_VCAM 15
+#define MC13783_VRFBG 16
+#define MC13783_VVIB 17
+#define MC13783_VRF1 18
+#define MC13783_VRF2 19
+#define MC13783_VMMC1 20
+#define MC13783_VMMC2 21
+#define MC13783_GPO1 22
+#define MC13783_GPO2 23
+#define MC13783_GPO3 24
+#define MC13783_GPO4 25
+#define MC13783_REG_NUM 26
+
+struct mc13783;
+struct regulator_init_data;
+
+struct mc13783_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC13783_REG_NUM];
+};
+
+struct mc13783 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc13783_pmic pmic;
+};
+
+int mc13783_register_regulator(struct mc13783 *mc13783, int reg,
+			       struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/mfd/mc13892/core.h b/include/linux/mfd/mc13892/core.h
new file mode 100644
index 0000000..3924e2e
--- /dev/null
+++ b/include/linux/mfd/mc13892/core.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13892_CORE_H_
+#define __LINUX_MFD_MC13892_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define MC13892_SW1 0
+#define MC13892_SW2 1
+#define MC13892_SW3 2
+#define MC13892_SW4 3
+#define MC13892_SWBST 4
+#define MC13892_VIOHI 5
+#define MC13892_VPLL 6
+#define MC13892_VDIG 7
+#define MC13892_VSD 8
+#define MC13892_VUSB2 9
+#define MC13892_VVIDEO 10
+#define MC13892_VAUDIO 11
+#define MC13892_VCAM 12
+#define MC13892_VGEN1 13
+#define MC13892_VGEN2 14
+#define MC13892_VGEN3 15
+#define MC13892_VUSB 16
+#define MC13892_GPO1 17
+#define MC13892_GPO2 18
+#define MC13892_GPO3 19
+#define MC13892_GPO4 20
+#define MC13892_PWGT1 21
+#define MC13892_PWGT2 22
+#define MC13892_REG_NUM 23
+
+struct mc13892;
+struct regulator_init_data;
+
+struct mc13892_platform_data {
+	int (*init)(struct mc13892 *);
+};
+
+struct mc13892_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC13892_REG_NUM];
+};
+
+struct mc13892 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc13892_pmic pmic;
+};
+
+int mc13892_register_regulator(struct mc13892 *mc13892, int reg,
+			      struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/mfd/mc34704/core.h b/include/linux/mfd/mc34704/core.h
new file mode 100644
index 0000000..f63ef08
--- /dev/null
+++ b/include/linux/mfd/mc34704/core.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC34704_CORE_H_
+#define __LINUX_MFD_MC34704_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define	MC34704_BKLT	0	/* REG1 5V for Backlight */
+#define	MC34704_CPU	1	/* REG2 3.3V for CPU & CPU board peripherals */
+#define	MC34704_CORE	2	/* REG3 1.45V for CPU Core */
+#define	MC34704_DDR	3	/* REG4 1.8V for DDR */
+#define	MC34704_PERS	4	/* REG5 3.3V for Personality board */
+#define	MC34704_REG6	5	/* REG6 not used */
+#define	MC34704_REG7	6	/* REG7 not used */
+#define	MC34704_REG8	7	/* REG8 not used */
+#define	MC34704_REG_NUM	8
+
+/* Regulator voltages in mV and dynamic voltage scaling limits in percent */
+
+#define REG1_V_MV		5000
+#define REG1_DVS_MIN_PCT	(-10)
+#define REG1_DVS_MAX_PCT	10
+
+#define REG2_V_MV		3300
+#define REG2_DVS_MIN_PCT	(-20)
+#define REG2_DVS_MAX_PCT	17.5
+
+#define REG3_V_MV		1450
+#define REG3_DVS_MIN_PCT	(-20)
+#define REG3_DVS_MAX_PCT	17.5
+
+#define REG4_V_MV		1800
+#define REG4_DVS_MIN_PCT	(-20)
+#define REG4_DVS_MAX_PCT	17.5
+
+#define REG5_V_MV		3300
+#define REG5_DVS_MIN_PCT	(-20)
+#define REG5_DVS_MAX_PCT	17.5
+
+struct mc34704;
+struct regulator_init_data;
+
+struct mc34704_platform_data {
+	int (*init) (struct mc34704 *);
+};
+
+struct mc34704_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC34704_REG_NUM];
+};
+
+struct mc34704 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc34704_pmic pmic;
+};
+
+int mc34704_register_regulator(struct mc34704 *mc34704, int reg,
+			       struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/mfd/mc9s08dz60/core.h b/include/linux/mfd/mc9s08dz60/core.h
new file mode 100644
index 0000000..d568f65
--- /dev/null
+++ b/include/linux/mfd/mc9s08dz60/core.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __LINUX_MFD_MC13892_CORE_H_
+#define __LINUX_MFD_MC13892_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define MC9S08DZ60_LCD 0
+#define MC9S08DZ60_WIFI 1
+#define MC9S08DZ60_HDD 2
+#define MC9S08DZ60_GPS 3
+#define MC9S08DZ60_SPKR 4
+#define MC9S08DZ60_REG_NUM 5
+
+struct mc9s08dz60;
+struct regulator_init_data;
+
+struct mc9s08dz60_platform_data {
+	int (*init)(struct mc9s08dz60 *);
+};
+
+struct mc9s08dz60_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC9S08DZ60_REG_NUM];
+};
+
+struct mc9s08dz60 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc9s08dz60_pmic pmic;
+};
+
+int mc9s08dz60_register_regulator(struct mc9s08dz60 *mc9s08dz60, int reg,
+			      struct regulator_init_data *initdata);
+
+#endif
diff --git a/include/linux/mfd/mc9s08dz60/pmic.h b/include/linux/mfd/mc9s08dz60/pmic.h
new file mode 100644
index 0000000..67a6822
--- /dev/null
+++ b/include/linux/mfd/mc9s08dz60/pmic.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+
+#ifndef __LINUX_MCU_PMIC_H_
+#define __LINUX_MCU_PMIC_H_
+
+enum {
+
+	/*reg names for mcu */
+	REG_MCU_VERSION = 0,
+	REG_MCU_SECS,
+	REG_MCU_MINS,
+	REG_MCU_HRS,
+	REG_MCU_DAY,
+	REG_MCU_DATE,
+	REG_MCU_MONTH,
+	REG_MCU_YEAR,
+	REG_MCU_ALARM_SECS,
+	REG_MCU_ALARM_MINS,
+	REG_MCU_ALARM_HRS,
+	REG_MCU_TS_CONTROL,
+	REG_MCU_X_LOW,
+	REG_MCU_Y_LOW,
+	REG_MCU_XY_HIGH,
+	REG_MCU_X_LEFT_LOW,
+	REG_MCU_X_LEFT_HIGH,
+	REG_MCU_X_RIGHT,
+	REG_MCU_Y_TOP_LOW,
+	REG_MCU_Y_TOP_HIGH,
+	REG_MCU_Y_BOTTOM,
+	REG_MCU_RESET_1,
+	REG_MCU_RESET_2,
+	REG_MCU_POWER_CTL,
+	REG_MCU_DELAY_CONFIG,
+	REG_MCU_GPIO_1,
+	REG_MCU_GPIO_2,
+	REG_MCU_KPD_1,
+	REG_MCU_KPD_2,
+	REG_MCU_KPD_CONTROL,
+	REG_MCU_INT_ENABLE_1,
+	REG_MCU_INT_ENABLE_2,
+	REG_MCU_INT_FLAG_1,
+	REG_MCU_INT_FLAG_2,
+	REG_MCU_DES_FLAG,
+};
+
+enum {
+
+	MCU_GPIO_REG_RESET_1,
+	MCU_GPIO_REG_RESET_2,
+	MCU_GPIO_REG_POWER_CONTROL,
+	MCU_GPIO_REG_GPIO_CONTROL_1,
+	MCU_GPIO_REG_GPIO_CONTROL_2,
+};
+
+int pmic_gpio_set_bit_val(int reg, unsigned int bit,
+				  unsigned int val);
+
+int pmic_gpio_get_bit_val(int reg, unsigned int bit,
+				  unsigned int *val);
+
+int pmic_gpio_get_designation_bit_val(unsigned int bit,
+					      unsigned int *val);
+
+
+int mcu_pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+
+int mcu_pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+#endif
diff --git a/include/linux/mfd/wm8350/audio.h b/include/linux/mfd/wm8350/audio.h
index a95141e..badb74c 100644
--- a/include/linux/mfd/wm8350/audio.h
+++ b/include/linux/mfd/wm8350/audio.h
@@ -605,6 +605,8 @@ struct wm8350_audio_platform_data {
 	int drain_msecs;	/* OFF drain time */
 	int cap_discharge_msecs;	/* Cap ON (from OFF) discharge time */
 	int vmid_charge_msecs;	/* vmid power up time */
+	char *regulator1;
+	char *regulator2;
 	u32 vmid_s_curve:2;	/* vmid enable s curve speed */
 	u32 dis_out4:2;		/* out4 discharge speed */
 	u32 dis_out3:2;		/* out3 discharge speed */
diff --git a/include/linux/mfd/wm8350/bl.h b/include/linux/mfd/wm8350/bl.h
new file mode 100644
index 0000000..c2c3fc9
--- /dev/null
+++ b/include/linux/mfd/wm8350/bl.h
@@ -0,0 +1,33 @@
+/*
+ * bl.h  --  Backlight Driver for Wolfson WM8350 PMIC
+ *
+ * Copyright 2009 Wolfson Microelectronics PLC
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef __LINUX_MFD_WM8350_BL_H_
+#define __LINUX_MFD_WM8350_BL_H_
+
+#include <linux/fb.h>
+
+/*
+ * WM8350 Backlight platform data
+ */
+struct wm8350_bl_platform_data {
+	int isink;
+	int dcdc;
+	int voltage_ramp;
+	int retries;
+	int max_brightness;
+	int power;
+	int brightness;
+	int (*check_fb)(struct fb_info *);
+};
+
+#endif
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
new file mode 100644
index 0000000..326cd20
--- /dev/null
+++ b/include/linux/mxc_asrc.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx35_asrc.h
+ *
+ * @brief MX35 Asynchronous Sample Rate Converter
+ *
+ * @ingroup ??
+ */
+
+#ifndef __MXC_ASRC_H__
+#define __MXC_ASRC_H__
+
+#define ASRC_IOC_MAGIC	'C'
+
+#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
+#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
+#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
+#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
+#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
+#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 10, struct asrc_status_flags)
+#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 11, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_PAIR_A,
+	ASRC_PAIR_B,
+	ASRC_PAIR_C
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	unsigned int word_width;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_pair {
+	unsigned int start_channel;
+	unsigned int chn_num;
+	unsigned int chn_max;
+	unsigned int active;
+	unsigned int overload_error;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_buffer {
+	unsigned int index;
+	unsigned int length;
+	int buf_valid;
+};
+
+struct asrc_status_flags {
+	enum asrc_pair_index index;
+	unsigned int overload_error;
+};
+
+#define ASRC_BUF_NA	    -35	/* ASRC DQ's buffer is NOT available */
+#define ASRC_BUF_AV	    35	/* ASRC DQ's buffer is available */
+enum asrc_error_status {
+	ASRC_TASK_Q_OVERLOAD = 0x01,
+	ASRC_OUTPUT_TASK_OVERLOAD = 0x02,
+	ASRC_INPUT_TASK_OVERLOAD = 0x04,
+	ASRC_OUTPUT_BUFFER_OVERFLOW = 0x08,
+	ASRC_INPUT_BUFFER_UNDERRUN = 0x10,
+};
+
+#ifdef __KERNEL__
+
+#define ASRC_DMA_BUFFER_NUM 8
+
+#define ASRC_ASRCTR_REG 	0x00
+#define ASRC_ASRIER_REG 	0x04
+#define ASRC_ASRCNCR_REG 	0x0C
+#define ASRC_ASRCFG_REG 	0x10
+#define ASRC_ASRCSR_REG 	0x14
+#define ASRC_ASRCDR1_REG 	0x18
+#define ASRC_ASRCDR2_REG 	0x1C
+#define ASRC_ASRSTR_REG 	0x20
+#define ASRC_ASRRA_REG 		0x24
+#define ASRC_ASRRB_REG 		0x28
+#define ASRC_ASRRC_REG 		0x2C
+#define ASRC_ASRPM1_REG 	0x40
+#define ASRC_ASRPM2_REG 	0x44
+#define ASRC_ASRPM3_REG 	0x48
+#define ASRC_ASRPM4_REG 	0x4C
+#define ASRC_ASRPM5_REG 	0x50
+#define ASRC_ASRTFR1		0x54
+#define ASRC_ASRCCR_REG 	0x5C
+#define ASRC_ASRDIA_REG 	0x60
+#define ASRC_ASRDOA_REG 	0x64
+#define ASRC_ASRDIB_REG 	0x68
+#define ASRC_ASRDOB_REG 	0x6C
+#define ASRC_ASRDIC_REG 	0x70
+#define ASRC_ASRDOC_REG 	0x74
+#define ASRC_ASRIDRHA_REG 	0x80
+#define ASRC_ASRIDRLA_REG 	0x84
+#define ASRC_ASRIDRHB_REG 	0x88
+#define ASRC_ASRIDRLB_REG 	0x8C
+#define ASRC_ASRIDRHC_REG 	0x90
+#define ASRC_ASRIDRLC_REG 	0x94
+#define ASRC_ASR76K_REG 	0x98
+#define ASRC_ASR56K_REG 	0x9C
+
+struct dma_block {
+	unsigned int index;
+	unsigned int length;
+	unsigned char *dma_vaddr;
+	dma_addr_t dma_paddr;
+	struct list_head queue;
+};
+
+struct asrc_pair_params {
+	enum asrc_pair_index index;
+	struct list_head input_queue;
+	struct list_head input_done_queue;
+	struct list_head output_queue;
+	struct list_head output_done_queue;
+	wait_queue_head_t input_wait_queue;
+	wait_queue_head_t output_wait_queue;
+	unsigned int input_counter;
+	unsigned int output_counter;
+	unsigned int input_queue_empty;
+	unsigned int output_queue_empty;
+	unsigned int input_dma_channel;
+	unsigned int output_dma_channel;
+	unsigned int input_buffer_size;
+	unsigned int output_buffer_size;
+	unsigned int buffer_num;
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct semaphore busy_lock;
+};
+
+struct asrc_data {
+	struct asrc_pair asrc_pair[3];
+};
+
+extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
+extern void asrc_release_pair(enum asrc_pair_index index);
+extern int asrc_config_pair(struct asrc_config *config);
+extern void asrc_get_status(struct asrc_status_flags *flags);
+extern void asrc_start_conv(enum asrc_pair_index index);
+extern void asrc_stop_conv(enum asrc_pair_index index);
+
+#endif				/* __kERNEL__ */
+
+#endif				/* __MXC_ASRC_H__ */
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
new file mode 100644
index 0000000..5fcc41d
--- /dev/null
+++ b/include/linux/mxc_mlb.h
@@ -0,0 +1,51 @@
+/*
+ * mxc_mlb.h
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_MLB_H
+#define _MXC_MLB_H
+
+/* define IOCTL command */
+#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
+#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
+#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+/*!
+ * set channel address for each logical channel
+ * the MSB 16bits is for tx channel, the left LSB is for rx channel
+ */
+#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
+#define MLB_CHAN_STARTUP	_IO('S', 0x14)
+#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
+#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
+
+/*!
+ * MLB event define
+ */
+enum {
+	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
+	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
+	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
+	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
+	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
+	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
+	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
+	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
+};
+
+#ifdef __KERNEL__
+extern void gpio_mlb_active(void);
+extern void gpio_mlb_inactive(void);
+#endif
+
+#endif				/* _MXC_MLB_H */
diff --git a/include/linux/mxc_pf.h b/include/linux/mxc_pf.h
new file mode 100644
index 0000000..cf8f35e
--- /dev/null
+++ b/include/linux/mxc_pf.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
+ */
+/*!
+ * @file arch-mxc/mxc_pf.h
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+#ifndef __INCLUDED_MXC_PF_H__
+#define __INCLUDED_MXC_PF_H__
+
+#define PF_MAX_BUFFER_CNT       17
+
+#define PF_WAIT_Y	0x0001
+#define PF_WAIT_U	0x0002
+#define PF_WAIT_V	0x0004
+#define PF_WAIT_ALL	(PF_WAIT_Y|PF_WAIT_U|PF_WAIT_V)
+
+/*!
+ * Structure for Post Filter initialization parameters.
+ */
+typedef struct {
+	uint16_t pf_mode;	/*!< Post filter operation mode */
+	uint16_t width;		/*!< Width of frame in pixels */
+	uint16_t height;	/*!< Height of frame in pixels */
+	uint16_t stride;	/*!< Stride of Y plane in pixels. Stride for U and V planes is half Y stride */
+	uint32_t qp_size;
+	unsigned long qp_paddr;
+} pf_init_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int count;		/*!< Number of buffers requested */
+	__u32 req_size;
+} pf_reqbufs_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int index;
+	int size;		/*!< Size of buffer allocated */
+	__u32 offset;		/*!< Buffer offset in driver memory. Set by QUERYBUF */
+	__u32 y_offset;		/*!< Optional starting relative offset of Y data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 u_offset;		/*!< Optional starting relative offset of U data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 v_offset;		/*!< Optional starting relative offset of V data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+} pf_buf;
+
+/*!
+ * Structure for Post Filter start parameters.
+ */
+typedef struct {
+	pf_buf in;		/*!< Input buffer address and offsets */
+	pf_buf out;		/*!< Output buffer address and offsets */
+	int qp_buf;
+	int wait;
+	uint32_t h264_pause_row;	/*!< Row to pause at for H.264 mode. 0 to disable pause */
+} pf_start_params;
+
+/*! @name User Client Ioctl Interface */
+/*! @{ */
+
+/*!
+ * IOCTL to Initialize the Post Filter.
+ */
+#define PF_IOCTL_INIT           _IOW('F', 0x0, pf_init_params)
+
+/*!
+ * IOCTL to Uninitialize the Post Filter.
+ */
+#define PF_IOCTL_UNINIT         _IO('F', 0x1)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_REQBUFS        _IOWR('F', 0x2, pf_reqbufs_params)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_QUERYBUF       _IOR('F', 0x2, pf_buf)
+
+/*!
+ * IOCTL to start post filtering on a frame of data. This ioctl may block until
+ * processing is done or return immediately.
+ */
+#define PF_IOCTL_START          _IOWR('F', 0x3, pf_start_params)
+
+/*!
+ * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
+ */
+#define PF_IOCTL_RESUME         _IOW('F', 0x4, int)
+
+/*!
+ * IOCTL to wait for post-filtering to complete.
+ */
+#define PF_IOCTL_WAIT           _IOW('F', 0x5, int)
+/*! @} */
+
+#endif				/* __INCLUDED_MXC_PF_H__ */
diff --git a/include/linux/mxc_scc2_driver.h b/include/linux/mxc_scc2_driver.h
new file mode 100644
index 0000000..fc8f055
--- /dev/null
+++ b/include/linux/mxc_scc2_driver.h
@@ -0,0 +1,975 @@
+
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef SCC_DRIVER_H
+#define SCC_DRIVER_H
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*! @file mxc_scc2_driver.h
+ *
+ * @brief (Header file to use the SCC2 driver.)
+ *
+ * The SCC2 driver is available to other kernel modules directly.  Secure
+ * Partition functionality is extended to users through the SHW API.  Other
+ * functionality of the SCC2 is limited to kernel-space users.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work with secure partitions: #scc_allocate_partition()
+ *     #scc_engage_partition() #scc_diminish_permissions()
+ *     #scc_release_partition()
+ * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
+ *     #scc_decrypt_region()
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The SCC2 encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC2 is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC2 driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/** @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/** @addtogroup scccompileflags */
+
+/** @{ */
+/**
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/** @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION    2
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0    0
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_2    2
+
+
+/*!
+ *  Interrupt line number of SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  Interrupt line number of the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+/**
+ * @typedef scc_return_t
+ */
+/** Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	 /**< Function succeeded  */
+		SCC_RET_FAIL,	 /**< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,
+				 /**< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,
+				 /**< At maximum registered functions */
+		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
+		/**< Encryption or decryption failed because@c count_out_bytes
+			says that @c data_out is too small to hold the value. */
+		SCC_RET_INSUFFICIENT_SPACE,
+	} scc_return_t;
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+	typedef enum scc_partition_status_t {
+		SCC_PART_S_UNUSABLE,
+				  /**< Partition not implemented */
+		SCC_PART_S_UNAVAILABLE,
+				  /**< Partition owned by other host */
+		SCC_PART_S_AVAILABLE,
+				  /**< Partition available */
+		SCC_PART_S_ALLOCATED,
+				  /**< Partition owned by host but not engaged*/
+		SCC_PART_S_ENGAGED,
+				  /**< Partition owned by host and engaged */
+	} scc_partition_status_t;
+
+/**
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;
+				/**< Major version of the SCC driver code  */
+		int driver_minor_version;
+				/**< Minor version of the SCC driver code  */
+		int scm_version; /**< Version from SCM Configuration register */
+		int smn_version; /**< Version from SMN Status register */
+		/**< Number of bytes per block of RAM; also
+			block size of the crypto algorithm. */
+		int block_size_bytes;
+		int partition_size_bytes;
+				/**< Number of bytes in each partition */
+		int partition_count;
+				/**< Number of partitions on this platform */
+	} scc_config_t;
+
+/**
+ * @typedef scc_enc_dec_t
+ */
+/**
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/**
+ * @typedef scc_verify_t
+ */
+/**
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+    /** No verification value added or checked.  Input plaintext data must be
+     *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
+		will be padded to a multiple of the blocksize, adding 3-10 bytes
+		to the resulting output ciphertext.  Upon decryption, this padding
+		will be stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/**
+ * @typedef scc_cypher_mode_t
+ */
+/**
+ * Select the cypher mode to use for partition cover/uncover operations.
+ */
+
+	typedef enum scc_cypher_mode_t {
+		SCC_CYPHER_MODE_ECB = 1,
+				   /**< ECB mode */
+		SCC_CYPHER_MODE_CBC = 2,
+				   /**< CBC mode */
+	} scc_cypher_mode_t;
+
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode ownership.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return      SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_allocate_partition(uint32_t smid_value,
+				   int *part_no,
+				   void **part_base, uint32_t *part_phys);
+
+/* Note: This function has to be run in the same context (userspace or kernel
+ * mode) as the process that will be using the partition.  Because the SCC2 API
+ * is not accessible in user mode, this function is also provided as a macro in
+ * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
+ * version of the function without having to include the whole SHW API.  If the
+ * macro definition was defined before we got here, un-define it so this
+ * version will be used instead.
+ */
+
+#ifdef scc_engage_partition
+#undef scc_engage_partition
+#endif
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_engage_partition(void *part_base,
+				 const uint8_t *UMID, uint32_t permissions);
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t scc_release_partition(void *part_base);
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_diminish_permissions(void *part_base, uint32_t permissions);
+
+/**
+ * Query the status of a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_partition_status_t scc_partition_status(void *part_base);
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ */
+	extern uint32_t scc_virt_to_phys(void *address);
+/*scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
+
+
+/**
+ * Encrypt a region of secure memory.
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Decrypt a region into secure memory
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/**
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/**
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/**
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/**
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/**
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried.  See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t *value);
+
+/**
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified.  See
+ *                              @ref scmregs and @ref smnregs
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/**
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup scmregs */
+/** @{ */
+/** Offset of SCM Version ID Register */
+#define SCM_VERSION_REG		0x000
+/** Offset of SCM Interrupt Control Register */
+#define SCM_INT_CTL_REG		0x008
+/** Offset of SCM Status Register */
+#define SCM_STATUS_REG		0x00c
+/** Offset of SCM Error Status Register */
+#define SCM_ERR_STATUS_REG	0x010
+/** Offset of SCM Fault Address Register */
+#define SCM_FAULT_ADR_REG	0x014
+/** Offset of SCM Partition Owners Register */
+#define SCM_PART_OWNERS_REG	0x018
+/** Offset of SCM Partitions Engaged Register */
+#define SCM_PART_ENGAGED_REG	0x01c
+/** Offset of SCM Unique Number 0 Register */
+#define SCM_UNIQUE_ID0_REG	0x020
+/** Offset of SCM Unique Number 1 Register */
+#define SCM_UNIQUE_ID1_REG	0x024
+/** Offset of SCM Unique Number 2 Register */
+#define SCM_UNIQUE_ID2_REG	0x028
+/** Offset of SCM Unique Number 3 Register */
+#define SCM_UNIQUE_ID3_REG	0x02c
+/** Offset of SCM Zeroize Command Register */
+#define SCM_ZCMD_REG		0x050
+/** Offset of SCM Cipher Command Register */
+#define SCM_CCMD_REG		0x054
+/** Offset of SCM Cipher Black RAM Start Address Register */
+#define SCM_C_BLACK_ST_REG	0x058
+/** Offset of SCM Internal Debug Register */
+#define SCM_DBG_STATUS_REG	0x05c
+/** Offset of SCM Cipher IV 0 Register */
+#define SCM_AES_CBC_IV0_REG	0x060
+/** Offset of SCM Cipher IV 1 Register */
+#define SCM_AES_CBC_IV1_REG	0x064
+/** Offset of SCM Cipher IV 2 Register */
+#define SCM_AES_CBC_IV2_REG	0x068
+/** Offset of SCM Cipher IV 3 Register */
+#define SCM_AES_CBC_IV3_REG	0x06c
+/** Offset of SCM SMID Partition 0 Register */
+#define SCM_SMID0_REG		0x080
+/** Offset of SCM Partition 0 Access Permissions Register */
+#define SCM_ACC0_REG		0x084
+/** Offset of SCM SMID Partition 1 Register */
+#define SCM_SMID1_REG		0x088
+/** Offset of SCM Partition 1 Access Permissions Register */
+#define SCM_ACC1_REG		0x08c
+/** Offset of SCM SMID Partition 2 Register */
+#define SCM_SMID2_REG		0x090
+/** Offset of SCM Partition 2 Access Permissions Register */
+#define SCM_ACC2_REG		0x094
+/** Offset of SCM SMID Partition 3 Register */
+#define SCM_SMID3_REG		0x098
+/** Offset of SCM Partition 3 Access Permissions Register */
+#define SCM_ACC3_REG		0x09c
+/** Offset of SCM SMID Partition 4 Register */
+#define SCM_SMID4_REG		0x0a0
+/** Offset of SCM Partition 4 Access Permissions Register */
+#define SCM_ACC4_REG		0x0a4
+/** Offset of SCM SMID Partition 5 Register */
+#define SCM_SMID5_REG		0x0a8
+/** Offset of SCM Partition 5 Access Permissions Register */
+#define SCM_ACC5_REG		0x0ac
+/** Offset of SCM SMID Partition 6 Register */
+#define SCM_SMID6_REG		0x0b0
+/** Offset of SCM Partition 6 Access Permissions Register */
+#define SCM_ACC6_REG		0x0b4
+/** Offset of SCM SMID Partition 7 Register */
+#define SCM_SMID7_REG		0x0b8
+/** Offset of SCM Partition 7 Access Permissions Register */
+#define SCM_ACC7_REG		0x0bc
+/** Offset of SCM SMID Partition 8 Register */
+#define SCM_SMID8_REG		0x0c0
+/** Offset of SCM Partition 8 Access Permissions Register */
+#define SCM_ACC8_REG		0x0c4
+/** Offset of SCM SMID Partition 9 Register */
+#define SCM_SMID9_REG		0x0c8
+/** Offset of SCM Partition 9 Access Permissions Register */
+#define SCM_ACC9_REG		0x0cc
+/** Offset of SCM SMID Partition 10 Register */
+#define SCM_SMID10_REG		0x0d0
+/** Offset of SCM Partition 10 Access Permissions Register */
+#define SCM_ACC10_REG		0x0d4
+/** Offset of SCM SMID Partition 11 Register */
+#define SCM_SMID11_REG		0x0d8
+/** Offset of SCM Partition 11 Access Permissions Register */
+#define SCM_ACC11_REG		0x0dc
+/** Offset of SCM SMID Partition 12 Register */
+#define SCM_SMID12_REG		0x0e0
+/** Offset of SCM Partition 12 Access Permissions Register */
+#define SCM_ACC12_REG		0x0e4
+/** Offset of SCM SMID Partition 13 Register */
+#define SCM_SMID13_REG		0x0e8
+/** Offset of SCM Partition 13 Access Permissions Register */
+#define SCM_ACC13_REG		0x0ec
+/** Offset of SCM SMID Partition 14 Register */
+#define SCM_SMID14_REG		0x0f0
+/** Offset of SCM Partition 14 Access Permissions Register */
+#define SCM_ACC14_REG		0x0f4
+/** Offset of SCM SMID Partition 15 Register */
+#define SCM_SMID15_REG		0x0f8
+/** Offset of SCM Partition 15 Access Permissions Register */
+#define SCM_ACC15_REG		0x0fc
+/** @} */
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Offset of the SMN registers */
+#define SMN_ADDR_OFFSET		0x100
+
+/**
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup smnregs */
+/** @{ */
+/** Offset of SMN Status Register */
+#define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
+/** Offset of SMH Command Register */
+#define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
+/** Offset of SMH Sequence Start Register */
+#define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
+/** Offset of SMH Sequence End Register */
+#define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
+/** Offset of SMH Sequence Check Register */
+#define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
+/** Offset of SMH BitBank Count Register */
+#define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
+/** Offset of SMH BitBank Increment Register */
+#define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
+/** Offset of SMH BitBank Decrement Register */
+#define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
+/** Offset of SMH Compare Register */
+#define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
+/** Offset of SMH Plaintext Check Register */
+#define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
+/** Offset of SMH Ciphertext Check Register */
+#define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
+/** Offset of SMH Timer Initial Value Register */
+#define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
+/** Offset of SMH Timer Control Register */
+#define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
+/** Offset of SMH Security Violation Register */
+#define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
+/** Offset of SMH Timer Register */
+#define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
+/** Offset of SMH High-Assurance Control Register */
+#define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
+/** Number of bytes allocated to the SMN registers */
+#define SMN_REG_BANK_SIZE	0x40
+/** @} */
+
+/** Number of bytes of total register space for the SCC. */
+#define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
+
+/**
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/** @addtogroup smnstatusregdefs */
+/** @{ */
+/** SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       28
+/** Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/** Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/** Some security peripheral is initializing */
+#define SMN_STATUS_PERIP_INIT             0x00010000
+/** Internal error detected in SMN. */
+#define SMN_STATUS_SMN_ERROR              0x00004000
+/** SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/** Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/** Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/** Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/** Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/** Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/** Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/** Security Violation Active error. */
+#define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
+/** Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/** SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/** @} */
+
+/**
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/** @addtogroup sccscmstates */
+/** @{ */
+/** This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/** The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/** SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/** SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/** Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/** @} */
+
+/** @{ */
+/** SCM Status bit: Key Status is Default Key in Use */
+#define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
+/** SCM Status bit: Key Status is (reserved) */
+#define SCM_STATUS_KST_RESERVED1	0x40000000
+/** SCM Status bit: Key status is Wrong Key */
+#define SCM_STATUS_KST_WRONG_KEY	0x20000000
+/** SCM Status bit: Bad Key detected */
+#define SCM_STATUS_KST_BAD_KEY	0x10000000
+/** SCM Status bit: Error has occurred */
+#define SCM_STATUS_ERR		0x00008000
+/** SCM Status bit: Monitor State is Failed */
+#define SCM_STATUS_MSS_FAIL	0x00004000
+/** SCM Status bit: Monitor State is Secure */
+#define SCM_STATUS_MSS_SEC	0x00002000
+/** SCM Status bit: Secure Storage is Failed */
+#define SCM_STATUS_RSS_FAIL	0x00000400
+/** SCM Status bit: Secure Storage is Secure */
+#define SCM_STATUS_RSS_SEC	0x00000200
+/** SCM Status bit: Secure Storage is Initializing */
+#define SCM_STATUS_RSS_INIT	0x00000100
+/** SCM Status bit: Unique Number Valid */
+#define SCM_STATUS_UNV		0x00000080
+/** SCM Status bit: Big Endian mode */
+#define SCM_STATUS_BIG		0x00000040
+/** SCM Status bit: Using Secret Key */
+#define SCM_STATUS_USK		0x00000020
+/** SCM Status bit: Ram is being blocked */
+#define SCM_STATUS_BAR		0x00000010
+/** Bit mask of SRS */
+#define SCM_STATUS_SRS_MASK	0x0000000F
+/** Number of bits to shift SRS to/from MSb */
+#define SCM_STATUS_SRS_SHIFT	0
+/** @} */
+
+#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
+#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
+#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
+#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
+#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
+#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
+#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
+#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
+#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
+#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
+#define SCM_STATUS_SRS_FAIL	    0xF	/**< Fail State */
+
+
+/* Format of the SCM VERSION ID REGISTER */
+#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
+#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
+#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
+#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
+#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
+#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
+#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
+#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
+#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
+#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
+
+/**< SCC Hardware version supported by this driver */
+#define SCM_MAJOR_VERSION_2 2
+
+/* Format of the SCM ERROR STATUS REGISTER */
+#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
+#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
+#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
+#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
+#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
+#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
+#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
+#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
+#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
+#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
+
+/* SCM ERROR STATUS REGISTER ERROR CODES */
+#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
+#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
+#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
+#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
+#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
+#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
+#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
+#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
+#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
+#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
+#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
+#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
+#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
+
+/* Format of the CIPHER COMMAND REGISTER */
+#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
+#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
+#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
+#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
+#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
+#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
+#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
+#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
+
+/* Values for SCM_CCMD_CCMD field */
+#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
+#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
+
+#define SCM_CCMD_AES     1     /**< Use AES Mode */
+#define SCM_CCMD_DEC     0     /**< Decrypt */
+#define SCM_CCMD_ENC     2     /**< Encrypt */
+#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
+#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
+
+/* Format of the ZEROIZE COMMAND REGISTER */
+#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
+#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
+#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
+#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
+
+/* MASTER ACCESS PERMISSIONS REGISTER */
+/* Note that API users should use the FSL_PERM_ defines instead of these */
+/** SCM Access Permission: Do not zeroize/deallocate partition
+	on SMN Fail state */
+#define SCM_PERM_NO_ZEROIZE	0x10000000
+/** SCM Access Permission: Ignore Supervisor/User mode
+	in permission determination */
+#define SCM_PERM_HD_SUP_DISABLE	0x00000800
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+#define SCM_PERM_HD_READ	0x00000400
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+#define SCM_PERM_HD_WRITE	0x00000200
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+#define SCM_PERM_HD_EXECUTE	0x00000100
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+#define SCM_PERM_TH_READ	0x00000040
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+#define SCM_PERM_TH_WRITE	0x00000020
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+#define SCM_PERM_OT_READ	0x00000004
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+#define SCM_PERM_OT_WRITE	0x00000002
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+#define SCM_PERM_OT_EXECUTE	0x00000001
+/**< Valid bits that can be set in the Permissions register */
+#define SCM_PERM_MASK 0xC0000F67
+
+/* Zeroize Command register definitions */
+#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
+#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
+
+/**
+ * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
+ */
+/** @addtogroup scmpartitionownersregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_POWN_SHIFT   2
+/** Mask for a field once the register has been shifted. */
+#define SCM_POWN_MASK    3
+/** Partition is free */
+#define SCM_POWN_PART_FREE       0
+/** Partition is unable to be allocated */
+#define SCM_POWN_PART_UNUSABLE   1
+/** Partition is owned by another master */
+#define SCM_POWN_PART_OTHER      2
+/** Partition is owned by this master */
+#define SCM_POWN_PART_OWNED      3
+/** @} */
+
+/**
+ * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
+ */
+/** @addtogroup smnpartitionsengagedregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_PENG_SHIFT   1
+/** Engaged value for a field once the register has been shifted. */
+#define SCM_PENG_ENGAGED    1
+/** @} */
+
+/** Number of bytes between each subsequent SMID register */
+#define SCM_SMID_WIDTH      8
+
+/**
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
+ */
+/** @addtogroup smncommandregdefs */
+/** @{ */
+
+/** These bits are unimplemented or reserved */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
+/** @} */
+
+/**
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/** @addtogroup smntimercontroldefs */
+/** @{ */
+/** These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/** Load the timer from #SMN_TIMER_IV_REG */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/** Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/** Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/** @} */
+
+/**
+ * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmchainmodedefs */
+/** @{ */
+#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
+#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
+/** @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/**
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmciphermodedefs */
+/** @{ */
+#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
+/** @} */
+
+/**
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ */
+/** @addtogroup smndbgdetdefs */
+/** @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
+/** @} */
+
+/** Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQ_START_REG) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQ_END_REG) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/** Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQ_CHECK_REG) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Bit Counter Register
+    (#SMN_BB_CNT_REG) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BB_INC_REG) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BB_DEC_REG) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/** Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_REG) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/*! @} */
+
+#endif				/* SCC_DRIVER_H */
diff --git a/include/linux/mxc_scc_driver.h b/include/linux/mxc_scc_driver.h
new file mode 100644
index 0000000..a2f808c
--- /dev/null
+++ b/include/linux/mxc_scc_driver.h
@@ -0,0 +1,1031 @@
+
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_DRIVER_H__
+#define __ASM_ARCH_MXC_SCC_DRIVER_H__
+
+/* Start marker for C++ compilers */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*!
+ * @defgroup MXCSCC SCC Driver
+ *
+ * @ingroup MXCSECDRVRS
+ */
+
+/*!
+ * @file arch-mxc/mxc_scc_driver.h
+ *
+ * @brief (Header file to use the SCC driver.)
+ *
+ * The SCC driver will only be available to other kernel modules.  That is,
+ * there will be no node file in /dev, no way for a user-mode program to access
+ * the driver, no way for a user program to access the device directly.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li encrypt or decrypt secrets - #scc_crypt()
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
+ *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
+ *     #scc_encrypt_slot(), #scc_get_slot_info()
+
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The driver does not allow "storage" of data in either the Red or Black
+ * memories.  Any decrypted secret is returned to the user, and if the user
+ * wants to use it at a later point, the encrypted form must again be passed
+ * to the driver, and it must be decrypted again.
+ *
+ * The SCC encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/*! @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/*! @addtogroup scccompileflags */
+
+/*! @{ */
+/*!
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/*! @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION_1 1
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0 0
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_4 4
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_5 5
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_6 6
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_8 8
+
+
+/*!
+ * @typedef scc_return_t
+ */
+/*! Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	/*!< Function succeeded  */
+		SCC_RET_FAIL,	/*!< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
+		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
+		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
+							   @c count_out_bytes says that @c data_out is
+							   too small to hold the value. */
+	} scc_return_t;
+
+/*!
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;	/*!< Major version of the SCC driver code  */
+		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
+		int scm_version;	/*!< Version from SCM Configuration register */
+		int smn_version;	/*!< Version from SMN Status register */
+		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
+					   block size of the crypto algorithm. */
+		int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
+		int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
+	} scc_config_t;
+
+/*!
+ * @typedef scc_enc_dec_t
+ */
+/*!
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/*
+ * @typedef scc_crypto_mode_t
+ */
+/*!
+ * Determine whether SCC will run its cryptographic function in ECB (electronic
+ * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_crypto_mode_t {
+		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
+		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
+	} scc_crypto_mode_t;
+
+/*!
+ * @typedef scc_verify_t
+ */
+/*!
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+		/*! No verification value added or checked.  Input plaintext data must be
+		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
+		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
+		   resulting output ciphertext.  Upon decryption, this padding will be
+		   stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/*!
+ * Determine if the given credentials match that of the key slot.
+ *
+ * @param[in]  owner_id     A value which will control access to the slot.
+ * @param[in]  slot         Key Slot to query
+ * @param[in]  access_len   Length of the key
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	 scc_return_t
+	    scc_verify_slot_access(uint64_t owner_id, uint32_t slot,
+				   uint32_t access_len);
+
+/*!
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/*!
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/*!
+ * Perform a Triple DES encryption or decryption operation.
+ *
+ * This routine will cause the SCM to perform an encryption or decryption with
+ * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
+ * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
+ * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
+ *
+ * This function will perform in a variety of ways, depending upon the values
+ * of @c direction, @c crypto_mode, and @c check_mode.  If
+ * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
+ * the @c count_in_bytes will be different from the returned value of @c
+ * count_out_bytes.  This is because the two-byte CRC and some amount of
+ * padding (at least one byte) will either be added or stripped.
+ *
+ * This function will not return until the SCC has performed the operation (or
+ * reported failure to do so).  It must therefore not be called from interrupt
+ * level.  In the current version, it will poll the SCC for completion.  In
+ * future versions, it may sleep.
+ *
+ * @param[in]    count_in_bytes The number of bytes to move through the crypto
+ *                            function.  Must be greater than zero.
+ *
+ * @param[in]    data_in      Pointer to the array of bytes to be used as input
+ *                            to the crypto function.
+ *
+ * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
+ *                            bytes which form the initialization vector for
+ *                            this operation.  A non-null value is required
+ *                            when @c crypto_mode has the value #SCC_CBC_MODE;
+ *                            the value is ignored in #SCC_ECB_MODE.
+ *
+ * @param[in]    direction    Direct the driver to perform encryption or
+ *                            decryption.
+ *
+ * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
+ *
+ * @param[in]    check_mode   During encryption, generate and append a check
+ *                            value to the plaintext and pad the resulting
+ *                            data.  During decryption, validate the plaintext
+ *                            with that check value and remove the padding.
+ *
+ * @param[in,out] count_out_bytes On input, the number of bytes available for
+ *                            copying to @c data_out.  On return, the number of
+ *                            bytes copied to @c data_out.
+ *
+ * @param[out] data_out       Pointer to the array of bytes that are where the
+ *                            output of the crypto function are to be placed.
+ *                            For encryption, this must be able to hold a
+ *                            longer ciphertext than the plaintext message at
+ *                            @c data_in.  The driver will append a 'pad' of
+ *                            1-8 bytes to the message, and if @c check_mode is
+ *                            used, additional bytes may be added, the number
+ *                            depending upon the type of check being requested.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ *
+ * @internal
+ * This function will verify SCC state and the functions parameters.  It will
+ * acquire the crypto lock, and set up some SCC registers and variables common
+ * to encryption and decryption.  A rough check will be made to verify that
+ * enough space is available in @c count_out_bytes.  Upon success, either the
+ * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
+ * The crypto lock will then be released.
+ */
+extern scc_return_t scc_crypt(unsigned long count_in_bytes,
+				      const uint8_t *data_in,
+				      const uint8_t *init_vector,
+				      scc_enc_dec_t direction,
+				      scc_crypto_mode_t crypto_mode,
+				      scc_verify_t check_mode,
+				      uint8_t *data_out,
+				      unsigned long *count_out_bytes);
+
+
+/*!
+ * Allocate a key slot for a stored key (or other stored value).
+ *
+ * This feature is to allow decrypted secret values to be kept in RED RAM.
+ * This can all visibility of the data only by Sahara.
+ *
+ * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
+ *                            a size up to 32 bytes is supported.
+ *
+ * @param      owner_id       A value which will control access to the slot.
+ *                            It must be passed into to any subsequent calls to
+ *                            use the assigned slot.
+ *
+ * @param[out] slot           The slot number for the key.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
+					   uint64_t owner_id, uint32_t *slot);
+
+/*!
+ * Deallocate the key slot of a stored key or secret value.
+ *
+ * @param      owner_id       The id which owns the @c slot.
+ *
+ * @param      slot           The slot number for the key.
+
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Load a value into a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_data      Data to load into the slot
+ * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
+					  const uint8_t *key_data,
+					  uint32_t key_length);
+/*!
+ * Read a value from a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_length    Length, in bytes, of @c key_data to copy from SCC.
+ * @param key_data      Location to write the key
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_read_slot(uint64_t owner_id, uint32_t slot,
+					  uint32_t key_length,
+					  uint8_t *key_data);
+
+/*!
+ * Allocate a key slot to fit the requested size.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location to store result of encrypting RED data in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     uint8_t *black_data);
+
+/*!
+ * Decrypt some black data and leave result in the slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location of data to dencrypt and store in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     const uint8_t *black_data);
+
+/*!
+ * Get attributes of data in RED slot.
+ *
+ * @param      owner_id         The id which owns the @c slot.
+ *
+ * @param      slot             The slot number for the key.
+ *
+ * @param[out] address          Physical address of RED value.
+ *
+ * @param[out] value_size_bytes Length, in bytes, of RED value,
+ *                              or NULL if unneeded..
+ *
+ * @param[out] slot_size_bytes  Length, in bytes, of slot size,
+ *                              or NULL if unneeded..
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
+					      uint32_t *address,
+					      uint32_t *value_size_bytes,
+					      uint32_t *slot_size_bytes);
+
+/*!
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/*!
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/*!
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/*!
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t *value);
+
+/*!
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/*
+ * NOTE TO MAINTAINERS
+ *
+ * All of the doxygen comments for the register offset values are in this the
+ * following comment section.  Any changes to register names or definitions
+ * must be reflected in this section and in both the TAHITI and non-TAHITI
+ *version of the memory map.
+ */
+
+/*!
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup scmregs */
+/*! @{ */
+/*! @def SCM_RED_START
+ * Starting block offset in red memory for cipher function. */
+
+/*! @def SCM_BLACK_START
+ * Starting block offset in black memory for cipher function. */
+
+/*! @def SCM_LENGTH
+ * Number of blocks to process during cipher function */
+
+/*! @def SCM_CONTROL
+ * SCM Control register.
+ * See @ref scmcontrolregdefs "SCM Control Register definitions" for details.
+ */
+
+/*! @def SCM_STATUS
+ * SCM Status register.
+ * See @ref scmstatusregdefs "SCM Status Register Definitions" for details.
+ */
+
+/*! @def SCM_ERROR_STATUS
+ * SCM Error Status Register.
+ * See @ref scmerrstatdefs "SCM Error Status Register definitions" for
+ * details. */
+
+/*! @def SCM_INTERRUPT_CTRL
+ * SCM Interrupt Control Register.
+ * See @ref scminterruptcontroldefs "SCM Interrupt Control Register definitions"
+ * for details.
+ */
+
+/*! @def SCM_CONFIGURATION
+ * SCM Configuration Register.
+ * See @ref scmconfigdefs "SCM Configuration Register Definitions" for
+ * details.
+ */
+
+/*! @def SCM_INIT_VECTOR_0
+ * Upper Half of the Initialization Vector */
+
+/*! @def SCM_INIT_VECTOR_1
+ * Lower Half of the Initialization Vector */
+
+/*! @def SCM_RED_MEMORY
+ * Starting location of first block of Red memory */
+
+/*! @def SCM_BLACK_MEMORY
+ * Starting location of first block of Black memory */
+
+	/*! @} *//* end of SCM group */
+
+/*!
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup smnregs */
+/*! @{ */
+/*! @def SMN_STATUS
+ * Status register for SMN.
+ * See @ref smnstatusregdefs "SMN Status Register definitions" for further
+ * information.
+ */
+
+/*! @def SMN_COMMAND
+ * Command register for SMN. See
+ * @ref smncommandregdefs "Command Register Definitions" for further
+ * information.
+ */
+
+/*! @def SMN_SEQUENCE_START
+ * Sequence Start register for ASC. See #SMN_SEQUENCE_START_MASK
+ */
+
+/*! @def SMN_SEQUENCE_END
+ * Sequence End register for ASC. See #SMN_SEQUENCE_CHECK_MASK
+ */
+
+/*! @def SMN_SEQUENCE_CHECK
+ * Sequence Check register for ASC. See #SMN_SEQUENCE_END_MASK
+ */
+
+/*! @def SMN_BIT_COUNT
+ * Bit Bank Repository for AIC. See #SMN_BIT_COUNT_MASK
+ */
+
+/*! @def SMN_BITBANK_INC_SIZE
+ * Bit Bank Increment Size for AIC. See #SMN_BITBANK_INC_SIZE_MASK
+ */
+
+/*! @def SMN_BITBANK_DECREMENT
+ * Bit Bank Decrement for AIC. See #SMN_BITBANK_DECREMENT_MASK
+ */
+
+/*! @def SMN_COMPARE_SIZE
+ * Compare Size register for Plaintext/Ciphertext checker.  See
+ * #SMN_COMPARE_SIZE_MASK */
+
+/*! @def SMN_PLAINTEXT_CHECK
+ * Plaintext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_CIPHERTEXT_CHECK
+ * Ciphertext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_TIMER_IV
+ * Timer Initial Value register
+ */
+
+/*! @def SMN_TIMER_CONTROL
+ * Timer Control register.
+ * See @ref smntimercontroldefs "SMN Timer Control Register definitions".
+ */
+
+/*! @def SMN_DEBUG_DETECT_STAT
+ * Debug Detector Status Register
+ * See @ref smndbgdetdefs "SMN Debug Detector Status Register"for definitions.
+ */
+
+/*! @def SMN_TIMER
+ * Current value of the Timer Register
+ */
+
+	/*! @} *//* end of SMN group */
+
+/*
+ * SCC MEMORY MAP
+ *
+ */
+
+/* SCM registers */
+#define SCM_RED_START           0x00000000	/*          read/write       */
+#define SCM_BLACK_START         0x00000004	/*          read/write       */
+#define SCM_LENGTH              0x00000008	/*          read/write       */
+#define SCM_CONTROL             0x0000000C	/*          read/write       */
+#define SCM_STATUS              0x00000010	/*          read only        */
+#define SCM_ERROR_STATUS        0x00000014	/*          read/write       */
+#define SCM_INTERRUPT_CTRL      0x00000018	/*          read/write       */
+#define SCM_CONFIGURATION       0x0000001C	/*          read only        */
+#define SCM_INIT_VECTOR_0       0x00000020	/*          read/write       */
+#define SCM_INIT_VECTOR_1       0x00000024	/*          read/write       */
+#define SCM_RED_MEMORY          0x00000400	/*          read/write       */
+#define SCM_BLACK_MEMORY        0x00000800	/*          read/write       */
+
+/* SMN Registers */
+#define SMN_STATUS              0x00001000	/*          read/write       */
+#define SMN_COMMAND             0x00001004	/*          read/write       */
+#define SMN_SEQUENCE_START      0x00001008	/*          read/write       */
+#define SMN_SEQUENCE_END        0x0000100C	/*          read/write       */
+#define SMN_SEQUENCE_CHECK      0x00001010	/*          read/write       */
+#define SMN_BIT_COUNT           0x00001014	/*          read only        */
+#define SMN_BITBANK_INC_SIZE    0x00001018	/*          read/write       */
+#define SMN_BITBANK_DECREMENT   0x0000101C	/*          write only       */
+#define SMN_COMPARE_SIZE        0x00001020	/*          read/write       */
+#define SMN_PLAINTEXT_CHECK     0x00001024	/*          read/write       */
+#define SMN_CIPHERTEXT_CHECK    0x00001028	/*          read/write       */
+#define SMN_TIMER_IV            0x0000102C	/*          read/write       */
+#define SMN_TIMER_CONTROL       0x00001030	/*          read/write       */
+#define SMN_DEBUG_DETECT_STAT   0x00001034	/*          read/write       */
+#define SMN_TIMER               0x00001038	/*          read only        */
+
+/*! Total address space of the SCC, in bytes */
+#define SCC_ADDRESS_RANGE    0x103c
+
+/*!
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/*! @addtogroup smnstatusregdefs */
+/*! @{ */
+/*! SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       26
+/*! Cacheable access to SMN attempted.  */
+#define SMN_STATUS_CACHEABLE_ACCESS       0x02000000
+/*! Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/*! Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/*! Unaligned access attempted. */
+#define SMN_STATUS_UNALIGNED_ACCESS       0x00400000
+/*! Bad byte offset access attempted. */
+#define SMN_STATUS_BYTE_ACCESS            0x00200000
+/*! Illegal address access attempted. */
+#define SMN_STATUS_ILLEGAL_ADDRESS        0x00100000
+/*! User access attempted. */
+#define SMN_STATUS_USER_ACCESS            0x00080000
+/*! SCM is using DEFAULT key.  */
+#define SMN_STATUS_DEFAULT_KEY            0x00040000
+/*! SCM detects weak or bad key.  */
+#define SMN_STATUS_BAD_KEY                0x00020000
+/*! Illegal access to SCM detected. */
+#define SMN_STATUS_ILLEGAL_ACCESS         0x00010000
+/*! Internal error detected in SCM. */
+#define SMN_STATUS_SCM_ERROR              0x00008000
+/*! SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/*! Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/*! Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/*! Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/*! Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/*! Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/*! Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/*! At least one Debug signal is active. */
+#define SMN_STATUS_DEBUG_ACTIVE           0x00000080
+/*! SCM failed to zeroize its memory. */
+#define SMN_STATUS_ZEROIZE_FAIL           0x00000040
+/*! Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/*! SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/*! @} */
+
+/*!
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/*! @addtogroup sccscmstates */
+/*! @{ */
+/*! This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/*! The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/*! SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/*! SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/*! @} */
+
+/*!
+ * @defgroup scmconfigdefs SCM Configuration Register definitions (SCM_CONFIGURATION)
+ **/
+/*! @addtogroup scmconfigdefs */
+/*! @{ */
+/*! Version number of the Secure Memory. */
+#define SCM_CFG_VERSION_ID_MASK         0xf8000000
+/*! Number of bits to shift #SCM_CFG_VERSION_ID_MASK to get it to LSB. */
+#define SCM_CFG_VERSION_ID_SHIFT        27
+/*! Version one value for SCC configuration */
+#define SCM_VERSION_1    1
+/*! Size, in blocks, of Red memory. */
+#define SCM_CFG_BLACK_SIZE_MASK         0x07fe0000
+/*! Number of bits to shift #SCM_CFG_BLACK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLACK_SIZE_SHIFT        17
+/*! Size, in blocks, of Black memory. */
+#define SCM_CFG_RED_SIZE_MASK           0x0001ff80
+/*! Number of bits to shift #SCM_CFG_RED_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_RED_SIZE_SHIFT          7
+/*! Number of bytes per block. */
+#define SCM_CFG_BLOCK_SIZE_MASK         0x0000007f
+/*! Number of bits to shift #SCM_CFG_BLOCK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLOCK_SIZE_SHIFT        0
+/*! @} */
+
+/*!
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
+ */
+/*! @addtogroup smncommandregdefs */
+/*! @{ */
+#define SMN_COMMAND_ZEROS_MASK   0xffffff70	/*!< These bits are unimplemented
+						   or reserved */
+#define SMN_COMMAND_TAMPER_LOCK         0x10 /*!< Lock Tamper Detect Bit */
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
+/*! @} */
+
+/*!
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/*! @addtogroup smntimercontroldefs */
+/*! @{ */
+/*! These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/*! Load the timer from #SMN_TIMER_IV */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/*! Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/*! Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/*! @} */
+
+/*!
+ * @defgroup scminterruptcontroldefs SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
+ *
+ * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
+ */
+/*! @addtogroup scminterruptcontroldefs */
+/*! @{ */
+/*! Clear SCM memory */
+#define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
+/*! Clear outstanding SCM interrupt */
+#define SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT     0x2
+/*! Inhibit SCM interrupts */
+#define SCM_INTERRUPT_CTRL_MASK_INTERRUPTS     0x1
+/*! @} */
+
+/*!
+ * @defgroup scmcontrolregdefs SCM Control Register definitions (SCM_CONTROL).
+ * These values are used with the #SCM_CONTROL register.
+ */
+/*! @addtogroup scmcontrolregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_CONTROL_ZEROS_MASK    0xfffffff8
+/*! Setting this will start encrypt/decrypt */
+#define SCM_CONTROL_START_CIPHER        0x04
+/*! CBC/ECB flag.
+ * See @ref scmchainmodedefs "Chaining Mode bit definitions."
+ */
+#define SCM_CONTROL_CHAINING_MODE_MASK  0x02
+/*! Encrypt/decrypt choice.
+ * See @ref scmciphermodedefs "Cipher Mode bit definitions." */
+#define SCM_CONTROL_CIPHER_MODE_MASK    0x01
+/*! @} */
+
+/*!
+ * @defgroup scmchainmodedefs  SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/*! @addtogroup scmchainmodedefs */
+/*! @{ */
+#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
+#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
+/*! @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/*!
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/*! @{ */
+#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
+/*! @} */
+
+/*!
+ * @defgroup scmstatusregdefs  SCM Status Register (SCM_STATUS).
+ * Bit and field definitions of the SCM_STATUS register.
+ */
+/*! @addtogroup scmstatusregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_STATUS_ZEROS_MASK        0xffffe000
+/*! Ciphering failed due to length error. */
+#define SCM_STATUS_LENGTH_ERROR          0x1000
+/*! SMN has stopped blocking access to the SCM */
+#define SCM_STATUS_BLOCK_ACCESS_REMOVED  0x0800
+/*! Ciphering done. */
+#define SCM_STATUS_CIPHERING_DONE        0x0400
+/*! Zeroizing done. */
+#define SCM_STATUS_ZEROIZING_DONE        0x0200
+/*! SCM wants attention. Interrupt status is available. */
+#define SCM_STATUS_INTERRUPT_STATUS      0x0100
+/*! Secret Key is in use. */
+#define SCM_STATUS_SECRET_KEY            0x0080
+/*! Secret Key is in use.  Deprecated.  Use #SCM_STATUS_SECRET_KEY. */
+#define SCM_STATUS_DEFAULT_KEY           0x0080
+/*! Internal error to SCM. */
+#define SCM_STATUS_INTERNAL_ERROR        0x0040
+/*! Secret key is not valid. */
+#define SCM_STATUS_BAD_SECRET_KEY        0x0020
+/*! Failed to zeroize memory. */
+#define SCM_STATUS_ZEROIZE_FAILED        0x0010
+/*! SMN is blocking access to Secure Memory. */
+#define SCM_STATUS_SMN_BLOCKING_ACCESS   0x0008
+/*! SCM is current encrypting or decrypting data. */
+#define SCM_STATUS_CIPHERING             0x0004
+/*! SCM is currently zeroizing data. */
+#define SCM_STATUS_ZEROIZING             0x0002
+/*! SCM is busy and access to memory is blocked. */
+#define SCM_STATUS_BUSY                  0x0001
+/*! @} */
+
+/*!
+ * @defgroup scmerrstatdefs SCM Error Status Register (SCM_ERROR_STATUS)
+ *
+ * These definitions are associated with the SCM Error Status Register
+ * (SCM_ERROR_STATUS).
+ */
+/*! @addtogroup scmerrstatdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_ERR_ZEROS_MASK      0xffffc000
+/*! Cacheable access to SCM was attempted */
+#define SCM_ERR_CACHEABLE_ACCESS    0x2000
+/*! Access attempted by illegal bus master */
+#define SCM_ERR_ILLEGAL_MASTER      0x1000
+/*! Unaligned access attempted */
+#define SCM_ERR_UNALIGNED_ACCESS    0x0800
+/*! Byte or half-word access attempted */
+#define SCM_ERR_BYTE_ACCESS         0x0400
+/*! Illegal address attempted */
+#define SCM_ERR_ILLEGAL_ADDRESS     0x0200
+/*! User access attempted */
+#define SCM_ERR_USER_ACCESS         0x0100
+/*! Access attempted while SCM was using default key */
+#define SCM_ERR_SECRET_KEY_IN_USE   0x0080
+/*! Access attempted while SCM had internal error */
+#define SCM_ERR_INTERNAL_ERROR      0x0040
+/*! Access attempted while SCM was detecting Bad Key */
+#define SCM_ERR_BAD_SECRET_KEY      0x0020
+/*! The SCM failed to Zeroize memory */
+#define SCM_ERR_ZEROIZE_FAILED      0x0010
+/*! Access attempted while SMN was Blocking Access */
+#define SCM_ERR_SMN_BLOCKING_ACCESS 0x0008
+/*! Access attempted while SCM was CIPHERING */
+#define SCM_ERR_CIPHERING           0x0004
+/*! Access attempted while SCM was ZEROIZING */
+#define SCM_ERR_ZEROIZING           0x0002
+/*! Access attempted while SCM was BUSY */
+#define SCM_ERR_BUSY                0x0001
+/*! @} */
+
+/*!
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register
+ * (SCM_DEBUG_DETECT_STAT)
+ */
+/*! @addtogroup smndbgdetdefs */
+/*! @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
+/*! @} */
+
+/*! Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQUENCE_START) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQUENCE_END) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/*! Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQUENCE_CHECK) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Bit Counter Register
+    (#SMN_BIT_COUNT) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BITBANK_INC_SIZE) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BITBANK_DECREMENT) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/*! Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_SIZE) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/* Close out marker for C++ compilers */
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __ASM_ARCH_MXC_SCC_DRIVER_H__ */
diff --git a/include/linux/mxc_si4702.h b/include/linux/mxc_si4702.h
new file mode 100644
index 0000000..d1d67cc
--- /dev/null
+++ b/include/linux/mxc_si4702.h
@@ -0,0 +1,39 @@
+/*
+ * linux/drivers/char/mxc_si4702.h
+ *
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Character device driver for SI4702 FM radio
+ */
+
+/*
+ * @file mxc_si4702.h
+ *
+ * @brief SI4702 Radio FM driver
+ *
+ * @ingroup Character
+ */
+
+#ifndef _MXC_SI4702_FM_H
+#define _MXC_SI4702_FM_H
+
+/* define IOCTL command */
+#define SI4702_GETVOLUME	_IOR('S', 0x10, unsigned int)
+#define SI4702_SETVOLUME	_IOW('S', 0x11, unsigned int)
+#define SI4702_MUTEON		_IO('S', 0x12)
+#define SI4702_MUTEOFF		_IO('S', 0x13)
+#define SI4702_SELECT		_IOW('S', 0x14, unsigned int)
+#define SI4702_SEEK		_IOWR('S', 0x15, unsigned int)
+
+#endif				/* _MXC_SI4702_FM_H */
diff --git a/include/linux/mxc_sim_interface.h b/include/linux/mxc_sim_interface.h
new file mode 100644
index 0000000..2d57876
--- /dev/null
+++ b/include/linux/mxc_sim_interface.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_sim_interface.h
+ *
+ * @brief Driver for Freescale IMX SIM interface
+ *
+ */
+
+#ifndef MXC_SIM_INTERFACE_H
+#define MXC_SIM_INTERFACE_H
+
+#define SIM_ATR_LENGTH_MAX 32
+
+/* Raw ATR SIM_IOCTL_GET_ATR */
+typedef struct {
+	uint32_t size;		/* length of ATR received */
+	uint8_t t[SIM_ATR_LENGTH_MAX];	/* raw ATR string received */
+} sim_atr_t;
+
+/* Communication parameters for SIM_IOCTL_[GET|SET]_PARAM */
+typedef struct {
+	uint8_t convention;	/* direct = 0, indirect = 1 */
+	uint8_t FI, DI;		/* frequency multiplier and devider indices */
+	uint8_t PI1, II;	/* programming voltage and current indices */
+	uint8_t N;		/* extra guard time */
+	uint8_t T;		/* protocol type: T0 = 0, T1 = 1 */
+	uint8_t PI2;		/* programming voltage 2 value */
+	uint8_t WWT;		/* working wait time */
+} sim_param_t;
+
+/* ISO7816-3 protocols */
+#define SIM_PROTOCOL_T0  0
+#define SIM_PROTOCOL_T1  1
+
+/* Transfer data for SIM_IOCTL_XFER */
+typedef struct {
+	uint8_t *xmt_buffer;	/* transmit buffer pointer */
+	int32_t xmt_length;	/* transmit buffer length */
+	uint8_t *rcv_buffer;	/* receive buffer pointer */
+	int32_t rcv_length;	/* receive buffer length */
+	int type;		/* transfer type: TPDU = 0, PTS = 1 */
+	int timeout;		/* transfer timeout in milliseconds */
+	uint8_t sw1;		/* status word 1 */
+	uint8_t sw2;		/* status word 2 */
+} sim_xfer_t;
+
+/* Transfer types for SIM_IOCTL_XFER */
+#define SIM_XFER_TYPE_TPDU 0
+#define SIM_XFER_TYPE_PTS  1
+
+/* Interface power states */
+#define SIM_POWER_OFF 0
+#define SIM_POWER_ON  1
+
+/* Return values for SIM_IOCTL_GET_PRESENSE */
+#define SIM_PRESENT_REMOVED     0
+#define SIM_PRESENT_DETECTED    1
+#define SIM_PRESENT_OPERATIONAL 2
+
+/* Return values for SIM_IOCTL_GET_ERROR */
+#define SIM_OK                         0
+#define SIM_E_ACCESS                   1
+#define SIM_E_TPDUSHORT                2
+#define SIM_E_PTSEMPTY                 3
+#define SIM_E_INVALIDXFERTYPE          4
+#define SIM_E_INVALIDXMTLENGTH         5
+#define SIM_E_INVALIDRCVLENGTH         6
+#define SIM_E_NACK                     7
+#define SIM_E_TIMEOUT                  8
+#define SIM_E_NOCARD                   9
+#define SIM_E_PARAM_FI_INVALID         10
+#define SIM_E_PARAM_DI_INVALID         11
+#define SIM_E_PARAM_FBYD_WITHFRACTION  12
+#define SIM_E_PARAM_FBYD_NOTDIVBY8OR12 13
+#define SIM_E_PARAM_DIVISOR_RANGE      14
+#define SIM_E_MALLOC                   15
+#define SIM_E_IRQ                      16
+#define SIM_E_POWERED_ON               17
+#define SIM_E_POWERED_OFF              18
+
+/* ioctl encodings */
+#define SIM_IOCTL_BASE 0xc0
+#define SIM_IOCTL_GET_PRESENSE   _IOR(SIM_IOCTL_BASE, 1, int)
+#define SIM_IOCTL_GET_ATR        _IOR(SIM_IOCTL_BASE, 2, sim_atr_t)
+#define SIM_IOCTL_GET_PARAM_ATR  _IOR(SIM_IOCTL_BASE, 3, sim_param_t)
+#define SIM_IOCTL_GET_PARAM      _IOR(SIM_IOCTL_BASE, 4, sim_param_t)
+#define SIM_IOCTL_SET_PARAM      _IOW(SIM_IOCTL_BASE, 5, sim_param_t)
+#define SIM_IOCTL_XFER           _IOR(SIM_IOCTL_BASE, 6, sim_xfer_t)
+#define SIM_IOCTL_POWER_ON       _IO(SIM_IOCTL_BASE, 7)
+#define SIM_IOCTL_POWER_OFF      _IO(SIM_IOCTL_BASE, 8)
+#define SIM_IOCTL_WARM_RESET     _IO(SIM_IOCTL_BASE, 9)
+#define SIM_IOCTL_COLD_RESET     _IO(SIM_IOCTL_BASE, 10)
+#define SIM_IOCTL_CARD_LOCK      _IO(SIM_IOCTL_BASE, 11)
+#define SIM_IOCTL_CARD_EJECT     _IO(SIM_IOCTL_BASE, 12)
+
+#endif
diff --git a/include/linux/mxc_srtc.h b/include/linux/mxc_srtc.h
new file mode 100644
index 0000000..a614264
--- /dev/null
+++ b/include/linux/mxc_srtc.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_srtc.h
+ *
+ * @brief SRTC IOCTL definitions
+ *
+ * @ingroup RTC
+ */
+
+
+#define RTC_READ_TIME_47BIT	_IOR('p', 0x20, unsigned long long)
+/* blocks until LPSCMR is set, returns difference */
+#define RTC_WAIT_TIME_SET	_IOR('p', 0x21, int64_t)
diff --git a/include/linux/mxc_v4l2.h b/include/linux/mxc_v4l2.h
new file mode 100644
index 0000000..530cf91
--- /dev/null
+++ b/include/linux/mxc_v4l2.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file arch-mxc/mxc_v4l2.h
+ *
+ * @brief mxc V4L2 private structures
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+/*
+ * For IPUv1 and IPUv3, V4L2_CID_MXC_ROT means encoder ioctl ID.
+ * And V4L2_CID_MXC_VF_ROT is viewfinder ioctl ID only for IPUv1 and IPUv3.
+ */
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_MXC_VF_ROT		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_MXC_MOTION     (V4L2_CID_PRIVATE_BASE + 3)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
diff --git a/include/linux/mxcfb.h b/include/linux/mxcfb.h
new file mode 100644
index 0000000..27f786e
--- /dev/null
+++ b/include/linux/mxcfb.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file arch-mxc/   mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_LOW_ACT	0x80000000
+#define FB_SYNC_CLK_LAT_FALL	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_loc_alpha {
+	int enable;
+	int alpha_in_pixel;
+	unsigned long alpha_phy_addr0;
+	unsigned long alpha_phy_addr1;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+struct mxcfb_pos {
+	__u16 x;
+	__u16 y;
+};
+
+struct mxcfb_gamma {
+	int enable;
+	int constk[16];
+	int slopek[16];
+};
+
+struct mxcfb_rect {
+	__u32 top;
+	__u32 left;
+	__u32 width;
+	__u32 height;
+};
+
+#define GRAYSCALE_8BIT				0x1
+#define GRAYSCALE_8BIT_INVERTED		0x2
+
+#define AUTO_UPDATE_MODE_REGION_MODE		0
+#define AUTO_UPDATE_MODE_AUTOMATIC_MODE	1
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define WAVEFORM_MODE_AUTO			257
+
+#define TEMP_USE_AMBIENT			0x1000
+
+struct mxcfb_alt_buffer_data {
+	__u32 phys_addr;
+	__u32 width;	/* width of entire buffer */
+	__u32 height;	/* height of entire buffer */
+	struct mxcfb_rect alt_update_region;	/* region within buffer to update */
+};
+
+struct mxcfb_update_data {
+	struct mxcfb_rect update_region;
+	__u32 waveform_mode;
+	__u32 update_mode;
+	__u32 update_marker;
+	int temp;
+	int use_alt_buffer;
+	struct mxcfb_alt_buffer_data alt_buffer_data;
+};
+
+/*
+ * Structure used to define waveform modes for driver
+ * Needed for driver to perform auto-waveform selection
+ */
+struct mxcfb_waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_OVERLAY_POS   _IOWR('F', 0x24, struct mxcfb_pos)
+#define MXCFB_GET_FB_IPU_CHAN 	_IOR('F', 0x25, u_int32_t)
+#define MXCFB_SET_LOC_ALPHA     _IOWR('F', 0x26, struct mxcfb_loc_alpha)
+#define MXCFB_SET_LOC_ALP_BUF    _IOW('F', 0x27, unsigned long)
+#define MXCFB_SET_GAMMA	       _IOW('F', 0x28, struct mxcfb_gamma)
+#define MXCFB_GET_FB_IPU_DI 	_IOR('F', 0x29, u_int32_t)
+#define MXCFB_GET_DIFMT	       _IOR('F', 0x2A, u_int32_t)
+
+/* IOCTLs for E-ink panel updates */
+#define MXCFB_SET_WAVEFORM_MODES	_IOW('F', 0x2B, struct mxcfb_waveform_modes)
+#define MXCFB_SET_TEMPERATURE		_IOW('F', 0x2C, int32_t)
+#define MXCFB_SET_AUTO_UPDATE_MODE	_IOW('F', 0x2D, __u32)
+#define MXCFB_SEND_UPDATE			_IOW('F', 0x2E, struct mxcfb_update_data)
+#define MXCFB_WAIT_FOR_UPDATE_COMPLETE	_IOW('F', 0x2F, __u32)
+
+#ifdef __KERNEL__
+
+extern struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region);
+
+#endif				/* __KERNEL__ */
+#endif
diff --git a/include/linux/pmic_adc.h b/include/linux/pmic_adc.h
new file mode 100644
index 0000000..a0c6599
--- /dev/null
+++ b/include/linux/pmic_adc.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D', 4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D', 5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum {
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum {
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum {
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct {
+/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum {
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct {
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator.
+ */
+typedef struct {
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+
+int is_pmic_adc_ready(void);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/linux/pmic_battery.h b/include/linux/pmic_battery.h
new file mode 100644
index 0000000..4f719e4
--- /dev/null
+++ b/include/linux/pmic_battery.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+
+/*!
+ * Get the charger voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_VOLTAGE		_IOR('p', 0xca, int)
+/*!
+ * Get the battery voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_VOLTAGE		_IOR('p', 0xcb, int)
+/*!
+ * Get the battery current.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_CURRENT		_IOR('p', 0xcc, int)
+/*!
+ * Get the charger sensor.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_SENSOR		_IOR('p', 0xcd, int)
+/*!
+ * Get the battery temperature.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_TEMPERATURE	_IOR('p', 0xce, int)
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum {
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum {
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum {
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum {
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct {
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct {
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * c_voltage threshold - Used on SC55112
+	 */
+	unsigned char threshold;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+
+/*START: for 3ds hw event*/
+/*!
+ * Battery event type enum
+ */
+enum {
+	BAT_EVENT_CHARGER_PLUG = 0x01,
+	BAT_EVENT_CHARGER_UNPLUG = 0x02,
+	BAT_EVENT_CHARGER_OVERVOLTAGE = 0x04,
+	BAT_EVENT_BATTERY_LOW = 0x08,
+	BAT_EVENT_POWER_FAILED = 0x10,
+	BAT_EVENT_CHARGER_FULL = 0x20,
+} t_bat_event;
+/*END: for 3ds hw event*/
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+ *		 BPDET   UVDET   LOBATL
+ *		 ____    _____   ___________
+ *		 0       2.6     UVDET + 0.2
+ *		 1       2.6     UVDET + 0.3
+ *		 2       2.6     UVDET + 0.4
+ *		 3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/linux/pmic_external.h b/include/linux/pmic_external.h
new file mode 100644
index 0000000..b632eaf
--- /dev/null
+++ b/include/linux/pmic_external.h
@@ -0,0 +1,434 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum {
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3,
+	PMIC_MC34704 = 4
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct {
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its
+ * parameter to be used when un/registering and launching a callback
+ * for an event.
+ */
+typedef struct {
+	/*!
+	 * call back function
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct {
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for sc55112 core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#define PMIC_ARBITRATION	"NULL"
+
+
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,		/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,		/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,		/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,		/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,		/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,		/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+};
+
+typedef enum {
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
+} t_sensor;
+
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value);
+int pmic_read(int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+void mc13892_power_off(void);
+
+#elif defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
+
+typedef enum {
+	/* register names for mc34704 */
+	REG_MC34704_GENERAL1 = 0x01,
+	REG_MC34704_GENERAL2 = 0x02,
+	REG_MC34704_GENERAL3 = 0x03,
+	REG_MC34704_VGSET1 = 0x04,
+	REG_MC34704_VGSET2 = 0x05,
+	REG_MC34704_REG2SET1 = 0x06,
+	REG_MC34704_REG2SET2 = 0x07,
+	REG_MC34704_REG3SET1 = 0x08,
+	REG_MC34704_REG3SET2 = 0x09,
+	REG_MC34704_REG4SET1 = 0x0A,
+	REG_MC34704_REG4SET2 = 0x0B,
+	REG_MC34704_REG5SET1 = 0x0C,
+	REG_MC34704_REG5SET2 = 0x0D,
+	REG_MC34704_REG5SET3 = 0x0E,
+	REG_MC34704_REG6SET1 = 0x0F,
+	REG_MC34704_REG6SET2 = 0x10,
+	REG_MC34704_REG6SET3 = 0x11,
+	REG_MC34704_REG7SET1 = 0x12,
+	REG_MC34704_REG7SET2 = 0x13,
+	REG_MC34704_REG7SET3 = 0x14,
+	REG_MC34704_REG8SET1 = 0x15,
+	REG_MC34704_REG8SET2 = 0x16,
+	REG_MC34704_REG8SET3 = 0x17,
+	REG_MC34704_FAULTS = 0x18,
+	REG_MC34704_I2CSET1 = 0x19,
+	REG_MC34704_REG3DAC = 0x49,
+	REG_MC34704_REG7CR0 = 0x58,
+	REG_MC34704_REG7DAC = 0x59,
+	REG_NB = 0x60,
+} pmic_reg;
+
+typedef enum {
+	/* events for mc34704 */
+	EVENT_FLT1 = 0,
+	EVENT_FLT2,
+	EVENT_FLT3,
+	EVENT_FLT4,
+	EVENT_FLT5,
+	EVENT_FLT6,
+	EVENT_FLT7,
+	EVENT_FLT8,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	MCU_SENSOR_NOT_SUPPORT
+} t_sensor;
+
+typedef enum {
+	MCU_SENSOR_BIT_NOT_SUPPORT
+} t_sensor_bits;
+
+#else
+typedef int type_event;
+typedef int t_sensor;
+typedef int t_sensor_bits;
+
+#endif				/* MXC_PMIC_MC34704 */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+#if defined(CONFIG_MXC_PMIC)
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback);
+/*!
+* This function is called by PMIC clients to un-subscribe on an event.
+*
+* @param        event_unsub   structure of event, it contains type of event and callback
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+/*!
+* This function is called to read all sensor bits of PMIC.
+*
+* @param        sensor    Sensor to be checked.
+*
+* @return       This function returns true if the sensor bit is high;
+*               or returns false if the sensor bit is low.
+*/
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+* This function checks one sensor of PMIC.
+*
+* @param        sensor_bits  structure of all sensor bits.
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits);
+
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
+#endif				/*CONFIG_MXC_PMIC*/
+#endif				/* __KERNEL__ */
+/* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
+
+struct pmic_platform_data {
+	int (*init)(void *);
+	int power_key_irq;
+};
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/linux/pmic_light.h b/include/linux/pmic_light.h
new file mode 100644
index 0000000..7611f48
--- /dev/null
+++ b/include/linux/pmic_light.h
@@ -0,0 +1,1082 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum {
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum {
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum {
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct {
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+				 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+				 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum {
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum {
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum {
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum {
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum {
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum {
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum {
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum {
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum {
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum {
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+enum curr_level {
+	LIT_CURR_0 = 0,
+	LIT_CURR_3,
+	LIT_CURR_6,
+	LIT_CURR_9,
+	LIT_CURR_12,
+	LIT_CURR_15,
+	LIT_CURR_18,
+	LIT_CURR_21,
+	/* below setting only used for main/aux/keypad */
+	LIT_CURR_HI_0,
+	LIT_CURR_HI_6,
+	LIT_CURR_HI_12,
+	LIT_CURR_HI_18,
+	LIT_CURR_HI_24,
+	LIT_CURR_HI_30,
+	LIT_CURR_HI_36,
+	LIT_CURR_HI_42,
+};
+
+enum lit_channel {
+	LIT_MAIN = 0,
+	LIT_AUX,
+	LIT_KEY,
+	LIT_RED,
+	LIT_GREEN,
+	LIT_BLUE,
+};
+
+#endif
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ *		 level     current
+ *		 ------    -----------
+ *		 0         0 mA
+ *		 1         12 mA
+ *		 2         24 mA
+ *		 3         36 mA
+ *		 4         48 mA
+ *		 5         60 mA
+ *		 6         72 mA
+ *		 7         84 mA
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+				   unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ *		 dc        Duty Cycle (% On-time over Cycle Time)
+ *		 ------    ---------------------------------------
+ *		 0        0%
+ *		 1        6.7%
+ *		 2        13.3%
+ *		 3        20%
+ *		 4        26.7%
+ *		 5        33.3%
+ *		 6        40%
+ *		 7        46.7%
+ *		 8        53.3%
+ *		 9        60%
+ *		 10        66.7%
+ *		 11        73.3%
+ *		 12        80%
+ *		 13        86.7%
+ *		 14        93.3%
+ *		 15        100%
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+				     unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ *		 period      Cycle Time
+ *		 --------    ------------
+ *		 0          0.01 seconds
+ *		 1          0.1 seconds
+ *		 2          0.5 seconds
+ *		 3          2 seconds
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Instant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level *level,
+				       t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool *skip,
+					     t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level *level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time *ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel,
+				      bool *rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool *rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain,
+					       bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level);
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level);
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc);
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc);
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/linux/pmic_rtc.h b/include/linux/pmic_rtc.h
new file mode 100644
index 0000000..ff15676
--- /dev/null
+++ b/include/linux/pmic_rtc.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+#define         PMIC_RTC_SET_TIME                    _IOWR('p', 0xd1, int)
+#define         PMIC_RTC_GET_TIME                    _IOWR('p', 0xd2, int)
+#define         PMIC_RTC_SET_ALARM		     _IOWR('p', 0xd3, int)
+#define         PMIC_RTC_GET_ALARM		     _IOWR('p', 0xd4, int)
+#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p', 0xd5, int)
+#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p', 0xd6, int)
+#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p', 0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum {
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ * 		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/linux/pmic_status.h b/include/linux/pmic_status.h
new file mode 100644
index 0000000..08a2acb
--- /dev/null
+++ b/include/linux/pmic_status.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+#ifdef __KERNEL__
+#include <asm/uaccess.h>	/* copy_{from,to}_user() */
+#endif
+/*!
+ * @file arch-mxc/pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != PMIC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != PMIC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
new file mode 100644
index 0000000..adca97d
--- /dev/null
+++ b/include/linux/pxp_dma.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _PXP_DMA
+#define _PXP_DMA
+
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE		0x0
+#define PXP_LUT_INVERT		0x1
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+struct pxp_layer_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned int pixel_fmt;
+
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	__u32 color_key_enable;
+	__u32 color_key;
+	bool global_alpha_enable;
+	__u8 global_alpha;
+	bool local_alpha_enable;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int yuv;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	__u32 bgcolor;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[8];
+	struct pxp_layer_param out_param;
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int chan_id;
+};
+
+struct pxp_mem_desc {
+	__u32 size;
+	dma_addr_t phys_addr;
+	__u32 cpu_addr;		/* cpu address to free the dma mem */
+	__u32 virt_uaddr;		/* virtual user space address */
+};
+
+#ifdef __KERNEL__
+
+struct pxp_tx_desc {
+	struct dma_async_tx_descriptor txd;
+	struct list_head tx_list;
+	struct list_head list;
+	int len;
+	union {
+		struct pxp_layer_param s0_param;
+		struct pxp_layer_param out_param;
+		struct pxp_layer_param ol_param;
+	} layer_param;
+	struct pxp_proc_data proc_data;
+
+	u32 hist_status;	/* Histogram output status */
+
+	struct pxp_tx_desc *next;
+};
+
+struct pxp_channel {
+	struct dma_chan dma_chan;
+	dma_cookie_t completed;	/* last completed cookie */
+	enum pxp_channel_status status;
+	void *client;		/* Only one client per channel */
+	unsigned int n_tx_desc;
+	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
+	struct list_head active_list;	/* active tx-descriptors */
+	struct list_head free_list;	/* free tx-descriptors */
+	struct list_head queue;	/* queued tx-descriptors */
+	struct list_head list;	/* track queued channel number */
+	spinlock_t lock;	/* protects sg[0,1], queue */
+	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	int active_buffer;
+	unsigned int eof_irq;
+	char eof_name[16];	/* EOF IRQ name for request_irq()  */
+};
+
+struct pxp_irq_info {
+	wait_queue_head_t waitq;
+	int irq_pending;
+	int hist_status;
+};
+
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+
+void pxp_txd_ack(struct dma_async_tx_descriptor *txd,
+		 struct pxp_channel *pxp_chan);
+#endif
+
+#endif
diff --git a/include/linux/regulator/max17135.h b/include/linux/regulator/max17135.h
new file mode 100644
index 0000000..06eaf88
--- /dev/null
+++ b/include/linux/regulator/max17135.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __LINUX_REGULATOR_MAX17135_H_
+#define __LINUX_REGULATOR_MAX17135_H_
+
+enum {
+    /* In alphabetical order */
+    MAX17135_DISPLAY, /* virtual master enable */
+    MAX17135_GVDD,
+    MAX17135_GVEE,
+    MAX17135_HVINN,
+    MAX17135_HVINP,
+    MAX17135_VCOM,
+    MAX17135_VNEG,
+    MAX17135_VPOS,
+    MAX17135_NUM_REGULATORS,
+};
+
+/*
+ * Declarations
+ */
+struct regulator_init_data;
+
+struct max17135_platform_data {
+	unsigned int gvee_pwrup;
+	unsigned int vneg_pwrup;
+	unsigned int vpos_pwrup;
+	unsigned int gvdd_pwrup;
+	unsigned int gvdd_pwrdn;
+	unsigned int vpos_pwrdn;
+	unsigned int vneg_pwrdn;
+	unsigned int gvee_pwrdn;
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_intr;
+	struct regulator_init_data *regulator_init;
+};
+
+#endif
diff --git a/include/linux/soundcard.h b/include/linux/soundcard.h
index 1904afe..91b9b79 100644
--- a/include/linux/soundcard.h
+++ b/include/linux/soundcard.h
@@ -873,12 +873,16 @@ typedef struct copr_msg {
 #define SOUND_MIXER_READ_LINE1		MIXER_READ(SOUND_MIXER_LINE1)
 #define SOUND_MIXER_READ_LINE2		MIXER_READ(SOUND_MIXER_LINE2)
 #define SOUND_MIXER_READ_LINE3		MIXER_READ(SOUND_MIXER_LINE3)
+#define SOUND_MIXER_READ_PHONEIN	MIXER_READ(SOUND_MIXER_PHONEIN)
+#define SOUND_MIXER_READ_PHONEOUT	MIXER_READ(SOUND_MIXER_PHONEOUT)
 
 /* Obsolete macros */
 #define SOUND_MIXER_READ_MUTE		MIXER_READ(SOUND_MIXER_MUTE)
 #define SOUND_MIXER_READ_ENHANCE	MIXER_READ(SOUND_MIXER_ENHANCE)
 #define SOUND_MIXER_READ_LOUD		MIXER_READ(SOUND_MIXER_LOUD)
 
+#define SOUND_MIXER_READ_OUTSRC		MIXER_READ(SOUND_MIXER_OUTSRC)
+#define SOUND_MIXER_READ_OUTMASK	MIXER_READ(SOUND_MIXER_OUTMASK)
 #define SOUND_MIXER_READ_RECSRC		MIXER_READ(SOUND_MIXER_RECSRC)
 #define SOUND_MIXER_READ_DEVMASK	MIXER_READ(SOUND_MIXER_DEVMASK)
 #define SOUND_MIXER_READ_RECMASK	MIXER_READ(SOUND_MIXER_RECMASK)
@@ -903,6 +907,8 @@ typedef struct copr_msg {
 #define SOUND_MIXER_WRITE_LINE1		MIXER_WRITE(SOUND_MIXER_LINE1)
 #define SOUND_MIXER_WRITE_LINE2		MIXER_WRITE(SOUND_MIXER_LINE2)
 #define SOUND_MIXER_WRITE_LINE3		MIXER_WRITE(SOUND_MIXER_LINE3)
+#define SOUND_MIXER_WRITE_PHONEIN	MIXER_WRITE(SOUND_MIXER_PHONEIN)
+#define SOUND_MIXER_WRITE_PHONEOUT	MIXER_WRITE(SOUND_MIXER_PHONEOUT)
 
 /* Obsolete macros */
 #define SOUND_MIXER_WRITE_MUTE		MIXER_WRITE(SOUND_MIXER_MUTE)
@@ -910,6 +916,7 @@ typedef struct copr_msg {
 #define SOUND_MIXER_WRITE_LOUD		MIXER_WRITE(SOUND_MIXER_LOUD)
 
 #define SOUND_MIXER_WRITE_RECSRC	MIXER_WRITE(SOUND_MIXER_RECSRC)
+#define SOUND_MIXER_WRITE_OUTSRC	MIXER_WRITE(SOUND_MIXER_OUTSRC)
 
 typedef struct mixer_info
 {
diff --git a/include/linux/usb/fsl_xcvr.h b/include/linux/usb/fsl_xcvr.h
new file mode 100644
index 0000000..96e5526
--- /dev/null
+++ b/include/linux/usb/fsl_xcvr.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __LINUX_USB_FSL_XCVR_H
+#define __LINUX_USB_FSL_XCVR_H
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+struct fsl_usb2_platform_data;
+
+enum usb_test_mode{
+	USB_TEST_J = 1,
+	USB_TEST_K = 2,
+};
+
+/**
+ * @name: transceiver name
+ * @xcvr_type: one of PORTSC_PTS_{UTMI,SERIAL,ULPI}
+ * @init: transceiver- and board-specific initialization function
+ * @uninit: transceiver- and board-specific uninitialization function
+ * @set_host:
+ * @set_device:
+ * @pullup: enable or disable D+ pullup
+ *
+ */
+struct fsl_xcvr_ops {
+	char *name;
+	u32 xcvr_type;
+
+	void (*init)(struct fsl_xcvr_ops *ops);
+	void (*uninit)(struct fsl_xcvr_ops *ops);
+	void (*suspend)(struct fsl_xcvr_ops *ops);
+	void (*set_host)(void);
+	void (*set_device)(void);
+	void (*set_vbus_power)(struct fsl_xcvr_ops *ops,
+			       struct fsl_usb2_platform_data *pdata, int on);
+	void (*set_vbus_draw)(struct fsl_xcvr_ops *ops,
+			struct fsl_usb2_platform_data *pdata, unsigned mA);
+	void (*set_remote_wakeup)(u32 *view);
+	void (*pullup)(int on);
+	void(*set_test_mode)(u32 *view, enum usb_test_mode mode);
+};
+
+struct fsl_xcvr_power {
+	struct platform_device *usb_pdev;
+	struct regulator *regu1;
+	struct regulator *regu2;
+};
+#endif
-- 
1.5.4.4

