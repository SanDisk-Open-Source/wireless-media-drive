From 755c9c452ede9e68cd61b67a701173b9550c7c96 Mon Sep 17 00:00:00 2001
From: Liu Ying <Ying.Liu@freescale.com>
Date: Sat, 12 Feb 2011 16:01:23 +0800
Subject: [PATCH] ENGR00139110-2 LDB:Chang video mode setting method

This patch changes video mode setting method for LDB
related video modes.
Users need to add 'ldb=dix' for default video mode
support, otherwise, need to specify the ldb mode
in Kernel bootup command line.

Signed-off-by: Liu Ying <Ying.Liu@freescale.com>
---
 drivers/video/mxc/Makefile |    2 +-
 drivers/video/mxc/ldb.c    | 1115 +++++++++++++++++++++++---------------------
 2 files changed, 589 insertions(+), 528 deletions(-)

diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index 02b3797..4554105 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -1,6 +1,7 @@
 obj-$(CONFIG_FB_MODE_HELPERS)			+= mxc_edid.o
 obj-$(CONFIG_FB_MXC_TVOUT_TVE)             	+= tve.o
 obj-$(CONFIG_FB_MXC_SII902X)                    += mxcfb_sii902x.o
+obj-$(CONFIG_FB_MXC_LDB)			+= ldb.o
 ifeq ($(CONFIG_ARCH_MX21)$(CONFIG_ARCH_MX27)$(CONFIG_ARCH_MX25),y)
 	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
 	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
@@ -20,7 +21,6 @@ obj-$(CONFIG_FB_MXC_EPSON_VGA_SYNC_PANEL)   += mxcfb_epson_vga.o
 obj-$(CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL)   += mxcfb_claa_wvga.o
 obj-$(CONFIG_FB_MXC_SEIKO_WVGA_SYNC_PANEL)   += mxcfb_seiko_wvga.o
 obj-$(CONFIG_FB_MXC_TVOUT_CH7024)           += ch7024.o
-obj-$(CONFIG_FB_MXC_LDB)                    += ldb.o
 obj-$(CONFIG_FB_MXC_CH7026)		    		+= mxcfb_ch7026.o
 obj-$(CONFIG_FB_MXC_EINK_PANEL)             += mxc_epdc_fb.o
 obj-$(CONFIG_FB_MXC_ELCDIF_FB)		    += mxc_elcdif_fb.o
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index 258c519..ecc48b2 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -40,6 +40,7 @@
 #include <linux/uaccess.h>
 #include <linux/fsl_devices.h>
 #include <mach/hardware.h>
+#include <mach/clock.h>
 
 #define LDB_BGREF_RMODE_MASK		0x00008000
 #define LDB_BGREF_RMODE_INT		0x00008000
@@ -85,11 +86,13 @@ enum ldb_chan_mode_opt {
 	LDB_DUL_DI1 = 4,
 	LDB_SPL_DI0 = 5,
 	LDB_SPL_DI1 = 6,
+	LDB_NO_MODE = 7,
 };
 
 static struct ldb_data {
 	struct fb_info *fbi[2];
 	bool ch_working[2];
+	int blank[2];
 	uint32_t chan_mode_opt;
 	uint32_t chan_bit_map[2];
 	uint32_t bgref_rmode;
@@ -97,16 +100,15 @@ static struct ldb_data {
 	uint32_t *control_reg;
 	struct clk *ldb_di_clk[2];
 	struct regulator *lvds_bg_reg;
-	struct list_head modelist;
 } ldb;
 
 static struct device *g_ldb_dev;
 static u32 *ldb_reg;
-static bool enabled[2];
-static int g_chan_mode_opt;
+static int g_chan_mode_opt = LDB_NO_MODE;
 static int g_chan_bit_map[2];
 static bool g_enable_ldb;
-static bool g_boot_cmd;
+static bool g_di0_used;
+static bool g_di1_used;
 
 DEFINE_SPINLOCK(ldb_lock);
 
@@ -118,7 +120,7 @@ struct fb_videomode mxcfb_ldb_modedb[] = {
 	 10, 2,
 	 0,
 	 FB_VMODE_NONINTERLACED,
-	 0,},
+	 FB_MODE_IS_DETAILED,},
 	{
 	 "XGA", 60, 1024, 768, 15385,
 	 220, 40,
@@ -126,7 +128,7 @@ struct fb_videomode mxcfb_ldb_modedb[] = {
 	 60, 10,
 	 0,
 	 FB_VMODE_NONINTERLACED,
-	 0,},
+	 FB_MODE_IS_DETAILED,},
 };
 int mxcfb_ldb_modedb_sz = ARRAY_SIZE(mxcfb_ldb_modedb);
 
@@ -166,7 +168,7 @@ static void ldb_disable(int ipu_di)
 
 	switch (ldb.chan_mode_opt) {
 	case LDB_SIN_DI0:
-		if (ipu_di != 0 || !ldb.ch_working[0] || !enabled[0]) {
+		if (ipu_di != 0 || !ldb.ch_working[0]) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
@@ -176,15 +178,15 @@ static void ldb_disable(int ipu_di)
 			     LDB_CH0_MODE_DISABLE,
 			     ldb.control_reg);
 
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		clk_disable(ldb.ldb_di_clk[0]);
+		ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+		if (clk_get_usecount(ldb.ldb_di_clk[0]) != 0)
+			clk_disable(ldb.ldb_di_clk[0]);
 		clk_put(ldb.ldb_di_clk[0]);
 
 		ldb.ch_working[0] = false;
-		enabled[0] = false;
 		break;
 	case LDB_SIN_DI1:
-		if (ipu_di != 1 || !ldb.ch_working[1] || !enabled[1]) {
+		if (ipu_di != 1 || !ldb.ch_working[1]) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
@@ -194,16 +196,16 @@ static void ldb_disable(int ipu_di)
 			     LDB_CH1_MODE_DISABLE,
 			     ldb.control_reg);
 
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		clk_disable(ldb.ldb_di_clk[1]);
+		ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+		if (clk_get_usecount(ldb.ldb_di_clk[1]) != 0)
+			clk_disable(ldb.ldb_di_clk[1]);
 		clk_put(ldb.ldb_di_clk[1]);
 
 		ldb.ch_working[1] = false;
-		enabled[1] = false;
 		break;
 	case LDB_SPL_DI0:
 	case LDB_DUL_DI0:
-		if (ipu_di != 0 || !enabled[0]) {
+		if (ipu_di != 0) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
@@ -226,20 +228,20 @@ static void ldb_disable(int ipu_di)
 						     ldb.control_reg);
 				}
 
-				ldb.ldb_di_clk[i] = clk_get(NULL, i ?
+				ldb.ldb_di_clk[i] = clk_get(g_ldb_dev, i ?
 							"ldb_di1_clk" :
 							"ldb_di0_clk");
-				clk_disable(ldb.ldb_di_clk[i]);
+				if (clk_get_usecount(ldb.ldb_di_clk[i]) != 0)
+					clk_disable(ldb.ldb_di_clk[i]);
 				clk_put(ldb.ldb_di_clk[i]);
 
 				ldb.ch_working[i] = false;
 			}
 		}
-		enabled[0] = false;
 		break;
 	case LDB_SPL_DI1:
 	case LDB_DUL_DI1:
-		if (ipu_di != 1 || !enabled[1]) {
+		if (ipu_di != 1) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
@@ -262,19 +264,19 @@ static void ldb_disable(int ipu_di)
 						     ldb.control_reg);
 				}
 
-				ldb.ldb_di_clk[i] = clk_get(NULL, i ?
+				ldb.ldb_di_clk[i] = clk_get(g_ldb_dev, i ?
 							"ldb_di1_clk" :
 							"ldb_di0_clk");
-				clk_disable(ldb.ldb_di_clk[i]);
+				if (clk_get_usecount(ldb.ldb_di_clk[i]) != 0)
+					clk_disable(ldb.ldb_di_clk[i]);
 				clk_put(ldb.ldb_di_clk[i]);
 
 				ldb.ch_working[i] = false;
 			}
 		}
-		enabled[1] = false;
 		break;
 	case LDB_SEP:
-		if (ldb.ch_working[ipu_di] && enabled[ipu_di]) {
+		if (ldb.ch_working[ipu_di]) {
 			reg = __raw_readl(ldb.control_reg);
 			if (ipu_di == 0)
 				__raw_writel((reg & ~LDB_CH0_MODE_MASK) |
@@ -285,14 +287,14 @@ static void ldb_disable(int ipu_di)
 					     LDB_CH1_MODE_DISABLE,
 					     ldb.control_reg);
 
-			ldb.ldb_di_clk[ipu_di] = clk_get(NULL, ipu_di ?
+			ldb.ldb_di_clk[ipu_di] = clk_get(g_ldb_dev, ipu_di ?
 							       "ldb_di1_clk" :
 							       "ldb_di0_clk");
-			clk_disable(ldb.ldb_di_clk[ipu_di]);
+			if (clk_get_usecount(ldb.ldb_di_clk[ipu_di]) != 0)
+				clk_disable(ldb.ldb_di_clk[ipu_di]);
 			clk_put(ldb.ldb_di_clk[ipu_di]);
 
 			ldb.ch_working[ipu_di] = false;
-			enabled[ipu_di] = false;
 		}
 		break;
 	default:
@@ -312,67 +314,68 @@ static void ldb_enable(int ipu_di)
 	reg = __raw_readl(ldb.control_reg);
 	switch (ldb.chan_mode_opt) {
 	case LDB_SIN_DI0:
-		if (ldb.ch_working[0] || ipu_di != 0 || enabled[0]) {
+		if (ldb.ch_working[0] || ipu_di != 0) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
 
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		clk_enable(ldb.ldb_di_clk[0]);
+		ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+		if (clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+			clk_enable(ldb.ldb_di_clk[0]);
 		clk_put(ldb.ldb_di_clk[0]);
 		__raw_writel((reg & ~LDB_CH0_MODE_MASK) |
 			      LDB_CH0_MODE_EN_TO_DI0, ldb.control_reg);
 		ldb.ch_working[0] = true;
-		enabled[0] = true;
 		break;
 	case LDB_SIN_DI1:
-		if (ldb.ch_working[1] || ipu_di != 1 || enabled[1]) {
+		if (ldb.ch_working[1] || ipu_di != 1) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
 
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		clk_enable(ldb.ldb_di_clk[1]);
+		ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+		if (clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+			clk_enable(ldb.ldb_di_clk[1]);
 		clk_put(ldb.ldb_di_clk[1]);
 		__raw_writel((reg & ~LDB_CH1_MODE_MASK) |
 			      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
 		ldb.ch_working[1] = true;
-		enabled[1] = true;
 		break;
 	case LDB_SEP:
-		if (ldb.ch_working[ipu_di] || enabled[ipu_di]) {
+		if (ldb.ch_working[ipu_di]) {
 			spin_unlock(&ldb_lock);
 			return;
 		}
 
 		if (ipu_di == 0) {
-			ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-			clk_enable(ldb.ldb_di_clk[0]);
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+			if (clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+				clk_enable(ldb.ldb_di_clk[0]);
 			clk_put(ldb.ldb_di_clk[0]);
 			__raw_writel((reg & ~LDB_CH0_MODE_MASK) |
 				      LDB_CH0_MODE_EN_TO_DI0,
 				      ldb.control_reg);
 			ldb.ch_working[0] = true;
 		} else {
-			ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-			clk_enable(ldb.ldb_di_clk[1]);
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+			if (clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+				clk_enable(ldb.ldb_di_clk[1]);
 			clk_put(ldb.ldb_di_clk[1]);
 			__raw_writel((reg & ~LDB_CH1_MODE_MASK) |
 				      LDB_CH1_MODE_EN_TO_DI1,
 				      ldb.control_reg);
 			ldb.ch_working[1] = true;
 		}
-		enabled[ipu_di] = true;
 		break;
 	case LDB_DUL_DI0:
 	case LDB_SPL_DI0:
-		if (ipu_di != 0 || enabled[0])
+		if (ipu_di != 0)
 			return;
 		else
 			goto proc;
 	case LDB_DUL_DI1:
 	case LDB_SPL_DI1:
-		if (ipu_di != 1 || enabled[1])
+		if (ipu_di != 1)
 			return;
 proc:
 		if (ldb.ch_working[0] || ldb.ch_working[1]) {
@@ -380,10 +383,12 @@ proc:
 			return;
 		}
 
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		clk_enable(ldb.ldb_di_clk[0]);
-		clk_enable(ldb.ldb_di_clk[1]);
+		ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+		ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+		if (clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+			clk_enable(ldb.ldb_di_clk[0]);
+		if (clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+			clk_enable(ldb.ldb_di_clk[1]);
 		clk_put(ldb.ldb_di_clk[0]);
 		clk_put(ldb.ldb_di_clk[1]);
 
@@ -414,7 +419,6 @@ proc:
 		}
 		ldb.ch_working[0] = true;
 		ldb.ch_working[1] = true;
-		enabled[ipu_di] = true;
 		break;
 	default:
 		break;
@@ -423,6 +427,172 @@ proc:
 	return;
 }
 
+static int ldb_fb_pre_setup(struct fb_info *fbi)
+{
+	int ipu_di = 0;
+	struct clk *di_clk, *ldb_clk_parent;
+	unsigned long ldb_clk_prate = 455000000;
+
+	fbi->mode = (struct fb_videomode *)fb_match_mode(&fbi->var,
+			&fbi->modelist);
+	if (!fbi->mode) {
+		dev_warn(g_ldb_dev, "can not find mode for xres=%d, yres=%d\n",
+				fbi->var.xres, fbi->var.yres);
+		return 0;
+	}
+
+	if (fbi->fbops->fb_ioctl) {
+		mm_segment_t old_fs;
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi,
+				MXCFB_GET_FB_IPU_DI,
+				(unsigned long)&ipu_di);
+		fbi->fbops->fb_ioctl(fbi,
+				MXCFB_GET_FB_BLANK,
+				(unsigned int)(&ldb.blank[ipu_di]));
+		set_fs(old_fs);
+
+		/*
+		 * Default ldb mode:
+		 * 1080p: DI0 split, SPWG or DI1 split, SPWG
+		 * others: single, SPWG
+		 */
+		if (ldb.chan_mode_opt == LDB_NO_MODE) {
+			if (fb_mode_is_equal(fbi->mode, &mxcfb_ldb_modedb[0])) {
+				if (ipu_di == 0) {
+					ldb.chan_mode_opt = LDB_SPL_DI0;
+					dev_warn(g_ldb_dev,
+						"default di0 split mode\n");
+				} else {
+					ldb.chan_mode_opt = LDB_SPL_DI1;
+					dev_warn(g_ldb_dev,
+						"default di1 split mode\n");
+				}
+				ldb.chan_bit_map[0] = LDB_BIT_MAP_SPWG;
+				ldb.chan_bit_map[1] = LDB_BIT_MAP_SPWG;
+			} else if (fb_mode_is_equal(fbi->mode, &mxcfb_ldb_modedb[1])) {
+				if (ipu_di == 0) {
+					ldb.chan_mode_opt = LDB_SIN_DI0;
+					ldb.chan_bit_map[0] = LDB_BIT_MAP_SPWG;
+					dev_warn(g_ldb_dev,
+						 "default di0 single mode\n");
+				} else {
+					ldb.chan_mode_opt = LDB_SIN_DI1;
+					ldb.chan_bit_map[1] = LDB_BIT_MAP_SPWG;
+					dev_warn(g_ldb_dev,
+						 "default di1 single mode\n");
+				}
+			}
+		}
+
+		/* TODO:Set the correct pll4 rate for all situations */
+		if (ipu_di == 1) {
+			ldb.ldb_di_clk[1] =
+				clk_get(g_ldb_dev, "ldb_di1_clk");
+			di_clk = clk_get(g_ldb_dev, "ipu_di1_clk");
+			ldb_clk_parent =
+				clk_get_parent(ldb.ldb_di_clk[1]);
+			clk_set_rate(ldb_clk_parent, ldb_clk_prate);
+			clk_set_parent(di_clk, ldb.ldb_di_clk[1]);
+			clk_put(di_clk);
+			clk_put(ldb.ldb_di_clk[1]);
+		} else {
+			ldb.ldb_di_clk[0] =
+				clk_get(g_ldb_dev, "ldb_di0_clk");
+			di_clk = clk_get(g_ldb_dev, "ipu_di0_clk");
+			ldb_clk_parent =
+				clk_get_parent(ldb.ldb_di_clk[0]);
+			clk_set_rate(ldb_clk_parent, ldb_clk_prate);
+			clk_set_parent(di_clk, ldb.ldb_di_clk[0]);
+			clk_put(di_clk);
+			clk_put(ldb.ldb_di_clk[0]);
+		}
+
+		switch (ldb.chan_mode_opt) {
+		case LDB_SIN_DI0:
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+			clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
+			if (ldb.blank[0] == FB_BLANK_UNBLANK &&
+			    clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+				clk_enable(ldb.ldb_di_clk[0]);
+			clk_put(ldb.ldb_di_clk[0]);
+			break;
+		case LDB_SIN_DI1:
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+			clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
+			if (ldb.blank[1] == FB_BLANK_UNBLANK &&
+			    clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+				clk_enable(ldb.ldb_di_clk[1]);
+			clk_put(ldb.ldb_di_clk[1]);
+			break;
+		case LDB_SEP:
+			if (ipu_di == 0) {
+				ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+				clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
+				if (ldb.blank[0] == FB_BLANK_UNBLANK &&
+				    clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+					clk_enable(ldb.ldb_di_clk[0]);
+				clk_put(ldb.ldb_di_clk[0]);
+			} else {
+				ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+				clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
+				if (ldb.blank[1] == FB_BLANK_UNBLANK &&
+				    clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+					clk_enable(ldb.ldb_di_clk[1]);
+				clk_put(ldb.ldb_di_clk[1]);
+			}
+			break;
+		case LDB_DUL_DI0:
+		case LDB_SPL_DI0:
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+			if (ldb.chan_mode_opt == LDB_DUL_DI0) {
+				clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
+			} else {
+				clk_set_rate(ldb.ldb_di_clk[0], 2*ldb_clk_prate/7);
+				clk_set_rate(ldb.ldb_di_clk[1], 2*ldb_clk_prate/7);
+			}
+			if (ldb.blank[0] == FB_BLANK_UNBLANK) {
+				if (clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+					clk_enable(ldb.ldb_di_clk[0]);
+				if (clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+					clk_enable(ldb.ldb_di_clk[1]);
+			}
+			clk_put(ldb.ldb_di_clk[0]);
+			clk_put(ldb.ldb_di_clk[1]);
+			break;
+		case LDB_DUL_DI1:
+		case LDB_SPL_DI1:
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
+			if (ldb.chan_mode_opt == LDB_DUL_DI1) {
+				clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
+			} else {
+				clk_set_rate(ldb.ldb_di_clk[0], 2*ldb_clk_prate/7);
+				clk_set_rate(ldb.ldb_di_clk[1], 2*ldb_clk_prate/7);
+			}
+			if (ldb.blank[1] == FB_BLANK_UNBLANK) {
+				if (clk_get_usecount(ldb.ldb_di_clk[0]) == 0)
+					clk_enable(ldb.ldb_di_clk[0]);
+				if (clk_get_usecount(ldb.ldb_di_clk[1]) == 0)
+					clk_enable(ldb.ldb_di_clk[1]);
+			}
+			clk_put(ldb.ldb_di_clk[0]);
+			clk_put(ldb.ldb_di_clk[1]);
+			break;
+		default:
+			break;
+		}
+
+		if (ldb.blank[ipu_di] == FB_BLANK_UNBLANK)
+			ldb_enable(ipu_di);
+	}
+
+	return 0;
+}
+
 int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 {
 	struct fb_event *event = v;
@@ -430,26 +600,322 @@ int ldb_fb_event(struct notifier_block *nb, unsigned long val, void *v)
 	mm_segment_t old_fs;
 	int ipu_di = 0;
 
+	/* Get rid of impact from FG fb */
+	if (strcmp(fbi->fix.id, "DISP3 FG") == 0)
+		return 0;
+
+	if (fbi->fbops->fb_ioctl) {
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi,
+				MXCFB_GET_FB_IPU_DI,
+				(unsigned long)&ipu_di);
+		set_fs(old_fs);
+	} else
+		return 0;
+
+	if ((ipu_di == 0 && !g_di0_used) ||
+	    (ipu_di == 1 && !g_di1_used) ||
+	    ipu_di > 1)
+		return 0;
+
+	fbi->mode = (struct fb_videomode *)fb_match_mode(&fbi->var,
+			&fbi->modelist);
+
+	if (!fbi->mode) {
+		dev_warn(g_ldb_dev, "can not find mode for xres=%d, yres=%d\n",
+				fbi->var.xres, fbi->var.yres);
+		return 0;
+	}
+
 	switch (val) {
-	case FB_EVENT_BLANK:
-		if (ldb.fbi[0] != fbi && ldb.fbi[1] != fbi)
+	case FB_EVENT_MODE_CHANGE: {
+		int ipu_di_pix_fmt;
+		uint32_t reg;
+
+		if ((ldb.fbi[0] != NULL && ldb.chan_mode_opt != LDB_SEP) ||
+		    ldb.fbi[1] != NULL)
 			return 0;
 
-		if (fbi->fbops->fb_ioctl) {
-			old_fs = get_fs();
-			set_fs(KERNEL_DS);
-			fbi->fbops->fb_ioctl(fbi,
-					MXCFB_GET_FB_IPU_DI,
-					(unsigned long)&ipu_di);
-			set_fs(old_fs);
+		/*
+		 * We cannot support two LVDS panels with different
+		 * pixel clock rates except that one's pixel clock rate
+		 * is two times of the others'.
+		 */
+		if (ldb.fbi[0]) {
+			if (ldb.fbi[0]->var.pixclock == fbi->var.pixclock ||
+			    ldb.fbi[0]->var.pixclock ==
+						2 * fbi->var.pixclock ||
+			    fbi->var.pixclock == 2 * ldb.fbi[0]->var.pixclock)
+				ldb.fbi[1] = fbi;
+			else
+				return 0;
 		} else
+			ldb.fbi[0] = fbi;
+
+		old_fs = get_fs();
+		set_fs(KERNEL_DS);
+		fbi->fbops->fb_ioctl(fbi, MXCFB_GET_DIFMT,
+				(unsigned long)&ipu_di_pix_fmt);
+		set_fs(old_fs);
+
+		if (!valid_mode(ipu_di_pix_fmt)) {
+			dev_err(g_ldb_dev, "Unsupport pixel format "
+					   "for ldb input\n");
+			return 0;
+		}
+
+		reg = __raw_readl(ldb.control_reg);
+		if (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT) {
+			if (ipu_di == 0)
+				__raw_writel((reg &
+					~LDB_DI0_VS_POL_MASK) |
+					LDB_DI0_VS_POL_ACT_HIGH,
+					ldb.control_reg);
+			else
+				__raw_writel((reg &
+					~LDB_DI1_VS_POL_MASK) |
+					LDB_DI1_VS_POL_ACT_HIGH,
+					ldb.control_reg);
+		} else {
+			if (ipu_di == 0)
+				__raw_writel((reg &
+					~LDB_DI0_VS_POL_MASK) |
+					LDB_DI0_VS_POL_ACT_LOW,
+					ldb.control_reg);
+			else
+				__raw_writel((reg &
+					~LDB_DI1_VS_POL_MASK) |
+					LDB_DI1_VS_POL_ACT_LOW,
+					ldb.control_reg);
+		}
+
+		switch (ldb.chan_mode_opt) {
+		case LDB_SIN_DI0:
+			reg = __raw_readl(ldb.control_reg);
+			if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+				__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
+					      LDB_DATA_WIDTH_CH0_24,
+					      ldb.control_reg);
+			else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+				__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
+					      LDB_DATA_WIDTH_CH0_18,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_JEIDA,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			__raw_writel((reg & ~LDB_CH0_MODE_MASK) |
+				      LDB_CH0_MODE_EN_TO_DI0, ldb.control_reg);
+			if (ldb.blank[0] == FB_BLANK_UNBLANK)
+				ldb.ch_working[0] = true;
+			break;
+		case LDB_SIN_DI1:
+			reg = __raw_readl(ldb.control_reg);
+			if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+				__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
+					      LDB_DATA_WIDTH_CH1_24,
+					      ldb.control_reg);
+			else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+				__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
+					      LDB_DATA_WIDTH_CH1_18,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_JEIDA,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			__raw_writel((reg & ~LDB_CH1_MODE_MASK) |
+				      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
+			if (ldb.blank[1] == FB_BLANK_UNBLANK)
+				ldb.ch_working[1] = true;
+			break;
+		case LDB_SEP:
+			reg = __raw_readl(ldb.control_reg);
+			if (ipu_di == 0) {
+				if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+					__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
+						      LDB_DATA_WIDTH_CH0_24,
+						      ldb.control_reg);
+				else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+					__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
+						      LDB_DATA_WIDTH_CH0_18,
+						      ldb.control_reg);
+			} else {
+				if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+					__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
+						      LDB_DATA_WIDTH_CH1_24,
+						      ldb.control_reg);
+				else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+					__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
+						      LDB_DATA_WIDTH_CH1_18,
+						      ldb.control_reg);
+			}
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_JEIDA,
+					      ldb.control_reg);
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_JEIDA,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
+					      LDB_CH1_MODE_MASK)) |
+				      LDB_CH0_MODE_EN_TO_DI0 |
+				      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
+			if (ldb.blank[0] == FB_BLANK_UNBLANK)
+				ldb.ch_working[0] = true;
+			if (ldb.blank[1] == FB_BLANK_UNBLANK)
+				ldb.ch_working[1] = true;
+			break;
+		case LDB_DUL_DI0:
+		case LDB_SPL_DI0:
+			reg = __raw_readl(ldb.control_reg);
+			if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+				__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
+						      LDB_DATA_WIDTH_CH1_MASK)) |
+					      LDB_DATA_WIDTH_CH0_24 |
+					      LDB_DATA_WIDTH_CH1_24,
+					      ldb.control_reg);
+			else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+				__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
+						      LDB_DATA_WIDTH_CH1_MASK)) |
+					      LDB_DATA_WIDTH_CH0_18 |
+					      LDB_DATA_WIDTH_CH1_18,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_JEIDA,
+					      ldb.control_reg);
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_JEIDA,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_mode_opt == LDB_SPL_DI0)
+				__raw_writel(reg | LDB_SPLIT_MODE_EN,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
+					      LDB_CH1_MODE_MASK)) |
+				      LDB_CH0_MODE_EN_TO_DI0 |
+				      LDB_CH1_MODE_EN_TO_DI0, ldb.control_reg);
+			if (ldb.blank[0] == FB_BLANK_UNBLANK) {
+				ldb.ch_working[0] = true;
+				ldb.ch_working[1] = true;
+			}
+			break;
+		case LDB_DUL_DI1:
+		case LDB_SPL_DI1:
+			reg = __raw_readl(ldb.control_reg);
+			if (bits_per_pixel(ipu_di_pix_fmt) == 24)
+				__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
+						      LDB_DATA_WIDTH_CH1_MASK)) |
+					      LDB_DATA_WIDTH_CH0_24 |
+					      LDB_DATA_WIDTH_CH1_24,
+					      ldb.control_reg);
+			else if (bits_per_pixel(ipu_di_pix_fmt) == 18)
+				__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
+						      LDB_DATA_WIDTH_CH1_MASK)) |
+					      LDB_DATA_WIDTH_CH0_18 |
+					      LDB_DATA_WIDTH_CH1_18,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
+					      LDB_BIT_MAP_CH0_JEIDA,
+					      ldb.control_reg);
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_SPWG,
+					      ldb.control_reg);
+			else
+				__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
+					      LDB_BIT_MAP_CH1_JEIDA,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			if (ldb.chan_mode_opt == LDB_SPL_DI1)
+				__raw_writel(reg | LDB_SPLIT_MODE_EN,
+					      ldb.control_reg);
+
+			reg = __raw_readl(ldb.control_reg);
+			__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
+					      LDB_CH1_MODE_MASK)) |
+				      LDB_CH0_MODE_EN_TO_DI1 |
+				      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
+			if (ldb.blank[1] == FB_BLANK_UNBLANK) {
+				ldb.ch_working[0] = true;
+				ldb.ch_working[1] = true;
+			}
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+	case FB_EVENT_BLANK: {
+		if (ldb.fbi[0] != fbi && ldb.fbi[1] != fbi)
+			return 0;
+
+		if (*((int *)event->data) == ldb.blank[ipu_di])
 			return 0;
 
 		if (*((int *)event->data) == FB_BLANK_UNBLANK)
 			ldb_enable(ipu_di);
 		else
 			ldb_disable(ipu_di);
+
+		ldb.blank[ipu_di] = *((int *)event->data);
 		break;
+	}
 	default:
 		break;
 	}
@@ -600,7 +1066,7 @@ static int mxc_ldb_ioctl(struct inode *inode, struct file *file,
 		spin_lock(&ldb_lock);
 
 		/* TODO:Set the correct pll4 rate for all situations */
-		pll4_clk = clk_get(NULL, "pll4");
+		pll4_clk = clk_get(g_ldb_dev, "pll4");
 		pll4_rate = clk_get_rate(pll4_clk);
 		pll4_rate = 455000000;
 		clk_set_rate(pll4_clk, pll4_rate);
@@ -612,7 +1078,7 @@ static int mxc_ldb_ioctl(struct inode *inode, struct file *file,
 			if (parm.di == 0) {
 				ldb.chan_mode_opt = LDB_SIN_DI0;
 
-				ldb.ldb_di_clk[0] = clk_get(NULL,
+				ldb.ldb_di_clk[0] = clk_get(g_ldb_dev,
 							    "ldb_di0_clk");
 				clk_set_rate(ldb.ldb_di_clk[0], pll4_rate/7);
 				clk_put(ldb.ldb_di_clk[0]);
@@ -623,7 +1089,7 @@ static int mxc_ldb_ioctl(struct inode *inode, struct file *file,
 			} else {
 				ldb.chan_mode_opt = LDB_SIN_DI1;
 
-				ldb.ldb_di_clk[1] = clk_get(NULL,
+				ldb.ldb_di_clk[1] = clk_get(g_ldb_dev,
 							    "ldb_di1_clk");
 				clk_set_rate(ldb.ldb_di_clk[1], pll4_rate/7);
 				clk_put(ldb.ldb_di_clk[1]);
@@ -636,10 +1102,10 @@ static int mxc_ldb_ioctl(struct inode *inode, struct file *file,
 		case LDB_CHAN_MODE_SEP:
 			ldb.chan_mode_opt = LDB_SEP;
 
-			ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
 			clk_set_rate(ldb.ldb_di_clk[0], pll4_rate/7);
 			clk_put(ldb.ldb_di_clk[0]);
-			ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
 			clk_set_rate(ldb.ldb_di_clk[1], pll4_rate/7);
 			clk_put(ldb.ldb_di_clk[1]);
 
@@ -651,8 +1117,8 @@ static int mxc_ldb_ioctl(struct inode *inode, struct file *file,
 			break;
 		case LDB_CHAN_MODE_DUL:
 		case LDB_CHAN_MODE_SPL:
-			ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-			ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
+			ldb.ldb_di_clk[0] = clk_get(g_ldb_dev, "ldb_di0_clk");
+			ldb.ldb_di_clk[1] = clk_get(g_ldb_dev, "ldb_di1_clk");
 			if (parm.di == 0) {
 				if (parm.channel_mode == LDB_CHAN_MODE_DUL) {
 					ldb.chan_mode_opt = LDB_DUL_DI0;
@@ -770,18 +1236,12 @@ static const struct file_operations mxc_ldb_fops = {
  */
 static int ldb_probe(struct platform_device *pdev)
 {
-	int ret = 0, i, ipu_di, ipu_di_pix_fmt[2];
-	bool primary = false, find_1080p = false;
+	int ret = 0;
 	struct resource *res;
 	struct ldb_platform_data *plat_data = pdev->dev.platform_data;
-	mm_segment_t old_fs;
-	struct clk *ldb_clk_parent;
-	unsigned long ldb_clk_prate = 455000000;
-	struct fb_var_screeninfo *var[2];
 	uint32_t reg;
 	struct device *temp;
 	int mxc_ldb_major;
-	const struct fb_videomode *mode;
 	struct class *mxc_ldb_class;
 
 	if (g_enable_ldb == false)
@@ -796,98 +1256,14 @@ static int ldb_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	memset(&ldb, 0, sizeof(struct ldb_data));
-	enabled[0] = enabled[1] = false;
-	var[0] = var[1] = NULL;
-	if (g_boot_cmd) {
-		ldb.chan_mode_opt = g_chan_mode_opt;
-		ldb.chan_bit_map[0] = g_chan_bit_map[0];
-		ldb.chan_bit_map[1] = g_chan_bit_map[1];
-	}
+	ldb.chan_mode_opt = g_chan_mode_opt;
+	ldb.chan_bit_map[0] = g_chan_bit_map[0];
+	ldb.chan_bit_map[1] = g_chan_bit_map[1];
 
 	ldb.base_addr = res->start;
 	ldb_reg = ioremap(ldb.base_addr, res->end - res->start + 1);
 	ldb.control_reg = ldb_reg + 2;
 
-	INIT_LIST_HEAD(&ldb.modelist);
-	for (i = 0; i < mxcfb_ldb_modedb_sz; i++)
-		fb_add_videomode(&mxcfb_ldb_modedb[i], &ldb.modelist);
-
-	for (i = 0; i < num_registered_fb; i++) {
-		if (registered_fb[i]->var.vmode == FB_VMODE_NONINTERLACED) {
-			mode = fb_match_mode(&registered_fb[i]->var,
-						&ldb.modelist);
-			if (mode) {
-				dev_dbg(g_ldb_dev, "fb mode found\n");
-				ldb.fbi[i] = registered_fb[i];
-				fb_videomode_to_var(&ldb.fbi[i]->var, mode);
-			} else if (i == 0 && ldb.chan_mode_opt != LDB_SEP) {
-				continue;
-			} else {
-				dev_warn(g_ldb_dev,
-						"can't find video mode\n");
-				goto err0;
-			}
-			/*
-			 * Default ldb mode:
-			 * 1080p: DI0 split, SPWG or DI1 split, SPWG
-			 * others: single, SPWG
-			 */
-			if (g_boot_cmd == false) {
-				if (fb_mode_is_equal(mode, &mxcfb_ldb_modedb[0])) {
-					if (strcmp(ldb.fbi[i]->fix.id,
-					    "DISP3 BG") == 0) {
-						ldb.chan_mode_opt = LDB_SPL_DI0;
-						dev_warn(g_ldb_dev,
-							"default di0 split mode\n");
-					} else if (strcmp(ldb.fbi[i]->fix.id,
-						   "DISP3 BG - DI1") == 0) {
-						ldb.chan_mode_opt = LDB_SPL_DI1;
-						dev_warn(g_ldb_dev,
-							"default di1 split mode\n");
-					}
-					ldb.chan_bit_map[0] = LDB_BIT_MAP_SPWG;
-					ldb.chan_bit_map[1] = LDB_BIT_MAP_SPWG;
-					find_1080p = true;
-				} else if (!find_1080p) {
-					if (strcmp(ldb.fbi[i]->fix.id,
-					    "DISP3 BG") == 0) {
-						ldb.chan_mode_opt = LDB_SIN_DI0;
-						ldb.chan_bit_map[0] = LDB_BIT_MAP_SPWG;
-						dev_warn(g_ldb_dev,
-							 "default di0 single mode\n");
-					} else if (strcmp(ldb.fbi[i]->fix.id,
-						   "DISP3 BG - DI1") == 0) {
-						ldb.chan_mode_opt = LDB_SIN_DI1;
-						ldb.chan_bit_map[1] = LDB_BIT_MAP_SPWG;
-						dev_warn(g_ldb_dev,
-							 "default di1 single mode\n");
-					}
-				}
-			}
-
-			acquire_console_sem();
-			fb_blank(ldb.fbi[i], FB_BLANK_POWERDOWN);
-			release_console_sem();
-
-			if (i == 0)
-				primary = true;
-
-			if (ldb.fbi[1] != NULL || ldb.chan_mode_opt != LDB_SEP)
-				break;
-		}
-	}
-
-	/*
-	 * We cannot support two LVDS panel with different pixel clock rates
-	 * except that one's pixel clock rate is two times of the others'.
-	 */
-	if (ldb.fbi[1] && ldb.fbi[0] != NULL) {
-		if (ldb.fbi[0]->var.pixclock != ldb.fbi[1]->var.pixclock &&
-		    ldb.fbi[0]->var.pixclock != 2 * ldb.fbi[1]->var.pixclock &&
-		    ldb.fbi[1]->var.pixclock != 2 * ldb.fbi[0]->var.pixclock)
-			return -EINVAL;
-	}
-
 	ldb.bgref_rmode = plat_data->ext_ref;
 	ldb.lvds_bg_reg = regulator_get(&pdev->dev, plat_data->lvds_bg_reg);
 	if (!IS_ERR(ldb.lvds_bg_reg)) {
@@ -895,82 +1271,6 @@ static int ldb_probe(struct platform_device *pdev)
 		regulator_enable(ldb.lvds_bg_reg);
 	}
 
-	for (i = 0; i < 2; i++) {
-		if (ldb.fbi[i] != NULL) {
-			if (strcmp(ldb.fbi[i]->fix.id, "DISP3 BG") == 0)
-				ipu_di = 0;
-			else if (strcmp(ldb.fbi[i]->fix.id, "DISP3 BG - DI1")
-				 == 0)
-				ipu_di = 1;
-			else {
-				dev_err(g_ldb_dev, "Wrong framebuffer\n");
-				goto err0;
-			}
-
-			var[ipu_di] = &ldb.fbi[i]->var;
-			if (ldb.fbi[i]->fbops->fb_ioctl) {
-				old_fs = get_fs();
-				set_fs(KERNEL_DS);
-				ldb.fbi[i]->fbops->fb_ioctl(ldb.fbi[i],
-						MXCFB_GET_DIFMT,
-						(unsigned long)&(ipu_di_pix_fmt[ipu_di]));
-				set_fs(old_fs);
-			} else {
-				dev_err(g_ldb_dev, "Can't get framebuffer "
-						   "information\n");
-				goto err0;
-			}
-
-			if (!valid_mode(ipu_di_pix_fmt[ipu_di])) {
-				dev_err(g_ldb_dev, "Unsupport pixel format "
-						   "for ldb input\n");
-				goto err0;
-			}
-
-			reg = __raw_readl(ldb.control_reg);
-			if (var[ipu_di]->sync & FB_SYNC_VERT_HIGH_ACT) {
-				if (ipu_di == 0)
-					__raw_writel((reg &
-						~LDB_DI0_VS_POL_MASK) |
-						LDB_DI0_VS_POL_ACT_HIGH,
-						ldb.control_reg);
-				else
-					__raw_writel((reg &
-						~LDB_DI1_VS_POL_MASK) |
-						LDB_DI1_VS_POL_ACT_HIGH,
-						ldb.control_reg);
-			} else {
-				if (ipu_di == 0)
-					__raw_writel((reg &
-						~LDB_DI0_VS_POL_MASK) |
-						LDB_DI0_VS_POL_ACT_LOW,
-						ldb.control_reg);
-				else
-					__raw_writel((reg &
-						~LDB_DI1_VS_POL_MASK) |
-						LDB_DI1_VS_POL_ACT_LOW,
-						ldb.control_reg);
-			}
-
-			/* TODO:Set the correct pll4 rate for all situations */
-			if (ipu_di == 1) {
-				ldb.ldb_di_clk[1] =
-					clk_get(&pdev->dev, "ldb_di1_clk");
-				ldb_clk_parent =
-					clk_get_parent(ldb.ldb_di_clk[1]);
-				clk_set_rate(ldb_clk_parent, ldb_clk_prate);
-				clk_put(ldb.ldb_di_clk[1]);
-			} else {
-				ldb.ldb_di_clk[0] =
-					clk_get(&pdev->dev, "ldb_di0_clk");
-				ldb_clk_parent =
-					clk_get_parent(ldb.ldb_di_clk[0]);
-				clk_set_rate(ldb_clk_parent, ldb_clk_prate);
-				clk_put(ldb.ldb_di_clk[0]);
-			}
-		}
-	}
-
 	reg = __raw_readl(ldb.control_reg);
 	if (ldb.bgref_rmode == LDB_EXT_REF)
 		__raw_writel((reg & ~LDB_BGREF_RMODE_MASK) |
@@ -979,276 +1279,6 @@ static int ldb_probe(struct platform_device *pdev)
 		__raw_writel((reg & ~LDB_BGREF_RMODE_MASK) |
 			      LDB_BGREF_RMODE_INT, ldb.control_reg);
 
-	switch (ldb.chan_mode_opt) {
-	case LDB_SIN_DI0:
-		if (var[0] == NULL) {
-			dev_err(g_ldb_dev, "Can't find framebuffer on DI0\n");
-			break;
-		}
-
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[0]) == 24)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
-				      LDB_DATA_WIDTH_CH0_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[0]) == 18)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
-				      LDB_DATA_WIDTH_CH0_18,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_JEIDA,
-				      ldb.control_reg);
-
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
-		clk_enable(ldb.ldb_di_clk[0]);
-		clk_put(ldb.ldb_di_clk[0]);
-
-		reg = __raw_readl(ldb.control_reg);
-		__raw_writel((reg & ~LDB_CH0_MODE_MASK) |
-			      LDB_CH0_MODE_EN_TO_DI0, ldb.control_reg);
-		ldb.ch_working[0] = true;
-		break;
-	case LDB_SIN_DI1:
-		if (var[1] == NULL) {
-			dev_err(g_ldb_dev, "Can't find framebuffer on DI1\n");
-			break;
-		}
-
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[1]) == 24)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
-				      LDB_DATA_WIDTH_CH1_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[1]) == 18)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
-				      LDB_DATA_WIDTH_CH1_18,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_JEIDA,
-				      ldb.control_reg);
-
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
-		clk_enable(ldb.ldb_di_clk[1]);
-		clk_put(ldb.ldb_di_clk[1]);
-
-		reg = __raw_readl(ldb.control_reg);
-		__raw_writel((reg & ~LDB_CH1_MODE_MASK) |
-			      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
-		ldb.ch_working[1] = true;
-		break;
-	case LDB_SEP:
-		if (var[0] == NULL || var[1] == NULL) {
-			dev_err(g_ldb_dev, "Can't find framebuffers on DI0/1\n");
-			break;
-		}
-
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[0]) == 24)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
-				      LDB_DATA_WIDTH_CH0_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[0]) == 18)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH0_MASK) |
-				      LDB_DATA_WIDTH_CH0_18,
-				      ldb.control_reg);
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[1]) == 24)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
-				      LDB_DATA_WIDTH_CH1_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[1]) == 18)
-			__raw_writel((reg & ~LDB_DATA_WIDTH_CH1_MASK) |
-				      LDB_DATA_WIDTH_CH1_18,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_JEIDA,
-				      ldb.control_reg);
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_JEIDA,
-				      ldb.control_reg);
-
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
-		clk_enable(ldb.ldb_di_clk[0]);
-		clk_put(ldb.ldb_di_clk[0]);
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
-		clk_enable(ldb.ldb_di_clk[1]);
-		clk_put(ldb.ldb_di_clk[1]);
-
-		reg = __raw_readl(ldb.control_reg);
-		__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
-				      LDB_CH1_MODE_MASK)) |
-			      LDB_CH0_MODE_EN_TO_DI0 |
-			      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
-		ldb.ch_working[0] = true;
-		ldb.ch_working[1] = true;
-		break;
-	case LDB_DUL_DI0:
-	case LDB_SPL_DI0:
-		if (var[0] == NULL) {
-			dev_err(g_ldb_dev, "Can't find framebuffer on DI0\n");
-			break;
-		}
-
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[0]) == 24)
-			__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
-					      LDB_DATA_WIDTH_CH1_MASK)) |
-				      LDB_DATA_WIDTH_CH0_24 |
-				      LDB_DATA_WIDTH_CH1_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[0]) == 18)
-			__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
-					      LDB_DATA_WIDTH_CH1_MASK)) |
-				      LDB_DATA_WIDTH_CH0_18 |
-				      LDB_DATA_WIDTH_CH1_18,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_JEIDA,
-				      ldb.control_reg);
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_JEIDA,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_mode_opt == LDB_SPL_DI0)
-			__raw_writel(reg | LDB_SPLIT_MODE_EN,
-				      ldb.control_reg);
-
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		if (ldb.chan_mode_opt == LDB_DUL_DI0) {
-			clk_set_rate(ldb.ldb_di_clk[0], ldb_clk_prate/7);
-		} else {
-			clk_set_rate(ldb.ldb_di_clk[0], 2*ldb_clk_prate/7);
-			clk_set_rate(ldb.ldb_di_clk[1], 2*ldb_clk_prate/7);
-		}
-		clk_enable(ldb.ldb_di_clk[0]);
-		clk_enable(ldb.ldb_di_clk[1]);
-		clk_put(ldb.ldb_di_clk[0]);
-		clk_put(ldb.ldb_di_clk[1]);
-
-		reg = __raw_readl(ldb.control_reg);
-		__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
-				      LDB_CH1_MODE_MASK)) |
-			      LDB_CH0_MODE_EN_TO_DI0 |
-			      LDB_CH1_MODE_EN_TO_DI0, ldb.control_reg);
-		ldb.ch_working[0] = true;
-		ldb.ch_working[1] = true;
-		break;
-	case LDB_DUL_DI1:
-	case LDB_SPL_DI1:
-		if (var[1] == NULL) {
-			dev_err(g_ldb_dev, "Can't find framebuffer on DI1\n");
-			break;
-		}
-
-		reg = __raw_readl(ldb.control_reg);
-		if (bits_per_pixel(ipu_di_pix_fmt[1]) == 24)
-			__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
-					      LDB_DATA_WIDTH_CH1_MASK)) |
-				      LDB_DATA_WIDTH_CH0_24 |
-				      LDB_DATA_WIDTH_CH1_24,
-				      ldb.control_reg);
-		else if (bits_per_pixel(ipu_di_pix_fmt[1]) == 18)
-			__raw_writel((reg & ~(LDB_DATA_WIDTH_CH0_MASK |
-					      LDB_DATA_WIDTH_CH1_MASK)) |
-				      LDB_DATA_WIDTH_CH0_18 |
-				      LDB_DATA_WIDTH_CH1_18,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[0] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH0_MASK) |
-				      LDB_BIT_MAP_CH0_JEIDA,
-				      ldb.control_reg);
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_bit_map[1] == LDB_BIT_MAP_SPWG)
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_SPWG,
-				      ldb.control_reg);
-		else
-			__raw_writel((reg & ~LDB_BIT_MAP_CH1_MASK) |
-				      LDB_BIT_MAP_CH1_JEIDA,
-				      ldb.control_reg);
-
-		reg = __raw_readl(ldb.control_reg);
-		if (ldb.chan_mode_opt == LDB_SPL_DI1)
-			__raw_writel(reg | LDB_SPLIT_MODE_EN,
-				      ldb.control_reg);
-
-		ldb.ldb_di_clk[0] = clk_get(NULL, "ldb_di0_clk");
-		ldb.ldb_di_clk[1] = clk_get(NULL, "ldb_di1_clk");
-		if (ldb.chan_mode_opt == LDB_DUL_DI1) {
-			clk_set_rate(ldb.ldb_di_clk[1], ldb_clk_prate/7);
-		} else {
-			clk_set_rate(ldb.ldb_di_clk[0], 2*ldb_clk_prate/7);
-			clk_set_rate(ldb.ldb_di_clk[1], 2*ldb_clk_prate/7);
-		}
-		clk_enable(ldb.ldb_di_clk[0]);
-		clk_enable(ldb.ldb_di_clk[1]);
-		clk_put(ldb.ldb_di_clk[0]);
-		clk_put(ldb.ldb_di_clk[1]);
-
-		reg = __raw_readl(ldb.control_reg);
-		__raw_writel((reg & ~(LDB_CH0_MODE_MASK |
-				      LDB_CH1_MODE_MASK)) |
-			      LDB_CH0_MODE_EN_TO_DI1 |
-			      LDB_CH1_MODE_EN_TO_DI1, ldb.control_reg);
-		ldb.ch_working[0] = true;
-		ldb.ch_working[1] = true;
-		break;
-	default:
-		break;
-	}
-
 	mxc_ldb_major = register_chrdev(0, "mxc_ldb", &mxc_ldb_fops);
 	if (mxc_ldb_major < 0) {
 		dev_err(g_ldb_dev, "Unable to register MXC LDB as a char "
@@ -1273,16 +1303,24 @@ static int ldb_probe(struct platform_device *pdev)
 		goto err2;
 	}
 
+	if (g_di0_used) {
+		mxcfb_register_mode(0, mxcfb_ldb_modedb,
+				mxcfb_ldb_modedb_sz,
+				MXC_DISP_SPEC_DEV);
+		mxcfb_register_presetup(0, ldb_fb_pre_setup);
+	}
+	if (g_di1_used) {
+		mxcfb_register_mode(1, mxcfb_ldb_modedb,
+				mxcfb_ldb_modedb_sz,
+				MXC_DISP_SPEC_DEV);
+		mxcfb_register_presetup(1, ldb_fb_pre_setup);
+	}
+
 	ret = fb_register_client(&nb);
 	if (ret < 0)
 		goto err2;
 
-	if (primary && ldb.fbi[0] != NULL) {
-		acquire_console_sem();
-		fb_blank(ldb.fbi[0], FB_BLANK_UNBLANK);
-		release_console_sem();
-		fb_show_logo(ldb.fbi[0], 0);
-	}
+	ldb.blank[0] = ldb.blank[1] = -1;
 
 	return ret;
 err2:
@@ -1302,7 +1340,7 @@ static int ldb_remove(struct platform_device *pdev)
 
 	for (i = 0; i < 2; i++) {
 		if (ldb.ch_working[i]) {
-			ldb.ldb_di_clk[i] = clk_get(NULL,
+			ldb.ldb_di_clk[i] = clk_get(g_ldb_dev,
 					    i ? "ldb_di1_clk" : "ldb_di0_clk");
 			clk_disable(ldb.ldb_di_clk[i]);
 			clk_put(ldb.ldb_di_clk[i]);
@@ -1320,16 +1358,20 @@ static int ldb_suspend(struct platform_device *pdev, pm_message_t state)
 	case LDB_SIN_DI0:
 	case LDB_DUL_DI0:
 	case LDB_SPL_DI0:
-		ldb_disable(0);
+		if (ldb.blank[0] != FB_BLANK_UNBLANK)
+			ldb_disable(0);
 		break;
 	case LDB_SIN_DI1:
 	case LDB_DUL_DI1:
 	case LDB_SPL_DI1:
-		ldb_disable(1);
+		if (ldb.blank[1] != FB_BLANK_UNBLANK)
+			ldb_disable(1);
 		break;
 	case LDB_SEP:
-		ldb_disable(0);
-		ldb_disable(1);
+		if (ldb.blank[0] != FB_BLANK_UNBLANK)
+			ldb_disable(0);
+		if (ldb.blank[1] != FB_BLANK_UNBLANK)
+			ldb_disable(1);
 		break;
 	default:
 		break;
@@ -1343,16 +1385,20 @@ static int ldb_resume(struct platform_device *pdev)
 	case LDB_SIN_DI0:
 	case LDB_DUL_DI0:
 	case LDB_SPL_DI0:
-		ldb_enable(0);
+		if (ldb.blank[0] == FB_BLANK_UNBLANK)
+			ldb_enable(0);
 		break;
 	case LDB_SIN_DI1:
 	case LDB_DUL_DI1:
 	case LDB_SPL_DI1:
-		ldb_enable(1);
+		if (ldb.blank[1] == FB_BLANK_UNBLANK)
+			ldb_enable(1);
 		break;
 	case LDB_SEP:
-		ldb_enable(0);
-		ldb_enable(1);
+		if (ldb.blank[0] == FB_BLANK_UNBLANK)
+			ldb_enable(0);
+		if (ldb.blank[1] == FB_BLANK_UNBLANK)
+			ldb_enable(1);
 		break;
 	default:
 		break;
@@ -1386,29 +1432,46 @@ static int __init ldb_setup(char *options)
 	else if (!strsep(&options, "="))
 		return 1;
 
+	if (!strncmp(options, "di0", 3))
+		g_di0_used = true;
+
+	if (!strncmp(options, "di1", 3))
+		g_di1_used = true;
+
 	if (!strncmp(options, "single", 6)) {
 		strsep(&options, ",");
-		if (!strncmp(options, "di=0", 4))
+		if (!strncmp(options, "di=0", 4)) {
 			g_chan_mode_opt = LDB_SIN_DI0;
-		else
+			g_di0_used = true;
+		} else {
 			g_chan_mode_opt = LDB_SIN_DI1;
+			g_di1_used = true;
+		}
 	} else if (!strncmp(options, "separate", 8)) {
 		g_chan_mode_opt = LDB_SEP;
+		g_di0_used = true;
+		g_di1_used = true;
 	} else if (!strncmp(options, "dual", 4)) {
 		strsep(&options, ",");
 		if (!strncmp(options, "di=", 3)) {
-			if (simple_strtoul(options + 3, NULL, 0) == 0)
+			if (simple_strtoul(options + 3, NULL, 0) == 0) {
 				g_chan_mode_opt = LDB_DUL_DI0;
-			else
+				g_di0_used = true;
+			} else {
 				g_chan_mode_opt = LDB_DUL_DI1;
+				g_di1_used = true;
+			}
 		}
 	} else if (!strncmp(options, "split", 5)) {
 		strsep(&options, ",");
 		if (!strncmp(options, "di=", 3)) {
-			if (simple_strtoul(options + 3, NULL, 0) == 0)
+			if (simple_strtoul(options + 3, NULL, 0) == 0) {
 				g_chan_mode_opt = LDB_SPL_DI0;
-			else
+				g_di0_used = true;
+			} else {
 				g_chan_mode_opt = LDB_SPL_DI1;
+				g_di1_used = true;
+			}
 		}
 	} else
 		return 1;
@@ -1431,8 +1494,6 @@ static int __init ldb_setup(char *options)
 			g_chan_bit_map[1] = LDB_BIT_MAP_JEIDA;
 	}
 
-	g_boot_cmd = true;
-
 	return 1;
 }
 __setup("ldb", ldb_setup);
-- 
1.5.4.4

