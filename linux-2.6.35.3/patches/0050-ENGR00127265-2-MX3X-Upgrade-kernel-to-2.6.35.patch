From b1c99e21b09adef75302e437e8cee35722d9b523 Mon Sep 17 00:00:00 2001
From: Jason Liu <r64343@freescale.com>
Date: Wed, 8 Sep 2010 10:53:26 +0800
Subject: [PATCH] ENGR00127265-2 MX3X: Upgrade kernel to 2.6.35

This patch contains changes to mach-mx3 files.
Contains all checkpatch and copyright fixes.

Signed-off-by: Jason Liu <r64343@freescale.com>
---
 arch/arm/mach-mx3/Kconfig                    |   60 ++
 arch/arm/mach-mx3/Makefile                   |   22 +-
 arch/arm/mach-mx3/clock-imx31.c              |  240 +++++-
 arch/arm/mach-mx3/clock-imx35.c              |   12 +-
 arch/arm/mach-mx3/cpu.c                      |   37 +
 arch/arm/mach-mx3/crm_regs.h                 |  162 ++++-
 arch/arm/mach-mx3/devices-imx31.h            |   39 +
 arch/arm/mach-mx3/devices-imx35.h            |   43 +
 arch/arm/mach-mx3/devices.c                  |  170 ++++-
 arch/arm/mach-mx3/devices.h                  |    4 +
 arch/arm/mach-mx3/dma.c                      | 1270 ++++++++++++++++++++++++++
 arch/arm/mach-mx3/dptc.c                     |  103 +++
 arch/arm/mach-mx3/dummy_gpio.c               |  119 +++
 arch/arm/mach-mx3/dvfs-imx35.c               |  609 ++++++++++++
 arch/arm/mach-mx3/entry-pm.S                 |  315 +++++++
 arch/arm/mach-mx3/iomux.h                    |  186 ++++
 arch/arm/mach-mx3/mach-mx31_3ds.c            |  270 +++----
 arch/arm/mach-mx3/mach-mx31ads.c             |   11 +-
 arch/arm/mach-mx3/mach-mx35_3ds.c            |  426 +++++++++
 arch/arm/mach-mx3/mach-mx35pdk.c             |  116 ---
 arch/arm/mach-mx3/mx31_sdma_script_code_v1.h |  581 ++++++++++++
 arch/arm/mach-mx3/mx31_sdma_script_code_v2.h |  371 ++++++++
 arch/arm/mach-mx3/mx35_3ds-irq.c             |  381 ++++++++
 arch/arm/mach-mx3/mx35_3ds_pesudo_irq.c      |  372 ++++++++
 arch/arm/mach-mx3/mx35_3ds_pmic_mc13892.c    |  392 ++++++++
 arch/arm/mach-mx3/mx35_3ds_pmic_mc9s08dz60.c |  105 +++
 arch/arm/mach-mx3/mx35_sdma_script_code_v1.h |  254 +++++
 arch/arm/mach-mx3/mx35_sdma_script_code_v2.h |  234 +++++
 arch/arm/mach-mx3/mx3_3ds_pmic_mc13783.c     |  273 ++++++
 arch/arm/mach-mx3/mx3x-dma.c                 |  195 ++++
 arch/arm/mach-mx3/pm.c                       |  179 ++++
 arch/arm/mach-mx3/system.c                   |  103 +++
 32 files changed, 7341 insertions(+), 313 deletions(-)

diff --git a/arch/arm/mach-mx3/Kconfig b/arch/arm/mach-mx3/Kconfig
index 344753f..6286cea 100644
--- a/arch/arm/mach-mx3/Kconfig
+++ b/arch/arm/mach-mx3/Kconfig
@@ -3,12 +3,28 @@ if ARCH_MX3
 config ARCH_MX31
 	select ARCH_HAS_RNGA
 	select ARCH_MXC_AUDMUX_V2
+	select ARM_ERRATA_364296
+	select ARM_ERRATA_411920
+	select CACHE_L2X0
+	select OUTER_CACHE
+	select USB_ARCH_HAS_EHCI
+	select ARCH_HAS_EVTMON
+	select ARCH_HAS_RNGA
+	select ISP1504_MXC
 	bool
 
 config ARCH_MX35
 	bool
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MXC_AUDMUX_V2
+	select ARM_ERRATA_364296
+	select ARM_ERRATA_411920
+	select CACHE_L2X0
+	select OUTER_CACHE
+	select USB_ARCH_HAS_EHCI
+	select ARCH_HAS_EVTMON
+	select ARCH_HAS_RNGA
+	select ISP1504_MXC
 
 comment "MX3 platforms:"
 
@@ -58,6 +74,7 @@ config MACH_MX31LITE
 config MACH_MX31_3DS
 	bool "Support MX31PDK (3DS)"
 	select ARCH_MX31
+	select MXC_DEBUG_BOARD
 	help
 	  Include support for MX31PDK (3DS) platform. This includes specific
 	  configurations for the board and its peripherals.
@@ -113,6 +130,11 @@ config MACH_ARMADILLO5X0
 config MACH_MX35_3DS
 	bool "Support MX35PDK platform"
 	select ARCH_MX35
+        select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_MMC
+        select MXC_ULPI if USB_ULPI
 	default n
 	help
 	  Include support for MX35PDK platform. This includes specific
@@ -125,4 +147,42 @@ config MACH_KZM_ARM11_01
 	  Include support for KZM-ARM11-01. This includes specific
 	  configurations for the board and its peripherals.
 
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+config SDMA_IRAM
+	bool "Use Internal RAM for SDMA transfer"
+	depends on MXC_SDMA_API
+	help
+	  Support Internal RAM as SDMA buffer or control structures
+
+
+config ARCH_MXC_HAS_NFC_V1
+        bool "MXC NFC Hardware Version 1"
+	depends on !(MACH_MX31ADS && XIP_KERNEL)
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 1
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V2
+        bool "MXC NFC Hardware Version 2"
+	depends on !(MACH_MX31ADS && XIP_KERNEL)
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V2_1
+        bool "MXC NFC Hardware Version 2.1"
+        depends on ARCH_MXC_HAS_NFC_V2
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2.1
+           If unsure, say N.
 endif
diff --git a/arch/arm/mach-mx3/Makefile b/arch/arm/mach-mx3/Makefile
index 5d650fd..589e821 100644
--- a/arch/arm/mach-mx3/Makefile
+++ b/arch/arm/mach-mx3/Makefile
@@ -5,10 +5,9 @@
 # Object file lists.
 
 obj-y				:= mm.o devices.o cpu.o
-CFLAGS_mm.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
-CFLAGS_devices.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
-CFLAGS_cpu.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
-obj-$(CONFIG_ARCH_MX31)		+= clock-imx31.o iomux-imx31.o
+obj-y				+= dma.o dummy_gpio.o mx3x-dma.o
+
+obj-$(CONFIG_ARCH_MX31)		+= clock-imx31.o iomux-imx31.o entry-pm.o
 obj-$(CONFIG_ARCH_MX35)		+= clock-imx35.o
 obj-$(CONFIG_MACH_MX31ADS)	+= mach-mx31ads.o
 obj-$(CONFIG_MACH_MX31LILLY)	+= mach-mx31lilly.o mx31lilly-db.o
@@ -16,11 +15,22 @@ obj-$(CONFIG_MACH_MX31LITE)	+= mach-mx31lite.o mx31lite-db.o
 obj-$(CONFIG_MACH_PCM037)	+= mach-pcm037.o
 obj-$(CONFIG_MACH_PCM037_EET)	+= mach-pcm037_eet.o
 obj-$(CONFIG_MACH_MX31_3DS)	+= mach-mx31_3ds.o
-CFLAGS_mach-mx31_3ds.o = -DIMX_NEEDS_DEPRECATED_SYMBOLS
 obj-$(CONFIG_MACH_MX31MOBOARD)	+= mach-mx31moboard.o mx31moboard-devboard.o \
 				   mx31moboard-marxbot.o mx31moboard-smartbot.o
 obj-$(CONFIG_MACH_QONG)		+= mach-qong.o
 obj-$(CONFIG_MACH_PCM043)	+= mach-pcm043.o
 obj-$(CONFIG_MACH_ARMADILLO5X0) += mach-armadillo5x0.o
-obj-$(CONFIG_MACH_MX35_3DS)	+= mach-mx35pdk.o
+obj-$(CONFIG_MACH_MX35_3DS)     += mach-mx35_3ds.o mx35_3ds_pmic_mc13892.o \
+				   mx35_3ds_pmic_mc9s08dz60.o mx35_3ds_pesudo_irq.o
 obj-$(CONFIG_MACH_KZM_ARM11_01)	+= mach-kzm_arm11_01.o
+
+
+CFLAGS_mm.o 			= -DIMX_NEEDS_DEPRECATED_SYMBOLS
+CFLAGS_devices.o 		= -DIMX_NEEDS_DEPRECATED_SYMBOLS
+CFLAGS_cpu.o 			= -DIMX_NEEDS_DEPRECATED_SYMBOLS
+CFLAGS_mach-mx31_3ds.o 		= -DIMX_NEEDS_DEPRECATED_SYMBOLS
+CFLAGS_mach-mx35_3ds.o 		= -DIMX_NEEDS_DEPRECATED_SYMBOLS
+
+# power management
+obj-$(CONFIG_PM) 		+= pm.o
+
diff --git a/arch/arm/mach-mx3/clock-imx31.c b/arch/arm/mach-mx3/clock-imx31.c
index 9a9eb6d..563b10c 100644
--- a/arch/arm/mach-mx3/clock-imx31.c
+++ b/arch/arm/mach-mx3/clock-imx31.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or
@@ -36,6 +36,11 @@
 
 #define PRE_DIV_MIN_FREQ    10000000 /* Minimum Frequency after Predivider */
 
+static int cpu_curr_wp;
+static struct cpu_wp *cpu_wp_tbl;
+static int cpu_wp_nr;
+static int cpu_clk_set_wp(int wp);
+
 static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
 {
 	u32 min_pre, temp_pre, old_err, err;
@@ -70,6 +75,8 @@ static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
 
 static struct clk mcu_pll_clk;
 static struct clk serial_pll_clk;
+static struct clk usb_pll_clk;
+static struct clk ahb_clk;
 static struct clk ipg_clk;
 static struct clk ckih_clk;
 
@@ -117,6 +124,73 @@ static unsigned long pll_ref_get_rate(void)
 		return clk_get_rate(&ckih_clk);
 }
 
+static int pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	signed long pd = 1;	/* Pre-divider */
+	signed long mfi;	/* Multiplication Factor (Integer part) */
+	signed long mfn;	/* Multiplication Factor (Integer part) */
+	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	signed long tmp;
+	u32 ref_freq = clk_get_rate(clk->parent);
+
+	while (((ref_freq / pd) * 10) > rate)
+		pd++;
+
+	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ)
+		return -EINVAL;
+
+	/* the ref_freq/2 in the following is to round up */
+	mfi = (((rate / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	if (mfi < 5 || mfi > 15)
+		return -EINVAL;
+
+	/* pick a mfd value that will work
+	 * then solve for mfn */
+	mfd = ref_freq / 50000;
+
+	/*
+	 *          pll_freq * pd * mfd
+	 *   mfn = --------------------  -  (mfi * mfd)
+	 *           2 * ref_freq
+	 */
+	/* the tmp/2 is for rounding */
+	tmp = ref_freq / 10000;
+	mfn =
+	    ((((((rate / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
+	    (mfi * mfd);
+
+	mfn = mfn & 0x3ff;
+	pd--;
+	mfd--;
+
+	/* Change the Pll value */
+	reg = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pd << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (clk == &mcu_pll_clk)
+		__raw_writel(reg, MXC_CCM_MPCTL);
+	else if (clk == &usb_pll_clk)
+		__raw_writel(reg, MXC_CCM_UPCTL);
+	else if (clk == &serial_pll_clk)
+		__raw_writel(reg, MXC_CCM_SRPCTL);
+
+	return 0;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 ahb_rate = clk_get_rate(&ahb_clk);
+	if ((rate < ahb_rate) || (rate % ahb_rate != 0)) {
+		printk(KERN_ERR "Wrong rate %lu in _clk_cpu_set_rate\n", rate);
+		return -EINVAL;
+	}
+
+	cpu_clk_set_wp(rate / ahb_rate - 1);
+
+	return 0;
+}
 static unsigned long usb_pll_get_rate(struct clk *clk)
 {
 	unsigned long reg;
@@ -209,6 +283,15 @@ static unsigned long mcu_main_get_rate(struct clk *clk)
 		return clk_get_rate(&mcu_pll_clk);
 }
 
+static unsigned long _clk_cpu_get_rate(struct clk *clk)
+{
+	unsigned long mcu_pdf;
+
+	mcu_pdf = PDR0(MXC_CCM_PDR0_MCU_PODF_MASK,
+		       MXC_CCM_PDR0_MCU_PODF_OFFSET);
+	return clk_get_rate(clk->parent) / (mcu_pdf + 1);
+}
+
 static unsigned long ahb_get_rate(struct clk *clk)
 {
 	unsigned long max_pdf;
@@ -414,6 +497,7 @@ static struct clk ckih_clk = {
 
 static struct clk mcu_pll_clk = {
 	.parent = &ckih_clk,
+	.set_rate = pll_set_rate,
 	.get_rate = mcu_pll_get_rate,
 };
 
@@ -424,6 +508,7 @@ static struct clk mcu_main_clk = {
 
 static struct clk serial_pll_clk = {
 	.parent = &ckih_clk,
+	.set_rate = pll_set_rate,
 	.get_rate = serial_pll_get_rate,
 	.enable = serial_pll_enable,
 	.disable = serial_pll_disable,
@@ -431,11 +516,18 @@ static struct clk serial_pll_clk = {
 
 static struct clk usb_pll_clk = {
 	.parent = &ckih_clk,
+	.set_rate = pll_set_rate,
 	.get_rate = usb_pll_get_rate,
 	.enable = usb_pll_enable,
 	.disable = usb_pll_disable,
 };
 
+static struct clk cpu_clk = {
+	.parent = &mcu_main_clk,
+	.get_rate = _clk_cpu_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+};
+
 static struct clk ahb_clk = {
 	.parent = &mcu_main_clk,
 	.get_rate = ahb_get_rate,
@@ -524,6 +616,7 @@ DEFINE_CLOCK(ipg_clk,     0, NULL,          0, ipg_get_rate, NULL, &ahb_clk);
 	},
 
 static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk)
 	_REGISTER_CLOCK(NULL, "emi", emi_clk)
 	_REGISTER_CLOCK("spi_imx.0", NULL, cspi1_clk)
 	_REGISTER_CLOCK("spi_imx.1", NULL, cspi2_clk)
@@ -588,23 +681,6 @@ int __init mx31_clocks_init(unsigned long fref)
 		if (clk_set_parent(&csi_clk, &usb_pll_clk))
 			pr_err("%s: error changing csi_clk parent\n", __func__);
 
-
-	/* Turn off all possible clocks */
-	__raw_writel((3 << 4), MXC_CCM_CGR0);
-	__raw_writel(0, MXC_CCM_CGR1);
-	__raw_writel((3 << 8) | (3 << 14) | (3 << 16)|
-		     1 << 27 | 1 << 28, /* Bit 27 and 28 are not defined for
-					   MX32, but still required to be set */
-		     MXC_CCM_CGR2);
-
-	/*
-	 * Before turning off usb_pll make sure ipg_per_clk is generated
-	 * by ipg_clk and not usb_pll.
-	 */
-	__raw_writel(__raw_readl(MXC_CCM_CCMR) | (1 << 24), MXC_CCM_CCMR);
-
-	usb_pll_disable(&usb_pll_clk);
-
 	pr_info("Clock input source is %ld\n", clk_get_rate(&ckih_clk));
 
 	clk_enable(&gpt_clk);
@@ -622,9 +698,137 @@ int __init mx31_clocks_init(unsigned long fref)
 		__raw_writel(reg, MXC_CCM_PMCR1);
 	}
 
+	cpu_curr_wp = clk_get_rate(&cpu_clk) / clk_get_rate(&ahb_clk) - 1;
+	cpu_wp_tbl = get_cpu_wp(&cpu_wp_nr);
+
+	/* Init serial PLL according */
+	clk_set_rate(&serial_pll_clk, (cpu_wp_tbl[2].pll_rate));
+
 	mxc_timer_init(&ipg_clk, MX31_IO_ADDRESS(MX31_GPT1_BASE_ADDR),
 			MX31_INT_GPT);
 
 	return 0;
 }
 
+#define MXC_PMCR0_DVFS_MASK	(MXC_CCM_PMCR0_DVSUP_MASK | \
+				 MXC_CCM_PMCR0_UDSC_MASK | \
+				MXC_CCM_PMCR0_VSCNT_MASK | \
+				 MXC_CCM_PMCR0_DPVCR)
+
+#define MXC_PDR0_MAX_MCU_MASK	(MXC_CCM_PDR0_MAX_PODF_MASK | \
+				 MXC_CCM_PDR0_MCU_PODF_MASK | \
+				 MXC_CCM_PDR0_HSP_PODF_MASK | \
+				 MXC_CCM_PDR0_IPG_PODF_MASK | \
+				 MXC_CCM_PDR0_NFC_PODF_MASK)
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point (0 is the slowest)
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_wp *p;
+	u32 dvsup;
+	u32 pmcr0, pmcr1;
+	u32 pdr0;
+	u32 cgr2 = 0x80000000;
+	u32 vscnt = MXC_CCM_PMCR0_VSCNT_2;
+	u32 udsc = MXC_CCM_PMCR0_UDSC_DOWN;
+	void __iomem *ipu_base = MX31_IO_ADDRESS(MX31_IPU_CTRL_BASE_ADDR);
+	u32 ipu_conf;
+
+	if (wp >= cpu_wp_nr || wp < 0) {
+		printk(KERN_ERR "Wrong wp: %d for cpu_clk_set_wp\n", wp);
+		return -EINVAL;
+	}
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	pmcr1 = __raw_readl(MXC_CCM_PMCR1);
+	pdr0 = __raw_readl(MXC_CCM_PDR0);
+
+	if (!(pmcr0 & MXC_CCM_PMCR0_UPDTEN))
+		return -EBUSY;
+
+	if (wp > cpu_curr_wp) {
+		/* going faster */
+		if (wp == (cpu_wp_nr - 1)) {
+			/* Only update vscnt going into Turbo */
+			vscnt = MXC_CCM_PMCR0_VSCNT_8;
+		}
+		udsc = MXC_CCM_PMCR0_UDSC_UP;
+	}
+
+	p = &cpu_wp_tbl[wp];
+
+	dvsup = (cpu_wp_nr - 1 - wp) << MXC_CCM_PMCR0_DVSUP_OFFSET;
+
+	if ((clk_get_rate(&mcu_main_clk) == 399000000) &&
+				(p->cpu_rate == 532000000)) {
+		cgr2 = __raw_readl(MXC_CCM_CGR2);
+		cgr2 &= 0x7fffffff;
+		vscnt = 0;
+		pmcr0 = (pmcr0 & ~MXC_PMCR0_DVFS_MASK) | dvsup | vscnt;
+		pr_debug("manul dvfs, dvsup = %x\n", dvsup);
+		__raw_writel(cgr2, MXC_CCM_CGR2);
+		__raw_writel(pmcr0, MXC_CCM_PMCR0);
+		udelay(100);
+	}
+
+	if (clk_get_rate(&mcu_main_clk) == p->pll_rate) {
+		/* No pll switching and relocking needed */
+		pmcr0 |= MXC_CCM_PMCR0_DFSUP0_PDR;
+	} else {
+		/* pll switching and relocking needed */
+		pmcr0 ^= MXC_CCM_PMCR0_DFSUP1;	/* flip MSB bit */
+		pmcr0 &= ~(MXC_CCM_PMCR0_DFSUP0);
+	}
+
+	pmcr0 = (pmcr0 & ~MXC_PMCR0_DVFS_MASK) | dvsup | vscnt | udsc;
+	/* also enable DVFS hardware */
+	pmcr0 |= MXC_CCM_PMCR0_DVFEN;
+
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+	/* IPU and DI submodule must be on for PDR0 update to take effect */
+	if (!clk_get_usecount(&ipu_clk))
+		ipu_clk.enable(&ipu_clk);
+	ipu_conf = __raw_readl(ipu_base);
+	if (!(ipu_conf & 0x40))
+		__raw_writel(ipu_conf | 0x40, ipu_base);
+
+	__raw_writel((pdr0 & ~MXC_PDR0_MAX_MCU_MASK) | p->pdr0_reg,
+		     MXC_CCM_PDR0);
+
+	if ((pmcr0 & MXC_CCM_PMCR0_DFSUP0) == MXC_CCM_PMCR0_DFSUP0_PLL) {
+		/* prevent pll restart */
+		pmcr1 |= 0x80;
+		__raw_writel(pmcr1, MXC_CCM_PMCR1);
+		/* PLL and post divider update */
+		if ((pmcr0 & MXC_CCM_PMCR0_DFSUP1) ==
+					MXC_CCM_PMCR0_DFSUP1_SPLL) {
+			__raw_writel(p->pll_reg, MXC_CCM_SRPCTL);
+			mcu_main_clk.parent = &serial_pll_clk;
+		} else {
+			__raw_writel(p->pll_reg, MXC_CCM_MPCTL);
+			mcu_main_clk.parent = &mcu_pll_clk;
+		}
+	}
+
+	if ((cgr2 & 0x80000000) == 0x0) {
+		pr_debug("start auto dvfs\n");
+		cgr2 |= 0x80000000;
+		__raw_writel(cgr2, MXC_CCM_CGR2);
+	}
+
+	cpu_curr_wp = wp;
+
+	/* Restore IPU_CONF setting */
+	__raw_writel(ipu_conf, ipu_base);
+	if (!clk_get_usecount(&ipu_clk))
+		ipu_clk.disable(&ipu_clk);
+
+	return 0;
+}
diff --git a/arch/arm/mach-mx3/clock-imx35.c b/arch/arm/mach-mx3/clock-imx35.c
index 9f3e943..9d0dc0c 100644
--- a/arch/arm/mach-mx3/clock-imx35.c
+++ b/arch/arm/mach-mx3/clock-imx35.c
@@ -370,7 +370,8 @@ DEFINE_CLOCK(rngc_clk,   0, CCM_CGR1, 30, get_rate_ipg, NULL);
 DEFINE_CLOCK(rtc_clk,    0, CCM_CGR2,  0, get_rate_ipg, NULL);
 DEFINE_CLOCK(rtic_clk,   0, CCM_CGR2,  2, get_rate_ahb, NULL);
 DEFINE_CLOCK(scc_clk,    0, CCM_CGR2,  4, get_rate_ipg, NULL);
-DEFINE_CLOCK(sdma_clk,   0, CCM_CGR2,  6, NULL, NULL);
+DEFINE_CLOCK(sdma_a_clk, 0, CCM_CGR2,  6, get_rate_ahb, NULL);
+DEFINE_CLOCK(sdma_p_clk, 0, CCM_CGR2,  6, get_rate_ipg, NULL);
 DEFINE_CLOCK(spba_clk,   0, CCM_CGR2,  8, get_rate_ipg, NULL);
 DEFINE_CLOCK(spdif_clk,  0, CCM_CGR2, 10, NULL, NULL);
 DEFINE_CLOCK(ssi1_clk,   0, CCM_CGR2, 12, get_rate_ssi, NULL);
@@ -438,9 +439,9 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "epit", epit1_clk)
 	_REGISTER_CLOCK(NULL, "epit", epit2_clk)
 	_REGISTER_CLOCK(NULL, "esai", esai_clk)
-	_REGISTER_CLOCK(NULL, "sdhc", esdhc1_clk)
-	_REGISTER_CLOCK(NULL, "sdhc", esdhc2_clk)
-	_REGISTER_CLOCK(NULL, "sdhc", esdhc3_clk)
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk)
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk)
+	_REGISTER_CLOCK("mxsdhci.2", NULL, esdhc3_clk)
 	_REGISTER_CLOCK("fec.0", NULL, fec_clk)
 	_REGISTER_CLOCK(NULL, "gpio", gpio1_clk)
 	_REGISTER_CLOCK(NULL, "gpio", gpio2_clk)
@@ -461,7 +462,8 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "rtc", rtc_clk)
 	_REGISTER_CLOCK(NULL, "rtic", rtic_clk)
 	_REGISTER_CLOCK(NULL, "scc", scc_clk)
-	_REGISTER_CLOCK(NULL, "sdma", sdma_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ahb_clk", sdma_a_clk)
+	_REGISTER_CLOCK(NULL, "sdma_ipg_clk", sdma_p_clk)
 	_REGISTER_CLOCK(NULL, "spba", spba_clk)
 	_REGISTER_CLOCK(NULL, "spdif", spdif_clk)
 	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk)
diff --git a/arch/arm/mach-mx3/cpu.c b/arch/arm/mach-mx3/cpu.c
index 861afe0..78d4854 100644
--- a/arch/arm/mach-mx3/cpu.c
+++ b/arch/arm/mach-mx3/cpu.c
@@ -11,6 +11,7 @@
 
 #include <linux/module.h>
 #include <linux/io.h>
+#include <linux/iram_alloc.h>
 #include <mach/hardware.h>
 #include <mach/iim.h>
 
@@ -55,3 +56,39 @@ void __init mx31_read_cpu_rev(void)
 
 	printk(KERN_WARNING "Unknown CPU identifier. srev = %02x\n", srev);
 }
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	volatile unsigned long aips_reg;
+
+	iram_init(MX31_IRAM_BASE_ADDR, MX31_IRAM_SIZE);
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx3/crm_regs.h b/arch/arm/mach-mx3/crm_regs.h
index 37a8a07..58d17a1 100644
--- a/arch/arm/mach-mx3/crm_regs.h
+++ b/arch/arm/mach-mx3/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2010 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 by Sascha Hauer <kernel@pengutronix.de>
  *
  * This program is free software; you can redistribute it and/or
@@ -55,6 +55,9 @@
 #define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
 
 /* Register bit definitions */
+#define MX35_CCM_CCMR_WFI                       (1 << 30)
+#define MX35_CCM_CCMR_STBY_EXIT_SRC             (1 << 29)
+#define MXC_CCM_CCMR_VSTBY                      (1 << 28)
 #define MXC_CCM_CCMR_WBEN                       (1 << 27)
 #define MXC_CCM_CCMR_CSCS                       (1 << 25)
 #define MXC_CCM_CCMR_PERCS                      (1 << 24)
@@ -66,6 +69,7 @@
 #define MXC_CCM_CCMR_LPM_MASK                   (0x3 << 14)
 #define MXC_CCM_CCMR_FIRS_OFFSET                11
 #define MXC_CCM_CCMR_FIRS_MASK                  (0x3 << 11)
+#define MXC_CCM_CCMR_WAMO                       (1 << 10)
 #define MXC_CCM_CCMR_UPE                        (1 << 9)
 #define MXC_CCM_CCMR_SPE                        (1 << 8)
 #define MXC_CCM_CCMR_MDS                        (1 << 7)
@@ -91,6 +95,47 @@
 #define MXC_CCM_PDR0_MCU_PODF_OFFSET            0
 #define MXC_CCM_PDR0_MCU_PODF_MASK              0x7
 
+#define MXC_CCM_PDR0_HSP_DIV_1                  (0x0 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_2                  (0x1 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_3                  (0x2 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_4                  (0x3 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_5                  (0x4 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_6                  (0x5 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_7                  (0x6 << 11)
+#define MXC_CCM_PDR0_HSP_DIV_8                  (0x7 << 11)
+
+#define MXC_CCM_PDR0_IPG_DIV_1                  (0x0 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_2                  (0x1 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_3                  (0x2 << 6)
+#define MXC_CCM_PDR0_IPG_DIV_4                  (0x3 << 6)
+
+#define MXC_CCM_PDR0_MAX_DIV_1                  (0x0 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_2                  (0x1 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_3                  (0x2 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_4                  (0x3 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_5                  (0x4 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_6                  (0x5 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_7                  (0x6 << 3)
+#define MXC_CCM_PDR0_MAX_DIV_8                  (0x7 << 3)
+
+#define MXC_CCM_PDR0_NFC_DIV_1                  (0x0 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_2                  (0x1 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_3                  (0x2 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_4                  (0x3 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_5                  (0x4 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_6                  (0x5 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_7                  (0x6 << 8)
+#define MXC_CCM_PDR0_NFC_DIV_8                  (0x7 << 8)
+
+#define MXC_CCM_PDR0_MCU_DIV_1                  0x0
+#define MXC_CCM_PDR0_MCU_DIV_2                  0x1
+#define MXC_CCM_PDR0_MCU_DIV_3                  0x2
+#define MXC_CCM_PDR0_MCU_DIV_4                  0x3
+#define MXC_CCM_PDR0_MCU_DIV_5                  0x4
+#define MXC_CCM_PDR0_MCU_DIV_6                  0x5
+#define MXC_CCM_PDR0_MCU_DIV_7                  0x6
+#define MXC_CCM_PDR0_MCU_DIV_8                  0x7
+
 #define MXC_CCM_PDR1_USB_PRDF_OFFSET            30
 #define MXC_CCM_PDR1_USB_PRDF_MASK              (0x3 << 30)
 #define MXC_CCM_PDR1_USB_PODF_OFFSET            27
@@ -109,7 +154,120 @@
 #define MXC_CCM_PDR1_SSI1_PODF_MASK             0x3F
 
 /* Bit definitions for RCSR */
-#define MXC_CCM_RCSR_NF16B			0x80000000
+#define MXC_CCM_RCSR_NF16B			(0x1 << 31)
+#define MXC_CCM_RCSR_NFMS 			(0x1 << 30)
+
+/* Bit definitions for both MCU, USB and SR PLL control registers */
+#define MXC_CCM_PCTL_BRM                        0x80000000
+#define MXC_CCM_PCTL_PD_OFFSET                  26
+#define MXC_CCM_PCTL_PD_MASK                    (0xF << 26)
+#define MXC_CCM_PCTL_MFD_OFFSET                 16
+#define MXC_CCM_PCTL_MFD_MASK                   (0x3FF << 16)
+#define MXC_CCM_PCTL_MFI_OFFSET                 10
+#define MXC_CCM_PCTL_MFI_MASK                   (0xF << 10)
+#define MXC_CCM_PCTL_MFN_OFFSET                 0
+#define MXC_CCM_PCTL_MFN_MASK                   0x3FF
+
+#define MXC_CCM_CGR0_SD_MMC1_OFFSET             0
+#define MXC_CCM_CGR0_SD_MMC1_MASK               (0x3 << 0)
+#define MXC_CCM_CGR0_SD_MMC2_OFFSET             2
+#define MXC_CCM_CGR0_SD_MMC2_MASK               (0x3 << 2)
+#define MXC_CCM_CGR0_GPT_OFFSET                 4
+#define MXC_CCM_CGR0_GPT_MASK                   (0x3 << 4)
+#define MXC_CCM_CGR0_EPIT1_OFFSET               6
+#define MXC_CCM_CGR0_EPIT1_MASK                 (0x3 << 6)
+#define MXC_CCM_CGR0_EPIT2_OFFSET               8
+#define MXC_CCM_CGR0_EPIT2_MASK                 (0x3 << 8)
+#define MXC_CCM_CGR0_IIM_OFFSET                 10
+#define MXC_CCM_CGR0_IIM_MASK                   (0x3 << 10)
+#define MXC_CCM_CGR0_ATA_OFFSET                 12
+#define MXC_CCM_CGR0_ATA_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR0_SDMA_OFFSET                14
+#define MXC_CCM_CGR0_SDMA_MASK                  (0x3 << 14)
+#define MXC_CCM_CGR0_CSPI3_OFFSET               16
+#define MXC_CCM_CGR0_CSPI3_MASK                 (0x3 << 16)
+#define MXC_CCM_CGR0_RNG_OFFSET                 18
+#define MXC_CCM_CGR0_RNG_MASK                   (0x3 << 18)
+#define MXC_CCM_CGR0_UART1_OFFSET               20
+#define MXC_CCM_CGR0_UART1_MASK                 (0x3 << 20)
+#define MXC_CCM_CGR0_UART2_OFFSET               22
+#define MXC_CCM_CGR0_UART2_MASK                 (0x3 << 22)
+#define MXC_CCM_CGR0_SSI1_OFFSET                24
+#define MXC_CCM_CGR0_SSI1_MASK                  (0x3 << 24)
+#define MXC_CCM_CGR0_I2C1_OFFSET                26
+#define MXC_CCM_CGR0_I2C1_MASK                  (0x3 << 26)
+#define MXC_CCM_CGR0_I2C2_OFFSET                28
+#define MXC_CCM_CGR0_I2C2_MASK                  (0x3 << 28)
+#define MXC_CCM_CGR0_I2C3_OFFSET                30
+#define MXC_CCM_CGR0_I2C3_MASK                  (0x3 << 30)
+
+#define MXC_CCM_CGR1_HANTRO_OFFSET              0
+#define MXC_CCM_CGR1_HANTRO_MASK                (0x3 << 0)
+#define MXC_CCM_CGR1_MEMSTICK1_OFFSET           2
+#define MXC_CCM_CGR1_MEMSTICK1_MASK             (0x3 << 2)
+#define MXC_CCM_CGR1_MEMSTICK2_OFFSET           4
+#define MXC_CCM_CGR1_MEMSTICK2_MASK             (0x3 << 4)
+#define MXC_CCM_CGR1_CSI_OFFSET                 6
+#define MXC_CCM_CGR1_CSI_MASK                   (0x3 << 6)
+#define MXC_CCM_CGR1_RTC_OFFSET                 8
+#define MXC_CCM_CGR1_RTC_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR1_WDOG_OFFSET                10
+#define MXC_CCM_CGR1_WDOG_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR1_PWM_OFFSET                 12
+#define MXC_CCM_CGR1_PWM_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR1_SIM_OFFSET                 14
+#define MXC_CCM_CGR1_SIM_MASK                   (0x3 << 14)
+#define MXC_CCM_CGR1_ECT_OFFSET                 16
+#define MXC_CCM_CGR1_ECT_MASK                   (0x3 << 16)
+#define MXC_CCM_CGR1_USBOTG_OFFSET              18
+#define MXC_CCM_CGR1_USBOTG_MASK                (0x3 << 18)
+#define MXC_CCM_CGR1_KPP_OFFSET                 20
+#define MXC_CCM_CGR1_KPP_MASK                   (0x3 << 20)
+#define MXC_CCM_CGR1_IPU_OFFSET                 22
+#define MXC_CCM_CGR1_IPU_MASK                   (0x3 << 22)
+#define MXC_CCM_CGR1_UART3_OFFSET               24
+#define MXC_CCM_CGR1_UART3_MASK                 (0x3 << 24)
+#define MXC_CCM_CGR1_UART4_OFFSET               26
+#define MXC_CCM_CGR1_UART4_MASK                 (0x3 << 26)
+#define MXC_CCM_CGR1_UART5_OFFSET               28
+#define MXC_CCM_CGR1_UART5_MASK                 (0x3 << 28)
+#define MXC_CCM_CGR1_OWIRE_OFFSET               30
+#define MXC_CCM_CGR1_OWIRE_MASK                 (0x3 << 30)
+
+#define MXC_CCM_CGR2_SSI2_OFFSET                0
+#define MXC_CCM_CGR2_SSI2_MASK                  (0x3 << 0)
+#define MXC_CCM_CGR2_CSPI1_OFFSET               2
+#define MXC_CCM_CGR2_CSPI1_MASK                 (0x3 << 2)
+#define MXC_CCM_CGR2_CSPI2_OFFSET               4
+#define MXC_CCM_CGR2_CSPI2_MASK                 (0x3 << 4)
+#define MXC_CCM_CGR2_GACC_OFFSET                6
+#define MXC_CCM_CGR2_GACC_MASK                  (0x3 << 6)
+#define MXC_CCM_CGR2_EMI_OFFSET                 8
+#define MXC_CCM_CGR2_EMI_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR2_RTIC_OFFSET                10
+#define MXC_CCM_CGR2_RTIC_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR2_FIRI_OFFSET                12
+#define MXC_CCM_CGR2_FIRI_MASK                  (0x3 << 12)
+#define MXC_CCM_CGR2_IPMUX1_OFFSET              14
+#define MXC_CCM_CGR2_IPMUX1_MASK                (0x3 << 14)
+#define MXC_CCM_CGR2_IPMUX2_OFFSET              16
+#define MXC_CCM_CGR2_IPMUX2_MASK                (0x3 << 16)
+
+/* These new CGR2 bits are added in MX32 */
+#define MXC_CCM_CGR2_APMSYSCLKSEL_OFFSET	18
+#define MXC_CCM_CGR2_APMSYSCLKSEL_MASK		(0x3 << 18)
+#define MXC_CCM_CGR2_APMSSICLKSEL_OFFSET	20
+#define MXC_CCM_CGR2_APMSSICLKSEL_MASK		(0x3 << 20)
+#define MXC_CCM_CGR2_APMPERCLKSEL_OFFSET	22
+#define MXC_CCM_CGR2_APMPERCLKSEL_MASK		(0x3 << 22)
+#define MXC_CCM_CGR2_MXCCLKENSEL_OFFSET		24
+#define MXC_CCM_CGR2_MXCCLKENSEL_MASK		(0x1 << 24)
+#define MXC_CCM_CGR2_CHIKCAMPEN_OFFSET		25
+#define MXC_CCM_CGR2_CHIKCAMPEN_MASK		(0x1 << 25)
+#define MXC_CCM_CGR2_OVRVPUBUSY_OFFSET		26
+#define MXC_CCM_CGR2_OVRVPUBUSY_MASK		(0x1 << 26)
+#define MXC_CCM_CGR2_APMENA_OFFSET		30
+#define MXC_CCM_CGR2_AOMENA_MASK		(0x1 << 30)
 
 /*
  * LTR0 register offsets
diff --git a/arch/arm/mach-mx3/devices-imx31.h b/arch/arm/mach-mx3/devices-imx31.h
new file mode 100644
index 0000000..3a03cf4
--- /dev/null
+++ b/arch/arm/mach-mx3/devices-imx31.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2010 Pengutronix
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/mx31.h>
+#include <mach/devices-common.h>
+
+#define imx31_add_imx_i2c0(pdata)	\
+	imx_add_imx_i2c(0, MX31_I2C1_BASE_ADDR, SZ_4K, MX31_INT_I2C1, pdata)
+#define imx31_add_imx_i2c1(pdata)	\
+	imx_add_imx_i2c(1, MX31_I2C2_BASE_ADDR, SZ_4K, MX31_INT_I2C2, pdata)
+#define imx31_add_imx_i2c2(pdata)	\
+	imx_add_imx_i2c(2, MX31_I2C3_BASE_ADDR, SZ_4K, MX31_INT_I2C3, pdata)
+
+#define imx31_add_imx_uart0(pdata)	\
+	imx_add_imx_uart_1irq(0, MX31_UART1_BASE_ADDR, SZ_16K, MX31_INT_UART1, pdata)
+#define imx31_add_imx_uart1(pdata)	\
+	imx_add_imx_uart_1irq(1, MX31_UART2_BASE_ADDR, SZ_16K, MX31_INT_UART2, pdata)
+#define imx31_add_imx_uart2(pdata)	\
+	imx_add_imx_uart_1irq(2, MX31_UART3_BASE_ADDR, SZ_16K, MX31_INT_UART3, pdata)
+#define imx31_add_imx_uart3(pdata)	\
+	imx_add_imx_uart_1irq(3, MX31_UART4_BASE_ADDR, SZ_16K, MX31_INT_UART4, pdata)
+#define imx31_add_imx_uart4(pdata)	\
+	imx_add_imx_uart_1irq(4, MX31_UART5_BASE_ADDR, SZ_16K, MX31_INT_UART5, pdata)
+
+#define imx31_add_mxc_nand(pdata)	\
+	imx_add_mxc_nand_v1(MX31_NFC_BASE_ADDR, MX31_INT_NANDFC, pdata)
+
+#define imx31_add_spi_imx0(pdata)	\
+	imx_add_spi_imx(0, MX31_CSPI1_BASE_ADDR, SZ_4K, MX31_INT_CSPI1, pdata)
+#define imx31_add_spi_imx1(pdata)	\
+	imx_add_spi_imx(1, MX31_CSPI2_BASE_ADDR, SZ_4K, MX31_INT_CSPI2, pdata)
+#define imx31_add_spi_imx2(pdata)	\
+	imx_add_spi_imx(2, MX31_CSPI3_BASE_ADDR, SZ_4K, MX31_INT_CSPI3, pdata)
diff --git a/arch/arm/mach-mx3/devices-imx35.h b/arch/arm/mach-mx3/devices-imx35.h
new file mode 100755
index 0000000..1c3de00
--- /dev/null
+++ b/arch/arm/mach-mx3/devices-imx35.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2010 Pengutronix
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/mx35.h>
+#include <mach/devices-common.h>
+
+#define imx35_add_flexcan0(pdata)	\
+	imx_add_flexcan(0, MX35_CAN1_BASE_ADDR, SZ_16K, MX35_INT_CAN1, pdata)
+#define imx35_add_flexcan1(pdata)	\
+	imx_add_flexcan(1, MX35_CAN2_BASE_ADDR, SZ_16K, MX35_INT_CAN2, pdata)
+
+#define imx35_add_imx_i2c0(pdata)	\
+	imx_add_imx_i2c(0, MX35_I2C1_BASE_ADDR, SZ_4K, MX35_INT_I2C1, pdata)
+#define imx35_add_imx_i2c1(pdata)	\
+	imx_add_imx_i2c(1, MX35_I2C2_BASE_ADDR, SZ_4K, MX35_INT_I2C2, pdata)
+#define imx35_add_imx_i2c2(pdata)	\
+	imx_add_imx_i2c(2, MX35_I2C3_BASE_ADDR, SZ_4K, MX35_INT_I2C3, pdata)
+
+#define imx35_add_imx_uart0(pdata)	\
+	imx_add_imx_uart_1irq(0, MX35_UART1_BASE_ADDR, SZ_16K, MX35_INT_UART1, pdata)
+#define imx35_add_imx_uart1(pdata)	\
+	imx_add_imx_uart_1irq(1, MX35_UART2_BASE_ADDR, SZ_16K, MX35_INT_UART2, pdata)
+#define imx35_add_imx_uart2(pdata)	\
+	imx_add_imx_uart_1irq(2, MX35_UART3_BASE_ADDR, SZ_16K, MX35_INT_UART3, pdata)
+
+#define imx35_add_mxc_nand(pdata)	\
+	imx_add_mxc_nand_v21(MX35_NFC_BASE_ADDR, MX35_INT_NANDFC, pdata)
+
+#define imx35_add_spi_imx0(pdata)	\
+	imx_add_spi_imx(0, MX35_CSPI1_BASE_ADDR, SZ_4K, MX35_INT_CSPI1, pdata)
+#define imx35_add_spi_imx1(pdata)	\
+	imx_add_spi_imx(1, MX35_CSPI2_BASE_ADDR, SZ_4K, MX35_INT_CSPI2, pdata)
+
+#define imx35_add_imx_mmc0(pdata)       \
+	imx_add_imx_mmc(0, MX35_MMC_SDHC1_BASE_ADDR, SZ_4K, MX35_INT_MMC_SDHC1, MXC_PSEUDO_IRQ_SD1_CD, pdata)
+#define imx35_add_imx_mmc1(pdata)	\
+	imx_add_imx_mmc(1, MX35_MMC_SDHC2_BASE_ADDR, SZ_4K, MX35_INT_MMC_SDHC2, 0, pdata)
diff --git a/arch/arm/mach-mx3/devices.c b/arch/arm/mach-mx3/devices.c
index db7acd6..54353c7 100644
--- a/arch/arm/mach-mx3/devices.c
+++ b/arch/arm/mach-mx3/devices.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2010 Freescale Semiconductor, Inc.
  * Copyright 2008 Sascha Hauer, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -27,6 +27,8 @@
 #include <mach/common.h>
 #include <mach/imx-uart.h>
 #include <mach/mx3_camera.h>
+#include <mach/sdma.h>
+#include <mach/mxc_dptc.h>
 
 #include "devices.h"
 
@@ -186,6 +188,41 @@ struct platform_device mxc_nand_device = {
 	.resource = mxc_nand_resources,
 };
 
+static struct resource mxc_nor_flash_resource = {
+	.start = 0xa0000000,
+	.end = 0xa0000000 + 0x04000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.num_resources = 1,
+	.resource = &mxc_nor_flash_resource,
+};
+
+static struct resource mxc_nandv2_resources[] = {
+	{
+		.flags = IORESOURCE_MEM,
+		.name  = "NFC_AXI_BASE",
+		.start	= 0, /* runtime dependent */
+		.end	= 0,
+	},
+	{
+		.flags = IORESOURCE_IRQ,
+		.start = MXC_INT_NANDFC,
+		.end   = MXC_INT_NANDFC,
+	},
+};
+
+struct platform_device mxc_nandv2_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.resource = mxc_nandv2_resources,
+	.num_resources = ARRAY_SIZE(mxc_nandv2_resources),
+};
+
 static struct resource mxc_i2c0_resources[] = {
 	{
 		.start = I2C_BASE_ADDR,
@@ -626,6 +663,133 @@ struct platform_device imx_kpp_device = {
 	.resource = imx_kpp_resources,
 };
 
+
+static struct resource sdma_resources[] = {
+	{
+		.start = SDMA_BASE_ADDR,
+		.end = SDMA_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MXC_INT_SDMA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_dma_device = {
+	.name = "mxc_sdma",
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+	.num_resources = ARRAY_SIZE(sdma_resources),
+	.resource = sdma_resources,
+};
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_4K,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = MXC_INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = MXC_INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static struct platform_device mxc_alsa_device = {
+	.name = "mxc_alsa",
+	.id = 0,
+};
+
+static struct platform_device mxc_scc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+};
+
+static struct platform_device hmp4e_device = {
+	.name = "mxc_hmp4e",
+	.id = 0,
+};
+
+/*!
+ * Resource definition for the DPTC LP
+ */
+static struct resource dptc_resources[] = {
+	[0] = {
+	       .start = CCM_BASE_ADDR,
+	       .end = CCM_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_CCM,
+	       .end = MXC_INT_CCM,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC DPTC */
+static struct platform_device mxc_dptc_device = {
+	.name = "mxc_dptc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(dptc_resources),
+	.resource = dptc_resources,
+};
+
+static struct resource mxc_iim_resources[] = {
+	{
+	 .start = MX31_IIM_BASE_ADDR,
+	 .end = MX31_IIM_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_iim_device = {
+	.name = "mxc_iim",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_iim_resources),
+	.resource = mxc_iim_resources
+};
+
+static struct resource pata_fsl_resources[] = {
+	{
+		.start = MX31_ATA_BASE_ADDR,
+		.end = MX31_ATA_BASE_ADDR + 0xD8,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX31_INT_ATA,
+		.end = MX31_INT_ATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device pata_fsl_device = {
+	.name = "pata_fsl",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pata_fsl_resources),
+	.resource = pata_fsl_resources,
+	.dev = {
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+};
+
+struct platform_device mxc_pseudo_irq_device = {
+	.name = "mxc_pseudo_irq",
+	.id = 0,
+};
+
 static int __init mx3_devices_init(void)
 {
 	if (cpu_is_mx31()) {
@@ -636,8 +800,8 @@ static int __init mx3_devices_init(void)
 		mxc_register_device(&mxc_rnga_device, NULL);
 	}
 	if (cpu_is_mx35()) {
-		mxc_nand_resources[0].start = MX35_NFC_BASE_ADDR;
-		mxc_nand_resources[0].end = MX35_NFC_BASE_ADDR + 0x1fff;
+		mxc_nandv2_resources[0].start = MX35_NFC_BASE_ADDR;
+		mxc_nandv2_resources[0].end = MX35_NFC_BASE_ADDR + 0x1fff;
 		otg_resources[0].start = MX35_OTG_BASE_ADDR;
 		otg_resources[0].end = MX35_OTG_BASE_ADDR + 0x1ff;
 		otg_resources[1].start = MXC_INT_USBOTG;
diff --git a/arch/arm/mach-mx3/devices.h b/arch/arm/mach-mx3/devices.h
index 2c3c864..479f6ef 100644
--- a/arch/arm/mach-mx3/devices.h
+++ b/arch/arm/mach-mx3/devices.h
@@ -6,6 +6,8 @@ extern struct platform_device mxc_uart_device3;
 extern struct platform_device mxc_uart_device4;
 extern struct platform_device mxc_w1_master_device;
 extern struct platform_device mxc_nand_device;
+extern struct platform_device mxc_nandv2_device;
+extern struct platform_device mxc_nor_mtd_device;
 extern struct platform_device mxc_i2c_device0;
 extern struct platform_device mxc_i2c_device1;
 extern struct platform_device mxc_i2c_device2;
@@ -15,6 +17,7 @@ extern struct platform_device mx3_camera;
 extern struct platform_device mxc_fec_device;
 extern struct platform_device mxcsdhc_device0;
 extern struct platform_device mxcsdhc_device1;
+extern struct platform_device mxc_pseudo_irq_device;
 extern struct platform_device mxc_otg_udc_device;
 extern struct platform_device mxc_otg_host;
 extern struct platform_device mxc_usbh1;
@@ -23,6 +26,7 @@ extern struct platform_device mxc_rnga_device;
 extern struct platform_device mxc_spi_device0;
 extern struct platform_device mxc_spi_device1;
 extern struct platform_device mxc_spi_device2;
+extern struct platform_device mxc_dma_device;
 extern struct platform_device imx_ssi_device0;
 extern struct platform_device imx_ssi_device1;
 extern struct platform_device imx_ssi_device1;
diff --git a/arch/arm/mach-mx3/dma.c b/arch/arm/mach-mx3/dma.c
new file mode 100644
index 0000000..115832d
--- /dev/null
+++ b/arch/arm/mach-mx3/dma.c
@@ -0,0 +1,1270 @@
+/*
+ * Copyright (C) 2007-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+#define MXC_MMC_BUFFER_ACCESS     0x38
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_FIRI_TXFIFO           0x14
+#define MXC_SDHC_MMC_WML          16
+#define MXC_SDHC_SD_WML           64
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_FIRI_WML              16
+#define MXC_SPDIF_TXFIFO_WML      8
+#define MXC_SPDIF_RXFIFO_WML      8
+#define MXC_SPDIF_TX_REG          0x2C
+#define MXC_SPDIF_RX_REG          0x14
+#define MXC_ASRC_FIFO_WML	0x40
+#define MXC_ASRCA_RX_REG	0x60
+#define MXC_ASRCA_TX_REG	0x64
+#define MXC_ASRCB_RX_REG	0x68
+#define MXC_ASRCB_TX_REG	0x6C
+#define MXC_ASRCC_RX_REG        0x70
+#define MXC_ASRCC_TX_REG        0x74
+#define MXC_ESAI_TX_REG	0x00
+#define MXC_ESAI_RX_REG	0x04
+#define MXC_ESAI_FIFO_WML 0x40
+#define MXC_UARTUTXD		0x40
+#define UART_UFCR_RXTL         16
+#define UART_UFCR_TXTL         16
+
+#ifdef CONFIG_SDMA_IRAM
+#define trans_type  int_2_per
+#define MXC_DMA_CHANNEL_IRAM	30
+#define MXC_DMA_CHANNEL_SSI1_TX	(MXC_DMA_CHANNEL_IRAM + 1)
+#define MXC_DMA_CHANNEL_SSI2_TX	(MXC_DMA_CHANNEL_IRAM + 1)
+#else
+#define trans_type emi_2_per
+#define MXC_DMA_CHANNEL_SSI1_TX	MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX	MXC_DMA_DYNAMIC_CHANNEL
+#endif
+
+struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	void *chnl_info;
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_RXTL,
+			.per_address = MX3x_UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_TXTL,
+			.per_address = MX3x_UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_RXTL,
+			.per_address = MX3x_UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_TXTL,
+			.per_address = MX3x_UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_RXTL,
+			.per_address = MX3x_UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_TXTL,
+			.per_address = MX3x_UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX31_DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_RXTL,
+			.per_address = MX31_UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_TXTL,
+			.per_address = MX31_UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX31_DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_RXTL,
+			.per_address = MX31_UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART_UFCR_TXTL,
+			.per_address = MX31_UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = MX31_DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MX31_MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MX31_MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MX31_MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MX31_MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = MX3x_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = MX3x_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = MX3x_DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = MX3x_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = trans_type,
+			.event_id = MX3x_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX3x_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = MX31_FIRI_BASE_ADDR,
+			.peripheral_type = FIRI,
+			.transfer_type = per_2_emi,
+			.event_id = MX31_DMA_REQ_FIRI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = MX31_FIRI_BASE_ADDR + MXC_FIRI_TXFIFO,
+			.peripheral_type = FIRI,
+			.transfer_type = emi_2_per,
+			.event_id = MX31_DMA_REQ_FIRI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = MX35_SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = MX35_DMA_REQ_SPDIF_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_TXFIFO_WML,
+			.per_address = MX35_SPDIF_BASE_ADDR + MXC_SPDIF_TX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = emi_2_per,
+			.event_id = MX35_DMA_REQ_SPDIF_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_spdif_32bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SPDIF_RXFIFO_WML,
+			.per_address = MX35_SPDIF_BASE_ADDR + MXC_SPDIF_RX_REG,
+			.peripheral_type = SPDIF,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_SPDIF_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCA_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = MX35_DMA_REQ_ASRC_DMA1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrca_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_ASRC_DMA4,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCB_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = MX35_DMA_REQ_ASRC_DMA2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcb_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_ASRC_DMA5,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCC_RX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = emi_2_per,
+			.event_id = MX35_DMA_REQ_ASRC_DMA3,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_asrcc_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ASRC_FIFO_WML * 3,
+			.per_address = MX35_ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			.peripheral_type = ASRC,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_ASRC_DMA6,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI1_TX1,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI1_TX2,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI2_TX1,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI2_TX2,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI1_TX1,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi1_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI1_TX2,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx0_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI2_TX1,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_ssi2_tx1_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX3x_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX3x_DMA_REQ_SSI2_TX2,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_SSI_TXFIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrca_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX35_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX35_DMA_REQ_ESAI_TX,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA4,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCA_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcb_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX35_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX35_DMA_REQ_ESAI_TX,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA5,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ESAI_FIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCB_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_ext_params_t mxc_sdma_asrcc_esai_params = {
+	.chnl_ext_params = {
+			    .common = {
+				       .watermark_level =
+				       MXC_ASRC_FIFO_WML >> 1,
+				       .per_address =
+				       MX35_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+				       .peripheral_type = ASRC,
+				       .transfer_type = per_2_per,
+				       .event_id = MX35_DMA_REQ_ESAI_TX,
+				       .event_id2 = MX35_DMA_REQ_ASRC_DMA6,
+				       .bd_number = 32,
+				       .word_size = TRANSFER_32BIT,
+				       .ext = 1,
+				       },
+			    .p2p_dir = 0,
+			    .info_bits =
+			    SDMA_ASRC_P2P_INFO_CONT | SDMA_ASRC_P2P_INFO_SP |
+			    SDMA_ASRC_P2P_INFO_DP,
+			    .watermark_level2 = MXC_ASRC_FIFO_WML,
+			    .per_address2 =
+					MX35_ASRC_BASE_ADDR + MXC_ASRCC_TX_REG,
+			    },
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX35_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX35_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = trans_type,
+			.event_id = MX35_DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX35_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = MX35_DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX35_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = trans_type,
+			.event_id = MX35_DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fifo_memory_params = {
+	.chnl_params = {
+			.peripheral_type = FIFO_MEMORY,
+			.per_address = MXC_FIFO_MEM_DEST_FIXED,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			.event_id = 0,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = MX3x_ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = MX3x_DMA_REQ_ATA_TX_END,
+			.event_id2 = MX3x_DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = MX3x_ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = MX3x_DMA_REQ_ATA_TX_END,
+			.event_id2 = MX3x_DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_DYNAMIC_CHANNEL,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_FIR_RX, &mxc_sdma_fir_rx_params},
+	{MXC_DMA_FIR_TX, &mxc_sdma_fir_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_FIFO_MEMORY, &mxc_sdma_fifo_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+	{MXC_DMA_SPDIF_16BIT_TX, &mxc_sdma_spdif_16bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_TX, &mxc_sdma_spdif_32bit_tx_params},
+	{MXC_DMA_SPDIF_32BIT_RX, &mxc_sdma_spdif_32bit_rx_params},
+	{MXC_DMA_ASRC_A_RX, &mxc_sdma_asrca_rx_params},
+	{MXC_DMA_ASRC_A_TX, &mxc_sdma_asrca_tx_params},
+	{MXC_DMA_ASRC_B_RX, &mxc_sdma_asrcb_rx_params},
+	{MXC_DMA_ASRC_B_TX, &mxc_sdma_asrcb_tx_params},
+	{MXC_DMA_ASRC_C_RX, &mxc_sdma_asrcc_rx_params},
+	{MXC_DMA_ASRC_C_TX, &mxc_sdma_asrcc_tx_params},
+	{MXC_DMA_ASRCA_SSI1_TX0, &mxc_sdma_asrca_ssi1_tx0_params},
+	{MXC_DMA_ASRCA_SSI1_TX1, &mxc_sdma_asrca_ssi1_tx1_params},
+	{MXC_DMA_ASRCA_SSI2_TX0, &mxc_sdma_asrca_ssi2_tx0_params},
+	{MXC_DMA_ASRCA_SSI2_TX1, &mxc_sdma_asrca_ssi2_tx1_params},
+	{MXC_DMA_ASRCB_SSI1_TX0, &mxc_sdma_asrcb_ssi1_tx0_params},
+	{MXC_DMA_ASRCB_SSI1_TX1, &mxc_sdma_asrcb_ssi1_tx1_params},
+	{MXC_DMA_ASRCB_SSI2_TX0, &mxc_sdma_asrcb_ssi2_tx0_params},
+	{MXC_DMA_ASRCB_SSI2_TX1, &mxc_sdma_asrcb_ssi2_tx1_params},
+	{MXC_DMA_ASRCA_ESAI, &mxc_sdma_asrca_esai_params},
+	{MXC_DMA_ASRCB_ESAI, &mxc_sdma_asrcb_esai_params},
+	{MXC_DMA_ASRCC_ESAI, &mxc_sdma_asrcc_esai_params},
+	{MXC_DMA_ESAI_16BIT_RX, &mxc_sdma_esai_16bit_rx_params},
+	{MXC_DMA_ESAI_16BIT_TX, &mxc_sdma_esai_16bit_tx_params},
+	{MXC_DMA_ESAI_24BIT_RX, &mxc_sdma_esai_24bit_rx_params},
+	{MXC_DMA_ESAI_24BIT_TX, &mxc_sdma_esai_24bit_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	struct mxc_sdma_info_entry_s *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif				/*CONFIG_SDMA_IRAM */
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx3/dptc.c b/arch/arm/mach-mx3/dptc.c
new file mode 100644
index 0000000..14efcbd
--- /dev/null
+++ b/arch/arm/mach-mx3/dptc.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.c
+ *
+ * @brief DPTC table for the Freescale Semiconductor MXC DPTC module.
+ *
+ * @ingroup PM
+ */
+
+#include <mach/hardware.h>
+#include <mach/mxc_dptc.h>
+
+struct dptc_wp dptc_wp_allfreq_26ckih[DPTC_WP_SUPPORTED] = {
+	/* 532MHz */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x95c00000, 0xffc00000, 0xe5800000, 1625},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1600},
+	{0xffc00000, 0x95e3e8e4, 0xffc00000, 0xe5b6fda0, 1575},
+	{0xffc00000, 0x95e3e8e8, 0xffc00000, 0xe5f70da4, 1550},
+	{0xffc00000, 0x9623f8e8, 0xffc00000, 0xe6371da8, 1525},
+	/* wp5 */
+	{0xffc00000, 0x966408f0, 0xffc00000, 0xe6b73db0, 1500},
+	{0xffc00000, 0x96e428f4, 0xffc00000, 0xe7776dbc, 1475},
+	{0xffc00000, 0x976448fc, 0xffc00000, 0xe8379dc8, 1450},
+	{0xffc00000, 0x97e46904, 0xffc00000, 0xe977ddd8, 1425},
+	{0xffc00000, 0x98a48910, 0xffc00000, 0xeab81de8, 1400},
+	/* wp10 */
+	{0xffc00000, 0x9964b918, 0xffc00000, 0xebf86df8, 1375},
+	{0xffc00000, 0xffe4e924, 0xffc00000, 0xfff8ae08, 1350},
+	{0xffc00000, 0xffe5192c, 0xffc00000, 0xfff8fe1c, 1350},
+	{0xffc00000, 0xffe54938, 0xffc00000, 0xfff95e2c, 1350},
+	{0xffc00000, 0xffe57944, 0xffc00000, 0xfff9ae44, 1350},
+	/* wp15 */
+	{0xffc00000, 0xffe5b954, 0xffc00000, 0xfffa0e58, 1350},
+	{0xffc00000, 0xffe5e960, 0xffc00000, 0xfffa6e70, 1350},
+};
+
+struct dptc_wp dptc_wp_allfreq_26ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
+	/* Mx31 TO 2.0  Offset table */
+	/* 532MHz  */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x9E265978, 0xffc00000, 0xE4371D9C, 1625},
+	{0xffc00000, 0x9E665978, 0xffc00000, 0xE4772D9C, 1600},
+	{0xffc00000, 0x9EA65978, 0xffc00000, 0xE4772DA0, 1575},
+	{0xffc00000, 0x9EE66978, 0xffc00000, 0xE4B73DA0, 1550},
+	{0xffc00000, 0x9F26697C, 0xffc00000, 0xE4F73DA0, 1525},
+	/* wp5 */
+	{0xffc00000, 0x9F66797C, 0xffc00000, 0xE5774DA4, 1500},
+	{0xffc00000, 0x9FE6797C, 0xffc00000, 0xE5F75DA4, 1475},
+	{0xffc00000, 0xA026897C, 0xffc00000, 0xE6776DA4, 1450},
+	{0xffc00000, 0xA0A6897C, 0xffc00000, 0xE6F77DA8, 1425},
+	{0xffc00000, 0xA0E69980, 0xffc00000, 0xE7B78DAC, 1400},
+	/* wp10 */
+	{0xffc00000, 0xA1669980, 0xffc00000, 0xE8379DAC, 1375},
+	{0xffc00000, 0xA1A6A980, 0xffc00000, 0xE8F7ADB0, 1350},
+	{0xffc00000, 0xA226B984, 0xffc00000, 0xE9F7CDB0, 1325},
+	{0xffc00000, 0xA2A6C984, 0xffc00000, 0xEAB7DDB4, 1300},
+	{0xffc00000, 0xA326C988, 0xffc00000, 0xEBB7FDB8, 1275},
+	/* wp15 */
+	{0xffc00000, 0xA3A6D988, 0xffc00000, 0xECB80DBC, 1250},
+	{0xffc00000, 0xA426E988, 0xffc00000, 0xEDB82DC0, 1225},
+};
+
+struct dptc_wp dptc_wp_allfreq_27ckih_TO_2_0[DPTC_WP_SUPPORTED] = {
+	/* Mx31 TO 2.0  Offset table */
+	/* 532MHz  */
+	/* dcvr0      dcvr1       dcvr2       dcvr3     voltage */
+	/* wp0 */
+	{0xffc00000, 0x9864E920, 0xffc00000, 0xDBB50D1C, 1625},
+	{0xffc00000, 0x98A4E920, 0xffc00000, 0xDBF51D1C, 1600},
+	{0xffc00000, 0x98E4E920, 0xffc00000, 0xDBF51D20, 1575},
+	{0xffc00000, 0x9924F920, 0xffc00000, 0xDC352D20, 1550},
+	{0xffc00000, 0x9924F924, 0xffc00000, 0xDC752D20, 1525},
+	/* wp5 */
+	{0xffc00000, 0x99650924, 0xffc00000, 0xDCF53D24, 1500},
+	{0xffc00000, 0x99E50924, 0xffc00000, 0xDD754D24, 1475},
+	{0xffc00000, 0x9A251924, 0xffc00000, 0xDDF55D24, 1450},
+	{0xffc00000, 0x9AA51924, 0xffc00000, 0xDE756D28, 1425},
+	{0xffc00000, 0x9AE52928, 0xffc00000, 0xDF357D2C, 1400},
+	/* wp10 */
+	{0xffc00000, 0x9B652928, 0xffc00000, 0xDFB58D2C, 1375},
+	{0xffc00000, 0x9BA53928, 0xffc00000, 0xE0759D30, 1350},
+	{0xffc00000, 0x9C254928, 0xffc00000, 0xE135BD30, 1325},
+	{0xffc00000, 0x9CA55928, 0xffc00000, 0xE1F5CD34, 1300},
+	{0xffc00000, 0x9D25592C, 0xffc00000, 0xE2F5ED38, 1275},
+	/* wp15 */
+	{0xffc00000, 0x9DA5692C, 0xffc00000, 0xE3F5FD38, 1250},
+	{0xffc00000, 0x9E25792C, 0xffc00000, 0xE4F61D3C, 1225},
+};
diff --git a/arch/arm/mach-mx3/dummy_gpio.c b/arch/arm/mach-mx3/dummy_gpio.c
new file mode 100644
index 0000000..6766cdf
--- /dev/null
+++ b/arch/arm/mach-mx3/dummy_gpio.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2007-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+
+void gpio_uart_active(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_active);
+
+void gpio_uart_inactive(int port, int no_irda) {}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+void gpio_gps_active(void) {}
+EXPORT_SYMBOL(gpio_gps_active);
+
+void gpio_gps_inactive(void) {}
+EXPORT_SYMBOL(gpio_gps_inactive);
+
+void config_uartdma_event(int port) {}
+EXPORT_SYMBOL(config_uartdma_event);
+
+void gpio_spi_active(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_active);
+
+void gpio_spi_inactive(int cspi_mod) {}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+void gpio_owire_active(void) {}
+EXPORT_SYMBOL(gpio_owire_active);
+
+void gpio_owire_inactive(void) {}
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+void gpio_i2c_active(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+void gpio_i2c_inactive(int i2c_num) {}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+void gpio_i2c_hs_active(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_active);
+
+void gpio_i2c_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_i2c_hs_inactive);
+
+void gpio_pmic_active(void) {}
+EXPORT_SYMBOL(gpio_pmic_active);
+
+void gpio_activate_audio_ports(void) {}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+void gpio_sdhc_active(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+void gpio_sdhc_inactive(int module) {}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+void gpio_sensor_select(int sensor) {}
+
+void gpio_sensor_active(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+void gpio_sensor_inactive(unsigned int csi) {}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+void gpio_ata_active(void) {}
+EXPORT_SYMBOL(gpio_ata_active);
+
+void gpio_ata_inactive(void) {}
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+void gpio_nand_active(void) {}
+EXPORT_SYMBOL(gpio_nand_active);
+
+void gpio_nand_inactive(void) {}
+EXPORT_SYMBOL(gpio_nand_inactive);
+
+void gpio_keypad_active(void) {}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+void gpio_keypad_inactive(void) {}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+int gpio_usbotg_hs_active(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void) {}
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+void gpio_fec_active(void) {}
+EXPORT_SYMBOL(gpio_fec_active);
+
+void gpio_fec_inactive(void) {}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+void gpio_spdif_active(void) {}
+EXPORT_SYMBOL(gpio_spdif_active);
+
+void gpio_spdif_inactive(void) {}
+EXPORT_SYMBOL(gpio_spdif_inactive);
+
+void gpio_mlb_active(void) {}
+EXPORT_SYMBOL(gpio_mlb_active);
+
+void gpio_mlb_inactive(void) {}
+EXPORT_SYMBOL(gpio_mlb_inactive);
diff --git a/arch/arm/mach-mx3/dvfs-imx35.c b/arch/arm/mach-mx3/dvfs-imx35.c
new file mode 100644
index 0000000..6ab210b
--- /dev/null
+++ b/arch/arm/mach-mx3/dvfs-imx35.c
@@ -0,0 +1,609 @@
+/*
+ *  Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+  * @file dvfs.c
+  *
+  * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+  *
+  * Upon initialization, the DVFS driver initializes the DVFS hardware
+  * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+  * data structures. When the DVFS interrupt occurs the driver checks the cause
+  * of the interrupt (lower frequency, increase frequency or emergency) and
+  * changes the CPU voltage according to translation table that is loaded into
+  * the driver.
+  *
+  * @ingroup PM
+  */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include "crm_regs.h"
+
+/*
+ * The frequency of div_3_clk will affect the dvfs sample rate..
+ */
+#define DVFS_DIV3CK		(3 << MXC_CCM_LTR0_DIV3CK_OFFSET)
+
+/*
+ * Panic threshold. Panic frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ */
+#define DVFS_PNCTHR		(63 << MXC_CCM_LTR1_PNCTHR_OFFSET)
+
+/*
+ * Load tracking buffer source: 1 for ld_add; 0 for pre_ld_add
+ */
+#define DVFS_LTBRSR		(1 << MXC_CCM_LTR1_LTBRSR_OFFSET)
+
+/* EMAC defines how many samples are included in EMA calculation */
+#define DVFS_EMAC		(0x20 << MXC_CCM_LTR2_EMAC_OFFSET)
+
+/*
+ * Frequency increase threshold. Increase frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ */
+#define DVFS_UPTHR(val)		(val << MXC_CCM_LTR0_UPTHR_OFFSET)
+
+/*
+ * Frequency decrease threshold. Decrease frequency change request
+ * will be sent if DVFS counter value will be less than this value.
+ */
+#define DVFS_DNTHR(val)		(val << MXC_CCM_LTR0_DNTHR_OFFSET)
+
+/*
+ * DNCNT defines the amount of times the down threshold should be exceeded
+ * before DVFS will trigger frequency decrease request.
+ */
+#define DVFS_DNCNT(val)		(val << MXC_CCM_LTR1_DNCNT_OFFSET)
+
+/*
+ * UPCNT defines the amount of times the up threshold should be exceeded
+ * before DVFS will trigger frequency increase request.
+ */
+#define DVFS_UPCNT(val)		(val << MXC_CCM_LTR1_UPCNT_OFFSET)
+
+#define DVFS_DVSUP(val)		(val << MXC_CCM_PMCR0_DVSUP_OFFSET)
+
+#define MXC_DVFS_MAX_WP_NUM 2
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+struct dvfs_wp {
+	unsigned long cpu_rate;
+	u32 core_voltage;
+	u32 dvsup;
+	u32 dnthr;
+	u32 upthr;
+	u32 dncnt;
+	u32 upcnt;
+};
+
+/* the default working points for MX35 TO2 DVFS. */
+static struct dvfs_wp dvfs_wp_tbl[MXC_DVFS_MAX_WP_NUM] = {
+	{399000000, 1200000, DVFS_DVSUP(DVSUP_LOW), DVFS_DNTHR(18),
+	 DVFS_UPTHR(31), DVFS_DNCNT(0x33),
+	 DVFS_UPCNT(0x33)},
+/* TBD: Need to set default voltage according to published data sheet */
+	{532000000, 1350000, DVFS_DVSUP(DVSUP_TURBO), DVFS_DNTHR(18),
+	 DVFS_UPTHR(30), DVFS_DNCNT(0x33),
+	 DVFS_UPCNT(0x33)}
+};
+
+static u8 dvfs_wp_num = MXC_DVFS_MAX_WP_NUM;
+
+ /* Used for tracking the number of interrupts */
+static u32 dvfs_nr_up[MXC_DVFS_MAX_WP_NUM];
+static u32 dvfs_nr_dn[MXC_DVFS_MAX_WP_NUM];
+static unsigned long stored_cpu_rate;	/* cpu rate before DVFS starts */
+static u32 stored_pmcr0;
+static int dvfs_is_active;	/* indicate DVFS is active or not */
+
+static struct delayed_work dvfs_work;
+
+/*
+ * Clock structures
+ */
+static struct clk *cpu_clk;
+static struct regulator *core_reg;
+
+const static u8 ltr_gp_weight[] = {
+	0,			/* 0 */
+	0,
+	0,
+	0,
+	0,
+	0,			/* 5 */
+	0,
+	0,
+	0,
+	0,
+	0,			/* 10 */
+	0,
+	0,
+	0,
+	0,
+	0,			/* 15 */
+};
+
+DEFINE_SPINLOCK(mxc_dvfs_lock);
+
+/*!
+ * This function sets the weight of general purpose signals
+ * @param   gp_id   number of general purpose bit
+ * @param   weight  the weight of the general purpose bit
+ */
+static void set_gp_weight(int gp_id, u8 weight)
+{
+	u32 reg;
+
+	if (gp_id < 9) {
+		reg = __raw_readl(MXC_CCM_LTR3);
+		reg = (reg & ~(MXC_CCM_LTR3_WSW_MASK(gp_id))) |
+		    (weight << MXC_CCM_LTR3_WSW_OFFSET(gp_id));
+		__raw_writel(reg, MXC_CCM_LTR3);
+	} else if (gp_id < 16) {
+		reg = __raw_readl(MXC_CCM_LTR2);
+		reg = (reg & ~(MXC_CCM_LTR2_WSW_MASK(gp_id))) |
+		    (weight << MXC_CCM_LTR2_WSW_OFFSET(gp_id));
+		__raw_writel(reg, MXC_CCM_LTR2);
+	}
+}
+
+/*!
+ * This function sets upper threshold, lower threshold,
+ * up-counter, down-counter for load tracking.
+ * @param   upthr  upper threshold
+ * @param   dnthr  lower threshold
+ * @param   upcnt  up counter
+ * @param   dncnt  down counter
+ */
+static void set_ltr_thres_counter(u32 upthr, u32 dnthr, u32 upcnt, u32 dncnt)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_LTR0);
+	reg =
+	    (reg &
+	     ~(MXC_CCM_LTR0_UPTHR_MASK |
+	       MXC_CCM_LTR0_DNTHR_MASK)) | upthr | dnthr;
+	__raw_writel(reg, MXC_CCM_LTR0);
+
+	reg = __raw_readl(MXC_CCM_LTR1);
+	reg =
+	    (reg &
+	     ~(MXC_CCM_LTR1_UPCNT_MASK |
+	       MXC_CCM_LTR1_DNCNT_MASK)) | upcnt | dncnt;
+	__raw_writel(reg, MXC_CCM_LTR1);
+}
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_controller(void)
+{
+	u32 i, reg;
+
+	/* setup LTR0 */
+	reg = __raw_readl(MXC_CCM_LTR0);
+	reg = (reg & ~(MXC_CCM_LTR0_DIV3CK_MASK)) | DVFS_DIV3CK;
+	__raw_writel(reg, MXC_CCM_LTR0);
+
+	/* set up LTR1 */
+	reg = __raw_readl(MXC_CCM_LTR1);
+	reg = (reg & ~(MXC_CCM_LTR1_PNCTHR_MASK | MXC_CCM_LTR1_LTBRSR_MASK));
+	reg = reg | DVFS_PNCTHR | DVFS_LTBRSR;
+	__raw_writel(reg, MXC_CCM_LTR1);
+
+	/* setup LTR2 */
+	reg = __raw_readl(MXC_CCM_LTR2);
+	reg = (reg & ~(MXC_CCM_LTR2_EMAC_MASK)) | DVFS_EMAC;
+	__raw_writel(reg, MXC_CCM_LTR2);
+
+	/* Set general purpose weights to 0 */
+	for (i = 0; i < 16; i++)
+		set_gp_weight(i, ltr_gp_weight[i]);
+
+	/* ARM interrupt, mask load buf full interrupt */
+	reg = __raw_readl(MXC_CCM_PMCR0);
+	reg |= MXC_CCM_PMCR0_DVFIS | MXC_CCM_PMCR0_LBMI;
+	__raw_writel(reg, MXC_CCM_PMCR0);
+
+	return 0;
+}
+
+static void dvfs_workqueue_handler(struct work_struct *work)
+{
+	u32 pmcr0 = stored_pmcr0;
+	u32 fsvai = (pmcr0 & MXC_CCM_PMCR0_FSVAI_MASK) >>
+	    MXC_CCM_PMCR0_FSVAI_OFFSET;
+	u32 dvsup = (pmcr0 & MXC_CCM_PMCR0_DVSUP_MASK) >>
+	    MXC_CCM_PMCR0_DVSUP_OFFSET;
+	u32 curr_cpu;
+	u8 curr_dvfs;
+
+	if (!dvfs_is_active)
+		return;
+
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		printk(KERN_WARNING "fsvai should not be 0\n");
+		goto exit;
+	}
+
+	if (((dvsup == DVSUP_LOW) && (fsvai == FSVAI_FREQ_DECREASE)) ||
+	    ((dvsup == DVSUP_TURBO) && ((fsvai == FSVAI_FREQ_INCREASE) ||
+					(fsvai == FSVAI_FREQ_EMERG)))) {
+		/* Interrupt should be disabled in these cases according to
+		 * the spec since DVFS is already at lowest (highest) state */
+		printk(KERN_WARNING "Something is wrong?\n");
+		goto exit;
+	}
+
+	/*Disable DPTC voltage update */
+	pmcr0 = pmcr0 & ~MXC_CCM_PMCR0_DPVCR;
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+	curr_cpu = clk_get_rate(cpu_clk);
+	for (curr_dvfs = 0; curr_dvfs < dvfs_wp_num; curr_dvfs++) {
+		if (dvfs_wp_tbl[curr_dvfs].cpu_rate == curr_cpu) {
+			if (fsvai == FSVAI_FREQ_DECREASE) {
+				curr_dvfs--;
+				dvfs_nr_dn[dvsup]++;
+				/*reduce frequency and then voltage */
+				clk_set_rate(cpu_clk,
+					     dvfs_wp_tbl[curr_dvfs].cpu_rate);
+				regulator_set_voltage(core_reg,
+						      dvfs_wp_tbl[curr_dvfs].
+						      core_voltage,
+						      dvfs_wp_tbl[curr_dvfs].
+						      core_voltage);
+				pr_info("Decrease frequency to: %ld \n",
+					dvfs_wp_tbl[curr_dvfs].cpu_rate);
+			} else {
+				/*increase freq to the highest one */
+				curr_dvfs = dvfs_wp_num - 1;
+				dvfs_nr_up[dvsup]++;
+				/*Increase voltage and then frequency */
+				regulator_set_voltage(core_reg,
+						      dvfs_wp_tbl[curr_dvfs].
+						      core_voltage,
+						      dvfs_wp_tbl[curr_dvfs].
+						      core_voltage);
+				clk_set_rate(cpu_clk,
+					     dvfs_wp_tbl[curr_dvfs].cpu_rate);
+				pr_info("Increase frequency to: %ld \n",
+					dvfs_wp_tbl[curr_dvfs].cpu_rate);
+			}
+			pmcr0 = (pmcr0 & ~MXC_CCM_PMCR0_DVSUP_MASK)
+			    | (dvfs_wp_tbl[curr_dvfs].dvsup);
+			__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+			set_ltr_thres_counter(dvfs_wp_tbl[curr_dvfs].upthr,
+					      dvfs_wp_tbl[curr_dvfs].dnthr,
+					      dvfs_wp_tbl[curr_dvfs].upcnt,
+					      dvfs_wp_tbl[curr_dvfs].dncnt);
+			break;
+		}
+	}
+
+      exit:
+	/* unmask interrupt */
+	pmcr0 = pmcr0 & ~MXC_CCM_PMCR0_FSVAIM;
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+	/*DVFS update finish */
+	pmcr0 = (pmcr0 | MXC_CCM_PMCR0_DVFS_UPDATE_FINISH);
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+}
+
+static irqreturn_t dvfs_irq(int irq, void *dev_id)
+{
+
+	u32 pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+
+	/* Config dvfs_start bit */
+	pmcr0 = pmcr0 | MXC_CCM_PMCR0_DVFS_START;
+	/*Mask interrupt */
+	pmcr0 = pmcr0 | MXC_CCM_PMCR0_FSVAIM;
+	__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+	stored_pmcr0 = pmcr0;
+	schedule_delayed_work(&dvfs_work, 0);
+
+	return IRQ_RETVAL(1);
+}
+
+/*!
+ * This function enables the DVFS module.
+ */
+static int start_dvfs(void)
+{
+	u32 reg = 0;
+	unsigned long flags;
+	u8 i;
+
+	if (dvfs_is_active) {
+		pr_info("DVFS is already started\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&mxc_dvfs_lock, flags);
+
+	stored_cpu_rate = clk_get_rate(cpu_clk);
+	for (i = 0; i < dvfs_wp_num; i++) {
+		if (dvfs_wp_tbl[i].cpu_rate == stored_cpu_rate) {
+			/*Set LTR0 and LTR1 */
+			set_ltr_thres_counter(dvfs_wp_tbl[i].upthr,
+					      dvfs_wp_tbl[i].dnthr,
+					      dvfs_wp_tbl[i].upcnt,
+					      dvfs_wp_tbl[i].dncnt);
+
+			reg = __raw_readl(MXC_CCM_PMCR0);
+			reg =
+			    (reg & ~MXC_CCM_PMCR0_DVSUP_MASK) | (dvfs_wp_tbl[i].
+								 dvsup);
+			/* enable dvfs and interrupt */
+			reg =
+			    (reg & ~MXC_CCM_PMCR0_FSVAIM) | MXC_CCM_PMCR0_DVFEN;
+
+			__raw_writel(reg, MXC_CCM_PMCR0);
+
+			dvfs_is_active = 1;
+			pr_info("DVFS Starts\n");
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&mxc_dvfs_lock, flags);
+	if (dvfs_is_active)
+		return 0;
+	else
+		return 1;
+}
+
+/*!
+ * This function disables the DVFS module.
+ */
+static void stop_dvfs(void)
+{
+	u32 pmcr0;
+	unsigned long curr_cpu = clk_get_rate(cpu_clk);
+	u8 index;
+
+	if (dvfs_is_active) {
+
+		pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+		/* disable dvfs and its interrupt */
+		pmcr0 = (pmcr0 & ~MXC_CCM_PMCR0_DVFEN) | MXC_CCM_PMCR0_FSVAIM;
+		__raw_writel(pmcr0, MXC_CCM_PMCR0);
+
+		if (stored_cpu_rate < curr_cpu) {
+			for (index = 0; index < dvfs_wp_num; index++) {
+				if (dvfs_wp_tbl[index].cpu_rate ==
+				    stored_cpu_rate)
+					break;
+			}
+			clk_set_rate(cpu_clk, stored_cpu_rate);
+			regulator_set_voltage(core_reg,
+					      dvfs_wp_tbl[index].core_voltage,
+					      dvfs_wp_tbl[index].core_voltage);
+		} else if (stored_cpu_rate > curr_cpu) {
+			for (index = 0; index < dvfs_wp_num; index++) {
+				if (dvfs_wp_tbl[index].cpu_rate ==
+				    stored_cpu_rate)
+					break;
+			}
+			regulator_set_voltage(core_reg,
+					      dvfs_wp_tbl[index].core_voltage,
+					      dvfs_wp_tbl[index].core_voltage);
+			clk_set_rate(cpu_clk, stored_cpu_rate);
+		}
+
+		dvfs_is_active = 0;
+	}
+
+	pr_info("DVFS is stopped\n");
+}
+
+static ssize_t dvfs_enable_store(struct sys_device *dev,
+					struct sysdev_attribute *attr,
+					const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		if (start_dvfs() != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL) {
+		stop_dvfs();
+	}
+
+	return size;
+}
+
+static ssize_t dvfs_status_show(struct sys_device *dev,
+					struct sysdev_attribute *attr,
+					char *buf)
+{
+	int size = 0, i;
+
+	if (dvfs_is_active)
+		size = sprintf(buf, "DVFS is enabled\n");
+	else
+		size = sprintf(buf, "DVFS is disabled\n");
+
+	size += sprintf((buf + size), "UP:\t");
+	for (i = 0; i < MXC_DVFS_MAX_WP_NUM; i++)
+		size += sprintf((buf + size), "%d\t", dvfs_nr_up[i]);
+	size += sprintf((buf + size), "\n");
+
+	size += sprintf((buf + size), "DOWN:\t");
+	for (i = 0; i < MXC_DVFS_MAX_WP_NUM; i++)
+		size += sprintf((buf + size), "%d\t", dvfs_nr_dn[i]);
+	size += sprintf((buf + size), "\n");
+
+	return size;
+}
+
+static ssize_t dvfs_status_store(struct sys_device *dev,
+					struct sysdev_attribute *attr,
+					const char *buf, size_t size)
+{
+	if (strstr(buf, "reset") != NULL) {
+		int i;
+		for (i = 0; i < MXC_DVFS_MAX_WP_NUM; i++) {
+			dvfs_nr_up[i] = 0;
+			dvfs_nr_dn[i] = 0;
+		}
+	}
+
+	return size;
+}
+
+static SYSDEV_ATTR(enable, 0200, NULL, dvfs_enable_store);
+static SYSDEV_ATTR(status, 0644, dvfs_status_show, dvfs_status_store);
+
+static struct sysdev_class dvfs_sysclass = {
+	.name = "dvfs",
+};
+
+static struct sys_device dvfs_device = {
+	.id = 0,
+	.cls = &dvfs_sysclass,
+};
+
+static int dvfs_sysdev_ctrl_init(void)
+{
+	int err;
+
+	err = sysdev_class_register(&dvfs_sysclass);
+	if (!err)
+		err = sysdev_register(&dvfs_device);
+	if (!err) {
+		err = sysdev_create_file(&dvfs_device, &attr_enable);
+		err = sysdev_create_file(&dvfs_device, &attr_status);
+	}
+
+	return err;
+}
+
+static void dvfs_sysdev_ctrl_exit(void)
+{
+	sysdev_remove_file(&dvfs_device, &attr_enable);
+	sysdev_remove_file(&dvfs_device, &attr_status);
+	sysdev_unregister(&dvfs_device);
+	sysdev_class_unregister(&dvfs_sysclass);
+}
+
+static int __init dvfs_init(void)
+{
+	int err = 0;
+	u8 index;
+	unsigned long curr_cpu;
+
+	if (cpu_is_mx35_rev(CHIP_REV_1_0) == 1) {
+		/*
+		 * Don't support DVFS for auto path in TO1 because
+		 * the voltages under 399M are all 1.2v
+		 */
+		if (!(__raw_readl(MXC_CCM_PDR0) & MXC_CCM_PDR0_AUTO_CON)) {
+			pr_info("MX35 TO1 auto path, no need to use DVFS \n");
+			return -1;
+		}
+	}
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	curr_cpu = clk_get_rate(cpu_clk);
+
+	if (board_is_rev(BOARD_REV_2))
+		core_reg = regulator_get(NULL, "SW2");
+	else
+		core_reg = regulator_get(NULL, "SW3");
+
+	dvfs_is_active = 0;
+
+	/*Set voltage */
+	for (index = 0; index < dvfs_wp_num; index++) {
+		if (dvfs_wp_tbl[index].cpu_rate == curr_cpu
+			&& !IS_ERR(core_reg)) {
+			regulator_set_voltage(core_reg,
+					      dvfs_wp_tbl[index].core_voltage,
+					      dvfs_wp_tbl[index].core_voltage);
+			break;
+		}
+	}
+
+	err = init_dvfs_controller();
+	if (err) {
+		printk(KERN_ERR "DVFS: Unable to initialize DVFS");
+		return err;
+	}
+
+	INIT_DELAYED_WORK(&dvfs_work, dvfs_workqueue_handler);
+
+	/* request the DVFS interrupt */
+	err = request_irq(MXC_INT_DVFS, dvfs_irq, IRQF_DISABLED, "dvfs", NULL);
+	if (err) {
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt");
+		return err;
+	}
+
+	err = dvfs_sysdev_ctrl_init();
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for dvfs");
+		return err;
+	}
+
+	return err;
+}
+
+static void __exit dvfs_cleanup(void)
+{
+	stop_dvfs();
+
+	/* release the DVFS interrupt */
+	free_irq(MXC_INT_DVFS, NULL);
+
+	dvfs_sysdev_ctrl_exit();
+
+	clk_put(cpu_clk);
+	regulator_put(core_reg);
+}
+
+module_init(dvfs_init);
+module_exit(dvfs_cleanup);
+
+MODULE_AUTHOR("Freescale Seminconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx3/entry-pm.S b/arch/arm/mach-mx3/entry-pm.S
new file mode 100644
index 0000000..17ce8da
--- /dev/null
+++ b/arch/arm/mach-mx3/entry-pm.S
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file plat-mxc/entry-pm.S
+ *
+ * @brief This file contains common pm entry .
+ *
+ * @ingroup MXC_PM
+ */
+
+#include <asm/assembler.h>
+#include <asm/ptrace.h>
+#include <asm/memory.h>
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+#include <asm/proc-fns.h>
+#include <asm/vfpmacros.h>
+
+#define WAIT_MODE               111
+#define DOZE_MODE               112
+#define STOP_MODE               113
+#define DSM_MODE                114
+
+#define PM_XLOAD_SIZE		0x04
+#define PM_XLOAD_ENTRY		0x08
+#define PM_XLOAD_SUSPEND_MODE	0x0C
+#define PM_XLOAD_CORE_SP	0x10
+
+#define PROCINFO_PROC_FNS	36
+#define PROC_FIN_FN		12
+#define PROC_IDLE_FN		20
+
+#ifdef CONFIG_FIQ
+#define ARM_CONTEXT_SIZE 12
+#else
+#define ARM_CONTEXT_SIZE 8
+#endif
+
+#ifdef CONFIG_PM_VERBOSE
+resume_str:
+	.string "Resume from DSM..."
+	.size resume_str, . - resume_str
+
+.macro show_resume_str
+	ldr r0, =resume_str
+	bl printk
+.endm
+
+#else
+.macro show_resume_str
+.endm
+#endif
+
+	.data
+	.align 3
+arm_core_context:
+	.rept ARM_CONTEXT_SIZE
+	.long 0
+	.endr
+
+#ifdef CONFIG_VFP
+	.text
+	.align 5
+arm_vfp_save:
+	mov ip, sp
+	stmdb sp!, {r0-r8, fp, ip, lr, pc}
+	sub fp, ip, #4
+	mov r1, #THREAD_SIZE
+	sub r1, r1, #1
+	bic r0, sp, r1
+	ldr r8, [r0, #TI_CPU]
+	add r4, r0, #TI_VFPSTATE
+
+	ldr r3, =last_VFP_context
+	VFPFMRX	r2, FPEXC
+	tst r2, #FPEXC_EN
+	bne 1f
+
+	ldr r4, [r3, r8, lsl #2]
+	cmp r4, #0
+	beq dead_vfp
+1:
+	bic r1, r2, #FPEXC_EN
+	VFPFMXR FPEXC, r1
+	/*TODO: SMP */
+	VFPFSTMIA r4, r1
+	VFPFMRX	r5, FPSCR
+	tst r2, #FPEXC_EX
+	VFPFMRX r6, FPINST, NE
+	tstne r2, #FPEXC_FP2V
+	VFPFMRX r7, FPINST2, NE
+	stmia r4, {r2, r5, r6, r7}
+
+	mov r1, #0
+	str r1, [r3, r8, lsl #2]
+dead_vfp:
+	ldmia sp, {r0-r8, fp, sp, pc}
+#endif
+/*
+ * The function just be called in this file
+ * Current r0 ~r4 are not saved.
+ * Otherwise, the working registers should be saved
+ */
+	.text
+	.align 5
+arm_core_save:
+	mov ip, sp
+	stmdb sp!, {r8, r9, sl, fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =arm_core_context
+	mov r3, r0
+	/* SVC mode */
+	mrs r1, spsr	@Save spsr
+	mrs r2, cpsr	@Save cpsr
+	stmia r0!, {r1, r2}
+	/* Abort mode */
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | ABT_MODE
+	stmia r0!, {sp}		@Save stack pointer for abort mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | UND_MODE
+	stmia r0!, {sp}		@Save stack pointer for undefine mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | IRQ_MODE
+	stmia r0!, {sp}		@Save stack pointer for irq mode
+#ifdef CONFIG_FIQ
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | FIQ_MODE
+	/*Save general register and sp for fiq mode*/
+	stmia r0!, {r8-r9, sl, fp, ip, sp}
+#endif
+	ldr r0, [r3, #4]
+	msr cpsr_c, r0
+	ldmia sp, {r8-r9, sl, fp, sp, pc}
+
+/*
+ * The function just be called in this file
+ * Current r0 ~r4 are not saved.
+ * Otherwise, the working registers should be saved
+ */
+arm_core_restore:
+	mov ip, sp
+	stmdb sp!, {fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =arm_core_context
+	mov r3, r0
+	/* SVC mode */
+	add r0, r0, #8		@skip svc mode
+	/* Abort mode */
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | ABT_MODE
+	ldmia r0!, {sp}		@restore stack pointer for abort mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | UND_MODE
+	ldmia r0!, {sp}		@restore stack pointer for undefine mode
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | IRQ_MODE
+	ldmia r0!, {sp}		@restore stack pointer for irq mode
+#ifdef CONFIG_FIQ
+	msr cpsr_c, #PSR_F_BIT | PSR_I_BIT | FIQ_MODE
+	/*Save general register and sp for fiq mode*/
+	ldmia r0!, {r8-r9, sl, fp, ip, sp}
+#endif
+	ldmia r3!, {r1, r2}
+	msr cpsr, r2		@restore cpsr
+	msr spsr, r1		@restore spsr
+	ldmia sp, {fp, sp, pc}
+
+mxc_cp15_context:
+	.rept 16
+	.long 0
+	.endr
+
+	.align 5
+mxc_cp15_restore:
+	/* Physical address */
+	adr r0, mxc_cp15_context
+	ldmia r0, {r1-r9}
+#ifndef CONFIG_PM_DEBUG
+	@Add dynamic check to skip this block when debug
+	sub lr, lr, #PHYS_OFFSET
+	add lr, lr, #PAGE_OFFSET
+#endif
+	mcr p15, 0, r3, c1, c0, 2	@CP Access Register
+	mcr p15, 0, r2, c1, c0, 1	@Aux Control register
+
+#ifndef CONFIG_PM_DEBUG
+	mcr p15, 0, r0, c7, c5, 6	@flush BTAC/BTB
+	mcr p15, 0, r0, c7, c7, 0	@invalidate both caches
+	mcr p15, 0, r0, c8, c7, 0	@Inval TLBs
+#endif
+
+	mcr p15, 0, r4, c13, c0, 0	@PID
+	mcr p15, 0, r5, c13, c0, 1	@Context ID
+
+	mcr p15, 0, r6, c3, c0, 0	@Domain Access Register
+	mcr p15, 0, r7, c2, c0, 0	@TTB0
+	mcr p15, 0, r8, c2, c0, 1	@TTB1
+	mcr p15, 0, r9, c2, c0, 2	@TTBC
+
+	mcr p15, 0, r1, c1, c0, 0	@Control Register
+	/* mcu enabled */
+	mrc p15, 0, r0, c2, c0, 0
+
+	mov pc, lr
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+mxc_cp15_save:
+	mov ip, sp
+	stmdb sp!, {r8-r9, fp, ip, lr, pc}
+	sub fp, ip, #4
+	ldr r0, =mxc_cp15_context
+/* System Control Registers */
+	mrc p15, 0, r1, c1, c0, 0	@Control Register
+	mrc p15, 0, r2, c1, c0, 1	@Aux Control Register
+	mrc p15, 0, r3, c1, c0, 2	@CP access Register
+
+/* Memory management Registers */
+	mrc p15, 0, r4, c13, c0, 0	@PID
+	mrc p15, 0, r5, c13, c0, 1	@Context ID
+
+	mrc p15, 0, r6, c3, c0, 0	@Domain Access Register
+
+	mrc p15, 0, r7, c2, c0, 0	@TTB0
+	mrc p15, 0, r8, c2, c0, 1	@TTB1
+	mrc p15, 0, r9, c2, c0, 2	@TTBC
+	stmia r0, {r1-r9}
+	ldmia sp, {r8, r9, fp, sp, pc}
+
+/*
+ * int __mxc_pm_arch_entry(u32 entry, u32 size)
+ */
+	.align 5
+	.globl mxc_pm_arch_entry
+mxc_pm_arch_entry:
+	mov ip, sp
+	stmdb sp!, {r4-r9, sl, fp, ip, lr, pc}
+	sub fp, ip, #4
+	sub sp, sp, #4
+	mov r8, r0	@save entry
+	mov r9, r1	@save entry size
+#ifdef CONFIG_VFP
+	bl arm_vfp_save
+#endif
+	/* r0 ~r3, ip is dirty*/
+	bl arm_core_save	@save arm context
+	bl mxc_cp15_save
+	mov r0, sp
+	mov r1, r8	@restore entry
+	mov r2, r9	@restore entry size
+	bl __mxc_pm_xload_setup
+1:	bl cpu_v6_proc_fin
+	bl cpu_v6_do_idle
+	nop
+	nop
+	nop
+	nop
+__mxc_pm_arch_leave:
+	adr r0, __mxc_pm_xload_info
+	ldr sp, [r0, #PM_XLOAD_CORE_SP]
+
+#ifndef CONFIG_PM_DEBUG
+	sub sp, sp, #PAGE_OFFSET
+	add sp, sp, #PHYS_OFFSET
+#endif
+	bl mxc_cp15_restore
+#ifndef CONFIG_PM_DEBUG
+	sub sp, sp, #PHYS_OFFSET
+	add sp, sp, #PAGE_OFFSET
+#endif
+	show_resume_str
+	bl arm_core_restore
+	ldmib sp, {r4-r9, sl, fp, sp, pc}
+
+__mxc_pm_xload_info:
+	adr pc, __mxc_pm_xload_entry		@Jump instruction
+	.long	__mxc_pm_xload_end - __mxc_pm_xload_info	@loader size
+	.long 	(__mxc_pm_arch_leave - PAGE_OFFSET + PHYS_OFFSET) @resume entry
+	.long   0 		@suspend state
+	.long   0		@Core Stack pointer
+__mxc_pm_xload_entry:
+	adr r0, __mxc_pm_xload_info
+	ldr pc, [r0, #PM_XLOAD_ENTRY]
+__mxc_pm_xload_end:
+
+/*
+ * __mxc_pm_xload_setup(u32 sp, u32 entry, u32 size)
+ * r0~r6 is dirty
+ */
+__mxc_pm_xload_setup:
+	ldr r3, =__mxc_pm_xload_info
+	str r0, [r3, #PM_XLOAD_CORE_SP]
+	ldr r4, [r3, #PM_XLOAD_SIZE]
+	cmp r2, r4
+	blo 2f
+1:	ldr r5, [r3], #4
+	str r5, [r1], #4
+	subs r4, r4, #4
+	bhi 1b
+	b 3f
+2:	str r3, [r1]
+3:	mov pc, lr
diff --git a/arch/arm/mach-mx3/iomux.h b/arch/arm/mach-mx3/iomux.h
new file mode 100644
index 0000000..de2651e
--- /dev/null
+++ b/arch/arm/mach-mx3/iomux.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_IOMUX_H__
+#define __MACH_MX31_IOMUX_H__
+
+#include <linux/types.h>
+#include <mach/gpio.h>
+#include "mx31_pins.h"
+
+typedef unsigned int iomux_pin_name_t;
+/*!
+ * @file mach-mx3/iomux.h
+ *
+ * @brief I/O Muxing control definitions and functions
+ *
+ * @ingroup GPIO_MX31
+ */
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_output_config {
+	OUTPUTCONFIG_GPIO = 0,	/*!< used as GPIO */
+	OUTPUTCONFIG_FUNC,	/*!< used as function */
+	OUTPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
+	OUTPUTCONFIG_ALT2,	/*!< used as alternate function 2 */
+	OUTPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
+	OUTPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
+	OUTPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
+	OUTPUTCONFIG_ALT6	/*!< used as alternate function 6 */
+} iomux_pin_ocfg_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUTCONFIG_NONE = 0,	/*!< not configured for input */
+	INPUTCONFIG_GPIO = 1 << 0,	/*!< used as GPIO */
+	INPUTCONFIG_FUNC = 1 << 1,	/*!< used as function */
+	INPUTCONFIG_ALT1 = 1 << 2,	/*!< used as alternate function 1 */
+	INPUTCONFIG_ALT2 = 1 << 3	/*!< used as alternate function 2 */
+} iomux_pin_icfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_NOLOOPBACK = 0x0 << 9,
+	PAD_CTL_LOOPBACK = 0x1 << 9,
+	PAD_CTL_PKE_NONE = 0x0 << 8,
+	PAD_CTL_PKE_ENABLE = 0x1 << 8,
+	PAD_CTL_PUE_KEEPER = 0x0 << 7,
+	PAD_CTL_PUE_PUD = 0x1 << 7,
+	PAD_CTL_100K_PD = 0x0 << 5,
+	PAD_CTL_100K_PU = 0x1 << 5,
+	PAD_CTL_47K_PU = 0x2 << 5,
+	PAD_CTL_22K_PU = 0x3 << 5,
+	PAD_CTL_HYS_CMOS = 0x0 << 4,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_PGP_FIRI = 0x1 << 0,
+	MUX_DDR_MODE = 0x1 << 1,
+	MUX_PGP_CSPI_BB = 0x1 << 2,
+	MUX_PGP_ATA_1 = 0x1 << 3,
+	MUX_PGP_ATA_2 = 0x1 << 4,
+	MUX_PGP_ATA_3 = 0x1 << 5,
+	MUX_PGP_ATA_4 = 0x1 << 6,
+	MUX_PGP_ATA_5 = 0x1 << 7,
+	MUX_PGP_ATA_6 = 0x1 << 8,
+	MUX_PGP_ATA_7 = 0x1 << 9,
+	MUX_PGP_ATA_8 = 0x1 << 10,
+	MUX_PGP_UH2 = 0x1 << 11,
+	MUX_SDCTL_CSD0_SEL = 0x1 << 12,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 13,
+	MUX_CSPI1_UART3 = 0x1 << 14,
+	MUX_EXTDMAREQ2_MBX_SEL = 0x1 << 15,
+	MUX_TAMPER_DETECT_EN = 0x1 << 16,
+	MUX_PGP_USB_4WIRE = 0x1 << 17,
+	MUX_PGB_USB_COMMON = 0x1 << 18,
+	MUX_SDHC_MEMSTICK1 = 0x1 << 19,
+	MUX_SDHC_MEMSTICK2 = 0x1 << 20,
+	MUX_PGP_SPLL_BYP = 0x1 << 21,
+	MUX_PGP_UPLL_BYP = 0x1 << 22,
+	MUX_PGP_MSHC1_CLK_SEL = 0x1 << 23,
+	MUX_PGP_MSHC2_CLK_SEL = 0x1 << 24,
+	MUX_CSPI3_UART5_SEL = 0x1 << 25,
+	MUX_PGP_ATA_9 = 0x1 << 26,
+	MUX_PGP_USB_SUSPEND = 0x1 << 27,
+	MUX_PGP_USB_OTG_LOOPBACK = 0x1 << 28,
+	MUX_PGP_USB_HS1_LOOPBACK = 0x1 << 29,
+	MUX_PGP_USB_HS2_LOOPBACK = 0x1 << 30,
+	MUX_CLKO_DDR_MODE = 0x1 << 31,
+} iomux_gp_func_t;
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ *
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ * @return 		0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pins
+ * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+#endif
diff --git a/arch/arm/mach-mx3/mach-mx31_3ds.c b/arch/arm/mach-mx3/mach-mx31_3ds.c
index 58e5729..d72022b 100644
--- a/arch/arm/mach-mx3/mach-mx31_3ds.c
+++ b/arch/arm/mach-mx3/mach-mx31_3ds.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,13 +22,15 @@
 #include <linux/clk.h>
 #include <linux/irq.h>
 #include <linux/gpio.h>
-#include <linux/smsc911x.h>
 #include <linux/platform_device.h>
 #include <linux/mfd/mc13783.h>
 #include <linux/spi/spi.h>
 #include <linux/regulator/machine.h>
 #include <linux/fsl_devices.h>
 #include <linux/input/matrix_keypad.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/fsl_devices.h>
 
 #include <mach/hardware.h>
 #include <asm/mach-types.h>
@@ -40,9 +42,12 @@
 #include <mach/board-mx31_3ds.h>
 #include <mach/imx-uart.h>
 #include <mach/iomux-mx3.h>
+#include <mach/3ds_debugboard.h>
+#include <mach/mmc.h>
 #include <mach/mxc_nand.h>
 #include <mach/spi.h>
 #include "devices.h"
+#include "crm_regs.h"
 
 /*!
  * @file mx31_3ds.c
@@ -68,6 +73,26 @@ static int mx31_3ds_pins[] = {
 	MX31_PIN_CSPI2_SS2__SS2, /*CS for MC13783 */
 	/* MC13783 IRQ */
 	IOMUX_MODE(MX31_PIN_GPIO1_3, IOMUX_CONFIG_GPIO),
+	/* SDHC1 */
+	MX31_PIN_SD1_DATA3__SD1_DATA3, MX31_PIN_SD1_DATA2__SD1_DATA2,
+	MX31_PIN_SD1_DATA1__SD1_DATA1, MX31_PIN_SD1_DATA0__SD1_DATA0,
+	MX31_PIN_SD1_CLK__SD1_CLK, MX31_PIN_SD1_CMD__SD1_CMD,
+	MX31_PIN_GPIO3_0__GPIO3_0, MX31_PIN_GPIO3_1__GPIO3_1,
+	/* SDHC2 */
+	MX31_PIN_PC_PWRON__SD2_DATA3, MX31_PIN_PC_VS1__SD2_DATA2,
+	MX31_PIN_PC_READY__SD2_DATA1, MX31_PIN_PC_WAIT_B__SD2_DATA0,
+	MX31_PIN_PC_CD2_B__SD2_CLK, MX31_PIN_PC_CD1_B__SD2_CMD,
+	MX31_PIN_GPIO1_2__GPIO1_2,
+	/* AUDMUX (4 & 5) */
+	MX31_PIN_SCK4__SCK4, MX31_PIN_SRXD4__SRXD4,
+	MX31_PIN_STXD4__STXD4, MX31_PIN_SFS4__SFS4,
+	MX31_PIN_STXD5__STXD5, MX31_PIN_SRXD5__SRXD5,
+	MX31_PIN_SCK5__SCK5, MX31_PIN_SFS5__SFS5,
+
+	MX31_PIN_LCS0__GPI03_23,
+	MX31_PIN_SRST0__GPIO3_2,
+	MX31_PIN_SIMPD0__GPIO2_3,
+	MX31_PIN_BATT_LINE__GPIO2_17,
 	/* USB OTG reset */
 	IOMUX_MODE(MX31_PIN_USB_PWR, IOMUX_CONFIG_GPIO),
 	/* USB OTG */
@@ -114,6 +139,10 @@ static struct matrix_keymap_data mx31_3ds_keymap_data = {
 	.keymap_size	= ARRAY_SIZE(mx31_3ds_keymap),
 };
 
+static struct mxc_audio_platform_data mxc_audio_data = {
+	.ssi_num = 1,
+};
+
 /* Regulators */
 static struct regulator_init_data pwgtx_init = {
 	.constraints = {
@@ -212,174 +241,56 @@ static struct imxuart_platform_data uart_pdata = {
 	.flags = IMXUART_HAVE_RTSCTS,
 };
 
-/*
- * Support for the SMSC9217 on the Debug board.
- */
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-	.flags		= SMSC911X_USE_16BIT | SMSC911X_FORCE_INTERNAL_PHY,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct resource smsc911x_resources[] = {
-	{
-		.start		= LAN9217_BASE_ADDR,
-		.end		= LAN9217_BASE_ADDR + 0xff,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= EXPIO_INT_ENET,
-		.end		= EXPIO_INT_ENET,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev		= {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-/*
- * Routines for the CPLD on the debug board. It contains a CPLD handling
- * LEDs, switches, interrupts for Ethernet.
- */
+#define PLL_PCTL_REG(pd, mfd, mfi, mfn)		\
+	((((pd) - 1) << 26) + (((mfd) - 1) << 16) + ((mfi)  << 10) + mfn)
 
-static void mx31_3ds_expio_irq_handler(uint32_t irq, struct irq_desc *desc)
-{
-	uint32_t imr_val;
-	uint32_t int_valid;
-	uint32_t expio_irq;
-
-	imr_val = __raw_readw(CPLD_INT_MASK_REG);
-	int_valid = __raw_readw(CPLD_INT_STATUS_REG) & ~imr_val;
-
-	expio_irq = MXC_EXP_IO_BASE;
-	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
-		if ((int_valid & 1) == 0)
-			continue;
-		generic_handle_irq(expio_irq);
-	}
-}
+/* For 26MHz input clock */
+#define PLL_532MHZ		PLL_PCTL_REG(1, 13, 10, 3)
+#define PLL_399MHZ		PLL_PCTL_REG(1, 52, 7, 35)
+#define PLL_133MHZ		PLL_PCTL_REG(2, 26, 5, 3)
 
-/*
- * Disable an expio pin's interrupt by setting the bit in the imr.
- * @param irq           an expio virtual irq number
- */
-static void expio_mask_irq(uint32_t irq)
-{
-	uint16_t reg;
-	uint32_t expio = MXC_IRQ_TO_EXPIO(irq);
-
-	/* mask the interrupt */
-	reg = __raw_readw(CPLD_INT_MASK_REG);
-	reg |= 1 << expio;
-	__raw_writew(reg, CPLD_INT_MASK_REG);
-}
-
-/*
- * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
- * @param irq           an expanded io virtual irq number
- */
-static void expio_ack_irq(uint32_t irq)
-{
-	uint32_t expio = MXC_IRQ_TO_EXPIO(irq);
+#define PDR0_REG(mcu, max, hsp, ipg, nfc)	\
+	(MXC_CCM_PDR0_MCU_DIV_##mcu | MXC_CCM_PDR0_MAX_DIV_##max | \
+	 MXC_CCM_PDR0_HSP_DIV_##hsp | MXC_CCM_PDR0_IPG_DIV_##ipg | \
+	 MXC_CCM_PDR0_NFC_DIV_##nfc)
 
-	/* clear the interrupt status */
-	__raw_writew(1 << expio, CPLD_INT_RESET_REG);
-	__raw_writew(0, CPLD_INT_RESET_REG);
-	/* mask the interrupt */
-	expio_mask_irq(irq);
-}
-
-/*
- * Enable a expio pin's interrupt by clearing the bit in the imr.
- * @param irq           a expio virtual irq number
- */
-static void expio_unmask_irq(uint32_t irq)
-{
-	uint16_t reg;
-	uint32_t expio = MXC_IRQ_TO_EXPIO(irq);
-
-	/* unmask the interrupt */
-	reg = __raw_readw(CPLD_INT_MASK_REG);
-	reg &= ~(1 << expio);
-	__raw_writew(reg, CPLD_INT_MASK_REG);
-}
-
-static struct irq_chip expio_irq_chip = {
-	.ack = expio_ack_irq,
-	.mask = expio_mask_irq,
-	.unmask = expio_unmask_irq,
+/* working point(wp): 0 - 133MHz; 1 - 266MHz; 2 - 399MHz; 3 - 532MHz */
+/* 26MHz input clock table */
+static struct cpu_wp cpu_wp_26[] = {
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 133000000,
+	 .pdr0_reg = PDR0_REG(4, 4, 4, 2, 6),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 266000000,
+	 .pdr0_reg = PDR0_REG(2, 4, 4, 2, 6),},
+	{
+	 .pll_reg = PLL_399MHZ,
+	 .pll_rate = 399000000,
+	 .cpu_rate = 399000000,
+	 .pdr0_reg = PDR0_REG(1, 3, 3, 2, 6),},
+	{
+	 .pll_reg = PLL_532MHZ,
+	 .pll_rate = 532000000,
+	 .cpu_rate = 532000000,
+	 .pdr0_reg = PDR0_REG(1, 4, 4, 2, 6),},
 };
 
-static int __init mx31_3ds_init_expio(void)
+struct cpu_wp *get_cpu_wp(int *wp)
 {
-	int i;
-	int ret;
-
-	/* Check if there's a debug board connected */
-	if ((__raw_readw(CPLD_MAGIC_NUMBER1_REG) != 0xAAAA) ||
-	    (__raw_readw(CPLD_MAGIC_NUMBER2_REG) != 0x5555) ||
-	    (__raw_readw(CPLD_MAGIC_NUMBER3_REG) != 0xCAFE)) {
-		/* No Debug board found */
-		return -ENODEV;
-	}
-
-	pr_info("i.MX31 3DS Debug board detected, rev = 0x%04X\n",
-		__raw_readw(CPLD_CODE_VER_REG));
-
-	/*
-	 * Configure INT line as GPIO input
-	 */
-	ret = gpio_request(IOMUX_TO_GPIO(MX31_PIN_GPIO1_1), "sms9217-irq");
-	if (ret)
-		pr_warning("could not get LAN irq gpio\n");
-	else
-		gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_GPIO1_1));
-
-	/* Disable the interrupts and clear the status */
-	__raw_writew(0, CPLD_INT_MASK_REG);
-	__raw_writew(0xFFFF, CPLD_INT_RESET_REG);
-	__raw_writew(0, CPLD_INT_RESET_REG);
-	__raw_writew(0x1F, CPLD_INT_MASK_REG);
-	for (i = MXC_EXP_IO_BASE;
-	     i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
-	     i++) {
-		set_irq_chip(i, &expio_irq_chip);
-		set_irq_handler(i, handle_level_irq);
-		set_irq_flags(i, IRQF_VALID);
-	}
-	set_irq_type(EXPIO_PARENT_INT, IRQ_TYPE_LEVEL_LOW);
-	set_irq_chained_handler(EXPIO_PARENT_INT, mx31_3ds_expio_irq_handler);
-
-	return 0;
+	*wp = 4;
+	return cpu_wp_26;
 }
 
 /*
- * This structure defines the MX31 memory map.
- */
-static struct map_desc mx31_3ds_io_desc[] __initdata = {
-	{
-		.virtual = MX31_CS5_BASE_ADDR_VIRT,
-		.pfn = __phys_to_pfn(MX31_CS5_BASE_ADDR),
-		.length = MX31_CS5_SIZE,
-		.type = MT_DEVICE,
-	},
-};
-
-/*
  * Set up static virtual mappings.
  */
 static void __init mx31_3ds_map_io(void)
 {
 	mx31_map_io();
-	iotable_init(mx31_3ds_io_desc, ARRAY_SIZE(mx31_3ds_io_desc));
 }
 
 /*!
@@ -387,6 +298,47 @@ static void __init mx31_3ds_map_io(void)
  */
 static void __init mxc_board_init(void)
 {
+	struct clk *pll_clk;
+	struct clk *ckih_clk;
+	struct clk *cko_clk;
+	void __iomem *iim_reg = MX31_IO_ADDRESS(MX31_IIM_BASE_ADDR);
+
+	/* request gpio for phone jack detect */
+	mxc_iomux_set_pad(MX31_PIN_BATT_LINE, PAD_CTL_PKE_NONE);
+	gpio_request(IOMUX_TO_GPIO(MX31_PIN_BATT_LINE), "batt_line");
+	gpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_BATT_LINE));
+
+	pll_clk = clk_get(NULL, "usb_pll");
+	mxc_audio_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
+	if (IS_ERR(pll_clk) || IS_ERR(mxc_audio_data.ssi_clk[0])) {
+		pr_err("cannot get usb pll or ssi clks\n");
+	} else {
+		clk_set_parent(mxc_audio_data.ssi_clk[0], pll_clk);
+		clk_put(mxc_audio_data.ssi_clk[0]);
+		clk_put(pll_clk);
+	}
+
+	/* override fuse for Hantro HW clock */
+	if (__raw_readl(iim_reg + 0x808) == 0x4) {
+		if (!(__raw_readl(iim_reg + 0x800) & (1 << 5))) {
+			writel(__raw_readl(iim_reg + 0x808) & 0xfffffffb,
+					   iim_reg + 0x808);
+		}
+	}
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	ckih_clk = clk_get(NULL, "ckih");
+	cko_clk = clk_get(NULL, "cko1_clk");
+	if (IS_ERR(ckih_clk) || IS_ERR(cko_clk)) {
+		printk(KERN_ERR "Unable to set CKO1 output to CKIH\n");
+	} else {
+		clk_set_parent(cko_clk, ckih_clk);
+		clk_set_rate(cko_clk, clk_get_rate(ckih_clk));
+		clk_enable(cko_clk);
+	}
+	clk_put(ckih_clk);
+	clk_put(cko_clk);
+
 	mxc_iomux_setup_multiple_pins(mx31_3ds_pins, ARRAY_SIZE(mx31_3ds_pins),
 				      "mx31_3ds");
 
@@ -402,8 +354,10 @@ static void __init mxc_board_init(void)
 	mx31_3ds_usbotg_init();
 	mxc_register_device(&mxc_otg_udc_device, &usbotg_pdata);
 
-	if (!mx31_3ds_init_expio())
-		platform_device_register(&smsc911x_device);
+	if (mxc_expio_init(CS5_BASE_ADDR, EXPIO_PARENT_INT))
+		printk(KERN_WARNING "Init of the debugboard failed, all "
+				   "devices on the board are unusable.\n");
+
 }
 
 static void __init mx31_3ds_timer_init(void)
diff --git a/arch/arm/mach-mx3/mach-mx31ads.c b/arch/arm/mach-mx3/mach-mx31ads.c
index b3d1a18..4ebaa26 100644
--- a/arch/arm/mach-mx3/mach-mx31ads.c
+++ b/arch/arm/mach-mx3/mach-mx31ads.c
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
- *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2005-2010 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -44,6 +44,7 @@
 #endif
 
 #include "devices.h"
+#include "devices-imx31.h"
 
 /*!
  * @file mx31ads.c
@@ -98,7 +99,7 @@ static inline int mxc_init_extuart(void)
 #endif
 
 #if defined(CONFIG_SERIAL_IMX) || defined(CONFIG_SERIAL_IMX_MODULE)
-static struct imxuart_platform_data uart_pdata = {
+static const struct imxuart_platform_data uart_pdata __initconst = {
 	.flags = IMXUART_HAVE_RTSCTS,
 };
 
@@ -112,7 +113,7 @@ static unsigned int uart_pins[] = {
 static inline void mxc_init_imx_uart(void)
 {
 	mxc_iomux_setup_multiple_pins(uart_pins, ARRAY_SIZE(uart_pins), "uart-0");
-	mxc_register_device(&mxc_uart_device0, &uart_pdata);
+	imx31_add_imx_uart0(&uart_pdata);
 }
 #else /* !SERIAL_IMX */
 static inline void mxc_init_imx_uart(void)
@@ -467,7 +468,7 @@ static struct i2c_board_info __initdata mx31ads_i2c1_devices[] = {
 #endif
 };
 
-static void mxc_init_i2c(void)
+static void __init mxc_init_i2c(void)
 {
 	i2c_register_board_info(1, mx31ads_i2c1_devices,
 				ARRAY_SIZE(mx31ads_i2c1_devices));
@@ -475,7 +476,7 @@ static void mxc_init_i2c(void)
 	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MOSI, IOMUX_CONFIG_ALT1));
 	mxc_iomux_mode(IOMUX_MODE(MX31_PIN_CSPI2_MISO, IOMUX_CONFIG_ALT1));
 
-	mxc_register_device(&mxc_i2c_device1, NULL);
+	imx31_add_imx_i2c1(NULL);
 }
 #else
 static void mxc_init_i2c(void)
diff --git a/arch/arm/mach-mx3/mach-mx35_3ds.c b/arch/arm/mach-mx3/mach-mx35_3ds.c
new file mode 100755
index 0000000..5495f73
--- /dev/null
+++ b/arch/arm/mach-mx3/mach-mx35_3ds.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/memory.h>
+#include <linux/gpio.h>
+#include <linux/fsl_devices.h>
+#include <linux/i2c.h>
+#include <linux/i2c/tsc2007.h>
+#include <linux/mfd/mc9s08dz60/pmic.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+
+#include <asm/mach/flash.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/imx-uart.h>
+#include <mach/iomux-mx35.h>
+#include <mach/board-mx35_3ds.h>
+#include <mach/3ds_debugboard.h>
+#include <mach/mmc.h>
+#include <mach/spi.h>
+#include <mach/iomux-v3.h>
+
+#include "devices-imx35.h"
+#include "devices.h"
+#include "crm_regs.h"
+
+/*
+ * Board specific pad setting.
+ */
+#define MX35_ESDHC1_CMD__PAD_CFG 	\
+(					\
+	PAD_CTL_PUE 		| 	\
+	PAD_CTL_PKE 		| 	\
+	PAD_CTL_HYS 		| 	\
+	PAD_CTL_DSE_MAX 	|	\
+	PAD_CTL_PUS_47K_UP 	|	\
+	PAD_CTL_SRE_FAST		\
+)
+
+#define MX35_ESDHC1_CLK__PAD_CFG	\
+(					\
+	PAD_CTL_PUE 		|	\
+	PAD_CTL_PKE 		| 	\
+	PAD_CTL_DSE_MAX 	|	\
+	PAD_CTL_PUS_47K_UP 	|	\
+	PAD_CTL_SRE_FAST		\
+)
+
+#define MX35_ESDHC1_DATA__PAD_CFG 	\
+	MX35_ESDHC1_CMD__PAD_CFG
+
+static const struct imxuart_platform_data uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static int spi_internal_chipselect[] = {
+	MXC_SPI_CS(0),
+	MXC_SPI_CS(1),
+	MXC_SPI_CS(2),
+	MXC_SPI_CS(3),
+};
+
+static const struct spi_imx_master spi_pdata = {
+	.chipselect = spi_internal_chipselect,
+	.num_chipselect = ARRAY_SIZE(spi_internal_chipselect),
+};
+
+static const struct imxi2c_platform_data i2c_data = {
+	.bitrate = 100000,
+};
+
+static unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	unsigned int ret;
+
+	if (board_is_rev(BOARD_REV_2))
+		pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_2, 7, 1);
+
+	if (to_platform_device(dev)->id == 0) {
+		if (0 != pmic_gpio_get_designation_bit_val(2, &ret))
+			printk(KERN_ERR "Get cd status error.");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sdhc_write_protect(struct device *dev)
+{
+	unsigned int rc = 0;
+
+	if (0 != pmic_gpio_get_designation_bit_val(3, &rc))
+		printk(KERN_ERR "Get wp status error.");
+
+	return rc;
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_32_33,
+#if defined(CONFIG_SDIO_UNIFI_FS) || defined(CONFIG_SDIO_UNIFI_FS_MODULE)
+	.caps = MMC_CAP_4_BIT_DATA,
+#else
+	.caps = MMC_CAP_8_BIT_DATA,
+#endif
+	.min_clk = 150000,
+	.max_clk = 52000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "sdhc_clk",
+};
+
+/* MTD NOR flash */
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE,
+	}, {
+	 .name = "nor.Kernel",
+	 .size = 4 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0,
+	}, {
+	 .name = "nor.userfs",
+	 .size = 30 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0,
+	}, {
+	 .name = "nor.rootfs",
+	 .size = 28 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE,
+	}, {
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE,
+	}, {
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE,
+	},
+};
+
+static struct flash_platform_data mxc_nor_flash_pdata = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+/* MTD NAND flash */
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+	 .name = "nand.bootloader",
+	 .offset = 0,
+	 .size = 3 * 1024 * 1024,
+	}, {
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 5 * 1024 * 1024,
+	}, {
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024,
+	}, {
+	 .name = "nand.configure",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 8 * 1024 * 1024,
+	}, {
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data mxc_nandv2_pdata = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static void __init mxc_register_nandv2_devices(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nandv2_pdata.width = 2;
+
+	mxc_register_device(&mxc_nandv2_device, &mxc_nandv2_pdata);
+}
+
+static void si4702_reset(void)
+{
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 4, 0);
+	msleep(100);
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 4, 1);
+	msleep(100);
+}
+
+static void si4702_clock_ctl(int flag)
+{
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 7, flag);
+}
+
+static struct mxc_fm_platform_data si4702_data = {
+	.reg_vio = "VSD",
+	.reg_vdd = NULL,
+	.reset = si4702_reset,
+	.clock_ctl = si4702_clock_ctl,
+	.sksnr = 0,
+	.skcnt = 0,
+	.band = 0,
+	.space = 100,
+	.seekth = 0xa,
+};
+
+static int tsc2007_get_pendown_state(void)
+{
+	return !gpio_get_value(MX35_GPIO1_4);
+}
+
+struct tsc2007_platform_data tsc2007_data = {
+	.model = 2007,
+	.x_plate_ohms = 400,
+	.get_pendown_state = tsc2007_get_pendown_state,
+};
+
+static struct mxc_camera_platform_data camera_data = {
+	.core_regulator = "SW1",
+	.io_regulator = "VAUDIO",
+	.analog_regulator = NULL,
+	.gpo_regulator = "PWGT1",
+	.mclk = 27000000,
+};
+
+static void adv7180_pwdn(int pwdn)
+{
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_GPIO_CONTROL_1, 1, ~pwdn);
+}
+
+static void adv7180_reset(void)
+{
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 6, 0);
+	msleep(5);
+	pmic_gpio_set_bit_val(MCU_GPIO_REG_RESET_1, 6, 1);
+	msleep(5);
+}
+
+static struct mxc_tvin_platform_data adv7180_data = {
+	.dvddio_reg = NULL,
+	.dvdd_reg = "SW3",
+	.avdd_reg = "PWGT2",
+	.pvdd_reg = NULL,
+	.pwdn = adv7180_pwdn,
+	.reset = adv7180_reset,
+};
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("max8660", 0x34),
+	}, {	I2C_BOARD_INFO("tsc2007", 0x48),
+		.platform_data = &tsc2007_data,
+		.irq = IOMUX_TO_IRQ(MX35_GPIO1_4),
+	}, {
+		I2C_BOARD_INFO("ov2640", 0x30),
+		.platform_data = (void *)&camera_data,
+	}, {
+		I2C_BOARD_INFO("sgtl5000-i2c", 0x0a),
+	}, {
+		I2C_BOARD_INFO("ak4647-i2c", 0x12),
+	}, {
+#if defined(CONFIG_I2C_SLAVE_CLIENT)
+		I2C_BOARD_INFO("i2c-slave-client", 0x55),
+#endif
+	}, {
+		I2C_BOARD_INFO("si4702", 0x10),
+		.platform_data = (void *)&si4702_data,
+	}, {
+		I2C_BOARD_INFO("adv7180", 0x21),
+		.platform_data = (void *)&adv7180_data,
+	},
+};
+
+static struct platform_device *devices[] __initdata = {
+	&mxc_fec_device,
+	&mxc_dma_device,
+};
+
+static struct pad_cfg mx35pdk_pads[] = {
+	/* UART1 */
+	{MX35_PAD_CTS1__UART1_CTS,             },
+	{MX35_PAD_RTS1__UART1_RTS,             },
+	{MX35_PAD_TXD1__UART1_TXD_MUX,         },
+	{MX35_PAD_RXD1__UART1_RXD_MUX,         },
+	/* FEC */
+	{MX35_PAD_FEC_TX_CLK__FEC_TX_CLK,      },
+	{MX35_PAD_FEC_RX_CLK__FEC_RX_CLK,      },
+	{MX35_PAD_FEC_RX_DV__FEC_RX_DV,        },
+	{MX35_PAD_FEC_COL__FEC_COL,},
+	{MX35_PAD_FEC_RDATA0__FEC_RDATA_0,     },
+	{MX35_PAD_FEC_TDATA0__FEC_TDATA_0,     },
+	{MX35_PAD_FEC_TX_EN__FEC_TX_EN,        },
+	{MX35_PAD_FEC_MDC__FEC_MDC,            },
+	{MX35_PAD_FEC_MDIO__FEC_MDIO,          },
+	{MX35_PAD_FEC_TX_ERR__FEC_TX_ERR,      },
+	{MX35_PAD_FEC_RX_ERR__FEC_RX_ERR,      },
+	{MX35_PAD_FEC_CRS__FEC_CRS,            },
+	{MX35_PAD_FEC_RDATA1__FEC_RDATA_1,     },
+	{MX35_PAD_FEC_TDATA1__FEC_TDATA_1,     },
+	{MX35_PAD_FEC_RDATA2__FEC_RDATA_2,     },
+	{MX35_PAD_FEC_TDATA2__FEC_TDATA_2,     },
+	{MX35_PAD_FEC_RDATA3__FEC_RDATA_3,     },
+	{MX35_PAD_FEC_TDATA3__FEC_TDATA_3,     },
+	/* USBOTG */
+	{MX35_PAD_USBOTG_PWR__USB_TOP_USBOTG_PWR,},
+	{MX35_PAD_USBOTG_OC__USB_TOP_USBOTG_OC,  },
+
+	/* SD/MMC-SDHC1 */
+	{MX35_PAD_SD1_CMD__ESDHC1_CMD, MX35_ESDHC1_CMD__PAD_CFG},
+	{MX35_PAD_SD1_CLK__ESDHC1_CLK, MX35_ESDHC1_CLK__PAD_CFG},
+	{MX35_PAD_SD1_DATA0__ESDHC1_DAT0, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD1_DATA1__ESDHC1_DAT1, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD1_DATA2__ESDHC1_DAT2, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD1_DATA3__ESDHC1_DAT3, MX35_ESDHC1_DATA__PAD_CFG},
+#if !defined(CONFIG_SDIO_UNIFI_FS) && !defined(CONFIG_SDIO_UNIFI_FS_MODULE)
+	{MX35_PAD_SD2_CMD__ESDHC1_DAT4, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD2_CLK__ESDHC1_DAT5, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD2_DATA0__ESDHC1_DAT6, MX35_ESDHC1_DATA__PAD_CFG},
+	{MX35_PAD_SD2_DATA1__ESDHC1_DAT7, MX35_ESDHC1_DATA__PAD_CFG},
+#endif
+	/* Capature */
+	{MX35_PAD_CAPTURE__GPIO1_4,},
+};
+
+/* OTG config */
+static struct fsl_usb2_platform_data usb_pdata = {
+	.operating_mode	= FSL_USB2_DR_DEVICE,
+	.phy_mode	= FSL_USB2_PHY_UTMI_WIDE,
+};
+
+/*
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads_ext(mx35pdk_pads,
+						ARRAY_SIZE(mx35pdk_pads));
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+	imx35_add_imx_uart0(&uart_pdata);
+	imx35_add_imx_uart1(&uart_pdata);
+	imx35_add_imx_uart2(&uart_pdata);
+
+	imx35_add_spi_imx0(&spi_pdata);
+	imx35_add_spi_imx1(&spi_pdata);
+
+	mxc_register_device(&mxc_otg_udc_device, &usb_pdata);
+
+	mxc_register_device(&mxc_nor_mtd_device, &mxc_nor_flash_pdata);
+
+	mxc_register_nandv2_devices();
+
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+	imx35_add_imx_i2c0(&i2c_data);
+
+	mx35_3stack_init_mc13892();
+	mx35_3stack_init_mc9s08dz60();
+
+	imx35_add_imx_mmc0(&mmc1_data);
+
+	if (mxc_expio_init(CS5_BASE_ADDR, EXPIO_PARENT_INT))
+		printk(KERN_WARNING "Init of the debugboard failed, all "
+				   "devices on the board are unusable.\n");
+}
+
+static void __init mx35pdk_timer_init(void)
+{
+	mx35_clocks_init();
+}
+
+struct sys_timer mx35pdk_timer = {
+	.init	= mx35pdk_timer_init,
+};
+
+MACHINE_START(MX35_3DS, "Freescale MX35PDK")
+	/* Maintainer: Freescale Semiconductor, Inc */
+	.phys_io	= MX35_AIPS1_BASE_ADDR,
+	.io_pg_offst	= ((MX35_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params    = MX3x_PHYS_OFFSET + 0x100,
+	.map_io         = mx35_map_io,
+	.init_irq       = mx35_init_irq,
+	.init_machine   = mxc_board_init,
+	.timer          = &mx35pdk_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx3/mach-mx35pdk.c b/arch/arm/mach-mx3/mach-mx35pdk.c
deleted file mode 100644
index bcac84d..0000000
--- a/arch/arm/mach-mx3/mach-mx35pdk.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * Author: Fabio Estevam <fabio.estevam@freescale.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/memory.h>
-#include <linux/gpio.h>
-#include <linux/fsl_devices.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/time.h>
-#include <asm/mach/map.h>
-
-#include <mach/hardware.h>
-#include <mach/common.h>
-#include <mach/imx-uart.h>
-#include <mach/iomux-mx35.h>
-
-#include "devices.h"
-
-static struct imxuart_platform_data uart_pdata = {
-	.flags = IMXUART_HAVE_RTSCTS,
-};
-
-static struct platform_device *devices[] __initdata = {
-	&mxc_fec_device,
-};
-
-static struct pad_desc mx35pdk_pads[] = {
-	/* UART1 */
-	MX35_PAD_CTS1__UART1_CTS,
-	MX35_PAD_RTS1__UART1_RTS,
-	MX35_PAD_TXD1__UART1_TXD_MUX,
-	MX35_PAD_RXD1__UART1_RXD_MUX,
-	/* FEC */
-	MX35_PAD_FEC_TX_CLK__FEC_TX_CLK,
-	MX35_PAD_FEC_RX_CLK__FEC_RX_CLK,
-	MX35_PAD_FEC_RX_DV__FEC_RX_DV,
-	MX35_PAD_FEC_COL__FEC_COL,
-	MX35_PAD_FEC_RDATA0__FEC_RDATA_0,
-	MX35_PAD_FEC_TDATA0__FEC_TDATA_0,
-	MX35_PAD_FEC_TX_EN__FEC_TX_EN,
-	MX35_PAD_FEC_MDC__FEC_MDC,
-	MX35_PAD_FEC_MDIO__FEC_MDIO,
-	MX35_PAD_FEC_TX_ERR__FEC_TX_ERR,
-	MX35_PAD_FEC_RX_ERR__FEC_RX_ERR,
-	MX35_PAD_FEC_CRS__FEC_CRS,
-	MX35_PAD_FEC_RDATA1__FEC_RDATA_1,
-	MX35_PAD_FEC_TDATA1__FEC_TDATA_1,
-	MX35_PAD_FEC_RDATA2__FEC_RDATA_2,
-	MX35_PAD_FEC_TDATA2__FEC_TDATA_2,
-	MX35_PAD_FEC_RDATA3__FEC_RDATA_3,
-	MX35_PAD_FEC_TDATA3__FEC_TDATA_3,
-	/* USBOTG */
-	MX35_PAD_USBOTG_PWR__USB_TOP_USBOTG_PWR,
-	MX35_PAD_USBOTG_OC__USB_TOP_USBOTG_OC,
-};
-
-/* OTG config */
-static struct fsl_usb2_platform_data usb_pdata = {
-	.operating_mode	= FSL_USB2_DR_DEVICE,
-	.phy_mode	= FSL_USB2_PHY_UTMI_WIDE,
-};
-
-/*
- * Board specific initialization.
- */
-static void __init mxc_board_init(void)
-{
-	mxc_iomux_v3_setup_multiple_pads(mx35pdk_pads, ARRAY_SIZE(mx35pdk_pads));
-
-	platform_add_devices(devices, ARRAY_SIZE(devices));
-
-	mxc_register_device(&mxc_uart_device0, &uart_pdata);
-
-	mxc_register_device(&mxc_otg_udc_device, &usb_pdata);
-}
-
-static void __init mx35pdk_timer_init(void)
-{
-	mx35_clocks_init();
-}
-
-struct sys_timer mx35pdk_timer = {
-	.init	= mx35pdk_timer_init,
-};
-
-MACHINE_START(MX35_3DS, "Freescale MX35PDK")
-	/* Maintainer: Freescale Semiconductor, Inc */
-	.phys_io	= MX35_AIPS1_BASE_ADDR,
-	.io_pg_offst	= ((MX35_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
-	.boot_params    = MX3x_PHYS_OFFSET + 0x100,
-	.map_io         = mx35_map_io,
-	.init_irq       = mx35_init_irq,
-	.init_machine   = mxc_board_init,
-	.timer          = &mx35pdk_timer,
-MACHINE_END
diff --git a/arch/arm/mach-mx3/mx31_sdma_script_code_v1.h b/arch/arm/mach-mx3/mx31_sdma_script_code_v1.h
new file mode 100644
index 0000000..fd9967f
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31_sdma_script_code_v1.h
@@ -0,0 +1,581 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __MX31_SDMA_SCRIPT_CODE_V1_H__
+#define __MX31_SDMA_SCRIPT_CODE_V1_H__
+
+/*!
+* Following define start address of start script
+*/
+#define mx31_start_ADDR	0
+/*!
+* Following define size of start script
+*/
+#define mx31_start_SIZE	21
+
+/*!
+* Following define start address of core script
+*/
+#define mx31_core_ADDR	80
+/*!
+* Following define size of core script
+*/
+#define mx31_core_SIZE	152
+
+/*!
+* Following define start address of common script
+*/
+#define mx31_common_ADDR	232
+/*!
+* Following define size of common script
+*/
+#define mx31_common_SIZE	191
+
+/*!
+* Following define start address of burst_copy script
+*/
+#define mx31_burst_copy_ADDR	423
+/*!
+* Following define size of burst_copy script
+*/
+#define mx31_burst_copy_SIZE	87
+
+/*!
+* Following define start address of dsp_2_burst script
+*/
+#define mx31_dsp_2_burst_ADDR	510
+/*!
+* Following define size of dsp_2_burst script
+*/
+#define mx31_dsp_2_burst_SIZE	24
+
+/*!
+* Following define start address of burst_2_dsp script
+*/
+#define mx31_burst_2_dsp_ADDR	534
+/*!
+* Following define size of burst_2_dsp script
+*/
+#define mx31_burst_2_dsp_SIZE	24
+
+/*!
+* Following define start address of dsp_copy script
+*/
+#define mx31_dsp_copy_ADDR	558
+/*!
+* Following define size of dsp_copy script
+*/
+#define mx31_dsp_copy_SIZE	86
+
+/*!
+* Following define start address of mcu_2_mcu script
+*/
+#define mx31_mcu_2_mcu_ADDR	644
+/*!
+* Following define size of mcu_2_mcu script
+*/
+#define mx31_mcu_2_mcu_SIZE	79
+
+/*!
+* Following define start address of mcu_2_per script
+*/
+#define mx31_mcu_2_per_ADDR	723
+/*!
+* Following define size of mcu_2_per script
+*/
+#define mx31_mcu_2_per_SIZE	88
+
+/*!
+* Following define start address of test script
+*/
+#define mx31_test_ADDR	811
+/*!
+* Following define size of test script
+*/
+#define mx31_test_SIZE	63
+
+/*!
+* Following define start address of mcu_2_dsp script
+*/
+#define mx31_mcu_2_dsp_ADDR	874
+/*!
+* Following define size of mcu_2_dsp script
+*/
+#define mx31_mcu_2_dsp_SIZE	30
+
+/*!
+* Following define start address of mcu_2_dsp_2buf script
+*/
+#define mx31_mcu_2_dsp_2buf_ADDR	904
+/*!
+* Following define size of mcu_2_dsp_2buf script
+*/
+#define mx31_mcu_2_dsp_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_mcu script
+*/
+#define mx31_dsp_2_mcu_ADDR	1017
+/*!
+* Following define size of dsp_2_mcu script
+*/
+#define mx31_dsp_2_mcu_SIZE	30
+
+/*!
+* Following define start address of dsp_2_mcu_2buf script
+*/
+#define mx31_dsp_2_mcu_2buf_ADDR	1047
+/*!
+* Following define size of dsp_2_mcu_2buf script
+*/
+#define mx31_dsp_2_mcu_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_dsp script
+*/
+#define mx31_dsp_2_dsp_ADDR	1160
+/*!
+* Following define size of dsp_2_dsp script
+*/
+#define mx31_dsp_2_dsp_SIZE	64
+
+/*!
+* Following define start address of per_2_mcu script
+*/
+#define mx31_per_2_mcu_ADDR	1224
+/*!
+* Following define size of per_2_mcu script
+*/
+#define mx31_per_2_mcu_SIZE	121
+
+/*!
+* Following define start address of dsp_2_per_2buf script
+*/
+#define mx31_dsp_2_per_2buf_ADDR	1345
+/*!
+* Following define size of dsp_2_per_2buf script
+*/
+#define mx31_dsp_2_per_2buf_SIZE	164
+
+/*!
+* Following define start address of per_2_dsp_2buf script
+*/
+#define mx31_per_2_dsp_2buf_ADDR	1509
+/*!
+* Following define size of per_2_dsp_2buf script
+*/
+#define mx31_per_2_dsp_2buf_SIZE	168
+
+/*!
+* Following define start address of per_2_per script
+*/
+#define mx31_per_2_per_ADDR	1677
+/*!
+* Following define size of per_2_per script
+*/
+#define mx31_per_2_per_SIZE	67
+
+/*!
+* Following define start address of error_dsp script
+*/
+#define mx31_error_dsp_ADDR	1744
+/*!
+* Following define size of error_dsp script
+*/
+#define mx31_error_dsp_SIZE	34
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define mx31_ap_2_ap_ADDR	6144
+/*!
+* Following define size of ap_2_ap script
+*/
+#define mx31_ap_2_ap_SIZE	294
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define mx31_app_2_mcu_ADDR	6438
+/*!
+* Following define size of app_2_mcu script
+*/
+#define mx31_app_2_mcu_SIZE	101
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define mx31_ata_2_mcu_ADDR	6539
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define mx31_ata_2_mcu_SIZE	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define mx31_dptc_dvfs_ADDR	6649
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define mx31_dptc_dvfs_SIZE	274
+
+/*!
+* Following define start address of error script
+*/
+#define mx31_error_ADDR	6923
+/*!
+* Following define size of error script
+*/
+#define mx31_error_SIZE	73
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define mx31_firi_2_mcu_ADDR	6996
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define mx31_firi_2_mcu_SIZE	114
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mx31_mcu_2_app_ADDR	7110
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mx31_mcu_2_app_SIZE	127
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mx31_mcu_2_ata_ADDR	7237
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mx31_mcu_2_ata_SIZE	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mx31_mcu_2_firi_ADDR	7324
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mx31_mcu_2_firi_SIZE	77
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mx31_mcu_2_mshc_ADDR	7401
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mx31_mcu_2_mshc_SIZE	48
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mx31_mcu_2_shp_ADDR	7449
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mx31_mcu_2_shp_SIZE	123
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mx31_mshc_2_mcu_ADDR	7572
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mx31_mshc_2_mcu_SIZE	60
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define mx31_shp_2_mcu_ADDR	7632
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define mx31_shp_2_mcu_SIZE	101
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define mx31_uart_2_mcu_ADDR	7733
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define mx31_uart_2_mcu_SIZE	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define mx31_uartsh_2_mcu_ADDR	7838
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define mx31_uartsh_2_mcu_SIZE	98
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define MX31_RAM_CODE_START_ADDR	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define MX31_RAM_CODE_SIZE	1792
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM.
+* This is required to start on a 4-byte aligned boundary on some platforms
+* for SDMA to work properly.
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static short mx31_sdma_code[] = {
+	0xc0ec, 0x7d59, 0x0970, 0x0111, 0x5111, 0x5ad1, 0x5bd9, 0xc0fe,
+	0x5ce1, 0x7d02, 0x0200, 0x9806, 0x08ff, 0x0011, 0x28ff, 0x00bc,
+	0x05df, 0x7d4b, 0x06df, 0x7d2f, 0x6dc5, 0x6ed5, 0x5ef1, 0x0288,
+	0xd81a, 0x9854, 0x0b04, 0x00d3, 0x7d20, 0x06a5, 0x3e03, 0x3d03,
+	0x03a5, 0x3b03, 0x008b, 0x058b, 0x7802, 0x63d8, 0x0000, 0x7e72,
+	0x63ff, 0x7e70, 0x02a5, 0x008a, 0x4e00, 0x7d01, 0x983d, 0x6dcf,
+	0x6edf, 0x0015, 0x0015, 0x7802, 0x63d8, 0x0000, 0x7e63, 0x63ff,
+	0x7e61, 0x3a03, 0x008a, 0x6dcd, 0x6edd, 0x7801, 0x63d8, 0x7e5a,
+	0x63ff, 0x7e58, 0x0006, 0x6dc5, 0x6e07, 0x5ef1, 0x0288, 0xd8f7,
+	0x7e02, 0x7f04, 0x9854, 0x0007, 0x68cc, 0x6b28, 0x54e1, 0x0089,
+	0xdb13, 0x0188, 0x5ce1, 0x9854, 0x52d1, 0x53d9, 0x54e1, 0xc10d,
+	0x7dad, 0x0200, 0x9800, 0x0200, 0x9800, 0x06df, 0x7d06, 0x6d23,
+	0x6ed5, 0x5ef1, 0x0288, 0xd8cd, 0x9854, 0x5ef1, 0x6e07, 0x6d03,
+	0x0b04, 0x00d3, 0x7d59, 0x06a5, 0x3e03, 0x3d03, 0x4d00, 0x7d09,
+	0x03a5, 0x00a3, 0x0588, 0x008b, 0xd8c9, 0x7ed8, 0x620c, 0x7ed6,
+	0x008d, 0x4e00, 0x7c25, 0x0a20, 0x00da, 0x7c22, 0x6503, 0x3d1f,
+	0x02a5, 0x00a2, 0x0215, 0x0215, 0x6a18, 0x6a28, 0x7fc7, 0x0a20,
+	0x0b08, 0x00da, 0x7c06, 0x6b18, 0x6b28, 0x7fc0, 0x0000, 0x2020,
+	0x9889, 0x0688, 0x0015, 0x0015, 0x6818, 0x6828, 0x7fb7, 0x98c2,
+	0x0007, 0x6a0c, 0x54e1, 0x0089, 0xdb0f, 0x0188, 0x5ce1, 0x9854,
+	0x0b04, 0x00d3, 0x7d21, 0x0389, 0x1b12, 0x048b, 0x0688, 0x0015,
+	0x0015, 0x0588, 0x038c, 0x0a08, 0x05da, 0x008d, 0x7c01, 0x008a,
+	0x05a0, 0x7803, 0x620b, 0x5a03, 0x1b01, 0x7e98, 0x008b, 0x00a4,
+	0x038c, 0x7803, 0x5203, 0x6a0b, 0x1b01, 0x6a28, 0x7f8f, 0x0000,
+	0x4d00, 0x7ce8, 0x008e, 0x3803, 0xd8c9, 0x7e88, 0x620c, 0x7e86,
+	0x9854, 0x7802, 0x6209, 0x6a29, 0x0006, 0x3e03, 0x4e00, 0x7d11,
+	0x0b04, 0x03a6, 0x02db, 0x7d01, 0x038a, 0x02a3, 0x048a, 0x008b,
+	0x7802, 0x6329, 0x6bc8, 0x7ebc, 0x63c8, 0x7ebc, 0x008c, 0x4800,
+	0x7d15, 0x0488, 0x0015, 0x0015, 0x6edf, 0x7803, 0x632b, 0x6bc8,
+	0x0000, 0x7eae, 0x63c8, 0x7eae, 0x008c, 0x3803, 0x6edd, 0x7803,
+	0x6329, 0x6bc8, 0x0000, 0x7ea4, 0x63c8, 0x7ea4, 0x0006, 0x3d03,
+	0x4d00, 0x7d0e, 0x0b04, 0x03a5, 0x02db, 0x7d01, 0x038a, 0x02a3,
+	0x048a, 0x008b, 0x7802, 0x63c8, 0x6b09, 0x7e1e, 0x7f1e, 0x008c,
+	0x0488, 0x0015, 0x0015, 0x6dcf, 0x0288, 0x008a, 0x0d08, 0x02dd,
+	0x7c01, 0x008d, 0x7802, 0x63c8, 0x6b0b, 0x7e0e, 0x6b28, 0x7f0d,
+	0x0000, 0x02dd, 0x7c02, 0x2208, 0x990d, 0x008c, 0x3803, 0x65c0,
+	0x6dc5, 0x7802, 0x63c8, 0x6b09, 0x6b28, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d5e, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x992c, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x993c, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210,
+	0x4a00, 0x7d1c, 0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311,
+	0x53eb, 0x62c8, 0x7e24, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09,
+	0x7f1e, 0x0212, 0x6a09, 0x7f1b, 0x0212, 0x6a09, 0x7f18, 0x2003,
+	0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313, 0x997d, 0x0015, 0x0015,
+	0x7802, 0x62c8, 0x6a0b, 0x997c, 0x0015, 0x7802, 0x62c8, 0x6a0a,
+	0x997c, 0x7802, 0x62c8, 0x6a09, 0x7c02, 0x0000, 0x993a, 0xdb13,
+	0x6a28, 0x7ffd, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7da5, 0x0200,
+	0x992c, 0x0200, 0x9929, 0xc19d, 0xc0ec, 0x7d69, 0x0c70, 0x0411,
+	0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02,
+	0x0200, 0x9994, 0x6d07, 0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff,
+	0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70, 0x0211, 0x552a,
+	0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9, 0x4d00, 0x7c13,
+	0x6928, 0x7f2d, 0x0400, 0x99a5, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e29, 0x6d28,
+	0x7f1e, 0x0000, 0x99a3, 0x1e20, 0x5506, 0x2620, 0x008d, 0x0560,
+	0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a, 0x7f10, 0x4c00,
+	0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000, 0x99ec, 0x0007,
+	0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28, 0x0007, 0x680c,
+	0x0007, 0x54d2, 0x0454, 0x99ef, 0x6928, 0x7ff1, 0x54d2, 0x008a,
+	0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200, 0x9994, 0x0200,
+	0x998c, 0xc0ec, 0x7d72, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1,
+	0x5bc9, 0x028e, 0xc0fe, 0x068a, 0x7c6a, 0x5dd9, 0x5ce1, 0x0bff,
+	0x0311, 0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363,
+	0x7c05, 0x036f, 0x7d27, 0x0374, 0x7c7a, 0x9a71, 0xdb04, 0x3c06,
+	0x4c00, 0x7df7, 0x028f, 0x1a04, 0x6a23, 0x620b, 0x6f23, 0x301f,
+	0x00aa, 0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9a30, 0x048a,
+	0x620b, 0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa,
+	0x048f, 0x1c04, 0x6c07, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e,
+	0x1a5c, 0x9a11, 0x058f, 0x1d0c, 0x6d23, 0x650b, 0x007d, 0x7c01,
+	0x1d08, 0x007c, 0x7c01, 0x1d04, 0x6d23, 0x650b, 0x0488, 0x3c1f,
+	0x0417, 0x0417, 0x0417, 0x0417, 0x059c, 0x6d23, 0x028e, 0x1a34,
+	0x6ad7, 0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28,
+	0x6ad7, 0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065,
+	0x7c02, 0x0101, 0x0025, 0x0400, 0x9a0d, 0x52c1, 0x53c9, 0x54e1,
+	0x0453, 0xc10d, 0x7d95, 0x0200, 0x9a00, 0x0200, 0x99f9, 0x0200,
+	0x9a00, 0x55d9, 0x6d07, 0x54d1, 0x058a, 0x2508, 0x6dc7, 0x0373,
+	0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372, 0x7c04, 0x65c8, 0x6d0b,
+	0x2408, 0x9a86, 0x6cce, 0x65c8, 0x6d0a, 0x2404, 0x6d28, 0x6507,
+	0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8, 0x0334, 0x6bc8, 0x0370,
+	0x7ca9, 0x0c60, 0x0411, 0x04bb, 0x4c00, 0x7da4, 0x0410, 0x1c30,
+	0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d, 0x7c03, 0x047c, 0x7c01,
+	0x9a3a, 0x003b, 0x003a, 0x0039, 0x0058, 0x9ab5, 0x047d, 0x7d03,
+	0x047c, 0x7d01, 0x9a3a, 0x005b, 0xdaf9, 0x1d18, 0x6d23, 0x650b,
+	0x0510, 0x003a, 0x0039, 0x0038, 0x00ad, 0xdb04, 0x0c30, 0x0410,
+	0x04bb, 0x003c, 0x003d, 0x00ac, 0xdaf9, 0x007b, 0x7c04, 0x003d,
+	0x003c, 0x1d0c, 0x9ad6, 0x048f, 0x1c14, 0x6c23, 0x640b, 0x4401,
+	0x7d04, 0x005d, 0x005c, 0x1d0c, 0x9ad6, 0x0310, 0x3b30, 0x4b30,
+	0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c, 0x00ab, 0x6ad7, 0x63c8,
+	0x6d23, 0x650b, 0x0560, 0x7d03, 0x005e, 0xdaed, 0x9a3a, 0x003e,
+	0x0c80, 0x0410, 0x0394, 0xdaed, 0x640b, 0x037f, 0x7d02, 0x1a14,
+	0x9aea, 0x1a0c, 0x6ad7, 0x6cc8, 0x9a3a, 0x0c7f, 0x0410, 0x03b4,
+	0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e, 0x1a04, 0x6ad7, 0x6cc8,
+	0x0006, 0x058f, 0x1d08, 0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d38,
+	0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b, 0x042c, 0x0454, 0x042b,
+	0x6ad7, 0x6cc8, 0x0006, 0x0007, 0x684c, 0x6144, 0x9b1c, 0x0007,
+	0x68cc, 0x61d0, 0x9b1c, 0x0007, 0x680c, 0x680c, 0x6107, 0x6907,
+	0x692b, 0x6928, 0x0007, 0x680c, 0x0d70, 0x0511, 0x5515, 0x55f5,
+	0x01a5, 0x0dff, 0x0512, 0x1dff, 0x0512, 0x04bd, 0x0499, 0x0454,
+	0x0006, 0x08ff, 0x0011, 0x28ff, 0x0006, 0x038c, 0x0eff, 0x0611,
+	0x2eff, 0x03b6, 0x0006, 0x53d6, 0x0398, 0x5bd6, 0x53ee, 0x0398,
+	0x5bee, 0x0006, 0x52de, 0x53e6, 0x54ee, 0x0498, 0x0454, 0x0006,
+	0x50f6, 0x52c6, 0x53ce, 0x54d6, 0x0498, 0x0454, 0x0006, 0x6207,
+	0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff,
+	0x0312, 0x04bb, 0x049a, 0x0006, 0x1e10, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b5b, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70,
+	0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9b6a, 0x0212,
+	0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8,
+	0xdba5, 0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xdbbd, 0x52c0,
+	0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x9b5b, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0xdba5, 0x9b68, 0x0200, 0x9b58, 0x0007, 0x68cc, 0x6a28,
+	0x7f01, 0x9ba3, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b,
+	0x6a28, 0x0007, 0x680c, 0x0454, 0x9b81, 0x05a0, 0x1e08, 0x6ec3,
+	0x0388, 0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5,
+	0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09,
+	0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5,
+	0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d78, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9bcc, 0x6d03, 0x6ed3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9bdc, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a,
+	0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25, 0x620a,
+	0x7e23, 0x9c06, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512,
+	0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70, 0x0311,
+	0x5313, 0x9c21, 0x7802, 0x6209, 0x6ac8, 0x9c20, 0x0015, 0x7802,
+	0x620a, 0x6ac8, 0x9c20, 0x0015, 0x0015, 0x7802, 0x620b, 0x6ac8,
+	0x7c03, 0x0000, 0x55db, 0x9bda, 0x0007, 0x68cc, 0x680c, 0x55d3,
+	0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9c2f, 0x0017, 0x0017, 0x55db,
+	0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8,
+	0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x008b, 0x52c0, 0x53c8, 0xc10d,
+	0x7d8b, 0x0200, 0x9bcc, 0x0200, 0x9bc9, 0xc19d, 0xc0ec, 0x7d52,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x9c4e, 0x6d03, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211, 0x4c00,
+	0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9c61, 0x4c01,
+	0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d, 0x9c5f,
+	0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f, 0x5d06,
+	0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0, 0x0454,
+	0x9c8b, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9, 0x4d00,
+	0x7c02, 0x0400, 0x9c8d, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7db6,
+	0x0200, 0x9c4e, 0x0200, 0x9c46, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9ca2, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62c8,
+	0x7e1f, 0x0400, 0x9cb3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16, 0x6ac8, 0x7f11, 0x0015,
+	0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e, 0x6ac8, 0x7f09, 0x6edf,
+	0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9cb1,
+	0x0007, 0x68cc, 0x9cdd, 0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd, 0x0200, 0x9ca2, 0x0200,
+	0x9c9f, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cf0, 0x0870, 0x0011,
+	0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228,
+	0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9cff, 0x620b, 0x7e06, 0x5a06,
+	0x7f06, 0x0000, 0x2504, 0x7d05, 0x9cff, 0x0007, 0x680c, 0x0007,
+	0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9cf0, 0x0200,
+	0x9cec, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d74, 0x5010, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d20, 0x6d03,
+	0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70, 0x0211, 0x532a, 0x5212,
+	0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9d34, 0x008f, 0x05d8, 0x7d01,
+	0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d27, 0x4d02, 0x7d20,
+	0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea, 0x0260, 0x7d05, 0x6509,
+	0x7e25, 0x630a, 0x7e23, 0x9d58, 0x630a, 0x7e20, 0x6509, 0x7e1e,
+	0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19, 0x2003, 0x4800, 0x7ced,
+	0x0a70, 0x0211, 0x5212, 0x9d73, 0x7802, 0x6309, 0x5b06, 0x9d72,
+	0x0015, 0x7802, 0x630a, 0x5b06, 0x9d72, 0x0015, 0x0015, 0x7802,
+	0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000, 0x9d32, 0x0007, 0x680c,
+	0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9d80, 0x0017, 0x0017,
+	0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d90,
+	0x0200, 0x9d20, 0x0200, 0x9d1c, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d35, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d9b, 0x0870, 0x0011, 0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d1c, 0x5228, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b,
+	0x0400, 0x9daa, 0x5206, 0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000,
+	0x2504, 0x7d0c, 0x9daa, 0x0007, 0x680c, 0x680c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3,
+	0x5010, 0x52c0, 0xc10d, 0x7dcf, 0x0200, 0x9d9b, 0x0200, 0x9d97,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d5e, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dd7, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0a70, 0x0211,
+	0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04, 0x6a28, 0x7f3a, 0x0400,
+	0x9de6, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312,
+	0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02, 0x7d20, 0x4b01, 0x7d23,
+	0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e24, 0x0260, 0x7d02, 0x0310,
+	0x0312, 0x6b09, 0x7f1e, 0x0312, 0x6b09, 0x7f1b, 0x0312, 0x6b09,
+	0x7f18, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e27,
+	0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b, 0x9e26, 0x0015, 0x7802,
+	0x5306, 0x6b0a, 0x9e26, 0x7802, 0x5306, 0x6b09, 0x7c02, 0x0000,
+	0x9de4, 0xdb13, 0x6928, 0x7ffd, 0x008a, 0x52c0, 0x53c8, 0xc10d,
+	0x7da6, 0x0200, 0x9dd7, 0x0200, 0x9dd3, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d5b, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9e3b, 0x0b70, 0x0311, 0x6ec3, 0x6d07, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3d, 0x522b, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f33, 0x0400, 0x9e4d, 0x028e, 0x1a94, 0x6ac3,
+	0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3, 0x6ed3, 0x62c8, 0x0248,
+	0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e, 0x7d31, 0x6a09, 0x7f1e,
+	0x2501, 0x4d00, 0x7d1f, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3,
+	0x0260, 0x7df1, 0x6a28, 0x7f12, 0xdb47, 0x9e8c, 0x6ee3, 0x008f,
+	0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17,
+	0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e4b, 0x0289, 0xdb13,
+	0x018a, 0x9e9b, 0x6a28, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0,
+	0x53c8, 0xc10d, 0x7da8, 0x0200, 0x9e3b, 0x0200, 0x9e38, 0x6a28,
+	0x7fed, 0xdb47, 0x9e9b, 0x0458, 0x0454, 0x9e8c, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d54, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9ea5, 0x0b70, 0x0311, 0x6d07, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d36, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x6928, 0x7f2c, 0x0400, 0x9eb6, 0x028e, 0x1a94,
+	0x5202, 0x0269, 0x7d16, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694,
+	0x5206, 0x026e, 0x7d2e, 0x6a09, 0x7f1b, 0x2501, 0x4d00, 0x7d1c,
+	0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6a28, 0x7f11, 0xdb47,
+	0x9eee, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206,
+	0x026e, 0x7d17, 0x6a09, 0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9eb4,
+	0x0289, 0xdb13, 0x018a, 0x9efd, 0x6928, 0x7ffa, 0x0b70, 0x0311,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7db0, 0x0200, 0x9ea5, 0x0200,
+	0x9ea1, 0x6a28, 0x7fed, 0xdb47, 0x9efd, 0x0458, 0x0454, 0x9eee,
+	0x9eee
+};
+#endif
diff --git a/arch/arm/mach-mx3/mx31_sdma_script_code_v2.h b/arch/arm/mach-mx3/mx31_sdma_script_code_v2.h
new file mode 100644
index 0000000..a003b94
--- /dev/null
+++ b/arch/arm/mach-mx3/mx31_sdma_script_code_v2.h
@@ -0,0 +1,371 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS15_MX31"
+
+*******************************************************************************/
+
+#ifndef __MX31_SDMA_SCRIPT_CODE_V2_H__
+#define __MX31_SDMA_SCRIPT_CODE_V2_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define mx31_start_ADDR_2	0
+#define mx31_start_SIZE_2	20
+
+#define mx31_core_ADDR_2	80
+#define mx31_core_SIZE_2	152
+
+#define mx31_common_ADDR_2	232
+#define mx31_common_SIZE_2	191
+
+#define mx31_ap_2_ap_ADDR_2	423
+#define mx31_ap_2_ap_SIZE_2	294
+
+#define mx31_bp_2_bp_ADDR_2	717
+#define mx31_bp_2_bp_SIZE_2	112
+
+#define mx31_ap_2_bp_ADDR_2	829
+#define mx31_ap_2_bp_SIZE_2	200
+
+#define mx31_bp_2_ap_ADDR_2	1029
+#define mx31_bp_2_ap_SIZE_2	223
+
+#define mx31_app_2_mcu_ADDR_2	6212
+#define mx31_app_2_mcu_SIZE_2	104
+
+#define mx31_mcu_2_app_ADDR_2	6735
+#define mx31_mcu_2_app_SIZE_2	129
+
+#define mx31_uart_2_mcu_ADDR_2	7736
+#define mx31_uart_2_mcu_SIZE_2	106
+
+#define mx31_uartsh_2_mcu_ADDR_2 7842
+#define mx31_uartsh_2_mcu_SIZE_2 99
+
+#define mx31_mcu_2_shp_ADDR_2	7076
+#define mx31_mcu_2_shp_SIZE_2	125
+
+#define mx31_shp_2_mcu_ADDR_2	7523
+#define mx31_shp_2_mcu_SIZE_2	104
+
+#define mx31_error_ADDR_2	1907
+#define mx31_error_SIZE_2	73
+
+#define mx31_test_ADDR_2	1980
+#define mx31_test_SIZE_2	63
+
+#define mx31_signature_ADDR_2	1023
+#define mx31_signature_SIZE_2	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define mx31_ap_2_ap_fixed_addr_ADDR_2	6144
+#define mx31_ap_2_ap_fixed_addr_SIZE_2	68
+
+#define mx31_app_2_per_ADDR_2	6316
+#define mx31_app_2_per_SIZE_2	105
+
+#define mx31_ata_2_mcu_ADDR_2	6421
+#define mx31_ata_2_mcu_SIZE_2	110
+
+#define mx31_firi_2_mcu_ADDR_2	6531
+#define mx31_firi_2_mcu_SIZE_2	114
+
+#define mx31_loop_DMAs_fixed_addr_ADDR_2	6645
+#define mx31_loop_DMAs_fixed_addr_SIZE_2	90
+
+#define mx31_mcu_2_ata_ADDR_2	6864
+#define mx31_mcu_2_ata_SIZE_2	87
+
+#define mx31_mcu_2_firi_ADDR_2	6951
+#define mx31_mcu_2_firi_SIZE_2	77
+
+#define mx31_mcu_2_mshc_ADDR_2	7028
+#define mx31_mcu_2_mshc_SIZE_2	48
+
+#define mx31_mshc_2_mcu_ADDR_2	7201
+#define mx31_mshc_2_mcu_SIZE_2	60
+
+#define mx31_per_2_app_ADDR_2	7261
+#define mx31_per_2_app_SIZE_2	131
+
+#define mx31_per_2_shp_ADDR_2	7392
+#define mx31_per_2_shp_SIZE_2	131
+
+#define mx31_shp_2_per_ADDR_2	7627
+#define mx31_shp_2_per_SIZE_2	109
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define MX31_RAM_CODE_START_ADDR_2	6144
+#define MX31_RAM_CODE_SIZE_2		1797
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short mx31_sdma_code_2[] = {
+	0x0970, 0x0111, 0x5111, 0x5ef9, 0xc0ec, 0x7d23, 0x5ad1, 0x5bd9,
+	0xc0fe, 0x7c1f, 0x5ce1, 0x5de9, 0x5ef1, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x048e, 0x56f9, 0x0660, 0x7d05, 0x0661, 0x7c2b, 0x6c07,
+	0x6d13, 0x9821, 0x0661, 0x7d26, 0x6c17, 0x6d03, 0x028d, 0x058c,
+	0x048a, 0xd9f5, 0x7e08, 0x7f07, 0x54e1, 0x52d1, 0x53d9, 0xc10d,
+	0x7dde, 0x0200, 0x9804, 0x0660, 0x7d03, 0x6007, 0x52f1, 0x9832,
+	0x6003, 0x52e9, 0x00a2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07,
+	0x6a2b, 0x6a28, 0x0007, 0x6a0c, 0x54e1, 0xc795, 0x048b, 0x0498,
+	0x0454, 0x9825, 0x0800, 0x983c, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d61, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x984a, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d45, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x6a28, 0x7f3b, 0x0400, 0x985a, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d1c,
+	0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311, 0x53eb, 0x62c8,
+	0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09, 0x7f1f, 0x0212,
+	0x6a09, 0x7f1c, 0x0212, 0x6a09, 0x7f19, 0x2003, 0x4800, 0x7cef,
+	0x0b70, 0x0311, 0x5313, 0x989b, 0x0015, 0x0015, 0x7802, 0x62c8,
+	0x6a0b, 0x989a, 0x0015, 0x7802, 0x62c8, 0x6a0a, 0x989a, 0x7802,
+	0x62c8, 0x6a09, 0x7c03, 0x6a28, 0x0000, 0x9858, 0xc77b, 0x6a28,
+	0x7ffd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da2,
+	0x0200, 0x984a, 0x0200, 0x9847, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d62, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x98b2, 0x6ec3, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d46, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9, 0x4a00,
+	0x7c04, 0x62ff, 0x7e3c, 0x0400, 0x98c2, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210, 0x4a00, 0x7d28,
+	0x4a02, 0x7d20, 0x4a01, 0x7d19, 0x6ddd, 0x0b70, 0x0311, 0x53eb,
+	0x62c8, 0x7e25, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6ac8, 0x7f1f,
+	0x0212, 0x6ac8, 0x7f1c, 0x0212, 0x6ac8, 0x7f19, 0x2003, 0x4800,
+	0x7cef, 0x0b70, 0x0311, 0x5313, 0x9905, 0x6ddd, 0x7802, 0x62c8,
+	0x6ac8, 0x9904, 0x6dde, 0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9904,
+	0x0015, 0x0015, 0x7801, 0x62d8, 0x7c02, 0x0000, 0x98c0, 0xc777,
+	0x62ff, 0x7efd, 0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d,
+	0x7da1, 0x0200, 0x98b2, 0x0200, 0x98af, 0xc19d, 0xc0ec, 0x7d69,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x991e, 0x6d07, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70,
+	0x0211, 0x552a, 0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9,
+	0x4d00, 0x7c13, 0x6928, 0x7f2d, 0x0400, 0x992f, 0x008f, 0x0015,
+	0x04d8, 0x7d01, 0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b,
+	0x7e29, 0x6d28, 0x7f1e, 0x0000, 0x992d, 0x1e20, 0x5506, 0x2620,
+	0x008d, 0x0560, 0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a,
+	0x7f10, 0x4c00, 0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000,
+	0x9976, 0x0007, 0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28,
+	0x0007, 0x680c, 0x0007, 0x54d2, 0x0454, 0x9979, 0x6928, 0x7ff1,
+	0x54d2, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200,
+	0x991e, 0x0200, 0x9916, 0x1e10, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x998a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70, 0x0311,
+	0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9999, 0x0212, 0x3aff,
+	0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8, 0xd9d4,
+	0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xd9ec, 0x52c0, 0x53c8,
+	0xc10d, 0x7dd0, 0x0200, 0x998a, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0xd9d4, 0x9997, 0x0200, 0x9987, 0x0007, 0x68cc, 0x6a28, 0x7f01,
+	0x99d2, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b, 0x6a28,
+	0x0007, 0x680c, 0x0454, 0x99b0, 0x05a0, 0x1e08, 0x6ec3, 0x0388,
+	0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5, 0x6a28,
+	0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09, 0x7edc,
+	0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5, 0x0dff,
+	0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0388, 0x028d, 0x3a03,
+	0x4a00, 0x7c33, 0x028c, 0x3a03, 0x4a00, 0x7d0c, 0x0804, 0x00a2,
+	0x00db, 0x7d24, 0x03a0, 0x0498, 0x7802, 0x6209, 0x6a29, 0x7e24,
+	0x620c, 0x7e22, 0x0804, 0x03d0, 0x7d19, 0x0820, 0x028c, 0x3a1f,
+	0x00a2, 0x03d0, 0x7c02, 0x008b, 0x3003, 0x03a0, 0x0015, 0x0015,
+	0x6818, 0x7e12, 0x6828, 0x7f10, 0x0000, 0x0820, 0x03d8, 0x7df5,
+	0x0804, 0x03d0, 0x7d03, 0x008b, 0x3003, 0x9a15, 0x008b, 0x7802,
+	0x6209, 0x6a29, 0x7e01, 0x620c, 0x0006, 0x0804, 0x03d0, 0x7df6,
+	0x048b, 0x3403, 0x03a4, 0x0415, 0x0415, 0x0d0f, 0x0511, 0x1df0,
+	0x0808, 0x04d0, 0x7c01, 0x008c, 0x58c1, 0x04a0, 0x7803, 0x620b,
+	0x5a05, 0x1d01, 0x7ee9, 0x50c1, 0x05a0, 0x7803, 0x5205, 0x6a0b,
+	0x1d01, 0x6a28, 0x7fe1, 0x0000, 0x4c00, 0x7ce7, 0x9a26, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d7a, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9a55, 0x6d03, 0x6ed3, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b,
+	0x5313, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9a65,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512,
+	0x05bc, 0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01,
+	0x7d1a, 0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25,
+	0x620a, 0x7e23, 0x9a8f, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512,
+	0x0512, 0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70,
+	0x0311, 0x5313, 0x9aaa, 0x7802, 0x6209, 0x6ac8, 0x9aa9, 0x0015,
+	0x7802, 0x620a, 0x6ac8, 0x9aa9, 0x0015, 0x0015, 0x7802, 0x620b,
+	0x6ac8, 0x7c03, 0x0000, 0x55db, 0x9a63, 0x0007, 0x68cc, 0x680c,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9ab8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d89, 0x0200, 0x9a55, 0x0200, 0x9a52,
+	0xc19d, 0xc0ec, 0x7d52, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c,
+	0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9ad9, 0x6d03,
+	0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da,
+	0x0a70, 0x0211, 0x4c00, 0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02,
+	0x0400, 0x9aec, 0x4c01, 0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x0020, 0x04a0, 0x0015, 0x7802, 0x650b, 0x5d06, 0x0000,
+	0x7e0c, 0x7f0d, 0x9aea, 0x650a, 0x7e08, 0x008d, 0x0011, 0x0010,
+	0x05a8, 0x065f, 0x5d06, 0x063f, 0x7f02, 0x0007, 0x680c, 0x0007,
+	0x5012, 0x54d0, 0x0454, 0x9b16, 0x5012, 0x54d0, 0x0473, 0x7c06,
+	0x552a, 0x05b9, 0x4d00, 0x7c02, 0x0400, 0x9b18, 0x52c0, 0x53c8,
+	0xc10d, 0x0288, 0x7db6, 0x0200, 0x9ad9, 0x0200, 0x9ad1, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d46, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9b2d, 0x0b70, 0x0311, 0x6ed3, 0x6d03,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d2b, 0x522b, 0x02b9,
+	0x4a00, 0x7c04, 0x62c8, 0x7e1f, 0x0400, 0x9b3e, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x0060, 0x7c05, 0x6edd, 0x6209, 0x7e16,
+	0x6ac8, 0x7f11, 0x0015, 0x0060, 0x7c05, 0x6ede, 0x620a, 0x7e0e,
+	0x6ac8, 0x7f09, 0x6edf, 0x0015, 0x7802, 0x620b, 0x6ac8, 0x0000,
+	0x7e05, 0x7f01, 0x9b3c, 0x0007, 0x68cc, 0x9b68, 0x0007, 0x6a0c,
+	0x0454, 0x62c8, 0x7ef8, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7dbd,
+	0x0200, 0x9b2d, 0x0200, 0x9b2a, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9b7b, 0x0870, 0x0011, 0x6d03, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9b8a,
+	0x620b, 0x7e06, 0x5a06, 0x7f06, 0x0000, 0x2504, 0x7d05, 0x9b8a,
+	0x0007, 0x680c, 0x0007, 0x0454, 0x5010, 0x52c0, 0xc10d, 0x7ddb,
+	0x0200, 0x9b7b, 0x0200, 0x9b77, 0xc19d, 0x0870, 0x0011, 0xc0ec,
+	0x7d76, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9bab, 0x6d03, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d57, 0x0a70,
+	0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02, 0x0400, 0x9bbf,
+	0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x5dda, 0x55d2, 0x4d00,
+	0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a, 0x0a70, 0x0211, 0x52ea,
+	0x0260, 0x7d05, 0x6509, 0x7e25, 0x630a, 0x7e23, 0x9be3, 0x630a,
+	0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512, 0x03ad, 0x5b06, 0x7f19,
+	0x2003, 0x4800, 0x7ced, 0x0a70, 0x0211, 0x5212, 0x9bfe, 0x7802,
+	0x6309, 0x5b06, 0x9bfd, 0x0015, 0x7802, 0x630a, 0x5b06, 0x9bfd,
+	0x0015, 0x0015, 0x7802, 0x630b, 0x5b06, 0x7c03, 0x55da, 0x0000,
+	0x9bbd, 0x0007, 0x680c, 0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02,
+	0x9c0b, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff,
+	0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454, 0x0870, 0x0011,
+	0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d8e, 0x0200, 0x9bab, 0x0200,
+	0x9ba7, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9c28, 0x0870, 0x0011,
+	0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c, 0x5228,
+	0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9c37, 0x5206,
+	0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9c37,
+	0x0007, 0x680c, 0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007,
+	0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0, 0xc10d,
+	0x7dcf, 0x0200, 0x9c28, 0x0200, 0x9c24, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d7c, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9c63, 0x6ed3, 0x6dc5, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d60, 0x0b70, 0x0311, 0x522b, 0x5313, 0x02b9,
+	0x4a00, 0x7c02, 0x0400, 0x9c73, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc, 0x0510, 0x5dd3, 0x4d00,
+	0x7d2c, 0x4d02, 0x7d24, 0x4d01, 0x7d1e, 0x59e3, 0x0b70, 0x0311,
+	0x53eb, 0x61c8, 0x7e2b, 0x62c8, 0x7e29, 0x65c8, 0x7e27, 0x0360,
+	0x7d03, 0x0112, 0x0112, 0x9c9e, 0x0512, 0x0512, 0x0211, 0x02a9,
+	0x02ad, 0x6ac8, 0x7f1b, 0x2003, 0x4800, 0x7ceb, 0x0b70, 0x0311,
+	0x5313, 0x51e3, 0x9cbb, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dce,
+	0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9cba, 0x6dcf, 0x0015, 0x0015,
+	0x7801, 0x62d8, 0x7c03, 0x0000, 0x55db, 0x9c71, 0x0007, 0x68ff,
+	0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9cc8, 0x0017, 0x0017,
+	0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010,
+	0x04b8, 0x04ad, 0x0454, 0x62c8, 0x7ee9, 0x0870, 0x0011, 0x5010,
+	0x52c0, 0x53c8, 0xc10d, 0x7d87, 0x0200, 0x9c63, 0x0200, 0x9c60,
+	0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d7c, 0x5010, 0x5ac0, 0x5bc8,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ce7, 0x6dc5, 0x0d03,
+	0x0512, 0x05bc, 0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x5df8, 0x4d00, 0x7d5d, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9,
+	0x4b00, 0x7c02, 0x0400, 0x9cfb, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x5dda, 0x55d2, 0x4d00, 0x7d2c, 0x4d02, 0x7d24, 0x4d01,
+	0x7d1e, 0x59e2, 0x0a70, 0x0211, 0x52ea, 0x61c8, 0x7e2c, 0x63c8,
+	0x7e2a, 0x65c8, 0x7e28, 0x0260, 0x7d03, 0x0112, 0x0112, 0x9d22,
+	0x0512, 0x0512, 0x0311, 0x03a9, 0x03ad, 0x5b06, 0x7f1c, 0x2003,
+	0x4800, 0x7ceb, 0x0a70, 0x0211, 0x5212, 0x51e2, 0x9d40, 0x7802,
+	0x63c8, 0x5b06, 0x9d3f, 0x6dce, 0x0015, 0x7802, 0x63c8, 0x5b06,
+	0x9d3f, 0x6dcf, 0x0015, 0x0015, 0x7802, 0x63c8, 0x5b06, 0x7c03,
+	0x55da, 0x0000, 0x9cf9, 0x0007, 0x68ff, 0x55d2, 0x4d00, 0x7d03,
+	0x4d02, 0x7d02, 0x9d4d, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa,
+	0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7d88, 0x0200,
+	0x9ce7, 0x0200, 0x9ce3, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d61,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9d6a, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d45, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c04,
+	0x6a28, 0x7f3b, 0x0400, 0x9d79, 0x008f, 0x05d8, 0x7d01, 0x008d,
+	0x05a0, 0x0b03, 0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d1c, 0x4b02,
+	0x7d20, 0x4b01, 0x7d23, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e25,
+	0x0260, 0x7d02, 0x0310, 0x0312, 0x6b09, 0x7f1f, 0x0312, 0x6b09,
+	0x7f1c, 0x0312, 0x6b09, 0x7f19, 0x2003, 0x4800, 0x7cef, 0x0a70,
+	0x0211, 0x5212, 0x9dba, 0x0015, 0x0015, 0x7802, 0x5306, 0x6b0b,
+	0x9db9, 0x0015, 0x7802, 0x5306, 0x6b0a, 0x9db9, 0x7802, 0x5306,
+	0x6b09, 0x7c03, 0x6b28, 0x0000, 0x9d77, 0xc77b, 0x6928, 0x7ffd,
+	0x0870, 0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da3, 0x0200,
+	0x9d6a, 0x0200, 0x9d66, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d60,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9dd2, 0x6dd7, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d46, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02,
+	0x0400, 0x9de1, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03,
+	0x0312, 0x03bc, 0x0310, 0x4b00, 0x7d28, 0x4b02, 0x7d20, 0x4b01,
+	0x7d19, 0x6ddd, 0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e27, 0x0260,
+	0x7d02, 0x0310, 0x0312, 0x6bc8, 0x7f21, 0x0312, 0x6bc8, 0x7f1e,
+	0x0312, 0x6bc8, 0x7f1b, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211,
+	0x5212, 0x9e23, 0x6ddd, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x6dde,
+	0x0015, 0x7802, 0x5306, 0x6bc8, 0x9e22, 0x0015, 0x0015, 0x7802,
+	0x5306, 0x6bc8, 0x7c03, 0x0000, 0xde32, 0x9ddf, 0xc777, 0x0870,
+	0x0011, 0x5010, 0x52c0, 0x53c8, 0xc10d, 0x7da4, 0x0200, 0x9dd2,
+	0x0200, 0x9dce, 0x63ff, 0x0368, 0x7d02, 0x0369, 0x7def, 0x0006,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d5c, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9e3e, 0x0b70, 0x0311, 0x6ec3,
+	0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d3e,
+	0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f34, 0x0400, 0x9e50,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1b, 0x1e94, 0x6ec3,
+	0x6ed3, 0x62c8, 0x0248, 0x6ac8, 0x2694, 0x6ec3, 0x62c8, 0x026e,
+	0x7d32, 0x6a09, 0x7f1f, 0x2501, 0x4d00, 0x7d20, 0x028e, 0x1a98,
+	0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x6a28, 0x7f13, 0xc7af,
+	0x9e90, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x62c8, 0x026e, 0x7d18, 0x6a09, 0x7f05, 0x2001, 0x7cf9, 0x6a28,
+	0x0000, 0x9e4e, 0x0289, 0xc77b, 0x018a, 0x9e9f, 0x6a28, 0x7ffa,
+	0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7da7, 0x0200,
+	0x9e3e, 0x0200, 0x9e3b, 0x6a28, 0x7fed, 0xc7af, 0x9e9f, 0x0458,
+	0x0454, 0x9e90, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d55, 0x5010,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ea9,
+	0x0b70, 0x0311, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d37, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f2d,
+	0x0400, 0x9eba, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d16, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d2f, 0x6a09,
+	0x7f1c, 0x2501, 0x4d00, 0x7d1d, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6a28, 0x7f12, 0xc7af, 0x9ef3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d18, 0x6a09, 0x7f05,
+	0x2001, 0x7cf9, 0x6a28, 0x0000, 0x9eb8, 0x0289, 0xc77b, 0x018a,
+	0x9f02, 0x6928, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7daf, 0x0200, 0x9ea9, 0x0200, 0x9ea5, 0x6a28, 0x7fed,
+	0xc7af, 0x9f02, 0x0458, 0x0454, 0x9ef3
+};
+#endif
diff --git a/arch/arm/mach-mx3/mx35_3ds-irq.c b/arch/arm/mach-mx3/mx35_3ds-irq.c
new file mode 100644
index 0000000..f9f7e6f
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_3ds-irq.c
@@ -0,0 +1,381 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/mfd/mc9s08dz60/pmic.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/bitops.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/iomux-v3.h>
+#include <mach/iomux-mx35.h>
+
+#include "mach/board-mx35pdk.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack_irq.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+/*
+ * The interrupt status and mask variables.
+ */
+static unsigned long pseudo_irq_pending;
+static unsigned long pseudo_irq_enable;
+static unsigned long pseudo_irq_wakeup;
+static unsigned long pseudo_suspend;
+static atomic_t pseudo_irq_state = ATOMIC_INIT(0);
+
+/*
+ * The declaration of handler of two work queue.
+ * The one is the work queue to indentify the events from MCU.
+ * The another is the work queue to change the events mask.
+ */
+static void mcu_event_handler(struct work_struct *work);
+static void mcu_state_handler(struct work_struct *work);
+static void mcu_event_delay(unsigned long data);
+
+/*!
+ * The work structure for mcu events.
+ */
+static DECLARE_WORK(mcu_event_ws, mcu_event_handler);
+static DECLARE_WORK(mcu_state_ws, mcu_state_handler);
+static DEFINE_TIMER(mcu_delay_timer, mcu_event_delay, HZ, 0);
+
+static inline void mxc_pseudo_irq_ack(void)
+{
+	disable_irq(MXC_PSEUDO_PARENT);
+	atomic_set(&pseudo_irq_state, 0);
+}
+
+static inline void mxc_pseudo_irq_trigger(void)
+{
+	if (!atomic_xchg(&pseudo_irq_state, 1))
+		enable_irq(MXC_PSEUDO_PARENT);
+}
+
+/*
+ * mask a pseudo interrupt by setting the bit in the mask variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_mask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	clear_bit(index, &pseudo_irq_enable);
+}
+
+/*
+ * disable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_disable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->mask(irq);
+	desc->status |= IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+/*
+ * Acknowledge a pseudo interrupt by clearing the bit in the isr variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_ack_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	/* clear the interrupt status */
+	clear_bit(index, &pseudo_irq_pending);
+}
+
+/*
+ * unmask a pseudo interrupt by clearing the bit in the imr.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_unmask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+
+	set_bit(index, &pseudo_irq_enable);
+
+	if (test_bit(index, &pseudo_irq_pending))
+		mxc_pseudo_irq_trigger();
+}
+
+/*
+ * Enable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_enable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->unmask(irq);
+	desc->status &= ~IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+/*
+ * set pseudo irq as a wake-up source.
+ * @param irq           a pseudo virtual irq number
+ * @param enable	enable as wake-up if equal to non-ero
+ * @return 	This function return 0 on success
+ */
+static int pseudo_set_wake_irq(u32 irq, u32 enable)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+
+	if (index >= 16)
+		return -ENODEV;
+
+	if (enable) {
+		if (!pseudo_irq_wakeup)
+			enable_irq_wake(gpio_to_irq(0));
+		pseudo_irq_wakeup |= (1 << index);
+	} else {
+		pseudo_irq_wakeup &= ~(1 << index);
+		if (!pseudo_irq_wakeup)
+			disable_irq_wake(gpio_to_irq(0));
+	}
+	return 0;
+}
+
+static struct irq_chip pseudo_irq_chip = {
+	.ack = pseudo_ack_irq,
+	.mask = pseudo_mask_irq,
+	.disable = pseudo_disable_irq,
+	.unmask = pseudo_unmask_irq,
+	.enable = pseudo_enable_irq,
+	.set_wake = pseudo_set_wake_irq,
+};
+
+static void mxc_pseudo_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 pseudo_irq;
+	u32 index, mask;
+
+	desc->chip->mask(irq);
+	mxc_pseudo_irq_ack();
+
+	mask = pseudo_irq_enable;
+	index = pseudo_irq_pending;
+
+	if (unlikely(!(index & mask))) {
+		printk(KERN_ERR "\nPseudo IRQ: Spurious interrupt:0x%0x\n\n",
+		       index);
+		pr_info("IEN=0x%x, PENDING=0x%x\n", mask, index);
+		return;
+	}
+
+	index = index & mask;
+	pseudo_irq = MXC_PSEUDO_IO_BASE;
+	for (; index != 0; index >>= 1, pseudo_irq++) {
+		struct irq_desc *d;
+		if ((index & 1) == 0)
+			continue;
+		d = irq_desc + pseudo_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nPseudo irq: %d unhandeled\n",
+			       pseudo_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(pseudo_irq, d);
+		d->chip->ack(pseudo_irq);
+	}
+}
+
+static void mcu_event_delay(unsigned long data)
+{
+	schedule_work(&mcu_event_ws);
+}
+
+/*!
+ * This function is called when mcu interrupt occurs on the processor.
+ * It is the interrupt handler for the mcu.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t mcu_irq_handler(int irq, void *dev_id)
+{
+	disable_irq_nosync(gpio_to_irq(0));
+	if (pseudo_suspend)
+		mod_timer(&mcu_delay_timer, jiffies + HZ);
+	else
+		schedule_work(&mcu_event_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is the work handler of mcu interrupt.
+ * It reads the events status and trigger the pseudo irq.
+ */
+static void mcu_event_handler(struct work_struct *work)
+{
+	int i, err;
+	unsigned int flag1, flag2;
+
+	/* read int flags and ack int */
+	for (i = 0; i < 3; i++) {
+#if FIXME
+		err = mcu_pmic_read_reg(REG_MCU_INT_FLAG_1, &flag1, 0xFFFFFFFF);
+		err |= mcu_pmic_read_reg(REG_MCU_INT_FLAG_2,
+			&flag2, 0xFFFFFFFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_FLAG_1, 0, 0xFFFFFFFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_FLAG_2, 0, 0xFFFFFFFF);
+#endif
+		if (err == 0)
+			break;
+	}
+
+	if (i >= 3) {
+		printk(KERN_ERR "Reads MCU event fail\n");
+		goto no_new_events;
+	}
+
+	for (i = 0; flag1 && (i < MCU_INT_RTC); i++, flag1 >>= 1)
+		if (flag1 & 1)
+			set_bit(i, &pseudo_irq_pending);
+
+	for (i = MCU_INT_RTC; flag2 && (i <= MCU_INT_KEYPAD); i++, flag2 >>= 1)
+		if (flag2 & 1)
+			set_bit(i, &pseudo_irq_pending);
+      no_new_events:
+	if (pseudo_irq_pending & pseudo_irq_enable)
+		mxc_pseudo_irq_trigger();
+	enable_irq(gpio_to_irq(0));
+}
+
+static void mcu_state_handler(struct work_struct *work)
+{
+	int err, i;
+	unsigned int event1, event2;
+	event1 = pseudo_irq_enable & ((1 << MCU_INT_RTC) - 1);
+	event2 = pseudo_irq_enable >> MCU_INT_RTC;
+
+#if FIXME
+	if (is_suspend_ops_started())
+		return;
+#endif
+
+	for (i = 0; i < 3; i++) {
+#if FIXME
+		err = mcu_pmic_write_reg(REG_MCU_INT_ENABLE_1, event1, 0xFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_ENABLE_2, event2, 0xFF);
+#endif
+		if (err == 0)
+			break;
+	}
+	if (i >= 3)
+		printk(KERN_ERR "Change MCU event mask fail\n");
+}
+
+static int __init mxc_pseudo_init(void)
+{
+	int i;
+
+	/* disable the interrupt and clear the status */
+	pseudo_irq_pending = 0;
+	pseudo_irq_enable = 0;
+
+	pr_info("3-Stack Pseudo interrupt rev=0.1v\n");
+
+	for (i = MXC_PSEUDO_IO_BASE;
+	     i < (MXC_PSEUDO_IO_BASE + 16); i++) {
+		set_irq_chip(i, &pseudo_irq_chip);
+		set_irq_handler(i, handle_simple_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	set_irq_flags(MXC_PSEUDO_PARENT, IRQF_NOAUTOEN);
+	set_irq_handler(MXC_PSEUDO_PARENT, mxc_pseudo_irq_handler);
+
+	/* Set and install PMIC IRQ handler */
+	gpio_request(0, NULL);
+	gpio_direction_input(0);
+
+	set_irq_type(gpio_to_irq(0), IRQF_TRIGGER_RISING);
+	if (request_irq(gpio_to_irq(0), mcu_irq_handler,
+			0, "MCU_IRQ", 0)) {
+		printk(KERN_ERR "mcu request irq failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+fs_initcall_sync(mxc_pseudo_init);
+
+static int mxc_pseudo_irq_suspend(struct platform_device *dev,
+				  pm_message_t mesg)
+{
+	int err, i;
+	unsigned int event1, event2;
+
+	if (!pseudo_irq_wakeup)
+		return 0;
+
+	event1 = pseudo_irq_wakeup & ((1 << MCU_INT_RTC) - 1);
+	event2 = pseudo_irq_wakeup >> MCU_INT_RTC;
+
+	for (i = 0; i < 3; i++) {
+#if FIXME
+		err = mcu_pmic_write_reg(REG_MCU_INT_ENABLE_1, event1, 0xFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_ENABLE_2, event2, 0xFF);
+#endif
+		if (err == 0)
+			break;
+	}
+	pseudo_suspend = 1;
+	return err;
+}
+
+static int mxc_pseudo_irq_resume(struct platform_device *dev)
+{
+	if (!pseudo_irq_wakeup)
+		return 0;
+
+	schedule_work(&mcu_state_ws);
+	pseudo_suspend = 0;
+	return 0;
+}
+
+static struct platform_driver mxc_pseudo_irq_driver = {
+	.driver = {
+		   .name = "mxc_pseudo_irq",
+		   },
+	.suspend = mxc_pseudo_irq_suspend,
+	.resume = mxc_pseudo_irq_resume,
+};
+
+static int __init mxc_pseudo_sysinit(void)
+{
+	return platform_driver_register(&mxc_pseudo_irq_driver);
+}
+
+late_initcall(mxc_pseudo_sysinit);
diff --git a/arch/arm/mach-mx3/mx35_3ds_pesudo_irq.c b/arch/arm/mach-mx3/mx35_3ds_pesudo_irq.c
new file mode 100644
index 0000000..cc9e330
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_3ds_pesudo_irq.c
@@ -0,0 +1,372 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/mfd/mc9s08dz60/pmic.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/bitops.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/iomux-v3.h>
+#include <mach/iomux-mx35.h>
+#include "mach/board-mx35_3ds.h"
+
+/*!
+ * @file mach-mx35/mx35_3stack_irq.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX35
+ */
+
+/*
+ * The interrupt status and mask variables.
+ */
+static unsigned long pseudo_irq_pending;
+static unsigned long pseudo_irq_enable;
+static unsigned long pseudo_irq_wakeup;
+static unsigned long pseudo_suspend;
+static atomic_t pseudo_irq_state = ATOMIC_INIT(0);
+
+/*
+ * The declaration of handler of two work queue.
+ * The one is the work queue to indentify the events from MCU.
+ * The another is the work queue to change the events mask.
+ */
+static void mcu_event_handler(struct work_struct *work);
+static void mcu_state_handler(struct work_struct *work);
+static void mcu_event_delay(unsigned long data);
+
+/*!
+ * The work structure for mcu events.
+ */
+static DECLARE_WORK(mcu_event_ws, mcu_event_handler);
+static DECLARE_WORK(mcu_state_ws, mcu_state_handler);
+static DEFINE_TIMER(mcu_delay_timer, mcu_event_delay, HZ, 0);
+
+static inline void mxc_pseudo_irq_ack(void)
+{
+	disable_irq(MXC_PSEUDO_PARENT);
+	atomic_set(&pseudo_irq_state, 0);
+}
+
+static inline void mxc_pseudo_irq_trigger(void)
+{
+	if (!atomic_xchg(&pseudo_irq_state, 1))
+		enable_irq(MXC_PSEUDO_PARENT);
+}
+
+/*
+ * mask a pseudo interrupt by setting the bit in the mask variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_mask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	clear_bit(index, &pseudo_irq_enable);
+}
+
+/*
+ * disable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_disable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->mask(irq);
+	desc->status |= IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+/*
+ * Acknowledge a pseudo interrupt by clearing the bit in the isr variable.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_ack_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+	/* clear the interrupt status */
+	clear_bit(index, &pseudo_irq_pending);
+}
+
+/*
+ * unmask a pseudo interrupt by clearing the bit in the imr.
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_unmask_irq(u32 irq)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+
+	set_bit(index, &pseudo_irq_enable);
+
+	if (test_bit(index, &pseudo_irq_pending))
+		mxc_pseudo_irq_trigger();
+}
+
+/*
+ * Enable a pseudo interrupt by triggerring a work queue
+ * @param irq           a pseudo virtual irq number
+ */
+static void pseudo_enable_irq(u32 irq)
+{
+	struct irq_desc *desc = irq_desc + irq;
+	desc->chip->unmask(irq);
+	desc->status &= ~IRQ_MASKED;
+	schedule_work(&mcu_state_ws);
+}
+
+/*
+ * set pseudo irq as a wake-up source.
+ * @param irq           a pseudo virtual irq number
+ * @param enable	enable as wake-up if equal to non-ero
+ * @return 	This function return 0 on success
+ */
+static int pseudo_set_wake_irq(u32 irq, u32 enable)
+{
+	int index = irq - MXC_PSEUDO_IO_BASE;
+
+	if (index >= 16)
+		return -ENODEV;
+
+	if (enable) {
+		if (!pseudo_irq_wakeup)
+			enable_irq_wake(gpio_to_irq(0));
+		pseudo_irq_wakeup |= (1 << index);
+	} else {
+		pseudo_irq_wakeup &= ~(1 << index);
+		if (!pseudo_irq_wakeup)
+			disable_irq_wake(gpio_to_irq(0));
+	}
+	return 0;
+}
+
+static struct irq_chip pseudo_irq_chip = {
+	.ack = pseudo_ack_irq,
+	.mask = pseudo_mask_irq,
+	.disable = pseudo_disable_irq,
+	.unmask = pseudo_unmask_irq,
+	.enable = pseudo_enable_irq,
+	.set_wake = pseudo_set_wake_irq,
+};
+
+static void mxc_pseudo_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 pseudo_irq;
+	u32 index, mask;
+
+	desc->chip->mask(irq);
+	mxc_pseudo_irq_ack();
+
+	mask = pseudo_irq_enable;
+	index = pseudo_irq_pending;
+
+	if (unlikely(!(index & mask))) {
+		printk(KERN_ERR "\nPseudo IRQ: Spurious interrupt:0x%0x\n\n",
+		       index);
+		pr_info("IEN=0x%x, PENDING=0x%x\n", mask, index);
+		return;
+	}
+
+	index = index & mask;
+	pseudo_irq = MXC_PSEUDO_IO_BASE;
+	for (; index != 0; index >>= 1, pseudo_irq++) {
+		struct irq_desc *d;
+		if ((index & 1) == 0)
+			continue;
+		d = irq_desc + pseudo_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nPseudo irq: %d unhandeled\n",
+			       pseudo_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(pseudo_irq, d);
+		d->chip->ack(pseudo_irq);
+	}
+}
+
+static void mcu_event_delay(unsigned long data)
+{
+	schedule_work(&mcu_event_ws);
+}
+
+/*!
+ * This function is called when mcu interrupt occurs on the processor.
+ * It is the interrupt handler for the mcu.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+static irqreturn_t mcu_irq_handler(int irq, void *dev_id)
+{
+	disable_irq_nosync(gpio_to_irq(0));
+	if (pseudo_suspend)
+		mod_timer(&mcu_delay_timer, jiffies + HZ);
+	else
+		schedule_work(&mcu_event_ws);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is the work handler of mcu interrupt.
+ * It reads the events status and trigger the pseudo irq.
+ */
+static void mcu_event_handler(struct work_struct *work)
+{
+	int i, err;
+	unsigned int flag1, flag2;
+
+	/* read int flags and ack int */
+	for (i = 0; i < 3; i++) {
+		err = mcu_pmic_read_reg(REG_MCU_INT_FLAG_1, &flag1, 0xFFFFFFFF);
+		err |= mcu_pmic_read_reg(REG_MCU_INT_FLAG_2,
+			&flag2, 0xFFFFFFFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_FLAG_1, 0, 0xFFFFFFFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_FLAG_2, 0, 0xFFFFFFFF);
+		if (err == 0)
+			break;
+	}
+
+	if (i >= 3) {
+		printk(KERN_ERR "Reads MCU event fail\n");
+		goto no_new_events;
+	}
+
+	for (i = 0; flag1 && (i < MCU_INT_RTC); i++, flag1 >>= 1)
+		if (flag1 & 1)
+			set_bit(i, &pseudo_irq_pending);
+
+	for (i = MCU_INT_RTC; flag2 && (i <= MCU_INT_KEYPAD); i++, flag2 >>= 1)
+		if (flag2 & 1)
+			set_bit(i, &pseudo_irq_pending);
+no_new_events:
+	if (pseudo_irq_pending & pseudo_irq_enable)
+		mxc_pseudo_irq_trigger();
+	enable_irq(gpio_to_irq(0));
+}
+
+static void mcu_state_handler(struct work_struct *work)
+{
+	int err, i;
+	unsigned int event1, event2;
+	event1 = pseudo_irq_enable & ((1 << MCU_INT_RTC) - 1);
+	event2 = pseudo_irq_enable >> MCU_INT_RTC;
+
+	if (is_suspend_ops_started())
+		return;
+
+	for (i = 0; i < 3; i++) {
+		err = mcu_pmic_write_reg(REG_MCU_INT_ENABLE_1, event1, 0xFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_ENABLE_2, event2, 0xFF);
+		if (err == 0)
+			break;
+	}
+	if (i >= 3)
+		printk(KERN_ERR "Change MCU event mask fail\n");
+}
+
+static int __init mxc_pseudo_init(void)
+{
+	int i;
+
+	/* disable the interrupt and clear the status */
+	pseudo_irq_pending = 0;
+	pseudo_irq_enable = 0;
+
+	pr_info("3-Stack Pseudo interrupt rev=0.1v\n");
+
+	for (i = MXC_PSEUDO_IO_BASE;
+	     i < (MXC_PSEUDO_IO_BASE + 16); i++) {
+		set_irq_chip(i, &pseudo_irq_chip);
+		set_irq_handler(i, handle_simple_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+
+	set_irq_flags(MXC_PSEUDO_PARENT, IRQF_NOAUTOEN);
+	set_irq_handler(MXC_PSEUDO_PARENT, mxc_pseudo_irq_handler);
+
+	/* Set and install PMIC IRQ handler */
+	gpio_request(0, NULL);
+	gpio_direction_input(0);
+
+	set_irq_type(gpio_to_irq(0), IRQF_TRIGGER_RISING);
+	if (request_irq(gpio_to_irq(0), mcu_irq_handler,
+			0, "MCU_IRQ", 0)) {
+		printk(KERN_ERR "mcu request irq failed\n");
+		return -1;
+	}
+	return 0;
+}
+
+fs_initcall_sync(mxc_pseudo_init);
+
+static int mxc_pseudo_irq_suspend(struct platform_device *dev,
+				  pm_message_t mesg)
+{
+	int err, i;
+	unsigned int event1, event2;
+
+	if (!pseudo_irq_wakeup)
+		return 0;
+
+	event1 = pseudo_irq_wakeup & ((1 << MCU_INT_RTC) - 1);
+	event2 = pseudo_irq_wakeup >> MCU_INT_RTC;
+
+	for (i = 0; i < 3; i++) {
+		err = mcu_pmic_write_reg(REG_MCU_INT_ENABLE_1, event1, 0xFF);
+		err |= mcu_pmic_write_reg(REG_MCU_INT_ENABLE_2, event2, 0xFF);
+		if (err == 0)
+			break;
+	}
+	pseudo_suspend = 1;
+	return err;
+}
+
+static int mxc_pseudo_irq_resume(struct platform_device *dev)
+{
+	if (!pseudo_irq_wakeup)
+		return 0;
+
+	schedule_work(&mcu_state_ws);
+	pseudo_suspend = 0;
+	return 0;
+}
+
+static struct platform_driver mxc_pseudo_irq_driver = {
+	.driver = {
+		   .name = "mxc_pseudo_irq",
+		   },
+	.suspend = mxc_pseudo_irq_suspend,
+	.resume = mxc_pseudo_irq_resume,
+};
+
+static int __init mxc_pseudo_sysinit(void)
+{
+	return platform_driver_register(&mxc_pseudo_irq_driver);
+}
+
+late_initcall(mxc_pseudo_sysinit);
diff --git a/arch/arm/mach-mx3/mx35_3ds_pmic_mc13892.c b/arch/arm/mach-mx3/mx35_3ds_pmic_mc13892.c
new file mode 100644
index 0000000..2199e85
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_3ds_pmic_mc13892.c
@@ -0,0 +1,392 @@
+/*
+ * mx35-3stack-pmic-mc13892.c  --  i.MX35 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+
+#include <mach/iomux-mx35.h>
+#include <mach/hardware.h>
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define STANDBYSECINV_LSH 11
+#define STANDBYSECINV_WID 1
+
+/* regulator standby mask */
+#define GEN1_STBY_MASK          (1 << 1)
+#define IOHI_STBY_MASK          (1 << 4)
+#define DIG_STBY_MASK           (1 << 10)
+#define GEN2_STBY_MASK          (1 << 13)
+#define PLL_STBY_MASK           (1 << 16)
+#define USB2_STBY_MASK          (1 << 19)
+
+#define GEN3_STBY_MASK          (1 << 1)
+#define CAM_STBY_MASK           (1 << 7)
+#define VIDEO_STBY_MASK         (1 << 13)
+#define AUDIO_STBY_MASK         (1 << 16)
+#define SD_STBY_MASK            (1 << 19)
+
+/* 0x92412 */
+#define REG_MODE_0_ALL_MASK     (GEN1_STBY_MASK | \
+		IOHI_STBY_MASK | DIG_STBY_MASK | \
+		GEN2_STBY_MASK | PLL_STBY_MASK | \
+		USB2_STBY_MASK)
+/* 0x92082 */
+#define REG_MODE_1_ALL_MASK     (GEN3_STBY_MASK | \
+		CAM_STBY_MASK | VIDEO_STBY_MASK | \
+		AUDIO_STBY_MASK | SD_STBY_MASK)
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "cpu_vcc",
+	}
+};
+
+static struct regulator_consumer_supply vcam_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "0-000a",
+	},
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 700000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 1200000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+		.state_standby = {
+			.uV = 1000000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST | REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vcam_consumers),
+	.consumer_supplies = vcam_consumers,
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	}
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+static struct regulator_init_data pwg1_init = {
+	.constraints = {
+		.name = "PWG1",
+	}
+};
+
+static struct regulator_init_data pwg2_init = {
+	.constraints = {
+		.name = "PWG2",
+	}
+};
+
+/*!
+ * the event handler for power on event
+ */
+static void power_on_evt_handler(void)
+{
+	pr_info("pwr on event1 is received \n");
+}
+
+/*!
+ * pmic board initialization code
+ */
+static int init_mc13892(void)
+{
+	unsigned int value;
+	pmic_event_callback_t power_key_event;
+
+	if (!board_is_rev(BOARD_REV_2))
+		return -1;
+
+	/* subscribe PWRON1 event. */
+	power_key_event.param = NULL;
+	power_key_event.func = (void *)power_on_evt_handler;
+	pmic_event_subscribe(EVENT_PWRONI, power_key_event);
+
+	pmic_read_reg(REG_POWER_CTL2, &value, 0xffffff);
+	/* Bit 11 (STANDBYSECINV): Active Low */
+	value |= 0x00800;
+	/* Bit 12 (WDIRESET): enable */
+	value |= 0x01000;
+	pmic_write_reg(REG_POWER_CTL2, value, 0xffffff);
+
+	/* Battery charger default settings */
+	/* current limit = 1200mA, PLIM = 1000mw, disable auto charge */
+	value = 0x210068;
+	pmic_write_reg(REG_CHARGE, value, 0x018078);
+
+	/* enable standby controll for regulators */
+	pmic_read_reg(REG_MODE_0, &value, 0xffffff);
+	value &= ~REG_MODE_0_ALL_MASK;
+	value |= (DIG_STBY_MASK | PLL_STBY_MASK | \
+		USB2_STBY_MASK);
+	pmic_write_reg(REG_MODE_0, value, 0xffffff);
+
+	pmic_read_reg(REG_MODE_1, &value, 0xffffff);
+	value |= REG_MODE_1_ALL_MASK;
+	pmic_write_reg(REG_MODE_1, value, 0xffffff);
+
+	return 0;
+}
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+	mc13892_register_regulator(mc13892, MC13892_PWGT1, &pwg1_init);
+	mc13892_register_regulator(mc13892, MC13892_PWGT2, &pwg2_init);
+
+	init_mc13892();
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq = IOMUX_TO_IRQ(MX35_GPIO2_0),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx35_3stack_init_mc13892(void)
+{
+	return i2c_register_board_info(0, &mc13892_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx3/mx35_3ds_pmic_mc9s08dz60.c b/arch/arm/mach-mx3/mx35_3ds_pmic_mc9s08dz60.c
new file mode 100644
index 0000000..8428bef
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_3ds_pmic_mc9s08dz60.c
@@ -0,0 +1,105 @@
+/*
+ * mx35-3stack-pmic-mc9s08dz60.c -- i.MX35 3STACK Driver for MCU PMIC
+ */
+ /*
+  * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc9s08dz60/core.h>
+
+#include <mach/board-mx35_3ds.h>
+#include <mach/hardware.h>
+
+static struct regulator_init_data lcd_init = {
+	.constraints = {
+		.name = "LCD",
+	}
+};
+
+static struct regulator_init_data wifi_init = {
+	.constraints = {
+		.name = "WIFI",
+	}
+};
+
+static struct regulator_init_data hdd_init = {
+	.constraints = {
+		.name = "HDD",
+	}
+};
+
+static struct regulator_init_data gps_init = {
+	.constraints = {
+		.name = "GPS",
+	}
+};
+
+static struct regulator_init_data spkr_init = {
+	.constraints = {
+		.name = "SPKR",
+	}
+};
+
+static int mc9s08dz60_regulator_init(struct mc9s08dz60 *mc9s08dz60)
+{
+	if (!board_is_rev(BOARD_REV_2))
+		return 0;
+
+	mc9s08dz60_register_regulator(
+			mc9s08dz60, MC9S08DZ60_LCD, &lcd_init);
+	mc9s08dz60_register_regulator(mc9s08dz60,
+			MC9S08DZ60_WIFI, &wifi_init);
+	mc9s08dz60_register_regulator(
+			mc9s08dz60, MC9S08DZ60_HDD, &hdd_init);
+	mc9s08dz60_register_regulator(
+			mc9s08dz60, MC9S08DZ60_GPS, &gps_init);
+	mc9s08dz60_register_regulator(mc9s08dz60,
+				MC9S08DZ60_SPKR, &spkr_init);
+	return 0;
+}
+
+static struct mc9s08dz60_platform_data mc9s08dz60_plat = {
+	.init = mc9s08dz60_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc9s08dz60_i2c_device = {
+	I2C_BOARD_INFO("mc9s08dz60", 0x69),
+	.platform_data = &mc9s08dz60_plat,
+};
+
+static struct resource mc9s08dz60_keypad_resource = {
+	.start = MXC_PSEUDO_IRQ_KEYPAD,
+	.end = MXC_PSEUDO_IRQ_KEYPAD,
+	.flags = IORESOURCE_IRQ,
+};
+
+static struct platform_device mc9s08dz60_keypad_dev = {
+	.name = "mc9s08dz60keypad",
+	.num_resources = 1,
+	.resource = &mc9s08dz60_keypad_resource,
+};
+
+int __init mx35_3stack_init_mc9s08dz60(void)
+{
+	int retval = 0;
+	retval = i2c_register_board_info(0, &mc9s08dz60_i2c_device, 1);
+	if (retval == 0)
+		platform_device_register(&mc9s08dz60_keypad_dev);
+	return retval;
+}
diff --git a/arch/arm/mach-mx3/mx35_sdma_script_code_v1.h b/arch/arm/mach-mx3/mx35_sdma_script_code_v1.h
new file mode 100644
index 0000000..9089211
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_sdma_script_code_v1.h
@@ -0,0 +1,254 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SS15_RINGO"
+
+*******************************************************************************/
+
+#ifndef __MX35_SDMA_SCRIPT_CODE_V1_H__
+#define __MX35_SDMA_SCRIPT_CODE_V1_H__
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define mx35_start_ADDR	0
+#define mx35_start_SIZE	22
+
+#define mx35_core_ADDR	80
+#define mx35_core_SIZE	232
+
+#define mx35_common_ADDR	312
+#define mx35_common_SIZE	330
+
+#define mx35_ap_2_ap_ADDR	642
+#define mx35_ap_2_ap_SIZE	41
+
+#define mx35_app_2_mcu_ADDR	683
+#define mx35_app_2_mcu_SIZE	64
+
+#define mx35_mcu_2_app_ADDR	747
+#define mx35_mcu_2_app_SIZE	70
+
+#define mx35_uart_2_mcu_ADDR	817
+#define mx35_uart_2_mcu_SIZE	75
+
+#define mx35_shp_2_mcu_ADDR	892
+#define mx35_shp_2_mcu_SIZE	69
+
+#define mx35_mcu_2_shp_ADDR	961
+#define mx35_mcu_2_shp_SIZE	72
+
+#define mx35_per_2_shp_ADDR	1033
+#define mx35_per_2_shp_SIZE	78
+
+#define mx35_shp_2_per_ADDR	1111
+#define mx35_shp_2_per_SIZE	72
+
+#define mx35_uartsh_2_mcu_ADDR	1183
+#define mx35_uartsh_2_mcu_SIZE	69
+
+#define mx35_mcu_2_ata_ADDR	1252
+#define mx35_mcu_2_ata_SIZE	81
+
+#define mx35_ata_2_mcu_ADDR	1333
+#define mx35_ata_2_mcu_SIZE	96
+
+#define mx35_loop_DMAs_routines_ADDR	1429
+#define mx35_loop_DMAs_routines_SIZE	227
+
+#define mx35_test_ADDR	1656
+#define mx35_test_SIZE	63
+
+#define mx35_signature_ADDR	1023
+#define mx35_signature_SIZE	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define mx35_app_2_per_ADDR	6144
+#define mx35_app_2_per_SIZE	66
+
+#define mx35_asrc__mcu_ADDR	6210
+#define mx35_asrc__mcu_SIZE	114
+
+#define mx35_ext_mem__ipu_ram_ADDR	6324
+#define mx35_ext_mem__ipu_ram_SIZE	123
+
+#define mx35_mcu_2_spdif_ADDR	6447
+#define mx35_mcu_2_spdif_SIZE	103
+
+#define mx35_p_2_p_ADDR	6550
+#define mx35_p_2_p_SIZE	254
+
+#define mx35_per_2_app_ADDR	6804
+#define mx35_per_2_app_SIZE	74
+
+#define mx35_spdif_2_mcu_ADDR	6878
+#define mx35_spdif_2_mcu_SIZE	47
+
+#define mx35_uart_2_per_ADDR	6925
+#define mx35_uart_2_per_SIZE	73
+
+#define mx35_uartsh_2_per_ADDR	6998
+#define mx35_uartsh_2_per_SIZE	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define MX35_RAM_CODE_START_ADDR		6144
+#define MX35_RAM_CODE_SIZE			921
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short mx35_sdma_code[] = {
+	0xc1e3, 0x57db, 0x52fb, 0x6ac3, 0x52f3, 0x6ad7, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x0478, 0x7d03, 0x0479, 0x7d1c, 0x7c21,
+	0x0479, 0x7c14, 0x6ddd, 0x56ee, 0x62c8, 0x7e28, 0x0660, 0x7d02,
+	0x0210, 0x0212, 0x6ac8, 0x7f22, 0x0212, 0x6ac8, 0x7f1f, 0x0212,
+	0x6ac8, 0x7f1c, 0x2003, 0x4800, 0x7cef, 0x9836, 0x6ddd, 0x7802,
+	0x62c8, 0x6ac8, 0x9835, 0x6dde, 0x0015, 0x7802, 0x62c8, 0x6ac8,
+	0x9835, 0x0015, 0x0015, 0x7801, 0x62d8, 0x7c08, 0x6ddf, 0x7f06,
+	0x0000, 0x4d00, 0x7d05, 0xc1fa, 0x57db, 0x9806, 0xc273, 0x0454,
+	0xc20a, 0x9801, 0xc1d9, 0xc1e3, 0x56f3, 0x57db, 0x047a, 0x7d07,
+	0x072f, 0x076e, 0x7d02, 0x6ec7, 0x9855, 0x6ed7, 0x9855, 0x074f,
+	0x076e, 0x7d02, 0x6e01, 0x9855, 0x6e05, 0x5ce3, 0x048f, 0x0410,
+	0x3c0f, 0x5c93, 0x0eff, 0x06bf, 0x06d5, 0x7d01, 0x068d, 0x05a6,
+	0x5deb, 0x55fb, 0x008e, 0x0768, 0x7d02, 0x0769, 0x7c04, 0x06d4,
+	0x7d01, 0x008c, 0x04a0, 0x06a0, 0x076f, 0x7d0c, 0x076e, 0x7d05,
+	0x7802, 0x62c8, 0x5a05, 0x7c2b, 0x9887, 0x7802, 0x5205, 0x6ac8,
+	0x7c26, 0x9887, 0x076e, 0x7d05, 0x7802, 0x620b, 0x5a05, 0x7c21,
+	0x9887, 0x7802, 0x5205, 0x6a0b, 0x7c1c, 0x6a28, 0x7f1a, 0x0768,
+	0x7d02, 0x0769, 0x7c0a, 0x4c00, 0x7c08, 0x0768, 0x7d03, 0x5a05,
+	0x7f11, 0x9894, 0x5205, 0x7e0e, 0x5493, 0x4e00, 0x7ccb, 0x0000,
+	0x54e3, 0x55eb, 0x4d00, 0x7d0a, 0xc1fa, 0x57db, 0x9856, 0x68cc,
+	0x98a2, 0x680c, 0x009e, 0x0007, 0x54e3, 0xd8a8, 0xc20a, 0x9844,
+	0x55eb, 0x009d, 0x058c, 0x0aff, 0x0211, 0x1aff, 0x05ba, 0x05a0,
+	0x04b2, 0x04ad, 0x0454, 0x0006, 0x0e70, 0x0611, 0x5616, 0xc13c,
+	0x7d2a, 0x5ade, 0x008e, 0xc14e, 0x7c26, 0x5be0, 0x5ef0, 0x5ce8,
+	0x0688, 0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6, 0x05df, 0x7d0b,
+	0x6dc5, 0x03df, 0x7d03, 0x6bd5, 0xd903, 0x98df, 0x6b05, 0xc5f5,
+	0x7e27, 0x7f29, 0x98df, 0x6d01, 0x03df, 0x7d05, 0x6bd5, 0xc61f,
+	0x7e18, 0x7f1a, 0x98df, 0x6b05, 0xc595, 0x7e07, 0x7f06, 0x52de,
+	0x53e6, 0xc159, 0x7dd7, 0x0200, 0x98b7, 0x0007, 0x6004, 0x680c,
+	0x53f6, 0x028e, 0x00a3, 0xc256, 0x048b, 0x0498, 0x0454, 0x068a,
+	0x98df, 0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff, 0x60d0, 0x98e8,
+	0x0207, 0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c, 0x98e8, 0x0007,
+	0x68ff, 0x60d0, 0x98e8, 0x0288, 0x03a5, 0x3b03, 0x3d03, 0x4d00,
+	0x7d0a, 0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0, 0x7b01, 0x65d8,
+	0x7eee, 0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11, 0x4b00, 0x7c0f,
+	0x008a, 0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015, 0x7b02, 0x65d8,
+	0x0000, 0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd, 0x6bdd, 0x008a,
+	0x7b02, 0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1, 0x0006, 0xc1d9,
+	0xc1e3, 0x57db, 0x52f3, 0x047a, 0x7d06, 0x0479, 0x7c02, 0x6ac6,
+	0x993c, 0x6ac7, 0x993c, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5deb, 0x56fb, 0x0478, 0x7d4e, 0x0479, 0x7c1f, 0x0015,
+	0x0388, 0x047a, 0x7d03, 0x62c8, 0x7e39, 0x9950, 0x620a, 0x7e38,
+	0x0808, 0x7801, 0x0217, 0x5a06, 0x7f34, 0x2301, 0x047a, 0x7d03,
+	0x62c8, 0x7e2c, 0x995d, 0x620a, 0x7e2b, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f27, 0x2301, 0x4b00, 0x7ce4, 0x997c, 0x0015, 0x0015,
+	0x0015, 0x047a, 0x7d09, 0x7806, 0x0b00, 0x62c8, 0x5a06, 0x0b01,
+	0x62c8, 0x5a26, 0x7c13, 0x997c, 0x7806, 0x0b00, 0x620b, 0x5a06,
+	0x0b01, 0x620b, 0x5a26, 0x7c0c, 0x0b70, 0x0311, 0x5313, 0x0000,
+	0x55eb, 0x4d00, 0x7d11, 0xc1fa, 0x57db, 0x993c, 0x68cc, 0x9989,
+	0x680c, 0x0007, 0x0479, 0x7c02, 0x008b, 0x9990, 0x0017, 0x00a3,
+	0x0b70, 0x0311, 0x5313, 0xc213, 0xc20a, 0x9931, 0x0b70, 0x0311,
+	0x5313, 0x076c, 0x7c01, 0xc1d9, 0x5efb, 0x068a, 0x076b, 0x7c01,
+	0xc1d9, 0x5ef3, 0x59db, 0x58d3, 0x018f, 0x0110, 0x390f, 0x008b,
+	0xc13c, 0x7d2b, 0x5ac0, 0x5bc8, 0xc14e, 0x7c27, 0x0388, 0x0689,
+	0x5ce3, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x073e, 0x4d00, 0x7d18,
+	0x0870, 0x0011, 0x077e, 0x7d09, 0x077d, 0x7d02, 0x5228, 0x99c1,
+	0x52f8, 0x54db, 0x02bc, 0x02cc, 0x7c09, 0x077c, 0x7d02, 0x5228,
+	0x99ca, 0x52f8, 0x54d3, 0x02bc, 0x02cc, 0x7d09, 0x0400, 0x99b8,
+	0x008b, 0x52c0, 0x53c8, 0xc159, 0x7dd6, 0x0200, 0x99a8, 0x08ff,
+	0x00bf, 0x077f, 0x7d15, 0x0488, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x5deb, 0x028f, 0x0212, 0x0212, 0x3aff, 0x05da, 0x7c02, 0x073e,
+	0x99f3, 0x02a4, 0x02dd, 0x7d02, 0x073e, 0x99f3, 0x075e, 0x99f3,
+	0x55eb, 0x0598, 0x5deb, 0x52f3, 0x54fb, 0x076a, 0x7d26, 0x076c,
+	0x7d01, 0x9a30, 0x076b, 0x7c57, 0x0769, 0x7d04, 0x0768, 0x7d02,
+	0x0e01, 0x9a0a, 0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0,
+	0x5d93, 0x06a0, 0x7802, 0x5502, 0x5d04, 0x7c1d, 0x4e00, 0x7c08,
+	0x0769, 0x7d03, 0x5502, 0x7e17, 0x9a17, 0x5d04, 0x7f14, 0x0689,
+	0x5093, 0x4800, 0x7d01, 0x9a02, 0x9a7b, 0x0015, 0x7806, 0x5502,
+	0x5d04, 0x074f, 0x5502, 0x5d24, 0x072f, 0x7c01, 0x9a7b, 0x0017,
+	0x076f, 0x7c01, 0x2001, 0x5593, 0x009d, 0x0007, 0xda82, 0x99d0,
+	0x6cd3, 0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9a3f, 0x5893,
+	0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802,
+	0x5502, 0x6dc8, 0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x5502,
+	0x7e09, 0x9a4c, 0x6dc8, 0x7f06, 0x0689, 0x5093, 0x4800, 0x7d01,
+	0x9a37, 0x9a7b, 0x9a75, 0x6ac3, 0x0769, 0x7d04, 0x0768, 0x7d02,
+	0x0e01, 0x9a62, 0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0,
+	0x5d93, 0x06a0, 0x7802, 0x65c8, 0x5d04, 0x7c0f, 0x4e00, 0x7c08,
+	0x0769, 0x7d03, 0x65c8, 0x7e09, 0x9a6f, 0x5d04, 0x7f06, 0x0689,
+	0x5093, 0x4800, 0x7d01, 0x9a5a, 0x9a7b, 0x5593, 0x009d, 0x0007,
+	0x6cff, 0xda82, 0x99d0, 0x0000, 0x54e3, 0x55eb, 0x4d00, 0x7c01,
+	0x99d0, 0x99b8, 0x54e3, 0x55eb, 0x0aff, 0x0211, 0x1aff, 0x077f,
+	0x7c02, 0x05a0, 0x9a8f, 0x009d, 0x058c, 0x05ba, 0x05a0, 0x0210,
+	0x04ba, 0x04ad, 0x0454, 0x0006, 0xc1e3, 0x57db, 0x52f3, 0x6ac5,
+	0x52fb, 0x6ad3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5deb,
+	0x0478, 0x7d03, 0x0479, 0x7d20, 0x7c25, 0x0479, 0x7c19, 0x59e3,
+	0x56ee, 0x61c8, 0x7e2e, 0x62c8, 0x7e2c, 0x65c8, 0x7e2a, 0x0660,
+	0x7d03, 0x0112, 0x0112, 0x9ab6, 0x0512, 0x0512, 0x0211, 0x02a9,
+	0x02ad, 0x6ac8, 0x7f1e, 0x2003, 0x4800, 0x7ceb, 0x51e3, 0x9ad0,
+	0x7802, 0x62c8, 0x6ac8, 0x9acf, 0x6dce, 0x0015, 0x7802, 0x62c8,
+	0x6ac8, 0x9acf, 0x6dcf, 0x0015, 0x0015, 0x7801, 0x62d8, 0x7c09,
+	0x6ddf, 0x7f07, 0x0000, 0x55eb, 0x4d00, 0x7d06, 0xc1fa, 0x57db,
+	0x9a9a, 0x0007, 0x68ff, 0xc213, 0xc20a, 0x9a95, 0xc1d9, 0xc1e3,
+	0x57db, 0x52f3, 0x047a, 0x7d02, 0x6ad7, 0x9ae7, 0x6a05, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x56fb, 0x0015, 0x0015, 0x0015,
+	0x047a, 0x7d07, 0x7804, 0x5206, 0x6ac8, 0x5226, 0x6ac8, 0x7c0f,
+	0x9b01, 0x7804, 0x5206, 0x6a0b, 0x5226, 0x6a0b, 0x7c0a, 0x6a28,
+	0x7f08, 0x0000, 0x4d00, 0x7d07, 0xc1fa, 0x57db, 0x9ae7, 0xc273,
+	0x9b0a, 0xc277, 0x0454, 0xc20a, 0x9ae0, 0xc1e3, 0x57db, 0x52f3,
+	0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1e,
+	0x1e94, 0x6ee3, 0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3, 0x6ac8,
+	0x2694, 0x52eb, 0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27, 0x6ac8,
+	0x7f23, 0x2501, 0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3, 0x62c8,
+	0x6ec3, 0x0260, 0x7df1, 0x62d0, 0xc27a, 0x9b52, 0x6ee3, 0x008f,
+	0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d0e,
+	0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00,
+	0x7d09, 0xc1fa, 0x57db, 0x9b11, 0x0007, 0x6aff, 0x62d0, 0xc27a,
+	0x0458, 0x0454, 0x6add, 0x7ff8, 0xc20a, 0x9b0e, 0xc1d9, 0xc1e3,
+	0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202, 0x0269,
+	0x7d17, 0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e,
+	0x7d26, 0x6ac8, 0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e, 0x1a98,
+	0x5202, 0x0260, 0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc27a, 0x9b95,
+	0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e,
+	0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000,
+	0x4d00, 0x7d0b, 0xc1fa, 0x57db, 0x9b5b, 0x0007, 0x6aff, 0x6add,
+	0x7ffc, 0x62d0, 0xc27a, 0x0458, 0x0454, 0x6add, 0x7ff6, 0xc20a,
+	0x9b58
+};
+#endif
diff --git a/arch/arm/mach-mx3/mx35_sdma_script_code_v2.h b/arch/arm/mach-mx3/mx35_sdma_script_code_v2.h
new file mode 100644
index 0000000..323eb41
--- /dev/null
+++ b/arch/arm/mach-mx3/mx35_sdma_script_code_v2.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.  */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/*******************************************************************************
+
+			SDMA RELEASE LABEL: 	"SDMA_RINGO.03.00.00"
+
+*******************************************************************************/
+
+#ifndef __MX35_SDMA_SCRIPT_CODE_V2_H
+#define __MX35_SDMA_SCRIPT_CODE_V2_H
+
+/*!
+* SDMA ROM scripts start addresses and sizes
+*/
+
+#define mx35_start_ADDR_V2	0
+#define mx35_start_SIZE_V2	24
+
+#define mx35_core_ADDR_V2	80
+#define mx35_core_SIZE_V2	233
+
+#define mx35_common_ADDR_V2	313
+#define mx35_common_SIZE_V2	416
+
+#define mx35_ap_2_ap_ADDR_V2	729
+#define mx35_ap_2_ap_SIZE_V2	41
+
+#define mx35_app_2_mcu_ADDR_V2	770
+#define mx35_app_2_mcu_SIZE_V2	64
+
+#define mx35_mcu_2_app_ADDR_V2	834
+#define mx35_mcu_2_app_SIZE_V2	70
+
+#define mx35_uart_2_mcu_ADDR_V2	904
+#define mx35_uart_2_mcu_SIZE_V2	75
+
+#define mx35_shp_2_mcu_ADDR_V2	979
+#define mx35_shp_2_mcu_SIZE_V2	69
+
+#define mx35_mcu_2_shp_ADDR_V2	1048
+#define mx35_mcu_2_shp_SIZE_V2	72
+
+#define mx35_per_2_shp_ADDR_V2	1120
+#define mx35_per_2_shp_SIZE_V2	78
+
+#define mx35_shp_2_per_ADDR_V2	1198
+#define mx35_shp_2_per_SIZE_V2	72
+
+#define mx35_uartsh_2_mcu_ADDR_V2	1270
+#define mx35_uartsh_2_mcu_SIZE_V2	69
+
+#define mx35_mcu_2_ata_ADDR_V2	1339
+#define mx35_mcu_2_ata_SIZE_V2	90
+
+#define mx35_ata_2_mcu_ADDR_V2	1429
+#define mx35_ata_2_mcu_SIZE_V2	102
+
+#define mx35_app_2_per_ADDR_V2	1531
+#define mx35_app_2_per_SIZE_V2	66
+
+#define mx35_per_2_app_ADDR_V2	1597
+#define mx35_per_2_app_SIZE_V2	74
+
+#define mx35_loop_DMAs_routines_ADDR_V2	1671
+#define mx35_loop_DMAs_routines_SIZE_V2	240
+
+#define mx35_test_ADDR_V2	1911
+#define mx35_test_SIZE_V2	63
+
+#define mx35_signature_ADDR_V2	1022
+#define mx35_signature_SIZE_V2	1
+
+/*!
+* SDMA RAM scripts start addresses and sizes
+*/
+
+#define mx35_asrc__mcu_ADDR_V2	6144
+#define mx35_asrc__mcu_SIZE_V2	116
+
+#define mx35_ext_mem__ipu_ram_ADDR_V2	6260
+#define mx35_ext_mem__ipu_ram_SIZE_V2	123
+
+#define mx35_mcu_2_spdif_ADDR_V2	6383
+#define mx35_mcu_2_spdif_SIZE_V2	103
+
+#define mx35_p_2_p_ADDR_V2	6486
+#define mx35_p_2_p_SIZE_V2	260
+
+#define mx35_spdif_2_mcu_ADDR_V2	6746
+#define mx35_spdif_2_mcu_SIZE_V2	47
+
+#define mx35_uart_2_per_ADDR_V2	6793
+#define mx35_uart_2_per_SIZE_V2	73
+
+#define mx35_uartsh_2_per_ADDR_V2	6866
+#define mx35_uartsh_2_per_SIZE_V2	67
+
+/*!
+* SDMA RAM image start address and size
+*/
+
+#define MX35_RAM_CODE_START_ADDR_V2		6144
+#define MX35_RAM_CODE_SIZE_V2		789
+
+/*!
+* Buffer that holds the SDMA RAM image
+*/
+
+static const short mx35_sdma_code_v2[] = {
+	0xc230, 0xc23a, 0x56f3, 0x57db, 0x047a, 0x7d07, 0x072f, 0x076e,
+	0x7d02, 0x6ec7, 0x9813, 0x6ed7, 0x9813, 0x074f, 0x076e, 0x7d02,
+	0x6e01, 0x9813, 0x6e05, 0x5ce3, 0x048f, 0x0410, 0x3c0f, 0x5c93,
+	0x0e03, 0x0611, 0x1eff, 0x06bf, 0x06d5, 0x7d01, 0x068d, 0x05a6,
+	0x5deb, 0x55fb, 0x008e, 0x076a, 0x7d02, 0x076b, 0x7c04, 0x06d4,
+	0x7d01, 0x008c, 0x04a0, 0x06a0, 0x076f, 0x7d0c, 0x076e, 0x7d05,
+	0x7802, 0x62c8, 0x5a05, 0x7c2b, 0x9847, 0x7802, 0x5205, 0x6ac8,
+	0x7c26, 0x9847, 0x076e, 0x7d05, 0x7802, 0x620b, 0x5a05, 0x7c21,
+	0x9847, 0x7802, 0x5205, 0x6a0b, 0x7c1c, 0x6a28, 0x7f1a, 0x076a,
+	0x7d02, 0x076b, 0x7c0a, 0x4c00, 0x7c08, 0x076a, 0x7d03, 0x5a05,
+	0x7f11, 0x9854, 0x5205, 0x7e0e, 0x5493, 0x4e00, 0x7ccb, 0x0000,
+	0x54e3, 0x55eb, 0x4d00, 0x7d0a, 0xc251, 0x57db, 0x9814, 0x68cc,
+	0x9862, 0x680c, 0x009e, 0x0007, 0x54e3, 0xd868, 0xc261, 0x9802,
+	0x55eb, 0x009d, 0x058c, 0x0aff, 0x0211, 0x1aff, 0x05ba, 0x05a0,
+	0x04b2, 0x04ad, 0x0454, 0x0006, 0x0e70, 0x0611, 0x5616, 0xc18a,
+	0x7d2a, 0x5ade, 0x008e, 0xc19c, 0x7c26, 0x5be0, 0x5ef0, 0x5ce8,
+	0x0688, 0x08ff, 0x0011, 0x28ff, 0x00bc, 0x53f6, 0x05df, 0x7d0b,
+	0x6dc5, 0x03df, 0x7d03, 0x6bd5, 0xd8c3, 0x989f, 0x6b05, 0xc6e7,
+	0x7e27, 0x7f29, 0x989f, 0x6d01, 0x03df, 0x7d05, 0x6bd5, 0xc711,
+	0x7e18, 0x7f1a, 0x989f, 0x6b05, 0xc687, 0x7e07, 0x7f06, 0x52de,
+	0x53e6, 0xc1a8, 0x7dd7, 0x0200, 0x9877, 0x0007, 0x6004, 0x680c,
+	0x53f6, 0x028e, 0x00a3, 0xc2ad, 0x048b, 0x0498, 0x0454, 0x068a,
+	0x989f, 0x0207, 0x680c, 0x6ddf, 0x0107, 0x68ff, 0x60d0, 0x98a8,
+	0x0207, 0x68ff, 0x6d28, 0x0107, 0x6004, 0x680c, 0x98a8, 0x0007,
+	0x68ff, 0x60d0, 0x98a8, 0x0288, 0x03a5, 0x3b03, 0x3d03, 0x4d00,
+	0x7d0a, 0x0804, 0x00a5, 0x00da, 0x7d1a, 0x02a0, 0x7b01, 0x65d8,
+	0x7eee, 0x65ff, 0x7eec, 0x0804, 0x02d0, 0x7d11, 0x4b00, 0x7c0f,
+	0x008a, 0x3003, 0x6dcf, 0x6bdf, 0x0015, 0x0015, 0x7b02, 0x65d8,
+	0x0000, 0x7edd, 0x63ff, 0x7edb, 0x3a03, 0x6dcd, 0x6bdd, 0x008a,
+	0x7b02, 0x65d8, 0x0000, 0x7ed3, 0x65ff, 0x7ed1, 0x0006, 0xc230,
+	0xc23a, 0x57db, 0x52f3, 0x047a, 0x7d06, 0x0479, 0x7c02, 0x6ac6,
+	0x98fc, 0x6ac7, 0x98fc, 0x6a01, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5deb, 0x56fb, 0x0478, 0x7d4e, 0x0479, 0x7c1f, 0x0015,
+	0x0388, 0x047a, 0x7d03, 0x62c8, 0x7e39, 0x9910, 0x620a, 0x7e38,
+	0x0808, 0x7801, 0x0217, 0x5a06, 0x7f34, 0x2301, 0x047a, 0x7d03,
+	0x62c8, 0x7e2c, 0x991d, 0x620a, 0x7e2b, 0x0808, 0x7801, 0x0217,
+	0x5a26, 0x7f27, 0x2301, 0x4b00, 0x7ce4, 0x993c, 0x0015, 0x0015,
+	0x0015, 0x047a, 0x7d09, 0x7806, 0x0b00, 0x62c8, 0x5a06, 0x0b01,
+	0x62c8, 0x5a26, 0x7c13, 0x993c, 0x7806, 0x0b00, 0x620b, 0x5a06,
+	0x0b01, 0x620b, 0x5a26, 0x7c0c, 0x0b70, 0x0311, 0x5313, 0x0000,
+	0x55eb, 0x4d00, 0x7d11, 0xc251, 0x57db, 0x98fc, 0x68cc, 0x9949,
+	0x680c, 0x0007, 0x0479, 0x7c02, 0x008b, 0x9950, 0x0017, 0x00a3,
+	0x0b70, 0x0311, 0x5313, 0xc26a, 0xc261, 0x98f1, 0x0b70, 0x0311,
+	0x5313, 0x076c, 0x7c01, 0xc230, 0x5efb, 0x068a, 0x076b, 0x7c01,
+	0xc230, 0x5ef3, 0x59db, 0x58d3, 0x018f, 0x0110, 0x390f, 0x008b,
+	0xc18a, 0x7d2b, 0x5ac0, 0x5bc8, 0xc19c, 0x7c27, 0x0388, 0x0689,
+	0x5ce3, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x073e, 0x4d00, 0x7d18,
+	0x0870, 0x0011, 0x077e, 0x7d09, 0x077d, 0x7d02, 0x5228, 0x9981,
+	0x52f8, 0x54db, 0x02bc, 0x02cc, 0x7c09, 0x077c, 0x7d02, 0x5228,
+	0x998a, 0x52f8, 0x54d3, 0x02bc, 0x02cc, 0x7d09, 0x0400, 0x9978,
+	0x008b, 0x52c0, 0x53c8, 0xc1a8, 0x7dd6, 0x0200, 0x9968, 0x08ff,
+	0x00bf, 0x077f, 0x7d1b, 0x0488, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x5deb, 0x028f, 0x32ff, 0x0210, 0x32ff, 0x0210, 0x0212, 0x0217,
+	0x0217, 0x32ff, 0x0212, 0x05da, 0x7c02, 0x073e, 0x99b9, 0x02a4,
+	0x02dd, 0x7d02, 0x073e, 0x99b9, 0x075e, 0x99b9, 0x55eb, 0x0598,
+	0x5deb, 0x52f3, 0x54fb, 0x076a, 0x7d26, 0x076c, 0x7d01, 0x99f6,
+	0x076b, 0x7c57, 0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x99d0,
+	0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0,
+	0x7802, 0x5502, 0x5d04, 0x7c1d, 0x4e00, 0x7c08, 0x0769, 0x7d03,
+	0x5502, 0x7e17, 0x99dd, 0x5d04, 0x7f14, 0x0689, 0x5093, 0x4800,
+	0x7d01, 0x99c8, 0x9a41, 0x0015, 0x7806, 0x5502, 0x5d04, 0x074d,
+	0x5502, 0x5d24, 0x072d, 0x7c01, 0x9a41, 0x0017, 0x076d, 0x7c01,
+	0x2001, 0x5593, 0x009d, 0x0007, 0xda48, 0x9990, 0x6cd3, 0x0769,
+	0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9a05, 0x5893, 0x00d6, 0x7d01,
+	0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0, 0x7802, 0x5502, 0x6dc8,
+	0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03, 0x5502, 0x7e09, 0x9a12,
+	0x6dc8, 0x7f06, 0x0689, 0x5093, 0x4800, 0x7d01, 0x99fd, 0x9a41,
+	0x9a3b, 0x6ac3, 0x0769, 0x7d04, 0x0768, 0x7d02, 0x0e01, 0x9a28,
+	0x5893, 0x00d6, 0x7d01, 0x008e, 0x5593, 0x05a0, 0x5d93, 0x06a0,
+	0x7802, 0x65c8, 0x5d04, 0x7c0f, 0x4e00, 0x7c08, 0x0769, 0x7d03,
+	0x65c8, 0x7e09, 0x9a35, 0x5d04, 0x7f06, 0x0689, 0x5093, 0x4800,
+	0x7d01, 0x9a20, 0x9a41, 0x5593, 0x009d, 0x0007, 0x6cff, 0xda48,
+	0x9990, 0x0000, 0x54e3, 0x55eb, 0x4d00, 0x7c01, 0x9990, 0x9978,
+	0x54e3, 0x55eb, 0x0aff, 0x0211, 0x1aff, 0x077f, 0x7c02, 0x05a0,
+	0x9a55, 0x009d, 0x058c, 0x05ba, 0x05a0, 0x0210, 0x04ba, 0x04ad,
+	0x0454, 0x0006, 0xc230, 0xc23a, 0x57db, 0x52f3, 0x047a, 0x7d02,
+	0x6ad7, 0x9a63, 0x6a05, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x56fb, 0x0015, 0x0015, 0x0015, 0x047a, 0x7d07, 0x7804, 0x5206,
+	0x6ac8, 0x5226, 0x6ac8, 0x7c0f, 0x9a7d, 0x7804, 0x5206, 0x6a0b,
+	0x5226, 0x6a0b, 0x7c0a, 0x6a28, 0x7f08, 0x0000, 0x4d00, 0x7d07,
+	0xc251, 0x57db, 0x9a63, 0xc2ca, 0x9a86, 0xc2ce, 0x0454, 0xc261,
+	0x9a5c, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb, 0x028e, 0x1a94,
+	0x6ac3, 0x62c8, 0x0269, 0x7d1e, 0x1e94, 0x6ee3, 0x62d0, 0x5aeb,
+	0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb, 0x6ad5, 0x6ee3,
+	0x62c8, 0x026e, 0x7d27, 0x6ac8, 0x7f23, 0x2501, 0x4d00, 0x7d26,
+	0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x62d0,
+	0xc2d1, 0x9ace, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x62c8, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001, 0x7cf9,
+	0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d09, 0xc251, 0x57db, 0x9a8d,
+	0x0007, 0x6aff, 0x62d0, 0xc2d1, 0x0458, 0x0454, 0x6add, 0x7ff8,
+	0xc261, 0x9a8a, 0xc230, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb,
+	0x028e, 0x1a94, 0x5202, 0x0269, 0x7d17, 0x1e94, 0x5206, 0x0248,
+	0x5a06, 0x2694, 0x5206, 0x026e, 0x7d26, 0x6ac8, 0x7f22, 0x2501,
+	0x4d00, 0x7d27, 0x028e, 0x1a98, 0x5202, 0x0260, 0x7df3, 0x6add,
+	0x7f18, 0x62d0, 0xc2d1, 0x9b11, 0x008f, 0x2001, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x5206, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a, 0x2001,
+	0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d0b, 0xc251, 0x57db,
+	0x9ad7, 0x0007, 0x6aff, 0x6add, 0x7ffc, 0x62d0, 0xc2d1, 0x0458,
+	0x0454, 0x6add, 0x7ff6, 0xc261, 0x9ad4
+};
+#endif
diff --git a/arch/arm/mach-mx3/mx3_3ds_pmic_mc13783.c b/arch/arm/mach-mx3/mx3_3ds_pmic_mc13783.c
new file mode 100644
index 0000000..1ecd553
--- /dev/null
+++ b/arch/arm/mach-mx3/mx3_3ds_pmic_mc13783.c
@@ -0,0 +1,273 @@
+/*
+ * mx3-3stack-pmic-mc13783.c  --  i.MX3 3STACK Driver for Atlas MC13783 PMIC
+ */
+ /*
+  * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13783/core.h>
+#include <mach/irqs.h>
+#include <mach/iomux-mx3.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+
+struct mc13783;
+
+static struct regulator_init_data violo_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1800), /* mc13783 allows max of 1800. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1800), /* mc13783 allows max of 1800. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1100), /* mc13783 allows min of 1100. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vrfdig_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 1200. */
+		.max_uV = mV_to_uV(1875), /* mc13783 allows max of 1875. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vrfref_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(2475), /* mc13783 allows min of 2475. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vrfcp_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(2700), /* mc13783 allows min of 2700. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vsim_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1800), /* mc13783 allows min of 1800. */
+		.max_uV = mV_to_uV(2900), /* mc13783 allows max of 2900. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vesim_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1800), /* mc13783 allows min of 1800. */
+		.max_uV = mV_to_uV(2900), /* mc13783 allows max of 2900. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1500), /* mc13783 allows min of 1500. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vvib_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1300), /* mc13783 allows min of 1300. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data vrf_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1500), /* mc13783 allows min of 1500. */
+		.max_uV = mV_to_uV(2775), /* mc13783 allows max of 2775. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vmmc_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1600), /* mc13783 allows min of 1600. */
+		.max_uV = mV_to_uV(3000), /* mc13783 allows max of 3000. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+	}
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(5000), /* mc13783 allows min of 5000. */
+		.max_uV = mV_to_uV(5500), /* mc13783 allows max of 5500. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 900. */
+		.max_uV = mV_to_uV(1600), /* mc13783 allows max of 2200. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE
+				  | REGULATOR_CHANGE_MODE,
+		.valid_modes_mask = REGULATOR_MODE_FAST
+				    | REGULATOR_MODE_NORMAL
+				    | REGULATOR_MODE_IDLE
+				    | REGULATOR_MODE_STANDBY,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = mV_to_uV(1250),
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	}
+};
+
+static struct regulator_init_data sw_init = {
+	.constraints = {
+		.min_uV = mV_to_uV(1200), /* mc13783 allows min of 900. */
+		.max_uV = mV_to_uV(2200), /* mc13783 allows max of 2200. */
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+	},
+};
+
+static struct regulator_init_data gpo_init = {
+	.constraints = {
+	},
+};
+
+static int mc13783_regulator_init(void *data)
+{
+	struct mc13783 *mc13783 = data;
+	unsigned int value;
+#if 0
+	/*most regulators are controled by standby signal*/
+	/*except violo*/
+	pmic_read_reg(REG_REGULATOR_MODE_0, &value, 0xffffff);
+	value |= 0x492412;
+	pmic_write_reg(REG_REGULATOR_MODE_0, value, 0xffffff);
+	pmic_read_reg(REG_REGULATOR_MODE_1, &value, 0xffffff);
+	value |= 0x492492;
+	pmic_write_reg(REG_REGULATOR_MODE_1, value, 0xffffff);
+	/*also sw3 is controled by standby signal*/
+	pmic_read_reg(REG_SWITCHERS_5, &value, 0xffffff);
+	value |= 0x200000;
+	pmic_write_reg(REG_SWITCHERS_5, value, 0xffffff);
+#endif
+	mc13783_register_regulator(mc13783, MC13783_SW1A, &sw1_init);
+	mc13783_register_regulator(mc13783, MC13783_SW1B, &sw_init);
+	mc13783_register_regulator(mc13783, MC13783_SW2A, &sw_init);
+	mc13783_register_regulator(mc13783, MC13783_SW2B, &sw_init);
+	mc13783_register_regulator(mc13783, MC13783_SW3, &sw3_init);
+	mc13783_register_regulator(mc13783, MC13783_VMMC1, &vmmc_init);
+	mc13783_register_regulator(mc13783, MC13783_VMMC2, &vmmc_init);
+	mc13783_register_regulator(mc13783, MC13783_VVIB, &vvib_init);
+	mc13783_register_regulator(mc13783, MC13783_VIOHI, &viohi_init);
+	mc13783_register_regulator(mc13783, MC13783_VIOLO, &violo_init);
+	mc13783_register_regulator(mc13783, MC13783_VDIG, &vdig_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFDIG, &vrfdig_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFREF, &vrfref_init);
+	mc13783_register_regulator(mc13783, MC13783_VRFCP, &vrfcp_init);
+	mc13783_register_regulator(mc13783, MC13783_VRF1, &vrf_init);
+	mc13783_register_regulator(mc13783, MC13783_VRF2, &vrf_init);
+	mc13783_register_regulator(mc13783, MC13783_VAUDIO, &vaudio_init);
+	mc13783_register_regulator(mc13783, MC13783_VCAM, &vcam_init);
+	mc13783_register_regulator(mc13783, MC13783_VGEN, &vgen_init);
+	mc13783_register_regulator(mc13783, MC13783_VSIM, &vsim_init);
+	mc13783_register_regulator(mc13783, MC13783_VESIM, &vesim_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO1, &gpo1_init);
+
+	gpo_init.supply_regulator_dev =
+			&(mc13783->pmic.pdev[MC13783_GPO1]->dev);
+	mc13783_register_regulator(mc13783, MC13783_GPO2, &gpo_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO3, &gpo_init);
+	mc13783_register_regulator(mc13783, MC13783_GPO4, &gpo4_init);
+
+	return 0;
+}
+
+static struct pmic_platform_data mc13783_plat = {
+	.init = mc13783_regulator_init,
+	.power_key_irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_2),
+};
+
+static struct spi_board_info __initdata mc13783_spi_device = {
+	.modalias = "pmic_spi",
+	.irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_3),
+	.max_speed_hz = 4000000,
+	.bus_num = 2,
+	.platform_data = &mc13783_plat,
+	.chip_select = 2,
+};
+
+int __init mx3_3stack_init_mc13783(void)
+{
+	return spi_register_board_info(&mc13783_spi_device, 1);
+}
diff --git a/arch/arm/mach-mx3/mx3x-dma.c b/arch/arm/mach-mx3/mx3x-dma.c
new file mode 100644
index 0000000..cd2eb1c
--- /dev/null
+++ b/arch/arm/mach-mx3/mx3x-dma.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <mach/sdma.h>
+
+#include "mx31_sdma_script_code_v1.h"
+#include "mx31_sdma_script_code_v2.h"
+#include "mx35_sdma_script_code_v1.h"
+#include "mx35_sdma_script_code_v2.h"
+
+void mx31_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	sdma_script_start_addrs *d = sdma_script_addr;
+
+	if (cpu_is_mx31_rev(CHIP_REV_1_0) == 1) {
+		d->mxc_sdma_app_2_mcu_addr = mx31_app_2_mcu_ADDR;
+		d->mxc_sdma_ap_2_ap_addr = mx31_ap_2_ap_ADDR;
+		d->mxc_sdma_ap_2_bp_addr = -1;
+		d->mxc_sdma_bp_2_ap_addr = -1;
+		d->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		d->mxc_sdma_mcu_2_app_addr = mx31_mcu_2_app_ADDR;
+		d->mxc_sdma_mcu_2_shp_addr = mx31_mcu_2_shp_ADDR;
+		d->mxc_sdma_mcu_interrupt_only_addr = -1;
+		d->mxc_sdma_shp_2_mcu_addr = mx31_shp_2_mcu_ADDR;
+		d->mxc_sdma_start_addr = (unsigned short *)mx31_sdma_code;
+		d->mxc_sdma_uartsh_2_mcu_addr = mx31_uartsh_2_mcu_ADDR;
+		d->mxc_sdma_uart_2_mcu_addr = mx31_uart_2_mcu_ADDR;
+		d->mxc_sdma_ram_code_size = MX31_RAM_CODE_SIZE;
+		d->mxc_sdma_ram_code_start_addr = MX31_RAM_CODE_START_ADDR;
+		d->mxc_sdma_dptc_dvfs_addr = mx31_dptc_dvfs_ADDR;
+		d->mxc_sdma_firi_2_mcu_addr = mx31_firi_2_mcu_ADDR;
+		d->mxc_sdma_firi_2_per_addr = -1;
+		d->mxc_sdma_mshc_2_mcu_addr = mx31_mshc_2_mcu_ADDR;
+		d->mxc_sdma_per_2_app_addr = -1;
+		d->mxc_sdma_per_2_firi_addr = -1;
+		d->mxc_sdma_per_2_shp_addr = -1;
+		d->mxc_sdma_mcu_2_ata_addr = mx31_mcu_2_ata_ADDR;
+		d->mxc_sdma_mcu_2_firi_addr = mx31_mcu_2_firi_ADDR;
+		d->mxc_sdma_mcu_2_mshc_addr = mx31_mcu_2_mshc_ADDR;
+		d->mxc_sdma_ata_2_mcu_addr = mx31_ata_2_mcu_ADDR;
+		d->mxc_sdma_uartsh_2_per_addr = -1;
+		d->mxc_sdma_shp_2_per_addr = -1;
+		d->mxc_sdma_uart_2_per_addr = -1;
+		d->mxc_sdma_app_2_per_addr = -1;
+	} else {
+		d->mxc_sdma_app_2_mcu_addr = mx31_app_2_mcu_ADDR_2;
+		d->mxc_sdma_ap_2_ap_addr = mx31_ap_2_ap_ADDR_2;
+		d->mxc_sdma_ap_2_ap_fixed_addr = mx31_ap_2_ap_fixed_addr_ADDR_2;
+		d->mxc_sdma_ap_2_bp_addr = mx31_ap_2_bp_ADDR_2;
+		d->mxc_sdma_ap_2_ap_fixed_addr = mx31_ap_2_ap_fixed_addr_ADDR_2;
+		d->mxc_sdma_bp_2_ap_addr = mx31_bp_2_ap_ADDR_2;
+		d->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		d->mxc_sdma_mcu_2_app_addr = mx31_mcu_2_app_ADDR_2;
+		d->mxc_sdma_mcu_2_shp_addr = mx31_mcu_2_shp_ADDR_2;
+		d->mxc_sdma_mcu_interrupt_only_addr = -1;
+		d->mxc_sdma_shp_2_mcu_addr = mx31_shp_2_mcu_ADDR_2;
+		d->mxc_sdma_start_addr = (unsigned short *)mx31_sdma_code_2;
+		d->mxc_sdma_uartsh_2_mcu_addr = mx31_uartsh_2_mcu_ADDR_2;
+		d->mxc_sdma_uart_2_mcu_addr = mx31_uart_2_mcu_ADDR_2;
+		d->mxc_sdma_ram_code_size = MX31_RAM_CODE_SIZE_2;
+		d->mxc_sdma_ram_code_start_addr = MX31_RAM_CODE_START_ADDR_2;
+		d->mxc_sdma_dptc_dvfs_addr = -1;
+		d->mxc_sdma_firi_2_mcu_addr = mx31_firi_2_mcu_ADDR_2;
+		d->mxc_sdma_firi_2_per_addr = -1;
+		d->mxc_sdma_mshc_2_mcu_addr = mx31_mshc_2_mcu_ADDR_2;
+		d->mxc_sdma_per_2_app_addr = mx31_per_2_app_ADDR_2;
+		d->mxc_sdma_per_2_firi_addr = -1;
+		d->mxc_sdma_per_2_shp_addr = mx31_per_2_shp_ADDR_2;
+		d->mxc_sdma_mcu_2_ata_addr = mx31_mcu_2_ata_ADDR_2;
+		d->mxc_sdma_mcu_2_firi_addr = mx31_mcu_2_firi_ADDR_2;
+		d->mxc_sdma_mcu_2_mshc_addr = mx31_mcu_2_mshc_ADDR_2;
+		d->mxc_sdma_ata_2_mcu_addr = mx31_ata_2_mcu_ADDR_2;
+		d->mxc_sdma_uartsh_2_per_addr = -1;
+		d->mxc_sdma_shp_2_per_addr = mx31_shp_2_per_ADDR_2;
+		d->mxc_sdma_uart_2_per_addr = -1;
+		d->mxc_sdma_app_2_per_addr = mx31_app_2_per_ADDR_2;
+	}
+}
+
+void mx35_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	sdma_script_start_addrs *d = sdma_script_addr;
+
+	if (cpu_is_mx35_rev(CHIP_REV_2_0) < 1) {
+		d->mxc_sdma_ap_2_ap_addr = mx35_ap_2_ap_ADDR;
+		d->mxc_sdma_ap_2_bp_addr = -1;
+		d->mxc_sdma_bp_2_ap_addr = -1;
+		d->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		d->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+		d->mxc_sdma_firi_2_per_addr = -1;
+		d->mxc_sdma_firi_2_mcu_addr = -1;
+		d->mxc_sdma_per_2_firi_addr = -1;
+		d->mxc_sdma_mcu_2_firi_addr = -1;
+
+		d->mxc_sdma_uart_2_per_addr = mx35_uart_2_per_ADDR;
+		d->mxc_sdma_uart_2_mcu_addr = mx35_uart_2_mcu_ADDR;
+		d->mxc_sdma_per_2_app_addr = mx35_per_2_app_ADDR;
+		d->mxc_sdma_mcu_2_app_addr = mx35_mcu_2_app_ADDR;
+		d->mxc_sdma_per_2_per_addr = mx35_p_2_p_ADDR;
+		d->mxc_sdma_uartsh_2_per_addr = mx35_uartsh_2_per_ADDR;
+		d->mxc_sdma_uartsh_2_mcu_addr = mx35_uartsh_2_mcu_ADDR;
+		d->mxc_sdma_per_2_shp_addr = mx35_per_2_shp_ADDR;
+		d->mxc_sdma_mcu_2_shp_addr = mx35_mcu_2_shp_ADDR;
+		d->mxc_sdma_ata_2_mcu_addr = mx35_ata_2_mcu_ADDR;
+		d->mxc_sdma_mcu_2_ata_addr = mx35_mcu_2_ata_ADDR;
+		d->mxc_sdma_app_2_per_addr = mx35_app_2_per_ADDR;
+		d->mxc_sdma_app_2_mcu_addr = mx35_app_2_mcu_ADDR;
+		d->mxc_sdma_shp_2_per_addr = mx35_shp_2_per_ADDR;
+		d->mxc_sdma_shp_2_mcu_addr = mx35_shp_2_mcu_ADDR;
+		d->mxc_sdma_mshc_2_mcu_addr = -1;
+		d->mxc_sdma_mcu_2_mshc_addr = -1;
+
+		d->mxc_sdma_spdif_2_mcu_addr = mx35_spdif_2_mcu_ADDR;
+		d->mxc_sdma_mcu_2_spdif_addr = mx35_mcu_2_spdif_ADDR;
+		d->mxc_sdma_asrc_2_mcu_addr = mx35_asrc__mcu_ADDR;
+
+		d->mxc_sdma_dptc_dvfs_addr = -1;
+		d->mxc_sdma_ext_mem_2_ipu_addr = mx35_ext_mem__ipu_ram_ADDR;
+		d->mxc_sdma_descrambler_addr = -1;
+
+		d->mxc_sdma_start_addr = (unsigned short *)mx35_sdma_code;
+		d->mxc_sdma_ram_code_size = MX35_RAM_CODE_SIZE;
+		d->mxc_sdma_ram_code_start_addr = MX35_RAM_CODE_START_ADDR;
+	} else {
+		d->mxc_sdma_ap_2_ap_addr = mx35_ap_2_ap_ADDR_V2;
+		d->mxc_sdma_ap_2_bp_addr = -1;
+		d->mxc_sdma_bp_2_ap_addr = -1;
+		d->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		d->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+		d->mxc_sdma_firi_2_per_addr = -1;
+		d->mxc_sdma_firi_2_mcu_addr = -1;
+		d->mxc_sdma_per_2_firi_addr = -1;
+		d->mxc_sdma_mcu_2_firi_addr = -1;
+
+		d->mxc_sdma_uart_2_per_addr = mx35_uart_2_per_ADDR_V2;
+		d->mxc_sdma_uart_2_mcu_addr = mx35_uart_2_mcu_ADDR_V2;
+		d->mxc_sdma_per_2_app_addr = mx35_per_2_app_ADDR_V2;
+		d->mxc_sdma_mcu_2_app_addr = mx35_mcu_2_app_ADDR_V2;
+		d->mxc_sdma_per_2_per_addr = mx35_p_2_p_ADDR_V2;
+		d->mxc_sdma_uartsh_2_per_addr = mx35_uartsh_2_per_ADDR_V2;
+		d->mxc_sdma_uartsh_2_mcu_addr = mx35_uartsh_2_mcu_ADDR_V2;
+		d->mxc_sdma_per_2_shp_addr = mx35_per_2_shp_ADDR_V2;
+		d->mxc_sdma_mcu_2_shp_addr = mx35_mcu_2_shp_ADDR_V2;
+
+		d->mxc_sdma_ata_2_mcu_addr = mx35_ata_2_mcu_ADDR_V2;
+		d->mxc_sdma_mcu_2_ata_addr = mx35_mcu_2_ata_ADDR_V2;
+
+		d->mxc_sdma_app_2_per_addr = mx35_app_2_per_ADDR_V2;
+		d->mxc_sdma_app_2_mcu_addr = mx35_app_2_mcu_ADDR_V2;
+		d->mxc_sdma_shp_2_per_addr = mx35_shp_2_per_ADDR_V2;
+		d->mxc_sdma_shp_2_mcu_addr = mx35_shp_2_mcu_ADDR_V2;
+
+		d->mxc_sdma_mshc_2_mcu_addr = -1;
+		d->mxc_sdma_mcu_2_mshc_addr = -1;
+
+		d->mxc_sdma_spdif_2_mcu_addr = mx35_spdif_2_mcu_ADDR_V2;
+		d->mxc_sdma_mcu_2_spdif_addr = mx35_mcu_2_spdif_ADDR_V2;
+
+		d->mxc_sdma_asrc_2_mcu_addr = mx35_asrc__mcu_ADDR_V2;
+
+		d->mxc_sdma_dptc_dvfs_addr = -1;
+		d->mxc_sdma_ext_mem_2_ipu_addr = mx35_ext_mem__ipu_ram_ADDR_V2;
+		d->mxc_sdma_descrambler_addr = -1;
+
+		d->mxc_sdma_start_addr = (unsigned short *)mx35_sdma_code_v2;
+		d->mxc_sdma_ram_code_size = MX35_RAM_CODE_SIZE;
+		d->mxc_sdma_ram_code_start_addr = MX35_RAM_CODE_START_ADDR_V2;
+	}
+}
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	sdma_script_start_addrs *d = sdma_script_addr;
+
+	if (cpu_is_mx31())
+		mx31_sdma_get_script_info(d);
+	else if (cpu_is_mx35())
+		mx35_sdma_get_script_info(d);
+}
diff --git a/arch/arm/mach-mx3/pm.c b/arch/arm/mach-mx3/pm.c
new file mode 100644
index 0000000..7c611b9
--- /dev/null
+++ b/arch/arm/mach-mx3/pm.c
@@ -0,0 +1,179 @@
+/*
+ * linux/arch/arm/mach-mx3/pm.c
+ *
+ * MX3 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX31
+ * Copyright 2005-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/suspend.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <mach/hardware.h>
+#include "crm_regs.h"
+
+extern void mxc_pm_arch_entry(void *entry, u32 size);
+extern void mxc_init_irq(void __iomem *irqbase);
+
+int suspend_ops_started;
+int is_suspend_ops_started(void)
+{
+	return suspend_ops_started;
+}
+
+static int mx31_suspend_enter(suspend_state_t state)
+{
+	unsigned long reg;
+
+	/* Enable Well Bias and set VSTBY
+	* VSTBY pin will be asserted during SR mode. This asks the
+	* PM IC to set the core voltage to the standby voltage
+	* Must clear the MXC_CCM_CCMR_SBYCS bit as well??  */
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg &= ~MXC_CCM_CCMR_LPM_MASK;
+	reg |= MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY | MXC_CCM_CCMR_SBYCS;
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		/* State Retention mode */
+		reg |= 2 << MXC_CCM_CCMR_LPM_OFFSET;
+		__raw_writel(reg, MXC_CCM_CCMR);
+
+		/* Executing CP15 (Wait-for-Interrupt) Instruction */
+		cpu_do_idle();
+		break;
+	case PM_SUSPEND_STANDBY:
+		/* Deep Sleep Mode */
+		reg |= 3 << MXC_CCM_CCMR_LPM_OFFSET;
+		__raw_writel(reg, MXC_CCM_CCMR);
+
+		/* wake up by keypad */
+		reg = __raw_readl(MXC_CCM_WIMR);
+		reg &= ~(1 << 18);
+		__raw_writel(reg, MXC_CCM_WIMR);
+
+		flush_cache_all();
+		l2x0_disable();
+
+		mxc_pm_arch_entry(MX31_IO_ADDRESS(MX31_NFC_BASE_ADDR), 2048);
+		printk(KERN_INFO "Resume from DSM\n");
+
+		l2x0_enable();
+		mxc_init_irq(MX31_IO_ADDRESS(MX31_AVIC_BASE_ADDR));
+
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mx35_suspend_enter(suspend_state_t state)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg &= ~MXC_CCM_CCMR_LPM_MASK;
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+	case PM_SUSPEND_STANDBY:
+		/* Enabled Well Bias */
+		reg |= MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_VSTBY;
+		/* program LPM bit */
+		reg |= 3 << MXC_CCM_CCMR_LPM_OFFSET;
+		/* program Interrupt holdoff bit */
+		reg |= MX35_CCM_CCMR_WFI;
+		/* TBD: PMIC has put the voltage back to
+		 * Normal if the voltage ready
+		 */
+		/* counter finished */
+		reg |= MX35_CCM_CCMR_STBY_EXIT_SRC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	__raw_writel(reg, MXC_CCM_CCMR);
+
+	/* Executing CP15 (Wait-for-Interrupt) Instruction */
+	cpu_do_idle();
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx3_suspend_prepare(void)
+{
+	suspend_ops_started = 1;
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx3_suspend_finish(void)
+{
+	suspend_ops_started = 0;
+	return;
+}
+
+static int mx3_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx3_suspend_ops = {
+	.valid = mx3_pm_valid,
+	.prepare = mx3_suspend_prepare,
+	.enter = mx31_suspend_enter,
+	.finish = mx3_suspend_finish,
+};
+
+static int __init mx3_pm_init(void)
+{
+	printk(KERN_INFO "Power Management for Freescale MX3x\n");
+	if (cpu_is_mx35())
+		mx3_suspend_ops.enter = mx35_suspend_enter;
+	suspend_set_ops(&mx3_suspend_ops);
+
+	return 0;
+}
+
+late_initcall(mx3_pm_init);
diff --git a/arch/arm/mach-mx3/system.c b/arch/arm/mach-mx3/system.c
new file mode 100644
index 0000000..8fe3241
--- /dev/null
+++ b/arch/arm/mach-mx3/system.c
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2004-2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX31 i.MX31 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx3/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX31
+ */
+
+static int clks_initialized;
+static struct clk *sdma_clk, *mbx_clk, *ipu_clk, *mpeg_clk, *vpu_clk, *usb_clk,
+    *rtic_clk, *nfc_clk, *emi_clk;
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	int emi_gated_off = 0;
+
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled) {
+		if (clks_initialized == 0) {
+			clks_initialized = 1;
+			sdma_clk = clk_get(NULL, "sdma_ahb_clk");
+			ipu_clk = clk_get(NULL, "ipu_clk");
+			if (cpu_is_mx31()) {
+				mpeg_clk = clk_get(NULL, "mpeg4_clk");
+				mbx_clk = clk_get(NULL, "mbx_clk");
+			} else {
+				vpu_clk = clk_get(NULL, "vpu_clk");
+			}
+			usb_clk = clk_get(NULL, "usb_ahb_clk");
+			rtic_clk = clk_get(NULL, "rtic_clk");
+			nfc_clk = clk_get(NULL, "nfc_clk");
+			emi_clk = clk_get(NULL, "emi_clk");
+		}
+
+		if ((clk_get_usecount(sdma_clk) == 0)
+		    && (clk_get_usecount(ipu_clk) <= 1)
+		    && (clk_get_usecount(usb_clk) == 0)
+		    && (clk_get_usecount(rtic_clk) == 0)
+		    && (clk_get_usecount(mpeg_clk) == 0)
+		    && (clk_get_usecount(mbx_clk) == 0)
+		    && (clk_get_usecount(nfc_clk) == 0)
+		    && (clk_get_usecount(vpu_clk) == 0)) {
+			emi_gated_off = 1;
+			clk_disable(emi_clk);
+		}
+
+		cpu_do_idle();
+		if (emi_gated_off == 1)
+			clk_enable(emi_clk);
+
+	}
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	/* Assert SRS signal */
+	mxc_wd_reset();
+}
-- 
1.5.4.4

