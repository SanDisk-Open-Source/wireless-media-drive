From 1701c3caa7ed7d183a57301f6513c1f5fb4102cd Mon Sep 17 00:00:00 2001
From: Sammy He <r62914@freescale.com>
Date: Mon, 16 Nov 2009 11:59:54 +0800
Subject: [PATCH] ENGR00118576 MX25: Support Smc911x ethernet

1. Add imx cspi support for cpld access.
2. Add smc911x ethernet support from cpld.

Signed-off-by: Sammy He <r62914@freescale.com>
---
 board/freescale/mx25_3stack/mx25_3stack.c |   30 +++-
 board/freescale/mx51_bbg/mx51_bbg.c       |    2 +-
 cpu/arm926ejs/mx25/generic.c              |    7 +
 cpu/arm926ejs/mx25/timer.c                |   22 +--
 drivers/mtd/spi/imx_spi_nor_atmel.c       |    2 +-
 drivers/mtd/spi/imx_spi_nor_sst.c         |    2 +-
 drivers/net/smc911x.h                     |   16 ++-
 drivers/spi/Makefile                      |    4 +-
 drivers/spi/imx_cspi.c                    |  275 ++++++++++++++++++++++++
 drivers/spi/imx_ecspi.c                   |  329 +++++++++++++++++++++++++++++
 drivers/spi/imx_spi.c                     |  329 -----------------------------
 drivers/spi/imx_spi_cpld.c                |   90 ++++++++
 drivers/spi/imx_spi_pmic.c                |    2 +-
 include/asm-arm/arch-mx25/imx_spi_cpld.h  |   33 +++
 include/asm-arm/arch-mx25/mx25.h          |    1 +
 include/asm-arm/arch-mx51/imx_spi.h       |   66 ------
 include/configs/mx25_3stack.h             |   26 ++-
 include/configs/mx51_3stack_android.h     |    4 +-
 include/configs/mx51_bbg.h                |    6 +-
 include/configs/mx51_bbg_android.h        |    3 +-
 include/imx_spi.h                         |   96 +++++++++
 21 files changed, 910 insertions(+), 435 deletions(-)

diff --git a/board/freescale/mx25_3stack/mx25_3stack.c b/board/freescale/mx25_3stack/mx25_3stack.c
index be1c571..b28cc3d 100644
--- a/board/freescale/mx25_3stack/mx25_3stack.c
+++ b/board/freescale/mx25_3stack/mx25_3stack.c
@@ -31,6 +31,7 @@
 #include <asm/arch/mx25_pins.h>
 #include <asm/arch/iomux.h>
 #include <asm/arch/gpio.h>
+#include <imx_spi.h>
 
 #ifdef CONFIG_CMD_MMC
 #include <mmc.h>
@@ -160,11 +161,28 @@ int board_mmc_init(void)
 }
 #endif
 
-int board_init(void)
+void spi_io_init(struct imx_spi_dev_t *dev)
 {
-	int pad;
-	u8 reg[4];
+	switch (dev->base) {
+	case CSPI1_BASE:
+		writel(0, IOMUXC_BASE + 0x180);		/* CSPI1 SCLK */
+		writel(0x1C0, IOMUXC_BASE + 0x5c4);
+		writel(0, IOMUXC_BASE + 0x184);		/* SPI_RDY */
+		writel(0x1E0, IOMUXC_BASE + 0x5c8);
+		writel(0, IOMUXC_BASE + 0x170);		/* MOSI */
+		writel(0x1C0, IOMUXC_BASE + 0x5b4);
+		writel(0, IOMUXC_BASE + 0x174);		/* MISO */
+		writel(0x1C0, IOMUXC_BASE + 0x5b8);
+		writel(0, IOMUXC_BASE + 0x17C);		/* SS1 */
+		writel(0x1E0, IOMUXC_BASE + 0x5C0);
+		break;
+	default:
+		break;
+	}
+}
 
+int board_init(void)
+{
 	setup_soc_rev();
 
 	/* setup pins for UART1 */
@@ -265,6 +283,12 @@ int board_late_init(void)
 	/* Turn PMIC On*/
 	reg[0] = 0x09;
 	i2c_write(0x54, 0x02, 1, reg, 1);
+
+#ifdef CONFIG_IMX_SPI_CPLD
+	mxc_cpld_spi_init();
+#endif
+
+	return 0;
 }
 #endif
 
diff --git a/board/freescale/mx51_bbg/mx51_bbg.c b/board/freescale/mx51_bbg/mx51_bbg.c
index ca60b32..0a4bc51 100644
--- a/board/freescale/mx51_bbg/mx51_bbg.c
+++ b/board/freescale/mx51_bbg/mx51_bbg.c
@@ -32,7 +32,7 @@
 #include <mxc_keyb.h>
 #include <asm/arch/keypad.h>
 #include "board-imx51.h"
-#include <asm/arch/imx_spi.h>
+#include <imx_spi.h>
 #include <asm/arch/imx_spi_pmic.h>
 
 #include <asm/errno.h>
diff --git a/cpu/arm926ejs/mx25/generic.c b/cpu/arm926ejs/mx25/generic.c
index 23b5cce..5ee10d4 100644
--- a/cpu/arm926ejs/mx25/generic.c
+++ b/cpu/arm926ejs/mx25/generic.c
@@ -70,6 +70,11 @@ unsigned int mx25_get_ipg_clk(void)
 	return mx25_get_ahb_clk()/2;
 }
 
+unsigned int mx25_get_cspi_clk(void)
+{
+	return mx25_get_ipg_clk();
+}
+
 void mx25_dump_clocks(void)
 {
 	u32 cpufreq = mx25_get_mcu_main_clk();
@@ -88,6 +93,8 @@ unsigned int mxc_get_clock(enum mxc_clock clk)
 	case MXC_IPG_PERCLK:
 	case MXC_IPG_CLK:
 		return mx25_get_ipg_clk();
+	case MXC_CSPI_CLK:
+		return mx25_get_cspi_clk();
 	case MXC_UART_CLK:
 		break;
 	}
diff --git a/cpu/arm926ejs/mx25/timer.c b/cpu/arm926ejs/mx25/timer.c
index 8b6a061..1900240 100644
--- a/cpu/arm926ejs/mx25/timer.c
+++ b/cpu/arm926ejs/mx25/timer.c
@@ -84,15 +84,10 @@ void reset_timer(void)
 
 ulong get_timer_masked(void)
 {
-	ulong now = GPTCNT; /* current tick value */
-
-	if (now >= lastinc)	/* normal mode (non roll) */
-		/* move stamp forward with absolut diff ticks */
-		timestamp += (now - lastinc);
-	else			/* we have rollover of incrementer */
-		timestamp += (0xFFFFFFFF - lastinc) + now;
-	lastinc = now;
-	return timestamp;
+	ulong now = GPTCNT;
+	now = now * 1000 / CONFIG_SYS_HZ; /* current tick value */
+
+	return now;
 }
 
 ulong get_timer(ulong base)
@@ -111,14 +106,7 @@ void udelay(unsigned long usec)
 
 	setup_gpt();
 
-	if (usec >= 1000) {	/* if "big" number, spread normalize to secs */
-		tmo = usec / 1000;	/* normalize usec to ticks per sec */
-		tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" to wait */
-		tmo /= 1000;		/* finish normalize. */
-	} else {			/* don't kill prior to HZ multiply */
-		tmo = usec * CONFIG_SYS_HZ;
-		tmo /= (1000*1000);
-	}
+	tmo = usec / 1000;		/* Current precision is Millisecond */
 
 	tmp = get_timer(0);		/* get current timestamp */
 	if ((tmo + tmp + 1) < tmp)	/* if overflow time stamp */
diff --git a/drivers/mtd/spi/imx_spi_nor_atmel.c b/drivers/mtd/spi/imx_spi_nor_atmel.c
index 24d446a..b6180a5 100644
--- a/drivers/mtd/spi/imx_spi_nor_atmel.c
+++ b/drivers/mtd/spi/imx_spi_nor_atmel.c
@@ -28,7 +28,7 @@
 #include <linux/types.h>
 #include <malloc.h>
 
-#include <asm/arch/imx_spi.h>
+#include <imx_spi.h>
 #include <asm/arch/imx_spi_nor.h>
 
 static u8 g_tx_buf[256];
diff --git a/drivers/mtd/spi/imx_spi_nor_sst.c b/drivers/mtd/spi/imx_spi_nor_sst.c
index bd10ca4..2d2b4a0 100644
--- a/drivers/mtd/spi/imx_spi_nor_sst.c
+++ b/drivers/mtd/spi/imx_spi_nor_sst.c
@@ -28,7 +28,7 @@
 #include <linux/types.h>
 #include <malloc.h>
 
-#include <asm/arch/imx_spi.h>
+#include <imx_spi.h>
 #include <asm/arch/imx_spi_nor.h>
 
 static u8 g_tx_buf[256];
diff --git a/drivers/net/smc911x.h b/drivers/net/smc911x.h
index 05e007c..02c33b3 100644
--- a/drivers/net/smc911x.h
+++ b/drivers/net/smc911x.h
@@ -30,7 +30,8 @@
 #define DRIVERNAME "smc911x"
 
 #if defined (CONFIG_SMC911X_32_BIT) && \
-	defined (CONFIG_SMC911X_16_BIT)
+	defined (CONFIG_SMC911X_16_BIT) && \
+	defined(CONFIG_SMC911X_CPLD)
 #error "SMC911X: Only one of CONFIG_SMC911X_32_BIT and \
 	CONFIG_SMC911X_16_BIT shall be set"
 #endif
@@ -62,6 +63,19 @@ static inline void smc911x_reg_write(struct eth_device *dev,
 	*(volatile u16 *)(dev->iobase + offset) = (u16)val;
 	*(volatile u16 *)(dev->iobase + offset + 2) = (u16)(val >> 16);
 }
+#elif defined(CONFIG_SMC911X_CPLD)
+#include <asm/arch/imx_spi_cpld.h>
+static inline u32 smc911x_reg_read(struct eth_device *dev, u32 offset)
+{
+	return cpld_reg_xfer(offset, 0x0, 1) | \
+		(cpld_reg_xfer(offset + 0x2, 0x0, 1) << 16);
+}
+static void smc911x_reg_write(struct eth_device *dev,
+			u32 offset, u32 val)
+{
+	cpld_reg_xfer(offset, val, 0);
+	cpld_reg_xfer(offset + 0x2, (val >> 16), 0);
+}
 #else
 #error "SMC911X: undefined bus width"
 #endif /* CONFIG_SMC911X_16_BIT */
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 0e8bf26..d8a1675 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -34,8 +34,10 @@ COBJS-$(CONFIG_MPC52XX_SPI) += mpc52xx_spi.o
 COBJS-$(CONFIG_MPC8XXX_SPI) += mpc8xxx_spi.o
 COBJS-$(CONFIG_MXC_SPI) += mxc_spi.o
 COBJS-$(CONFIG_SOFT_SPI) += soft_spi.o
-COBJS-$(CONFIG_IMX_SPI) += imx_spi.o
+COBJS-$(CONFIG_IMX_ECSPI) += imx_ecspi.o
+COBJS-$(CONFIG_IMX_CSPI) += imx_cspi.o
 COBJS-$(CONFIG_IMX_SPI_PMIC) += imx_spi_pmic.o
+COBJS-$(CONFIG_IMX_SPI_CPLD) += imx_spi_cpld.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/spi/imx_cspi.c b/drivers/spi/imx_cspi.c
new file mode 100644
index 0000000..51238eb
--- /dev/null
+++ b/drivers/spi/imx_cspi.c
@@ -0,0 +1,275 @@
+/*
+ * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <spi.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <malloc.h>
+
+#include <imx_spi.h>
+
+static inline struct imx_spi_dev_t *to_imx_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct imx_spi_dev_t, slave);
+}
+
+static s32 spi_get_cfg(struct imx_spi_dev_t *dev)
+{
+	switch (dev->slave.cs) {
+	case 0:
+		/* cpld */
+		dev->base = CSPI1_BASE;
+		dev->freq = 25000000;
+		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
+		dev->ss = 0;
+		dev->fifo_sz = 32;
+		dev->us_delay = 0;
+		break;
+	default:
+		printf("Invalid Bus ID! \n");
+		break;
+	}
+
+	return 0;
+}
+
+static s32 spi_reset(struct spi_slave *slave)
+{
+	u32 clk_src = mxc_get_clock(MXC_CSPI_CLK);
+	s32 div = 0, i, reg_ctrl;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *reg = &(dev->reg);
+	int lim = 0;
+	unsigned int baud_rate_div[] = { 4, 8, 16, 32, 64, 128, 256, 512 };
+
+	if (dev->freq == 0) {
+		printf("Error: desired clock is 0\n");
+		return 1;
+	}
+
+	reg_ctrl = readl(dev->base + SPI_CON_REG);
+	/* Reset spi */
+	writel(0, dev->base + SPI_CON_REG);
+	writel((reg_ctrl | SPI_CTRL_EN), dev->base + SPI_CON_REG);
+
+	lim = sizeof(baud_rate_div) / sizeof(unsigned int);
+	if (clk_src > dev->freq) {
+		div = clk_src / dev->freq;
+
+		for (i = 0; i < lim; i++) {
+			if (div <= baud_rate_div[i])
+				break;
+		}
+	}
+	debug("div = %d\n", baud_rate_div[i]);
+
+	reg_ctrl =
+	    (reg_ctrl & ~SPI_CTRL_SS_MASK) | (dev->ss << SPI_CTRL_SS_OFF);
+	reg_ctrl = (reg_ctrl & ~SPI_CTRL_DATA_MASK) | (i << SPI_CTRL_DATA_OFF);
+	reg_ctrl |= SPI_CTRL_MODE;	/* always set to master mode !!!! */
+	reg_ctrl &= ~SPI_CTRL_EN;	/* disable spi */
+
+	/* configuration register setup */
+	reg_ctrl =
+	    (reg_ctrl & ~SPI_CTRL_SSPOL) | (dev->ss_pol << SPI_CTRL_SSPOL_OFF);
+	reg_ctrl =
+	    (reg_ctrl & ~SPI_CTRL_SSCTL) | (dev->ssctl << SPI_CTRL_SSCTL_OFF);
+	reg_ctrl =
+	    (reg_ctrl & ~SPI_CTRL_SCLK_POL) | (dev->
+					       sclkpol <<
+					       SPI_CTRL_SCLK_POL_OFF);
+	reg_ctrl =
+	    (reg_ctrl & ~SPI_CTRL_SCLK_PHA) | (dev->
+					       sclkpha <<
+					       SPI_CTRL_SCLK_PHA_OFF);
+
+	debug("reg_ctrl = 0x%x\n", reg_ctrl);
+	writel(reg_ctrl, dev->base + SPI_CON_REG);
+	/* save control register */
+	reg->ctrl_reg = reg_ctrl;
+
+	/* clear interrupt reg */
+	writel(0, dev->base + SPI_INT_REG);
+	writel(SPI_INT_STAT_TC, dev->base + SPI_STAT_REG);
+
+	return 0;
+}
+
+void spi_init(void)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+				  unsigned int max_hz, unsigned int mode)
+{
+	struct imx_spi_dev_t *imx_spi_slave = NULL;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	imx_spi_slave =
+	    (struct imx_spi_dev_t *)malloc(sizeof(struct imx_spi_dev_t));
+	if (!imx_spi_slave)
+		return NULL;
+
+	imx_spi_slave->slave.bus = bus;
+	imx_spi_slave->slave.cs = cs;
+
+	spi_get_cfg(imx_spi_slave);
+
+	spi_io_init(imx_spi_slave);
+
+	spi_reset(&(imx_spi_slave->slave));
+
+	return &(imx_spi_slave->slave);
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *imx_spi_slave;
+
+	if (slave) {
+		imx_spi_slave = to_imx_spi_slave(slave);
+		free(imx_spi_slave);
+	}
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+
+}
+
+/*
+ * SPI transfer:
+ *
+ * See include/spi.h and http://www.altera.com/literature/ds/ds_nios_spi.pdf
+ * for more informations.
+ */
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+	     void *din, unsigned long flags)
+{
+	s32 val = SPI_RETRY_TIMES;
+	u32 *p_buf;
+	u32 reg;
+	s32 len = 0, ret_val = 0;
+	s32 burst_bytes = bitlen >> 3;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *spi_reg = &(dev->reg);
+
+	if (!slave)
+		return -1;
+
+	if ((bitlen % 8) != 0)
+		burst_bytes++;
+
+	if (burst_bytes > (dev->fifo_sz)) {
+		printf("Error: maximum burst size is 0x%x bytes, asking 0x%x\n",
+		       dev->fifo_sz, burst_bytes);
+		return -1;
+	}
+
+	if (flags & SPI_XFER_BEGIN) {
+		spi_cs_activate(slave);
+
+		if (spi_reg->ctrl_reg == 0) {
+			printf
+			    ("Error: spi(base=0x%x) has not been initialized\n",
+			     dev->base);
+			return -1;
+		}
+
+		spi_reg->ctrl_reg = (spi_reg->ctrl_reg & ~SPI_CTRL_BURST_MASK) |
+		    ((bitlen - 1) << SPI_CTRL_BURST_OFF);
+		writel(spi_reg->ctrl_reg | SPI_CTRL_EN,
+		       dev->base + SPI_CON_REG);
+		debug("ctrl_reg=0x%x\n", readl(dev->base + SPI_CON_REG));
+
+		/* move data to the tx fifo */
+		if (dout) {
+			for (p_buf = (u32 *) dout, len = burst_bytes; len > 0;
+			     p_buf++, len -= 4)
+				writel(*p_buf, dev->base + SPI_TX_DATA);
+		}
+
+		reg = readl(dev->base + SPI_CON_REG);
+		reg |= SPI_CTRL_REG_XCH_BIT;	/* set xch bit */
+		debug("control reg = 0x%08x\n", reg);
+		writel(reg, dev->base + SPI_CON_REG);
+
+		/* poll on the TC bit (transfer complete) */
+		while ((val-- > 0) &&
+		       (((reg =
+			  readl(dev->base + SPI_STAT_REG)) & SPI_INT_STAT_TC) ==
+			0)) {
+			udelay(100);
+		}
+
+		/* clear the TC bit */
+		writel(reg | SPI_INT_STAT_TC, dev->base + SPI_STAT_REG);
+		if (val <= 0) {
+			printf
+			    ("Error: re-tried %d times without response. Give up\n",
+			     SPI_RETRY_TIMES);
+			ret_val = -1;
+			goto error;
+		}
+	}
+
+	/* move data in the rx buf */
+	if (flags & SPI_XFER_END) {
+		if (din) {
+			for (p_buf = (u32 *) din, len = burst_bytes; len > 0;
+			     p_buf++, len -= 4)
+				*p_buf = readl(dev->base + SPI_RX_DATA);
+		}
+	}
+error:
+	spi_cs_deactivate(slave);
+	return ret_val;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	spi_io_init(dev);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	writel(0, dev->base + SPI_CON_REG);
+}
diff --git a/drivers/spi/imx_ecspi.c b/drivers/spi/imx_ecspi.c
new file mode 100644
index 0000000..d9345da
--- /dev/null
+++ b/drivers/spi/imx_ecspi.c
@@ -0,0 +1,329 @@
+/*
+ * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <spi.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <asm/io.h>
+#include <malloc.h>
+
+#include <imx_spi.h>
+
+#ifdef	DEBUG
+
+/* -----------------------------------------------
+ * Helper functions to peek into tx and rx buffers
+ * ----------------------------------------------- */
+static const char * const hex_digit = "0123456789ABCDEF";
+
+static char quickhex(int i)
+{
+	return hex_digit[i];
+}
+
+static void memdump(const void *pv, int num)
+{
+
+}
+
+#else /* !DEBUG */
+
+#define	memdump(p, n)
+
+#endif /* DEBUG */
+
+static inline struct imx_spi_dev_t *to_imx_spi_slave(struct spi_slave *slave)
+{
+	return container_of(slave, struct imx_spi_dev_t, slave);
+}
+
+static s32 spi_get_cfg(struct imx_spi_dev_t *dev)
+{
+	switch (dev->slave.cs) {
+	case 0:
+		/* pmic */
+		dev->base = CSPI1_BASE_ADDR;
+		dev->freq = 2500000;
+		dev->ss_pol = IMX_SPI_ACTIVE_HIGH;
+		dev->ss = 0;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	case 1:
+		/* spi_nor */
+		dev->base = CSPI1_BASE_ADDR;
+		dev->freq = 2500000;
+		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
+		dev->ss = 1;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	default:
+		printf("Invalid Bus ID! \n");
+		break;
+	}
+
+	return 0;
+}
+
+static s32 spi_reset(struct spi_slave *slave)
+{
+	u32 clk_src = mxc_get_clock(MXC_CSPI_CLK);
+	s32 pre_div = 0, post_div = 0, i, reg_ctrl, reg_config;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *reg = &(dev->reg);
+
+	if (dev->freq == 0) {
+		printf("Error: desired clock is 0\n");
+		return 1;
+	}
+
+	reg_ctrl = readl(dev->base + SPI_CON_REG);
+	/* Reset spi */
+	writel(0, dev->base + SPI_CON_REG);
+	writel((reg_ctrl | 0x1), dev->base + SPI_CON_REG);
+
+	/* Control register setup */
+	if (clk_src > dev->freq) {
+		pre_div = clk_src / dev->freq;
+		if (pre_div > 16) {
+			post_div = pre_div / 16;
+			pre_div = 15;
+		}
+		if (post_div != 0) {
+			for (i = 0; i < 16; i++) {
+				if ((1 << i) >= post_div)
+					break;
+			}
+			if (i == 16) {
+				printf("Error: no divider can meet the freq: %d\n",
+					dev->freq);
+				return -1;
+			}
+			post_div = i;
+		}
+	}
+
+	debug("pre_div = %d, post_div=%d\n", pre_div, post_div);
+	reg_ctrl = (reg_ctrl & ~(3 << 18)) | dev->ss << 18;
+	reg_ctrl = (reg_ctrl & ~(0xF << 12)) | pre_div << 12;
+	reg_ctrl = (reg_ctrl & ~(0xF << 8)) | post_div << 8;
+	reg_ctrl |= 1 << (dev->ss + 4);	/* always set to master mode !!!! */
+	reg_ctrl &= ~0x1;		/* disable spi */
+
+	reg_config = readl(dev->base + SPI_CFG_REG);
+	/* configuration register setup */
+	reg_config = (reg_config & ~(1 << ((dev->ss + 12)))) |
+		(dev->ss_pol << (dev->ss + 12));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 20)))) |
+		(dev->in_sctl << (dev->ss + 20));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 16)))) |
+		(dev->in_dctl << (dev->ss + 16));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 8)))) |
+		(dev->ssctl << (dev->ss + 8));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 4)))) |
+		(dev->sclkpol << (dev->ss + 4));
+	reg_config = (reg_config & ~(1 << ((dev->ss + 0)))) |
+		(dev->sclkpha << (dev->ss + 0));
+
+	debug("reg_ctrl = 0x%x\n", reg_ctrl);
+	writel(reg_ctrl, dev->base + SPI_CON_REG);
+	debug("reg_config = 0x%x\n", reg_config);
+	writel(reg_config, dev->base + SPI_CFG_REG);
+
+	/* save config register and control register */
+	reg->cfg_reg  = reg_config;
+	reg->ctrl_reg = reg_ctrl;
+
+	/* clear interrupt reg */
+	writel(0, dev->base + SPI_INT_REG);
+	writel(3 << 6, dev->base + SPI_STAT_REG);
+
+	return 0;
+}
+
+void spi_init(void)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct imx_spi_dev_t *imx_spi_slave = NULL;
+
+	if (!spi_cs_is_valid(bus, cs))
+		return NULL;
+
+	imx_spi_slave = (struct imx_spi_dev_t *)malloc(sizeof(struct imx_spi_dev_t));
+	if (!imx_spi_slave)
+		return NULL;
+
+	imx_spi_slave->slave.bus = bus;
+	imx_spi_slave->slave.cs = cs;
+
+	spi_get_cfg(imx_spi_slave);
+
+	spi_io_init(imx_spi_slave);
+
+	spi_reset(&(imx_spi_slave->slave));
+
+	return &(imx_spi_slave->slave);
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *imx_spi_slave;
+
+	if (slave) {
+		imx_spi_slave = to_imx_spi_slave(slave);
+		free(imx_spi_slave);
+	}
+}
+
+int spi_claim_bus(struct spi_slave *slave)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *slave)
+{
+
+}
+
+/*
+ * SPI transfer:
+ *
+ * See include/spi.h and http://www.altera.com/literature/ds/ds_nios_spi.pdf
+ * for more informations.
+ */
+int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	s32 val = SPI_RETRY_TIMES;
+	u32 *p_buf;
+	u32 reg;
+	s32 len = 0,
+		ret_val = 0;
+	s32 burst_bytes = bitlen >> 3;
+	s32 tmp = 0;
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+	struct spi_reg_t *spi_reg = &(dev->reg);
+
+	if (!slave)
+		return -1;
+
+	if (burst_bytes > (MAX_SPI_BYTES)) {
+		printf("Error: maximum burst size is 0x%x bytes, asking 0x%x\n",
+				MAX_SPI_BYTES, burst_bytes);
+		return -1;
+	}
+
+	if (flags & SPI_XFER_BEGIN) {
+		spi_cs_activate(slave);
+
+		if (spi_reg->ctrl_reg == 0) {
+			printf("Error: spi(base=0x%x) has not been initialized yet\n",
+					dev->base);
+			return -1;
+		}
+		spi_reg->ctrl_reg = (spi_reg->ctrl_reg & ~0xFFF00000) | \
+					((burst_bytes * 8 - 1) << 20);
+
+		writel(spi_reg->ctrl_reg | 0x1, dev->base + SPI_CON_REG);
+		writel(spi_reg->cfg_reg, dev->base + SPI_CFG_REG);
+		debug("ctrl_reg=0x%x, cfg_reg=0x%x\n",
+					 readl(dev->base + SPI_CON_REG),
+					 readl(dev->base + SPI_CFG_REG));
+
+		/* move data to the tx fifo */
+		if (dout) {
+			for (p_buf = (u32 *)dout, len = burst_bytes; len > 0;
+				p_buf++, len -= 4)
+				writel(*p_buf, dev->base + SPI_TX_DATA);
+		} else {
+			for (len = burst_bytes; len > 0; len -= 4)
+				writel(tmp, dev->base + SPI_TX_DATA);
+		}
+
+		reg = readl(dev->base + SPI_CON_REG);
+		reg |= (1 << 2); /* set xch bit */
+		debug("control reg = 0x%08x\n", reg);
+		writel(reg, dev->base + SPI_CON_REG);
+
+		/* poll on the TC bit (transfer complete) */
+		while ((val-- > 0) &&
+			(readl(dev->base + SPI_STAT_REG) & (1 << 7)) == 0) {
+			udelay(100);
+		}
+
+		/* clear the TC bit */
+		writel(3 << 6, dev->base + SPI_STAT_REG);
+		if (val <= 0) {
+			printf("Error: re-tried %d times without response. Give up\n",
+					SPI_RETRY_TIMES);
+			ret_val = -1;
+			goto error;
+		}
+	}
+
+	/* move data in the rx buf */
+	if (flags & SPI_XFER_END) {
+		if (din) {
+			for (p_buf = (u32 *)din, len = burst_bytes; len > 0;
+				++p_buf, len -= 4)
+				*p_buf = readl(dev->base + SPI_RX_DATA);
+		} else {
+			for (len = burst_bytes; len > 0; len -= 4)
+				tmp = readl(dev->base + SPI_RX_DATA);
+		}
+
+		spi_cs_deactivate(slave);
+	}
+
+	return ret_val;
+
+error:
+	spi_cs_deactivate(slave);
+	return ret_val;
+}
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	spi_io_init(dev);
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
+
+	writel(0, dev->base + SPI_CON_REG);
+}
+
diff --git a/drivers/spi/imx_spi.c b/drivers/spi/imx_spi.c
deleted file mode 100644
index 6146da9..0000000
--- a/drivers/spi/imx_spi.c
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-#include <spi.h>
-#include <asm/errno.h>
-#include <linux/types.h>
-#include <asm/io.h>
-#include <malloc.h>
-
-#include <asm/arch/imx_spi.h>
-
-#ifdef	DEBUG
-
-/* -----------------------------------------------
- * Helper functions to peek into tx and rx buffers
- * ----------------------------------------------- */
-static const char * const hex_digit = "0123456789ABCDEF";
-
-static char quickhex(int i)
-{
-	return hex_digit[i];
-}
-
-static void memdump(const void *pv, int num)
-{
-
-}
-
-#else /* !DEBUG */
-
-#define	memdump(p, n)
-
-#endif /* DEBUG */
-
-static inline struct imx_spi_dev_t *to_imx_spi_slave(struct spi_slave *slave)
-{
-	return container_of(slave, struct imx_spi_dev_t, slave);
-}
-
-static s32 spi_get_cfg(struct imx_spi_dev_t *dev)
-{
-	switch (dev->slave.cs) {
-	case 0:
-		/* pmic */
-		dev->base = CSPI1_BASE_ADDR;
-		dev->freq = 2500000;
-		dev->ss_pol = IMX_SPI_ACTIVE_HIGH;
-		dev->ss = 0;
-		dev->fifo_sz = 64 * 4;
-		dev->us_delay = 0;
-		break;
-	case 1:
-		/* spi_nor */
-		dev->base = CSPI1_BASE_ADDR;
-		dev->freq = 2500000;
-		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
-		dev->ss = 1;
-		dev->fifo_sz = 64 * 4;
-		dev->us_delay = 0;
-		break;
-	default:
-		printf("Invalid Bus ID! \n");
-		break;
-	}
-
-	return 0;
-}
-
-static s32 spi_reset(struct spi_slave *slave)
-{
-	u32 clk_src = mxc_get_clock(MXC_CSPI_CLK);
-	s32 pre_div = 0, post_div = 0, i, reg_ctrl, reg_config;
-	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
-	struct spi_reg_t *reg = &(dev->reg);
-
-	if (dev->freq == 0) {
-		printf("Error: desired clock is 0\n");
-		return 1;
-	}
-
-	reg_ctrl = readl(dev->base + SPI_CON_REG);
-	/* Reset spi */
-	writel(0, dev->base + SPI_CON_REG);
-	writel((reg_ctrl | 0x1), dev->base + SPI_CON_REG);
-
-	/* Control register setup */
-	if (clk_src > dev->freq) {
-		pre_div = clk_src / dev->freq;
-		if (pre_div > 16) {
-			post_div = pre_div / 16;
-			pre_div = 15;
-		}
-		if (post_div != 0) {
-			for (i = 0; i < 16; i++) {
-				if ((1 << i) >= post_div)
-					break;
-			}
-			if (i == 16) {
-				printf("Error: no divider can meet the freq: %d\n",
-					dev->freq);
-				return -1;
-			}
-			post_div = i;
-		}
-	}
-
-	debug("pre_div = %d, post_div=%d\n", pre_div, post_div);
-	reg_ctrl = (reg_ctrl & ~(3 << 18)) | dev->ss << 18;
-	reg_ctrl = (reg_ctrl & ~(0xF << 12)) | pre_div << 12;
-	reg_ctrl = (reg_ctrl & ~(0xF << 8)) | post_div << 8;
-	reg_ctrl |= 1 << (dev->ss + 4);	/* always set to master mode !!!! */
-	reg_ctrl &= ~0x1;		/* disable spi */
-
-	reg_config = readl(dev->base + SPI_CFG_REG);
-	/* configuration register setup */
-	reg_config = (reg_config & ~(1 << ((dev->ss + 12)))) |
-		(dev->ss_pol << (dev->ss + 12));
-	reg_config = (reg_config & ~(1 << ((dev->ss + 20)))) |
-		(dev->in_sctl << (dev->ss + 20));
-	reg_config = (reg_config & ~(1 << ((dev->ss + 16)))) |
-		(dev->in_dctl << (dev->ss + 16));
-	reg_config = (reg_config & ~(1 << ((dev->ss + 8)))) |
-		(dev->ssctl << (dev->ss + 8));
-	reg_config = (reg_config & ~(1 << ((dev->ss + 4)))) |
-		(dev->sclkpol << (dev->ss + 4));
-	reg_config = (reg_config & ~(1 << ((dev->ss + 0)))) |
-		(dev->sclkpha << (dev->ss + 0));
-
-	debug("reg_ctrl = 0x%x\n", reg_ctrl);
-	writel(reg_ctrl, dev->base + SPI_CON_REG);
-	debug("reg_config = 0x%x\n", reg_config);
-	writel(reg_config, dev->base + SPI_CFG_REG);
-
-	/* save config register and control register */
-	reg->cfg_reg  = reg_config;
-	reg->ctrl_reg = reg_ctrl;
-
-	/* clear interrupt reg */
-	writel(0, dev->base + SPI_INT_REG);
-	writel(3 << 6, dev->base + SPI_STAT_REG);
-
-	return 0;
-}
-
-void spi_init(void)
-{
-}
-
-struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
-		unsigned int max_hz, unsigned int mode)
-{
-	struct imx_spi_dev_t *imx_spi_slave = NULL;
-
-	if (!spi_cs_is_valid(bus, cs))
-		return NULL;
-
-	imx_spi_slave = (struct imx_spi_dev_t *)malloc(sizeof(struct imx_spi_dev_t));
-	if (!imx_spi_slave)
-		return NULL;
-
-	imx_spi_slave->slave.bus = bus;
-	imx_spi_slave->slave.cs = cs;
-
-	spi_get_cfg(imx_spi_slave);
-
-	spi_io_init(imx_spi_slave);
-
-	spi_reset(&(imx_spi_slave->slave));
-
-	return &(imx_spi_slave->slave);
-}
-
-void spi_free_slave(struct spi_slave *slave)
-{
-	struct imx_spi_dev_t *imx_spi_slave;
-
-	if (slave) {
-		imx_spi_slave = to_imx_spi_slave(slave);
-		free(imx_spi_slave);
-	}
-}
-
-int spi_claim_bus(struct spi_slave *slave)
-{
-	return 0;
-}
-
-void spi_release_bus(struct spi_slave *slave)
-{
-
-}
-
-/*
- * SPI transfer:
- *
- * See include/spi.h and http://www.altera.com/literature/ds/ds_nios_spi.pdf
- * for more informations.
- */
-int spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
-		void *din, unsigned long flags)
-{
-	s32 val = SPI_RETRY_TIMES;
-	u32 *p_buf;
-	u32 reg;
-	s32 len = 0,
-		ret_val = 0;
-	s32 burst_bytes = bitlen >> 3;
-	s32 tmp = 0;
-	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
-	struct spi_reg_t *spi_reg = &(dev->reg);
-
-	if (!slave)
-		return -1;
-
-	if (burst_bytes > (MAX_SPI_BYTES)) {
-		printf("Error: maximum burst size is 0x%x bytes, asking 0x%x\n",
-				MAX_SPI_BYTES, burst_bytes);
-		return -1;
-	}
-
-	if (flags & SPI_XFER_BEGIN) {
-		spi_cs_activate(slave);
-
-		if (spi_reg->ctrl_reg == 0) {
-			printf("Error: spi(base=0x%x) has not been initialized yet\n",
-					dev->base);
-			return -1;
-		}
-		spi_reg->ctrl_reg = (spi_reg->ctrl_reg & ~0xFFF00000) | \
-					((burst_bytes * 8 - 1) << 20);
-
-		writel(spi_reg->ctrl_reg | 0x1, dev->base + SPI_CON_REG);
-		writel(spi_reg->cfg_reg, dev->base + SPI_CFG_REG);
-		debug("ctrl_reg=0x%x, cfg_reg=0x%x\n",
-					 readl(dev->base + SPI_CON_REG),
-					 readl(dev->base + SPI_CFG_REG));
-
-		/* move data to the tx fifo */
-		if (dout) {
-			for (p_buf = (u32 *)dout, len = burst_bytes; len > 0;
-				p_buf++, len -= 4)
-				writel(*p_buf, dev->base + SPI_TX_DATA);
-		} else {
-			for (len = burst_bytes; len > 0; len -= 4)
-				writel(tmp, dev->base + SPI_TX_DATA);
-		}
-
-		reg = readl(dev->base + SPI_CON_REG);
-		reg |= (1 << 2); /* set xch bit */
-		debug("control reg = 0x%08x\n", reg);
-		writel(reg, dev->base + SPI_CON_REG);
-
-		/* poll on the TC bit (transfer complete) */
-		while ((val-- > 0) &&
-			(readl(dev->base + SPI_STAT_REG) & (1 << 7)) == 0) {
-			udelay(100);
-		}
-
-		/* clear the TC bit */
-		writel(3 << 6, dev->base + SPI_STAT_REG);
-		if (val <= 0) {
-			printf("Error: re-tried %d times without response. Give up\n",
-					SPI_RETRY_TIMES);
-			ret_val = -1;
-			goto error;
-		}
-	}
-
-	/* move data in the rx buf */
-	if (flags & SPI_XFER_END) {
-		if (din) {
-			for (p_buf = (u32 *)din, len = burst_bytes; len > 0;
-				++p_buf, len -= 4)
-				*p_buf = readl(dev->base + SPI_RX_DATA);
-		} else {
-			for (len = burst_bytes; len > 0; len -= 4)
-				tmp = readl(dev->base + SPI_RX_DATA);
-		}
-
-		spi_cs_deactivate(slave);
-	}
-
-	return ret_val;
-
-error:
-	spi_cs_deactivate(slave);
-	return ret_val;
-}
-
-int spi_cs_is_valid(unsigned int bus, unsigned int cs)
-{
-	return 1;
-}
-
-void spi_cs_activate(struct spi_slave *slave)
-{
-	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
-
-	spi_io_init(dev);
-}
-
-void spi_cs_deactivate(struct spi_slave *slave)
-{
-	struct imx_spi_dev_t *dev = to_imx_spi_slave(slave);
-
-	writel(0, dev->base + SPI_CON_REG);
-}
-
diff --git a/drivers/spi/imx_spi_cpld.c b/drivers/spi/imx_spi_cpld.c
new file mode 100644
index 0000000..2e20b9c
--- /dev/null
+++ b/drivers/spi/imx_spi_cpld.c
@@ -0,0 +1,90 @@
+/*
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <spi.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+
+#include <imx_spi.h>
+
+static struct spi_slave *cpld_slave;
+
+/*!
+ * To read/write to a CPLD register.
+ *
+ * @param   reg         register number inside the CPLD
+ * @param   val         data to be written to the register; don't care for read
+ * @param   read        0 for write; 1 for read
+ *
+ * @return              the actual data in the CPLD register
+ */
+unsigned int cpld_reg_xfer(unsigned int reg, unsigned int val,
+			   unsigned int read)
+{
+	unsigned int local_val1, local_val2;
+	unsigned int g_tx_buf[2], g_rx_buf[2];
+
+	reg >>= 1;
+
+	local_val1 = (read << 13) | ((reg & 0x0001FFFF) >> 5) | 0x00001000;
+	if (read)
+		local_val2 = (((reg & 0x0000001F) << 27) | 0x0200001f);
+	else
+		local_val2 =
+		    (((reg & 0x0000001F) << 27) | ((val & 0x0000FFFF) << 6) |
+		     0x03C00027);
+
+	*g_tx_buf = local_val1;
+	*(g_tx_buf + 1) = local_val2;
+
+	if (read) {
+		if (spi_xfer(cpld_slave, 46, (u8 *) g_tx_buf, (u8 *) g_rx_buf,
+			     SPI_XFER_BEGIN | SPI_XFER_END)) {
+			return -1;
+		}
+	} else {
+		if (spi_xfer(cpld_slave, 46, (u8 *) g_tx_buf, (u8 *) g_rx_buf,
+			     SPI_XFER_BEGIN)) {
+			return -1;
+		}
+	}
+	return ((*(g_rx_buf + 1)) >> 6) & 0xffff;
+}
+
+struct spi_slave *spi_cpld_probe()
+{
+	cpld_slave = spi_setup_slave(0, 0, 25000000, 0);
+	return cpld_slave;
+}
+
+void mxc_cpld_spi_init(void)
+{
+	spi_cpld_probe();
+}
+
+void spi_cpld_free(struct spi_slave *slave)
+{
+	if (slave)
+		spi_free_slave(slave);
+}
diff --git a/drivers/spi/imx_spi_pmic.c b/drivers/spi/imx_spi_pmic.c
index 678f0b4..ec32277 100644
--- a/drivers/spi/imx_spi_pmic.c
+++ b/drivers/spi/imx_spi_pmic.c
@@ -26,7 +26,7 @@
 #include <asm/errno.h>
 #include <linux/types.h>
 
-#include <asm/arch/imx_spi.h>
+#include <imx_spi.h>
 
 static u32 pmic_tx, pmic_rx;
 
diff --git a/include/asm-arm/arch-mx25/imx_spi_cpld.h b/include/asm-arm/arch-mx25/imx_spi_cpld.h
new file mode 100644
index 0000000..f0fa00c
--- /dev/null
+++ b/include/asm-arm/arch-mx25/imx_spi_cpld.h
@@ -0,0 +1,33 @@
+/*
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _IMX_SPI_CPLD_H_
+#define _IMX_SPI_CPLD_H_
+
+#include <linux/types.h>
+
+extern struct spi_slave *spi_cpld_probe();
+extern void spi_cpld_free(struct spi_slave *slave);
+extern unsigned int cpld_reg_xfer(unsigned int reg, unsigned int val,
+				  unsigned int read);
+
+#endif				/* _IMX_SPI_CPLD_H_ */
diff --git a/include/asm-arm/arch-mx25/mx25.h b/include/asm-arm/arch-mx25/mx25.h
index 60e0de0..a51b893 100644
--- a/include/asm-arm/arch-mx25/mx25.h
+++ b/include/asm-arm/arch-mx25/mx25.h
@@ -36,6 +36,7 @@ enum mxc_clock {
 	MXC_IPG_CLK,
 	MXC_IPG_PERCLK,
 	MXC_UART_CLK,
+	MXC_CSPI_CLK
 };
 
 extern unsigned int mx25_get_ipg_clk(void);
diff --git a/include/asm-arm/arch-mx51/imx_spi.h b/include/asm-arm/arch-mx51/imx_spi.h
deleted file mode 100644
index c9d51e9..0000000
--- a/include/asm-arm/arch-mx51/imx_spi.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __IMX_SPI_H__
-#define __IMX_SPI_H__
-
-#include <spi.h>
-
-#undef IMX_SPI_DEBUG
-
-#define IMX_SPI_ACTIVE_HIGH     1
-#define IMX_SPI_ACTIVE_LOW      0
-#define SPI_RETRY_TIMES         100
-
-#define	SPI_RX_DATA				0x0
-#define SPI_TX_DATA				0x4
-#define SPI_CON_REG				0x8
-#define SPI_CFG_REG				0xc
-#define SPI_INT_REG				0x10
-#define SPI_DMA_REG				0x14
-#define SPI_STAT_REG				0x18
-#define SPI_PERIOD_REG				0x1C
-
-struct spi_reg_t {
-	u32 ctrl_reg;
-	u32 cfg_reg;
-};
-
-struct imx_spi_dev_t {
-	struct spi_slave slave;
-	u32 base;      /* base address of SPI module the device is connected to */
-	u32 freq;      /* desired clock freq in Hz for this device */
-	u32 ss_pol;    /* ss polarity: 1=active high; 0=active low */
-	u32 ss;        /* slave select */
-	u32 in_sctl;   /* inactive sclk ctl: 1=stay low; 0=stay high */
-	u32 in_dctl;   /* inactive data ctl: 1=stay low; 0=stay high */
-	u32 ssctl;     /* single burst mode vs multiple: 0=single; 1=multi */
-	u32 sclkpol;   /* sclk polarity: active high=0; active low=1 */
-	u32 sclkpha;   /* sclk phase: 0=phase 0; 1=phase1 */
-	u32 fifo_sz;   /* fifo size in bytes for either tx or rx. Don't add them up! */
-	u32 us_delay;  /* us delay in each xfer */
-	struct spi_reg_t reg; /* pointer to a set of SPI registers */
-};
-
-extern void spi_io_init(struct imx_spi_dev_t *dev);
-
-#endif /* __IMX_SPI_H__ */
diff --git a/include/configs/mx25_3stack.h b/include/configs/mx25_3stack.h
index 8272cbe..aa24d53 100644
--- a/include/configs/mx25_3stack.h
+++ b/include/configs/mx25_3stack.h
@@ -39,6 +39,10 @@
 #define CONFIG_MX25_HCLK_FREQ	24000000
 #define CONFIG_MX25_CLK32	32768
 
+#define CONFIG_IMX_CSPI		1
+#define IMX_CSPI_VER_0_7	1
+#define CONFIG_IMX_SPI_CPLD
+
 /* IF iMX25 3DS V-1.0 define it */
 /* #define CONFIG_MX25_3DS_V10 */
 
@@ -122,23 +126,29 @@
 
 #define	CONFIG_EXTRA_ENV_SETTINGS					\
 	"netdev=eth0\0"							\
-	"ethprime=fec\0"						\
+	"ethprime=smc911x-0\0"						\
+	"uboot=u-boot.bin\0"						\
+	"uboot_addr=0xa0000000\0"					\
+	"kernel=uImage\0"						\
 	"bootargs_base=setenv bootargs console=ttymxc0,115200\0"	\
 	"bootargs_nfs=setenv bootargs $(bootargs) root=/dev/nfs "	\
 		"ip=dhcp nfsroot=$(serverip):$(nfsrootfs),v3,tcp\0"	\
 	"bootcmd=run bootcmd_net\0"					\
-	"bootcmd_net=run bootargs_base bootargs_mtd bootargs_nfs; "	\
-		"tftpboot 0x81000000 uImage; bootm\0"
+	"bootcmd_net=run bootargs_base bootargs_nfs; "			\
+		"tftpboot ${loadaddr} ${kernel}; bootm\0"		\
+	"load_uboot=tftpboot ${loadaddr} ${uboot}\0"
 
 /*Support LAN9217*/
-/*#define CONFIG_SMC911X   1
-#define CONFIG_SMC911X_16_BIT 1
-#define CONFIG_SMC911X_BASE CS5_BASE*/
+#define CONFIG_SMC911X
+#define CONFIG_SMC911X_CPLD
+#define CONFIG_SMC911X_BASE	0
 
-/*#define CONFIG_HAS_ETH1*/
+#define CONFIG_HAS_ETH1
 #define CONFIG_CMD_NET
 #define CONFIG_CMD_DHCP
-#define CONFIG_NET_MULTI	1
+#define CONFIG_NET_MULTI
+#define CONFIG_ETH_PRIME
+
 #define CONFIG_MXC_FEC
 #define CONFIG_MII
 #define CONFIG_DISCOVER_PHY
diff --git a/include/configs/mx51_3stack_android.h b/include/configs/mx51_3stack_android.h
index 7661713..04bcbb8 100644
--- a/include/configs/mx51_3stack_android.h
+++ b/include/configs/mx51_3stack_android.h
@@ -77,10 +77,10 @@
 #define CONFIG_CMD_SF
 #define CONFIG_SPI_FLASH_IMX_ATMEL	1
 #define CONFIG_SPI_FLASH_CS	1
-#define CONFIG_IMX_SPI
+#define CONFIG_IMX_ECSPI
 #define CONFIG_IMX_SPI_PMIC
 #define CONFIG_IMX_SPI_PMIC_CS 0
-
+#define IMX_CSPI_VER_2_3	1
 #define MAX_SPI_BYTES		(64 * 4)
 */
 
diff --git a/include/configs/mx51_bbg.h b/include/configs/mx51_bbg.h
index 64f0e2b..e00ae62 100644
--- a/include/configs/mx51_bbg.h
+++ b/include/configs/mx51_bbg.h
@@ -73,10 +73,10 @@
 #define CONFIG_FSL_SF		1
 #define CONFIG_SPI_FLASH_IMX_ATMEL	1
 #define CONFIG_SPI_FLASH_CS	1
-#define CONFIG_IMX_SPI
+#define CONFIG_IMX_ECSPI
 #define CONFIG_IMX_SPI_PMIC
-#define CONFIG_IMX_SPI_PMIC_CS 0
-
+#define CONFIG_IMX_SPI_PMIC_CS	0
+#define	IMX_CSPI_VER_2_3	1
 #define MAX_SPI_BYTES		(64 * 4)
 
 /*
diff --git a/include/configs/mx51_bbg_android.h b/include/configs/mx51_bbg_android.h
index f791f4d..24ffc6c 100644
--- a/include/configs/mx51_bbg_android.h
+++ b/include/configs/mx51_bbg_android.h
@@ -227,9 +227,10 @@
 #define CONFIG_CMD_SF
 #define CONFIG_SPI_FLASH_IMX_ATMEL	1
 #define CONFIG_SPI_FLASH_CS	1
-#define CONFIG_IMX_SPI
+#define CONFIG_IMX_ECSPI
 #define CONFIG_IMX_SPI_PMIC
 #define CONFIG_IMX_SPI_PMIC_CS 0
+#define IMX_CSPI_VER_2_3        1
 
 #define MAX_SPI_BYTES		(64 * 4)
 
diff --git a/include/imx_spi.h b/include/imx_spi.h
new file mode 100644
index 0000000..e4f6444
--- /dev/null
+++ b/include/imx_spi.h
@@ -0,0 +1,96 @@
+/*
+ * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __IMX_SPI_H__
+#define __IMX_SPI_H__
+
+#include <spi.h>
+
+#undef IMX_SPI_DEBUG
+
+#define IMX_SPI_ACTIVE_HIGH     1
+#define IMX_SPI_ACTIVE_LOW      0
+#define SPI_RETRY_TIMES         100
+
+#if defined(IMX_CSPI_VER_0_7)
+	#define	SPI_RX_DATA		0x0
+	#define SPI_TX_DATA		0x4
+	#define SPI_CON_REG		0x8
+	#define SPI_INT_REG		0xC
+	#define SPI_DMA_REG		0x10
+	#define SPI_STAT_REG		0x14
+	#define SPI_PERIOD_REG		0x18
+
+	#define SPI_CTRL_EN		(1 << 0)
+	#define SPI_CTRL_MODE		(1 << 1)
+	#define SPI_CTRL_REG_XCH_BIT	(1 << 2)
+	#define SPI_CTRL_SSPOL		(1 << 7)
+	#define SPI_CTRL_SSPOL_OFF	(7)
+	#define SPI_CTRL_SSCTL		(1 << 6)
+	#define SPI_CTRL_SSCTL_OFF	(6)
+	#define SPI_CTRL_SCLK_POL	(1 << 4)
+	#define SPI_CTRL_SCLK_POL_OFF	(4)
+	#define SPI_CTRL_SCLK_PHA	(1 << 5)
+	#define SPI_CTRL_SCLK_PHA_OFF	(5)
+	#define SPI_CTRL_SS_OFF		(12)
+	#define SPI_CTRL_SS_MASK	(3 << 12)
+	#define SPI_CTRL_DATA_OFF	(16)
+	#define SPI_CTRL_DATA_MASK	(7 << 16)
+	#define SPI_CTRL_BURST_OFF	(20)
+	#define SPI_CTRL_BURST_MASK	(0xFFF << 20)
+	#define SPI_INT_STAT_TC		(1 << 7)
+
+#elif defined(IMX_CSPI_VER_2_3)
+	#define	SPI_RX_DATA		0x0
+	#define SPI_TX_DATA		0x4
+	#define SPI_CON_REG		0x8
+	#define SPI_CFG_REG		0xC
+	#define SPI_INT_REG		0x10
+	#define SPI_DMA_REG		0x14
+	#define SPI_STAT_REG		0x18
+	#define SPI_PERIOD_REG		0x1C
+#endif
+
+struct spi_reg_t {
+	u32 ctrl_reg;
+	u32 cfg_reg;
+};
+
+struct imx_spi_dev_t {
+	struct spi_slave slave;
+	u32 base;      /* base address of SPI module the device is connected to */
+	u32 freq;      /* desired clock freq in Hz for this device */
+	u32 ss_pol;    /* ss polarity: 1=active high; 0=active low */
+	u32 ss;        /* slave select */
+	u32 in_sctl;   /* inactive sclk ctl: 1=stay low; 0=stay high */
+	u32 in_dctl;   /* inactive data ctl: 1=stay low; 0=stay high */
+	u32 ssctl;     /* single burst mode vs multiple: 0=single; 1=multi */
+	u32 sclkpol;   /* sclk polarity: active high=0; active low=1 */
+	u32 sclkpha;   /* sclk phase: 0=phase 0; 1=phase1 */
+	u32 fifo_sz;   /* fifo size in bytes for either tx or rx. Don't add them up! */
+	u32 us_delay;  /* us delay in each xfer */
+	struct spi_reg_t reg; /* pointer to a set of SPI registers */
+};
+
+extern void spi_io_init(struct imx_spi_dev_t *dev);
+
+#endif /* __IMX_SPI_H__ */
-- 
1.5.4.4

