From 90bfe6af18c84a7e3ba424cba0c2602d883bd286 Mon Sep 17 00:00:00 2001
From: Terry Lv <r65388@freescale.com>
Date: Wed, 12 May 2010 22:49:24 +0800
Subject: [PATCH] ENGR00122651: Add dwc_ahsata support

Add dwc_ahsata support.

Signed-off-by: Terry Lv <r65388@freescale.com>
---
 board/freescale/mx53_evk/mx53_evk.c |   11 +-
 common/cmd_sata.c                   |   12 +-
 cpu/arm_cortexa8/mx53/generic.c     |    2 +
 drivers/block/Makefile              |    1 +
 drivers/block/ahci.c                |    5 +-
 drivers/block/dwc_ahsata.c          | 1116 +++++++++++++++++++++++++++++++++++
 drivers/block/dwc_ahsata.h          |  333 +++++++++++
 drivers/mtd/spi/imx_spi_nor_atmel.c |    3 +-
 drivers/net/mxc_fec.c               |   32 +-
 include/ahci.h                      |   14 +-
 include/asm-arm/arch-mx35/mmu.h     |    8 +-
 include/asm-arm/arch-mx51/mmu.h     |   18 +-
 include/asm-arm/arch-mx53/mmu.h     |   10 +-
 include/asm-arm/arch-mx53/mx53.h    |    8 +-
 include/configs/mx53_arm2.h         |   18 +-
 include/configs/mx53_evk.h          |   14 +
 16 files changed, 1559 insertions(+), 46 deletions(-)

diff --git a/board/freescale/mx53_evk/mx53_evk.c b/board/freescale/mx53_evk/mx53_evk.c
index 24fc9c5..f9731bf 100644
--- a/board/freescale/mx53_evk/mx53_evk.c
+++ b/board/freescale/mx53_evk/mx53_evk.c
@@ -52,7 +52,6 @@ DECLARE_GLOBAL_DATA_PTR;
 
 static u32 system_rev;
 static enum boot_device boot_dev;
-u32	mx51_io_base_addr;
 
 static inline void setup_boot_device(void)
 {
@@ -287,6 +286,7 @@ void setup_core_voltages(void)
 	writel(0x0, CCM_BASE_ADDR + CLKCTL_CACRR);
 }
 
+#ifndef CONFIG_MX53_ARM2
 static int __read_adc_channel(unsigned int chan)
 {
 	unsigned char buf[4] = { 0 };
@@ -475,6 +475,7 @@ int identify_board_id(void)
 
 }
 #endif
+#endif
 
 void spi_io_init(struct imx_spi_dev_t *dev)
 {
@@ -714,10 +715,16 @@ int checkboard(void)
 {
 	printf("Board: ");
 
+#ifdef CONFIG_MX53_ARM2
+	printf("Board: MX53 ARMADILLO2 ");
+	printf("1.0 [");
+#else
 #ifdef CONFIG_I2C_MXC
 	identify_board_id();
-#endif
+
 	printf("Boot Reason: [");
+#endif
+#endif
 
 	switch (__REG(SRC_BASE_ADDR + 0x8)) {
 	case 0x0001:
diff --git a/common/cmd_sata.c b/common/cmd_sata.c
index 1693a7e..cd21f2a 100644
--- a/common/cmd_sata.c
+++ b/common/cmd_sata.c
@@ -1,4 +1,7 @@
 /*
+ * (C) Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
  * Copyright (C) 2000-2005, DENX Software Engineering
  *		Wolfgang Denk <wd@denx.de>
  * Copyright (C) Procsys. All rights reserved.
@@ -48,9 +51,12 @@ int __sata_initialize(void)
 		sata_dev_desc[i].block_write = sata_write;
 
 		rc = init_sata(i);
-		rc = scan_sata(i);
-		if ((sata_dev_desc[i].lba > 0) && (sata_dev_desc[i].blksz > 0))
-			init_part(&sata_dev_desc[i]);
+		if (!rc) {
+			rc = scan_sata(i);
+			if ((sata_dev_desc[i].lba > 0) &&
+				(sata_dev_desc[i].blksz > 0))
+				init_part(&sata_dev_desc[i]);
+		}
 	}
 	sata_curr_device = 0;
 	return rc;
diff --git a/cpu/arm_cortexa8/mx53/generic.c b/cpu/arm_cortexa8/mx53/generic.c
index cba38ec..53bc09f 100644
--- a/cpu/arm_cortexa8/mx53/generic.c
+++ b/cpu/arm_cortexa8/mx53/generic.c
@@ -477,6 +477,8 @@ unsigned int mxc_get_clock(enum mxc_clock clk)
 		return __get_esdhc3_clk();
 	case MXC_ESDHC4_CLK:
 		return __get_esdhc4_clk();
+	case MXC_SATA_CLK:
+		return __get_ahb_clk();
 	default:
 		break;
 	}
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 0a5dc8c..1ce481e 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -27,6 +27,7 @@ LIB	:= $(obj)libblock.a
 
 COBJS-$(CONFIG_ATA_PIIX) += ata_piix.o
 COBJS-$(CONFIG_CMD_MG_DISK) += mg_disk.o
+COBJS-$(CONFIG_DWC_AHSATA) += dwc_ahsata.o
 COBJS-$(CONFIG_FSL_SATA) += fsl_sata.o
 COBJS-$(CONFIG_IDE_SIL680) += sil680.o
 COBJS-$(CONFIG_LIBATA) += libata.o
diff --git a/drivers/block/ahci.c b/drivers/block/ahci.c
index a3ca2dc..0ca220d 100644
--- a/drivers/block/ahci.c
+++ b/drivers/block/ahci.c
@@ -1,4 +1,7 @@
 /*
+ * (C) Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
  * Copyright (C) Freescale Semiconductor, Inc. 2006.
  * Author: Jason Jin<Jason.jin@freescale.com>
  *         Zhang Wei<wei.zhang@freescale.com>
@@ -390,7 +393,7 @@ static int ahci_port_start(u8 port)
 	 */
 	pp->cmd_slot = (struct ahci_cmd_hdr *)mem;
 	debug("cmd_slot = 0x%x\n", pp->cmd_slot);
-	mem += (AHCI_CMD_SLOT_SZ + 224);
+	mem += (AHCI_CMD_SLOT_SZ * AHCI_MAX_CMD_SLOT);
 
 	/*
 	 * Second item: Received-FIS area
diff --git a/drivers/block/dwc_ahsata.c b/drivers/block/dwc_ahsata.c
new file mode 100644
index 0000000..3a78490
--- /dev/null
+++ b/drivers/block/dwc_ahsata.c
@@ -0,0 +1,1116 @@
+/*
+ * (C) Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * with the reference on libata and ahci drvier in kernel
+ *
+ */
+#include "dwc_ahsata.h"
+
+#ifdef CONFIG_ARCH_MMU
+#include <asm/arch/mmu.h>
+#endif
+
+#include <libata.h>
+#include <ahci.h>
+#include <fis.h>
+
+#include <common.h>
+#include <malloc.h>
+#include <linux/ctype.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <linux/bitops.h>
+
+struct sata_port_regs {
+	u32 clb;
+	u32 clbu;
+	u32 fb;
+	u32 fbu;
+	u32 is;
+	u32 ie;
+	u32 cmd;
+	u32 res1[1];
+	u32 tfd;
+	u32 sig;
+	u32 ssts;
+	u32 sctl;
+	u32 serr;
+	u32 sact;
+	u32 ci;
+	u32 sntf;
+	u32 res2[1];
+	u32 dmacr;
+	u32 res3[1];
+	u32 phycr;
+	u32 physr;
+};
+
+struct sata_host_regs {
+	u32 cap;
+	u32 ghc;
+	u32 is;
+	u32 pi;
+	u32 vs;
+	u32 ccc_ctl;
+	u32 ccc_ports;
+	u32 res1[2];
+	u32 cap2;
+	u32 res2[30];
+	u32 bistafr;
+	u32 bistcr;
+	u32 bistfctr;
+	u32 bistsr;
+	u32 bistdecr;
+	u32 res3[2];
+	u32 oobr;
+	u32 res4[8];
+	u32 timer1ms;
+	u32 res5[1];
+	u32 gparam1r;
+	u32 gparam2r;
+	u32 pparamr;
+	u32 testr;
+	u32 versionr;
+	u32 idr;
+};
+
+#define MAX_DATA_BYTES_PER_SG  (4 * 1024 * 1024)
+#define MAX_BYTES_PER_TRANS (AHCI_MAX_SG * MAX_DATA_BYTES_PER_SG)
+
+#define writel_with_flush(a, b)	do { writel(a, b); readl(b); } while (0)
+
+#ifdef CONFIG_ARCH_MMU
+static u8 *dma_buf;
+#endif
+static int is_ready;
+extern block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
+
+static inline void mdelay(u32 msec)
+{
+	u32 i;
+	for (i = 0; i < msec; ++i)
+		udelay(1000);
+}
+
+static inline void sdelay(u32 sec)
+{
+	u32 i;
+	for (i = 0; i < sec; ++i)
+		mdelay(1000);
+}
+
+void dprint_buffer(u8 *buf, s32 len)
+{
+	s32 i, j;
+
+	i = 0;
+	j = 0;
+	printf("\n\r");
+
+	for (i = 0; i < len; ++i) {
+		printf("%02x ", *buf++);
+		j++;
+		if (j == 16) {
+			printf("\n\r");
+			j = 0;
+		}
+	}
+	printf("\n\r");
+}
+
+static inline u32 ahci_port_base(u32 base, u32 port)
+{
+	return base + 0x100 + (port * 0x80);
+}
+
+
+static void ahci_setup_port(struct ahci_ioports *port, u32 base,
+				u32 port_idx)
+{
+	base = ahci_port_base(base, port_idx);
+}
+
+static int waiting_for_cmd_completed(u8 *offset,
+					int timeout_msec,
+					u32 sign)
+{
+	int i;
+	u32 status;
+
+	for (i = 0;
+		((status = readl(offset)) & sign) && i < timeout_msec;
+		++i)
+		mdelay(1);
+
+	return (i < timeout_msec) ? 0 : -1;
+}
+
+static int ahci_setup_oobr(struct ahci_probe_ent *probe_ent,
+						int clk)
+{
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+
+	writel(SATA_HOST_OOBR_WE, &(host_mmio->oobr));
+	writel(0x02060b14, &(host_mmio->oobr));
+
+	return 0;
+}
+
+static int ahci_host_init(struct ahci_probe_ent *probe_ent)
+{
+	u32 tmp, cap_save, num_ports;
+	int i, j, timeout = 1000;
+	struct sata_port_regs *port_mmio = NULL;
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+	int clk = mxc_get_clock(MXC_SATA_CLK);
+
+	cap_save = readl(&(host_mmio->cap));
+	cap_save |= SATA_HOST_CAP_SSS;
+
+	/* global controller reset */
+	tmp = readl(&(host_mmio->ghc));
+	if ((tmp & SATA_HOST_GHC_HR) == 0)
+		writel_with_flush(tmp | SATA_HOST_GHC_HR, &(host_mmio->ghc));
+
+	while ((readl(&(host_mmio->ghc)) & SATA_HOST_GHC_HR)
+		&& --timeout)
+		;
+
+	if (timeout <= 0) {
+		debug("controller reset failed (0x%x)\n", tmp);
+		return -1;
+	}
+
+	/* Set timer 1ms */
+	writel(clk / 1000, &(host_mmio->timer1ms));
+
+	ahci_setup_oobr(probe_ent, 0);
+
+	writel_with_flush(SATA_HOST_GHC_AE, &(host_mmio->ghc));
+	writel(cap_save, &(host_mmio->cap));
+	num_ports = (cap_save & SATA_HOST_CAP_NP_MASK) + 1;
+	writel_with_flush((1 << num_ports) - 1,
+				&(host_mmio->pi));
+
+	/* Determine which Ports are implemented by the DWC_ahsata,
+	 * by reading the PI register. This bit map value aids the
+	 * software to determine how many Ports are available and
+	 * which Port registers need to be initialized. */
+	probe_ent->cap = readl(&(host_mmio->cap));
+	probe_ent->port_map = readl(&(host_mmio->pi));
+	/* Determine how many command slots the HBA supports */
+	probe_ent->n_ports =
+		(probe_ent->cap & SATA_HOST_CAP_NP_MASK) + 1;
+
+	debug("cap 0x%x  port_map 0x%x  n_ports %d\n",
+		probe_ent->cap, probe_ent->port_map, probe_ent->n_ports);
+
+	for (i = 0; i < probe_ent->n_ports; i++) {
+		probe_ent->port[i].port_mmio =
+			ahci_port_base((u32)host_mmio, i);
+		port_mmio =
+			(struct sata_port_regs *)probe_ent->port[i].port_mmio;
+		ahci_setup_port(&probe_ent->port[i], (u32)host_mmio, i);
+
+		/* make sure port is not active */
+		/* Ensure that the DWC_ahsata is in idle state */
+		tmp = readl(&(port_mmio->cmd));
+		/* When P#CMD.ST, P#CMD.CR, P#CMD.FRE and P#CMD.FR
+		 * are all cleared, the Port is in an idle state. */
+		if (tmp & (SATA_PORT_CMD_CR | SATA_PORT_CMD_FR |
+			SATA_PORT_CMD_FRE | SATA_PORT_CMD_ST)) {
+			/* System software places a Port into the idle state by
+			 * clearing P#CMD.ST and waiting for P#CMD.CR to return
+			 * 0 when read. */
+
+			tmp &= ~SATA_PORT_CMD_ST;
+			writel_with_flush(tmp, &(port_mmio->cmd));
+
+			/* spec says 500 msecs for each bit, so
+			 * this is slightly incorrect.
+			 */
+			mdelay(500);
+
+			timeout = 1000;
+			while ((readl(&(port_mmio->cmd)) & SATA_PORT_CMD_CR)
+				&& --timeout)
+				;
+
+			if (timeout <= 0) {
+				debug("port reset failed (0x%x)\n", tmp);
+				return -1;
+			}
+		}
+
+		/* Spin-up device */
+		tmp = readl(&(port_mmio->cmd));
+		writel((tmp | SATA_PORT_CMD_SUD), &(port_mmio->cmd));
+
+		/* Wait for spin-up to finish */
+		timeout = 1000;
+		while (!(readl(&(port_mmio->cmd)) | SATA_PORT_CMD_SUD)
+			&& --timeout)
+			;
+		if (timeout <= 0) {
+			debug("Spin-Up can't finish!\n");
+			return -1;
+		}
+
+		for (j = 0; j < 100; ++j) {
+			mdelay(10);
+			tmp = readl(&(port_mmio->ssts));
+			if (((tmp & SATA_PORT_SSTS_DET_MASK) == 0x3) ||
+				((tmp & SATA_PORT_SSTS_DET_MASK) == 0x1))
+				break;
+		}
+
+		/* Wait for COMINIT bit 26 (DIAG_X) in SERR */
+		timeout = 1000;
+		while (!(readl(&(port_mmio->serr)) | SATA_PORT_SERR_DIAG_X)
+			&& --timeout)
+			;
+		if (timeout <= 0) {
+			debug("Can't find DIAG_X set!\n");
+			return -1;
+		}
+
+		/* For each implemented Port, clear the P#SERR
+		 * register, by writing ones to each implemented\
+		 * bit location. */
+		tmp = readl(&(port_mmio->serr));
+		debug("P#SERR 0x%x\n",
+				tmp);
+		writel(tmp, &(port_mmio->serr));
+
+		/* Ack any pending irq events for this port */
+		tmp = readl(&(host_mmio->is));
+		debug("IS 0x%x\n", tmp);
+		if (tmp)
+			writel(tmp, &(host_mmio->is));
+
+		writel(1 << i, &(host_mmio->is));
+
+		/* set irq mask (enables interrupts) */
+		writel(DEF_PORT_IRQ, &(port_mmio->ie));
+
+		/*register linkup ports */
+		tmp = readl(&(port_mmio->ssts));
+		debug("Port %d status: 0x%x\n", i, tmp);
+		if ((tmp & SATA_PORT_SSTS_DET_MASK) == 0x03)
+			probe_ent->link_port_map |= (0x01 << i);
+	}
+
+	tmp = readl(&(host_mmio->ghc));
+	debug("GHC 0x%x\n", tmp);
+	writel(tmp | SATA_HOST_GHC_IE, &(host_mmio->ghc));
+	tmp = readl(&(host_mmio->ghc));
+	debug("GHC 0x%x\n", tmp);
+
+	return 0;
+}
+
+static void ahci_print_info(struct ahci_probe_ent *probe_ent)
+{
+	struct sata_host_regs *host_mmio =
+		(struct sata_host_regs *)probe_ent->mmio_base;
+	u32 vers, cap, impl, speed;
+	const char *speed_s;
+	const char *scc_s;
+
+	vers = readl(&(host_mmio->vs));
+	cap = probe_ent->cap;
+	impl = probe_ent->port_map;
+
+	speed = (cap & SATA_HOST_CAP_ISS_MASK)
+		>> SATA_HOST_CAP_ISS_OFFSET;
+	if (speed == 1)
+		speed_s = "1.5";
+	else if (speed == 2)
+		speed_s = "3";
+	else
+		speed_s = "?";
+
+	scc_s = "SATA";
+
+	printf("AHCI %02x%02x.%02x%02x "
+		"%u slots %u ports %s Gbps 0x%x impl %s mode\n",
+		(vers >> 24) & 0xff,
+		(vers >> 16) & 0xff,
+		(vers >> 8) & 0xff,
+		vers & 0xff,
+		((cap >> 8) & 0x1f) + 1,
+		(cap & 0x1f) + 1,
+		speed_s,
+		impl,
+		scc_s);
+
+	printf("flags: "
+		"%s%s%s%s%s%s"
+		"%s%s%s%s%s%s%s\n",
+		cap & (1 << 31) ? "64bit " : "",
+		cap & (1 << 30) ? "ncq " : "",
+		cap & (1 << 28) ? "ilck " : "",
+		cap & (1 << 27) ? "stag " : "",
+		cap & (1 << 26) ? "pm " : "",
+		cap & (1 << 25) ? "led " : "",
+		cap & (1 << 24) ? "clo " : "",
+		cap & (1 << 19) ? "nz " : "",
+		cap & (1 << 18) ? "only " : "",
+		cap & (1 << 17) ? "pmp " : "",
+		cap & (1 << 15) ? "pio " : "",
+		cap & (1 << 14) ? "slum " : "",
+		cap & (1 << 13) ? "part " : "");
+}
+
+static int ahci_init_one(int pdev)
+{
+	int rc;
+	struct ahci_probe_ent *probe_ent = NULL;
+
+	probe_ent = malloc(sizeof(struct ahci_probe_ent));
+	memset(probe_ent, 0, sizeof(struct ahci_probe_ent));
+	probe_ent->dev = pdev;
+
+	probe_ent->host_flags = ATA_FLAG_SATA
+				| ATA_FLAG_NO_LEGACY
+				| ATA_FLAG_MMIO
+				| ATA_FLAG_PIO_DMA
+				| ATA_FLAG_NO_ATAPI;
+
+	probe_ent->mmio_base = CONFIG_DWC_AHSATA_BASE_ADDR;
+
+	/* initialize adapter */
+	rc = ahci_host_init(probe_ent);
+	if (rc)
+		goto err_out;
+
+	ahci_print_info(probe_ent);
+
+#ifdef CONFIG_ARCH_MMU
+	dma_buf = (u8 *)memalign(ATA_MAX_SECTORS * ATA_SECT_SIZE, 4);
+	if (NULL == dma_buf) {
+		printf("Fail to alloc buf for dma access!\n");
+		return 0;
+	}
+#endif
+
+	/* Save the private struct to block device struct */
+	sata_dev_desc[pdev].priv = (void *)probe_ent;
+
+	return 0;
+
+err_out:
+	return rc;
+}
+
+static int ahci_fill_sg(struct ahci_probe_ent *probe_ent,
+			u8 port, unsigned char *buf, int buf_len)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+#ifdef CONFIG_ARCH_MMU
+	struct ahci_sg *ahci_sg =
+	    (struct ahci_sg *)ioremap_nocache(iomem_to_phys(pp->cmd_tbl_sg),
+		    0);
+#else
+	struct ahci_sg *ahci_sg = pp->cmd_tbl_sg;
+#endif
+	u32 sg_count, max_bytes;
+	int i;
+
+	max_bytes = MAX_DATA_BYTES_PER_SG;
+	sg_count = ((buf_len - 1) / max_bytes) + 1;
+	if (sg_count > AHCI_MAX_SG) {
+		printf("Error:Too much sg!\n");
+		return -1;
+	}
+
+	for (i = 0; i < sg_count; i++) {
+#ifdef CONFIG_ARCH_MMU
+		ahci_sg->addr =
+		iomem_to_phys(cpu_to_le32((u32)buf + i * max_bytes));
+#else
+		ahci_sg->addr =
+			cpu_to_le32((u32)buf + i * max_bytes);
+#endif
+		ahci_sg->addr_hi = 0;
+		ahci_sg->flags_size = cpu_to_le32(0x3fffff &
+					(buf_len < max_bytes
+					? (buf_len - 1)
+					: (max_bytes - 1)));
+		ahci_sg++;
+		buf_len -= max_bytes;
+	}
+
+	return sg_count;
+}
+
+static void ahci_fill_cmd_slot(struct ahci_ioports *pp, u32 cmd_slot, u32 opts)
+{
+#ifdef CONFIG_ARCH_MMU
+	struct ahci_cmd_hdr *cmd_hdr =
+	    (struct ahci_cmd_hdr *)ioremap_nocache(iomem_to_phys(pp->cmd_slot
+				+ AHCI_CMD_SLOT_SZ * cmd_slot), 0);
+#else
+	struct ahci_cmd_hdr *cmd_hdr = (struct ahci_cmd_hdr *)(pp->cmd_slot +
+					AHCI_CMD_SLOT_SZ * cmd_slot);
+#endif
+
+	memset(cmd_hdr, 0, AHCI_CMD_SLOT_SZ);
+	cmd_hdr->opts = cpu_to_le32(opts);
+	cmd_hdr->status = 0;
+#ifdef CONFIG_ARCH_MMU
+	cmd_hdr->tbl_addr =
+		iomem_to_phys(cpu_to_le32(pp->cmd_tbl & 0xffffffff));
+#else
+	cmd_hdr->tbl_addr = cpu_to_le32(pp->cmd_tbl & 0xffffffff);
+#endif
+	cmd_hdr->tbl_addr_hi = 0;
+}
+
+#define AHCI_GET_CMD_SLOT(c) ((c) ? ffs(c) : 0)
+
+static int ahci_exec_ata_cmd(struct ahci_probe_ent *probe_ent,
+		u8 port, struct sata_fis_h2d *cfis,
+		u8 *buf, u32 buf_len, s32 is_write)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+	struct sata_port_regs *port_mmio =
+			(struct sata_port_regs *)pp->port_mmio;
+	u32 opts;
+	int sg_count = 0, cmd_slot = 0;
+
+	cmd_slot = AHCI_GET_CMD_SLOT(readl(&(port_mmio->ci)));
+	if (32 == cmd_slot) {
+		printf("Can't find empty command slot!\n");
+		return 0;
+	}
+	/* Check xfer length */
+	if (buf_len > MAX_BYTES_PER_TRANS) {
+		printf("Max transfer length is %dB\n\r",
+			MAX_BYTES_PER_TRANS);
+		return 0;
+	}
+
+	memcpy((u8 *)(pp->cmd_tbl), cfis, sizeof(struct sata_fis_h2d));
+	if (buf && buf_len)
+		sg_count = ahci_fill_sg(probe_ent, port, buf, buf_len);
+	opts = (sizeof(struct sata_fis_h2d) >> 2) | (sg_count << 16);
+	if (is_write)
+		opts |= 0x40;
+	ahci_fill_cmd_slot(pp, cmd_slot, opts);
+
+	writel_with_flush(1 << cmd_slot, &(port_mmio->ci));
+
+	if (waiting_for_cmd_completed((u8 *)&(port_mmio->ci),
+				10000, 0x1 << cmd_slot)) {
+		printf("timeout exit!\n");
+		return -1;
+	}
+	debug("ahci_exec_ata_cmd: %d byte transferred.\n",
+	      pp->cmd_slot->status);
+
+	return buf_len;
+}
+
+static void ahci_set_feature(u8 dev, u8 port)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+
+	/*set feature */
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 1 << 7;
+	cfis->command = ATA_CMD_SET_FEATURES;
+	cfis->features = SETFEATURES_XFER;
+	cfis->sector_count = ffs(probe_ent->udma_mask + 1) + 0x3e;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, READ_CMD);
+}
+
+static int ahci_port_start(struct ahci_probe_ent *probe_ent,
+					u8 port)
+{
+	struct ahci_ioports *pp = &(probe_ent->port[port]);
+	struct sata_port_regs *port_mmio =
+		(struct sata_port_regs *)pp->port_mmio;
+	u32 port_status;
+	u32 mem;
+	int timeout = 1000;
+
+	debug("Enter start port: %d\n", port);
+	port_status = readl(&(port_mmio->ssts));
+	debug("Port %d status: %x\n", port, port_status);
+	if ((port_status & 0xf) != 0x03) {
+		printf("No Link on this port!\n");
+		return -1;
+	}
+
+	mem = (u32)malloc(AHCI_PORT_PRIV_DMA_SZ + 1024);
+	if (!mem) {
+		free(pp);
+		printf("No mem for table!\n");
+		return -ENOMEM;
+	}
+
+	mem = (mem + 0x400) & (~0x3ff);	/* Aligned to 1024-bytes */
+	memset((u8 *)mem, 0, AHCI_PORT_PRIV_DMA_SZ);
+
+	/*
+	 * First item in chunk of DMA memory: 32-slot command table,
+	 * 32 bytes each in size
+	 */
+#ifdef CONFIG_ARCH_MMU
+	pp->cmd_slot =
+	(struct ahci_cmd_hdr *)ioremap_nocache(iomem_to_phys((ulong)mem),
+		AHCI_CMD_SLOT_SZ);
+#else
+	pp->cmd_slot = (struct ahci_cmd_hdr *)mem;
+#endif
+	debug("cmd_slot = 0x%x\n", pp->cmd_slot);
+	mem += (AHCI_CMD_SLOT_SZ * DWC_AHSATA_MAX_CMD_SLOTS);
+
+	/*
+	 * Second item: Received-FIS area, 256-Byte aligned
+	 */
+#ifdef CONFIG_ARCH_MMU
+	pp->rx_fis = (u32)ioremap_nocache(iomem_to_phys((ulong)mem),
+		AHCI_RX_FIS_SZ);
+#else
+	pp->rx_fis = mem;
+#endif
+	mem += AHCI_RX_FIS_SZ;
+
+	/*
+	 * Third item: data area for storing a single command
+	 * and its scatter-gather table
+	 */
+#ifdef CONFIG_ARCH_MMU
+	pp->cmd_tbl = (u32)ioremap_nocache(iomem_to_phys((ulong)mem),
+		AHCI_CMD_TBL_HDR);
+#else
+	pp->cmd_tbl = mem;
+#endif
+	debug("cmd_tbl_dma = 0x%x\n", pp->cmd_tbl);
+
+	mem += AHCI_CMD_TBL_HDR;
+
+	writel_with_flush(0x00004444, &(port_mmio->dmacr));
+#ifdef CONFIG_ARCH_MMU
+	pp->cmd_tbl_sg =
+		(struct ahci_sg *)ioremap_nocache(iomem_to_phys((ulong)mem),
+		AHCI_CMD_TBL_HDR);
+	writel_with_flush(iomem_to_phys(pp->cmd_slot), &(port_mmio->clb));
+	writel_with_flush(iomem_to_phys(pp->rx_fis), &(port_mmio->fb));
+#else
+	pp->cmd_tbl_sg = (struct ahci_sg *)mem;
+	writel_with_flush((u32)pp->cmd_slot, &(port_mmio->clb));
+	writel_with_flush(pp->rx_fis, &(port_mmio->fb));
+#endif
+
+	/* Enable FRE */
+	writel_with_flush((SATA_PORT_CMD_FRE | readl(&(port_mmio->cmd))),
+			&(port_mmio->cmd));
+
+	/* Wait device ready */
+	while ((readl(&(port_mmio->tfd)) & (SATA_PORT_TFD_STS_ERR |
+		SATA_PORT_TFD_STS_DRQ | SATA_PORT_TFD_STS_BSY))
+		&& --timeout)
+		;
+	if (timeout <= 0) {
+		debug("Device not ready for BSY, DRQ and"
+			"ERR in TFD!\n");
+		return -1;
+	}
+
+	writel_with_flush(PORT_CMD_ICC_ACTIVE | PORT_CMD_FIS_RX |
+			  PORT_CMD_POWER_ON | PORT_CMD_SPIN_UP |
+			  PORT_CMD_START, &(port_mmio->cmd));
+
+	debug("Exit start port %d\n", port);
+
+	return 0;
+}
+
+int init_sata(int dev)
+{
+	int i;
+	u32 linkmap;
+	struct ahci_probe_ent *probe_ent = NULL;
+
+	if (dev < 0 || dev > (CONFIG_SYS_SATA_MAX_DEVICE - 1)) {
+		printf("The sata index %d is out of ranges\n\r", dev);
+		return -1;
+	}
+
+	ahci_init_one(dev);
+
+	probe_ent = (struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	linkmap = probe_ent->link_port_map;
+
+	if (0 == linkmap) {
+		printf("No port device detected!\n");
+		return 1;
+	}
+
+	for (i = 0; i < probe_ent->n_ports; i++) {
+		if ((linkmap >> i) && ((linkmap >> i) & 0x01)) {
+			if (ahci_port_start(probe_ent, (u8)i)) {
+				printf("Can not start port %d\n", i);
+				return 1;
+			}
+			/* ahci_set_feature(dev, (u8)i); */
+			probe_ent->hard_port_no = i;
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void dwc_ahsata_print_info(int dev)
+{
+	block_dev_desc_t *pdev = &(sata_dev_desc[dev]);
+
+	printf("SATA Device Info:\n\r");
+#ifdef CONFIG_SYS_64BIT_LBA
+	printf("S/N: %s\n\rProduct model number: %s\n\r"
+		"Firmware version: %s\n\rCapacity: %lld sectors\n\r",
+		pdev->product, pdev->vendor, pdev->revision, pdev->lba);
+#else
+	printf("S/N: %s\n\rProduct model number: %s\n\r"
+		"Firmware version: %s\n\rCapacity: %ld sectors\n\r",
+		pdev->product, pdev->vendor, pdev->revision, pdev->lba);
+#endif
+}
+
+static void dwc_ahsata_identify(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_ID_ATA;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis,
+			(u8 *)id, ATA_ID_WORDS * 2, READ_CMD);
+	ata_swap_buf_le16(id, ATA_ID_WORDS);
+}
+
+static void dwc_ahsata_xfer_mode(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+
+	probe_ent->pio_mask = id[ATA_ID_PIO_MODES];
+	probe_ent->udma_mask = id[ATA_ID_UDMA_MODES];
+	debug("pio %04x, udma %04x\n\r",
+		probe_ent->pio_mask, probe_ent->udma_mask);
+}
+
+static u32 dwc_ahsata_rw_cmd(int dev, u32 start, u32 blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u32 block;
+#ifdef CONFIG_ARCH_MMU
+	u8 *dma_buf_virt = NULL;
+
+	dma_buf_virt = (u8 *)ioremap_nocache((ulong)dma_buf, 0);
+	memset(dma_buf_virt, 0, blkcnt * ATA_SECT_SIZE);
+#endif
+
+	block = start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = (is_write) ? ATA_CMD_WRITE : ATA_CMD_READ;
+	cfis->device = ATA_LBA;
+
+	cfis->device |= (block >> 24) & 0xf;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+	cfis->sector_count = (u8)(blkcnt & 0xff);
+
+#ifdef CONFIG_ARCH_MMU
+	if (is_write)
+		memcpy(dma_buf_virt, buffer, ATA_SECT_SIZE * blkcnt);
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis, dma_buf_virt,
+			ATA_SECT_SIZE * blkcnt, is_write) > 0)  {
+		if (!is_write)
+			memcpy(buffer, dma_buf_virt, ATA_SECT_SIZE * blkcnt);
+	} else
+		blkcnt = 0;
+
+	return blkcnt;
+#else
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis,
+			buffer, ATA_SECT_SIZE * blkcnt, is_write) > 0)
+		return blkcnt;
+	else
+		return 0;
+#endif
+}
+
+void dwc_ahsata_flush_cache(int dev)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_FLUSH;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, 0);
+}
+
+static u32 dwc_ahsata_rw_cmd_ext(int dev, u32 start, lbaint_t blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u64 block;
+#ifdef CONFIG_ARCH_MMU
+	u8 *dma_buf_virt = NULL;
+
+	dma_buf_virt = (u8 *)ioremap_nocache((ulong)dma_buf, 0);
+	memset(dma_buf_virt, 0, blkcnt * ATA_SECT_SIZE);
+#endif
+
+	block = (u64)start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+
+	cfis->command = (is_write) ? ATA_CMD_WRITE_EXT
+				 : ATA_CMD_READ_EXT;
+
+	cfis->lba_high_exp = (block >> 40) & 0xff;
+	cfis->lba_mid_exp = (block >> 32) & 0xff;
+	cfis->lba_low_exp = (block >> 24) & 0xff;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+	cfis->device = ATA_LBA;
+	cfis->sector_count_exp = (blkcnt >> 8) & 0xff;
+	cfis->sector_count = blkcnt & 0xff;
+
+#ifdef CONFIG_ARCH_MMU
+	if (is_write)
+		memcpy(dma_buf_virt, buffer, ATA_SECT_SIZE * blkcnt);
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis, dma_buf_virt,
+			ATA_SECT_SIZE * blkcnt, is_write) > 0)  {
+		if (!is_write)
+			memcpy(buffer, dma_buf_virt, ATA_SECT_SIZE * blkcnt);
+	} else
+		blkcnt = 0;
+
+	return blkcnt;
+#else
+	if (ahci_exec_ata_cmd(probe_ent, port, cfis, buffer,
+			ATA_SECT_SIZE * blkcnt, is_write) > 0)
+		return blkcnt;
+	else
+		return 0;
+#endif
+}
+
+u32 dwc_ahsata_rw_ncq_cmd(int dev, u32 start, lbaint_t blkcnt,
+				u8 *buffer, int is_write)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+	u8 queue_depth;
+	int ncq_channel;
+	u64 block;
+
+	if (sata_dev_desc[dev].lba48 != 1) {
+		printf("execute FPDMA command on non-LBA48 hard disk\n\r");
+		return -1;
+	}
+
+	block = (u64)start;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+
+	cfis->command = (is_write) ? ATA_CMD_FPDMA_WRITE
+				 : ATA_CMD_FPDMA_READ;
+
+	cfis->lba_high_exp = (block >> 40) & 0xff;
+	cfis->lba_mid_exp = (block >> 32) & 0xff;
+	cfis->lba_low_exp = (block >> 24) & 0xff;
+	cfis->lba_high = (block >> 16) & 0xff;
+	cfis->lba_mid = (block >> 8) & 0xff;
+	cfis->lba_low = block & 0xff;
+
+	cfis->device = ATA_LBA;
+	cfis->features_exp = (blkcnt >> 8) & 0xff;
+	cfis->features = blkcnt & 0xff;
+
+	queue_depth = probe_ent->flags & SATA_FLAG_Q_DEP_MASK;
+	if (queue_depth >= DWC_AHSATA_HC_MAX_CMD)
+		ncq_channel = DWC_AHSATA_HC_MAX_CMD - 1;
+	else
+		ncq_channel = queue_depth - 1;
+
+	/* Use the latest queue */
+	ahci_exec_ata_cmd(probe_ent, port, cfis,
+			buffer, ATA_SECT_SIZE * blkcnt, is_write);
+
+	return blkcnt;
+}
+
+void dwc_ahsata_flush_cache_ext(int dev)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	struct sata_fis_h2d h2d, *cfis = &h2d;
+	u8 port = probe_ent->hard_port_no;
+
+	memset(cfis, 0, sizeof(struct sata_fis_h2d));
+
+	cfis->fis_type = SATA_FIS_TYPE_REGISTER_H2D;
+	cfis->pm_port_c = 0x80; /* is command */
+	cfis->command = ATA_CMD_FLUSH_EXT;
+
+	ahci_exec_ata_cmd(probe_ent, port, cfis, NULL, 0, 0);
+}
+
+static void dwc_ahsata_init_wcache(int dev, u16 *id)
+{
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+
+	if (ata_id_has_wcache(id) && ata_id_wcache_enabled(id))
+		probe_ent->flags |= SATA_FLAG_WCACHE;
+	if (ata_id_has_flush(id))
+		probe_ent->flags |= SATA_FLAG_FLUSH;
+	if (ata_id_has_flush_ext(id))
+		probe_ent->flags |= SATA_FLAG_FLUSH_EXT;
+}
+
+u32 ata_low_level_rw_lba48(int dev, u32 blknr, lbaint_t blkcnt,
+				void *buffer, int is_write)
+{
+	u32 start, blks;
+	u8 *addr;
+	int max_blks;
+
+	start = blknr;
+	blks = blkcnt;
+	addr = (u8 *)buffer;
+
+#ifdef CONFIG_ARCH_MMU
+	max_blks = ATA_MAX_SECTORS;
+#else
+	max_blks = ATA_MAX_SECTORS_LBA48;
+#endif
+
+	do {
+		if (blks > max_blks) {
+			if (max_blks != dwc_ahsata_rw_cmd_ext(dev, start,
+						max_blks, addr, is_write))
+				return 0;
+			start += max_blks;
+			blks -= max_blks;
+			addr += ATA_SECT_SIZE * max_blks;
+		} else {
+			if (blks != dwc_ahsata_rw_cmd_ext(dev, start,
+						blks, addr, is_write))
+				return 0;
+			start += blks;
+			blks = 0;
+			addr += ATA_SECT_SIZE * blks;
+		}
+	} while (blks != 0);
+
+	return blkcnt;
+}
+
+u32 ata_low_level_rw_lba28(int dev, u32 blknr, lbaint_t blkcnt,
+				void *buffer, int is_write)
+{
+	u32 start, blks;
+	u8 *addr;
+	int max_blks;
+
+	start = blknr;
+	blks = blkcnt;
+	addr = (u8 *)buffer;
+
+	max_blks = ATA_MAX_SECTORS;
+	do {
+		if (blks > max_blks) {
+			if (max_blks != dwc_ahsata_rw_cmd(dev, start,
+						max_blks, addr, is_write))
+				return 0;
+			start += max_blks;
+			blks -= max_blks;
+			addr += ATA_SECT_SIZE * max_blks;
+		} else {
+			if (blks != dwc_ahsata_rw_cmd(dev, start,
+						blks, addr, is_write))
+				return 0;
+			start += blks;
+			blks = 0;
+			addr += ATA_SECT_SIZE * blks;
+		}
+	} while (blks != 0);
+
+	return blkcnt;
+}
+
+/*
+ * SATA interface between low level driver and command layer
+ */
+ulong sata_read(int dev, unsigned long blknr, lbaint_t blkcnt, void *buffer)
+{
+	u32 rc;
+
+	if (sata_dev_desc[dev].lba48)
+		rc = ata_low_level_rw_lba48(dev, blknr, blkcnt,
+						buffer, READ_CMD);
+	else
+		rc = ata_low_level_rw_lba28(dev, blknr, blkcnt,
+						buffer, READ_CMD);
+	return rc;
+}
+
+ulong sata_write(int dev, unsigned long blknr, lbaint_t blkcnt, void *buffer)
+{
+	u32 rc;
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	u32 flags = probe_ent->flags;
+
+	if (sata_dev_desc[dev].lba48) {
+		rc = ata_low_level_rw_lba48(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH_EXT))
+			dwc_ahsata_flush_cache_ext(dev);
+	} else {
+		rc = ata_low_level_rw_lba28(dev, blknr, blkcnt,
+						buffer, WRITE_CMD);
+		if ((flags & SATA_FLAG_WCACHE) &&
+			(flags & SATA_FLAG_FLUSH))
+			dwc_ahsata_flush_cache(dev);
+	}
+	return rc;
+}
+
+int scan_sata(int dev)
+{
+	u8 serial[ATA_ID_SERNO_LEN + 1] = { 0 };
+	u8 firmware[ATA_ID_FW_REV_LEN + 1] = { 0 };
+	u8 product[ATA_ID_PROD_LEN + 1] = { 0 };
+	u16 *id;
+	u64 n_sectors;
+	struct ahci_probe_ent *probe_ent =
+		(struct ahci_probe_ent *)sata_dev_desc[dev].priv;
+	u8 port = probe_ent->hard_port_no;
+	block_dev_desc_t *pdev = &(sata_dev_desc[dev]);
+
+	id = (u16 *)malloc(ATA_ID_WORDS * 2);
+	if (!id) {
+		printf("id malloc failed\n\r");
+		return -1;
+	}
+
+	/* Identify device to get information */
+	dwc_ahsata_identify(dev, id);
+
+	/* Serial number */
+	ata_id_c_string(id, serial, ATA_ID_SERNO, sizeof(serial));
+	memcpy(pdev->product, serial, sizeof(serial));
+
+	/* Firmware version */
+	ata_id_c_string(id, firmware, ATA_ID_FW_REV, sizeof(firmware));
+	memcpy(pdev->revision, firmware, sizeof(firmware));
+
+	/* Product model */
+	ata_id_c_string(id, product, ATA_ID_PROD, sizeof(product));
+	memcpy(pdev->vendor, product, sizeof(product));
+
+	/* Totoal sectors */
+	n_sectors = ata_id_n_sectors(id);
+	pdev->lba = (u32)n_sectors;
+
+	pdev->type = DEV_TYPE_HARDDISK;
+	pdev->blksz = ATA_SECT_SIZE;
+	pdev->lun = 0 ;
+
+	/* Check if support LBA48 */
+	if (ata_id_has_lba48(id)) {
+		pdev->lba48 = 1;
+		debug("Device support LBA48\n\r");
+	}
+
+	/* Get the NCQ queue depth from device */
+	probe_ent->flags &= (~SATA_FLAG_Q_DEP_MASK);
+	probe_ent->flags |= ata_id_queue_depth(id);
+
+	/* Get the xfer mode from device */
+	dwc_ahsata_xfer_mode(dev, id);
+
+	/* Get the write cache status from device */
+	dwc_ahsata_init_wcache(dev, id);
+
+	/* Set the xfer mode to highest speed */
+	ahci_set_feature(dev, port);
+
+	free((void *)id);
+
+	dwc_ahsata_print_info(dev);
+
+	is_ready = 1;
+
+	return 0;
+}
+
diff --git a/drivers/block/dwc_ahsata.h b/drivers/block/dwc_ahsata.h
new file mode 100644
index 0000000..dce70e9
--- /dev/null
+++ b/drivers/block/dwc_ahsata.h
@@ -0,0 +1,333 @@
+/*
+ * (C) Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __FSL_SATA_H__
+#define __FSL_SATA_H__
+
+#define DWC_AHSATA_MAX_CMD_SLOTS	32
+
+/* Max host controller numbers */
+#define SATA_HC_MAX_NUM		4
+/* Max command queue depth per host controller */
+#define DWC_AHSATA_HC_MAX_CMD	32
+/* Max port number per host controller */
+#define SATA_HC_MAX_PORT	16
+
+/* Generic Host Register */
+
+/* HBA Capabilities Register */
+#define SATA_HOST_CAP_S64A		0x80000000
+#define SATA_HOST_CAP_SNCQ		0x40000000
+#define SATA_HOST_CAP_SSNTF		0x20000000
+#define SATA_HOST_CAP_SMPS		0x10000000
+#define SATA_HOST_CAP_SSS		0x08000000
+#define SATA_HOST_CAP_SALP		0x04000000
+#define SATA_HOST_CAP_SAL		0x02000000
+#define SATA_HOST_CAP_SCLO		0x01000000
+#define SATA_HOST_CAP_ISS_MASK		0x00f00000
+#define SATA_HOST_CAP_ISS_OFFSET	20
+#define SATA_HOST_CAP_SNZO		0x00080000
+#define SATA_HOST_CAP_SAM		0x00040000
+#define SATA_HOST_CAP_SPM		0x00020000
+#define SATA_HOST_CAP_PMD		0x00008000
+#define SATA_HOST_CAP_SSC		0x00004000
+#define SATA_HOST_CAP_PSC		0x00002000
+#define SATA_HOST_CAP_NCS		0x00001f00
+#define SATA_HOST_CAP_CCCS		0x00000080
+#define SATA_HOST_CAP_EMS		0x00000040
+#define SATA_HOST_CAP_SXS		0x00000020
+#define SATA_HOST_CAP_NP_MASK		0x0000001f
+
+/* Global HBA Control Register */
+#define SATA_HOST_GHC_AE	0x80000000
+#define SATA_HOST_GHC_IE	0x00000002
+#define SATA_HOST_GHC_HR	0x00000001
+
+/* Interrupt Status Register */
+
+/* Ports Implemented Register */
+
+/* AHCI Version Register */
+#define SATA_HOST_VS_MJR_MASK	0xffff0000
+#define SATA_HOST_VS_MJR_OFFSET	16
+#define SATA_HOST_VS_MJR_MNR	0x0000ffff
+
+/* Command Completion Coalescing Control */
+#define SATA_HOST_CCC_CTL_TV_MASK	0xffff0000
+#define SATA_HOST_CCC_CTL_TV_OFFSET		16
+#define SATA_HOST_CCC_CTL_CC_MASK	0x0000ff00
+#define SATA_HOST_CCC_CTL_CC_OFFSET		8
+#define SATA_HOST_CCC_CTL_INT_MASK	0x000000f8
+#define SATA_HOST_CCC_CTL_INT_OFFSET	3
+#define SATA_HOST_CCC_CTL_EN	0x00000001
+
+/* Command Completion Coalescing Ports */
+
+/* HBA Capabilities Extended Register */
+#define SATA_HOST_CAP2_APST		0x00000004
+
+/* BIST Activate FIS Register */
+#define SATA_HOST_BISTAFR_NCP_MASK	0x0000ff00
+#define SATA_HOST_BISTAFR_NCP_OFFSET	8
+#define SATA_HOST_BISTAFR_PD_MASK	0x000000ff
+#define SATA_HOST_BISTAFR_PD_OFFSET		0
+
+/* BIST Control Register */
+#define SATA_HOST_BISTCR_FERLB	0x00100000
+#define SATA_HOST_BISTCR_TXO	0x00040000
+#define SATA_HOST_BISTCR_CNTCLR	0x00020000
+#define SATA_HOST_BISTCR_NEALB	0x00010000
+#define SATA_HOST_BISTCR_LLC_MASK	0x00000700
+#define SATA_HOST_BISTCR_LLC_OFFSET	8
+#define SATA_HOST_BISTCR_ERREN	0x00000040
+#define SATA_HOST_BISTCR_FLIP	0x00000020
+#define SATA_HOST_BISTCR_PV		0x00000010
+#define SATA_HOST_BISTCR_PATTERN_MASK	0x0000000f
+#define SATA_HOST_BISTCR_PATTERN_OFFSET	0
+
+/* BIST FIS Count Register */
+
+/* BIST Status Register */
+#define SATA_HOST_BISTSR_FRAMERR_MASK	0x0000ffff
+#define SATA_HOST_BISTSR_FRAMERR_OFFSET	0
+#define SATA_HOST_BISTSR_BRSTERR_MASK	0x00ff0000
+#define SATA_HOST_BISTSR_BRSTERR_OFFSET	16
+
+/* BIST DWORD Error Count Register */
+
+/* OOB Register*/
+#define SATA_HOST_OOBR_WE		0x80000000
+#define SATA_HOST_OOBR_cwMin_MASK	0x7f000000
+#define SATA_HOST_OOBR_cwMAX_MASK	0x00ff0000
+#define SATA_HOST_OOBR_ciMin_MASK	0x0000ff00
+#define SATA_HOST_OOBR_ciMax_MASK	0x000000ff
+
+/* Timer 1-ms Register */
+
+/* Global Parameter 1 Register */
+#define SATA_HOST_GPARAM1R_ALIGN_M	0x80000000
+#define SATA_HOST_GPARAM1R_RX_BUFFER	0x40000000
+#define SATA_HOST_GPARAM1R_PHY_DATA_MASK	0x30000000
+#define SATA_HOST_GPARAM1R_PHY_RST	0x08000000
+#define SATA_HOST_GPARAM1R_PHY_CTRL_MASK	0x07e00000
+#define SATA_HOST_GPARAM1R_PHY_STAT_MASK	0x001f8000
+#define SATA_HOST_GPARAM1R_LATCH_M	0x00004000
+#define SATA_HOST_GPARAM1R_BIST_M	0x00002000
+#define SATA_HOST_GPARAM1R_PHY_TYPE	0x00001000
+#define SATA_HOST_GPARAM1R_RETURN_ERR	0x00000400
+#define SATA_HOST_GPARAM1R_AHB_ENDIAN_MASK	0x00000300
+#define SATA_HOST_GPARAM1R_S_HADDR	0X00000080
+#define SATA_HOST_GPARAM1R_M_HADDR	0X00000040
+
+/* Global Parameter 2 Register */
+#define SATA_HOST_GPARAM2R_DEV_CP	0x00004000
+#define SATA_HOST_GPARAM2R_DEV_MP	0x00002000
+#define SATA_HOST_GPARAM2R_DEV_ENCODE_M	0x00001000
+#define SATA_HOST_GPARAM2R_RXOOB_CLK_M	0x00000800
+#define SATA_HOST_GPARAM2R_RXOOB_M	0x00000400
+#define SATA_HOST_GPARAM2R_TX_OOB_M	0x00000200
+#define SATA_HOST_GPARAM2R_RXOOB_CLK_MASK	0x000001ff
+
+/* Port Parameter Register */
+#define SATA_HOST_PPARAMR_TX_MEM_M	0x00000200
+#define SATA_HOST_PPARAMR_TX_MEM_S	0x00000100
+#define SATA_HOST_PPARAMR_RX_MEM_M	0x00000080
+#define SATA_HOST_PPARAMR_RX_MEM_S	0x00000040
+#define SATA_HOST_PPARAMR_TXFIFO_DEPTH_MASK	0x00000038
+#define SATA_HOST_PPARAMR_RXFIFO_DEPTH_MASK	0x00000007
+
+/* Test Register */
+#define SATA_HOST_TESTR_PSEL_MASK	0x00070000
+#define SATA_HOST_TESTR_TEST_IF		0x00000001
+
+/* Port Register Descriptions */
+/* Port# Command List Base Address Register */
+#define SATA_PORT_CLB_CLB_MASK		0xfffffc00
+
+/* Port# Command List Base Address Upper 32-Bits Register */
+
+/* Port# FIS Base Address Register */
+#define SATA_PORT_FB_FB_MASK		0xfffffff0
+
+/* Port# FIS Base Address Upper 32-Bits Register */
+
+/* Port# Interrupt Status Register */
+#define SATA_PORT_IS_CPDS		0x80000000
+#define SATA_PORT_IS_TFES		0x40000000
+#define SATA_PORT_IS_HBFS		0x20000000
+#define SATA_PORT_IS_HBDS		0x10000000
+#define SATA_PORT_IS_IFS		0x08000000
+#define SATA_PORT_IS_INFS		0x04000000
+#define SATA_PORT_IS_OFS		0x01000000
+#define SATA_PORT_IS_IPMS		0x00800000
+#define SATA_PORT_IS_PRCS		0x00400000
+#define SATA_PORT_IS_DMPS		0x00000080
+#define SATA_PORT_IS_PCS		0x00000040
+#define SATA_PORT_IS_DPS		0x00000020
+#define SATA_PORT_IS_UFS		0x00000010
+#define SATA_PORT_IS_SDBS		0x00000008
+#define SATA_PORT_IS_DSS		0x00000004
+#define SATA_PORT_IS_PSS		0x00000002
+#define SATA_PORT_IS_DHRS		0x00000001
+
+/* Port# Interrupt Enable Register */
+#define SATA_PORT_IE_CPDE		0x80000000
+#define SATA_PORT_IE_TFEE		0x40000000
+#define SATA_PORT_IE_HBFE		0x20000000
+#define SATA_PORT_IE_HBDE		0x10000000
+#define SATA_PORT_IE_IFE		0x08000000
+#define SATA_PORT_IE_INFE		0x04000000
+#define SATA_PORT_IE_OFE		0x01000000
+#define SATA_PORT_IE_IPME		0x00800000
+#define SATA_PORT_IE_PRCE		0x00400000
+#define SATA_PORT_IE_DMPE		0x00000080
+#define SATA_PORT_IE_PCE		0x00000040
+#define SATA_PORT_IE_DPE		0x00000020
+#define SATA_PORT_IE_UFE		0x00000010
+#define SATA_PORT_IE_SDBE		0x00000008
+#define SATA_PORT_IE_DSE		0x00000004
+#define SATA_PORT_IE_PSE		0x00000002
+#define SATA_PORT_IE_DHRE		0x00000001
+
+/* Port# Command Register */
+#define SATA_PORT_CMD_ICC_MASK		0xf0000000
+#define SATA_PORT_CMD_ASP		0x08000000
+#define SATA_PORT_CMD_ALPE		0x04000000
+#define SATA_PORT_CMD_DLAE		0x02000000
+#define SATA_PORT_CMD_ATAPI		0x01000000
+#define SATA_PORT_CMD_APSTE		0x00800000
+#define SATA_PORT_CMD_ESP		0x00200000
+#define SATA_PORT_CMD_CPD		0x00100000
+#define SATA_PORT_CMD_MPSP		0x00080000
+#define SATA_PORT_CMD_HPCP		0x00040000
+#define SATA_PORT_CMD_PMA		0x00020000
+#define SATA_PORT_CMD_CPS		0x00010000
+#define SATA_PORT_CMD_CR		0x00008000
+#define SATA_PORT_CMD_FR		0x00004000
+#define SATA_PORT_CMD_MPSS		0x00002000
+#define SATA_PORT_CMD_CCS_MASK		0x00001f00
+#define SATA_PORT_CMD_FRE		0x00000010
+#define SATA_PORT_CMD_CLO		0x00000008
+#define SATA_PORT_CMD_POD		0x00000004
+#define SATA_PORT_CMD_SUD		0x00000002
+#define SATA_PORT_CMD_ST		0x00000001
+
+/* Port# Task File Data Register */
+#define SATA_PORT_TFD_ERR_MASK		0x0000ff00
+#define SATA_PORT_TFD_STS_MASK		0x000000ff
+#define SATA_PORT_TFD_STS_ERR		0x00000001
+#define SATA_PORT_TFD_STS_DRQ		0x00000008
+#define SATA_PORT_TFD_STS_BSY		0x00000080
+
+/* Port# Signature Register */
+
+/* Port# Serial ATA Status {SStatus} Register */
+#define SATA_PORT_SSTS_IPM_MASK		0x00000f00
+#define SATA_PORT_SSTS_SPD_MASK		0x000000f0
+#define SATA_PORT_SSTS_DET_MASK		0x0000000f
+
+/* Port# Serial ATA Control {SControl} Register */
+#define SATA_PORT_SCTL_IPM_MASK		0x00000f00
+#define SATA_PORT_SCTL_SPD_MASK		0x000000f0
+#define SATA_PORT_SCTL_DET_MASK		0x0000000f
+
+/* Port# Serial ATA Error {SError} Register */
+#define SATA_PORT_SERR_DIAG_X		0x04000000
+#define SATA_PORT_SERR_DIAG_F		0x02000000
+#define SATA_PORT_SERR_DIAG_T		0x01000000
+#define SATA_PORT_SERR_DIAG_S		0x00800000
+#define SATA_PORT_SERR_DIAG_H		0x00400000
+#define SATA_PORT_SERR_DIAG_C		0x00200000
+#define SATA_PORT_SERR_DIAG_D		0x00100000
+#define SATA_PORT_SERR_DIAG_B		0x00080000
+#define SATA_PORT_SERR_DIAG_W		0x00040000
+#define SATA_PORT_SERR_DIAG_I		0x00020000
+#define SATA_PORT_SERR_DIAG_N		0x00010000
+#define SATA_PORT_SERR_ERR_E		0x00000800
+#define SATA_PORT_SERR_ERR_P		0x00000400
+#define SATA_PORT_SERR_ERR_C		0x00000200
+#define SATA_PORT_SERR_ERR_T		0x00000100
+#define SATA_PORT_SERR_ERR_M		0x00000002
+#define SATA_PORT_SERR_ERR_I		0x00000001
+
+/* Port# Serial ATA Active {SActive} Register */
+
+/* Port# Command Issue Register */
+
+/* Port# Serial ATA Notification Register */
+
+/* Port# DMA Control Register */
+#define SATA_PORT_DMACR_RXABL_MASK	0x0000f000
+#define SATA_PORT_DMACR_TXABL_MASK	0x00000f00
+#define SATA_PORT_DMACR_RXTS_MASK	0x000000f0
+#define SATA_PORT_DMACR_TXTS_MASK	0x0000000f
+
+/* Port# PHY Control Register */
+
+/* Port# PHY Status Register */
+
+#define SATA_HC_CMD_HDR_ENTRY_SIZE	sizeof(struct cmd_hdr_entry)
+
+/* DW0
+*/
+#define CMD_HDR_DI_CFL_MASK	0x0000001f
+#define CMD_HDR_DI_CFL_OFFSET	0
+#define CMD_HDR_DI_A			0x00000020
+#define CMD_HDR_DI_W			0x00000040
+#define CMD_HDR_DI_P			0x00000080
+#define CMD_HDR_DI_R			0x00000100
+#define CMD_HDR_DI_B			0x00000200
+#define CMD_HDR_DI_C			0x00000400
+#define CMD_HDR_DI_PMP_MASK	0x0000f000
+#define CMD_HDR_DI_PMP_OFFSET	12
+#define CMD_HDR_DI_PRDTL		0xffff0000
+#define CMD_HDR_DI_PRDTL_OFFSET	16
+
+/* prde_fis_len
+*/
+#define CMD_HDR_PRD_ENTRY_SHIFT	16
+#define CMD_HDR_PRD_ENTRY_MASK	0x003f0000
+#define CMD_HDR_FIS_LEN_SHIFT	2
+
+/* attribute
+*/
+#define CMD_HDR_ATTR_RES	0x00000800 /* Reserved bit, should be 1 */
+#define CMD_HDR_ATTR_VBIST	0x00000400 /* Vendor BIST */
+/* Snoop enable for all descriptor */
+#define CMD_HDR_ATTR_SNOOP	0x00000200
+#define CMD_HDR_ATTR_FPDMA	0x00000100 /* FPDMA queued command */
+#define CMD_HDR_ATTR_RESET	0x00000080 /* Reset - a SRST or device reset */
+/* BIST - require the host to enter BIST mode */
+#define CMD_HDR_ATTR_BIST	0x00000040
+#define CMD_HDR_ATTR_ATAPI	0x00000020 /* ATAPI command */
+#define CMD_HDR_ATTR_TAG	0x0000001f /* TAG mask */
+
+#define FLAGS_DMA	0x00000000
+#define FLAGS_FPDMA	0x00000001
+
+#define SATA_FLAG_Q_DEP_MASK	0x0000000f
+#define SATA_FLAG_WCACHE	0x00000100
+#define SATA_FLAG_FLUSH		0x00000200
+#define SATA_FLAG_FLUSH_EXT	0x00000400
+
+#define READ_CMD	0
+#define WRITE_CMD	1
+
+#endif /* __FSL_SATA_H__ */
diff --git a/drivers/mtd/spi/imx_spi_nor_atmel.c b/drivers/mtd/spi/imx_spi_nor_atmel.c
index 19a5197..5575498 100644
--- a/drivers/mtd/spi/imx_spi_nor_atmel.c
+++ b/drivers/mtd/spi/imx_spi_nor_atmel.c
@@ -100,13 +100,13 @@ static s32 spi_nor_status(struct spi_flash *flash)
 	return g_rx_buf[0];
 }
 
+#if 0
 /*!
  * Erase a block_size data from block_addr offset in the flash
  */
 static int spi_nor_erase_page(struct spi_flash *flash,
 				void *page_addr)
 {
-	u32 *cmd = (u32 *)g_tx_buf;
 	u32 addr = (u32)page_addr;
 
 	if ((addr & 512) != 0) {
@@ -127,6 +127,7 @@ static int spi_nor_erase_page(struct spi_flash *flash,
 
 	return 0;
 }
+#endif
 
 static int spi_nor_flash_read(struct spi_flash *flash, u32 offset,
 		size_t len, void *buf)
diff --git a/drivers/net/mxc_fec.c b/drivers/net/mxc_fec.c
index b828240..e5baf43 100644
--- a/drivers/net/mxc_fec.c
+++ b/drivers/net/mxc_fec.c
@@ -23,6 +23,10 @@
  * MA 02111-1307 USA
  */
 
+#ifdef CONFIG_ARCH_MMU
+#include <asm/arch/mmu.h>
+#endif
+
 #include <common.h>
 #include <malloc.h>
 
@@ -32,10 +36,7 @@
 #include <net.h>
 #include <miiphy.h>
 #include <linux/types.h>
-
-#ifdef CONFIG_ARCH_MMU
 #include <asm/io.h>
-#endif
 
 #undef	ET_DEBUG
 #undef	MII_DEBUG
@@ -408,8 +409,9 @@ int fec_send(struct eth_device *dev, volatile void *packet, int length)
 #endif
 
 #ifdef CONFIG_ARCH_MMU
-	memcpy(ioremap_nocache(info->txbd[info->txIdx].cbd_bufaddr, length),
-			packet, length);
+	memcpy(ioremap_nocache((ulong)info->txbd[info->txIdx].cbd_bufaddr,
+			length),
+			(void *)packet, length);
 #else
 	info->txbd[info->txIdx].cbd_bufaddr = (uint)packet;
 #endif
@@ -483,8 +485,8 @@ int fec_recv(struct eth_device *dev)
 #endif
 			/* Pass the packet up to the protocol layers. */
 #ifdef CONFIG_ARCH_MMU
-			memcpy(NetRxPackets[info->rxIdx],
-				ioremap_nocache(info->rxbd[info->rxIdx].cbd_bufaddr, 0),
+			memcpy((void *)NetRxPackets[info->rxIdx],
+				ioremap_nocache((ulong)info->rxbd[info->rxIdx].cbd_bufaddr, 0),
 				length);
 #endif
 			NetReceive(NetRxPackets[info->rxIdx], length);
@@ -761,7 +763,7 @@ int fec_init(struct eth_device *dev, bd_t *bd)
 		info->rxbd[i].cbd_datlen = 0;	/* Reset */
 #ifdef CONFIG_ARCH_MMU
 		info->rxbd[i].cbd_bufaddr =
-			(uint)iomem_to_phys(info->rxbuf[i]);
+			(uint)iomem_to_phys((ulong)info->rxbuf[i]);
 #else
 		info->rxbd[i].cbd_bufaddr = (uint)NetRxPackets[i];
 #endif
@@ -778,7 +780,7 @@ int fec_init(struct eth_device *dev, bd_t *bd)
 		info->txbd[i].cbd_datlen = 0;	/* Reset */
 #ifdef CONFIG_ARCH_MMU
 		info->txbd[i].cbd_bufaddr =
-			(uint)iomem_to_phys(&info->txbuf[0]);
+			(uint)iomem_to_phys((ulong)&info->txbuf[0]);
 #else
 		info->txbd[i].cbd_bufaddr = (uint)&info->txbuf[0];
 #endif
@@ -787,8 +789,8 @@ int fec_init(struct eth_device *dev, bd_t *bd)
 
 	/* Set receive and transmit descriptor base */
 #ifdef CONFIG_ARCH_MMU
-	fecp->erdsr = (uint)iomem_to_phys(&info->rxbd[0]);
-	fecp->etdsr = (uint)iomem_to_phys(&info->txbd[0]);
+	fecp->erdsr = (uint)iomem_to_phys((ulong)&info->rxbd[0]);
+	fecp->etdsr = (uint)iomem_to_phys((ulong)&info->txbd[0]);
 #else
 	fecp->erdsr = (uint)(&info->rxbd[0]);
 	fecp->etdsr = (uint)(&info->txbd[0]);
@@ -874,20 +876,20 @@ int mxc_fec_initialize(bd_t *bis)
 		/* setup Receive and Transmit buffer descriptor */
 #ifdef CONFIG_ARCH_MMU
 		fec_info[i].rxbd =
-			(cbd_t *)ioremap_nocache((ulong)iomem_to_phys(memalign(CONFIG_SYS_CACHELINE_SIZE,
+			(cbd_t *)ioremap_nocache(iomem_to_phys((ulong)memalign(CONFIG_SYS_CACHELINE_SIZE,
 						(PKTBUFSRX * sizeof(cbd_t)))),
 						CONFIG_SYS_CACHELINE_SIZE);
 		fec_info[i].txbd =
-			(cbd_t *)ioremap_nocache((ulong)iomem_to_phys(memalign(CONFIG_SYS_CACHELINE_SIZE,
+			(cbd_t *)ioremap_nocache(iomem_to_phys((ulong)memalign(CONFIG_SYS_CACHELINE_SIZE,
 						(TX_BUF_CNT * sizeof(cbd_t)))),
 						CONFIG_SYS_CACHELINE_SIZE);
 		fec_info[i].txbuf =
-			(char *)ioremap_nocache((ulong)iomem_to_phys(memalign(CONFIG_SYS_CACHELINE_SIZE,
+			(char *)ioremap_nocache(iomem_to_phys((ulong)memalign(CONFIG_SYS_CACHELINE_SIZE,
 						DBUF_LENGTH)),
 						CONFIG_SYS_CACHELINE_SIZE);
 		for (j = 0; j < PKTBUFSRX; ++j) {
 			fec_info[i].rxbuf[j] =
-				(char *)ioremap_nocache((ulong)iomem_to_phys(memalign(PKTSIZE_ALIGN,
+				(char *)ioremap_nocache(iomem_to_phys((ulong)memalign(PKTSIZE_ALIGN,
 						PKTSIZE)),
 						PKTSIZE_ALIGN);
 		}
diff --git a/include/ahci.h b/include/ahci.h
index 0c6bbbd..12f653a 100644
--- a/include/ahci.h
+++ b/include/ahci.h
@@ -1,4 +1,7 @@
 /*
+ * (C) Copyright 2008-2010 Freescale Semiconductor, Inc.
+ * Terry Lv <r65388@freescale.com>
+ *
  * Copyright (C) Freescale Semiconductor, Inc. 2006.
  * Author: Jason Jin<Jason.jin@freescale.com>
  *         Zhang Wei<wei.zhang@freescale.com>
@@ -25,15 +28,18 @@
 #ifndef _AHCI_H_
 #define _AHCI_H_
 
+#include <pci.h>
+
 #define AHCI_PCI_BAR		0x24
 #define AHCI_MAX_SG		56 /* hardware max is 64K */
+#define AHCI_MAX_CMD_SLOT	32
 #define AHCI_CMD_SLOT_SZ	32
 #define AHCI_RX_FIS_SZ		256
 #define AHCI_CMD_TBL_HDR	0x80
 #define AHCI_CMD_TBL_CDB	0x40
-#define AHCI_CMD_TBL_SZ		AHCI_CMD_TBL_HDR + (AHCI_MAX_SG * 16)
-#define AHCI_PORT_PRIV_DMA_SZ	AHCI_CMD_SLOT_SZ + AHCI_CMD_TBL_SZ	\
-				+ AHCI_RX_FIS_SZ
+#define AHCI_CMD_TBL_SZ		(AHCI_CMD_TBL_HDR + (AHCI_MAX_SG * 16))
+#define AHCI_PORT_PRIV_DMA_SZ	(AHCI_CMD_SLOT_SZ * AHCI_MAX_CMD_SLOT + \
+				AHCI_CMD_TBL_SZ	+ AHCI_RX_FIS_SZ)
 #define AHCI_CMD_ATAPI		(1 << 5)
 #define AHCI_CMD_WRITE		(1 << 6)
 #define AHCI_CMD_PREFETCH	(1 << 7)
@@ -179,7 +185,7 @@ struct ahci_probe_ent {
 	u32	host_flags;
 	u32	host_set_flags;
 	u32	mmio_base;
-	u32     pio_mask;
+	u32	pio_mask;
 	u32	udma_mask;
 	u32	flags;
 	u32	cap;	/* cache of HOST_CAP register */
diff --git a/include/asm-arm/arch-mx35/mmu.h b/include/asm-arm/arch-mx35/mmu.h
index 1e9a96f..1b15dba 100644
--- a/include/asm-arm/arch-mx35/mmu.h
+++ b/include/asm-arm/arch-mx35/mmu.h
@@ -136,15 +136,15 @@ union ARM_MMU_FIRST_LEVEL_DESCRIPTOR {
  * Translate the virtual address of ram space to physical address
  * It is dependent on the implementation of mmu_init
  */
-inline void *iomem_to_phys(unsigned long virt)
+inline unsigned long iomem_to_phys(unsigned long virt)
 {
 	if (virt < 0x08000000)
-		return (void *)(virt | PHYS_SDRAM_1);
+		return (unsigned long)(virt | PHYS_SDRAM_1);
 
 	if ((virt & 0xF0000000) == PHYS_SDRAM_1)
-		return (void *)(virt & (~0x08000000));
+		return (unsigned long)(virt & (~0x08000000));
 
-	return (void *)virt;
+	return (unsigned long)virt;
 }
 
 /*
diff --git a/include/asm-arm/arch-mx51/mmu.h b/include/asm-arm/arch-mx51/mmu.h
index e80cfc9..1c58977 100644
--- a/include/asm-arm/arch-mx51/mmu.h
+++ b/include/asm-arm/arch-mx51/mmu.h
@@ -140,15 +140,15 @@ union ARM_MMU_FIRST_LEVEL_DESCRIPTOR {
  * Translate the virtual address of ram space to physical address
  * It is dependent on the implementation of mmu_init
  */
-inline void *iomem_to_phys(unsigned long virt)
+inline unsigned long iomem_to_phys(unsigned long virt)
 {
 	if (virt < 0x08000000)
-		return (void *)(virt | PHYS_SDRAM_1);
+		return (unsigned long)(virt | PHYS_SDRAM_1);
 
 	if ((virt & 0xF0000000) == PHYS_SDRAM_1)
-		return (void *)(virt & (~0x08000000));
+		return (unsigned long)(virt & (~0x08000000));
 
-	return (void *)virt;
+	return (unsigned long)virt;
 }
 
 /*
@@ -174,15 +174,15 @@ void *__ioremap(unsigned long offset, size_t size, unsigned long flags)
  * Translate the virtual address of ram space to physical address
  * It is dependent on the implementation of mmu_init
  */
-inline void *iomem_to_phys(unsigned long virt)
+inline unsigned long iomem_to_phys(unsigned long virt)
 {
 	if (virt < (PHYS_SDRAM_1_SIZE - 0x100000))
-		return (void *)(virt + PHYS_SDRAM_1);
+		return (unsigned long)(virt + PHYS_SDRAM_1);
 
 	if (virt >= 0xE0000000)
-		return (void *)((virt - 0xE0000000) + PHYS_SDRAM_1);
+		return (unsigned long)((virt - 0xE0000000) + PHYS_SDRAM_1);
 
-	return (void *)virt;
+	return (unsigned long)virt;
 }
 
 /*
@@ -201,7 +201,7 @@ void *__ioremap(unsigned long offset, size_t size, unsigned long flags)
 		meory space which is mapped to SDRAM */
 		if (offset >= PHYS_SDRAM_1 &&
 			offset < (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
-			return (void *)(offset - PHYS_SDRAM_1) + 0xE0000000;
+			return (void *)((offset - PHYS_SDRAM_1) + 0xE0000000);
 		else
 			return NULL;
 	} else
diff --git a/include/asm-arm/arch-mx53/mmu.h b/include/asm-arm/arch-mx53/mmu.h
index 5fa2fc0..5063528 100644
--- a/include/asm-arm/arch-mx53/mmu.h
+++ b/include/asm-arm/arch-mx53/mmu.h
@@ -138,12 +138,12 @@ union ARM_MMU_FIRST_LEVEL_DESCRIPTOR {
  * Translate the virtual address of ram space to physical address
  * It is dependent on the implementation of mmu_init
  */
-inline void *iomem_to_phys(unsigned long virt)
+inline unsigned long iomem_to_phys(unsigned long virt)
 {
 	if (virt >= 0xB0000000)
-		return (void *)((virt - 0xB0000000) + PHYS_SDRAM_1);
+		return (unsigned long)((virt - 0xB0000000) + PHYS_SDRAM_1);
 
-	return (void *)virt;
+	return (unsigned long)virt;
 }
 
 /*
@@ -154,8 +154,8 @@ void *__ioremap(unsigned long offset, size_t size, unsigned long flags)
 {
 	if (1 == flags) {
 		if (offset >= PHYS_SDRAM_1 &&
-			offset < (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
-			return (void *)(offset - PHYS_SDRAM_1) + 0xB0000000;
+		offset < (unsigned long)(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
+			return (void *)((offset - PHYS_SDRAM_1) + 0xB0000000);
 		else
 			return NULL;
 	} else
diff --git a/include/asm-arm/arch-mx53/mx53.h b/include/asm-arm/arch-mx53/mx53.h
index 6586b9c..ea04877 100644
--- a/include/asm-arm/arch-mx53/mx53.h
+++ b/include/asm-arm/arch-mx53/mx53.h
@@ -23,7 +23,12 @@
 #define __REG16(x)      (*((volatile u16 *)(x)))
 #define __REG8(x)       (*((volatile u8 *)(x)))
 
- /*
+/*
+ * SATA
+ */
+#define SATA_BASE_ADDR		0x10000000
+
+/*
  * IRAM
  */
 #define IRAM_BASE_ADDR		0xF8000000	/* internal ram */
@@ -407,6 +412,7 @@ enum mxc_clock {
 	MXC_ESDHC2_CLK,
 	MXC_ESDHC3_CLK,
 	MXC_ESDHC4_CLK,
+	MXC_SATA_CLK
 };
 
 enum mxc_peri_clocks {
diff --git a/include/configs/mx53_arm2.h b/include/configs/mx53_arm2.h
index 7265062..c28f6d3 100644
--- a/include/configs/mx53_arm2.h
+++ b/include/configs/mx53_arm2.h
@@ -100,6 +100,8 @@
 #define CONFIG_CMD_CLOCK
 #define CONFIG_REF_CLK_FREQ CONFIG_MX53_HCLK_FREQ
 
+#define CONFIG_CMD_SATA
+
 #undef CONFIG_CMD_IMLS
 
 #define CONFIG_BOOTDELAY	3
@@ -198,6 +200,19 @@
 	#define CONFIG_CMD_FAT		1
 	#define CONFIG_CMD_EXT2		1
 #endif
+
+/*
+ * SATA Configs
+ */
+#ifdef CONFIG_CMD_SATA
+	#define CONFIG_DWC_AHSATA
+	#define CONFIG_SYS_SATA_MAX_DEVICE	1
+	#define CONFIG_DWC_AHSATA_PORT_ID	0
+	#define CONFIG_DWC_AHSATA_BASE_ADDR 	SATA_BASE_ADDR
+	#define CONFIG_LBA48
+	#define CONFIG_LIBATA
+#endif
+
 /*-----------------------------------------------------------------------
  * Stack sizes
  *
@@ -212,7 +227,8 @@
 #define PHYS_SDRAM_1		CSD0_BASE_ADDR
 #define PHYS_SDRAM_1_SIZE	(1024 * 1024 * 1024)
 #define iomem_valid_addr(addr, size) \
-	(addr >= PHYS_SDRAM_1 && addr <= (PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
+	(addr >= PHYS_SDRAM_1 && addr <= \
+		(unsigned long)(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE))
 
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
diff --git a/include/configs/mx53_evk.h b/include/configs/mx53_evk.h
index 760d4ac..4fa66f2 100644
--- a/include/configs/mx53_evk.h
+++ b/include/configs/mx53_evk.h
@@ -100,6 +100,7 @@
 #define CONFIG_CMD_CLOCK
 #define CONFIG_REF_CLK_FREQ CONFIG_MX53_HCLK_FREQ
 
+#define CONFIG_CMD_SATA
 #undef CONFIG_CMD_IMLS
 
 #define CONFIG_BOOTDELAY	3
@@ -198,6 +199,19 @@
 	#define CONFIG_CMD_FAT		1
 	#define CONFIG_CMD_EXT2		1
 #endif
+
+/*
+ * SATA Configs
+ */
+#ifdef CONFIG_CMD_SATA
+	#define CONFIG_DWC_AHSATA
+	#define CONFIG_SYS_SATA_MAX_DEVICE	1
+	#define CONFIG_DWC_AHSATA_PORT_ID	0
+	#define CONFIG_DWC_AHSATA_BASE_ADDR 	SATA_BASE_ADDR
+	#define CONFIG_LBA48
+	#define CONFIG_LIBATA
+#endif
+
 /*-----------------------------------------------------------------------
  * Stack sizes
  *
-- 
1.5.4.4

