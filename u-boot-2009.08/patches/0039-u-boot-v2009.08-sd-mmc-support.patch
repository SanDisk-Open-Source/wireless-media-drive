From ba816f983f5dac44d9f4461906b9bc0101237ac8 Mon Sep 17 00:00:00 2001
From: Terry Lv <r65388@freescale.com>
Date: Thu, 29 Oct 2009 19:19:00 +0800
Subject: [PATCH] u-boot v2009.08 sd/mmc support.

Signed-off-by: Terry Lv <r65388@freescale.com>
---
 Makefile                                  |    8 +-
 board/freescale/imx51/Makefile            |   49 -
 board/freescale/imx51/board-imx51.h       |   64 --
 board/freescale/imx51/config.mk           |    3 -
 board/freescale/imx51/flash_header.S      |  113 ---
 board/freescale/imx51/imx51.c             |  611 -----------
 board/freescale/imx51/lowlevel_init.S     |  287 ------
 board/freescale/imx51/u-boot.lds          |   73 --
 board/freescale/mx25_3stack/config.mk     |    2 +
 board/freescale/mx25_3stack/mx25_3stack.c |   23 +-
 board/freescale/mx31_3stack/config.mk     |    2 +
 board/freescale/mx35_3stack/config.mk     |    2 +
 board/freescale/mx35_3stack/mx35_3stack.c |  175 ++--
 board/freescale/mx51_3stack/config.mk     |    2 +
 board/freescale/mx51_3stack/mx51_3stack.c |   27 +-
 board/freescale/mx51_bbg/Makefile         |   49 +
 board/freescale/mx51_bbg/board-imx51.h    |   64 ++
 board/freescale/mx51_bbg/config.mk        |    3 +
 board/freescale/mx51_bbg/flash_header.S   |  113 +++
 board/freescale/mx51_bbg/lowlevel_init.S  |  287 ++++++
 board/freescale/mx51_bbg/mx51_bbg.c       |  680 +++++++++++++
 board/freescale/mx51_bbg/u-boot.lds       |   73 ++
 board/stmp378x_dev/config.mk              |    1 +
 common/Makefile                           |    2 +
 common/cmd_mmc.c                          |    7 +-
 common/env_mmc.c                          |  100 ++-
 cpu/arm1136/mx35/Makefile                 |    2 +-
 cpu/arm1136/mx35/generic.c                |  159 +++-
 cpu/arm1136/mx35/interrupts.c             |  115 ---
 cpu/arm1136/mx35/timer.c                  |  127 +++
 cpu/arm1136/start.S                       |   42 +-
 cpu/arm926ejs/mx25/Makefile               |    2 +-
 cpu/arm926ejs/mx25/interrupts.c           |  121 ---
 cpu/arm926ejs/mx25/timer.c                |  135 +++
 cpu/arm_cortexa8/mx51/generic.c           |    2 +
 drivers/i2c/mxc_i2c.c                     |    2 +-
 drivers/mmc/Makefile                      |    1 +
 drivers/mmc/fsl_mmc.c                     | 1569 -----------------------------
 drivers/mmc/imx_esdhc.c                   |  448 ++++++++
 drivers/mmc/mmc.c                         |   57 +-
 drivers/net/smc911x.c                     |  466 +---------
 drivers/net/smc911x.h                     |    9 +-
 include/asm-arm/arch-mx25/mmc.h           |   16 -
 include/asm-arm/arch-mx25/sdhc.h          |  218 ----
 include/asm-arm/arch-mx35/mmc.h           |   16 -
 include/asm-arm/arch-mx35/mx35.h          |   33 +
 include/asm-arm/arch-mx35/sdhc.h          |  218 ----
 include/asm-arm/arch-mx51/mmc.h           |   16 -
 include/asm-arm/arch-mx51/mx51.h          |   26 +
 include/asm-arm/arch-mx51/sdhc.h          |  218 ----
 include/configs/imx51.h                   |  239 -----
 include/configs/imx51_android.h           |  297 ------
 include/configs/mx25_3stack.h             |   35 +-
 include/configs/mx31_3stack.h             |   12 +-
 include/configs/mx35_3stack.h             |    7 +-
 include/configs/mx35_3stack_mmc.h         |   20 +-
 include/configs/mx51_3stack.h             |   30 +-
 include/configs/mx51_3stack_android.h     |   68 +-
 include/configs/mx51_bbg.h                |  277 +++++
 include/configs/mx51_bbg_android.h        |  298 ++++++
 include/fsl_esdhc.h                       |    8 +-
 include/linux/mmc/card.h                  |  141 ---
 include/linux/mmc/core.h                  |  132 ---
 include/linux/mmc/mmc.h                   |  291 ------
 include/linux/mmc/sd.h                    |   95 --
 include/linux/mmc/sdhci.h                 |  223 ----
 lib_arm/board.c                           |   10 +-
 net/eth.c                                 |    4 +-
 68 files changed, 3147 insertions(+), 5878 deletions(-)

diff --git a/Makefile b/Makefile
index b131cc7..d37e5ad 100644
--- a/Makefile
+++ b/Makefile
@@ -3235,16 +3235,16 @@ mx31pdk_nand_config	: unconfig
 	fi
 	@$(MKCONFIG) -a mx31pdk arm arm1136 mx31pdk freescale mx31
 
-Mx31_3stack_config	: unconfig
+mx31_3stack_config	: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm1136 mx31_3stack freescale mx31
 
 mx35_3stack_config      \
 mx35_3stack_mmc_config: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm1136 mx35_3stack freescale mx35
 
-imx51_android_config	\
-imx51_config		: unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 imx51 freescale mx51
+mx51_bbg_android_config	\
+mx51_bbg_config		: unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 mx51_bbg freescale mx51
 
 mx51_3stack_android_config	\
 mx51_3stack_config	: unconfig
diff --git a/board/freescale/imx51/Makefile b/board/freescale/imx51/Makefile
deleted file mode 100644
index fbd40f2..0000000
--- a/board/freescale/imx51/Makefile
+++ /dev/null
@@ -1,49 +0,0 @@
-#
-# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
-#
-# (C) Copyright 2009 Freescale Semiconductor, Inc.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= imx51.o
-SOBJS	:= lowlevel_init.o flash_header.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak .depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff --git a/board/freescale/imx51/board-imx51.h b/board/freescale/imx51/board-imx51.h
deleted file mode 100644
index 7a2cae0..0000000
--- a/board/freescale/imx51/board-imx51.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __BOARD_FREESCALE_BOARD_IMX51_H__
-#define __BOARD_FREESCALE_BOARD_IMX51_H__
-
-/*!
- * @defgroup BRDCFG_MX51 Board Configuration Options
- * @ingroup MSL_MX51
- */
-
-/*!
- * @file mx51_3stack/board-imx51.h
- *
- * @brief This file contains all the board level configuration options.
- *
- * It currently hold the options defined for MX51 3Stack Platform.
- *
- * @ingroup BRDCFG_IMX51
- */
-
-/* CPLD offsets */
-#define PBC_LED_CTRL		(0x20000)
-#define PBC_SB_STAT		(0x20008)
-#define PBC_ID_AAAA		(0x20040)
-#define PBC_ID_5555		(0x20048)
-#define PBC_VERSION		(0x20050)
-#define PBC_ID_CAFE		(0x20058)
-#define PBC_INT_STAT		(0x20010)
-#define PBC_INT_MASK		(0x20038)
-#define PBC_INT_REST		(0x20020)
-#define PBC_SW_RESET		(0x20060)
-
-/* LED switchs */
-#define LED_SWITCH_REG		0x00
-/* buttons */
-#define SWITCH_BUTTONS_REG	0x08
-/* status, interrupt */
-#define INTR_STATUS_REG	0x10
-#define INTR_MASK_REG		0x38
-#define INTR_RESET_REG		0x20
-/* magic word for debug CPLD */
-#define MAGIC_NUMBER1_REG	0x40
-#define MAGIC_NUMBER2_REG	0x48
-/* CPLD code version */
-#define CPLD_CODE_VER_REG	0x50
-/* magic word for debug CPLD */
-#define MAGIC_NUMBER3_REG	0x58
-/* module reset register*/
-#define MODULE_RESET_REG	0x60
-/* CPU ID and Personality ID */
-#define MCU_BOARD_ID_REG	0x68
-
-#endif				/* __BOARD_FREESCALE_BOARD_IMX51_H__ */
diff --git a/board/freescale/imx51/config.mk b/board/freescale/imx51/config.mk
deleted file mode 100644
index 705aa34..0000000
--- a/board/freescale/imx51/config.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
-
-TEXT_BASE = 0x97800000
diff --git a/board/freescale/imx51/flash_header.S b/board/freescale/imx51/flash_header.S
deleted file mode 100644
index 6790679..0000000
--- a/board/freescale/imx51/flash_header.S
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright 2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <asm/arch/mx51.h>
-#include "board-imx51.h"
-
-#ifdef	CONFIG_FLASH_HEADER
-#ifndef CONFIG_FLASH_HEADER_OFFSET
-# error "Must define the offset of flash header"
-#endif
-#define MXC_DCD_ITEM(i, type, addr, val)	\
-dcd_node_##i:					\
-	.word type			;	\
-	.word addr			;	\
-	.word val			;	\
-
-.section ".text.flasheader", "x"
-	b	_start
-	.org	CONFIG_FLASH_HEADER_OFFSET
-app_code_jump_v:	.word	_start
-app_code_code_barker:	.word	CONFIG_FLASH_HEADER_BARKER
-app_code_csf:		.word	0
-dcd_ptr_ptr:		.word	dcd_ptr
-super_root_key:		.word	0
-dcd_ptr:		.word	dcd_array_start
-app_dest_ptr:		.word	TEXT_BASE
-dcd_array_start:
-magic:			.word	0xB17219E9
-dcd_array_size:		.word	dcd_data_end - dcd_array_start - 8
-/* DCD */
-/* DDR2 IOMUX configuration */
-MXC_DCD_ITEM(1, 4, IOMUXC_BASE_ADDR + 0x8a0, 0x200)
-MXC_DCD_ITEM(2, 4, IOMUXC_BASE_ADDR + 0x50c, 0x20c5)
-MXC_DCD_ITEM(3, 4, IOMUXC_BASE_ADDR + 0x510, 0x20c5)
-MXC_DCD_ITEM(4, 4, IOMUXC_BASE_ADDR + 0x83c, 0x2)
-MXC_DCD_ITEM(5, 4, IOMUXC_BASE_ADDR + 0x848, 0x2)
-MXC_DCD_ITEM(6, 4, IOMUXC_BASE_ADDR + 0x4b8, 0xe7)
-MXC_DCD_ITEM(7, 4, IOMUXC_BASE_ADDR + 0x4bc, 0x45)
-MXC_DCD_ITEM(8, 4, IOMUXC_BASE_ADDR + 0x4c0, 0x45)
-MXC_DCD_ITEM(9, 4, IOMUXC_BASE_ADDR + 0x4c4, 0x45)
-MXC_DCD_ITEM(10, 4, IOMUXC_BASE_ADDR + 0x4c8, 0x45)
-MXC_DCD_ITEM(11, 4, IOMUXC_BASE_ADDR + 0x820, 0x0)
-MXC_DCD_ITEM(12, 4, IOMUXC_BASE_ADDR + 0x4a4, 0x3)
-MXC_DCD_ITEM(13, 4, IOMUXC_BASE_ADDR + 0x4a8, 0x3)
-MXC_DCD_ITEM(14, 4, IOMUXC_BASE_ADDR + 0x4ac, 0xe3)
-MXC_DCD_ITEM(15, 4, IOMUXC_BASE_ADDR + 0x4b0, 0xe3)
-MXC_DCD_ITEM(16, 4, IOMUXC_BASE_ADDR + 0x4b4, 0xe3)
-MXC_DCD_ITEM(17, 4, IOMUXC_BASE_ADDR + 0x4cc, 0xe3)
-MXC_DCD_ITEM(18, 4, IOMUXC_BASE_ADDR + 0x4d0, 0xe2)
-/* Set drive strength to MAX */
-MXC_DCD_ITEM(19, 4, IOMUXC_BASE_ADDR + 0x82c, 0x6)
-MXC_DCD_ITEM(20, 4, IOMUXC_BASE_ADDR + 0x8a4, 0x6)
-MXC_DCD_ITEM(21, 4, IOMUXC_BASE_ADDR + 0x8ac, 0x6)
-MXC_DCD_ITEM(22, 4, IOMUXC_BASE_ADDR + 0x8b8, 0x6)
-/* 13 ROW, 10 COL, 32Bit, SREF=4 Micron Model */
-/* CAS=3,  BL=4 */
-MXC_DCD_ITEM(23, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL0, 0x82a20000)
-MXC_DCD_ITEM(24, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL1, 0x82a20000)
-MXC_DCD_ITEM(25, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDMISC, 0x000ad0d0)
-MXC_DCD_ITEM(26, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCFG0, 0x333574aa)
-MXC_DCD_ITEM(27, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCFG1, 0x333574aa)
-/* Init DRAM on CS0 */
-MXC_DCD_ITEM(28, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x04008008)
-MXC_DCD_ITEM(29, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801a)
-MXC_DCD_ITEM(30, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801b)
-MXC_DCD_ITEM(31, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00448019)
-MXC_DCD_ITEM(32, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x07328018)
-MXC_DCD_ITEM(33, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x04008008)
-MXC_DCD_ITEM(34, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008010)
-MXC_DCD_ITEM(35, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008010)
-MXC_DCD_ITEM(36, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x06328018)
-MXC_DCD_ITEM(37, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x03808019)
-MXC_DCD_ITEM(38, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00408019)
-MXC_DCD_ITEM(39, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008000)
-/* Init DRAM on CS1 */
-MXC_DCD_ITEM(40, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0400800c)
-MXC_DCD_ITEM(41, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801e)
-MXC_DCD_ITEM(42, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801f)
-MXC_DCD_ITEM(43, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801d)
-MXC_DCD_ITEM(44, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0732801c)
-MXC_DCD_ITEM(45, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0400800c)
-MXC_DCD_ITEM(46, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008014)
-MXC_DCD_ITEM(47, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008014)
-MXC_DCD_ITEM(48, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0632801c)
-MXC_DCD_ITEM(49, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0380801d)
-MXC_DCD_ITEM(50, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0040801d)
-MXC_DCD_ITEM(51, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008004)
-MXC_DCD_ITEM(52, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL0, 0xb2a20000)
-MXC_DCD_ITEM(53, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL1, 0xb2a20000)
-MXC_DCD_ITEM(54, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDMISC, 0x000ad6d0)
-MXC_DCD_ITEM(55, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCDLYGD, 0x90000000)
-MXC_DCD_ITEM(56, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00000000)
-dcd_data_end:
-image_len:		.word	0x100000
-//image_len:		.word	_end - _start
-#endif
diff --git a/board/freescale/imx51/imx51.c b/board/freescale/imx51/imx51.c
deleted file mode 100644
index 364f224..0000000
--- a/board/freescale/imx51/imx51.c
+++ /dev/null
@@ -1,611 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/mx51.h>
-#include <asm/arch/mx51_pins.h>
-#include <asm/arch/iomux.h>
-#include <asm/errno.h>
-#include <i2c.h>
-#include <mxc_keyb.h>
-#include <asm/arch/keypad.h>
-#include "board-imx51.h"
-#include <asm/arch/imx_spi.h>
-#include <asm/arch/imx_spi_pmic.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-static u32 system_rev;
-u32	mx51_io_base_addr;
-volatile u32 *esdhc_base_pointer;
-
-u32 get_board_rev(void)
-{
-	return system_rev;
-}
-
-static inline void setup_soc_rev(void)
-{
-	int reg;
-	reg = __REG(ROM_SI_REV);
-	switch (reg) {
-	case 0x02:
-		system_rev = 0x51000 | CHIP_REV_1_1;
-		break;
-	case 0x10:
-		if ((__REG(GPIO1_BASE_ADDR + 0x0) & (0x1 << 22)) == 0) {
-			system_rev = 0x51000 | CHIP_REV_2_5;
-		} else {
-			system_rev = 0x51000 | CHIP_REV_2_0;
-		}
-		break;
-	default:
-		system_rev = 0x51000 | CHIP_REV_1_0;
-	}
-}
-
-static inline void set_board_rev(int rev)
-{
-	system_rev |= (rev & 0xF) << 8;
-}
-
-inline int is_soc_rev(int rev)
-{
-	return (system_rev & 0xFF) - rev;
-}
-
-int dram_init(void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
-	return 0;
-}
-
-static void setup_uart(void)
-{
-	unsigned int pad = PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE |
-			 PAD_CTL_PUE_PULL | PAD_CTL_DRV_HIGH;
-	mxc_request_iomux(MX51_PIN_UART1_RXD, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX51_PIN_UART1_RXD, pad | PAD_CTL_SRE_FAST);
-	mxc_request_iomux(MX51_PIN_UART1_TXD, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX51_PIN_UART1_TXD, pad | PAD_CTL_SRE_FAST);
-	mxc_request_iomux(MX51_PIN_UART1_RTS, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX51_PIN_UART1_RTS, pad);
-	mxc_request_iomux(MX51_PIN_UART1_CTS, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX51_PIN_UART1_CTS, pad);
-}
-
-void setup_nfc(void)
-{
-	/* Enable NFC IOMUX */
-	mxc_request_iomux(MX51_PIN_NANDF_CS0, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS1, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT0);
-}
-
-static void setup_expio(void)
-{
-	u32 reg;
-	/* CS5 setup */
-	mxc_request_iomux(MX51_PIN_EIM_CS5, IOMUX_CONFIG_ALT0);
-	writel(0x00410089, WEIM_BASE_ADDR + 0x78 + CSGCR1);
-	writel(0x00000002, WEIM_BASE_ADDR + 0x78 + CSGCR2);
-	/* RWSC=50, RADVA=2, RADVN=6, OEA=0, OEN=0, RCSA=0, RCSN=0 */
-	writel(0x32260000, WEIM_BASE_ADDR + 0x78 + CSRCR1);
-	/* APR = 0 */
-	writel(0x00000000, WEIM_BASE_ADDR + 0x78 + CSRCR2);
-	/* WAL=0, WBED=1, WWSC=50, WADVA=2, WADVN=6, WEA=0, WEN=0,
-	 * WCSA=0, WCSN=0
-	 */
-	writel(0x72080F00, WEIM_BASE_ADDR + 0x78 + CSWCR1);
-	if ((readw(CS5_BASE_ADDR + PBC_ID_AAAA) == 0xAAAA) &&
-	    (readw(CS5_BASE_ADDR + PBC_ID_5555) == 0x5555)) {
-		if (is_soc_rev(CHIP_REV_2_0) < 0) {
-			reg = readl(CCM_BASE_ADDR + CLKCTL_CBCDR);
-			reg = (reg & (~0x70000)) | 0x30000;
-			writel(reg, CCM_BASE_ADDR + CLKCTL_CBCDR);
-			/* make sure divider effective */
-			while (readl(CCM_BASE_ADDR + CLKCTL_CDHIPR) != 0)
-				;
-			writel(0x0, CCM_BASE_ADDR + CLKCTL_CCDR);
-		}
-		mx51_io_base_addr = CS5_BASE_ADDR;
-	} else {
-		/* CS1 */
-		writel(0x00410089, WEIM_BASE_ADDR + 0x18 + CSGCR1);
-		writel(0x00000002, WEIM_BASE_ADDR + 0x18 + CSGCR2);
-		/*  RWSC=50, RADVA=2, RADVN=6, OEA=0, OEN=0, RCSA=0, RCSN=0 */
-		writel(0x32260000, WEIM_BASE_ADDR + 0x18 + CSRCR1);
-		/* APR=0 */
-		writel(0x00000000, WEIM_BASE_ADDR + 0x18 + CSRCR2);
-		/* WAL=0, WBED=1, WWSC=50, WADVA=2, WADVN=6, WEA=0,
-		 * WEN=0, WCSA=0, WCSN=0
-		 */
-		writel(0x72080F00, WEIM_BASE_ADDR + 0x18 + CSWCR1);
-		mx51_io_base_addr = CS1_BASE_ADDR;
-	}
-
-	/* Reset interrupt status reg */
-	writew(0x1F, mx51_io_base_addr + PBC_INT_REST);
-	writew(0x00, mx51_io_base_addr + PBC_INT_REST);
-	writew(0xFFFF, mx51_io_base_addr + PBC_INT_MASK);
-
-	/* Reset the XUART and Ethernet controllers */
-	reg = readw(mx51_io_base_addr + PBC_SW_RESET);
-	reg |= 0x9;
-	writew(reg, mx51_io_base_addr + PBC_SW_RESET);
-	reg &= ~0x9;
-	writew(reg, mx51_io_base_addr + PBC_SW_RESET);
-}
-
-void spi_io_init(struct imx_spi_dev_t *dev)
-{
-	switch (dev->base) {
-	case CSPI1_BASE_ADDR:
-		/* 000: Select mux mode: ALT0 mux port: MOSI of instance: ecspi1 */
-		mxc_request_iomux(MX51_PIN_CSPI1_MOSI, IOMUX_CONFIG_ALT0);
-		mxc_iomux_set_pad(MX51_PIN_CSPI1_MOSI, 0x105);
-
-		/* 000: Select mux mode: ALT0 mux port: MISO of instance: ecspi1. */
-		mxc_request_iomux(MX51_PIN_CSPI1_MISO, IOMUX_CONFIG_ALT0);
-		mxc_iomux_set_pad(MX51_PIN_CSPI1_MISO, 0x105);
-
-		if (dev->ss == 0) {
-			/* de-select SS1 of instance: ecspi1. */
-			mxc_request_iomux(MX51_PIN_CSPI1_SS1, IOMUX_CONFIG_ALT3);
-			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS1, 0x85);
-			/* 000: Select mux mode: ALT0 mux port: SS0 of instance: ecspi1. */
-			mxc_request_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT0);
-			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS0, 0x185);
-		} else if (dev->ss == 1) {
-			/* de-select SS0 of instance: ecspi1. */
-			mxc_request_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT3);
-			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS0, 0x85);
-			/* 000: Select mux mode: ALT0 mux port: SS1 of instance: ecspi1. */
-			mxc_request_iomux(MX51_PIN_CSPI1_SS1, IOMUX_CONFIG_ALT0);
-			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS1, 0x105);
-		}
-
-		/* 000: Select mux mode: ALT0 mux port: RDY of instance: ecspi1. */
-		mxc_request_iomux(MX51_PIN_CSPI1_RDY, IOMUX_CONFIG_ALT0);
-		mxc_iomux_set_pad(MX51_PIN_CSPI1_RDY, 0x180);
-
-		/* 000: Select mux mode: ALT0 mux port: SCLK of instance: ecspi1. */
-		mxc_request_iomux(MX51_PIN_CSPI1_SCLK, IOMUX_CONFIG_ALT0);
-		mxc_iomux_set_pad(MX51_PIN_CSPI1_SCLK, 0x105);
-		break;
-	case CSPI2_BASE_ADDR:
-	default:
-		break;
-	}
-}
-
-static void setup_fec(void)
-{
-	/*FEC_MDIO*/
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0D4);
-	writel(0x1FD, IOMUXC_BASE_ADDR + 0x0468);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0954);
-
-	/*FEC_MDC*/
-	writel(0x2, IOMUXC_BASE_ADDR + 0x13C);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0524);
-
-	/* FEC RDATA[3] */
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0EC);
-	writel(0x180, IOMUXC_BASE_ADDR + 0x0480);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0964);
-
-	/* FEC RDATA[2] */
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0E8);
-	writel(0x180, IOMUXC_BASE_ADDR + 0x047C);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0960);
-
-	/* FEC RDATA[1] */
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0d8);
-	writel(0x180, IOMUXC_BASE_ADDR + 0x046C);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x095C);
-
-	/* FEC RDATA[0] */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x016C);
-	writel(0x2180, IOMUXC_BASE_ADDR + 0x0554);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0958);
-
-	/* FEC TDATA[3] */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x148);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0530);
-
-	/* FEC TDATA[2] */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x144);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x052C);
-
-	/* FEC TDATA[1] */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x140);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0528);
-
-	/* FEC TDATA[0] */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x0170);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0558);
-
-	/* FEC TX_EN */
-	writel(0x1, IOMUXC_BASE_ADDR + 0x014C);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0534);
-
-	/* FEC TX_ER */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x0138);
-	writel(0x2004, IOMUXC_BASE_ADDR + 0x0520);
-
-	/* FEC TX_CLK */
-	writel(0x1, IOMUXC_BASE_ADDR + 0x0150);
-	writel(0x2180, IOMUXC_BASE_ADDR + 0x0538);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0974);
-
-	/* FEC COL */
-	writel(0x1, IOMUXC_BASE_ADDR + 0x0124);
-	writel(0x2180, IOMUXC_BASE_ADDR + 0x0500);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x094c);
-
-	/* FEC RX_CLK */
-	writel(0x1, IOMUXC_BASE_ADDR + 0x0128);
-	writel(0x2180, IOMUXC_BASE_ADDR + 0x0504);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0968);
-
-	/* FEC CRS */
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0f4);
-	writel(0x180, IOMUXC_BASE_ADDR + 0x0488);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0950);
-
-	/* FEC RX_ER */
-	writel(0x3, IOMUXC_BASE_ADDR + 0x0f0);
-	writel(0x180, IOMUXC_BASE_ADDR + 0x0484);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x0970);
-
-	/* FEC RX_DV */
-	writel(0x2, IOMUXC_BASE_ADDR + 0x164);
-	writel(0x2180, IOMUXC_BASE_ADDR + 0x054C);
-	writel(0x0, IOMUXC_BASE_ADDR + 0x096C);
-}
-
-static void power_init(void)
-{
-	struct spi_slave *slave;
-	unsigned int val;
-	unsigned int reg;
-
-	slave = spi_pmic_probe();
-
-	/* power up the system first */
-	pmic_reg(slave, 34, 0x00200000, 1);
-
-	if (mxc_get_clock(MXC_FEC_CLK) > 800000000) {
-		/* Set core voltage to 1.175V */
-		val = pmic_reg(slave, 24, 0, 0);
-		val = (val & (~0x1F)) | 0x17;
-		pmic_reg(slave, 24, val, 1);
-	}
-
-	/* Setup VCC (SW2) to 1.225 */
-	val = pmic_reg(slave, 25, 0, 0);
-	val = (val & (~0x1F)) | 0x19;
-	pmic_reg(slave, 25, val, 1);
-
-	/* Setup 1V2_DIG1 (SW3) to 1.2 */
-	val = pmic_reg(slave, 26, 0, 0);
-	val = (val & (~0x1F)) | 0x18;
-	pmic_reg(slave, 25, val, 1);
-
-	/* Set VDIG to 1.65V, VGEN3 to 1.8V, VCAM to 2.5V */
-	val = pmic_reg(slave, 30, 0, 0);
-	val &= ~0x34030;
-	val |= 0x10020;
-	pmic_reg(slave, 30, val, 1);
-
-	/* Set VVIDEO to 2.775V, VAUDIO to 3V, VSD to 3.15V */
-	val = pmic_reg(slave, 31, 0, 0);
-	val &= ~0x1FC;
-	val |= 0x1F4;
-	pmic_reg(slave, 31, val, 1);
-
-	/* Configure VGEN3 and VCAM regulators to use external PNP */
-	val = 0x208;
-	pmic_reg(slave, 33, val, 1);
-	udelay(200);
-
-	reg = readl(GPIO2_BASE_ADDR + 0x0);
-	reg &= ~0x4000;  /* Lower reset line */
-	writel(reg, GPIO2_BASE_ADDR + 0x0);
-
-	reg = readl(GPIO2_BASE_ADDR + 0x4);
-	reg |= 0x4000;  /* configure GPIO lines as output */
-	writel(reg, GPIO2_BASE_ADDR + 0x4);
-
-	/* Reset the ethernet controller over GPIO */
-	writel(0x1, IOMUXC_BASE_ADDR + 0x0AC);
-
-	/* Enable VGEN3, VCAM, VAUDIO, VVIDEO, VSD regulators */
-	val = 0x49249;
-	pmic_reg(slave, 33, val, 1);
-
-	udelay(500);
-
-	reg = readl(GPIO2_BASE_ADDR + 0x0);
-	reg |= 0x4000;
-	writel(reg, GPIO2_BASE_ADDR + 0x0);
-
-	/* Setup the FEC after enabling the regulators */
-	setup_fec();
-
-	spi_pmic_free(slave);
-}
-
-#ifdef CONFIG_NET_MULTI
-
-#if defined(CONFIG_DRIVER_SMC911X)
-extern int smc911x_initialize(bd_t *bis);
-#endif
-int board_eth_init(bd_t *bis)
-{
-	int rc = -ENODEV;
-
-#if defined(CONFIG_DRIVER_SMC911X)
-	rc = smc911x_initialize(bis);
-#endif
-
-	return rc;
-}
-#endif
-
-#ifdef CONFIG_FSL_MMC
-
-int sdhc_init(void)
-{
-	u32 interface_esdhc = 0;
-	s32 status = 0;
-
-	interface_esdhc = (readl(SRC_BASE_ADDR + 0x4) & (0x00180000)) >> 19;
-
-	switch (interface_esdhc) {
-	case 0:
-
-		esdhc_base_pointer = (volatile u32 *)MMC_SDHC1_BASE_ADDR;
-
-		mxc_request_iomux(MX51_PIN_SD1_CMD,
-			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-		mxc_request_iomux(MX51_PIN_SD1_CLK,
-			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-
-		mxc_request_iomux(MX51_PIN_SD1_DATA0,
-				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-		mxc_request_iomux(MX51_PIN_SD1_DATA1,
-				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-		mxc_request_iomux(MX51_PIN_SD1_DATA2,
-				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-		mxc_request_iomux(MX51_PIN_SD1_DATA3,
-				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
-		mxc_iomux_set_pad(MX51_PIN_SD1_CMD,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_ENABLE | PAD_CTL_47K_PU |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		mxc_iomux_set_pad(MX51_PIN_SD1_CLK,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_NONE | PAD_CTL_47K_PU |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		mxc_iomux_set_pad(MX51_PIN_SD1_DATA0,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_ENABLE | PAD_CTL_47K_PU |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		mxc_iomux_set_pad(MX51_PIN_SD1_DATA1,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_ENABLE | PAD_CTL_47K_PU |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		mxc_iomux_set_pad(MX51_PIN_SD1_DATA2,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_ENABLE | PAD_CTL_47K_PU |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		mxc_iomux_set_pad(MX51_PIN_SD1_DATA3,
-				PAD_CTL_DRV_MAX | PAD_CTL_DRV_VOT_HIGH |
-				PAD_CTL_HYS_ENABLE | PAD_CTL_100K_PD |
-				PAD_CTL_PUE_PULL |
-				PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST);
-		break;
-	case 1:
-		status = 1;
-		break;
-	case 2:
-		status = 1;
-		break;
-	case 3:
-		status = 1;
-		break;
-	default:
-		status = 1;
-		break;
-	}
-
-	return status = 1;
-}
-
-#endif
-
-#if defined(CONFIG_MXC_KPD)
-int setup_mxc_kpd()
-{
-	mxc_request_iomux(MX51_PIN_KEY_COL0, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_COL1, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_COL2, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_COL3, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_COL4, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_COL5, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
-
-	return 0;
-}
-#endif
-
-int board_init(void)
-{
-	setup_soc_rev();
-
-	gd->bd->bi_arch_number = MACH_TYPE_MX51_BABBAGE;	/* board id for linux */
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
-
-	setup_uart();
-	setup_nfc();
-	setup_expio();
-	return 0;
-}
-
-#ifdef BOARD_LATE_INIT
-int board_late_init(void)
-{
-#if defined(CONFIG_FSL_ANDROID) && defined(CONFIG_MXC_KPD)
-	struct kpp_key_info key_info = {0, 0};
-	int switch_delay = CONFIG_ANDROID_BOOTMOD_DELAY;
-	int state = 0, boot_mode_switch = 0;
-#endif
-
-	power_init();
-
-#if defined(CONFIG_FSL_ANDROID) && defined(CONFIG_MXC_KPD)
-	mxc_kpp_init();
-
-	puts("Press home + power to enter recovery mode ...\n");
-
-	while ((switch_delay > 0) && (!boot_mode_switch)) {
-		int i;
-
-		--switch_delay;
-		/* delay 100 * 10ms */
-		for (i = 0; !boot_mode_switch && i < 100; ++i) {
-			/* A state machine to scan home + power key */
-			/* Check for home + power */
-			if (mxc_kpp_getc(&key_info)) {
-				switch (state) {
-				case 0:
-					/* First press */
-					if (TEST_HOME_KEY_DEPRESS(key_info.val, key_info.evt)) {
-						/* Press Home */
-						state = 1;
-					} else if (TEST_POWER_KEY_DEPRESS(key_info.val, key_info.evt)) {
-						state = 2;
-					} else {
-						state = 0;
-					}
-					break;
-				case 1:
-					/* Home is already pressed, try to detect Power */
-					if (TEST_POWER_KEY_DEPRESS(key_info.val,
-						    key_info.evt)) {
-						boot_mode_switch = 1;
-					} else {
-					    if (TEST_HOME_KEY_DEPRESS(key_info.val,
-							key_info.evt))
-						state = 1;
-					    else
-						state = 0;
-					}
-					break;
-				case 2:
-					/* Power is already pressed, try to detect Home */
-					if (TEST_HOME_KEY_DEPRESS(key_info.val,
-						    key_info.evt)) {
-						boot_mode_switch = 1;
-					} else {
-						if (TEST_POWER_KEY_DEPRESS(key_info.val,
-							    key_info.evt))
-							state = 2;
-						else
-							state = 0;
-					}
-					break;
-				default:
-					break;
-				}
-
-				if (1 == boot_mode_switch) {
-					printf("Boot mode switched to recovery mode!\n");
-					/* Set env to recovery mode */
-					setenv("bootargs_android", CONFIG_ANDROID_RECOVERY_BOOTARGS);
-					setenv("bootcmd_android", CONFIG_ANDROID_RECOVERY_BOOTCMD);
-					setenv("bootcmd", "run bootcmd_android");
-					break;
-				}
-			}
-		}
-		for (i = 0; i < 100; ++i)
-			udelay(10000);
-	}
-#endif
-
-	return 0;
-}
-#endif
-
-int checkboard(void)
-{
-	printf("Board: MX51 BABBAGE ");
-
-	if (system_rev & CHIP_REV_2_5) {
-		printf("2.5 [");
-	} else if (system_rev & CHIP_REV_2_0) {
-		printf("2.0 [");
-	} else if (system_rev & CHIP_REV_1_1) {
-		printf("1.1 [");
-	} else {
-		printf("1.0 [");
-	}
-
-	switch (__REG(SRC_BASE_ADDR + 0x8)) {
-	case 0x0001:
-		printf("POR");
-		break;
-	case 0x0009:
-		printf("RST");
-		break;
-	case 0x0010:
-	case 0x0011:
-		printf("WDOG");
-		break;
-	default:
-		printf("unknown");
-	}
-	printf("]\n");
-	return 0;
-}
-
diff --git a/board/freescale/imx51/lowlevel_init.S b/board/freescale/imx51/lowlevel_init.S
deleted file mode 100644
index e974a5f..0000000
--- a/board/freescale/imx51/lowlevel_init.S
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <asm/arch/mx51.h>
-#include "board-imx51.h"
-
-/*
- * return soc version
- * 	0x10:  TO1
- *	0x20:  TO2
- *	0x30:  TO3
- */
-.macro check_soc_version ret, tmp
-.endm
-
-/*
- * L2CC Cache setup/invalidation/disable
- */
-.macro init_l2cc
-	/* reconfigure L2 cache aux control reg */
-	ldr r0, =0x03C000C4
-	mcr p15, 1, r0, c9, c0, 2
-.endm /* init_l2cc */
-
-/* AIPS setup - Only setup MPROTx registers.
- * The PACR default values are good.*/
-.macro init_aips
-	/*
-	 * Set all MPROTx to be non-bufferable, trusted for R/W,
-	 * not forced to user-mode.
-	 */
-	ldr r0, =AIPS1_BASE_ADDR
-	ldr r1, =0x77777777
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	ldr r0, =AIPS2_BASE_ADDR
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	/*
-	 * Clear the on and off peripheral modules Supervisor Protect bit
-	 * for SDMA to access them. Did not change the AIPS control registers
-	 * (offset 0x20) access type
-	 */
-.endm /* init_aips */
-
-/* MAX (Multi-Layer AHB Crossbar Switch) setup */
-.macro init_max
-.endm /* init_max */
-
-/* M4IF setup */
-.macro init_m4if
-	/* VPU and IPU given higher priority (0x4)
-	 * IPU accesses with ID=0x1 given highest priority (=0xA)
-	 */
-	ldr r0, =M4IF_BASE_ADDR
-
-	ldr r1, =0x00000203
-	str r1, [r0, #0x40]
-
-	ldr r1, =0x0
-	str r1, [r0, #0x44]
-
-	ldr r1, =0x00120125
-	str r1, [r0, #0x9C]
-
-	ldr r1, =0x001901A3
-	str r1, [r0, #0x48]
-
-/*
-	ldr r1, =0x00000a01
-	str r1, [r0, #0x48]
-	ldr r1, =0x00000404
-	str r1, [r0, #0x40]
-*/
-.endm /* init_m4if */
-
-/* To support 133MHz DDR */
-.macro  init_drive_strength
-.endm /* init_drive_strength */
-
-/* CPLD on CS5 setup */
-.macro init_debug_board
-.endm /* init_debug_board */
-
-.macro setup_pll pll, freq
-	ldr r2, =\pll
-	ldr r1, =0x00001232
-	str r1, [r2, #PLL_DP_CTL] /* Set DPLL ON (set UPEN bit): BRMO=1 */
-	mov r1, #0x2
-	str r1, [r2, #PLL_DP_CONFIG] /* Enable auto-restart AREN bit */
-
-	str r3, [r2, #PLL_DP_OP]
-	str r3, [r2, #PLL_DP_HFS_OP]
-
-	str r4, [r2, #PLL_DP_MFD]
-	str r4, [r2, #PLL_DP_HFS_MFD]
-
-	str r5, [r2, #PLL_DP_MFN]
-	str r5, [r2, #PLL_DP_HFS_MFN]
-
-	ldr r1, =0x00001232
-	str r1, [r2, #PLL_DP_CTL]
-1:	ldr r1, [r2, #PLL_DP_CTL]
-	ands r1, r1, #0x1
-	beq 1b
-.endm
-
-.macro init_clock
-	ldr r0, =CCM_BASE_ADDR
-	mov r1, #0x00060000
-	str r1, [r0, #CLKCTL_CCDR]
-
-	/* Switch ARM to step clock */
-	mov r1, #0x4
-	str r1, [r0, #CLKCTL_CCSR]
-
-	mov r3, #DP_OP_800
-	mov r4, #DP_MFD_800
-	mov r5, #DP_MFN_800
-	setup_pll PLL1_BASE_ADDR
-	mov r3, #DP_OP_665
-	mov r4, #DP_MFD_665
-	mov r5, #DP_MFN_665
-	setup_pll PLL3_BASE_ADDR
-
-	/* Switch peripheral to PLL 3 */
-	ldr r1, =0x0000D3C0
-	str r1, [r0, #CLKCTL_CBCMR]
-	ldr r1, =0x033B9145
-	str r1, [r0, #CLKCTL_CBCDR]
-	mov r3, #DP_OP_665
-	mov r4, #DP_MFD_665
-	mov r5, #DP_MFN_665
-	setup_pll PLL2_BASE_ADDR
-
-	/* Switch peripheral to PLL2 */
-	ldr r1, =0x013B9145
-	str r1, [r0, #CLKCTL_CBCDR]
-	ldr r1, =0x0000E3C0
-	str r1, [r0, #CLKCTL_CBCMR]
-
-	mov r3, #DP_OP_216
-	mov r4, #DP_MFD_216
-	mov r5, #DP_MFN_216
-	setup_pll PLL3_BASE_ADDR
-
-	/* Set the platform clock dividers */
-	ldr r2, =ARM_BASE_ADDR
-	ldr r1, =0x00000725
-	str r1, [r2, #0x14]
-
-	/* Switch ARM back to PLL 1 */
-	mov r1, #0
-	str r1, [r0,  #CLKCTL_CCSR]
-	str r1, [r0,  #CLKCTL_CACRR]
-
-	/* Use lp_apm (24MHz) source for perclk */
-	mov r2, #0x48
-	ldr r2, [r0]
-	cmp r2, #0x10
-	ldrhs r1, =0x000020C2
-	ldrlo r1, =0x0000E3C2
-	str r1, [r0, #CLKCTL_CBCMR]
-	/* TO1.x emi = ahb, all perclk dividers are 1 since using 24MHz */
-	/* TO2.x ddr from PLL1, all perclk dividers are 1 since using 24MHz */
-	ldrhs r1, =0x59239100
-	ldrlo r1, =0x013D9100
-	strlo r1, [r0, #CLKCTL_CBCDR]
-
-	/* use PLL2 for UART source, get 66.5MHz */
-	ldr r1, =0xA5A2A020
-	str r1, [r0, #CLKCTL_CSCMR1]
-	ldr r1, =0x00C30321
-	str r1, [r0, #CLKCTL_CSCDR1]
-
-	/* make sure divider effective */
-1:	ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0
-	bne 1b
-
-	mov r1, #0x0
-	str r1, [r0, #CLKCTL_CCDR]
-.endm
-
-.macro setup_wdog
-	ldr r0, =WDOG1_BASE_ADDR
-	mov r1, #0x30
-	strh r1, [r0]
-.endm
-
-.section ".text.init", "x"
-
-.globl lowlevel_init
-lowlevel_init:
-	/* Platform CHIP level init*/
-	ldr r0, =GPIO1_BASE_ADDR
-    ldr r1, [r0, #0x0]
-    orr r1, r1, #(1 << 23)
-    str r1, [r0, #0x0]
-    ldr r1, [r0, #0x4]
-    orr r1, r1, #(1 << 23)
-    str r1, [r0, #0x4]
-
-#ifdef TURN_OFF_IMPRECISE_ABORT
-	mrs r0, cpsr
-	bic r0, r0, #0x100
-	msr cpsr, r0
-#endif
-
-	mrc 15, 0, r1, c1, c0, 0
-
-#ifndef BRANCH_PREDICTION_ENABLE
-    	mrc 15, 0, r0, c1, c0, 1
-    	bic r0, r0, #7
-    	mcr 15, 0, r0, c1, c0, 1
-#else
-    	mrc 15, 0, r0, c1, c0, 1
-    	orr r0, r0, #7
-    	mcr 15, 0, r0, c1, c0, 1
-    	orr r1, r1, #(1<<11)
-#endif
-
-#ifdef UNALIGNED_ACCESS_ENABLE
-    	orr r1, r1, #(1<<22)
-#endif
-
-#ifdef LOW_INT_LATENCY_ENABLE
-    	orr r1, r1, #(1<<21)
-#endif
-    	mcr 15, 0, r1, c1, c0, 0
-
-    	mov r0, #0
-#ifdef BRANCH_PREDICTION_ENABLE
-   	mcr 15, 0, r0, c15, c2, 4
-#endif
-	mcr 15, 0, r0, c7, c10, 4       /* Drain the write buffer */
-
-	init_l2cc
-
-	init_aips
-
-	init_max
-
-	init_m4if
-
-	init_drive_strength
-
-	cmp pc, #PHYS_SDRAM_1
-	blo init_clock_start
-	cmp pc, #(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
-	blo init_clock_start
-
-init_clock_start:
-	init_clock
-	init_debug_board
-	/*init_sdram*/
-
-	/* return from mxc_nand_load */
-	/* r12 saved upper lr*/
-	b mxc_nand_load
-
-/* Board level setting value */
-DDR_PERCHARGE_CMD:	.word 0x04008008
-DDR_REFRESH_CMD:	.word 0x00008010
-DDR_LMR1_W:		.word 0x00338018
-DDR_LMR_CMD:		.word 0xB2220000
-DDR_TIMING_W:		.word 0xB02567A9
-DDR_MISC_W:		.word 0x000A0104
diff --git a/board/freescale/imx51/u-boot.lds b/board/freescale/imx51/u-boot.lds
deleted file mode 100644
index 15d50ab..0000000
--- a/board/freescale/imx51/u-boot.lds
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * January 2004 - Changed to support H4 device
- * Copyright (c) 2004 Texas Instruments
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text	   :
-	{
-	  /* WARNING - the following is hand-optimized to fit within	*/
-	  /* the sector layout of our flash chips!	XXX FIXME XXX	*/
-	  board/freescale/imx51/flash_header.o	(.text.flasheader)
-	  cpu/arm_cortexa8/start.o
-	  board/freescale/imx51/libimx51.a	(.text)
-	  lib_arm/libarm.a		(.text)
-	  net/libnet.a			(.text)
-	  drivers/mtd/libmtd.a		(.text)
-	  drivers/mmc/libmmc.a		(.text)
-
-	  . = DEFINED(env_offset) ? env_offset : .;
-	  common/env_embedded.o(.text)
-
-	  *(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(.rodata) }
-
-	. = ALIGN(4);
-	.data : { *(.data) }
-
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss : { *(.bss) }
-	_end = .;
-}
diff --git a/board/freescale/mx25_3stack/config.mk b/board/freescale/mx25_3stack/config.mk
index 4c401e7..083613a 100644
--- a/board/freescale/mx25_3stack/config.mk
+++ b/board/freescale/mx25_3stack/config.mk
@@ -1 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
 TEXT_BASE = 0x83F00000
diff --git a/board/freescale/mx25_3stack/mx25_3stack.c b/board/freescale/mx25_3stack/mx25_3stack.c
index b33eaa1..f79b1b9 100644
--- a/board/freescale/mx25_3stack/mx25_3stack.c
+++ b/board/freescale/mx25_3stack/mx25_3stack.c
@@ -35,7 +35,6 @@
 DECLARE_GLOBAL_DATA_PTR;
 
 static u32 system_rev;
-volatile u32 *esdhc_base_pointer;
 
 u32 get_board_rev(void)
 {
@@ -67,9 +66,11 @@ int dram_init(void)
 	return 0;
 }
 
-#ifdef CONFIG_FSL_MMC
+#ifdef CONFIG_CMD_MMC
 
-int sdhc_init(void)
+u32 *imx_esdhc_base_addr;
+
+int esdhc_gpio_init(void)
 {
 	u32 interface_esdhc = 0, val = 0;
 
@@ -77,7 +78,7 @@ int sdhc_init(void)
 
 	switch (interface_esdhc) {
 	case 0:
-		esdhc_base_pointer = (volatile u32 *)MMC_SDHC1_BASE;
+		imx_esdhc_base_addr = (u32 *)MMC_SDHC1_BASE;
 		/* Pins */
 		writel(0x10, IOMUXC_BASE + 0x190);	/* SD1_CMD */
 		writel(0x10, IOMUXC_BASE + 0x194);	/* SD1_CLK */
@@ -114,7 +115,7 @@ int sdhc_init(void)
 		writel(val, GPIO1_BASE + GPIO_GDIR);
 		break;
 	case 1:
-		esdhc_base_pointer = (volatile u32 *)MMC_SDHC2_BASE;
+		imx_esdhc_base_addr = (u32 *)MMC_SDHC2_BASE;
 		/* Pins */
 		writel(0x16, IOMUXC_BASE + 0x0e8);	/* LD8 (SD1_CMD) */
 		writel(0x16, IOMUXC_BASE + 0x0ec);	/* LD9 (SD1_CLK) */
@@ -144,6 +145,14 @@ int sdhc_init(void)
 	}
 	return 0;
 }
+
+int board_mmc_init(void)
+{
+	if (!esdhc_gpio_init())
+		return fsl_esdhc_mmc_init(gd->bd);
+	else
+		return -1;
+}
 #endif
 
 int board_init(void)
@@ -264,8 +273,8 @@ int checkboard(void)
 int board_eth_init(bd_t *bis)
 {
 	int rc = -ENODEV;
-#if defined(CONFIG_DRIVER_SMC911X)
-	rc = smc911x_initialize(bis);
+#if defined(CONFIG_SMC911X)
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
 #endif
 	return rc;
 }
diff --git a/board/freescale/mx31_3stack/config.mk b/board/freescale/mx31_3stack/config.mk
index d34dc02..f8fc7dd 100644
--- a/board/freescale/mx31_3stack/config.mk
+++ b/board/freescale/mx31_3stack/config.mk
@@ -1 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
 TEXT_BASE = 0x87f00000
diff --git a/board/freescale/mx35_3stack/config.mk b/board/freescale/mx35_3stack/config.mk
index 70b4271..848787d 100644
--- a/board/freescale/mx35_3stack/config.mk
+++ b/board/freescale/mx35_3stack/config.mk
@@ -1 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
 TEXT_BASE = 0x87800000
diff --git a/board/freescale/mx35_3stack/mx35_3stack.c b/board/freescale/mx35_3stack/mx35_3stack.c
index f7fb96a..cbd0756 100644
--- a/board/freescale/mx35_3stack/mx35_3stack.c
+++ b/board/freescale/mx35_3stack/mx35_3stack.c
@@ -31,11 +31,7 @@
 #include <i2c.h>
 #include <linux/types.h>
 
-#ifdef CONFIG_MMC
-#include <asm/arch/sdhc.h>
-#endif
 DECLARE_GLOBAL_DATA_PTR;
-volatile u32 *esdhc_base_pointer;
 
 static u32 system_rev;
 
@@ -58,7 +54,6 @@ static inline void setup_soc_rev(void)
 
 static inline void set_board_rev(int rev)
 {
-	int reg;
 	system_rev =  (system_rev & ~(0xF << 8)) | (rev & 0xF) << 8;
 }
 
@@ -276,129 +271,101 @@ int checkboard(void)
 	return 0;
 }
 
+#if defined(CONFIG_SMC911X)
+extern int smc911x_initialize(u8 dev_num, int base_addr);
+#endif
+
 int board_eth_init(bd_t *bis)
 {
 	int rc = -ENODEV;
-#if defined(CONFIG_DRIVER_SMC911X)
-	rc = smc911x_initialize(bis);
+#if defined(CONFIG_SMC911X)
+	rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
 #endif
 	return rc;
 }
 
-#ifdef CONFIG_FSL_MMC
+#ifdef CONFIG_CMD_MMC
 
-int sdhc_init(void)
+u32 *imx_esdhc_base_addr;
+
+int esdhc_gpio_init(void)
 {
 	u32 interface_esdhc = 0;
 	u32 pad_val = 0;
 
 	interface_esdhc = (readl(IIM_BASE_ADDR + 0x80c)) & (0x000000C0) >> 6;
 
-	if (!is_soc_rev(CHIP_REV_1_0)) {
-		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
-			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
-			PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
+	/* IOMUX PROGRAMMING */
+	switch (interface_esdhc) {
+	case 0:
+		imx_esdhc_base_addr = \
+				(u32 *)MMC_SDHC1_BASE_ADDR;
 
-		switch (interface_esdhc) {
-		case 0:
-			debug("TO1 ESDHC1\n");
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+				PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_HIGH |
+				PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
+		mxc_request_iomux(MX35_PIN_SD1_CLK,
+				MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX35_PIN_SD1_CLK, pad_val);
 
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC1_BASE_ADDR;
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_HIGH |
+			PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
+		mxc_request_iomux(MX35_PIN_SD1_CMD,
+			MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX35_PIN_SD1_CMD, pad_val);
+		mxc_request_iomux(MX35_PIN_SD1_DATA0,
+			  MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA0, pad_val);
+		mxc_request_iomux(MX35_PIN_SD1_DATA3,
+			  MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX35_PIN_SD1_DATA3, pad_val);
 
-			mxc_iomux_set_pad(MX35_PIN_SD1_DATA3, pad_val);
-			break;
-		case 1:
-			debug("TO1 ESDHC2\n");
+		break;
+	case 1:
+		imx_esdhc_base_addr = \
+				(u32 *)MMC_SDHC2_BASE_ADDR;
+
+		mxc_request_iomux(MX35_PIN_SD2_CLK,
+			  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_CMD,
+			  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX35_PIN_SD2_DATA0,
+			  MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX35_PIN_SD2_DATA3,
+			  MUX_CONFIG_FUNC);
 
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC2_BASE_ADDR;
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
+			PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
+		mxc_iomux_set_pad(MX35_PIN_SD2_CLK, pad_val);
 
-			mxc_iomux_set_pad(MX35_PIN_SD2_DATA3, pad_val);
-			break;
-		case 2:
-			debug("TO1 ESDHC3\n");
+		pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
+			PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
+			PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
+		mxc_iomux_set_pad(MX35_PIN_SD2_CMD, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA0, pad_val);
+		mxc_iomux_set_pad(MX35_PIN_SD2_DATA3, pad_val);
 
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC3_BASE_ADDR;
+		break;
+	case 2:
+		imx_esdhc_base_addr = \
+				(u32 *)MMC_SDHC3_BASE_ADDR;
 
-			printf("TO1 ESDHC3 not supported!");
-			break;
-		default:
-			break;
-		}
-	} else if (!is_soc_rev(CHIP_REV_2_0)) {
-			/* IOMUX PROGRAMMING */
-		switch (interface_esdhc) {
-		case 0:
-			debug("TO2 ESDHC1\n");
-
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC1_BASE_ADDR;
-
-			pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
-					PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_HIGH |
-					PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
-			mxc_request_iomux(MX35_PIN_SD1_CLK,
-					MUX_CONFIG_FUNC | MUX_CONFIG_SION);
-			mxc_iomux_set_pad(MX35_PIN_SD1_CLK, pad_val);
-
-			pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
-				PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_HIGH |
-				PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
-			mxc_request_iomux(MX35_PIN_SD1_CMD,
-				MUX_CONFIG_FUNC | MUX_CONFIG_SION);
-			mxc_iomux_set_pad(MX35_PIN_SD1_CMD, pad_val);
-			mxc_request_iomux(MX35_PIN_SD1_DATA0,
-				  MUX_CONFIG_FUNC);
-			mxc_iomux_set_pad(MX35_PIN_SD1_DATA0, pad_val);
-			mxc_request_iomux(MX35_PIN_SD1_DATA3,
-				  MUX_CONFIG_FUNC);
-			mxc_iomux_set_pad(MX35_PIN_SD1_DATA3, pad_val);
-
-			break;
-		case 1:
-			debug("TO2 ESDHC2\n");
-
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC2_BASE_ADDR;
-
-			mxc_request_iomux(MX35_PIN_SD2_CLK,
-				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
-			mxc_request_iomux(MX35_PIN_SD2_CMD,
-				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
-			mxc_request_iomux(MX35_PIN_SD2_DATA0,
-				  MUX_CONFIG_FUNC);
-			mxc_request_iomux(MX35_PIN_SD2_DATA3,
-				  MUX_CONFIG_FUNC);
-
-			pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
-				PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
-				PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
-			mxc_iomux_set_pad(MX35_PIN_SD2_CLK, pad_val);
-
-			pad_val = PAD_CTL_PUE_PUD | PAD_CTL_PKE_ENABLE |
-				PAD_CTL_HYS_SCHMITZ | PAD_CTL_DRV_MAX |
-				PAD_CTL_100K_PU | PAD_CTL_SRE_FAST;
-			mxc_iomux_set_pad(MX35_PIN_SD2_CMD, pad_val);
-			mxc_iomux_set_pad(MX35_PIN_SD2_DATA0, pad_val);
-			mxc_iomux_set_pad(MX35_PIN_SD2_DATA3, pad_val);
-
-			break;
-		case 2:
-			debug("TO2 ESDHC3\n");
-
-			esdhc_base_pointer = \
-				(volatile u32 *)MMC_SDHC3_BASE_ADDR;
-
-			printf("TO2 ESDHC3 not supported!");
-			break;
-		default:
-			break;
-		}
+		printf("TO2 ESDHC3 not supported!");
+		break;
+	default:
+		break;
 	}
 
 	return 0;
 }
 
+int board_mmc_init(void)
+{
+	if (!esdhc_gpio_init())
+		return fsl_esdhc_mmc_init(gd->bd);
+	else
+		return -1;
+}
 #endif
diff --git a/board/freescale/mx51_3stack/config.mk b/board/freescale/mx51_3stack/config.mk
index ce7369d..705aa34 100644
--- a/board/freescale/mx51_3stack/config.mk
+++ b/board/freescale/mx51_3stack/config.mk
@@ -1 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
 TEXT_BASE = 0x97800000
diff --git a/board/freescale/mx51_3stack/mx51_3stack.c b/board/freescale/mx51_3stack/mx51_3stack.c
index 4ee342e..50aec8c 100644
--- a/board/freescale/mx51_3stack/mx51_3stack.c
+++ b/board/freescale/mx51_3stack/mx51_3stack.c
@@ -32,12 +32,12 @@
 #include <mxc_keyb.h>
 #include <asm/arch/keypad.h>
 #include "board-mx51_3stack.h"
+#include <netdev.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
 static u32 system_rev;
 u32	mx51_io_base_addr;
-volatile u32 *esdhc_base_pointer;
 
 u32 get_board_rev(void)
 {
@@ -349,20 +349,26 @@ int checkboard(void)
 	return 0;
 }
 
+#if defined(CONFIG_SMC911X)
+extern int smc911x_initialize(u8 dev_num, int base_addr);
+#endif
+
 #ifdef CONFIG_NET_MULTI
 int board_eth_init(bd_t *bis)
 {
 	int rc = -ENODEV;
-#if defined(CONFIG_DRIVER_SMC911X)
-	 rc = smc911x_initialize(bis);
+#if defined(CONFIG_SMC911X)
+	 rc = smc911x_initialize(0, CONFIG_SMC911X_BASE);
 #endif
 	return rc;
 }
 #endif
 
-#ifdef CONFIG_FSL_MMC
+#ifdef CONFIG_CMD_MMC
+
+u32 *imx_esdhc_base_addr;
 
-int sdhc_init(void)
+int esdhc_gpio_init(void)
 {
 	u32 interface_esdhc = 0;
 	s32 status = 0;
@@ -372,7 +378,7 @@ int sdhc_init(void)
 	switch (interface_esdhc) {
 	case 0:
 
-		esdhc_base_pointer = (volatile u32 *)MMC_SDHC1_BASE_ADDR;
+		imx_esdhc_base_addr = (u32 *)MMC_SDHC1_BASE_ADDR;
 
 		mxc_request_iomux(MX51_PIN_SD1_CMD,
 			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
@@ -432,9 +438,16 @@ int sdhc_init(void)
 		break;
 	}
 
-	return status = 1;
+	return status;
 }
 
+int board_mmc_init(void)
+{
+	if (!esdhc_gpio_init())
+		return fsl_esdhc_mmc_init(gd->bd);
+	else
+		return -1;
+}
 #endif
 
 #if defined(CONFIG_MXC_KPD)
diff --git a/board/freescale/mx51_bbg/Makefile b/board/freescale/mx51_bbg/Makefile
new file mode 100644
index 0000000..109ca7b
--- /dev/null
+++ b/board/freescale/mx51_bbg/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2009 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= mx51_bbg.o
+SOBJS	:= lowlevel_init.o flash_header.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/mx51_bbg/board-imx51.h b/board/freescale/mx51_bbg/board-imx51.h
new file mode 100644
index 0000000..7a2cae0
--- /dev/null
+++ b/board/freescale/mx51_bbg/board-imx51.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __BOARD_FREESCALE_BOARD_IMX51_H__
+#define __BOARD_FREESCALE_BOARD_IMX51_H__
+
+/*!
+ * @defgroup BRDCFG_MX51 Board Configuration Options
+ * @ingroup MSL_MX51
+ */
+
+/*!
+ * @file mx51_3stack/board-imx51.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX51 3Stack Platform.
+ *
+ * @ingroup BRDCFG_IMX51
+ */
+
+/* CPLD offsets */
+#define PBC_LED_CTRL		(0x20000)
+#define PBC_SB_STAT		(0x20008)
+#define PBC_ID_AAAA		(0x20040)
+#define PBC_ID_5555		(0x20048)
+#define PBC_VERSION		(0x20050)
+#define PBC_ID_CAFE		(0x20058)
+#define PBC_INT_STAT		(0x20010)
+#define PBC_INT_MASK		(0x20038)
+#define PBC_INT_REST		(0x20020)
+#define PBC_SW_RESET		(0x20060)
+
+/* LED switchs */
+#define LED_SWITCH_REG		0x00
+/* buttons */
+#define SWITCH_BUTTONS_REG	0x08
+/* status, interrupt */
+#define INTR_STATUS_REG	0x10
+#define INTR_MASK_REG		0x38
+#define INTR_RESET_REG		0x20
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	0x40
+#define MAGIC_NUMBER2_REG	0x48
+/* CPLD code version */
+#define CPLD_CODE_VER_REG	0x50
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER3_REG	0x58
+/* module reset register*/
+#define MODULE_RESET_REG	0x60
+/* CPU ID and Personality ID */
+#define MCU_BOARD_ID_REG	0x68
+
+#endif				/* __BOARD_FREESCALE_BOARD_IMX51_H__ */
diff --git a/board/freescale/mx51_bbg/config.mk b/board/freescale/mx51_bbg/config.mk
new file mode 100644
index 0000000..705aa34
--- /dev/null
+++ b/board/freescale/mx51_bbg/config.mk
@@ -0,0 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
+TEXT_BASE = 0x97800000
diff --git a/board/freescale/mx51_bbg/flash_header.S b/board/freescale/mx51_bbg/flash_header.S
new file mode 100644
index 0000000..6790679
--- /dev/null
+++ b/board/freescale/mx51_bbg/flash_header.S
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx51.h>
+#include "board-imx51.h"
+
+#ifdef	CONFIG_FLASH_HEADER
+#ifndef CONFIG_FLASH_HEADER_OFFSET
+# error "Must define the offset of flash header"
+#endif
+#define MXC_DCD_ITEM(i, type, addr, val)	\
+dcd_node_##i:					\
+	.word type			;	\
+	.word addr			;	\
+	.word val			;	\
+
+.section ".text.flasheader", "x"
+	b	_start
+	.org	CONFIG_FLASH_HEADER_OFFSET
+app_code_jump_v:	.word	_start
+app_code_code_barker:	.word	CONFIG_FLASH_HEADER_BARKER
+app_code_csf:		.word	0
+dcd_ptr_ptr:		.word	dcd_ptr
+super_root_key:		.word	0
+dcd_ptr:		.word	dcd_array_start
+app_dest_ptr:		.word	TEXT_BASE
+dcd_array_start:
+magic:			.word	0xB17219E9
+dcd_array_size:		.word	dcd_data_end - dcd_array_start - 8
+/* DCD */
+/* DDR2 IOMUX configuration */
+MXC_DCD_ITEM(1, 4, IOMUXC_BASE_ADDR + 0x8a0, 0x200)
+MXC_DCD_ITEM(2, 4, IOMUXC_BASE_ADDR + 0x50c, 0x20c5)
+MXC_DCD_ITEM(3, 4, IOMUXC_BASE_ADDR + 0x510, 0x20c5)
+MXC_DCD_ITEM(4, 4, IOMUXC_BASE_ADDR + 0x83c, 0x2)
+MXC_DCD_ITEM(5, 4, IOMUXC_BASE_ADDR + 0x848, 0x2)
+MXC_DCD_ITEM(6, 4, IOMUXC_BASE_ADDR + 0x4b8, 0xe7)
+MXC_DCD_ITEM(7, 4, IOMUXC_BASE_ADDR + 0x4bc, 0x45)
+MXC_DCD_ITEM(8, 4, IOMUXC_BASE_ADDR + 0x4c0, 0x45)
+MXC_DCD_ITEM(9, 4, IOMUXC_BASE_ADDR + 0x4c4, 0x45)
+MXC_DCD_ITEM(10, 4, IOMUXC_BASE_ADDR + 0x4c8, 0x45)
+MXC_DCD_ITEM(11, 4, IOMUXC_BASE_ADDR + 0x820, 0x0)
+MXC_DCD_ITEM(12, 4, IOMUXC_BASE_ADDR + 0x4a4, 0x3)
+MXC_DCD_ITEM(13, 4, IOMUXC_BASE_ADDR + 0x4a8, 0x3)
+MXC_DCD_ITEM(14, 4, IOMUXC_BASE_ADDR + 0x4ac, 0xe3)
+MXC_DCD_ITEM(15, 4, IOMUXC_BASE_ADDR + 0x4b0, 0xe3)
+MXC_DCD_ITEM(16, 4, IOMUXC_BASE_ADDR + 0x4b4, 0xe3)
+MXC_DCD_ITEM(17, 4, IOMUXC_BASE_ADDR + 0x4cc, 0xe3)
+MXC_DCD_ITEM(18, 4, IOMUXC_BASE_ADDR + 0x4d0, 0xe2)
+/* Set drive strength to MAX */
+MXC_DCD_ITEM(19, 4, IOMUXC_BASE_ADDR + 0x82c, 0x6)
+MXC_DCD_ITEM(20, 4, IOMUXC_BASE_ADDR + 0x8a4, 0x6)
+MXC_DCD_ITEM(21, 4, IOMUXC_BASE_ADDR + 0x8ac, 0x6)
+MXC_DCD_ITEM(22, 4, IOMUXC_BASE_ADDR + 0x8b8, 0x6)
+/* 13 ROW, 10 COL, 32Bit, SREF=4 Micron Model */
+/* CAS=3,  BL=4 */
+MXC_DCD_ITEM(23, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL0, 0x82a20000)
+MXC_DCD_ITEM(24, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL1, 0x82a20000)
+MXC_DCD_ITEM(25, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDMISC, 0x000ad0d0)
+MXC_DCD_ITEM(26, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCFG0, 0x333574aa)
+MXC_DCD_ITEM(27, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCFG1, 0x333574aa)
+/* Init DRAM on CS0 */
+MXC_DCD_ITEM(28, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x04008008)
+MXC_DCD_ITEM(29, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801a)
+MXC_DCD_ITEM(30, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801b)
+MXC_DCD_ITEM(31, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00448019)
+MXC_DCD_ITEM(32, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x07328018)
+MXC_DCD_ITEM(33, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x04008008)
+MXC_DCD_ITEM(34, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008010)
+MXC_DCD_ITEM(35, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008010)
+MXC_DCD_ITEM(36, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x06328018)
+MXC_DCD_ITEM(37, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x03808019)
+MXC_DCD_ITEM(38, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00408019)
+MXC_DCD_ITEM(39, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008000)
+/* Init DRAM on CS1 */
+MXC_DCD_ITEM(40, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0400800c)
+MXC_DCD_ITEM(41, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801e)
+MXC_DCD_ITEM(42, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801f)
+MXC_DCD_ITEM(43, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0000801d)
+MXC_DCD_ITEM(44, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0732801c)
+MXC_DCD_ITEM(45, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0400800c)
+MXC_DCD_ITEM(46, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008014)
+MXC_DCD_ITEM(47, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008014)
+MXC_DCD_ITEM(48, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0632801c)
+MXC_DCD_ITEM(49, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0380801d)
+MXC_DCD_ITEM(50, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x0040801d)
+MXC_DCD_ITEM(51, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00008004)
+MXC_DCD_ITEM(52, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL0, 0xb2a20000)
+MXC_DCD_ITEM(53, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCTL1, 0xb2a20000)
+MXC_DCD_ITEM(54, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDMISC, 0x000ad6d0)
+MXC_DCD_ITEM(55, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDCDLYGD, 0x90000000)
+MXC_DCD_ITEM(56, 4, ESDCTL_BASE_ADDR + ESDCTL_ESDSCR, 0x00000000)
+dcd_data_end:
+image_len:		.word	0x100000
+//image_len:		.word	_end - _start
+#endif
diff --git a/board/freescale/mx51_bbg/lowlevel_init.S b/board/freescale/mx51_bbg/lowlevel_init.S
new file mode 100644
index 0000000..e974a5f
--- /dev/null
+++ b/board/freescale/mx51_bbg/lowlevel_init.S
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx51.h>
+#include "board-imx51.h"
+
+/*
+ * return soc version
+ * 	0x10:  TO1
+ *	0x20:  TO2
+ *	0x30:  TO3
+ */
+.macro check_soc_version ret, tmp
+.endm
+
+/*
+ * L2CC Cache setup/invalidation/disable
+ */
+.macro init_l2cc
+	/* reconfigure L2 cache aux control reg */
+	ldr r0, =0x03C000C4
+	mcr p15, 1, r0, c9, c0, 2
+.endm /* init_l2cc */
+
+/* AIPS setup - Only setup MPROTx registers.
+ * The PACR default values are good.*/
+.macro init_aips
+	/*
+	 * Set all MPROTx to be non-bufferable, trusted for R/W,
+	 * not forced to user-mode.
+	 */
+	ldr r0, =AIPS1_BASE_ADDR
+	ldr r1, =0x77777777
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+	ldr r0, =AIPS2_BASE_ADDR
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+	/*
+	 * Clear the on and off peripheral modules Supervisor Protect bit
+	 * for SDMA to access them. Did not change the AIPS control registers
+	 * (offset 0x20) access type
+	 */
+.endm /* init_aips */
+
+/* MAX (Multi-Layer AHB Crossbar Switch) setup */
+.macro init_max
+.endm /* init_max */
+
+/* M4IF setup */
+.macro init_m4if
+	/* VPU and IPU given higher priority (0x4)
+	 * IPU accesses with ID=0x1 given highest priority (=0xA)
+	 */
+	ldr r0, =M4IF_BASE_ADDR
+
+	ldr r1, =0x00000203
+	str r1, [r0, #0x40]
+
+	ldr r1, =0x0
+	str r1, [r0, #0x44]
+
+	ldr r1, =0x00120125
+	str r1, [r0, #0x9C]
+
+	ldr r1, =0x001901A3
+	str r1, [r0, #0x48]
+
+/*
+	ldr r1, =0x00000a01
+	str r1, [r0, #0x48]
+	ldr r1, =0x00000404
+	str r1, [r0, #0x40]
+*/
+.endm /* init_m4if */
+
+/* To support 133MHz DDR */
+.macro  init_drive_strength
+.endm /* init_drive_strength */
+
+/* CPLD on CS5 setup */
+.macro init_debug_board
+.endm /* init_debug_board */
+
+.macro setup_pll pll, freq
+	ldr r2, =\pll
+	ldr r1, =0x00001232
+	str r1, [r2, #PLL_DP_CTL] /* Set DPLL ON (set UPEN bit): BRMO=1 */
+	mov r1, #0x2
+	str r1, [r2, #PLL_DP_CONFIG] /* Enable auto-restart AREN bit */
+
+	str r3, [r2, #PLL_DP_OP]
+	str r3, [r2, #PLL_DP_HFS_OP]
+
+	str r4, [r2, #PLL_DP_MFD]
+	str r4, [r2, #PLL_DP_HFS_MFD]
+
+	str r5, [r2, #PLL_DP_MFN]
+	str r5, [r2, #PLL_DP_HFS_MFN]
+
+	ldr r1, =0x00001232
+	str r1, [r2, #PLL_DP_CTL]
+1:	ldr r1, [r2, #PLL_DP_CTL]
+	ands r1, r1, #0x1
+	beq 1b
+.endm
+
+.macro init_clock
+	ldr r0, =CCM_BASE_ADDR
+	mov r1, #0x00060000
+	str r1, [r0, #CLKCTL_CCDR]
+
+	/* Switch ARM to step clock */
+	mov r1, #0x4
+	str r1, [r0, #CLKCTL_CCSR]
+
+	mov r3, #DP_OP_800
+	mov r4, #DP_MFD_800
+	mov r5, #DP_MFN_800
+	setup_pll PLL1_BASE_ADDR
+	mov r3, #DP_OP_665
+	mov r4, #DP_MFD_665
+	mov r5, #DP_MFN_665
+	setup_pll PLL3_BASE_ADDR
+
+	/* Switch peripheral to PLL 3 */
+	ldr r1, =0x0000D3C0
+	str r1, [r0, #CLKCTL_CBCMR]
+	ldr r1, =0x033B9145
+	str r1, [r0, #CLKCTL_CBCDR]
+	mov r3, #DP_OP_665
+	mov r4, #DP_MFD_665
+	mov r5, #DP_MFN_665
+	setup_pll PLL2_BASE_ADDR
+
+	/* Switch peripheral to PLL2 */
+	ldr r1, =0x013B9145
+	str r1, [r0, #CLKCTL_CBCDR]
+	ldr r1, =0x0000E3C0
+	str r1, [r0, #CLKCTL_CBCMR]
+
+	mov r3, #DP_OP_216
+	mov r4, #DP_MFD_216
+	mov r5, #DP_MFN_216
+	setup_pll PLL3_BASE_ADDR
+
+	/* Set the platform clock dividers */
+	ldr r2, =ARM_BASE_ADDR
+	ldr r1, =0x00000725
+	str r1, [r2, #0x14]
+
+	/* Switch ARM back to PLL 1 */
+	mov r1, #0
+	str r1, [r0,  #CLKCTL_CCSR]
+	str r1, [r0,  #CLKCTL_CACRR]
+
+	/* Use lp_apm (24MHz) source for perclk */
+	mov r2, #0x48
+	ldr r2, [r0]
+	cmp r2, #0x10
+	ldrhs r1, =0x000020C2
+	ldrlo r1, =0x0000E3C2
+	str r1, [r0, #CLKCTL_CBCMR]
+	/* TO1.x emi = ahb, all perclk dividers are 1 since using 24MHz */
+	/* TO2.x ddr from PLL1, all perclk dividers are 1 since using 24MHz */
+	ldrhs r1, =0x59239100
+	ldrlo r1, =0x013D9100
+	strlo r1, [r0, #CLKCTL_CBCDR]
+
+	/* use PLL2 for UART source, get 66.5MHz */
+	ldr r1, =0xA5A2A020
+	str r1, [r0, #CLKCTL_CSCMR1]
+	ldr r1, =0x00C30321
+	str r1, [r0, #CLKCTL_CSCDR1]
+
+	/* make sure divider effective */
+1:	ldr r1, [r0, #CLKCTL_CDHIPR]
+	cmp r1, #0
+	bne 1b
+
+	mov r1, #0x0
+	str r1, [r0, #CLKCTL_CCDR]
+.endm
+
+.macro setup_wdog
+	ldr r0, =WDOG1_BASE_ADDR
+	mov r1, #0x30
+	strh r1, [r0]
+.endm
+
+.section ".text.init", "x"
+
+.globl lowlevel_init
+lowlevel_init:
+	/* Platform CHIP level init*/
+	ldr r0, =GPIO1_BASE_ADDR
+    ldr r1, [r0, #0x0]
+    orr r1, r1, #(1 << 23)
+    str r1, [r0, #0x0]
+    ldr r1, [r0, #0x4]
+    orr r1, r1, #(1 << 23)
+    str r1, [r0, #0x4]
+
+#ifdef TURN_OFF_IMPRECISE_ABORT
+	mrs r0, cpsr
+	bic r0, r0, #0x100
+	msr cpsr, r0
+#endif
+
+	mrc 15, 0, r1, c1, c0, 0
+
+#ifndef BRANCH_PREDICTION_ENABLE
+    	mrc 15, 0, r0, c1, c0, 1
+    	bic r0, r0, #7
+    	mcr 15, 0, r0, c1, c0, 1
+#else
+    	mrc 15, 0, r0, c1, c0, 1
+    	orr r0, r0, #7
+    	mcr 15, 0, r0, c1, c0, 1
+    	orr r1, r1, #(1<<11)
+#endif
+
+#ifdef UNALIGNED_ACCESS_ENABLE
+    	orr r1, r1, #(1<<22)
+#endif
+
+#ifdef LOW_INT_LATENCY_ENABLE
+    	orr r1, r1, #(1<<21)
+#endif
+    	mcr 15, 0, r1, c1, c0, 0
+
+    	mov r0, #0
+#ifdef BRANCH_PREDICTION_ENABLE
+   	mcr 15, 0, r0, c15, c2, 4
+#endif
+	mcr 15, 0, r0, c7, c10, 4       /* Drain the write buffer */
+
+	init_l2cc
+
+	init_aips
+
+	init_max
+
+	init_m4if
+
+	init_drive_strength
+
+	cmp pc, #PHYS_SDRAM_1
+	blo init_clock_start
+	cmp pc, #(PHYS_SDRAM_1 + PHYS_SDRAM_1_SIZE)
+	blo init_clock_start
+
+init_clock_start:
+	init_clock
+	init_debug_board
+	/*init_sdram*/
+
+	/* return from mxc_nand_load */
+	/* r12 saved upper lr*/
+	b mxc_nand_load
+
+/* Board level setting value */
+DDR_PERCHARGE_CMD:	.word 0x04008008
+DDR_REFRESH_CMD:	.word 0x00008010
+DDR_LMR1_W:		.word 0x00338018
+DDR_LMR_CMD:		.word 0xB2220000
+DDR_TIMING_W:		.word 0xB02567A9
+DDR_MISC_W:		.word 0x000A0104
diff --git a/board/freescale/mx51_bbg/mx51_bbg.c b/board/freescale/mx51_bbg/mx51_bbg.c
new file mode 100644
index 0000000..9e1bb1a
--- /dev/null
+++ b/board/freescale/mx51_bbg/mx51_bbg.c
@@ -0,0 +1,680 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mx51.h>
+#include <asm/arch/mx51_pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/errno.h>
+#include <i2c.h>
+#include <mxc_keyb.h>
+#include <asm/arch/keypad.h>
+#include "board-imx51.h"
+#include <asm/arch/imx_spi.h>
+#include <asm/arch/imx_spi_pmic.h>
+#include <fsl_esdhc.h>
+
+#include <part.h>
+#include <ext2fs.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static u32 system_rev;
+u32	mx51_io_base_addr;
+
+u32 get_board_rev(void)
+{
+	return system_rev;
+}
+
+static inline void setup_soc_rev(void)
+{
+	int reg;
+	reg = __REG(ROM_SI_REV);
+	switch (reg) {
+	case 0x02:
+		system_rev = 0x51000 | CHIP_REV_1_1;
+		break;
+	case 0x10:
+		if ((__REG(GPIO1_BASE_ADDR + 0x0) & (0x1 << 22)) == 0) {
+			system_rev = 0x51000 | CHIP_REV_2_5;
+		} else {
+			system_rev = 0x51000 | CHIP_REV_2_0;
+		}
+		break;
+	default:
+		system_rev = 0x51000 | CHIP_REV_1_0;
+	}
+}
+
+static inline void set_board_rev(int rev)
+{
+	system_rev |= (rev & 0xF) << 8;
+}
+
+inline int is_soc_rev(int rev)
+{
+	return (system_rev & 0xFF) - rev;
+}
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+static void setup_uart(void)
+{
+	unsigned int pad = PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE |
+			 PAD_CTL_PUE_PULL | PAD_CTL_DRV_HIGH;
+	mxc_request_iomux(MX51_PIN_UART1_RXD, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_UART1_RXD, pad | PAD_CTL_SRE_FAST);
+	mxc_request_iomux(MX51_PIN_UART1_TXD, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_UART1_TXD, pad | PAD_CTL_SRE_FAST);
+	mxc_request_iomux(MX51_PIN_UART1_RTS, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_UART1_RTS, pad);
+	mxc_request_iomux(MX51_PIN_UART1_CTS, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX51_PIN_UART1_CTS, pad);
+}
+
+void setup_nfc(void)
+{
+	/* Enable NFC IOMUX */
+	mxc_request_iomux(MX51_PIN_NANDF_CS0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT0);
+}
+
+static void setup_expio(void)
+{
+	u32 reg;
+	/* CS5 setup */
+	mxc_request_iomux(MX51_PIN_EIM_CS5, IOMUX_CONFIG_ALT0);
+	writel(0x00410089, WEIM_BASE_ADDR + 0x78 + CSGCR1);
+	writel(0x00000002, WEIM_BASE_ADDR + 0x78 + CSGCR2);
+	/* RWSC=50, RADVA=2, RADVN=6, OEA=0, OEN=0, RCSA=0, RCSN=0 */
+	writel(0x32260000, WEIM_BASE_ADDR + 0x78 + CSRCR1);
+	/* APR = 0 */
+	writel(0x00000000, WEIM_BASE_ADDR + 0x78 + CSRCR2);
+	/* WAL=0, WBED=1, WWSC=50, WADVA=2, WADVN=6, WEA=0, WEN=0,
+	 * WCSA=0, WCSN=0
+	 */
+	writel(0x72080F00, WEIM_BASE_ADDR + 0x78 + CSWCR1);
+	if ((readw(CS5_BASE_ADDR + PBC_ID_AAAA) == 0xAAAA) &&
+	    (readw(CS5_BASE_ADDR + PBC_ID_5555) == 0x5555)) {
+		if (is_soc_rev(CHIP_REV_2_0) < 0) {
+			reg = readl(CCM_BASE_ADDR + CLKCTL_CBCDR);
+			reg = (reg & (~0x70000)) | 0x30000;
+			writel(reg, CCM_BASE_ADDR + CLKCTL_CBCDR);
+			/* make sure divider effective */
+			while (readl(CCM_BASE_ADDR + CLKCTL_CDHIPR) != 0)
+				;
+			writel(0x0, CCM_BASE_ADDR + CLKCTL_CCDR);
+		}
+		mx51_io_base_addr = CS5_BASE_ADDR;
+	} else {
+		/* CS1 */
+		writel(0x00410089, WEIM_BASE_ADDR + 0x18 + CSGCR1);
+		writel(0x00000002, WEIM_BASE_ADDR + 0x18 + CSGCR2);
+		/*  RWSC=50, RADVA=2, RADVN=6, OEA=0, OEN=0, RCSA=0, RCSN=0 */
+		writel(0x32260000, WEIM_BASE_ADDR + 0x18 + CSRCR1);
+		/* APR=0 */
+		writel(0x00000000, WEIM_BASE_ADDR + 0x18 + CSRCR2);
+		/* WAL=0, WBED=1, WWSC=50, WADVA=2, WADVN=6, WEA=0,
+		 * WEN=0, WCSA=0, WCSN=0
+		 */
+		writel(0x72080F00, WEIM_BASE_ADDR + 0x18 + CSWCR1);
+		mx51_io_base_addr = CS1_BASE_ADDR;
+	}
+
+	/* Reset interrupt status reg */
+	writew(0x1F, mx51_io_base_addr + PBC_INT_REST);
+	writew(0x00, mx51_io_base_addr + PBC_INT_REST);
+	writew(0xFFFF, mx51_io_base_addr + PBC_INT_MASK);
+
+	/* Reset the XUART and Ethernet controllers */
+	reg = readw(mx51_io_base_addr + PBC_SW_RESET);
+	reg |= 0x9;
+	writew(reg, mx51_io_base_addr + PBC_SW_RESET);
+	reg &= ~0x9;
+	writew(reg, mx51_io_base_addr + PBC_SW_RESET);
+}
+
+void spi_io_init(struct imx_spi_dev_t *dev)
+{
+	switch (dev->base) {
+	case CSPI1_BASE_ADDR:
+		/* 000: Select mux mode: ALT0 mux port: MOSI of instance: ecspi1 */
+		mxc_request_iomux(MX51_PIN_CSPI1_MOSI, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_CSPI1_MOSI, 0x105);
+
+		/* 000: Select mux mode: ALT0 mux port: MISO of instance: ecspi1. */
+		mxc_request_iomux(MX51_PIN_CSPI1_MISO, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_CSPI1_MISO, 0x105);
+
+		if (dev->ss == 0) {
+			/* de-select SS1 of instance: ecspi1. */
+			mxc_request_iomux(MX51_PIN_CSPI1_SS1, IOMUX_CONFIG_ALT3);
+			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS1, 0x85);
+			/* 000: Select mux mode: ALT0 mux port: SS0 of instance: ecspi1. */
+			mxc_request_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT0);
+			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS0, 0x185);
+		} else if (dev->ss == 1) {
+			/* de-select SS0 of instance: ecspi1. */
+			mxc_request_iomux(MX51_PIN_CSPI1_SS0, IOMUX_CONFIG_ALT3);
+			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS0, 0x85);
+			/* 000: Select mux mode: ALT0 mux port: SS1 of instance: ecspi1. */
+			mxc_request_iomux(MX51_PIN_CSPI1_SS1, IOMUX_CONFIG_ALT0);
+			mxc_iomux_set_pad(MX51_PIN_CSPI1_SS1, 0x105);
+		}
+
+		/* 000: Select mux mode: ALT0 mux port: RDY of instance: ecspi1. */
+		mxc_request_iomux(MX51_PIN_CSPI1_RDY, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_CSPI1_RDY, 0x180);
+
+		/* 000: Select mux mode: ALT0 mux port: SCLK of instance: ecspi1. */
+		mxc_request_iomux(MX51_PIN_CSPI1_SCLK, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_CSPI1_SCLK, 0x105);
+		break;
+	case CSPI2_BASE_ADDR:
+	default:
+		break;
+	}
+}
+
+static void setup_fec(void)
+{
+	/*FEC_MDIO*/
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0D4);
+	writel(0x1FD, IOMUXC_BASE_ADDR + 0x0468);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0954);
+
+	/*FEC_MDC*/
+	writel(0x2, IOMUXC_BASE_ADDR + 0x13C);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0524);
+
+	/* FEC RDATA[3] */
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0EC);
+	writel(0x180, IOMUXC_BASE_ADDR + 0x0480);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0964);
+
+	/* FEC RDATA[2] */
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0E8);
+	writel(0x180, IOMUXC_BASE_ADDR + 0x047C);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0960);
+
+	/* FEC RDATA[1] */
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0d8);
+	writel(0x180, IOMUXC_BASE_ADDR + 0x046C);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x095C);
+
+	/* FEC RDATA[0] */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x016C);
+	writel(0x2180, IOMUXC_BASE_ADDR + 0x0554);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0958);
+
+	/* FEC TDATA[3] */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x148);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0530);
+
+	/* FEC TDATA[2] */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x144);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x052C);
+
+	/* FEC TDATA[1] */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x140);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0528);
+
+	/* FEC TDATA[0] */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x0170);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0558);
+
+	/* FEC TX_EN */
+	writel(0x1, IOMUXC_BASE_ADDR + 0x014C);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0534);
+
+	/* FEC TX_ER */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x0138);
+	writel(0x2004, IOMUXC_BASE_ADDR + 0x0520);
+
+	/* FEC TX_CLK */
+	writel(0x1, IOMUXC_BASE_ADDR + 0x0150);
+	writel(0x2180, IOMUXC_BASE_ADDR + 0x0538);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0974);
+
+	/* FEC COL */
+	writel(0x1, IOMUXC_BASE_ADDR + 0x0124);
+	writel(0x2180, IOMUXC_BASE_ADDR + 0x0500);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x094c);
+
+	/* FEC RX_CLK */
+	writel(0x1, IOMUXC_BASE_ADDR + 0x0128);
+	writel(0x2180, IOMUXC_BASE_ADDR + 0x0504);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0968);
+
+	/* FEC CRS */
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0f4);
+	writel(0x180, IOMUXC_BASE_ADDR + 0x0488);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0950);
+
+	/* FEC RX_ER */
+	writel(0x3, IOMUXC_BASE_ADDR + 0x0f0);
+	writel(0x180, IOMUXC_BASE_ADDR + 0x0484);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x0970);
+
+	/* FEC RX_DV */
+	writel(0x2, IOMUXC_BASE_ADDR + 0x164);
+	writel(0x2180, IOMUXC_BASE_ADDR + 0x054C);
+	writel(0x0, IOMUXC_BASE_ADDR + 0x096C);
+}
+
+static void power_init(void)
+{
+	struct spi_slave *slave;
+	unsigned int val;
+	unsigned int reg;
+
+	slave = spi_pmic_probe();
+
+	/* power up the system first */
+	pmic_reg(slave, 34, 0x00200000, 1);
+
+	if (mxc_get_clock(MXC_FEC_CLK) > 800000000) {
+		/* Set core voltage to 1.175V */
+		val = pmic_reg(slave, 24, 0, 0);
+		val = (val & (~0x1F)) | 0x17;
+		pmic_reg(slave, 24, val, 1);
+	}
+
+	/* Setup VCC (SW2) to 1.225 */
+	val = pmic_reg(slave, 25, 0, 0);
+	val = (val & (~0x1F)) | 0x19;
+	pmic_reg(slave, 25, val, 1);
+
+	/* Setup 1V2_DIG1 (SW3) to 1.2 */
+	val = pmic_reg(slave, 26, 0, 0);
+	val = (val & (~0x1F)) | 0x18;
+	pmic_reg(slave, 25, val, 1);
+
+	/* Set VDIG to 1.65V, VGEN3 to 1.8V, VCAM to 2.5V */
+	val = pmic_reg(slave, 30, 0, 0);
+	val &= ~0x34030;
+	val |= 0x10020;
+	pmic_reg(slave, 30, val, 1);
+
+	/* Set VVIDEO to 2.775V, VAUDIO to 3V, VSD to 3.15V */
+	val = pmic_reg(slave, 31, 0, 0);
+	val &= ~0x1FC;
+	val |= 0x1F4;
+	pmic_reg(slave, 31, val, 1);
+
+	/* Configure VGEN3 and VCAM regulators to use external PNP */
+	val = 0x208;
+	pmic_reg(slave, 33, val, 1);
+	udelay(200);
+
+	reg = readl(GPIO2_BASE_ADDR + 0x0);
+	reg &= ~0x4000;  /* Lower reset line */
+	writel(reg, GPIO2_BASE_ADDR + 0x0);
+
+	reg = readl(GPIO2_BASE_ADDR + 0x4);
+	reg |= 0x4000;  /* configure GPIO lines as output */
+	writel(reg, GPIO2_BASE_ADDR + 0x4);
+
+	/* Reset the ethernet controller over GPIO */
+	writel(0x1, IOMUXC_BASE_ADDR + 0x0AC);
+
+	/* Enable VGEN3, VCAM, VAUDIO, VVIDEO, VSD regulators */
+	val = 0x49249;
+	pmic_reg(slave, 33, val, 1);
+
+	udelay(500);
+
+	reg = readl(GPIO2_BASE_ADDR + 0x0);
+	reg |= 0x4000;
+	writel(reg, GPIO2_BASE_ADDR + 0x0);
+
+	/* Setup the FEC after enabling the regulators */
+	setup_fec();
+
+	spi_pmic_free(slave);
+}
+
+#ifdef CONFIG_NET_MULTI
+
+int board_eth_init(bd_t *bis)
+{
+	int rc = -ENODEV;
+
+	return rc;
+}
+#endif
+
+#ifdef CONFIG_CMD_MMC
+
+u32 *imx_esdhc_base_addr;
+
+int esdhc_gpio_init(void)
+{
+	u32 interface_esdhc = 0;
+        s32 status = 0;
+        u32 pad = 0;
+
+        interface_esdhc = (readl(SRC_BASE_ADDR + 0x4) & (0x00180000)) >> 19;
+
+	printf("interface_esdhc: %d\n", interface_esdhc);
+
+	switch (interface_esdhc) {
+        case 0:
+		imx_esdhc_base_addr = (u32 *)MMC_SDHC1_BASE_ADDR;
+
+		pad = PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+		                PAD_CTL_47K_PU | PAD_CTL_SRE_FAST;
+
+		mxc_request_iomux(MX51_PIN_SD1_CMD,
+			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD1_CLK,
+			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+
+		mxc_request_iomux(MX51_PIN_SD1_DATA0,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD1_DATA1,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD1_DATA2,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD1_DATA3,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD1_CMD, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD1_CLK, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA0, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA1, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA2, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD1_DATA3, pad);
+		break;
+	case 1:
+		imx_esdhc_base_addr = (u32 *)MMC_SDHC2_BASE_ADDR;
+
+		pad = PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST;
+
+		mxc_request_iomux(MX51_PIN_SD2_CMD,
+			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD2_CLK,
+			  IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+
+		mxc_request_iomux(MX51_PIN_SD2_DATA0,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD2_DATA1,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD2_DATA2,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_request_iomux(MX51_PIN_SD2_DATA3,
+				IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX51_PIN_SD2_CMD, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD2_CLK, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA0, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA1, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA2, pad);
+		mxc_iomux_set_pad(MX51_PIN_SD2_DATA3, pad);
+		break;
+	case 2:
+		status = -1;
+		break;
+	case 3:
+		status = -1;
+		break;
+	default:
+		status = -1;
+		break;
+	}
+
+	return status;
+}
+
+int board_mmc_init(void)
+{
+	if (!esdhc_gpio_init())
+		return fsl_esdhc_mmc_init(gd->bd);
+	else
+		return -1;
+}
+
+#endif
+
+#if defined(CONFIG_MXC_KPD)
+int setup_mxc_kpd()
+{
+	mxc_request_iomux(MX51_PIN_KEY_COL0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_COL5, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	setup_soc_rev();
+
+	gd->bd->bi_arch_number = MACH_TYPE_MX51_BABBAGE;	/* board id for linux */
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	setup_uart();
+	setup_nfc();
+	setup_expio();
+	return 0;
+}
+
+#ifdef BOARD_LATE_INIT
+int board_late_init(void)
+{
+#if defined(CONFIG_FSL_ANDROID) && defined(CONFIG_MXC_KPD)
+	struct kpp_key_info key_info = {0, 0};
+	int switch_delay = CONFIG_ANDROID_BOOTMOD_DELAY;
+	int state = 0, boot_mode_switch = 0;
+#endif
+
+	power_init();
+
+#if defined(CONFIG_FSL_ANDROID) && defined(CONFIG_MXC_KPD)
+	mxc_kpp_init();
+
+	puts("Press home + power to enter recovery mode ...\n");
+
+	while ((switch_delay > 0) && (!boot_mode_switch)) {
+		int i;
+
+		--switch_delay;
+		/* delay 100 * 10ms */
+		for (i = 0; !boot_mode_switch && i < 100; ++i) {
+			/* A state machine to scan home + power key */
+			/* Check for home + power */
+			if (mxc_kpp_getc(&key_info)) {
+				switch (state) {
+				case 0:
+					/* First press */
+					if (TEST_HOME_KEY_DEPRESS(key_info.val, key_info.evt)) {
+						/* Press Home */
+						state = 1;
+					} else if (TEST_POWER_KEY_DEPRESS(key_info.val, key_info.evt)) {
+						state = 2;
+					} else {
+						state = 0;
+					}
+					break;
+				case 1:
+					/* Home is already pressed, try to detect Power */
+					if (TEST_POWER_KEY_DEPRESS(key_info.val,
+						    key_info.evt)) {
+						boot_mode_switch = 1;
+					} else {
+					    if (TEST_HOME_KEY_DEPRESS(key_info.val,
+							key_info.evt))
+						state = 1;
+					    else
+						state = 0;
+					}
+					break;
+				case 2:
+					/* Power is already pressed, try to detect Home */
+					if (TEST_HOME_KEY_DEPRESS(key_info.val,
+						    key_info.evt)) {
+						boot_mode_switch = 1;
+					} else {
+						if (TEST_POWER_KEY_DEPRESS(key_info.val,
+							    key_info.evt))
+							state = 2;
+						else
+							state = 0;
+					}
+					break;
+				default:
+					break;
+				}
+
+				if (1 == boot_mode_switch) {
+					printf("Boot mode switched to recovery mode!\n");
+					/* Set env to recovery mode */
+					setenv("bootargs_android", CONFIG_ANDROID_RECOVERY_BOOTARGS);
+					setenv("bootcmd_android", CONFIG_ANDROID_RECOVERY_BOOTCMD);
+					setenv("bootcmd", "run bootcmd_android");
+					break;
+				}
+			}
+		}
+		for (i = 0; i < 100; ++i)
+			udelay(10000);
+	}
+
+	/* Check CONFIG_ANDROID_RECOVERY_CMD_FILE to 
+	judge if need to enter recovery mode */
+	{
+		char *cmd_file_patch;
+		block_dev_desc_t *dev_desc = NULL;
+		disk_partition_t info;
+		ulong part_length;
+		int filelen;
+
+		cmd_file_patch = getenv("android_recovery_cmd_file");
+		if (!cmd_file_patch)
+			cmd_file_patch = CONFIG_ANDROID_RECOVERY_CMD_FILE;
+
+		dev_desc = get_dev("mmc", 0);
+
+		if (dev_desc==NULL) {
+			puts("** Block device MMC 0 not supported\n");
+			return 1;
+		}
+
+		if (get_partition_info (dev_desc, 
+				CONFIG_ANDROID_CACHE_PARTITION,
+				&info)) {
+			printf("** Bad partition %d **\n",
+				CONFIG_ANDROID_CACHE_PARTITION);
+			return 1;
+		}
+
+		if ((part_length = \
+			ext2fs_set_blk_dev(dev_desc, 
+				CONFIG_ANDROID_CACHE_PARTITION)) == 0) {
+			printf("** Bad partition - mmc 0:%d **\n",
+				CONFIG_ANDROID_CACHE_PARTITION);
+			ext2fs_close();
+			return 1;
+		}
+
+		if (!ext2fs_mount(part_length)) {
+			printf ("** Bad ext2 partition or disk - mmc 0:%d **\n",
+				CONFIG_ANDROID_CACHE_PARTITION);
+			ext2fs_close();
+			return 1;
+		}
+
+		filelen = ext2fs_open(CONFIG_ANDROID_RECOVERY_CMD_FILE);
+
+		if (filelen > 0) {
+			puts("Recovery command file founded, switch to recovery mode!\n");
+			/* Set env to recovery mode */
+			setenv("bootargs_android", CONFIG_ANDROID_RECOVERY_BOOTARGS);
+			setenv("bootcmd_android", CONFIG_ANDROID_RECOVERY_BOOTCMD);
+			setenv("bootcmd", "run bootcmd_android");
+		} else {
+			puts("Recovery command file not found, normal boot!\n");
+		}
+
+		ext2fs_close();
+	}
+	
+#endif
+
+	return 0;
+}
+#endif
+
+int checkboard(void)
+{
+	printf("Board: MX51 BABBAGE ");
+
+	if (system_rev & CHIP_REV_2_5) {
+		printf("2.5 [");
+	} else if (system_rev & CHIP_REV_2_0) {
+		printf("2.0 [");
+	} else if (system_rev & CHIP_REV_1_1) {
+		printf("1.1 [");
+	} else {
+		printf("1.0 [");
+	}
+
+	switch (__REG(SRC_BASE_ADDR + 0x8)) {
+	case 0x0001:
+		printf("POR");
+		break;
+	case 0x0009:
+		printf("RST");
+		break;
+	case 0x0010:
+	case 0x0011:
+		printf("WDOG");
+		break;
+	default:
+		printf("unknown");
+	}
+	printf("]\n");
+	return 0;
+}
+
diff --git a/board/freescale/mx51_bbg/u-boot.lds b/board/freescale/mx51_bbg/u-boot.lds
new file mode 100644
index 0000000..9ece8af
--- /dev/null
+++ b/board/freescale/mx51_bbg/u-boot.lds
@@ -0,0 +1,73 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  /* WARNING - the following is hand-optimized to fit within	*/
+	  /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+	  board/freescale/mx51_bbg/flash_header.o	(.text.flasheader)
+	  cpu/arm_cortexa8/start.o
+	  board/freescale/mx51_bbg/libmx51_bbg.a	(.text)
+	  lib_arm/libarm.a		(.text)
+	  net/libnet.a			(.text)
+	  drivers/mtd/libmtd.a		(.text)
+	  drivers/mmc/libmmc.a		(.text)
+
+	  . = DEFINED(env_offset) ? env_offset : .;
+	  common/env_embedded.o(.text)
+
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/stmp378x_dev/config.mk b/board/stmp378x_dev/config.mk
index cfd24d1..7b57ec3 100644
--- a/board/stmp378x_dev/config.mk
+++ b/board/stmp378x_dev/config.mk
@@ -1,5 +1,6 @@
 #
 # image should be loaded at 0x41008000
 #
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
 
 TEXT_BASE = 0x41008000
diff --git a/common/Makefile b/common/Makefile
index 7091eef..f71053e 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -55,6 +55,8 @@ COBJS-$(CONFIG_ENV_IS_EMBEDDED) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_EEPROM) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_FLASH) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_NVRAM) += env_embedded.o
+COBJS-$(CONFIG_ENV_IS_IN_MMC) += env_embedded.o
+COBJS-$(CONFIG_ENV_IS_IN_NAND) += env_embedded.o
 COBJS-$(CONFIG_ENV_IS_IN_FLASH) += env_flash.o
 COBJS-$(CONFIG_ENV_IS_IN_MG_DISK) += env_mgdisk.o
 COBJS-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
diff --git a/common/cmd_mmc.c b/common/cmd_mmc.c
index 0e3393b..421482e 100644
--- a/common/cmd_mmc.c
+++ b/common/cmd_mmc.c
@@ -127,9 +127,10 @@ int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
 	mmc = find_mmc_device(dev_num);
 
 	if (mmc) {
-		mmc_init(mmc);
-
-		print_mmcinfo(mmc);
+		if (mmc_init(mmc))
+			puts("MMC card init failed!\n");
+		else
+			print_mmcinfo(mmc);
 	}
 
 	return 0;
diff --git a/common/env_mmc.c b/common/env_mmc.c
index 74e6c60..180f39c 100644
--- a/common/env_mmc.c
+++ b/common/env_mmc.c
@@ -147,45 +147,74 @@ int env_init(void)
 int saveenv(void)
 {
 	size_t total;
-	int ret = 0;
+	uint blk_start = 0, blk_cnt = 0, n = 0;
+	struct mmc *mmc = find_mmc_device(0);
 
 	env_ptr->flags++;
 	total = CONFIG_ENV_SIZE;
 
+	if (!mmc) {
+		puts("No MMC card found\n");
+		return;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return 1;
+	}
+
 	if (gd->env_valid == 1) {
 		puts("Writing to redundant MMC... ");
-		ret = mmc_write((u_char *)env_ptr,
-				CONFIG_ENV_OFFSET_REDUND, total);
+		blk_start = (CONFIG_ENV_OFFSET_REDUND % 512) ? \
+			((CONFIG_ENV_OFFSET_REDUND / 512) + 1) : (CONFIG_ENV_OFFSET_REDUND / 512);
+		blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+		n = mmc->block_dev.block_write(0, blk_start , blk_cnt, (u_char *)env_ptr);
 	} else {
 		puts("Writing to MMC... ");
-		ret = mmc_write((u_char *)env_ptr,
-				CONFIG_ENV_OFFSET, total);
+		blk_start = (CONFIG_ENV_OFFSET % 512) ? \
+			((CONFIG_ENV_OFFSET / 512) + 1) : (CONFIG_ENV_OFFSET / 512);
+		blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+		n = mmc->block_dev.block_write(0, blk_start , blk_cnt, (u_char *)env_ptr);
 	}
-	if (ret || total != CONFIG_ENV_SIZE) {
+	if ((n != blk_cnt) || (total != CONFIG_ENV_SIZE)) {
 		puts("failed\n");
 		return 1;
 	}
 
 	puts("done\n");
 	gd->env_valid = (gd->env_valid == 2 ? 1 : 2);
-	return ret;
+	return 0;
 }
 #else /* ! CONFIG_ENV_OFFSET_REDUND */
 int saveenv(void)
 {
 	size_t total;
-	int ret = 0;
+	uint blk_start = 0, blk_cnt = 0, n = 0;
+	struct mmc *mmc = find_mmc_device(0);
+
+	if (!mmc) {
+		puts("No MMC card found\n");
+		return;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return 1;
+	}
 
 	puts("Writing to MMC... ");
 	total = CONFIG_ENV_SIZE;
-	ret = mmc_write((u_char *)env_ptr, CONFIG_ENV_OFFSET, total);
-	if (ret || total != CONFIG_ENV_SIZE) {
+	blk_start = (CONFIG_ENV_OFFSET % 512) ? \
+			((CONFIG_ENV_OFFSET / 512) + 1) : (CONFIG_ENV_OFFSET / 512);
+	blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+	n = mmc->block_dev.block_write(0, blk_start , blk_cnt, (u_char *)env_ptr);
+	if ((n != blk_cnt) || (total != CONFIG_ENV_SIZE)) {
 		puts("failed\n");
 		return 1;
 	}
 
 	puts("done\n");
-	return ret;
+	return 0;
 }
 #endif /* CONFIG_ENV_OFFSET_REDUND */
 #endif /* CMD_SAVEENV */
@@ -197,11 +226,16 @@ void env_relocate_spec(void)
 	size_t total;
 	int crc1_ok = 0, crc2_ok = 0;
 	env_t *tmp_env1 = NULL, *tmp_env2 = NULL;
+	uint blk_start = 0, blk_cnt = 0, n = 0;
+	struct mmc *mmc = find_mmc_device(0);
 
-	puts("Initialing MMC card... \n");
-
-	if (mmc_init(1) != 0) {
+	if (!mmc) {
 		puts("No MMC card found\n");
+		return;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
 		goto use_default;
 	}
 
@@ -222,14 +256,28 @@ void env_relocate_spec(void)
 	memset(tmp_env2, 0, CONFIG_ENV_SIZE);
 
 	puts("Loading environment from mmc... ");
-	if (mmc_read(CONFIG_ENV_OFFSET, (uchar *)tmp_env1, total)) {
+
+	blk_start = (CONFIG_ENV_OFFSET % 512) ? \
+			((CONFIG_ENV_OFFSET / 512) + 1) : (CONFIG_ENV_OFFSET / 512);
+	blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+
+	n = mmc->block_dev.block_read(0, blk_start, blk_cnt, (uchar *)tmp_env1);
+	
+	if (n != blk_cnt) {
 		puts("failed\n");
 		goto use_default;
 	}
 	puts("done\n");
 
 	puts("Loading redundant environment from mmc... ");
-	if (mmc_read(CONFIG_ENV_OFFSET_REDUND, (uchar *)tmp_env2, total)) {
+
+	blk_start = (CONFIG_ENV_OFFSET_REDUND % 512) ? \
+			((CONFIG_ENV_OFFSET_REDUND / 512) + 1) : (CONFIG_ENV_OFFSET_REDUND / 512);
+	blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+
+	n = mmc->block_dev.block_read(0, blk_start, blk_cnt, (uchar *)tmp_env2);
+
+	if (n != blk_cnt) {
 		puts("failed\n");
 		goto use_default;
 	}
@@ -287,16 +335,28 @@ void env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	size_t total;
-	int ret;
+	uint blk_start = 0, blk_cnt = 0, n = 0;
+	struct mmc *mmc = find_mmc_device(0);
 
-	if (mmc_init(1) != 0) {
+	if (!mmc) {
 		puts("No MMC card found\n");
+		return;	
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
 		return;
 	}
 
 	total = CONFIG_ENV_SIZE;
-	ret = mmc_read(CONFIG_ENV_OFFSET, (u_char *)env_ptr, total);
-	if (ret || total != CONFIG_ENV_SIZE)
+
+	blk_start = (CONFIG_ENV_OFFSET % 512) ? \
+			((CONFIG_ENV_OFFSET / 512) + 1) : (CONFIG_ENV_OFFSET / 512);
+	blk_cnt = (total % 512) ? ((total / 512) + 1) : (total / 512);
+
+	n = mmc->block_dev.block_read(0, blk_start, blk_cnt, (uchar *)env_ptr);
+	
+	if ((n != blk_cnt) || (total != CONFIG_ENV_SIZE))
 		return use_default();
 
 	if (crc32(0, env_ptr->data, ENV_SIZE) != env_ptr->crc)
diff --git a/cpu/arm1136/mx35/Makefile b/cpu/arm1136/mx35/Makefile
index afcf771..996360f 100644
--- a/cpu/arm1136/mx35/Makefile
+++ b/cpu/arm1136/mx35/Makefile
@@ -27,7 +27,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(SOC).a
 
-COBJS	= interrupts.o serial.o generic.o iomux.o
+COBJS	= timer.o serial.o generic.o iomux.o
 SOBJS = mxc_nand_load.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
diff --git a/cpu/arm1136/mx35/generic.c b/cpu/arm1136/mx35/generic.c
index b70c3ea..31bcbec 100644
--- a/cpu/arm1136/mx35/generic.c
+++ b/cpu/arm1136/mx35/generic.c
@@ -24,6 +24,7 @@
  */
 
 #include <common.h>
+#include <asm/io.h>
 #include <asm/errno.h>
 #include <asm/arch/mx35.h>
 #include "crm_regs.h"
@@ -47,6 +48,12 @@ static int g_clk_mux_consumer[16] = {
 	-1, -1, CLK_CODE(4, 2, 0), -1,
 };
 
+static int hsp_div_table[3][16] = {
+	{4, 3, 2, -1, -1, -1, 1, 5, 4, 3, 2, -1, -1, -1, 1, -1},
+	{-1, -1, -1, -1, -1, -1, -1, -1, 8, 6, 4, -1, -1, -1, 2, -1},
+	{3, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1},
+};
+
 static u32 __get_arm_div(u32 pdr0, u32 *fi, u32 *fd)
 {
 	int *pclk_mux;
@@ -117,7 +124,7 @@ static u32 __get_mcu_main_clk(void)
 	u32 arm_div, fi, fd;
 	arm_div = __get_arm_div(__REG(CCM_BASE_ADDR + CLKCTL_PDR0), &fi, &fd);
 	fi *=
-	    __decode_pll(__REG(CCM_BASE_ADDR + CLKCTL_MPCTL),
+	    __decode_pll(__REG(MCU_PLL),
 			 CONFIG_MX35_HCLK_FREQ);
 	return fi / (arm_div * fd);
 }
@@ -160,7 +167,7 @@ static u32 __get_uart_clk(void)
 	if (__REG(CCM_BASE_ADDR + CLKCTL_PDR3) & MXC_CCM_PDR3_UART_M_U)
 		freq = __get_mcu_main_clk();
 	else
-		freq = __decode_pll(__REG(CCM_BASE_ADDR + CLKCTL_PPCTL),
+		freq = __decode_pll(__REG(PER_PLL),
 				    CONFIG_MX35_HCLK_FREQ);
 	freq /= ((CCM_GET_DIVIDER(pdr4,
 				  MXC_CCM_PDR4_UART_PRDF_MASK,
@@ -171,6 +178,150 @@ static u32 __get_uart_clk(void)
 	return freq;
 }
 
+unsigned int mxc_get_main_clock(enum mxc_main_clocks clk)
+{
+	u32 nfc_pdf, hsp_podf;
+	u32 pll, ret_val = 0, usb_prdf, usb_podf;
+
+	u32 reg = readl(CCM_BASE_ADDR + CLKCTL_PDR0);
+	u32 reg4 = readl(CCM_BASE_ADDR + CLKCTL_PDR4);
+
+	reg |= 0x1;
+
+	switch (clk) {
+	case CPU_CLK:
+		ret_val = __get_mcu_main_clk();
+		break;
+	case AHB_CLK:
+		ret_val = __get_mcu_main_clk();
+		break;
+	case HSP_CLK:
+		if (reg & CLKMODE_CONSUMER) {
+			hsp_podf = (reg >> 20) & 0x3;
+			pll = __get_mcu_main_clk();
+			hsp_podf = hsp_div_table[hsp_podf][(reg>>16)&0xF];
+			if(hsp_podf > 0 ) {
+				ret_val = pll / hsp_podf;
+			} else {
+				puts("mismatch HSP with ARM clock setting\n");
+				ret_val = 0;
+			}
+		} else {
+			ret_val = __get_mcu_main_clk();
+		}
+		break;
+	case IPG_CLK:
+		ret_val = __get_ipg_clk();;
+		break;
+	case IPG_PER_CLK:
+		ret_val = __get_ipg_per_clk();
+		break;
+	case NFC_CLK:
+		nfc_pdf = (reg4 >> 28) & 0xF;
+		pll = __get_mcu_main_clk();
+		/* AHB/nfc_pdf */
+		ret_val = pll / (nfc_pdf + 1);
+		break;
+	case USB_CLK:
+		usb_prdf = (reg4 >> 25) & 0x7;
+		usb_podf = (reg4 >> 22) & 0x7;
+		if (reg4 & 0x200)
+       		pll = __get_mcu_main_clk();
+ 		else
+       		pll = __decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ);
+
+		ret_val = pll / ((usb_prdf + 1) * (usb_podf + 1));
+		break;
+	default:
+		printf("Unknown clock: %d\n", clk);
+		break;
+	}
+
+	return ret_val;
+}
+unsigned int mxc_get_peri_clock(enum mxc_peri_clocks clk)
+{
+	u32 ret_val = 0, pdf, pre_pdf, clk_sel;
+	u32 mpdr2 = readl(CCM_BASE_ADDR + CLKCTL_PDR2);
+	u32 mpdr3 = readl(CCM_BASE_ADDR + CLKCTL_PDR3);
+	u32 mpdr4 = readl(CCM_BASE_ADDR + CLKCTL_PDR4);
+
+	switch (clk) {
+	case UART1_BAUD:
+	case UART2_BAUD:
+	case UART3_BAUD:
+		clk_sel = mpdr3 & (1 << 14);
+		pre_pdf = (mpdr4 >> 13) & 0x7;
+		pdf = (mpdr4 >> 10) & 0x7;
+		ret_val = ((clk_sel != 0) ? mxc_get_main_clock(CPU_CLK) :
+		__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case SSI1_BAUD:
+		pre_pdf = (mpdr2 >> 24) & 0x7;
+		pdf = mpdr2 & 0x3F;
+		clk_sel = mpdr2 & ( 1 << 6);
+		ret_val = ((clk_sel != 0) ? mxc_get_main_clock(CPU_CLK) :
+		__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case SSI2_BAUD:
+		pre_pdf = (mpdr2 >> 27) & 0x7;
+		pdf = (mpdr2 >> 8)& 0x3F;
+		clk_sel = mpdr2 & ( 1 << 6);
+		ret_val = ((clk_sel != 0) ? mxc_get_main_clock(CPU_CLK) :
+		__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case CSI_BAUD:
+		clk_sel = mpdr2 & (1 << 7);
+		pre_pdf = (mpdr2 >> 16) & 0x7;
+		pdf = (mpdr2 >> 19) & 0x7;
+		ret_val = ((clk_sel != 0) ? mxc_get_main_clock(CPU_CLK) :
+		__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case MSHC_CLK:
+		pre_pdf = readl(CCM_BASE_ADDR + CLKCTL_PDR1);
+	 	clk_sel = (pre_pdf & 0x80);
+		pdf = (pre_pdf >> 22) & 0x3F;
+		pre_pdf = (pre_pdf >> 28) & 0x7;
+		ret_val = ((clk_sel != 0)? mxc_get_main_clock(CPU_CLK) :
+				__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case ESDHC1_CLK:
+		clk_sel = mpdr3 & 0x40;
+		pre_pdf = mpdr3&0x7;
+		pdf = (mpdr3>>3)&0x7;
+		ret_val = ((clk_sel != 0)? mxc_get_main_clock(CPU_CLK) :
+				__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case ESDHC2_CLK:
+		clk_sel = mpdr3 & 0x40;
+		pre_pdf = (mpdr3 >> 8)&0x7;
+		pdf = (mpdr3 >> 11)&0x7;
+		ret_val = ((clk_sel != 0)? mxc_get_main_clock(CPU_CLK) :
+				__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case ESDHC3_CLK:
+		clk_sel = mpdr3 & 0x40;
+		pre_pdf = (mpdr3 >> 16)&0x7;
+		pdf = (mpdr3 >> 19)&0x7;
+		ret_val = ((clk_sel != 0)? mxc_get_main_clock(CPU_CLK) :
+				__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	case SPDIF_CLK:
+		clk_sel = mpdr3 & 0x400000;
+		pre_pdf = (mpdr3 >> 29)&0x7;
+		pdf = (mpdr3 >> 23)&0x3F;
+		ret_val = ((clk_sel != 0)? mxc_get_main_clock(CPU_CLK) :
+				__decode_pll(__REG(PER_PLL), CONFIG_MX35_HCLK_FREQ)) / ((pre_pdf + 1) * (pdf + 1));
+		break;
+	default:
+		printf("%s(): This clock: %d not supported yet \n",
+				__FUNCTION__, clk);
+		break;
+	}
+
+	return ret_val;
+}
+
 unsigned int mxc_get_clock(enum mxc_clock clk)
 {
 	switch (clk) {
@@ -184,6 +335,10 @@ unsigned int mxc_get_clock(enum mxc_clock clk)
 		return __get_ipg_per_clk();
 	case MXC_UART_CLK:
 		return __get_uart_clk();
+	case MXC_ESDHC_CLK:
+		return mxc_get_peri_clock(ESDHC1_CLK);
+	case MXC_USB_CLK:
+		return mxc_get_main_clock(USB_CLK);
 	}
 	return -1;
 }
diff --git a/cpu/arm1136/mx35/interrupts.c b/cpu/arm1136/mx35/interrupts.c
deleted file mode 100644
index 40b9d4c..0000000
--- a/cpu/arm1136/mx35/interrupts.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * (C) Copyright 2007
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/arch/mx35.h>
-
-/* General purpose timers registers */
-#define GPTCR   __REG(GPT1_BASE_ADDR)	/* Control register */
-#define GPTPR  	__REG(GPT1_BASE_ADDR + 0x4)	/* Prescaler register */
-#define GPTSR   __REG(GPT1_BASE_ADDR + 0x8)	/* Status register */
-#define GPTCNT 	__REG(GPT1_BASE_ADDR + 0x24)	/* Counter register */
-
-/* General purpose timers bitfields */
-#define GPTCR_SWR       (1<<15)	/* Software reset */
-#define GPTCR_FRR       (1<<9)	/* Freerun / restart */
-#define GPTCR_CLKSOURCE_32 (4<<6)	/* Clock source */
-#define GPTCR_TEN       (1)	/* Timer enable */
-
-/* nothing really to do with interrupts, just starts up a counter. */
-int interrupt_init(void)
-{
-	int i;
-
-	/* setup GP Timer 1 */
-	GPTCR = GPTCR_SWR;
-	for (i = 0; i < 100; i++)
-		GPTCR = 0;	/* We have no udelay by now */
-	GPTPR = 0;		/* 32Khz */
-	/* Freerun Mode, PERCLK1 input */
-	GPTCR |= GPTCR_CLKSOURCE_32 | GPTCR_TEN;
-
-	return 0;
-}
-
-void reset_timer(void)
-{
-	reset_timer_masked();
-}
-
-void reset_timer_masked(void)
-{
-	GPTCR = 0;
-	/* Freerun Mode, PERCLK1 input */
-	GPTCR = GPTCR_CLKSOURCE_32 | GPTCR_TEN;
-}
-
-ulong get_timer_masked(void)
-{
-	ulong val = GPTCNT;
-	return val;
-}
-
-ulong get_timer(ulong base)
-{
-	return get_timer_masked() - base;
-}
-
-void set_timer(ulong t)
-{
-}
-
-/* delay x useconds AND perserve advance timstamp value */
-void udelay(unsigned long usec)
-{
-	ulong tmo, tmp;
-
-		/* if "big" number, spread normalization to seconds */
-	if (usec >= 1000) {
-		/* start to normalize for usec to ticks per sec */
-		tmo = usec / 1000;
-		/* find number of "ticks" to wait to achieve target */
-		tmo *= CONFIG_SYS_HZ;
-		tmo /= 1000;	/* finish normalize. */
-	} else {/* else small number, don't kill it prior to HZ multiply */
-		tmo = usec * CONFIG_SYS_HZ;
-		tmo /= (1000 * 1000);
-	}
-
-	tmp = get_timer(0);	/* get current timestamp */
-	/* if setting this forward will roll time stamp */
-	if ((tmo + tmp + 1) < tmp)
-		 /* reset "advancing" timestamp to 0, set lastinc value */
-		reset_timer_masked();
-	else	/* else, set advancing stamp wake up time */
-		tmo += tmp;
-	while (get_timer_masked() < tmo)	/* loop till event */
-		 /*NOP*/;
-}
-
-void reset_cpu(ulong addr)
-{
-	__REG16(WDOG_BASE_ADDR) = 4;
-}
diff --git a/cpu/arm1136/mx35/timer.c b/cpu/arm1136/mx35/timer.c
new file mode 100644
index 0000000..d6f65cf
--- /dev/null
+++ b/cpu/arm1136/mx35/timer.c
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2007
+ * Sascha Hauer, Pengutronix
+ *
+ * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/mx35.h>
+
+/* General purpose timers registers */
+#define GPTCR   __REG(GPT1_BASE_ADDR)	/* Control register */
+#define GPTPR  	__REG(GPT1_BASE_ADDR + 0x4)	/* Prescaler register */
+#define GPTSR   __REG(GPT1_BASE_ADDR + 0x8)	/* Status register */
+#define GPTCNT 	__REG(GPT1_BASE_ADDR + 0x24)	/* Counter register */
+
+/* General purpose timers bitfields */
+#define GPTCR_SWR       (1<<15)	/* Software reset */
+#define GPTCR_FRR       (1<<9)	/* Freerun / restart */
+#define GPTCR_CLKSOURCE_32 (4<<6)	/* Clock source */
+#define GPTCR_TEN       (1)	/* Timer enable */
+
+static inline void setup_gpt()
+{
+	int i;
+	static int init_done;
+
+	if (init_done)
+	    return;
+
+	init_done = 1;
+
+	/* setup GP Timer 1 */
+	GPTCR = GPTCR_SWR;
+	for (i = 0; i < 100; i++)
+		GPTCR = 0;      /* We have no udelay by now */
+	GPTPR = 0;              /* 32Khz */
+	/* Freerun Mode, PERCLK1 input */
+	GPTCR |= GPTCR_CLKSOURCE_32 | GPTCR_TEN;
+}
+
+int timer_init(void)
+{
+	setup_gpt();
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+void reset_timer_masked(void)
+{
+	GPTCR = 0;
+	/* Freerun Mode, PERCLK1 input */
+	GPTCR = GPTCR_CLKSOURCE_32 | GPTCR_TEN;
+}
+
+ulong get_timer_masked(void)
+{
+	ulong val = GPTCNT;
+	return val;
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	setup_gpt();
+
+	/* if "big" number, spread normalization to seconds */
+	if (usec >= 1000) {
+		/* start to normalize for usec to ticks per sec */
+		tmo = usec / 1000;
+		/* find number of "ticks" to wait to achieve target */
+		tmo *= CONFIG_SYS_HZ;
+		tmo /= 1000;	/* finish normalize. */
+	} else {/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000 * 1000);
+	}
+
+	tmp = get_timer(0);	/* get current timestamp */
+	/* if setting this forward will roll time stamp */
+	if ((tmo + tmp + 1) < tmp)
+		 /* reset "advancing" timestamp to 0, set lastinc value */
+		reset_timer_masked();
+	else	/* else, set advancing stamp wake up time */
+		tmo += tmp;
+	while (get_timer_masked() < tmo)	/* loop till event */
+		 /*NOP*/;
+}
+
+void reset_cpu(ulong addr)
+{
+	__REG16(WDOG_BASE_ADDR) = 4;
+}
diff --git a/cpu/arm1136/start.S b/cpu/arm1136/start.S
index 57f13ef..b1d7087 100644
--- a/cpu/arm1136/start.S
+++ b/cpu/arm1136/start.S
@@ -130,6 +130,7 @@ next:
 #endif
 	b	setup_env
 
+#ifndef CONFIG_SKIP_LOWLEVEL_INIT
 /*
  *************************************************************************
  *
@@ -166,7 +167,7 @@ cpu_init_crit:
 	bl	lowlevel_init	/* go setup pll,mux,memory */
 	mov	lr, ip		/* restore link */
 	mov	pc, lr		/* back to my caller */
-
+#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
 
 .section ".text.setup", "ax"
 
@@ -263,45 +264,6 @@ _start_armboot: .word start_armboot
 #endif /* CONFIG_ONENAND_IPL */
 #endif /* CONFIG_NAND_SPL */
 
-/*
- *************************************************************************
- *
- * CPU_init_critical registers
- *
- * setup important registers
- * setup memory timing
- *
- *************************************************************************
- */
-#ifndef CONFIG_SKIP_LOWLEVEL_INIT
-cpu_init_crit:
-	/*
-	 * flush v4 I/D caches
-	 */
-	mov	r0, #0
-	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
-	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
-
-	/*
-	 * disable MMU stuff and caches
-	 */
-	mrc	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
-	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
-	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
-	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
-	mcr	p15, 0, r0, c1, c0, 0
-
-	/*
-	 * Jump to board specific initialization... The Mask ROM will have already initialized
-	 * basic memory.  Go here to bump up clock rate and handle wake up conditions.
-	 */
-	mov	ip, lr		/* persevere link reg across call */
-	bl	lowlevel_init	/* go setup pll,mux,memory */
-	mov	lr, ip		/* restore link */
-	mov	pc, lr		/* back to my caller */
-#endif /* CONFIG_SKIP_LOWLEVEL_INIT */
-
 #ifndef CONFIG_PRELOADER
 /*
  *************************************************************************
diff --git a/cpu/arm926ejs/mx25/Makefile b/cpu/arm926ejs/mx25/Makefile
index 74add9d..48b4e7d 100644
--- a/cpu/arm926ejs/mx25/Makefile
+++ b/cpu/arm926ejs/mx25/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(SOC).a
 
-COBJS	= interrupts.o serial.o generic.o iomux.o gpio.o
+COBJS	= timer.o serial.o generic.o iomux.o gpio.o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff --git a/cpu/arm926ejs/mx25/interrupts.c b/cpu/arm926ejs/mx25/interrupts.c
deleted file mode 100644
index cbd5d09..0000000
--- a/cpu/arm926ejs/mx25/interrupts.c
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * (C) Copyright 2007
- * Sascha Hauer, Pengutronix
- *
- * (C) Copyright 2009 Freescale Semiconductor
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/arch/mx25-regs.h>
-
-#define TIMER_BASE 0x53f90000 /* General purpose timer 1 */
-
-/* General purpose timers registers */
-#define GPTCR	__REG(TIMER_BASE) /* Control register */
-#define GPTPR	__REG(TIMER_BASE + 0x4) /* Prescaler register */
-#define GPTSR	__REG(TIMER_BASE + 0x8) /* Status register */
-#define GPTCNT	__REG(TIMER_BASE + 0x24) /* Counter register */
-
-/* General purpose timers bitfields */
-#define GPTCR_SWR	(1<<15) /* Software reset */
-#define GPTCR_FRR	(1<<9)  /* Freerun / restart */
-#define GPTCR_CLKSOURCE_32	(4<<6)  /* Clock source */
-#define GPTCR_TEN	(1)	/* Timer enable */
-
-static ulong timestamp;
-static ulong lastinc;
-
-/* nothing really to do with interrupts, just starts up a counter. */
-int interrupt_init(void)
-{
-	int i;
-
-	/* setup GP Timer 1 */
-	GPTCR = GPTCR_SWR;
-	for (i = 0; i < 100; i++)
-		GPTCR = 0; /* We have no udelay by now */
-	GPTPR = 0; /* 32Khz */
-	GPTCR |= GPTCR_CLKSOURCE_32 | GPTCR_TEN; /* Freerun Mode, PERCLK1 in */
-
-	return 0;
-}
-
-void reset_timer_masked(void)
-{
-	/* reset time */
-	lastinc = GPTCNT; /* capture current incrementer value time */
-	timestamp = 0; /* start "advancing" time stamp from 0 */
-}
-
-void reset_timer(void)
-{
-	reset_timer_masked();
-}
-
-ulong get_timer_masked(void)
-{
-	ulong now = GPTCNT; /* current tick value */
-
-	if (now >= lastinc)	/* normal mode (non roll) */
-		/* move stamp forward with absolut diff ticks */
-		timestamp += (now - lastinc);
-	else			/* we have rollover of incrementer */
-		timestamp += (0xFFFFFFFF - lastinc) + now;
-	lastinc = now;
-	return timestamp;
-}
-
-ulong get_timer(ulong base)
-{
-	return get_timer_masked() - base;
-}
-
-void set_timer(ulong t)
-{
-}
-
-/* delay x useconds AND perserve advance timstamp value */
-void udelay(unsigned long usec)
-{
-	ulong tmo, tmp;
-
-	if (usec >= 1000) {	/* if "big" number, spread normalize to secs */
-		tmo = usec / 1000;	/* normalize usec to ticks per sec */
-		tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" to wait */
-		tmo /= 1000;		/* finish normalize. */
-	} else {			/* don't kill prior to HZ multiply */
-		tmo = usec * CONFIG_SYS_HZ;
-		tmo /= (1000*1000);
-	}
-
-	tmp = get_timer(0);		/* get current timestamp */
-	if ((tmo + tmp + 1) < tmp)	/* if overflow time stamp */
-		reset_timer_masked();	/* reset "advancing" timestamp to 0 */
-	else
-		tmo += tmp;		/* else, set stamp wake up time */
-	while (get_timer_masked() < tmo)/* loop till event */
-		/*NOP*/;
-}
-
-void reset_cpu(ulong addr)
-{
-	__REG16(WDOG_BASE) = 4;
-}
diff --git a/cpu/arm926ejs/mx25/timer.c b/cpu/arm926ejs/mx25/timer.c
new file mode 100644
index 0000000..8b6a061
--- /dev/null
+++ b/cpu/arm926ejs/mx25/timer.c
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2007
+ * Sascha Hauer, Pengutronix
+ *
+ * (C) Copyright 2009 Freescale Semiconductor
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/mx25-regs.h>
+
+#define TIMER_BASE 0x53f90000 /* General purpose timer 1 */
+
+/* General purpose timers registers */
+#define GPTCR	__REG(TIMER_BASE) /* Control register */
+#define GPTPR	__REG(TIMER_BASE + 0x4) /* Prescaler register */
+#define GPTSR	__REG(TIMER_BASE + 0x8) /* Status register */
+#define GPTCNT	__REG(TIMER_BASE + 0x24) /* Counter register */
+
+/* General purpose timers bitfields */
+#define GPTCR_SWR	(1<<15) /* Software reset */
+#define GPTCR_FRR	(1<<9)  /* Freerun / restart */
+#define GPTCR_CLKSOURCE_32	(4<<6)  /* Clock source */
+#define GPTCR_TEN	(1)	/* Timer enable */
+
+static ulong timestamp;
+static ulong lastinc;
+
+static inline void setup_gpt()
+{
+	int i;
+	static int init_done;
+
+	if (init_done)
+	    return;
+
+	init_done = 1;
+
+	/* setup GP Timer 1 */
+	GPTCR = GPTCR_SWR;
+	for (i = 0; i < 100; i++)
+		GPTCR = 0;      /* We have no udelay by now */
+	GPTPR = 0;              /* 32Khz */
+	/* Freerun Mode, PERCLK1 input */
+	GPTCR |= GPTCR_CLKSOURCE_32 | GPTCR_TEN;
+}
+
+/* nothing really to do with interrupts, just starts up a counter. */
+int timer_init(void)
+{
+	setup_gpt();
+
+	return 0;
+}
+
+void reset_timer_masked(void)
+{
+	/* reset time */
+	lastinc = GPTCNT; /* capture current incrementer value time */
+	timestamp = 0; /* start "advancing" time stamp from 0 */
+}
+
+void reset_timer(void)
+{
+	reset_timer_masked();
+}
+
+ulong get_timer_masked(void)
+{
+	ulong now = GPTCNT; /* current tick value */
+
+	if (now >= lastinc)	/* normal mode (non roll) */
+		/* move stamp forward with absolut diff ticks */
+		timestamp += (now - lastinc);
+	else			/* we have rollover of incrementer */
+		timestamp += (0xFFFFFFFF - lastinc) + now;
+	lastinc = now;
+	return timestamp;
+}
+
+ulong get_timer(ulong base)
+{
+	return get_timer_masked() - base;
+}
+
+void set_timer(ulong t)
+{
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay(unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	setup_gpt();
+
+	if (usec >= 1000) {	/* if "big" number, spread normalize to secs */
+		tmo = usec / 1000;	/* normalize usec to ticks per sec */
+		tmo *= CONFIG_SYS_HZ;	/* find number of "ticks" to wait */
+		tmo /= 1000;		/* finish normalize. */
+	} else {			/* don't kill prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000*1000);
+	}
+
+	tmp = get_timer(0);		/* get current timestamp */
+	if ((tmo + tmp + 1) < tmp)	/* if overflow time stamp */
+		reset_timer_masked();	/* reset "advancing" timestamp to 0 */
+	else
+		tmo += tmp;		/* else, set stamp wake up time */
+	while (get_timer_masked() < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+void reset_cpu(ulong addr)
+{
+	__REG16(WDOG_BASE) = 4;
+}
diff --git a/cpu/arm_cortexa8/mx51/generic.c b/cpu/arm_cortexa8/mx51/generic.c
index 6f928f6..2512081 100644
--- a/cpu/arm_cortexa8/mx51/generic.c
+++ b/cpu/arm_cortexa8/mx51/generic.c
@@ -206,6 +206,8 @@ unsigned int mxc_get_clock(enum mxc_clock clk)
 		return __get_cspi_clk();
 	case MXC_FEC_CLK:
 		return __decode_pll(PLL1_CLK, CONFIG_MX51_HCLK_FREQ);
+	case MXC_ESDHC_CLK:
+		return __decode_pll(PLL3_CLK, CONFIG_MX51_HCLK_FREQ);
 	default:
 		break;
 	}
diff --git a/drivers/i2c/mxc_i2c.c b/drivers/i2c/mxc_i2c.c
index 7b7d894..eb3460e 100644
--- a/drivers/i2c/mxc_i2c.c
+++ b/drivers/i2c/mxc_i2c.c
@@ -99,7 +99,7 @@ void i2c_init(int speed, int unused)
 #else
 	freq = mxc_get_clock(MXC_IPG_PERCLK);
 #endif
-	For (i = 0; i < 0x1f; i++)
+	for (i = 0; i < 0x1f; i++)
 		if (freq / div[i] <= speed)
 			break;
 
diff --git a/drivers/mmc/Makefile b/drivers/mmc/Makefile
index afb74ae..15c07ca 100644
--- a/drivers/mmc/Makefile
+++ b/drivers/mmc/Makefile
@@ -34,6 +34,7 @@ COBJS-$(CONFIG_MXC_MMC) += mxcmmc.o
 COBJS-$(CONFIG_PXA_MMC) += pxa_mmc.o
 COBJS-$(CONFIG_FSL_MMC) += fsl_mmc.o
 COBJS-$(CONFIG_FSL_MMC) += fsl_esdhc.o
+COBJS-$(CONFIG_IMX_MMC) += imx_esdhc.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/mmc/fsl_mmc.c b/drivers/mmc/fsl_mmc.c
deleted file mode 100644
index 2be9f3e..0000000
--- a/drivers/mmc/fsl_mmc.c
+++ /dev/null
@@ -1,1569 +0,0 @@
-/*
- * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for	list of people who contributed to this
- * project.
- *
- * This	program	is free	software; you can redistribute it and/or
- * modify it under the terms of	the GNU General Public License as
- * published by	the Free Software Foundation; either version 2 of
- * the License,	or (at your option) any later version.
- *
- * This	program	is distributed in the hope that	it will	be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59	Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <common.h>
-#ifdef CONFIG_MMC
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/sd.h>
-#include <linux/mmc/core.h>
-#include <linux/mmc/card.h>
-#include <asm/errno.h>
-#include <part.h>
-#include <asm/arch/sdhc.h>
-#include <linux/types.h>
-
-#define CARD_SUPPORT_BYTE_MODE			(0)
-#define CARD_SUPPORT_SECT_MODE			(1)
-
-#define RETRY_TIMEOUT					(10)
-
-
-extern int sdhc_init();
-
-extern int fat_register_device(block_dev_desc_t *dev_desc, int part_no);
-
-static block_dev_desc_t	mmc_dev;
-
-block_dev_desc_t *mmc_get_dev(int dev)
-{
-	return (block_dev_desc_t *)&mmc_dev;
-}
-
-/*
- * FIXME needs to read cid and csd info	to determine block size
- * and other parameters
- */
-static int mmc_ready;
-static u32 g_Card_Address_Mode;
-static u32 g_Card_rca;
-
-enum states {
-    IDLE,
-    READY,
-    IDENT,
-    STBY,
-    TRAN,
-    DATA,
-    RCV,
-    PRG,
-    DIS,
-    BTST,
-    SLP
-};
-
-static u32 mmc_cmd(struct mmc_command *cmd, u32 opcode,
-		u32 arg, u32 xfer, u32 fmt, u32 write,
-		u32 crc, u32 cmd_check_en);
-static u32 mmc_acmd(struct mmc_command *cmd, u32 opcode,
-		u32 arg, u32 xfer, u32 fmt, u32 write,
-		u32 crc, u32 cmd_check_en);
-static s32 mmc_decode_cid(struct mmc_card *card);
-static s32 mmc_decode_csd(struct mmc_card *card);
-static s32 sd_voltage_validation(void);
-static s32 mmc_voltage_validation(void);
-static s32 mmc_send_cid(struct mmc_card *card);
-static s32 mmc_send_csd(struct mmc_card *card, u32 u32CardRCA);
-static s32 mmc_select_card(u32 card_rca);
-static s32 mmcsd_check_status(u32 card_rca, u32 timeout,
-		u32 card_state, u32 status_bit);
-static s32 mmc_send_relative_addr(u32 *u32CardRCA);
-static s32 mmc_decode_scr(struct mmc_card *card);
-static s32 mmc_send_scr(struct mmc_card *card);
-static s32 mmc_set_relative_addr(u32 u32CardRCA);
-static s32 mmc_app_set_bus_width(s32 width);
-static s32 mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value);
-static s32 mmc_sd_switch(struct mmc_card *card, s32 mode, s32 group,
-						u8 value, u8 *resp);
-
-static u32 mmc_cmd(struct mmc_command *cmd, u32 opcode,
-			u32 arg, u32 xfer, u32 fmt,
-			u32 write, u32 crc, u32 cmd_check_en)
-{
-	struct mmc_command *pCmd = cmd;
-
-	pCmd->cmd.command = opcode;
-	pCmd->cmd.arg =	arg;
-	pCmd->cmd.data_transfer	= xfer;
-	pCmd->cmd.response_format = pCmd->resp.format = fmt;
-	pCmd->cmd.data_present = write;
-	pCmd->cmd.crc_check = crc;
-	pCmd->cmd.cmdindex_check = cmd_check_en;
-
-	if (MMC_READ_MULTIPLE_BLOCK == opcode || \
-		MMC_WRITE_MULTIPLE_BLOCK == opcode) {
-		pCmd->cmd.block_count_enable_check = ENABLE;
-		pCmd->cmd.multi_single_block = MULTIPLE;
-	} else {
-		pCmd->cmd.block_count_enable_check = DISABLE;
-		pCmd->cmd.multi_single_block = SINGLE;
-	}
-
-	if (interface_send_cmd_wait_resp(&(pCmd->cmd))) {
-		debug("interface_send_cmd_wait_resp Failed!\n");
-		return EPERM;
-	}
-
-	interface_read_response(&(pCmd->resp));
-
-	return 0;
-}
-
-static u32 mmc_acmd(struct mmc_command *cmd, u32 opcode,
-			u32 arg, u32 xfer, u32 fmt, u32 write,
-			u32 crc, u32 cmd_check_en)
-{
-	struct mmc_command *pCmd = cmd;
-	struct mmc_command stAPCmd;
-
-	memset(&stAPCmd, 0, sizeof(struct mmc_command));
-
-	/* Send MMC_APP_CMD first to use ACMD */
-	stAPCmd.cmd.command = MMC_APP_CMD;
-	stAPCmd.cmd.arg = (g_Card_rca << 16);
-	stAPCmd.cmd.data_transfer = READ;
-	stAPCmd.cmd.response_format = stAPCmd.resp.format = RESPONSE_48;
-	stAPCmd.cmd.data_present = DATA_PRESENT_NONE;
-	stAPCmd.cmd.crc_check = ENABLE;
-	stAPCmd.cmd.cmdindex_check = ENABLE;
-
-	if (interface_send_cmd_wait_resp(&(stAPCmd.cmd))) {
-		debug("Send MMC_APP_CMD Failed! :(\n");
-		return EPERM;
-	}
-
-	pCmd->cmd.command = opcode;
-	pCmd->cmd.arg =	arg;
-	pCmd->cmd.data_transfer	= xfer;
-	pCmd->cmd.response_format = pCmd->resp.format = fmt;
-	pCmd->cmd.data_present = write;
-	pCmd->cmd.crc_check = crc;
-	pCmd->cmd.cmdindex_check = cmd_check_en;
-
-	if (interface_send_cmd_wait_resp(&(pCmd->cmd))) {
-		debug("interface_send_cmd_wait_resp Failed!, :(\n");
-		return EPERM;
-	}
-
-	interface_read_response(&(pCmd->resp));
-
-	return 0;
-}
-
-int
-/****************************************************/
-mmc_read(ulong src, uchar *dst, int size)
-/****************************************************/
-{
-	struct mmc_command stCmd;
-	u32 u32Offset = src;
-	u32 *pu32Dst = (u32 *)dst;
-	s32 s32Rslt = EPERM;
-	s32 s32ReadRslt	= 0;
-	u32 u32BlkLen = BLK_LEN;
-	u32 u32MultiBlkNum = 0;
-
-	if (!mmc_ready)	{
-		printf("Please initial the Card first\n");
-		return EPERM;
-	}
-
-	if (size == 0)
-		return 0;
-
-	debug("Entry: mmc_read\n");
-
-	debug("src:%08x	dst:%08x size:%d\n", src,	dst, size);
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	if (g_Card_Address_Mode	== CARD_SUPPORT_SECT_MODE) {
-		u32BlkLen = 1;
-		u32Offset /= BLK_LEN;
-	}
-
-	u32MultiBlkNum = (size % BLK_LEN) ? ((size / BLK_LEN) + 1) \
-					 : (size / BLK_LEN);
-
-	if (mmcsd_check_status(g_Card_rca, 96, TRAN, R1_ERROR)) {
-		debug("Can't wait for TRAN state! :(\n");
-		return EPERM;
-	}
-
-	interface_config_block_info(BLK_LEN, u32MultiBlkNum, \
-				(u32)0x00000080);
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			((u32MultiBlkNum > 1) ? MMC_READ_MULTIPLE_BLOCK : MMC_READ_SINGLE_BLOCK),
-			u32Offset,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT,
-			ENABLE,
-			ENABLE);
-
-	if (s32Rslt) {
-		debug("Send MMC_READ_MULTIPLE_BLOCK Failed! :(\n");
-		return EPERM;
-	}
-
-	s32Rslt	= interface_data_read((u32 *)pu32Dst, BLK_LEN * u32MultiBlkNum);
-
-	if (s32Rslt) {
-		debug("interface_data_read Failed! :(\n");
-		return EPERM;
-	}
-
-	if (u32MultiBlkNum > 1) {
-		s32Rslt	= mmc_cmd(&stCmd,
-				MMC_STOP_TRANSMISSION,
-				0,
-				READ,
-				RESPONSE_48,
-				DATA_PRESENT_NONE,
-				ENABLE,
-				ENABLE);
-
-		if (s32Rslt) {
-			debug("Send MMC_STOP_TRANSMISSION Failed! :(\n");
-			return EPERM;
-		}
-	}
-
-	debug("mmc_read	succeed! :)\n");
-
-	debug("Exit: mmc_read\n");
-
-	return s32ReadRslt;
-}
-
-int
-/****************************************************/
-mmc_write(uchar *src, ulong dst, int size)
-/****************************************************/
-{
-	struct mmc_command stCmd;
-	u32 u32Offset = dst;
-	s32 s32Rslt = EPERM;
-	s32 s32WriteRslt = 0;
-	u32 u32BlkLen = BLK_LEN;
-	u32 *pu32Src = (u32 *)src;
-	u32 u32MultiBlkNum = 0;
-
-	debug("Entry: mmc_write\n");
-
-	debug("src:%08x	dst:%08x size:%d\n", src,	dst, size);
-
-	if (!mmc_ready)	{
-		printf("Please initial the Card first\n");
-		return -1;
-	}
-
-	if (size == 0)
-		return 0;
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	if (g_Card_Address_Mode	== CARD_SUPPORT_SECT_MODE) {
-		u32BlkLen = 1;
-		u32Offset /= BLK_LEN;
-	}
-
-	u32MultiBlkNum = (size % BLK_LEN) ? ((size / BLK_LEN) + 1) \
-					 : (size / BLK_LEN);
-
-	if (mmcsd_check_status(g_Card_rca, 96, TRAN, R1_ERROR)) {
-		debug("Can't wait for TRAN state! :(\n");
-		return EPERM;
-	}
-
-	interface_config_block_info(BLK_LEN, u32MultiBlkNum, \
-					(u32)0x00800000);
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			((u32MultiBlkNum > 1) ? MMC_WRITE_MULTIPLE_BLOCK : MMC_WRITE_BLOCK),
-			u32Offset,
-			WRITE,
-			RESPONSE_48,
-			DATA_PRESENT,
-			ENABLE,
-			ENABLE);
-
-	if (s32Rslt) {
-		debug("Send MMC_WRITE_BLOCK Failed! :(\n");
-		return EPERM;
-	}
-
-	s32Rslt	= interface_data_write((u32 *)pu32Src,
-					BLK_LEN * u32MultiBlkNum);
-
-	if (s32Rslt) {
-		debug("interface_data_read Failed! :(\n");
-		return EPERM;
-	}
-
-	if (u32MultiBlkNum > 1) {
-		s32Rslt	= mmc_cmd(&stCmd,
-				MMC_STOP_TRANSMISSION,
-				0,
-				READ,
-				RESPONSE_48,
-				DATA_PRESENT_NONE,
-				ENABLE,
-				ENABLE);
-
-		if (s32Rslt) {
-			debug("Send MMC_STOP_TRANSMISSION Failed! :(\n");
-			return EPERM;
-		}
-	}
-
-	debug("mmc_write succeed! :)\n");
-
-	debug("Exit: mmc_write\n");
-
-	return s32WriteRslt;
-}
-
-ulong
-/****************************************************/
-mmc_bread(int dev, ulong blknr, lbaint_t blkcnt, void *dst)
-/****************************************************/
-{
-	int mmc_block_size = BLK_LEN;
-	ulong src = blknr * mmc_block_size + CONFIG_MMC_BASE;
-
-	if (mmc_read(src, (uchar *)dst, blkcnt * mmc_block_size))
-		return 0;
-	else
-		return blkcnt;
-}
-
-ulong
-/****************************************************/
-mmc_bwrite(int dev, ulong blknr, lbaint_t blkcnt, const void *src)
-/****************************************************/
-{
-	int mmc_block_size = BLK_LEN;
-	ulong dst = blknr * mmc_block_size + CONFIG_MMC_BASE;
-
-	if (mmc_write((uchar *)src, dst, blkcnt * mmc_block_size))
-		return 0;
-	else
-		return blkcnt;
-}
-
-#define	UNSTUFF_BITS(resp, start, size)					\
-	({								\
-		const int __size = size;				\
-		const uint32_t __mask =	(__size	< 32 ? 1 << __size : 0) - 1; \
-		const int32_t __off = 3 - ((start) / 32); \
-		const int32_t __shft = (start) & 31; \
-		uint32_t __res;						\
-									\
-		__res =	resp[__off] >> __shft;				\
-		if (__size + __shft > 32)				\
-			__res |= resp[__off-1] << ((32 - __shft) % 32);	\
-		__res &	__mask;						\
-	})
-
-static const unsigned int tran_exp[] = {
-	10000, 100000, 1000000, 10000000,
-	0, 0, 0, 0
-};
-
-static const unsigned char tran_mant[] = {
-	0,  10, 12, 13, 15, 20, 25, 30,
-	35, 40, 45, 50, 55, 60, 70, 80,
-};
-
-static const unsigned int tacc_exp[] = {
-	1, 10, 100, 1000, 10000, 100000, 1000000, 10000000,
-};
-
-static const unsigned int tacc_mant[] = {
-	0,  10, 12, 13, 15, 20, 25, 30,
-	35, 40, 45, 50, 55, 60, 70, 80,
-};
-
-static s32 mmc_set_blk_len(u32 len)
-{
-	s32 s32Rslt = 0;
-	struct mmc_command stCmd;
-
-	debug("Entry: mmc_set_blk_len\n");
-
-	memset(&stCmd, 0, sizeof(struct mmc_command));
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SET_BLOCKLEN,
-			BLK_LEN,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-
-	if (s32Rslt) {
-		debug("Send MMC_SET_BLOCKLEN Failed! :(\n");
-		return EPERM;
-	}
-
-	debug("Exit: mmc_set_blk_len\n");
-
-	return s32Rslt;
-}
-
-/*
- * Given the decoded CSD structure, decode the raw CID to our CID structure.
- */
-static s32 mmc_decode_cid(struct mmc_card *card)
-{
-	u32 *resp = card->raw_cid;
-
-	debug("Entry: mmc_decode_cid\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return EPERM;
-	}
-
-	memset(&card->cid, 0, sizeof(struct mmc_cid));
-
-	switch (card->type) {
-	case MMC_TYPE_MMC:
-		debug("MMC Card!\n");
-		/*
-		* The selection	of the format here is based upon published
-		* specs	from sandisk and from what people have reported.
-		*/
-		switch (card->csd.mmca_vsn) {
-		case 0:	/* MMC v1.0 - v1.2 */
-		case 1:	/* MMC v1.4	*/
-			card->cid.manfid	= \
-				UNSTUFF_BITS(resp, 104, 24);
-			card->cid.prod_name[0]	= \
-				UNSTUFF_BITS(resp, 96, 8);
-			card->cid.prod_name[1]	= \
-				UNSTUFF_BITS(resp, 88, 8);
-			card->cid.prod_name[2]	= \
-				UNSTUFF_BITS(resp, 80, 8);
-			card->cid.prod_name[3]	= \
-				UNSTUFF_BITS(resp, 72, 8);
-			card->cid.prod_name[4]	= \
-				UNSTUFF_BITS(resp, 64, 8);
-			card->cid.prod_name[5]	= \
-				UNSTUFF_BITS(resp, 56, 8);
-			card->cid.prod_name[6]	= \
-				UNSTUFF_BITS(resp, 48, 8);
-			card->cid.hwrev	= UNSTUFF_BITS(resp, 44, 4);
-			card->cid.fwrev	= UNSTUFF_BITS(resp, 40, 4);
-			card->cid.serial = UNSTUFF_BITS(resp, 16, 24);
-			card->cid.month	= UNSTUFF_BITS(resp, 12, 4);
-			card->cid.year	= \
-				UNSTUFF_BITS(resp, 8,	4) + 1997;
-
-			sprintf((char *)mmc_dev.vendor,
-				"Man %08x \"%c%c%c%c%c%c%c\" Date %02u/%04u",
-				card->cid.manfid,
-				card->cid.prod_name[0],
-				card->cid.prod_name[1],
-				card->cid.prod_name[2],
-				card->cid.prod_name[3],
-				card->cid.prod_name[4],
-				card->cid.prod_name[5],
-				card->cid.prod_name[6],
-				card->cid.month,
-				card->cid.year);
-			sprintf((char *)mmc_dev.revision, "%d.%d",
-					card->cid.hwrev,
-					card->cid.fwrev);
-			sprintf((char *)mmc_dev.product, "%u",
-					card->cid.serial);
-			break;
-		case 2:	/* MMC v2.0 - v2.2 */
-		case 3:	/* MMC v3.1 - v3.3 */
-		case 4:	/* MMC v4 */
-			card->cid.manfid = UNSTUFF_BITS(resp, 120, 8);
-			card->cid.oemid.mmc_id	= \
-				UNSTUFF_BITS(resp, 104, 16);
-			card->cid.prod_name[0]	= \
-				UNSTUFF_BITS(resp, 96, 8);
-			card->cid.prod_name[1]	= \
-				UNSTUFF_BITS(resp, 88, 8);
-			card->cid.prod_name[2]	= \
-				UNSTUFF_BITS(resp, 80, 8);
-			card->cid.prod_name[3]	= \
-				UNSTUFF_BITS(resp, 72, 8);
-			card->cid.prod_name[4]	= \
-				UNSTUFF_BITS(resp, 64, 8);
-			card->cid.prod_name[5]	= \
-				UNSTUFF_BITS(resp, 56, 8);
-			card->cid.serial = UNSTUFF_BITS(resp, 16, 32);
-			card->cid.month	 = UNSTUFF_BITS(resp, 12, 4);
-			card->cid.year	 = \
-				UNSTUFF_BITS(resp, 8, 4) + 1997;
-
-			sprintf((char *)mmc_dev.vendor,
-			"Man %02x OEM %04x \"%c%c%c%c%c%c\" Date %02u/%04u",
-				card->cid.manfid,
-				card->cid.oemid.mmc_id,
-				card->cid.prod_name[0],
-				card->cid.prod_name[1],
-				card->cid.prod_name[2],
-				card->cid.prod_name[3],
-				card->cid.prod_name[4],
-				card->cid.prod_name[5],
-				card->cid.month,
-				card->cid.year);
-			sprintf((char *)mmc_dev.product, "%u",
-					card->cid.serial);
-			sprintf((char *)mmc_dev.revision, "N/A");
-			break;
-		default:
-			printf("MMC card has unknown MMCA version %d\n",
-				card->csd.mmca_vsn);
-			return EPERM;
-		}
-		break;
-
-	case MMC_TYPE_SD:
-		debug("SD Card!\n");
-		card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
-		card->cid.oemid.sd_id[0] = UNSTUFF_BITS(resp, 112, 8);
-		card->cid.oemid.sd_id[1] = UNSTUFF_BITS(resp, 104, 8);
-		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
-		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
-		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
-		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
-		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
-		card->cid.hwrev		= UNSTUFF_BITS(resp, 60, 4);
-		card->cid.fwrev		= UNSTUFF_BITS(resp, 56, 4);
-		card->cid.serial	= UNSTUFF_BITS(resp, 24, 32);
-		card->cid.year		= UNSTUFF_BITS(resp, 12, 8);
-		card->cid.month		= UNSTUFF_BITS(resp, 8,	4);
-		card->cid.year += 2000;	/* SD cards year offset */
-
-		sprintf((char *)mmc_dev.vendor,
-			"Man %02x OEM %c%c \"%c%c%c%c%c\" Date %02u/%04u",
-			card->cid.manfid,
-			card->cid.oemid.sd_id[0],
-			card->cid.oemid.sd_id[1],
-			card->cid.prod_name[0],
-			card->cid.prod_name[1],
-			card->cid.prod_name[2],
-			card->cid.prod_name[3],
-			card->cid.prod_name[4],
-			card->cid.month,
-			card->cid.year);
-		sprintf((char *)mmc_dev.revision, "%d.%d",
-				card->cid.hwrev, card->cid.fwrev);
-		sprintf((char *)mmc_dev.product, "%u",
-				card->cid.serial);
-		break;
-
-	default:
-		printf("unknown card type!\n");
-		return EPERM;
-	}
-
-	printf("%s card.\nVendor: %s\nProduct: %s\nRevision: %s\n",
-	       (IF_TYPE_SD == mmc_dev.if_type) ? "SD" : "MMC", mmc_dev.vendor,
-	       mmc_dev.product, mmc_dev.revision);
-
-	debug("Exit: mmc_decode_cid\n");
-
-	return 0;
-}
-
-/*
- * Given a 128-bit response, decode to our card CSD structure.
- */
-static s32 mmc_decode_csd(struct mmc_card *card)
-{
-	struct mmc_csd *csd = &card->csd;
-	u32 e, m, csd_struct;
-	u32 *resp = card->raw_csd;
-
-	debug("Entry: mmc_decode_csd\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return EPERM;
-	}
-
-	switch (card->type) {
-	case MMC_TYPE_MMC:
-		/*
-		 * We only understand CSD structure v1.1 and v1.2.
-		 * v1.2	has extra information in bits 15, 11 and 10.
-		 */
-		csd_struct = UNSTUFF_BITS(resp,	126, 2);
-		if (csd_struct != 1 && csd_struct != 2)	{
-			printf("unrecognised CSD structure version %d\n",
-				csd_struct);
-			return EPERM;
-		}
-
-		csd->mmca_vsn	 = UNSTUFF_BITS(resp, 122, 4);
-		m = UNSTUFF_BITS(resp, 115, 4);
-		e = UNSTUFF_BITS(resp, 112, 3);
-		csd->tacc_ns   = (tacc_exp[e] * tacc_mant[m] + 9) / 10;
-		csd->tacc_clks = UNSTUFF_BITS(resp, 104, 8) * 100;
-
-		m = UNSTUFF_BITS(resp, 99, 4);
-		e = UNSTUFF_BITS(resp, 96, 3);
-		csd->max_dtr  = tran_exp[e] * tran_mant[m];
-		csd->cmdclass = UNSTUFF_BITS(resp, 84, 12);
-
-		e =	UNSTUFF_BITS(resp, 47, 3);
-		m =	UNSTUFF_BITS(resp, 62, 12);
-		csd->capacity = (1 + m) << (e + 2);
-
-		csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
-		csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
-		csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
-		csd->read_misalign = UNSTUFF_BITS(resp, 77, 1);
-		csd->r2w_factor	= UNSTUFF_BITS(resp, 26, 3);
-		csd->write_blkbits = UNSTUFF_BITS(resp,	22, 4);
-		csd->write_partial = UNSTUFF_BITS(resp,	21, 1);
-
-		mmc_dev.if_type = IF_TYPE_MMC;
-
-		mmc_dev.lba = csd->capacity;
-		mmc_dev.blksz = 1 << csd->read_blkbits;
-		mmc_dev.part_type = PART_TYPE_DOS;
-		mmc_dev.dev = 0;
-		mmc_dev.lun = 0;
-		mmc_dev.type = DEV_TYPE_HARDDISK;
-		mmc_dev.removable = 0;
-		mmc_dev.block_read  = mmc_bread;
-		mmc_dev.block_write = mmc_bwrite;
-
-		break;
-
-	case MMC_TYPE_SD:
-		csd_struct = UNSTUFF_BITS(resp,	126, 2);
-
-		switch (csd_struct) {
-		case 0:
-			m = UNSTUFF_BITS(resp, 115, 4);
-			e = UNSTUFF_BITS(resp, 112, 3);
-			csd->tacc_ns = (tacc_exp[e] * tacc_mant[m] + 9)	/ 10;
-			csd->tacc_clks = UNSTUFF_BITS(resp, 104, 8) * 100;
-
-			m = UNSTUFF_BITS(resp, 99, 4);
-			e = UNSTUFF_BITS(resp, 96, 3);
-			csd->max_dtr = tran_exp[e] * tran_mant[m];
-			csd->cmdclass = UNSTUFF_BITS(resp, 84, 12);
-
-			e = UNSTUFF_BITS(resp, 47, 3);
-			m = UNSTUFF_BITS(resp, 62, 12);
-			csd->capacity = (1 + m) << (e + 2);
-
-			csd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);
-			csd->read_partial = UNSTUFF_BITS(resp, 79, 1);
-			csd->write_misalign = UNSTUFF_BITS(resp, 78, 1);
-			csd->read_misalign = UNSTUFF_BITS(resp,	77, 1);
-			csd->r2w_factor	= UNSTUFF_BITS(resp, 26, 3);
-			csd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);
-			csd->write_partial = UNSTUFF_BITS(resp,	21, 1);
-
-			mmc_dev.if_type = IF_TYPE_SD;
-
-			mmc_dev.lba = csd->capacity;
-			mmc_dev.blksz = 1 << csd->read_blkbits;
-			mmc_dev.part_type = PART_TYPE_DOS;
-			mmc_dev.dev = 0;
-			mmc_dev.lun = 0;
-			mmc_dev.type = DEV_TYPE_HARDDISK;
-			mmc_dev.removable = 0;
-			mmc_dev.block_read  = mmc_bread;
-			mmc_dev.block_write = mmc_bwrite;
-
-			break;
-		case 1:
-			/*
-			 * This	is a block-addressed SDHC card.	Most
-			 * interesting fields are unused and have fixed
-			 * values. To avoid getting tripped by buggy cards,
-			 * we assume those fixed values	ourselves.
-			 */
-			mmc_card_set_blockaddr(card);
-
-			csd->tacc_ns   = 0; /* Unused */
-			csd->tacc_clks = 0; /* Unused */
-
-			m = UNSTUFF_BITS(resp, 99, 4);
-			e = UNSTUFF_BITS(resp, 96, 3);
-			csd->max_dtr  = tran_exp[e] * tran_mant[m];
-			csd->cmdclass = UNSTUFF_BITS(resp, 84, 12);
-
-			m = UNSTUFF_BITS(resp, 48, 22);
-			csd->capacity = (1 + m) << 10;
-
-			csd->read_blkbits = 9;
-			csd->read_partial = 0;
-			csd->write_misalign = 0;
-			csd->read_misalign = 0;
-			csd->r2w_factor	= 4; /*	Unused */
-			csd->write_blkbits = 9;
-			csd->write_partial = 0;
-
-			mmc_dev.if_type = IF_TYPE_SD;
-
-			mmc_dev.lba = csd->capacity;
-			mmc_dev.blksz = 512;
-			mmc_dev.part_type = PART_TYPE_DOS;
-			mmc_dev.dev = 0;
-			mmc_dev.lun = 0;
-			mmc_dev.type = DEV_TYPE_HARDDISK;
-			mmc_dev.removable = 0;
-			mmc_dev.block_read = mmc_bread;
-
-			break;
-		default:
-			printf("unrecognised CSD structure version %d\n",
-					csd_struct);
-			return EPERM;
-		}
-		break;
-
-	default:
-		printf("unknown	card type!\n");
-		return EPERM;
-		}
-
-	debug("Exit: mmc_decode_csd\n");
-
-	return 0;
-}
-
-/*
- * Do SD voltage validation.
- */
-static s32 sd_voltage_validation(void)
-{
-	struct mmc_command stCmd;
-	u32 u32OcrVal =	0;
-	u32 u32VoltageValidation = EPERM;
-	s32 s32Rslt	= EPERM;
-	s32 s32Retries = 0;
-	/* Supported arguments for CMD8 */
-	const u32 sd_if_cmd_arg[SD_IF_CMD_ARG_COUNT] = {
-		SD_IF_HV_COND_ARG,
-		SD_IF_LV_COND_ARG };
-	const u32 sd_ocr_value[SD_OCR_VALUE_COUNT] = {
-		SD_OCR_VALUE_HV_HC,
-		SD_OCR_VALUE_LV_HC,
-		SD_OCR_VALUE_HV_LC };
-
-	debug("Entry: sd_voltage_validation\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	for (s32Retries = 0; s32Retries < SD_IF_CMD_ARG_COUNT; ++s32Retries) {
-		/* Configure CMD55 for SD card */
-		/* This	command	expects	defualt	RCA 0x0000 as argument.*/
-		s32Rslt	= mmc_cmd(&stCmd,
-				SD_SEND_IF_COND,
-				sd_if_cmd_arg[s32Retries],
-				READ,
-				RESPONSE_48,
-				DATA_PRESENT_NONE,
-				ENABLE,
-				ENABLE);
-
-		if (!s32Rslt) {
-			if (sd_if_cmd_arg[s32Retries] == \
-			(stCmd.resp.cmd_rsp0 & sd_if_cmd_arg[s32Retries])) {
-				u32OcrVal = sd_ocr_value[s32Retries];
-			} else {
-				u32OcrVal = 0;
-			}
-			break;
-		}
-	}
-
-	if (s32Rslt) {
-		debug("Card is of SD-1.x spec with LC\n");
-		u32OcrVal = SD_OCR_VALUE_HV_LC;
-	}
-
-	for (s32Retries = RETRY_TIMEOUT; s32Retries; --s32Retries) {
-		/* Configure ACMD41	for	SD card	*/
-		/* This	command	expects	operating voltage range	as argument.*/
-		s32Rslt	= mmc_acmd(&stCmd,
-				SD_APP_OP_COND,
-				u32OcrVal,
-				READ,
-				RESPONSE_48,
-				DATA_PRESENT_NONE,
-				DISABLE,
-				DISABLE);
-
-		/* Issue ACMD41	to SD Memory card to determine OCR value */
-		if (s32Rslt == EPERM) {
-			debug("Send SD_APP_OP_COND Failed! :(\n");
-			break;
-		}
-
-		/* Obtain OCR value	from the response buffer
-		*/
-		u32OcrVal = stCmd.resp.cmd_rsp0;
-
-		/* Check if	card busy bit is cleared or	not	*/
-		if (!(u32OcrVal	& MMC_CARD_BUSY))
-			continue;
-
-		u32VoltageValidation = 0;
-
-		/* Check if volatge	lies in	range or not*/
-		g_Card_Address_Mode = (u32OcrVal & 0x40000000) ? \
-			 CARD_SUPPORT_SECT_MODE : CARD_SUPPORT_BYTE_MODE;
-		break;
-	}
-
-	debug("Exit: sd_voltage_validation\n");
-
-	return u32VoltageValidation;
-}
-
-/*
- * Do SD voltage validation.
- */
-static s32 mmc_voltage_validation(void)
-{
-	struct mmc_command stCmd;
-	u32 u32Respones	= 0;
-	u32 u32VoltageValidation = EPERM;
-	s32 s32Rslt = EPERM;
-	s32 s32Retries = 0;
-
-	debug("Entry: mmc_voltage_validation\n");
-
-	for (s32Retries = RETRY_TIMEOUT; s32Retries; --s32Retries) {
-		s32Rslt	= mmc_cmd(&stCmd,
-				MMC_SEND_OP_COND,
-				(u32)0x40FF8000,
-				READ,
-				RESPONSE_48,
-				DATA_PRESENT_NONE,
-				DISABLE,
-				DISABLE);
-
-		/* Issue CMD55 to SD Memory card*/
-		if (s32Rslt == EPERM) {
-			debug("Send MMC_SEND_OP_COND Failed! :(\n");
-			break;
-		}
-
-		/* Obtain OCR value from the response buffer
-		*/
-		u32Respones = stCmd.resp.cmd_rsp0;
-
-		/* Check if card busy bit is cleared or not */
-		if (!(u32Respones & MMC_CARD_BUSY)) {
-			debug("Card Busy!\n");
-			continue;
-		}
-
-		u32VoltageValidation = 0;
-
-		/* Check if volatge lies in range or not*/
-		if (0x40000000 == (u32Respones & 0x60000000)) {
-			debug("Address_mode: SECT_MODE\n");
-			g_Card_Address_Mode = CARD_SUPPORT_SECT_MODE;
-		} else {
-			debug("Address_mode: BYTE_MODE\n");
-			g_Card_Address_Mode = CARD_SUPPORT_BYTE_MODE;
-		}
-	}
-
-	debug("mmc_voltage_validation succeed! :)\n");
-
-	debug("Exit: mmc_voltage_validation\n");
-
-	return u32VoltageValidation;
-}
-
-static s32 mmc_send_cid(struct mmc_card *card)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-
-	debug("Entry: mmc_send_cid\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return EPERM;
-	}
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_ALL_SEND_CID,
-			0,
-			READ,
-			RESPONSE_136,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			DISABLE);
-
-	/* Issue CMD55 to SD Memory card*/
-	if (s32Rslt) {
-		debug("Send MMC_ALL_SEND_CID Failed! :(\n");
-		return EPERM;
-	}
-
-	/*
-	card->raw_cid[0] = stCmd.resp.cmd_rsp0;
-	card->raw_cid[1] = stCmd.resp.cmd_rsp1;
-	card->raw_cid[2] = stCmd.resp.cmd_rsp2;
-	card->raw_cid[3] = stCmd.resp.cmd_rsp3;
-	*/
-
-	card->raw_cid[0] = (stCmd.resp.cmd_rsp3 << 8) | \
-				(stCmd.resp.cmd_rsp2 >> 24);
-	card->raw_cid[1] = (stCmd.resp.cmd_rsp2 << 8) | \
-				(stCmd.resp.cmd_rsp1 >> 24);
-	card->raw_cid[2] = (stCmd.resp.cmd_rsp1 << 8) | \
-				(stCmd.resp.cmd_rsp0 >> 24);
-	card->raw_cid[3] = stCmd.resp.cmd_rsp0 << 8;
-
-	debug("mmc_send_cid succeed! :)\n");
-
-	debug("Exit: mmc_send_cid\n");
-
-	return 0;
-}
-
-static s32 mmc_send_csd(struct mmc_card *card, u32 u32CardRCA)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-
-	debug("Entry: mmc_send_csd\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return s32Rslt;
-	}
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SEND_CSD,
-			(u32CardRCA << 16),
-			READ,
-			RESPONSE_136,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			DISABLE);
-
-	 /* Issue CMD55 to SD Memory card*/
-	 if (s32Rslt) {
-		debug("Send MMC_SEND_CSD Failed! :(\n");
-		return EPERM;
-	 }
-
-	 /*
-	card->raw_csd[0] = stCmd.resp.cmd_rsp0;
-	card->raw_csd[1] = stCmd.resp.cmd_rsp1;
-	card->raw_csd[2] = stCmd.resp.cmd_rsp2;
-	card->raw_csd[3] = stCmd.resp.cmd_rsp3;
-	*/
-
-	card->raw_csd[0] = (stCmd.resp.cmd_rsp3 << 8) | \
-				(stCmd.resp.cmd_rsp2 >> 24);
-	card->raw_csd[1] = (stCmd.resp.cmd_rsp2 << 8) | \
-				(stCmd.resp.cmd_rsp1 >> 24);
-	card->raw_csd[2] = (stCmd.resp.cmd_rsp1 << 8) | \
-				(stCmd.resp.cmd_rsp0 >> 24);
-	card->raw_csd[3] = stCmd.resp.cmd_rsp0 << 8;
-
-	debug("mmc_send_csd succeed! :)\n");
-
-	debug("Exit: mmc_send_csd\n");
-
-	return 0;
-}
-
-static s32 mmc_select_card(u32 card_rca)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-	u32 u32CardAddr = card_rca << 16;
-
-	debug("Entry: mmcsd_set_data_transfer_mode\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SELECT_CARD,
-			u32CardAddr,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-	if (s32Rslt) {
-		debug("Send MMC_SELECT_CARD Failed! :(\n");
-		return EPERM;
-	}
-
-	debug("Exit mmcsd_set_data_transfer_mode\n");
-
-	return mmcsd_check_status(card_rca, 96, TRAN, R1_ERROR);
-}
-
-static s32 mmcsd_check_status(u32 card_rca, u32 timeout, \
-				u32 card_state, u32 status_bit)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-	s32 s32Retries = 0;
-	u32 u32CardAddr	= card_rca << 16;
-	s32 s32Status =	1;
-
-	debug("Entry: mmcsd_check_status\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	for (s32Retries = 10; s32Retries; --s32Retries)	{
-
-		udelay(timeout);
-
-		s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SEND_STATUS,
-			u32CardAddr,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-		if (s32Rslt) {
-			debug("Send MMC_SEND_STATUS Failed!	:(\n");
-			break;
-		}
-
-		if (stCmd.resp.cmd_rsp0 & status_bit) {
-			debug("R1 Error! :(\n");
-			break;
-		}
-
-		if (R1_CURRENT_STATE(stCmd.resp.cmd_rsp0) == card_state) {
-			debug("Get state! :)\n");
-			s32Status = 0;
-			break;
-		}
-	}
-
-	debug("Exit: mmcsd_check_status\n");
-
-	return s32Status;
-}
-
-static s32 mmc_send_relative_addr(u32 *u32CardRCA)
-{
-	struct mmc_command stCmd;
-	s32 s32Status = 1;
-	s32	s32Rslt	= EPERM;
-
-	debug("Entry: mmc_send_relative_addr\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			SD_SEND_RELATIVE_ADDR,
-			0,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-	if (s32Rslt) {
-		debug("Send SD_SEND_RELATIVE_ADDR Failed! :(\n");
-		return s32Status;
-	}
-
-	*u32CardRCA = (u32)stCmd.resp.cmd_rsp0 >> 16;
-
-	if (R1_CURRENT_STATE(stCmd.resp.cmd_rsp0) != IDENT) {
-		debug("Invalid R1 State! :(\n");
-		return s32Status;
-	}
-
-	debug("Exit: mmc_send_relative_addr\n");
-
-	return 0;
-}
-
-static s32 mmc_set_relative_addr(u32 u32CardRCA)
-{
-	struct mmc_command stCmd;
-	s32	s32Rslt	= EPERM;
-
-	debug("Entry: mmc_set_relative_addr\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	/* Set RCA */
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SET_RELATIVE_ADDR,
-			(u32CardRCA	<< 16),
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-	if (s32Rslt) {
-		debug("Send MMC_SET_RELATIVE_ADDR Failed! :(\n");
-		return 1;
-	}
-
-	if (R1_CURRENT_STATE(stCmd.resp.cmd_rsp0) != IDENT) {
-		debug("Invalid R1 State! :(\n");
-		return 1;
-	}
-
-	debug("Exit: mmc_set_relative_addr\n");
-
-	return 0;
-}
-
-static s32 mmc_send_scr(struct mmc_card *card)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-
-	debug("Entry: mmc_app_send_scr\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return s32Rslt;
-	}
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_acmd(&stCmd,
-			SD_APP_SEND_SCR,
-			0,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-
-	 /* Issue CMD55 to SD Memory card*/
-	 if (s32Rslt) {
-		debug("Send SD_APP_SEND_SCR Failed! :(\n");
-		return EPERM;
-	 }
-
-	card->raw_scr[0] = stCmd.resp.cmd_rsp0;
-	card->raw_scr[1] = stCmd.resp.cmd_rsp1;
-
-	mmc_decode_scr(card);
-
-	debug("mmc_send_scr succeed! :)\n");
-
-	debug("Exit: mmc_app_send_scr\n");
-
-	return 0;
-}
-
-static s32 mmc_decode_scr(struct mmc_card *card)
-{
-	struct sd_scr *scr = &card->scr;
-	unsigned int scr_struct;
-	u32 resp[4];
-
-	resp[3] = card->raw_scr[1];
-	resp[2] = card->raw_scr[0];
-
-	scr_struct = UNSTUFF_BITS(resp, 60, 4);
-	if (scr_struct != 0) {
-		printf("Unrecognised SCR structure version %d\n", scr_struct);
-		return 1;
-	}
-
-	scr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);
-	scr->bus_widths = UNSTUFF_BITS(resp, 48, 4);
-
-	return 0;
-}
-
-static s32 mmc_read_switch(struct mmc_card *card)
-{
-	u8 status[64] = { 0 };
-
-	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
-		return 0;
-
-	if (!(card->csd.cmdclass & CCC_SWITCH)) {
-		printf("card lacks mandatory switch "
-			"function, performance might suffer.\n");
-		return 0;
-	}
-
-	if (mmc_sd_switch(card, 0, 0, 1, status)) {
-		/*
-		 * We all hosts that cannot perform the command
-		 * to fail more gracefully
-		 */
-		printf("problem reading switch "
-			"capabilities, performance might suffer.\n");
-
-		return 1;
-	}
-
-	if (status[13] & 0x02)
-		card->sw_caps.hs_max_dtr = 50000000;
-
-	return 0;
-}
-
-static s32 mmc_sd_switch(struct mmc_card *card, s32 mode, s32 group,
-						u8 value, u8 *resp)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-	u32 u32Args = 0;
-
-	debug("Entry: mmc_sd_switch\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return s32Rslt;
-	}
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	u32Args = mode << 31 | 0x00FFFFFF;
-	u32Args &= ~(0xF << (group * 4));
-	u32Args |= value << (group * 4);
-
-	s32Rslt	= mmc_acmd(&stCmd,
-			SD_SWITCH,
-			u32Args,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT,
-			ENABLE,
-			ENABLE);
-
-	 /* Issue CMD55 to SD Memory card*/
-	 if (s32Rslt) {
-		debug("Send SD_SWITCH Failed! :(\n");
-		return EPERM;
-	 }
-
-	return 0;
-}
-
-static s32 mmc_app_set_bus_width(s32 width)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-
-	debug("Entry: mmc_app_set_bus_width\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	s32Rslt	= mmc_acmd(&stCmd,
-			SD_APP_SET_BUS_WIDTH,
-			width,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-
-	if (s32Rslt) {
-		debug("Send SD_APP_SET_BUS_WIDTH Failed! :(\n");
-		return EPERM;
-	 }
-
-	debug("Exit: mmc_app_set_bus_width\n");
-
-	return 0;
-}
-
-static s32 mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value)
-{
-	struct mmc_command stCmd;
-	s32 s32Rslt = EPERM;
-	u32 u32Args = 0;
-
-	debug("Entry: mmc_sd_switch\n");
-
-	if (!card) {
-		debug("NULL card pointer!\n");
-		return s32Rslt;
-	}
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-
-	u32Args = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
-				(index << 16) | (value << 8) | set;
-
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_SWITCH,
-			u32Args,
-			READ,
-			RESPONSE_48,
-			DATA_PRESENT_NONE,
-			ENABLE,
-			ENABLE);
-
-	/* Issue CMD55 to SD Memory card*/
-	if (s32Rslt) {
-		debug("Send SD_SWITCH Failed! :(\n");
-		return EPERM;
-	}
-
-	debug("Entry: mmc_sd_switch\n");
-
-	return 0;
-}
-
-
-static s32 mmc_init_sd(struct mmc_card *card)
-{
-	u32 u32CardRCA = 0;
-
-	if (mmc_send_cid(card)) {
-		debug("mmcsd_get_cid Failed! :(\n");
-		return 1;
-	}
-
-	if (mmc_send_relative_addr(&u32CardRCA)) {
-		debug("sd_send_relative_addr Failed! :(\n");
-		return 1;
-	}
-
-	if (mmc_send_csd(card, u32CardRCA)) {
-		debug("mmcsd_get_csd Failed! :(\n");
-		return 1;
-	}
-
-	g_Card_rca = u32CardRCA;
-
-	mmc_decode_csd(card);
-	mmc_decode_cid(card);
-
-	/* Enable operating	frequency */
-	interface_configure_clock(OPERATING_FREQ);
-
-	if (mmc_select_card(u32CardRCA)) {
-		debug("mmc_select_card Failed! :(\n");
-		return 1;
-	}
-
-	if (mmcsd_check_status(g_Card_rca, 96, TRAN, R1_ERROR)) {
-		debug("Can't wait for TRAN state! :(\n");
-		return EPERM;
-	}
-
-	if (mmc_set_blk_len(BLK_LEN)) {
-		debug("mmc_set_blk_len Failed! :(\n");
-		return EPERM;
-	}
-
-	/*
-	if (mmc_send_scr(card)) {
-		debug("mmc_send_scr Failed! :(\n");
-		return 1;
-	}
-	*/
-
-	if (mmc_app_set_bus_width(SD_BUS_WIDTH_4)) {
-		/* Try to set 1 bit mode */
-		if (mmc_app_set_bus_width(SD_BUS_WIDTH_1)) {
-			debug("mmc_app_set_bus_width Failed\n");
-			return EPERM;
-		}
-		interface_set_bus_width(SD_BUS_WIDTH_1);
-	} else {
-		interface_set_bus_width(SD_BUS_WIDTH_4);
-	}
-
-	return 0;
-}
-
-static s32 mmc_init_mmc(struct mmc_card *card)
-{
-	u32 u32CardRCA = 1;
-
-	/* mmc init */
-	if (mmc_send_cid(card)) {
-		debug("mmcsd_get_cid Failed! :(\n");
-		return 1;
-	}
-
-	/* Set RCA */
-	if (mmc_set_relative_addr(u32CardRCA)) {
-		debug("mmc_set_relative_addr Failed! :(\n");
-		return 1;
-	}
-
-	if (mmc_send_csd(card, u32CardRCA)) {
-		debug("mmcsd_get_csd Failed! :(\n");
-		return 1;
-	}
-
-	g_Card_rca = u32CardRCA;
-
-	mmc_decode_csd(card);
-	mmc_decode_cid(card);
-
-	/* Enable operating frequency */
-	interface_configure_clock(OPERATING_FREQ);
-
-	if (mmc_select_card(u32CardRCA)) {
-		debug("mmc_select_card Failed! :(\n");
-		return 1;
-	}
-
-	if (mmcsd_check_status(g_Card_rca, 96, TRAN, R1_ERROR)) {
-		debug("Can't wait for TRAN state! :(\n");
-		return EPERM;
-	}
-
-	if (mmc_set_blk_len(BLK_LEN)) {
-		debug("mmc_set_blk_len Failed! :(\n");
-		return 1;
-	}
-
-	if (card->csd.mmca_vsn >= CSD_SPEC_VER_4) {
-		if (mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BUS_WIDTH, EXT_CSD_BUS_WIDTH_4)) {
-			debug("Switch card to 4 bits failed! :(\n");
-			return 1;
-		}
-		interface_set_bus_width(MMC_BUS_WIDTH_4);
-	}
-
-	return 0;
-}
-
-int
-/****************************************************/
-mmc_init(int verbose)
-/****************************************************/
-{
-	struct mmc_command stCmd;
-	s32	s32InitStatus =	-1;
-	struct mmc_card	card;
-	s32	s32Rslt	= EPERM;
-
-	debug("Entry: mmc_init\n");
-
-	memset(&stCmd, 0, sizeof(struct	mmc_command));
-	memset(&card, 0, sizeof(struct mmc_card));
-
-	g_Card_rca = 0;
-
-	/* Reset device	interface type */
-	mmc_dev.if_type	= IF_TYPE_UNKNOWN;
-
-	/* initialize Interface	Controller */
-	sdhc_init();
-
-	/* Software reset to Interface Controller */
-	if (interface_reset()) {
-		debug("interface_reset failed! :(\n");
-		return s32InitStatus;
-	}
-
-	/* Enable Identification Frequency */
-	interface_configure_clock(IDENTIFICATION_FREQ);
-
-	/* Software reset */
-	s32Rslt	= mmc_cmd(&stCmd,
-			MMC_GO_IDLE_STATE,
-			0,
-			READ,
-			RESPONSE_NONE,
-			DATA_PRESENT_NONE,
-			DISABLE,
-			DISABLE);
-
-	if (!sd_voltage_validation()) {
-		debug("SD Card Detected!\n");
-		card.type = MMC_TYPE_SD;
-
-		/* SD init */
-		if (mmc_init_sd(&card)) {
-			debug("mmc_init_sd Failed! :(\n");
-			return s32InitStatus;
-		}
-
-		s32InitStatus = 0;
-		mmc_ready = 1;
-	} else if (!mmc_voltage_validation()) {
-		debug("MMC Card	Detected!\n");
-		card.type = MMC_TYPE_MMC;
-
-		/* mmc init	*/
-		if (mmc_init_mmc(&card)) {
-			debug("mmc_init_mmc Failed! :(\n");
-			return s32InitStatus;
-		}
-
-		s32InitStatus = 0;
-		mmc_ready = 1;
-	} else {
-		mmc_ready = 0;
-		return s32InitStatus;
-	}
-
-	fat_register_device(&mmc_dev, 1); /* partitions start counting with 1 */
-
-	debug("Exit: mmc_init\n");
-
-	return s32InitStatus;
-}
-
-int mmc_ident(block_dev_desc_t *dev)
-{
-	return 0;
-}
-
-int mmc2info(ulong addr)
-{
-	u32 u32BaseAddr = 0;
-
-#if defined(CONFIG_MMC_BASE)
-	u32BaseAddr = CONFIG_MMC_BASE;
-#endif
-
-	if (addr >= CONFIG_MMC_BASE
-	    && addr < CONFIG_MMC_BASE + (mmc_dev.lba * mmc_dev.blksz)) {
-		return 1;
-	}
-	return 0;
-}
-
-#endif /* CONFIG_MMC */
-
diff --git a/drivers/mmc/imx_esdhc.c b/drivers/mmc/imx_esdhc.c
new file mode 100644
index 0000000..776bb1f
--- /dev/null
+++ b/drivers/mmc/imx_esdhc.c
@@ -0,0 +1,448 @@
+/*
+ * Copyright 2007, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the pxa mmc code:
+ * (C) Copyright 2003
+ * Kyle Harris, Nexus Technologies, Inc. kharris@nexus-tech.net
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <command.h>
+#include <hwconfig.h>
+#include <mmc.h>
+#include <part.h>
+#include <malloc.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <fdt_support.h>
+#include <asm/io.h>
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SDHCI_IRQ_EN_BITS		(IRQSTATEN_CC | IRQSTATEN_TC | \
+				IRQSTATEN_BWR | IRQSTATEN_BRR | IRQSTATEN_CINT | \
+				IRQSTATEN_CTOE | IRQSTATEN_CCE | IRQSTATEN_CEBE | \
+				IRQSTATEN_CIE | IRQSTATEN_DTOE | IRQSTATEN_DCE | IRQSTATEN_DEBE)
+
+struct fsl_esdhc {
+	uint	dsaddr;
+	uint	blkattr;
+	uint	cmdarg;
+	uint	xfertyp;
+	uint	cmdrsp0;
+	uint	cmdrsp1;
+	uint	cmdrsp2;
+	uint	cmdrsp3;
+	uint	datport;
+	uint	prsstat;
+	uint	proctl;
+	uint	sysctl;
+	uint	irqstat;
+	uint	irqstaten;
+	uint	irqsigen;
+	uint	autoc12err;
+	uint	hostcapblt;
+	uint	wml;
+	char	reserved1[8];
+	uint	fevt;
+	char	reserved2[168];
+	uint	hostver;
+	char	reserved3[780];
+	uint	scr;
+};
+
+
+static inline void mdelay(unsigned long msec)
+{
+	unsigned long i;
+	for (i = 0; i < msec * 10; i++)
+		udelay(100);
+}
+
+static inline void sdelay(unsigned long sec)
+{
+	unsigned long i;
+	for (i = 0; i < sec * 10; i++)
+		mdelay(100);
+}
+
+/* Return the XFERTYP flags for a given command and data packet */
+uint esdhc_xfertyp(struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	uint xfertyp = 0;
+
+	if (data) {
+		xfertyp |= XFERTYP_DPSEL;
+
+		if (data->blocks > 1) {
+			xfertyp |= XFERTYP_MSBSEL;
+			xfertyp |= XFERTYP_BCEN;
+		}
+
+		if (data->flags & MMC_DATA_READ)
+			xfertyp |= XFERTYP_DTDSEL;
+	}
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		xfertyp |= XFERTYP_CCCEN;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		xfertyp |= XFERTYP_CICEN;
+	if (cmd->resp_type & MMC_RSP_136)
+		xfertyp |= XFERTYP_RSPTYP_136;
+	else if (cmd->resp_type & MMC_RSP_BUSY)
+		xfertyp |= XFERTYP_RSPTYP_48_BUSY;
+	else if (cmd->resp_type & MMC_RSP_PRESENT)
+		xfertyp |= XFERTYP_RSPTYP_48;
+
+	return XFERTYP_CMD(cmd->cmdidx) | xfertyp;
+}
+
+static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
+{
+	uint wml_value;
+	int timeout;
+	u32 tmp;
+	struct fsl_esdhc *regs = mmc->priv;
+
+	wml_value = data->blocksize / 4;
+
+	if (wml_value > 0x80)
+		wml_value = 0x80;
+
+	if (!(data->flags & MMC_DATA_READ)) {
+		if ((readl(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
+			printf("\nThe SD card is locked. Can not write to a locked card.\n\n");
+			return TIMEOUT;
+		}
+		wml_value = wml_value << 16;
+	}
+
+	writel(wml_value, &regs->wml);
+
+	writel(data->blocks << 16 | data->blocksize, &regs->blkattr);
+
+	/* Calculate the timeout period for data transactions */
+	/*
+	timeout = __ilog2(mmc->tran_speed/10);
+	timeout -= 13;
+
+	if (timeout > 14)
+		timeout = 14;
+
+	if (timeout < 0)
+		timeout = 0;
+	*/
+	timeout = 14;
+
+	tmp = (readl(&regs->sysctl) & (~SYSCTL_TIMEOUT_MASK)) | (timeout << 16);
+	writel(tmp, &regs->sysctl);
+
+	return 0;
+}
+
+
+/*
+ * Sends a command out on the bus.  Takes the mmc pointer,
+ * a command pointer, and an optional data pointer.
+ */
+static int
+esdhc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	uint	xfertyp;
+	uint	irqstat;
+	u32	tmp;
+	volatile struct fsl_esdhc *regs = mmc->priv;
+
+	writel(-1, &regs->irqstat);
+
+	sync();
+
+	tmp = readl(&regs->irqstaten) | SDHCI_IRQ_EN_BITS;
+	writel(tmp, &regs->irqstaten);
+
+	/* Wait for the bus to be idle */
+	while ((readl(&regs->prsstat) & PRSSTAT_CICHB) ||
+			(readl(&regs->prsstat) & PRSSTAT_CIDHB))
+			mdelay(1);
+
+	while (readl(&regs->prsstat) & PRSSTAT_DLA);
+
+	/* Wait at least 8 SD clock cycles before the next command */
+	/*
+	 * Note: This is way more than 8 cycles, but 1ms seems to
+	 * resolve timing issues with some cards
+	 */
+	mdelay(10);
+
+	/* Set up for a data transfer if we have one */
+	if (data) {
+		int err;
+
+		err = esdhc_setup_data(mmc, data);
+		if(err)
+			return err;
+	}
+
+	/* Figure out the transfer arguments */
+	xfertyp = esdhc_xfertyp(cmd, data);
+
+	/* Send the command */
+	writel(cmd->cmdarg, &regs->cmdarg);
+	writel(xfertyp, &regs->xfertyp);
+
+	mdelay(10);
+
+	/* Mask all irqs */
+	writel(0, &regs->irqsigen);
+
+	/* Wait for the command to complete */
+	while (!(readl(&regs->irqstat) & IRQSTAT_CC));
+
+	irqstat = readl(&regs->irqstat);
+	writel(irqstat, &regs->irqstat);
+
+	if (irqstat & CMD_ERR)
+		return COMM_ERR;
+
+	if (irqstat & IRQSTAT_CTOE)
+		return TIMEOUT;
+
+	/* Copy the response to the response buffer */
+	if (cmd->resp_type & MMC_RSP_136) {
+		u32 cmdrsp3, cmdrsp2, cmdrsp1, cmdrsp0;
+
+		cmdrsp3 = readl(&regs->cmdrsp3);
+		cmdrsp2 = readl(&regs->cmdrsp2);
+		cmdrsp1 = readl(&regs->cmdrsp1);
+		cmdrsp0 = readl(&regs->cmdrsp0);
+		cmd->response[0] = (cmdrsp3 << 8) | (cmdrsp2 >> 24);
+		cmd->response[1] = (cmdrsp2 << 8) | (cmdrsp1 >> 24);
+		cmd->response[2] = (cmdrsp1 << 8) | (cmdrsp0 >> 24);
+		cmd->response[3] = (cmdrsp0 << 8);
+	} else
+		cmd->response[0] = readl(&regs->cmdrsp0);
+
+	/* Wait until all of the blocks are transferred */
+	if (data) {
+		int i = 0, j = 0;
+		u32 *tmp_ptr = NULL;
+		uint block_size = data->blocksize;
+		uint block_cnt = data->blocks;
+
+		tmp = readl(&regs->irqstaten) | SDHCI_IRQ_EN_BITS;
+		writel(tmp, &regs->irqstaten);
+
+		if (data->flags & MMC_DATA_READ) {
+			tmp_ptr = (u32 *)data->dest;
+
+			for (i = 0; i < (block_cnt); ++i) {
+				while (!(readl(&regs->irqstat) & IRQSTAT_BRR)) 
+					mdelay(1);
+
+				for (j = 0; j < (block_size >> 2); ++j, ++tmp_ptr) {
+					*tmp_ptr = readl(&regs->datport);
+				}
+
+				tmp = readl(&regs->irqstat) & (IRQSTAT_BRR);
+				writel(tmp, &regs->irqstat);
+			}
+		} else {
+			tmp_ptr = (u32 *)data->src;
+
+			for (i = 0; i < (block_cnt); ++i) {
+				while (!(readl(&regs->irqstat) & IRQSTAT_BWR)) 
+					mdelay(1);
+
+				for (j = 0; j < (block_size >> 2); ++j, ++tmp_ptr) {
+					writel(*tmp_ptr, &regs->datport);
+				}
+
+				tmp = readl(&regs->irqstat) & (IRQSTAT_BWR);
+				writel(tmp, &regs->irqstat);
+			}
+		}
+
+		while (!(readl(&regs->irqstat) & IRQSTAT_TC)) ;
+	}
+
+	writel(-1, &regs->irqstat);
+
+	return 0;
+}
+
+void set_sysctl(struct mmc *mmc, uint clock)
+{
+	int sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	int div, pre_div;
+	volatile struct fsl_esdhc *regs = mmc->priv;
+	uint clk;
+	u32 tmp;
+
+	if (sdhc_clk / 16 > clock) {
+		for (pre_div = 2; pre_div < 256; pre_div *= 2)
+			if ((sdhc_clk / pre_div) <= (clock * 16))
+				break;
+	} else
+		pre_div = 2;
+
+	for (div = 1; div <= 16; div++)
+		if ((sdhc_clk / (div * pre_div)) <= clock)
+			break;
+
+	pre_div >>= 1;
+	div -= 1;
+
+	clk = (pre_div << 8) | (div << 4);
+
+	tmp = readl(&regs->sysctl) & (~SYSCTL_SDCLKEN);
+	writel(tmp, &regs->sysctl);
+
+	tmp = (readl(&regs->sysctl) & (~SYSCTL_CLOCK_MASK)) | clk;
+	writel(tmp, &regs->sysctl);
+
+	mdelay(100);
+
+	while (!(readl(&regs->prsstat) & PRSSTAT_SDSTB)) ;
+
+	tmp = readl(&regs->sysctl) | (SYSCTL_SDCLKEN);
+	writel(tmp, &regs->sysctl);
+}
+
+static void esdhc_set_ios(struct mmc *mmc)
+{
+	struct fsl_esdhc *regs = mmc->priv;
+	u32 tmp;
+
+	/* Set the clock speed */
+	set_sysctl(mmc, mmc->clock);
+
+	/* Set the bus width */
+	tmp = readl(&regs->proctl) & (~(PROCTL_DTW_4 | PROCTL_DTW_8));
+	writel(tmp, &regs->proctl);
+
+	if (mmc->bus_width == 4) {
+		tmp = readl(&regs->proctl) | PROCTL_DTW_4;
+		writel(tmp, &regs->proctl);
+	} else if (mmc->bus_width == 8) {
+		tmp = readl(&regs->proctl) | PROCTL_DTW_8;
+		writel(tmp, &regs->proctl);
+	}
+}
+
+static int esdhc_init(struct mmc *mmc)
+{
+	struct fsl_esdhc *regs = mmc->priv;
+	int timeout = 1000;
+	u32 tmp;
+
+	/* Reset the eSDHC by writing 1 to RSTA bit of SYSCTRL Register */
+	tmp = readl(&regs->sysctl) | SYSCTL_RSTA;
+	writel(tmp, &regs->sysctl);
+
+	while (readl(&regs->sysctl) & SYSCTL_RSTA)
+	    mdelay(1);
+
+	/* Set the initial clock speed */
+	set_sysctl(mmc, 400000);
+
+	/* Put the PROCTL reg back to the default */
+	writel(PROCTL_INIT | PROCTL_D3CD, &regs->proctl);
+
+	/* FIXME: For our CINS bit doesn't work. So this section is disabled. */
+
+	while (!(readl(&regs->prsstat) & PRSSTAT_CINS) && --timeout)
+		mdelay(1);
+
+	if (timeout <= 0) {
+		printf("No MMC card detected!\n");
+		return NO_CARD_ERR;
+	}
+
+
+	set_sysctl(mmc, 400000);
+
+	tmp = readl(&regs->sysctl) | SYSCTL_INITA;
+	writel(tmp, &regs->sysctl);
+
+	while (readl(&regs->sysctl) & SYSCTL_INITA)
+		mdelay(1);
+
+	return 0;
+}
+
+#ifndef CONFIG_SYS_FSL_ESDHC_ADDR
+extern u32 *imx_esdhc_base_addr;
+#endif
+
+static int esdhc_initialize(bd_t *bis)
+{
+#ifdef CONFIG_SYS_FSL_ESDHC_ADDR
+	struct fsl_esdhc *regs = (struct fsl_esdhc *)CONFIG_SYS_IMX_ESDHC_ADDR;
+#else
+	struct fsl_esdhc *regs = (struct fsl_esdhc *)imx_esdhc_base_addr;
+#endif
+	struct mmc *mmc;
+	u32 caps;
+
+	mmc = malloc(sizeof(struct mmc));
+
+	sprintf(mmc->name, "FSL_ESDHC");
+	mmc->priv = regs;
+	mmc->send_cmd = esdhc_send_cmd;
+	mmc->set_ios = esdhc_set_ios;
+	mmc->init = esdhc_init;
+
+	/*
+	caps = regs->hostcapblt;
+
+	if (caps & ESDHC_HOSTCAPBLT_VS18)
+		mmc->voltages |= MMC_VDD_165_195;
+	if (caps & ESDHC_HOSTCAPBLT_VS30)
+		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
+	if (caps & ESDHC_HOSTCAPBLT_VS33) {
+		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
+	}
+	*/
+	mmc->voltages = MMC_VDD_35_36 | MMC_VDD_34_35 | MMC_VDD_33_34 |
+			MMC_VDD_32_33 | MMC_VDD_31_32 | MMC_VDD_30_31 |
+			MMC_VDD_29_30 | MMC_VDD_28_29 | MMC_VDD_27_28;
+
+	mmc->host_caps = MMC_MODE_4BIT | MMC_MODE_8BIT;
+
+	if (caps & ESDHC_HOSTCAPBLT_HSS)
+		mmc->host_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+
+	mmc->f_min = 400000;
+	mmc->f_max = MIN(mxc_get_clock(MXC_ESDHC_CLK), 50000000);
+
+	mmc_register(mmc);
+
+	return 0;
+}
+
+int fsl_esdhc_mmc_init(bd_t *bis)
+{
+	return esdhc_initialize(bis);
+}
+
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index b69ce15..dcc9548 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -88,7 +88,7 @@ mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
 	err = mmc_set_blocklen(mmc, mmc->write_bl_len);
 
 	if (err) {
-		printf("set write bl len failed\n\r");
+		puts("set write bl len failed\n\r");
 		return err;
 	}
 
@@ -113,7 +113,7 @@ mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
 	err = mmc_send_cmd(mmc, &cmd, &data);
 
 	if (err) {
-		printf("mmc write failed\n\r");
+		puts("mmc write failed\n\r");
 		return err;
 	}
 
@@ -164,7 +164,7 @@ int mmc_read(struct mmc *mmc, u64 src, uchar *dst, int size)
 	buffer = malloc(blklen);
 
 	if (!buffer) {
-		printf("Could not allocate buffer for MMC read!\n");
+		puts("Could not allocate buffer for MMC read!\n");
 		return -1;
 	}
 
@@ -205,27 +205,56 @@ free_buffer:
 
 static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
 {
+	struct mmc_cmd cmd;
+	struct mmc_data data;
 	int err;
-	int i;
+	int stoperr = 0;
 	struct mmc *mmc = find_mmc_device(dev_num);
+	int blklen;
 
 	if (!mmc)
-		return 0;
+		return -1;
 
-	/* We always do full block reads from the card */
-	err = mmc_set_blocklen(mmc, mmc->read_bl_len);
+	blklen = mmc->read_bl_len;
+
+	err = mmc_set_blocklen(mmc, blklen);
 
 	if (err) {
-		return 0;
+		puts("set read bl len failed\n\r");
+		return err;
 	}
 
-	for (i = start; i < start + blkcnt; i++, dst += mmc->read_bl_len) {
-		err = mmc_read_block(mmc, dst, i);
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
 
-		if (err) {
-			printf("block read failed: %d\n", err);
-			return i - start;
-		}
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * blklen;
+
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.flags = 0;
+
+	data.dest = dst;
+	data.blocks = blkcnt;
+	data.blocksize = blklen;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	if (err) {
+		puts("mmc read failed\n\r");
+		return err;
+	}
+
+	if (blkcnt > 1) {
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		cmd.flags = 0;
+		stoperr = mmc_send_cmd(mmc, &cmd, NULL);
 	}
 
 	return blkcnt;
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
index 6cea1ba..c50758e 100644
--- a/drivers/net/smc911x.c
+++ b/drivers/net/smc911x.c
@@ -3,8 +3,6 @@
  *
  * (c) 2007 Pengutronix, Sascha Hauer <s.hauer@pengutronix.de>
  *
- * (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -36,436 +34,14 @@ u32 pkt_data_pull(struct eth_device *dev, u32 addr) \
 	__attribute__ ((weak, alias ("smc911x_reg_read")));
 void pkt_data_push(struct eth_device *dev, u32 addr, u32 val) \
 	__attribute__ ((weak, alias ("smc911x_reg_write")));
-#ifndef CONFIG_DRIVER_SMC911X_BASE
-#ifdef CONFIG_DRIVER_SMC911X_BASE_VARIABLE
-extern u32 CONFIG_DRIVER_SMC911X_BASE_VARIABLE;
-#define CONFIG_DRIVER_SMC911X_BASE CONFIG_DRIVER_SMC911X_BASE_VARIABLE
-#else
-#error "Please define base constant or variable!"
-#endif
-#endif
-
-#if defined (CONFIG_DRIVER_SMC911X_32_BIT)
-static inline u32 smc911x_reg_read(u32 addr)
-{
-	return *(volatile u32*)addr;
-}
-static inline void smc911x_reg_write(u32 addr, u32 val)
-{
-	*(volatile u32*)addr = val;
-}
-#elif defined (CONFIG_DRIVER_SMC911X_16_BIT)
-static inline u32 smc911x_reg_read(u32 addr)
-{
-	volatile u16 *addr_16 = (u16 *)addr;
-	return ((*addr_16 & 0x0000ffff) | (*(addr_16 + 1) << 16));
-}
-
-static inline void smc911x_reg_write(u32 addr, u32 val)
-{
-	*(volatile u16*)addr = (u16)val;
-	*(volatile u16*)(addr + 2) = (u16)(val >> 16);
-}
-#else
-#error "SMC911X: undefined bus width"
-#endif /* CONFIG_DRIVER_SMC911X_16_BIT */
 
 #define mdelay(n)       udelay((n)*1000)
 
 static void smx911x_handle_mac_address(struct eth_device *dev)
-/* Below are the register offsets and bit definitions
- * of the Lan911x memory space
- */
-#define RX_DATA_FIFO		 (CONFIG_DRIVER_SMC911X_BASE + 0x00)
-
-#define TX_DATA_FIFO		 (CONFIG_DRIVER_SMC911X_BASE + 0x20)
-#define	TX_CMD_A_INT_ON_COMP			0x80000000
-#define	TX_CMD_A_INT_BUF_END_ALGN		0x03000000
-#define	TX_CMD_A_INT_4_BYTE_ALGN		0x00000000
-#define	TX_CMD_A_INT_16_BYTE_ALGN		0x01000000
-#define	TX_CMD_A_INT_32_BYTE_ALGN		0x02000000
-#define	TX_CMD_A_INT_DATA_OFFSET		0x001F0000
-#define	TX_CMD_A_INT_FIRST_SEG			0x00002000
-#define	TX_CMD_A_INT_LAST_SEG			0x00001000
-#define	TX_CMD_A_BUF_SIZE			0x000007FF
-#define	TX_CMD_B_PKT_TAG			0xFFFF0000
-#define	TX_CMD_B_ADD_CRC_DISABLE		0x00002000
-#define	TX_CMD_B_DISABLE_PADDING		0x00001000
-#define	TX_CMD_B_PKT_BYTE_LENGTH		0x000007FF
-
-#define RX_STATUS_FIFO		(CONFIG_DRIVER_SMC911X_BASE + 0x40)
-#define	RX_STS_PKT_LEN				0x3FFF0000
-#define	RX_STS_ES				0x00008000
-#define	RX_STS_BCST				0x00002000
-#define	RX_STS_LEN_ERR				0x00001000
-#define	RX_STS_RUNT_ERR				0x00000800
-#define	RX_STS_MCAST				0x00000400
-#define	RX_STS_TOO_LONG				0x00000080
-#define	RX_STS_COLL				0x00000040
-#define	RX_STS_ETH_TYPE				0x00000020
-#define	RX_STS_WDOG_TMT				0x00000010
-#define	RX_STS_MII_ERR				0x00000008
-#define	RX_STS_DRIBBLING			0x00000004
-#define	RX_STS_CRC_ERR				0x00000002
-#define RX_STATUS_FIFO_PEEK	(CONFIG_DRIVER_SMC911X_BASE + 0x44)
-#define TX_STATUS_FIFO		(CONFIG_DRIVER_SMC911X_BASE + 0x48)
-#define	TX_STS_TAG				0xFFFF0000
-#define	TX_STS_ES				0x00008000
-#define	TX_STS_LOC				0x00000800
-#define	TX_STS_NO_CARR				0x00000400
-#define	TX_STS_LATE_COLL			0x00000200
-#define	TX_STS_MANY_COLL			0x00000100
-#define	TX_STS_COLL_CNT				0x00000078
-#define	TX_STS_MANY_DEFER			0x00000004
-#define	TX_STS_UNDERRUN				0x00000002
-#define	TX_STS_DEFERRED				0x00000001
-#define TX_STATUS_FIFO_PEEK	(CONFIG_DRIVER_SMC911X_BASE + 0x4C)
-#define ID_REV			(CONFIG_DRIVER_SMC911X_BASE + 0x50)
-#define	ID_REV_CHIP_ID				0xFFFF0000  /* RO */
-#define	ID_REV_REV_ID				0x0000FFFF  /* RO */
-
-#define INT_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0x54)
-#define	INT_CFG_INT_DEAS			0xFF000000  /* R/W */
-#define	INT_CFG_INT_DEAS_CLR			0x00004000
-#define	INT_CFG_INT_DEAS_STS			0x00002000
-#define	INT_CFG_IRQ_INT				0x00001000  /* RO */
-#define	INT_CFG_IRQ_EN				0x00000100  /* R/W */
-#define	INT_CFG_IRQ_POL				0x00000010  /* R/W Not Affected by SW Reset */
-#define	INT_CFG_IRQ_TYPE			0x00000001  /* R/W Not Affected by SW Reset */
-
-#define INT_STS			(CONFIG_DRIVER_SMC911X_BASE + 0x58)
-#define	INT_STS_SW_INT				0x80000000  /* R/WC */
-#define	INT_STS_TXSTOP_INT			0x02000000  /* R/WC */
-#define	INT_STS_RXSTOP_INT			0x01000000  /* R/WC */
-#define	INT_STS_RXDFH_INT			0x00800000  /* R/WC */
-#define	INT_STS_RXDF_INT			0x00400000  /* R/WC */
-#define	INT_STS_TX_IOC				0x00200000  /* R/WC */
-#define	INT_STS_RXD_INT				0x00100000  /* R/WC */
-#define	INT_STS_GPT_INT				0x00080000  /* R/WC */
-#define	INT_STS_PHY_INT				0x00040000  /* RO */
-#define	INT_STS_PME_INT				0x00020000  /* R/WC */
-#define	INT_STS_TXSO				0x00010000  /* R/WC */
-#define	INT_STS_RWT				0x00008000  /* R/WC */
-#define	INT_STS_RXE				0x00004000  /* R/WC */
-#define	INT_STS_TXE				0x00002000  /* R/WC */
-/*#define	INT_STS_ERX		0x00001000*/  /* R/WC */
-#define	INT_STS_TDFU				0x00000800  /* R/WC */
-#define	INT_STS_TDFO				0x00000400  /* R/WC */
-#define	INT_STS_TDFA				0x00000200  /* R/WC */
-#define	INT_STS_TSFF				0x00000100  /* R/WC */
-#define	INT_STS_TSFL				0x00000080  /* R/WC */
-/*#define	INT_STS_RXDF		0x00000040*/  /* R/WC */
-#define	INT_STS_RDFO				0x00000040  /* R/WC */
-#define	INT_STS_RDFL				0x00000020  /* R/WC */
-#define	INT_STS_RSFF				0x00000010  /* R/WC */
-#define	INT_STS_RSFL				0x00000008  /* R/WC */
-#define	INT_STS_GPIO2_INT			0x00000004  /* R/WC */
-#define	INT_STS_GPIO1_INT			0x00000002  /* R/WC */
-#define	INT_STS_GPIO0_INT			0x00000001  /* R/WC */
-#define INT_EN			(CONFIG_DRIVER_SMC911X_BASE + 0x5C)
-#define	INT_EN_SW_INT_EN			0x80000000  /* R/W */
-#define	INT_EN_TXSTOP_INT_EN			0x02000000  /* R/W */
-#define	INT_EN_RXSTOP_INT_EN			0x01000000  /* R/W */
-#define	INT_EN_RXDFH_INT_EN			0x00800000  /* R/W */
-/*#define	INT_EN_RXDF_INT_EN		0x00400000*/  /* R/W */
-#define	INT_EN_TIOC_INT_EN			0x00200000  /* R/W */
-#define	INT_EN_RXD_INT_EN			0x00100000  /* R/W */
-#define	INT_EN_GPT_INT_EN			0x00080000  /* R/W */
-#define	INT_EN_PHY_INT_EN			0x00040000  /* R/W */
-#define	INT_EN_PME_INT_EN			0x00020000  /* R/W */
-#define	INT_EN_TXSO_EN				0x00010000  /* R/W */
-#define	INT_EN_RWT_EN				0x00008000  /* R/W */
-#define	INT_EN_RXE_EN				0x00004000  /* R/W */
-#define	INT_EN_TXE_EN				0x00002000  /* R/W */
-/*#define	INT_EN_ERX_EN			0x00001000*/  /* R/W */
-#define	INT_EN_TDFU_EN				0x00000800  /* R/W */
-#define	INT_EN_TDFO_EN				0x00000400  /* R/W */
-#define	INT_EN_TDFA_EN				0x00000200  /* R/W */
-#define	INT_EN_TSFF_EN				0x00000100  /* R/W */
-#define	INT_EN_TSFL_EN				0x00000080  /* R/W */
-/*#define	INT_EN_RXDF_EN			0x00000040*/  /* R/W */
-#define	INT_EN_RDFO_EN				0x00000040  /* R/W */
-#define	INT_EN_RDFL_EN				0x00000020  /* R/W */
-#define	INT_EN_RSFF_EN				0x00000010  /* R/W */
-#define	INT_EN_RSFL_EN				0x00000008  /* R/W */
-#define	INT_EN_GPIO2_INT			0x00000004  /* R/W */
-#define	INT_EN_GPIO1_INT			0x00000002  /* R/W */
-#define	INT_EN_GPIO0_INT			0x00000001  /* R/W */
-
-#define BYTE_TEST		(CONFIG_DRIVER_SMC911X_BASE + 0x64)
-#define FIFO_INT		(CONFIG_DRIVER_SMC911X_BASE + 0x68)
-#define	FIFO_INT_TX_AVAIL_LEVEL			0xFF000000  /* R/W */
-#define	FIFO_INT_TX_STS_LEVEL			0x00FF0000  /* R/W */
-#define	FIFO_INT_RX_AVAIL_LEVEL			0x0000FF00  /* R/W */
-#define	FIFO_INT_RX_STS_LEVEL			0x000000FF  /* R/W */
-
-#define RX_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0x6C)
-#define	RX_CFG_RX_END_ALGN			0xC0000000  /* R/W */
-#define		RX_CFG_RX_END_ALGN4		0x00000000  /* R/W */
-#define		RX_CFG_RX_END_ALGN16		0x40000000  /* R/W */
-#define		RX_CFG_RX_END_ALGN32		0x80000000  /* R/W */
-#define	RX_CFG_RX_DMA_CNT			0x0FFF0000  /* R/W */
-#define	RX_CFG_RX_DUMP				0x00008000  /* R/W */
-#define	RX_CFG_RXDOFF				0x00001F00  /* R/W */
-/*#define	RX_CFG_RXBAD			0x00000001*/  /* R/W */
-
-#define TX_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0x70)
-/*#define	TX_CFG_TX_DMA_LVL		0xE0000000*/	 /* R/W */
-/*#define	TX_CFG_TX_DMA_CNT		0x0FFF0000*/	 /* R/W Self Clearing */
-#define	TX_CFG_TXS_DUMP				0x00008000  /* Self Clearing */
-#define	TX_CFG_TXD_DUMP				0x00004000  /* Self Clearing */
-#define	TX_CFG_TXSAO				0x00000004  /* R/W */
-#define	TX_CFG_TX_ON				0x00000002  /* R/W */
-#define	TX_CFG_STOP_TX				0x00000001  /* Self Clearing */
-
-#define HW_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0x74)
-#define	HW_CFG_TTM				0x00200000  /* R/W */
-#define	HW_CFG_SF				0x00100000  /* R/W */
-#define	HW_CFG_TX_FIF_SZ			0x000F0000  /* R/W */
-#define	HW_CFG_TR				0x00003000  /* R/W */
-#define	HW_CFG_PHY_CLK_SEL			0x00000060  /* R/W */
-#define	HW_CFG_PHY_CLK_SEL_INT_PHY		0x00000000 /* R/W */
-#define	HW_CFG_PHY_CLK_SEL_EXT_PHY		0x00000020 /* R/W */
-#define	HW_CFG_PHY_CLK_SEL_CLK_DIS		0x00000040 /* R/W */
-#define	HW_CFG_SMI_SEL				0x00000010  /* R/W */
-#define	HW_CFG_EXT_PHY_DET			0x00000008  /* RO */
-#define	HW_CFG_EXT_PHY_EN			0x00000004  /* R/W */
-#define	HW_CFG_32_16_BIT_MODE			0x00000004  /* RO */
-#define	HW_CFG_SRST_TO				0x00000002  /* RO */
-#define	HW_CFG_SRST				0x00000001  /* Self Clearing */
-
-#define RX_DP_CTRL		(CONFIG_DRIVER_SMC911X_BASE + 0x78)
-#define	RX_DP_CTRL_RX_FFWD			0x80000000  /* R/W */
-#define	RX_DP_CTRL_FFWD_BUSY			0x80000000  /* RO */
-
-#define RX_FIFO_INF		(CONFIG_DRIVER_SMC911X_BASE + 0x7C)
-#define	 RX_FIFO_INF_RXSUSED			0x00FF0000  /* RO */
-#define	 RX_FIFO_INF_RXDUSED			0x0000FFFF  /* RO */
-
-#define TX_FIFO_INF		(CONFIG_DRIVER_SMC911X_BASE + 0x80)
-#define	TX_FIFO_INF_TSUSED			0x00FF0000  /* RO */
-#define	TX_FIFO_INF_TDFREE			0x0000FFFF  /* RO */
-
-#define PMT_CTRL		(CONFIG_DRIVER_SMC911X_BASE + 0x84)
-#define	PMT_CTRL_PM_MODE			0x00003000  /* Self Clearing */
-#define	PMT_CTRL_PHY_RST			0x00000400  /* Self Clearing */
-#define	PMT_CTRL_WOL_EN				0x00000200  /* R/W */
-#define	PMT_CTRL_ED_EN				0x00000100  /* R/W */
-#define	PMT_CTRL_PME_TYPE			0x00000040  /* R/W Not Affected by SW Reset */
-#define	PMT_CTRL_WUPS				0x00000030  /* R/WC */
-#define	PMT_CTRL_WUPS_NOWAKE			0x00000000  /* R/WC */
-#define	PMT_CTRL_WUPS_ED			0x00000010  /* R/WC */
-#define	PMT_CTRL_WUPS_WOL			0x00000020  /* R/WC */
-#define	PMT_CTRL_WUPS_MULTI			0x00000030  /* R/WC */
-#define	PMT_CTRL_PME_IND			0x00000008  /* R/W */
-#define	PMT_CTRL_PME_POL			0x00000004  /* R/W */
-#define	PMT_CTRL_PME_EN				0x00000002  /* R/W Not Affected by SW Reset */
-#define	PMT_CTRL_READY				0x00000001  /* RO */
-
-#define GPIO_CFG		(CONFIG_DRIVER_SMC911X_BASE + 0x88)
-#define	GPIO_CFG_LED3_EN			0x40000000  /* R/W */
-#define	GPIO_CFG_LED2_EN			0x20000000  /* R/W */
-#define	GPIO_CFG_LED1_EN			0x10000000  /* R/W */
-#define	GPIO_CFG_GPIO2_INT_POL			0x04000000  /* R/W */
-#define	GPIO_CFG_GPIO1_INT_POL			0x02000000  /* R/W */
-#define	GPIO_CFG_GPIO0_INT_POL			0x01000000  /* R/W */
-#define	GPIO_CFG_EEPR_EN			0x00700000  /* R/W */
-#define	GPIO_CFG_GPIOBUF2			0x00040000  /* R/W */
-#define	GPIO_CFG_GPIOBUF1			0x00020000  /* R/W */
-#define	GPIO_CFG_GPIOBUF0			0x00010000  /* R/W */
-#define	GPIO_CFG_GPIODIR2			0x00000400  /* R/W */
-#define	GPIO_CFG_GPIODIR1			0x00000200  /* R/W */
-#define	GPIO_CFG_GPIODIR0			0x00000100  /* R/W */
-#define	GPIO_CFG_GPIOD4				0x00000010  /* R/W */
-#define	GPIO_CFG_GPIOD3				0x00000008  /* R/W */
-#define	GPIO_CFG_GPIOD2				0x00000004  /* R/W */
-#define	GPIO_CFG_GPIOD1				0x00000002  /* R/W */
-#define	GPIO_CFG_GPIOD0				0x00000001  /* R/W */
-
-#define GPT_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0x8C)
-#define	GPT_CFG_TIMER_EN			0x20000000  /* R/W */
-#define	GPT_CFG_GPT_LOAD			0x0000FFFF  /* R/W */
-
-#define GPT_CNT			(CONFIG_DRIVER_SMC911X_BASE + 0x90)
-#define	GPT_CNT_GPT_CNT				0x0000FFFF  /* RO */
-
-#define ENDIAN			(CONFIG_DRIVER_SMC911X_BASE + 0x98)
-#define FREE_RUN		(CONFIG_DRIVER_SMC911X_BASE + 0x9C)
-#define RX_DROP			(CONFIG_DRIVER_SMC911X_BASE + 0xA0)
-#define MAC_CSR_CMD		(CONFIG_DRIVER_SMC911X_BASE + 0xA4)
-#define	 MAC_CSR_CMD_CSR_BUSY			0x80000000  /* Self Clearing */
-#define	 MAC_CSR_CMD_R_NOT_W			0x40000000  /* R/W */
-#define	 MAC_CSR_CMD_CSR_ADDR			0x000000FF  /* R/W */
-
-#define MAC_CSR_DATA		(CONFIG_DRIVER_SMC911X_BASE + 0xA8)
-#define AFC_CFG			(CONFIG_DRIVER_SMC911X_BASE + 0xAC)
-#define		AFC_CFG_AFC_HI			0x00FF0000  /* R/W */
-#define		AFC_CFG_AFC_LO			0x0000FF00  /* R/W */
-#define		AFC_CFG_BACK_DUR		0x000000F0  /* R/W */
-#define		AFC_CFG_FCMULT			0x00000008  /* R/W */
-#define		AFC_CFG_FCBRD			0x00000004  /* R/W */
-#define		AFC_CFG_FCADD			0x00000002  /* R/W */
-#define		AFC_CFG_FCANY			0x00000001  /* R/W */
-
-#define E2P_CMD			(CONFIG_DRIVER_SMC911X_BASE + 0xB0)
-#define		E2P_CMD_EPC_BUSY		0x80000000  /* Self Clearing */
-#define		E2P_CMD_EPC_CMD			0x70000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_READ		0x00000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_EWDS		0x10000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_EWEN		0x20000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_WRITE		0x30000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_WRAL		0x40000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_ERASE		0x50000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_ERAL		0x60000000  /* R/W */
-#define		E2P_CMD_EPC_CMD_RELOAD		0x70000000  /* R/W */
-#define		E2P_CMD_EPC_TIMEOUT		0x00000200  /* RO */
-#define		E2P_CMD_MAC_ADDR_LOADED		0x00000100  /* RO */
-#define		E2P_CMD_EPC_ADDR		0x000000FF  /* R/W */
-
-#define E2P_DATA		(CONFIG_DRIVER_SMC911X_BASE + 0xB4)
-#define	E2P_DATA_EEPROM_DATA			0x000000FF  /* R/W */
-/* end of LAN register offsets and bit definitions */
-
-/* MAC Control and Status registers */
-#define MAC_CR			0x01  /* R/W */
-
-/* MAC_CR - MAC Control Register */
-#define MAC_CR_RXALL			0x80000000
-/* TODO: delete this bit? It is not described in the data sheet. */
-#define MAC_CR_HBDIS			0x10000000
-#define MAC_CR_RCVOWN			0x00800000
-#define MAC_CR_LOOPBK			0x00200000
-#define MAC_CR_FDPX			0x00100000
-#define MAC_CR_MCPAS			0x00080000
-#define MAC_CR_PRMS			0x00040000
-#define MAC_CR_INVFILT			0x00020000
-#define MAC_CR_PASSBAD			0x00010000
-#define MAC_CR_HFILT			0x00008000
-#define MAC_CR_HPFILT			0x00002000
-#define MAC_CR_LCOLL			0x00001000
-#define MAC_CR_BCAST			0x00000800
-#define MAC_CR_DISRTY			0x00000400
-#define MAC_CR_PADSTR			0x00000100
-#define MAC_CR_BOLMT_MASK		0x000000C0
-#define MAC_CR_DFCHK			0x00000020
-#define MAC_CR_TXEN			0x00000008
-#define MAC_CR_RXEN			0x00000004
-
-#define ADDRH			0x02	  /* R/W mask 0x0000FFFFUL */
-#define ADDRL			0x03	  /* R/W mask 0xFFFFFFFFUL */
-#define HASHH			0x04	  /* R/W */
-#define HASHL			0x05	  /* R/W */
-
-#define MII_ACC			0x06	  /* R/W */
-#define MII_ACC_PHY_ADDR		0x0000F800
-#define MII_ACC_MIIRINDA		0x000007C0
-#define MII_ACC_MII_WRITE		0x00000002
-#define MII_ACC_MII_BUSY		0x00000001
-
-#define MII_DATA		0x07	  /* R/W mask 0x0000FFFFUL */
-
-#define FLOW			0x08	  /* R/W */
-#define FLOW_FCPT			0xFFFF0000
-#define FLOW_FCPASS			0x00000004
-#define FLOW_FCEN			0x00000002
-#define FLOW_FCBSY			0x00000001
-
-#define VLAN1			0x09	  /* R/W mask 0x0000FFFFUL */
-#define VLAN1_VTI1			0x0000ffff
-
-#define VLAN2			0x0A	  /* R/W mask 0x0000FFFFUL */
-#define VLAN2_VTI2			0x0000ffff
-
-#define WUFF			0x0B	  /* WO */
-
-#define WUCSR			0x0C	  /* R/W */
-#define WUCSR_GUE			0x00000200
-#define WUCSR_WUFR			0x00000040
-#define WUCSR_MPR			0x00000020
-#define WUCSR_WAKE_EN			0x00000004
-#define WUCSR_MPEN			0x00000002
-
-/* Chip ID values */
-#define CHIP_9115	0x115
-#define CHIP_9116	0x116
-#define CHIP_9117	0x117
-#define CHIP_9118	0x118
-#define CHIP_9215	0x115a
-#define CHIP_9216	0x116a
-#define CHIP_9217	0x117a
-#define CHIP_9218	0x118a
-
-struct chip_id {
-	u16 id;
-	char *name;
-};
-
-static const struct chip_id chip_ids[] =  {
-	{ CHIP_9115, "LAN9115" },
-	{ CHIP_9116, "LAN9116" },
-	{ CHIP_9117, "LAN9117" },
-	{ CHIP_9118, "LAN9118" },
-	{ CHIP_9215, "LAN9215" },
-	{ CHIP_9216, "LAN9216" },
-	{ CHIP_9217, "LAN9217" },
-	{ CHIP_9218, "LAN9218" },
-	{ 0, NULL },
-};
-
-#define DRIVERNAME "smc911x"
-
-u32 smc911x_get_mac_csr(u8 reg)
-{
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
-		;
-	reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | MAC_CSR_CMD_R_NOT_W | reg);
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
-		;
-
-	return reg_read(MAC_CSR_DATA);
-}
-
-void smc911x_set_mac_csr(u8 reg, u32 data)
-{
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
-		;
-	reg_write(MAC_CSR_DATA, data);
-	reg_write(MAC_CSR_CMD, MAC_CSR_CMD_CSR_BUSY | reg);
-	while (reg_read(MAC_CSR_CMD) & MAC_CSR_CMD_CSR_BUSY)
-		;
-}
-
-static int smx911x_handle_mac_address(struct eth_device *dev)
 {
 	unsigned long addrh, addrl;
 	uchar *m = dev->enetaddr;
 
-	/* if the environment has a valid mac address then use it */
-	if ((m[0] | m[1] | m[2] | m[3] | m[4] | m[5])) {
-		addrl = m[0] | m[1] << 8 | m[2] << 16 | m[3] << 24;
-		addrh = m[4] | m[5] << 8;
-		smc911x_set_mac_csr(ADDRH, addrh);
-		smc911x_set_mac_csr(ADDRL, addrl);
-	} else {
-		/* if not, try to get one from the eeprom */
-		addrh = smc911x_get_mac_csr(ADDRH);
-		addrl = smc911x_get_mac_csr(ADDRL);
-
-		m[0] = (addrl       ) & 0xff;
-		m[1] = (addrl >>  8 ) & 0xff;
-		m[2] = (addrl >> 16 ) & 0xff;
-		m[3] = (addrl >> 24 ) & 0xff;
-		m[4] = (addrh       ) & 0xff;
-		m[5] = (addrh >>  8 ) & 0xff;
-
-		/* we get 0xff when there is no eeprom connected */
-		if ((m[0] & m[1] & m[2] & m[3] & m[4] & m[5]) == 0xff) {
-			printf(DRIVERNAME ": no valid mac address in environment "
-				"and no eeprom found\n");
-			return -1;
-		}
-	}
-
 	addrl = m[0] | (m[1] << 8) | (m[2] << 16) | (m[3] << 24);
 	addrh = m[4] | (m[5] << 8);
 	smc911x_set_mac_csr(dev, ADDRL, addrl);
@@ -568,44 +144,27 @@ static void smc911x_enable(struct eth_device *dev)
 
 }
 
-#ifndef CONFIG_NET_MULTI
-int eth_init(bd_t *bd)
-#else
-static int smc911x_init(struct eth_device *dev, bd_t *bd)
-#endif
+static int smc911x_init(struct eth_device *dev, bd_t * bd)
 {
-	printf(DRIVERNAME ": initializing\n");
+	struct chip_id *id = dev->priv;
 
-	if (smc911x_detect_chip(dev))
-		goto err_out;
+	printf(DRIVERNAME ": detected %s controller\n", id->name);
 
 	smc911x_reset(dev);
 
 	/* Configure the PHY, initialize the link state */
 	smc911x_phy_configure(dev);
 
-#ifndef CONFIG_NET_MULTI
-	if (smx911x_handle_mac_address(bd->bi_enetaddr))
-#else
-	if (smx911x_handle_mac_address(dev))
-#endif
-		goto err_out;
+	smx911x_handle_mac_address(dev);
 
 	/* Turn on Tx + Rx */
 	smc911x_enable(dev);
 
 	return 0;
-
-err_out:
-	return -1;
 }
 
-#ifndef CONFIG_NET_MULTI
-int eth_send(volatile void *packet, int length)
-#else
 static int smc911x_send(struct eth_device *dev,
 			volatile void *packet, int length)
-#endif
 {
 	u32 *data = (u32*)packet;
 	u32 tmplen;
@@ -644,20 +203,12 @@ static int smc911x_send(struct eth_device *dev,
 	return -1;
 }
 
-#ifndef CONFIG_NET_MULTI
-void eth_halt(void)
-#else
 static void smc911x_halt(struct eth_device *dev)
-#endif
 {
 	smc911x_reset(dev);
 }
 
-#ifndef CONFIG_NET_MULTI
-int eth_rx(void)
-#else
 static int smc911x_rx(struct eth_device *dev)
-#endif
 {
 	u32 *data = (u32 *)NetRxPackets[0];
 	u32 pktlen, tmplen;
@@ -684,7 +235,6 @@ static int smc911x_rx(struct eth_device *dev)
 	return 0;
 }
 
-#if defined(CONFIG_CMD_NET) && defined(CONFIG_NET_MULTI)
 int smc911x_initialize(u8 dev_num, int base_addr)
 {
 	unsigned long addrl, addrh;
@@ -696,10 +246,15 @@ int smc911x_initialize(u8 dev_num, int base_addr)
 		return 0;
 	}
 	memset(dev, 0, sizeof(*dev));
-	strcpy(dev->name, DRIVERNAME);
 
 	dev->iobase = base_addr;
 
+	/* Try to detect chip. Will fail if not present. */
+	if (smc911x_detect_chip(dev)) {
+		free(dev);
+		return 0;
+	}
+
 	addrh = smc911x_get_mac_csr(dev, ADDRH);
 	addrl = smc911x_get_mac_csr(dev, ADDRL);
 	dev->enetaddr[0] = addrl;
@@ -718,4 +273,3 @@ int smc911x_initialize(u8 dev_num, int base_addr)
 	eth_register(dev);
 	return 0;
 }
-#endif
diff --git a/drivers/net/smc911x.h b/drivers/net/smc911x.h
index 053e330..05e007c 100644
--- a/drivers/net/smc911x.h
+++ b/drivers/net/smc911x.h
@@ -393,6 +393,7 @@ static inline void smc911x_reg_write(struct eth_device *dev,
 #define CHIP_9216	0x116a
 #define CHIP_9217	0x117a
 #define CHIP_9218	0x118a
+#define CHIP_9220	0x9220
 #define CHIP_9221	0x9221
 
 struct chip_id {
@@ -410,6 +411,7 @@ static const struct chip_id chip_ids[] =  {
 	{ CHIP_9216, "LAN9216" },
 	{ CHIP_9217, "LAN9217" },
 	{ CHIP_9218, "LAN9218" },
+	{ CHIP_9220, "LAN9220" },
 	{ CHIP_9221, "LAN9221" },
 	{ 0, NULL },
 };
@@ -441,7 +443,10 @@ static int smc911x_detect_chip(struct eth_device *dev)
 	unsigned long val, i;
 
 	val = smc911x_reg_read(dev, BYTE_TEST);
-	if (val != 0x87654321) {
+	if (val == 0xffffffff) {
+		/* Special case -- no chip present */
+		return -1;
+	} else if (val != 0x87654321) {
 		printf(DRIVERNAME ": Invalid chip endian 0x%08lx\n", val);
 		return -1;
 	}
@@ -455,7 +460,7 @@ static int smc911x_detect_chip(struct eth_device *dev)
 		return -1;
 	}
 
-	printf(DRIVERNAME ": detected %s controller\n", chip_ids[i].name);
+	dev->priv = (void *)&chip_ids[i];
 
 	return 0;
 }
diff --git a/include/asm-arm/arch-mx25/mmc.h b/include/asm-arm/arch-mx25/mmc.h
deleted file mode 100644
index 5f12934..0000000
--- a/include/asm-arm/arch-mx25/mmc.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- *  (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- *  linux/drivers/mmc/mmc.h
- *
- *  Author: Vladimir Shebordaev, Igor Oblakov
- *  Copyright:  MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-#ifndef __MMC_MX25_3STACK_H__
-#define __MMC_MX25_3STACK_H__
-
-#endif /* __MMC_MX51_3STACK_H__ */
diff --git a/include/asm-arm/arch-mx25/sdhc.h b/include/asm-arm/arch-mx25/sdhc.h
deleted file mode 100644
index 5514ad4..0000000
--- a/include/asm-arm/arch-mx25/sdhc.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef SDHC_H
-#define SDHC_H
-
-#include <linux/types.h>
-
-#define ESDHC_SOFTWARE_RESET_DATA ((u32)0x04000000)
-#define ESDHC_SOFTWARE_RESET_CMD  ((u32)0x02000000)
-#define ESDHC_SOFTWARE_RESET      ((u32)0x01000000)
-#define ESDHC_CMD_INHIBIT       0x00000003
-#define ESDHC_SYSCTL_INITA        ((u32)0x08000000)
-#define ESDHC_LITTLE_ENDIAN_MODE  ((u32)0x00000020)
-#define ESDHC_HW_BIG_ENDIAN_MODE  ((u32)0x00000010)
-#define ESDHC_BIG_ENDIAN_MODE     ((u32)0x00000000)
-#define ESDHC_ONE_BIT_SUPPORT     ((u32)0x00000000)
-#define ESDHC_FOUR_BIT_SUPPORT    ((u32)0x00000002)
-#define ESDHC_EIGHT_BIT_SUPPORT   ((u32)0x00000004)
-#define ESDHC_CLOCK_ENABLE 		0x00000007
-#define ESDHC_FREQ_MASK 0xffff0007
-#define ESDHC_SYSCTL_FREQ_MASK    ((u32)0x000FFFF0)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO1   ((u32)0x0000800e)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO1   ((u32)0x00000200)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO2   ((u32)0x00002040)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO2   ((u32)0x00000050)
-#define ESDHC_INTERRUPT_ENABLE    ((u32)0x007f0133)
-#define ESDHC_CLEAR_INTERRUPT     ((u32)0x117f01ff)
-#define ESDHC_SYSCTL_DTOCV_VAL    ((u32)0x000E0000)
-#define ESDHC_IRQSTATEN_DTOESEN   ((u32)0x00100000)
-#define ESDHC_ENDIAN_MODE_MASK    ((u32)0x00000030)
-#define ESDHC_SYSCTRL_RSTC        ((u32)0x02000000)
-#define ESDHC_SYSCTRL_RSTD        ((u32)0x04000000)
-#define ESDHC_CONFIG_BLOCK 0x00010200
-#define ESDHC_OPER_TIMEOUT (96 * 100)
-#define ESDHC_ACMD41_TIMEOUT      (32000)
-#define ESDHC_CMD1_TIMEOUT        (32000)
-#define ESDHC_BLOCK_SHIFT         (16)
-#define ESDHC_CARD_INIT_TIMEOUT   (64)
-
-#define ESDHC_SYSCTL_SDCLKEN_MASK     ((u32)0x00000008)
-#define ESDHC_PRSSTAT_SDSTB_BIT       ((u32)0x00000008)
-#define ESDHC_SYSCTL_INPUT_CLOCK_MASK ((u32)0x00000007)
-
-#define ESDHC_BUS_WIDTH_MASK                    ((u32)0x00000006)
-#define ESDHC_DATA_TRANSFER_SHIFT               (4)
-#define ESDHC_RESPONSE_FORMAT_SHIFT             (16)
-#define ESDHC_DATA_PRESENT_SHIFT                (21)
-#define ESDHC_CRC_CHECK_SHIFT                   (19)
-#define ESDHC_CMD_INDEX_CHECK_SHIFT             (20)
-#define ESDHC_CMD_INDEX_SHIFT                   (24)
-#define ESDHC_BLOCK_COUNT_ENABLE_SHIFT          (1)
-#define ESDHC_MULTI_SINGLE_BLOCK_SELECT_SHIFT   (5)
-#define BLK_LEN                           		(512)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_4       ((u32)0x00000001)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_8       ((u32)0x00000002)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_16      ((u32)0x00000004)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_64      ((u32)0x00000010)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_512     ((u32)0x00000080)
-
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_4      ((u32)0x00010000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_8      ((u32)0x00020000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_16     ((u32)0x00040000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_64     ((u32)0x00100000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_512    ((u32)0x00800000)
-
-#define WRITE_READ_WATER_MARK_LEVEL 0x00800080
-
-/* Present State register bit masks */
-#define ESDHC_PRESENT_STATE_CIHB    ((u32)0x00000001)
-#define ESDHC_PRESENT_STATE_CDIHB   ((u32)0x00000002)
-#define ONE                         (1)
-#define ESDHC_FIFO_SIZE             (128)
-
-#define ESDHC_STATUS_END_CMD_RESP_MSK         ((u32)0x00000001)
-#define ESDHC_STATUS_END_CMD_RESP_TIME_MSK    ((u32)0x000F0001)
-#define ESDHC_STATUS_TIME_OUT_RESP_MSK        ((u32)0x00010000)
-#define ESDHC_STATUS_RESP_CRC_ERR_MSK         ((u32)0x00020000)
-#define ESDHC_STATUS_RESP_CMD_INDEX_ERR_MSK   ((u32)0x00080000)
-#define ESDHC_STATUS_BUF_READ_RDY_MSK         ((u32)0x00000020)
-#define ESDHC_STATUS_BUF_WRITE_RDY_MSK        ((u32)0x00000010)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_DATA_RW_MSK              ((u32)0x00700002)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_TIME_OUT_READ_MASK       ((u32)0x00100000)
-#define ESDHC_STATUS_READ_CRC_ERR_MSK         ((u32)0x00200000)
-#define ESDHC_STATUS_RESP_CMD_END_BIT_ERR_MSK ((u32)0x00040000)
-#define ESDHC_STATUS_RW_DATA_END_BIT_ERR_MSK  ((u32)0x00400000)
-
-#define ESDHC_STATUS_TIME_OUT_READ  (3200)
-#define ESDHC_READ_DATA_TIME_OUT    (3200)
-#define ESDHC_WRITE_DATA_TIME_OUT   (8000)
-
-#define ESDHC_CONFIG_BLOCK_512      ((u32)0x00000200)
-#define ESDHC_CONFIG_BLOCK_64       ((u32)0x00000040)
-#define ESDHC_CONFIG_BLOCK_8        ((u32)0x00000008)
-#define ESDHC_CONFIG_BLOCK_4        ((u32)0x00000004)
-
-#define ESDHC_MAX_BLOCK_COUNT       ((u32)0x0000ffff)
-
-typedef enum {
-	ESDHC1,
-	ESDHC2,
-	ESDHC3
-} esdhc_num_t;
-
-typedef enum {
-	WRITE,
-	READ,
-} xfer_type_t;
-
-typedef enum {
-	RESPONSE_NONE,
-	RESPONSE_136,
-	RESPONSE_48,
-	RESPONSE_48_CHECK_BUSY
-} response_format_t;
-
-
-typedef enum {
-	DATA_PRESENT_NONE,
-	DATA_PRESENT
-} data_present_select;
-
-typedef enum {
-	DISABLE,
-	ENABLE
-} crc_check_enable, cmdindex_check_enable, block_count_enable;
-
-typedef enum {
-	SINGLE,
-	MULTIPLE
-} multi_single_block_select;
-
-typedef struct {
-	u32 command;
-	u32 arg;
-	xfer_type_t data_transfer;
-	response_format_t response_format;
-	data_present_select data_present;
-	crc_check_enable crc_check;
-	cmdindex_check_enable cmdindex_check;
-	block_count_enable block_count_enable_check;
-	multi_single_block_select multi_single_block;
-} esdhc_cmd_t;
-
-typedef struct {
-	response_format_t format;
-	u32 cmd_rsp0;
-	u32 cmd_rsp1;
-	u32 cmd_rsp2;
-	u32 cmd_rsp3;
-} esdhc_resp_t;
-
-typedef enum {
-	BIG_ENDIAN,
-	HALF_WORD_BIG_ENDIAN,
-	LITTLE_ENDIAN
-} endian_mode_t;
-
-typedef enum {
-	OPERATING_FREQ = 20000,   /* in kHz */
-	IDENTIFICATION_FREQ = 400   /* in kHz */
-} sdhc_freq_t;
-
-enum esdhc_data_status {
-	ESDHC_DATA_ERR = 3,
-	ESDHC_DATA_OK = 4
-};
-
-enum esdhc_int_cntr_val {
-	ESDHC_INT_CNTR_END_CD_RESP = 0x4,
-	ESDHC_INT_CNTR_BUF_WR_RDY = 0x8
-};
-
-enum esdhc_reset_status {
-	ESDHC_WRONG_RESET = 0,
-	ESDHC_CORRECT_RESET = 1
-};
-
-typedef enum {
-	WEAK = 0,
-	STRONG = 1
-} esdhc_pullup_t;
-
-extern u32 interface_reset(void);
-extern void interface_configure_clock(sdhc_freq_t);
-extern void interface_read_response(esdhc_resp_t *);
-extern u32 interface_send_cmd_wait_resp(esdhc_cmd_t *);
-extern u32 interface_data_read(u32 *, u32);
-extern void interface_config_block_info(u32, u32, u32);
-extern u32 interface_data_write(u32 *, u32);
-extern void interface_clear_interrupt(void);
-extern void interface_initialization_active(void);
-extern void esdhc_set_cmd_pullup(esdhc_pullup_t pull_up);
-extern void esdhc_soft_reset(u32 mask);
-extern u32 interface_set_bus_width(u32 bus_width);
-/*================================================================================================*/
-#endif  /* ESDHC_H */
diff --git a/include/asm-arm/arch-mx35/mmc.h b/include/asm-arm/arch-mx35/mmc.h
deleted file mode 100644
index 8699f40..0000000
--- a/include/asm-arm/arch-mx35/mmc.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- *  (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- *  linux/drivers/mmc/mmc.h
- *
- *  Author: Vladimir Shebordaev, Igor Oblakov
- *  Copyright:  MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-#ifndef __MMC_MX35_3STACK_H__
-#define __MMC_MX35_3STACK_H__
-
-#endif /* __MMC_MX35_3STACK_H__ */
diff --git a/include/asm-arm/arch-mx35/mx35.h b/include/asm-arm/arch-mx35/mx35.h
index 9d1ae54..45ddc0f 100644
--- a/include/asm-arm/arch-mx35/mx35.h
+++ b/include/asm-arm/arch-mx35/mx35.h
@@ -232,14 +232,47 @@
 
 #ifndef __ASSEMBLER__
 
+
 enum mxc_clock {
 MXC_ARM_CLK = 0,
 MXC_AHB_CLK,
 MXC_IPG_CLK,
 MXC_IPG_PERCLK,
 MXC_UART_CLK,
+MXC_ESDHC_CLK,
+MXC_USB_CLK,
+};
+
+enum plls {
+	MCU_PLL = CCM_BASE_ADDR + CLKCTL_MPCTL,
+	PER_PLL = CCM_BASE_ADDR + CLKCTL_PPCTL,
 };
 
+enum mxc_main_clocks {
+	CPU_CLK,
+	AHB_CLK,
+	IPG_CLK,
+	IPG_PER_CLK,
+	NFC_CLK,
+	USB_CLK,
+	HSP_CLK,
+};
+
+enum mxc_peri_clocks {
+	UART1_BAUD,
+	UART2_BAUD,
+	UART3_BAUD,
+	SSI1_BAUD,
+	SSI2_BAUD,
+	CSI_BAUD,
+	MSHC_CLK,
+	ESDHC1_CLK,
+	ESDHC2_CLK,
+	ESDHC3_CLK,
+	SPDIF_CLK,
+	SPI1_CLK,
+	SPI2_CLK,
+};
 /*!
  * NFMS bit in RCSR register for pagesize of nandflash
  */
diff --git a/include/asm-arm/arch-mx35/sdhc.h b/include/asm-arm/arch-mx35/sdhc.h
deleted file mode 100644
index 5514ad4..0000000
--- a/include/asm-arm/arch-mx35/sdhc.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef SDHC_H
-#define SDHC_H
-
-#include <linux/types.h>
-
-#define ESDHC_SOFTWARE_RESET_DATA ((u32)0x04000000)
-#define ESDHC_SOFTWARE_RESET_CMD  ((u32)0x02000000)
-#define ESDHC_SOFTWARE_RESET      ((u32)0x01000000)
-#define ESDHC_CMD_INHIBIT       0x00000003
-#define ESDHC_SYSCTL_INITA        ((u32)0x08000000)
-#define ESDHC_LITTLE_ENDIAN_MODE  ((u32)0x00000020)
-#define ESDHC_HW_BIG_ENDIAN_MODE  ((u32)0x00000010)
-#define ESDHC_BIG_ENDIAN_MODE     ((u32)0x00000000)
-#define ESDHC_ONE_BIT_SUPPORT     ((u32)0x00000000)
-#define ESDHC_FOUR_BIT_SUPPORT    ((u32)0x00000002)
-#define ESDHC_EIGHT_BIT_SUPPORT   ((u32)0x00000004)
-#define ESDHC_CLOCK_ENABLE 		0x00000007
-#define ESDHC_FREQ_MASK 0xffff0007
-#define ESDHC_SYSCTL_FREQ_MASK    ((u32)0x000FFFF0)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO1   ((u32)0x0000800e)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO1   ((u32)0x00000200)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO2   ((u32)0x00002040)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO2   ((u32)0x00000050)
-#define ESDHC_INTERRUPT_ENABLE    ((u32)0x007f0133)
-#define ESDHC_CLEAR_INTERRUPT     ((u32)0x117f01ff)
-#define ESDHC_SYSCTL_DTOCV_VAL    ((u32)0x000E0000)
-#define ESDHC_IRQSTATEN_DTOESEN   ((u32)0x00100000)
-#define ESDHC_ENDIAN_MODE_MASK    ((u32)0x00000030)
-#define ESDHC_SYSCTRL_RSTC        ((u32)0x02000000)
-#define ESDHC_SYSCTRL_RSTD        ((u32)0x04000000)
-#define ESDHC_CONFIG_BLOCK 0x00010200
-#define ESDHC_OPER_TIMEOUT (96 * 100)
-#define ESDHC_ACMD41_TIMEOUT      (32000)
-#define ESDHC_CMD1_TIMEOUT        (32000)
-#define ESDHC_BLOCK_SHIFT         (16)
-#define ESDHC_CARD_INIT_TIMEOUT   (64)
-
-#define ESDHC_SYSCTL_SDCLKEN_MASK     ((u32)0x00000008)
-#define ESDHC_PRSSTAT_SDSTB_BIT       ((u32)0x00000008)
-#define ESDHC_SYSCTL_INPUT_CLOCK_MASK ((u32)0x00000007)
-
-#define ESDHC_BUS_WIDTH_MASK                    ((u32)0x00000006)
-#define ESDHC_DATA_TRANSFER_SHIFT               (4)
-#define ESDHC_RESPONSE_FORMAT_SHIFT             (16)
-#define ESDHC_DATA_PRESENT_SHIFT                (21)
-#define ESDHC_CRC_CHECK_SHIFT                   (19)
-#define ESDHC_CMD_INDEX_CHECK_SHIFT             (20)
-#define ESDHC_CMD_INDEX_SHIFT                   (24)
-#define ESDHC_BLOCK_COUNT_ENABLE_SHIFT          (1)
-#define ESDHC_MULTI_SINGLE_BLOCK_SELECT_SHIFT   (5)
-#define BLK_LEN                           		(512)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_4       ((u32)0x00000001)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_8       ((u32)0x00000002)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_16      ((u32)0x00000004)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_64      ((u32)0x00000010)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_512     ((u32)0x00000080)
-
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_4      ((u32)0x00010000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_8      ((u32)0x00020000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_16     ((u32)0x00040000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_64     ((u32)0x00100000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_512    ((u32)0x00800000)
-
-#define WRITE_READ_WATER_MARK_LEVEL 0x00800080
-
-/* Present State register bit masks */
-#define ESDHC_PRESENT_STATE_CIHB    ((u32)0x00000001)
-#define ESDHC_PRESENT_STATE_CDIHB   ((u32)0x00000002)
-#define ONE                         (1)
-#define ESDHC_FIFO_SIZE             (128)
-
-#define ESDHC_STATUS_END_CMD_RESP_MSK         ((u32)0x00000001)
-#define ESDHC_STATUS_END_CMD_RESP_TIME_MSK    ((u32)0x000F0001)
-#define ESDHC_STATUS_TIME_OUT_RESP_MSK        ((u32)0x00010000)
-#define ESDHC_STATUS_RESP_CRC_ERR_MSK         ((u32)0x00020000)
-#define ESDHC_STATUS_RESP_CMD_INDEX_ERR_MSK   ((u32)0x00080000)
-#define ESDHC_STATUS_BUF_READ_RDY_MSK         ((u32)0x00000020)
-#define ESDHC_STATUS_BUF_WRITE_RDY_MSK        ((u32)0x00000010)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_DATA_RW_MSK              ((u32)0x00700002)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_TIME_OUT_READ_MASK       ((u32)0x00100000)
-#define ESDHC_STATUS_READ_CRC_ERR_MSK         ((u32)0x00200000)
-#define ESDHC_STATUS_RESP_CMD_END_BIT_ERR_MSK ((u32)0x00040000)
-#define ESDHC_STATUS_RW_DATA_END_BIT_ERR_MSK  ((u32)0x00400000)
-
-#define ESDHC_STATUS_TIME_OUT_READ  (3200)
-#define ESDHC_READ_DATA_TIME_OUT    (3200)
-#define ESDHC_WRITE_DATA_TIME_OUT   (8000)
-
-#define ESDHC_CONFIG_BLOCK_512      ((u32)0x00000200)
-#define ESDHC_CONFIG_BLOCK_64       ((u32)0x00000040)
-#define ESDHC_CONFIG_BLOCK_8        ((u32)0x00000008)
-#define ESDHC_CONFIG_BLOCK_4        ((u32)0x00000004)
-
-#define ESDHC_MAX_BLOCK_COUNT       ((u32)0x0000ffff)
-
-typedef enum {
-	ESDHC1,
-	ESDHC2,
-	ESDHC3
-} esdhc_num_t;
-
-typedef enum {
-	WRITE,
-	READ,
-} xfer_type_t;
-
-typedef enum {
-	RESPONSE_NONE,
-	RESPONSE_136,
-	RESPONSE_48,
-	RESPONSE_48_CHECK_BUSY
-} response_format_t;
-
-
-typedef enum {
-	DATA_PRESENT_NONE,
-	DATA_PRESENT
-} data_present_select;
-
-typedef enum {
-	DISABLE,
-	ENABLE
-} crc_check_enable, cmdindex_check_enable, block_count_enable;
-
-typedef enum {
-	SINGLE,
-	MULTIPLE
-} multi_single_block_select;
-
-typedef struct {
-	u32 command;
-	u32 arg;
-	xfer_type_t data_transfer;
-	response_format_t response_format;
-	data_present_select data_present;
-	crc_check_enable crc_check;
-	cmdindex_check_enable cmdindex_check;
-	block_count_enable block_count_enable_check;
-	multi_single_block_select multi_single_block;
-} esdhc_cmd_t;
-
-typedef struct {
-	response_format_t format;
-	u32 cmd_rsp0;
-	u32 cmd_rsp1;
-	u32 cmd_rsp2;
-	u32 cmd_rsp3;
-} esdhc_resp_t;
-
-typedef enum {
-	BIG_ENDIAN,
-	HALF_WORD_BIG_ENDIAN,
-	LITTLE_ENDIAN
-} endian_mode_t;
-
-typedef enum {
-	OPERATING_FREQ = 20000,   /* in kHz */
-	IDENTIFICATION_FREQ = 400   /* in kHz */
-} sdhc_freq_t;
-
-enum esdhc_data_status {
-	ESDHC_DATA_ERR = 3,
-	ESDHC_DATA_OK = 4
-};
-
-enum esdhc_int_cntr_val {
-	ESDHC_INT_CNTR_END_CD_RESP = 0x4,
-	ESDHC_INT_CNTR_BUF_WR_RDY = 0x8
-};
-
-enum esdhc_reset_status {
-	ESDHC_WRONG_RESET = 0,
-	ESDHC_CORRECT_RESET = 1
-};
-
-typedef enum {
-	WEAK = 0,
-	STRONG = 1
-} esdhc_pullup_t;
-
-extern u32 interface_reset(void);
-extern void interface_configure_clock(sdhc_freq_t);
-extern void interface_read_response(esdhc_resp_t *);
-extern u32 interface_send_cmd_wait_resp(esdhc_cmd_t *);
-extern u32 interface_data_read(u32 *, u32);
-extern void interface_config_block_info(u32, u32, u32);
-extern u32 interface_data_write(u32 *, u32);
-extern void interface_clear_interrupt(void);
-extern void interface_initialization_active(void);
-extern void esdhc_set_cmd_pullup(esdhc_pullup_t pull_up);
-extern void esdhc_soft_reset(u32 mask);
-extern u32 interface_set_bus_width(u32 bus_width);
-/*================================================================================================*/
-#endif  /* ESDHC_H */
diff --git a/include/asm-arm/arch-mx51/mmc.h b/include/asm-arm/arch-mx51/mmc.h
deleted file mode 100644
index 062c568..0000000
--- a/include/asm-arm/arch-mx51/mmc.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/*
- *  (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- *  linux/drivers/mmc/mmc.h
- *
- *  Author: Vladimir Shebordaev, Igor Oblakov
- *  Copyright:  MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
- */
-#ifndef __MMC_MX51_3STACK_H__
-#define __MMC_MX51_3STACK_H__
-
-#endif /* __MMC_MX51_3STACK_H__ */
diff --git a/include/asm-arm/arch-mx51/mx51.h b/include/asm-arm/arch-mx51/mx51.h
index 533919a..1014d41 100644
--- a/include/asm-arm/arch-mx51/mx51.h
+++ b/include/asm-arm/arch-mx51/mx51.h
@@ -407,6 +407,32 @@ MXC_IPG_PERCLK,
 MXC_UART_CLK,
 MXC_CSPI_CLK,
 MXC_FEC_CLK,
+MXC_ESDHC_CLK,
+};
+
+/*
+enum mxc_main_clocks {
+	MXC_CPU_CLK,
+	MXC_AHB_CLK,
+	MXC_IPG_CLK,
+	MXC_IPG_PER_CLK,
+	MXC_DDR_CLK,
+	MXC_NFC_CLK,
+	MXC_USB_CLK,
+};
+*/
+
+enum mxc_peri_clocks {
+	MXC_UART1_BAUD,
+	MXC_UART2_BAUD,
+	MXC_UART3_BAUD,
+	MXC_SSI1_BAUD,
+	MXC_SSI2_BAUD,
+	MXC_CSI_BAUD,
+	MXC_MSTICK1_CLK,
+	MXC_MSTICK2_CLK,
+	MXC_SPI1_CLK,
+	MXC_SPI2_CLK,
 };
 
 extern unsigned int mxc_get_clock(enum mxc_clock clk);
diff --git a/include/asm-arm/arch-mx51/sdhc.h b/include/asm-arm/arch-mx51/sdhc.h
deleted file mode 100644
index 5514ad4..0000000
--- a/include/asm-arm/arch-mx51/sdhc.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef SDHC_H
-#define SDHC_H
-
-#include <linux/types.h>
-
-#define ESDHC_SOFTWARE_RESET_DATA ((u32)0x04000000)
-#define ESDHC_SOFTWARE_RESET_CMD  ((u32)0x02000000)
-#define ESDHC_SOFTWARE_RESET      ((u32)0x01000000)
-#define ESDHC_CMD_INHIBIT       0x00000003
-#define ESDHC_SYSCTL_INITA        ((u32)0x08000000)
-#define ESDHC_LITTLE_ENDIAN_MODE  ((u32)0x00000020)
-#define ESDHC_HW_BIG_ENDIAN_MODE  ((u32)0x00000010)
-#define ESDHC_BIG_ENDIAN_MODE     ((u32)0x00000000)
-#define ESDHC_ONE_BIT_SUPPORT     ((u32)0x00000000)
-#define ESDHC_FOUR_BIT_SUPPORT    ((u32)0x00000002)
-#define ESDHC_EIGHT_BIT_SUPPORT   ((u32)0x00000004)
-#define ESDHC_CLOCK_ENABLE 		0x00000007
-#define ESDHC_FREQ_MASK 0xffff0007
-#define ESDHC_SYSCTL_FREQ_MASK    ((u32)0x000FFFF0)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO1   ((u32)0x0000800e)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO1   ((u32)0x00000200)
-#define ESDHC_SYSCTL_IDENT_FREQ_TO2   ((u32)0x00002040)
-#define ESDHC_SYSCTL_OPERT_FREQ_TO2   ((u32)0x00000050)
-#define ESDHC_INTERRUPT_ENABLE    ((u32)0x007f0133)
-#define ESDHC_CLEAR_INTERRUPT     ((u32)0x117f01ff)
-#define ESDHC_SYSCTL_DTOCV_VAL    ((u32)0x000E0000)
-#define ESDHC_IRQSTATEN_DTOESEN   ((u32)0x00100000)
-#define ESDHC_ENDIAN_MODE_MASK    ((u32)0x00000030)
-#define ESDHC_SYSCTRL_RSTC        ((u32)0x02000000)
-#define ESDHC_SYSCTRL_RSTD        ((u32)0x04000000)
-#define ESDHC_CONFIG_BLOCK 0x00010200
-#define ESDHC_OPER_TIMEOUT (96 * 100)
-#define ESDHC_ACMD41_TIMEOUT      (32000)
-#define ESDHC_CMD1_TIMEOUT        (32000)
-#define ESDHC_BLOCK_SHIFT         (16)
-#define ESDHC_CARD_INIT_TIMEOUT   (64)
-
-#define ESDHC_SYSCTL_SDCLKEN_MASK     ((u32)0x00000008)
-#define ESDHC_PRSSTAT_SDSTB_BIT       ((u32)0x00000008)
-#define ESDHC_SYSCTL_INPUT_CLOCK_MASK ((u32)0x00000007)
-
-#define ESDHC_BUS_WIDTH_MASK                    ((u32)0x00000006)
-#define ESDHC_DATA_TRANSFER_SHIFT               (4)
-#define ESDHC_RESPONSE_FORMAT_SHIFT             (16)
-#define ESDHC_DATA_PRESENT_SHIFT                (21)
-#define ESDHC_CRC_CHECK_SHIFT                   (19)
-#define ESDHC_CMD_INDEX_CHECK_SHIFT             (20)
-#define ESDHC_CMD_INDEX_SHIFT                   (24)
-#define ESDHC_BLOCK_COUNT_ENABLE_SHIFT          (1)
-#define ESDHC_MULTI_SINGLE_BLOCK_SELECT_SHIFT   (5)
-#define BLK_LEN                           		(512)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_4       ((u32)0x00000001)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_8       ((u32)0x00000002)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_16      ((u32)0x00000004)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_64      ((u32)0x00000010)
-#define ESDHC_READ_WATER_MARK_LEVEL_BL_512     ((u32)0x00000080)
-
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_4      ((u32)0x00010000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_8      ((u32)0x00020000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_16     ((u32)0x00040000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_64     ((u32)0x00100000)
-#define ESDHC_WRITE_WATER_MARK_LEVEL_BL_512    ((u32)0x00800000)
-
-#define WRITE_READ_WATER_MARK_LEVEL 0x00800080
-
-/* Present State register bit masks */
-#define ESDHC_PRESENT_STATE_CIHB    ((u32)0x00000001)
-#define ESDHC_PRESENT_STATE_CDIHB   ((u32)0x00000002)
-#define ONE                         (1)
-#define ESDHC_FIFO_SIZE             (128)
-
-#define ESDHC_STATUS_END_CMD_RESP_MSK         ((u32)0x00000001)
-#define ESDHC_STATUS_END_CMD_RESP_TIME_MSK    ((u32)0x000F0001)
-#define ESDHC_STATUS_TIME_OUT_RESP_MSK        ((u32)0x00010000)
-#define ESDHC_STATUS_RESP_CRC_ERR_MSK         ((u32)0x00020000)
-#define ESDHC_STATUS_RESP_CMD_INDEX_ERR_MSK   ((u32)0x00080000)
-#define ESDHC_STATUS_BUF_READ_RDY_MSK         ((u32)0x00000020)
-#define ESDHC_STATUS_BUF_WRITE_RDY_MSK        ((u32)0x00000010)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_DATA_RW_MSK              ((u32)0x00700002)
-#define ESDHC_STATUS_TRANSFER_COMPLETE_MSK    ((u32)0x00000002)
-#define ESDHC_STATUS_TIME_OUT_READ_MASK       ((u32)0x00100000)
-#define ESDHC_STATUS_READ_CRC_ERR_MSK         ((u32)0x00200000)
-#define ESDHC_STATUS_RESP_CMD_END_BIT_ERR_MSK ((u32)0x00040000)
-#define ESDHC_STATUS_RW_DATA_END_BIT_ERR_MSK  ((u32)0x00400000)
-
-#define ESDHC_STATUS_TIME_OUT_READ  (3200)
-#define ESDHC_READ_DATA_TIME_OUT    (3200)
-#define ESDHC_WRITE_DATA_TIME_OUT   (8000)
-
-#define ESDHC_CONFIG_BLOCK_512      ((u32)0x00000200)
-#define ESDHC_CONFIG_BLOCK_64       ((u32)0x00000040)
-#define ESDHC_CONFIG_BLOCK_8        ((u32)0x00000008)
-#define ESDHC_CONFIG_BLOCK_4        ((u32)0x00000004)
-
-#define ESDHC_MAX_BLOCK_COUNT       ((u32)0x0000ffff)
-
-typedef enum {
-	ESDHC1,
-	ESDHC2,
-	ESDHC3
-} esdhc_num_t;
-
-typedef enum {
-	WRITE,
-	READ,
-} xfer_type_t;
-
-typedef enum {
-	RESPONSE_NONE,
-	RESPONSE_136,
-	RESPONSE_48,
-	RESPONSE_48_CHECK_BUSY
-} response_format_t;
-
-
-typedef enum {
-	DATA_PRESENT_NONE,
-	DATA_PRESENT
-} data_present_select;
-
-typedef enum {
-	DISABLE,
-	ENABLE
-} crc_check_enable, cmdindex_check_enable, block_count_enable;
-
-typedef enum {
-	SINGLE,
-	MULTIPLE
-} multi_single_block_select;
-
-typedef struct {
-	u32 command;
-	u32 arg;
-	xfer_type_t data_transfer;
-	response_format_t response_format;
-	data_present_select data_present;
-	crc_check_enable crc_check;
-	cmdindex_check_enable cmdindex_check;
-	block_count_enable block_count_enable_check;
-	multi_single_block_select multi_single_block;
-} esdhc_cmd_t;
-
-typedef struct {
-	response_format_t format;
-	u32 cmd_rsp0;
-	u32 cmd_rsp1;
-	u32 cmd_rsp2;
-	u32 cmd_rsp3;
-} esdhc_resp_t;
-
-typedef enum {
-	BIG_ENDIAN,
-	HALF_WORD_BIG_ENDIAN,
-	LITTLE_ENDIAN
-} endian_mode_t;
-
-typedef enum {
-	OPERATING_FREQ = 20000,   /* in kHz */
-	IDENTIFICATION_FREQ = 400   /* in kHz */
-} sdhc_freq_t;
-
-enum esdhc_data_status {
-	ESDHC_DATA_ERR = 3,
-	ESDHC_DATA_OK = 4
-};
-
-enum esdhc_int_cntr_val {
-	ESDHC_INT_CNTR_END_CD_RESP = 0x4,
-	ESDHC_INT_CNTR_BUF_WR_RDY = 0x8
-};
-
-enum esdhc_reset_status {
-	ESDHC_WRONG_RESET = 0,
-	ESDHC_CORRECT_RESET = 1
-};
-
-typedef enum {
-	WEAK = 0,
-	STRONG = 1
-} esdhc_pullup_t;
-
-extern u32 interface_reset(void);
-extern void interface_configure_clock(sdhc_freq_t);
-extern void interface_read_response(esdhc_resp_t *);
-extern u32 interface_send_cmd_wait_resp(esdhc_cmd_t *);
-extern u32 interface_data_read(u32 *, u32);
-extern void interface_config_block_info(u32, u32, u32);
-extern u32 interface_data_write(u32 *, u32);
-extern void interface_clear_interrupt(void);
-extern void interface_initialization_active(void);
-extern void esdhc_set_cmd_pullup(esdhc_pullup_t pull_up);
-extern void esdhc_soft_reset(u32 mask);
-extern u32 interface_set_bus_width(u32 bus_width);
-/*================================================================================================*/
-#endif  /* ESDHC_H */
diff --git a/include/configs/imx51.h b/include/configs/imx51.h
deleted file mode 100644
index e5ae114..0000000
--- a/include/configs/imx51.h
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * Configuration settings for the MX51-3Stack Freescale board.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <asm/arch/mx51.h>
-
- /* High Level Configuration Options */
-#define CONFIG_ARMV7		1	/* This is armv7 Cortex-A8 CPU core */
-#define CONFIG_L2_OFF
-
-#define CONFIG_MXC		1
-#define CONFIG_MX51_BBG		1	/* in a mx51 */
-#define CONFIG_FLASH_HEADER	1
-#define CONFIG_FLASH_HEADER_OFFSET 0x400
-#define CONFIG_FLASH_HEADER_BARKER 0xB1
-
-#define CONFIG_SKIP_RELOCATE_UBOOT
-
-#define CONFIG_MX51_HCLK_FREQ	24000000	/* RedBoot says 26MHz */
-#define CONFIG_MX51_CLK32	32768
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#define BOARD_LATE_INIT
-/*
- * Disabled for now due to build problems under Debian and a significant
- * increase in the final file size: 144260 vs. 109536 Bytes.
- */
-
-#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
-#define CONFIG_REVISION_TAG		1
-#define CONFIG_SETUP_MEMORY_TAGS	1
-#define CONFIG_INITRD_TAG		1
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
-/* size in bytes reserved for initial data */
-#define CONFIG_SYS_GBL_DATA_SIZE	128
-
-/*
- * Hardware drivers
- */
-#define CONFIG_MX51_UART	1
-#define CONFIG_MX51_UART1	1
-
-/*
- * SPI Configs
- * */
-#define CONFIG_FSL_SF		1
-#define CONFIG_CMD_SPI
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH_IMX_ATMEL	1
-#define CONFIG_SPI_FLASH_CS	1
-#define CONFIG_IMX_SPI
-#define CONFIG_IMX_SPI_PMIC
-#define CONFIG_IMX_SPI_PMIC_CS 0
-
-#define MAX_SPI_BYTES		(64 * 4)
-
-/*
- * MMC Configs
- * */
-
-/*
- * Eth Configs
- */
-#define CONFIG_HAS_ETH1
-#define CONFIG_NET_MULTI 1
-#define CONFIG_MXC_FEC
-#define CONFIG_MII
-#define CONFIG_DISCOVER_PHY
-
-#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
-#define CONFIG_FEC0_PINMUX	-1
-#define CONFIG_FEC0_PHY_ADDR	0x1F
-#define CONFIG_FEC0_MIIBASE 	-1
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-#define CONFIG_BAUDRATE			115200
-#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
-
-/***********************************************************
- * Command definition
- ***********************************************************/
-
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_NET
-
-/* Enable below configure when supporting nand */
-#define CONFIG_CMD_ENV
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_BOOTDELAY	3
-
-#define CONFIG_PRIME	"FEC0"
-
-#define CONFIG_LOADADDR		0x90800000	/* loadaddr env var */
-
-#define	CONFIG_EXTRA_ENV_SETTINGS					\
-		"netdev=eth0\0"						\
-		"ethprime=FEC0\0"					\
-		"uboot_addr=0xa0000000\0"				\
-		"uboot=u-boot.bin\0"			\
-		"kernel=uImage\0"				\
-		"bootargs_base=setenv bootargs console=ttymxc0,115200\0"\
-		"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs "\
-			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0"\
-		"bootcmd=run bootcmd_net\0"				\
-		"bootcmd_net=run bootargs_base bootargs_nfs; "		\
-			"tftpboot ${loadaddr} ${kernel}; bootm\0"	\
-		"load_uboot=tftpboot ${loadaddr} ${uboot}\0"		\
-
-/*
- * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
- * U-Boot, RedBoot and Linux: the ethernet Rx signal is reaching the CS8900A
- * controller inverted. The controller is capable of detecting and correcting
- * this, but it needs 4 network packets for that. Which means, at startup, you
- * will not receive answers to the first 4 packest, unless there have been some
- * broadcasts on the network, or your board is on a hub. Reducing the ARP
- * timeout from default 5 seconds to 200ms we speed up the initial TFTP
- * transfer, should the user wish one, significantly.
- */
-#define CONFIG_ARP_TIMEOUT	200UL
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_PROMPT		"BBG U-Boot > "
-#define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-/* Print Buffer Size */
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
-
-#define CONFIG_SYS_MEMTEST_START	0	/* memtest works on */
-#define CONFIG_SYS_MEMTEST_END		0x10000
-
-#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-
-#define CONFIG_SYS_HZ	CONFIG_MX51_CLK32/* use 32kHz clock as source */
-
-#define CONFIG_CMDLINE_EDITING	1
-
-/*-----------------------------------------------------------------------
- * Stack sizes
- *
- * The stack sizes are set up in start.S using the settings below
- */
-#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
-
-/*-----------------------------------------------------------------------
- * Physical Memory Map
- */
-#define CONFIG_NR_DRAM_BANKS	1
-#define PHYS_SDRAM_1		CSD0_BASE_ADDR
-/* TO1 boards */
-/* #define PHYS_SDRAM_1_SIZE	(128 * 1024 * 1024) */
-#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-#define CONFIG_SYS_NO_FLASH
-
-/*-----------------------------------------------------------------------
- * NAND FLASH driver setup
- */
-#define NAND_MAX_CHIPS         8
-#define CONFIG_SYS_MAX_NAND_DEVICE    1
-#define CONFIG_SYS_NAND_BASE          0x40000000
-
-/* Monitor at beginning of flash */
-#if defined(CONFIG_FSL_SF)
-	#define CONFIG_FSL_ENV_IN_SF
-#elif defined(CONFIG_FSL_MMC)
-	#define CONFIG_FSL_ENV_IN_MMC
-#elif defined(CONFIG_CMD_NAND)
-	#define CONFIG_FSL_ENV_IN_NAND
-#endif
-
-#define CONFIG_ENV_SECT_SIZE    (128 * 1024)
-#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
-
-#if defined(CONFIG_FSL_ENV_IN_NAND)
-	#define CONFIG_ENV_IS_IN_NAND 1
-	#define CONFIG_ENV_OFFSET	0x100000
-#elif defined(CONFIG_FSL_ENV_IN_MMC)
-	#define CONFIG_ENV_IS_IN_MMC	1
-	#define CONFIG_ENV_OFFSET	(768 * 1024)
-#elif defined(CONFIG_FSL_ENV_IN_SF)
-	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
-	#define CONFIG_ENV_IS_EMBEDDED	1
-	#define CONFIG_ENV_SPI_CS		1
-	#define CONFIG_ENV_OFFSET       (768 * 1024)
-#else
-	#define CONFIG_ENV_IS_NOWHERE	1
-#endif
-/*
- * JFFS2 partitions
- */
-#undef CONFIG_JFFS2_CMDLINE
-#define CONFIG_JFFS2_DEV	"nand0"
-
-#endif				/* __CONFIG_H */
diff --git a/include/configs/imx51_android.h b/include/configs/imx51_android.h
deleted file mode 100644
index 55bcfbf..0000000
--- a/include/configs/imx51_android.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
- *
- * Configuration settings for the MX51-3Stack Freescale board.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <asm/arch/mx51.h>
-
- /* High Level Configuration Options */
-#define CONFIG_ARMV7		1	/* This is armv7 Cortex-A8 CPU core */
-#define CONFIG_SYS_APCS_GNU
-#define CONFIG_L2_OFF
-
-#define CONFIG_MXC		1
-#define CONFIG_MX51_BBG		1	/* in a mx51 */
-#define CONFIG_FLASH_HEADER	1
-#define CONFIG_FLASH_HEADER_OFFSET 0x400
-#define CONFIG_FLASH_HEADER_BARKER 0xB1
-
-#define CONFIG_SKIP_RELOCATE_UBOOT
-
-#define CONFIG_MX51_HCLK_FREQ	24000000	/* RedBoot says 26MHz */
-#define CONFIG_MX51_CLK32	32768
-#define CONFIG_DISPLAY_CPUINFO
-#define CONFIG_DISPLAY_BOARDINFO
-
-#define BOARD_LATE_INIT
-/*
- * Disabled for now due to build problems under Debian and a significant
- * increase in the final file size: 144260 vs. 109536 Bytes.
- */
-
-#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
-#define CONFIG_REVISION_TAG		1
-#define CONFIG_SETUP_MEMORY_TAGS	1
-#define CONFIG_INITRD_TAG		1
-
-/*
- * Size of malloc() pool
- */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
-/* size in bytes reserved for initial data */
-#define CONFIG_SYS_GBL_DATA_SIZE	128
-
-/*
- * Hardware drivers
- */
-#define CONFIG_MX51_UART	1
-#define CONFIG_MX51_UART1	1
-
-/*
- * SPI Configs
- * */
-#define CONFIG_FSL_SF		1
-#define CONFIG_CMD_SPI
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH_IMX_ATMEL	1
-#define CONFIG_SPI_FLASH_CS	1
-#define CONFIG_IMX_SPI
-#define CONFIG_IMX_SPI_PMIC
-#define CONFIG_IMX_SPI_PMIC_CS 0
-
-#define MAX_SPI_BYTES		(64 * 4)
-
-/*
- * MMC Configs
- * */
-#define CONFIG_FSL_MMC		1
-
-#define CONFIG_MMC              1
-#define CONFIG_CMD_MMC
-#define CONFIG_DOS_PARTITION	1
-#define CONFIG_CMD_FAT		1
-#define CONFIG_MMC_BASE         0x0
-
-/*
- * Eth Configs
- */
-#define CONFIG_HAS_ETH1
-#define CONFIG_NET_MULTI 1
-#define CONFIG_MXC_FEC
-#define CONFIG_MII
-#define CONFIG_DISCOVER_PHY
-
-#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
-#define CONFIG_FEC0_PINMUX	-1
-#define CONFIG_FEC0_PHY_ADDR	0x1F
-#define CONFIG_FEC0_MIIBASE 	-1
-
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_NET
-
-/*
- * Android support Configs
- */
-#include <asm/arch/keypad.h>
-
-#define CONFIG_FSL_ANDROID
-
-#define CONFIG_MXC_KPD
-#define CONFIG_MXC_KEYMAPPING \
-	{	\
-		KEY_1, KEY_2, KEY_3, KEY_F1, KEY_UP, KEY_F2, \
-		KEY_4, KEY_5, KEY_6, KEY_LEFT, KEY_SELECT, KEY_RIGHT, \
-		KEY_7, KEY_8, KEY_9, KEY_F3, KEY_DOWN, KEY_F4, \
-		KEY_0, KEY_OK, KEY_ESC, KEY_ENTER, KEY_MENU, KEY_BACK, \
-	}
-/*
-	{	\
-		KEY_3,         KEY_2,        KEY_0, KEY_OK, KEY_ESC, KEY_ENTER,
-		KEY_F1,	KEY_4, KEY_6, KEY_5,
-		KEY_LEFT,      KEY_1,        KEY_ , KEY_8,  KEY_9,   KEY_RIGHT,
-	}
-	*/
-#define CONFIG_MXC_KPD_COLMAX 4
-#define CONFIG_MXC_KPD_ROWMAX 4
-#define CONFIG_ANDROID_NORMAL_BOOTARGS "ip=dhcp mem=480M init=/init wvga calibration"
-#define CONFIG_ANDROID_RECOVERY_BOOTARGS "setenv bootargs ${bootargs} root=/dev/mmcblk0p4 ip=dhcp init=/init rootfstype=ext3 wvga"
-#define CONFIG_ANDROID_RECOVERY_BOOTCMD  "run bootargs_base bootargs_android;mmcinit;cp.b 0x100000 ${loadaddr} 0x250000;bootm"
-#define CONFIG_ANDROID_BOOTMOD_DELAY 3
-
-/* allow to overwrite serial and ethaddr */
-#define CONFIG_ENV_OVERWRITE
-#define CONFIG_CONS_INDEX		1
-#define CONFIG_BAUDRATE			115200
-#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
-
-/***********************************************************
- * Command definition
- ***********************************************************/
-
-#include <config_cmd_default.h>
-
-#define CONFIG_CMD_PING
-#define CONFIG_CMD_DHCP
-/* Enable below configure when supporting nand */
-/* #define CONFIG_CMD_NAND */
-#define CONFIG_CMD_ENV
-
-#undef CONFIG_CMD_IMLS
-
-#define CONFIG_BOOTDELAY	3
-
-#define CONFIG_PRIME	"FEC0"
-
-#define CONFIG_LOADADDR		0x90800000	/* loadaddr env var */
-#define CONFIG_RD_LOADADDR	(CONFIG_LOADADDR + 0x300000)
-
-#define	CONFIG_EXTRA_ENV_SETTINGS					\
-		"netdev=eth0\0"						\
-		"ethprime=FEC0\0"					\
-		"uboot_addr=0xa0000000\0"				\
-		"uboot=u-boot.bin\0"			\
-		"kernel=uImage\0"				\
-		"rd_loadaddr=0x90B00000\0"	\
-		"nfsroot=/opt/eldk/arm\0"				\
-		"bootargs_base=setenv bootargs console=ttymxc0,115200\0"\
-		"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs "\
-			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0"\
-		"bootargs_android=setenv bootargs ${bootargs} ip=dhcp mem=480M init=/init wvga calibration\0"	\
-		"bootcmd=run bootcmd_android\0"				\
-		"bootcmd_net=run bootargs_base bootargs_nfs; "		\
-			"tftpboot ${loadaddr} ${kernel}; bootm\0"	\
-		"bootcmd_android=run bootargs_base bootargs_android; "	\
-			"mmcinit;cp.b 0x100000 ${loadaddr} 0x250000; "	\
-			"cp.b 0x400000 ${rd_loadaddr} 0x4B000; "	\
-			"bootm ${loadaddr} ${rd_loadaddr}\0"		\
-		"prg_uboot=tftpboot ${loadaddr} ${uboot}; "		\
-			"protect off ${uboot_addr} 0xa003ffff; "	\
-			"erase ${uboot_addr} 0xa003ffff; "		\
-			"cp.b ${loadaddr} ${uboot_addr} ${filesize}; "	\
-			"setenv filesize; saveenv\0"
-
-/*Support LAN9217*/
-/*
-#define CONFIG_DRIVER_SMC911X	1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE_VARIABLE mx51_io_base_addr
-*/
-
-/*
- * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
- * U-Boot, RedBoot and Linux: the ethernet Rx signal is reaching the CS8900A
- * controller inverted. The controller is capable of detecting and correcting
- * this, but it needs 4 network packets for that. Which means, at startup, you
- * will not receive answers to the first 4 packest, unless there have been some
- * broadcasts on the network, or your board is on a hub. Reducing the ARP
- * timeout from default 5 seconds to 200ms we speed up the initial TFTP
- * transfer, should the user wish one, significantly.
- */
-#define CONFIG_ARP_TIMEOUT	200UL
-
-/*
- * Miscellaneous configurable options
- */
-#define CONFIG_SYS_LONGHELP		/* undef to save memory */
-#define CONFIG_SYS_PROMPT		"BBG U-Boot > "
-#define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
-/* Print Buffer Size */
-#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
-#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
-
-#define CONFIG_SYS_MEMTEST_START	0	/* memtest works on */
-#define CONFIG_SYS_MEMTEST_END		0x10000
-
-#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
-
-#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
-
-#define CONFIG_SYS_HZ	CONFIG_MX51_CLK32/* use 32kHz clock as source */
-
-#define CONFIG_CMDLINE_EDITING	1
-
-/*-----------------------------------------------------------------------
- * Stack sizes
- *
- * The stack sizes are set up in start.S using the settings below
- */
-#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
-
-/*-----------------------------------------------------------------------
- * Physical Memory Map
- */
-#define CONFIG_NR_DRAM_BANKS	1
-#define PHYS_SDRAM_1		CSD0_BASE_ADDR
-/* TO1 boards */
-/* #define PHYS_SDRAM_1_SIZE	(128 * 1024 * 1024) */
-#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
-
-/*-----------------------------------------------------------------------
- * FLASH and environment organization
- */
-#define CONFIG_SYS_NO_FLASH
-
-/*-----------------------------------------------------------------------
- * NAND FLASH driver setup
- */
-#define NAND_MAX_CHIPS         8
-#define CONFIG_SYS_MAX_NAND_DEVICE    1
-#define CONFIG_SYS_NAND_BASE          0x40000000
-
-/* Monitor at beginning of flash */
-#if defined(CONFIG_FSL_SF)
-	#define CONFIG_FSL_ENV_IN_SF
-#elif defined(CONFIG_FSL_MMC)
-	#define CONFIG_FSL_ENV_IN_MMC
-#elif defined(CONFIG_CMD_NAND)
-	#define CONFIG_FSL_ENV_IN_NAND
-#endif
-
-#define CONFIG_ENV_SECT_SIZE    (128 * 1024)
-#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
-
-#if defined(CONFIG_FSL_ENV_IN_NAND)
-	#define CONFIG_ENV_IS_IN_NAND 1
-	#define CONFIG_ENV_OFFSET	0x100000
-#elif defined(CONFIG_FSL_ENV_IN_MMC)
-	#define CONFIG_ENV_IS_IN_MMC	1
-	#define CONFIG_ENV_OFFSET	(768 * 1024)
-#elif defined(CONFIG_FSL_ENV_IN_SF)
-	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
-	#define CONFIG_ENV_SPI_CS		1
-	#define CONFIG_ENV_OFFSET       (768 * 1024)
-#else
-	#define CONFIG_ENV_IS_NOWHERE	1
-#endif
-/*
- * JFFS2 partitions
- */
-#undef CONFIG_JFFS2_CMDLINE
-#define CONFIG_JFFS2_DEV	"nand0"
-
-#endif				/* __CONFIG_H */
diff --git a/include/configs/mx25_3stack.h b/include/configs/mx25_3stack.h
index 93e4b9a..2943479 100644
--- a/include/configs/mx25_3stack.h
+++ b/include/configs/mx25_3stack.h
@@ -96,17 +96,21 @@
 /* #define CONFIG_CMD_SPI */
 /* #define CONFIG_CMD_DATE */
 #define CONFIG_CMD_NAND
+/* #define CONFIG_CMD_MMC */
 
 /*
  * MMC Configs
  * */
 /*
-#define CONFIG_FSL_MMC
-#define CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_DOS_PARTITION
-#define CONFIG_CMD_FAT
-#define CONFIG_MMC_BASE       0x0  */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+#endif
+*/
 
 /* Disabled due to compilation errors in cmd_bootm.c (IMLS seems to require
  * that CONFIG_NO_FLASH is undefined).
@@ -128,9 +132,9 @@
 		"tftpboot 0x81000000 uImage; bootm\0"
 
 /*Support LAN9217*/
-/*#define CONFIG_DRIVER_SMC911X   1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE CS5_BASE*/
+/*#define CONFIG_SMC911X   1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE CS5_BASE*/
 
 /*#define CONFIG_HAS_ETH1*/
 #define CONFIG_CMD_NET
@@ -189,13 +193,8 @@
 #endif
 
 /* Monitor at beginning of flash */
-#if defined(CONFIG_FSL_SF)
-	#define CONFIG_FSL_ENV_IN_SF
-#elif defined(CONFIG_FSL_MMC)
-	#define CONFIG_FSL_ENV_IN_MMC
-#elif defined(CONFIG_CMD_NAND)
-	#define CONFIG_FSL_ENV_IN_NAND
-#endif
+/* #define CONFIG_FSL_ENV_IN_MMC */
+#define CONFIG_FSL_ENV_IN_NAND
 
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
@@ -206,10 +205,6 @@
 #elif defined(CONFIG_FSL_ENV_IN_MMC)
 	#define CONFIG_ENV_IS_IN_MMC	1
 	#define CONFIG_ENV_OFFSET	(768 * 1024)
-#elif defined(CONFIG_FSL_ENV_IN_SF)
-	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
-	#define CONFIG_ENV_SPI_CS		1
-	#define CONFIG_ENV_OFFSET	(768 * 1024)
 #else
 	#define CONFIG_ENV_IS_NOWHERE	1
 #endif
diff --git a/include/configs/mx31_3stack.h b/include/configs/mx31_3stack.h
index e7b6f89..d7629b2 100644
--- a/include/configs/mx31_3stack.h
+++ b/include/configs/mx31_3stack.h
@@ -50,9 +50,8 @@
 /*
  * Hardware drivers
  */
-
-#define CONFIG_MX31_UART	1
-#define CONFIG_SYS_MX31_UART1		1
+#define CONFIG_MXC_UART	1
+#define CONFIG_SYS_MX31_UART1   1
 
 #define CONFIG_MXC_SPI		1
 
@@ -99,9 +98,10 @@
 		"tftpboot ${loadaddr} ${tftp_server}:${kernel}; bootm\0"
 
 /* configure for smc91xx debug board ethernet */
-#define CONFIG_DRIVER_SMC911X          1
-#define CONFIG_DRIVER_SMC911X_16_BIT   1
-#define CONFIG_DRIVER_SMC911X_BASE     CS5_BASE
+#define CONFIG_NET_MULTI
+#define CONFIG_SMC911X          1
+#define CONFIG_SMC911X_16_BIT   1
+#define CONFIG_SMC911X_BASE     CS5_BASE
 
 #define CONFIG_ARP_TIMEOUT	200UL
 
diff --git a/include/configs/mx35_3stack.h b/include/configs/mx35_3stack.h
index e0181d1..4140a86 100644
--- a/include/configs/mx35_3stack.h
+++ b/include/configs/mx35_3stack.h
@@ -90,6 +90,7 @@
 
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
 
 #define CONFIG_BOOTDELAY	3
 
@@ -115,9 +116,9 @@
 			"setenv filesize; saveenv\0"
 
 /*Support LAN9217*/
-#define CONFIG_DRIVER_SMC911X	1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE CS5_BASE_ADDR
+#define CONFIG_SMC911X		1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE CS5_BASE_ADDR
 
 #define CONFIG_HAS_ETH1
 #define CONFIG_NET_MULTI 1
diff --git a/include/configs/mx35_3stack_mmc.h b/include/configs/mx35_3stack_mmc.h
index 1676004..e1d5d75 100644
--- a/include/configs/mx35_3stack_mmc.h
+++ b/include/configs/mx35_3stack_mmc.h
@@ -86,6 +86,8 @@
 /*#define CONFIG_CMD_SPI*/
 /*#define CONFIG_CMD_DATE*/
 /*#define CONFIG_CMD_NAND*/
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_MMC
 
 #define CONFIG_CMD_I2C
 #define CONFIG_CMD_MII
@@ -114,9 +116,9 @@
 			"setenv filesize; saveenv\0"
 
 /*Support LAN9217*/
-#define CONFIG_DRIVER_SMC911X	1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE CS5_BASE_ADDR
+#define CONFIG_SMC911X	1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE CS5_BASE_ADDR
 
 #define CONFIG_HAS_ETH1
 #define CONFIG_NET_MULTI 1
@@ -181,9 +183,14 @@
 /*
  * MMC Configs
  * */
-#define CONFIG_FSL_MMC
-#define CONFIG_MMC              1
-#define CONFIG_CMD_MMC
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+#endif
 
 #define CONFIG_FLASH_HEADER     1
 #define CONFIG_FLASH_HEADER_OFFSET 0x400
@@ -191,7 +198,6 @@
 
 #define CONFIG_DOS_PARTITION    1
 #define CONFIG_CMD_FAT          1
-#define CONFIG_MMC_BASE         0x0
 
 /*-----------------------------------------------------------------------
  * FLASH and environment organization
diff --git a/include/configs/mx51_3stack.h b/include/configs/mx51_3stack.h
index 236de3c..e0fa523 100644
--- a/include/configs/mx51_3stack.h
+++ b/include/configs/mx51_3stack.h
@@ -83,23 +83,27 @@
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 /* Enable below configure when supporting nand */
-/* #define CONFIG_CMD_NAND */
+#define CONFIG_CMD_NAND
 #define CONFIG_MXC_NAND
 #define CONFIG_CMD_ENV
+#define CMD_SAVEENV
 #undef CONFIG_CMD_IMLS
 #define CONFIG_CMD_MII
 #define CONFIG_CMD_NET
+#define CONFIG_NET_MULTI
+#define CONFIG_CMD_MMC
 
 /*
  * MMC Configs
  */
-#define CONFIG_FSL_MMC          1
-
-#define CONFIG_MMC              1
-#define CONFIG_CMD_MMC
-#define CONFIG_DOS_PARTITION    1
-#define CONFIG_CMD_FAT          1
-#define CONFIG_MMC_BASE         0x0
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+#endif
 
 /*
  * I2C Configs
@@ -135,9 +139,9 @@
 			"setenv filesize; saveenv\0"
 
 /*Support LAN9217*/
-#define CONFIG_DRIVER_SMC911X	1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE_VARIABLE mx51_io_base_addr
+#define CONFIG_SMC911X	1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE mx51_io_base_addr
 
 /*
  * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
@@ -203,7 +207,9 @@
 #define CONFIG_SYS_NAND_BASE          0x40000000
 
 /* Monitor at beginning of flash */
-#define CONFIG_FSL_ENV_IN_MMC
+#define CONFIG_FSL_ENV_IN_NAND
+/* #define CONFIG_FSL_ENV_IN_NAND */
+
 #define CONFIG_ENV_SECT_SIZE    (128 * 1024)
 #define CONFIG_ENV_SIZE		CONFIG_ENV_SECT_SIZE
 #if defined(CONFIG_FSL_ENV_IN_NAND)
diff --git a/include/configs/mx51_3stack_android.h b/include/configs/mx51_3stack_android.h
index 153993b..a4c1004 100644
--- a/include/configs/mx51_3stack_android.h
+++ b/include/configs/mx51_3stack_android.h
@@ -84,30 +84,6 @@
 #define MAX_SPI_BYTES		(64 * 4)
 */
 
-/*
- * MMC Configs
- * */
-#define CONFIG_FSL_MMC		1
-
-#define CONFIG_MMC              1
-#define CONFIG_CMD_MMC
-#define CONFIG_DOS_PARTITION	1
-#define CONFIG_CMD_FAT		1
-#define CONFIG_MMC_BASE         0x0
-
-/*
- * Eth Configs
- */
-#define CONFIG_HAS_ETH1
-#define CONFIG_NET_MULTI 1
-#define CONFIG_MXC_FEC
-#define CONFIG_MII
-#define CONFIG_DISCOVER_PHY
-
-#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
-#define CONFIG_FEC0_PINMUX	-1
-#define CONFIG_FEC0_PHY_ADDR	0x1F
-#define CONFIG_FEC0_MIIBASE 	-1
 
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
@@ -134,7 +110,9 @@
 #define CONFIG_ANDROID_NORMAL_BOOTARGS "ip=dhcp mem=480M init=/init wvga calibration"
 #define CONFIG_ANDROID_RECOVERY_BOOTARGS "setenv bootargs ${bootargs} root=/dev/mmcblk0p4 ip=dhcp init=/init rootfstype=ext3 wvga"
 #define CONFIG_ANDROID_RECOVERY_BOOTCMD  "run bootargs_base bootargs_android;mmcinit;cp.b 0x100000 ${loadaddr} 0x250000;bootm"
+#define CONFIG_ANDROID_RECOVERY_CMD_FILE "/cache/recovery/command"
 #define CONFIG_ANDROID_BOOTMOD_DELAY 3
+#define CONFIG_ANDROID_CACHE_PARTITION 4
 
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
@@ -153,6 +131,7 @@
 /* Enable below configure when supporting nand */
 #define CONFIG_CMD_NAND
 #define CONFIG_MXC_NAND
+#define CONFIG_CMD_MMC
 #define CONFIG_CMD_ENV
 
 #undef CONFIG_CMD_IMLS
@@ -190,9 +169,35 @@
 			"setenv filesize; saveenv\0"
 
 /*Support LAN9217*/
-#define CONFIG_DRIVER_SMC911X	1
-#define CONFIG_DRIVER_SMC911X_16_BIT 1
-#define CONFIG_DRIVER_SMC911X_BASE_VARIABLE mx51_io_base_addr
+#define CONFIG_SMC911X	1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE mx51_io_base_addr
+
+/*
+ * MMC Configs
+ * */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+#endif
+
+/*
+ * Eth Configs
+ */
+#define CONFIG_HAS_ETH1
+#define CONFIG_NET_MULTI 1
+#define CONFIG_MXC_FEC
+#define CONFIG_MII
+#define CONFIG_DISCOVER_PHY
+
+#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+#define CONFIG_FEC0_PINMUX	-1
+#define CONFIG_FEC0_PHY_ADDR	0x1F
+#define CONFIG_FEC0_MIIBASE 	-1
 
 /*
  * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
@@ -258,13 +263,8 @@
 #define CONFIG_SYS_NAND_BASE          0x40000000
 
 /* Monitor at beginning of flash */
-#if defined(CONFIG_FSL_SF)
-	#define CONFIG_FSL_ENV_IN_SF
-#elif defined(CONFIG_FSL_MMC)
-	#define CONFIG_FSL_ENV_IN_MMC
-#elif defined(CONFIG_CMD_NAND)
-	#define CONFIG_FSL_ENV_IN_NAND
-#endif
+/* #define CONFIG_FSL_ENV_IN_MMC */
+#define CONFIG_FSL_ENV_IN_NAND
 
 #define CONFIG_ENV_SECT_SIZE    (128 * 1024)
 #define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
diff --git a/include/configs/mx51_bbg.h b/include/configs/mx51_bbg.h
new file mode 100644
index 0000000..dd4727d
--- /dev/null
+++ b/include/configs/mx51_bbg.h
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the MX51-3Stack Freescale board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/mx51.h>
+
+ /* High Level Configuration Options */
+#define CONFIG_ARMV7		1	/* This is armv7 Cortex-A8 CPU core */
+#define CONFIG_L2_OFF
+
+#define CONFIG_MXC		1
+#define CONFIG_MX51_BBG		1	/* in a mx51 */
+#define CONFIG_FLASH_HEADER	1
+#define CONFIG_FLASH_HEADER_OFFSET 0x400
+#define CONFIG_FLASH_HEADER_BARKER 0xB1
+
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+#define CONFIG_MX51_HCLK_FREQ	24000000	/* RedBoot says 26MHz */
+#define CONFIG_MX51_CLK32	32768
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define BOARD_LATE_INIT
+/*
+ * Disabled for now due to build problems under Debian and a significant
+ * increase in the final file size: 144260 vs. 109536 Bytes.
+ */
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_REVISION_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_MX51_UART	1
+#define CONFIG_MX51_UART1	1
+
+/*
+ * SPI Configs
+ * */
+#define CONFIG_FSL_SF		1
+#define CONFIG_SPI_FLASH_IMX_ATMEL	1
+#define CONFIG_SPI_FLASH_CS	1
+#define CONFIG_IMX_SPI
+#define CONFIG_IMX_SPI_PMIC
+#define CONFIG_IMX_SPI_PMIC_CS 0
+
+#define MAX_SPI_BYTES		(64 * 4)
+
+/*
+ * MMC Configs
+ * */
+
+/*
+ * Eth Configs
+ */
+#define CONFIG_HAS_ETH1
+#define CONFIG_NET_MULTI 1
+#define CONFIG_MXC_FEC
+#define CONFIG_MII
+#define CONFIG_DISCOVER_PHY
+
+#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+#define CONFIG_FEC0_PINMUX	-1
+#define CONFIG_FEC0_PHY_ADDR	0x1F
+#define CONFIG_FEC0_MIIBASE 	-1
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_MMC
+
+/*
+ * SPI Configs
+ * */
+#ifdef CONFIG_CMD_SF
+	#define CONFIG_FSL_SF		1
+	#define CONFIG_SPI_FLASH_IMX_ATMEL	1
+	#define CONFIG_SPI_FLASH_CS	1
+	#define CONFIG_IMX_SPI
+	#define CONFIG_IMX_SPI_PMIC
+	#define CONFIG_IMX_SPI_PMIC_CS 0
+
+	#define MAX_SPI_BYTES		(64 * 4)
+#endif
+
+/*
+ * MMC Configs
+ * */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+#endif
+/*
+ * Eth Configs
+ */
+#define CONFIG_HAS_ETH1
+#define CONFIG_NET_MULTI 1
+#define CONFIG_MXC_FEC
+#define CONFIG_MII
+#define CONFIG_DISCOVER_PHY
+
+#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+#define CONFIG_FEC0_PINMUX	-1
+#define CONFIG_FEC0_PHY_ADDR	0x1F
+#define CONFIG_FEC0_MIIBASE 	-1
+
+
+
+/* Enable below configure when supporting nand */
+#define CONFIG_CMD_ENV
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_PRIME	"FEC0"
+
+#define CONFIG_LOADADDR		0x90800000	/* loadaddr env var */
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+		"netdev=eth0\0"						\
+		"ethprime=FEC0\0"					\
+		"uboot_addr=0xa0000000\0"				\
+		"uboot=u-boot.bin\0"			\
+		"kernel=uImage\0"				\
+		"bootargs_base=setenv bootargs console=ttymxc0,115200\0"\
+		"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs "\
+			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0"\
+		"bootcmd=run bootcmd_net\0"				\
+		"bootcmd_net=run bootargs_base bootargs_nfs; "		\
+			"tftpboot ${loadaddr} ${kernel}; bootm\0"	\
+		"load_uboot=tftpboot ${loadaddr} ${uboot}\0"		\
+
+/*
+ * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
+ * U-Boot, RedBoot and Linux: the ethernet Rx signal is reaching the CS8900A
+ * controller inverted. The controller is capable of detecting and correcting
+ * this, but it needs 4 network packets for that. Which means, at startup, you
+ * will not receive answers to the first 4 packest, unless there have been some
+ * broadcasts on the network, or your board is on a hub. Reducing the ARP
+ * timeout from default 5 seconds to 200ms we speed up the initial TFTP
+ * transfer, should the user wish one, significantly.
+ */
+#define CONFIG_ARP_TIMEOUT	200UL
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT		"BBG U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START	0	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x10000
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_HZ	CONFIG_MX51_CLK32/* use 32kHz clock as source */
+
+#define CONFIG_CMDLINE_EDITING	1
+
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CSD0_BASE_ADDR
+/* TO1 boards */
+/* #define PHYS_SDRAM_1_SIZE	(128 * 1024 * 1024) */
+#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_NO_FLASH
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH driver setup
+ */
+#define NAND_MAX_CHIPS         8
+#define CONFIG_SYS_MAX_NAND_DEVICE    1
+#define CONFIG_SYS_NAND_BASE          0x40000000
+
+/* Monitor at beginning of flash */
+/* #define CONFIG_FSL_ENV_IN_SF */
+#define CONFIG_FSL_ENV_IN_MMC
+/* #define CONFIG_FSL_ENV_IN_NAND */
+
+#define CONFIG_ENV_SECT_SIZE    (128 * 1024)
+#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
+
+#if defined(CONFIG_FSL_ENV_IN_NAND)
+	#define CONFIG_ENV_IS_IN_NAND 1
+	#define CONFIG_ENV_OFFSET	0x100000
+#elif defined(CONFIG_FSL_ENV_IN_MMC)
+	#define CONFIG_ENV_IS_IN_MMC	1
+	#define CONFIG_ENV_OFFSET	(768 * 1024)
+#elif defined(CONFIG_FSL_ENV_IN_SF)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
+	#define CONFIG_ENV_IS_EMBEDDED	1
+	#define CONFIG_ENV_SPI_CS		1
+	#define CONFIG_ENV_OFFSET       (768 * 1024)
+#else
+	#define CONFIG_ENV_IS_NOWHERE	1
+#endif
+/*
+ * JFFS2 partitions
+ */
+#undef CONFIG_JFFS2_CMDLINE
+#define CONFIG_JFFS2_DEV	"nand0"
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/mx51_bbg_android.h b/include/configs/mx51_bbg_android.h
new file mode 100644
index 0000000..d49e039
--- /dev/null
+++ b/include/configs/mx51_bbg_android.h
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the MX51-3Stack Freescale board.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/mx51.h>
+
+ /* High Level Configuration Options */
+#define CONFIG_ARMV7		1	/* This is armv7 Cortex-A8 CPU core */
+#define CONFIG_SYS_APCS_GNU
+#define CONFIG_L2_OFF
+
+#define CONFIG_MXC		1
+#define CONFIG_MX51_BBG		1	/* in a mx51 */
+#define CONFIG_FLASH_HEADER	1
+#define CONFIG_FLASH_HEADER_OFFSET 0x400
+#define CONFIG_FLASH_HEADER_BARKER 0xB1
+
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+#define CONFIG_MX51_HCLK_FREQ	24000000	/* RedBoot says 26MHz */
+#define CONFIG_MX51_CLK32	32768
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define BOARD_LATE_INIT
+/*
+ * Disabled for now due to build problems under Debian and a significant
+ * increase in the final file size: 144260 vs. 109536 Bytes.
+ */
+
+#define CONFIG_CMDLINE_TAG		1	/* enable passing of ATAGs */
+#define CONFIG_REVISION_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
+/* size in bytes reserved for initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	128
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_MX51_UART	1
+#define CONFIG_MX51_UART1	1
+
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+
+/*
+ * Android support Configs
+ */
+#include <asm/arch/keypad.h>
+
+#define CONFIG_FSL_ANDROID
+
+#define CONFIG_MXC_KPD
+#define CONFIG_MXC_KEYMAPPING \
+	{	\
+		KEY_1, KEY_2, KEY_3, KEY_F1, KEY_UP, KEY_F2, \
+		KEY_4, KEY_5, KEY_6, KEY_LEFT, KEY_SELECT, KEY_RIGHT, \
+		KEY_7, KEY_8, KEY_9, KEY_F3, KEY_DOWN, KEY_F4, \
+		KEY_0, KEY_OK, KEY_ESC, KEY_ENTER, KEY_MENU, KEY_BACK, \
+	}
+/*
+	{	\
+		KEY_3,         KEY_2,        KEY_0, KEY_OK, KEY_ESC, KEY_ENTER,
+		KEY_F1,	KEY_4, KEY_6, KEY_5,
+		KEY_LEFT,      KEY_1,        KEY_ , KEY_8,  KEY_9,   KEY_RIGHT,
+	}
+	*/
+#define CONFIG_MXC_KPD_COLMAX 4
+#define CONFIG_MXC_KPD_ROWMAX 4
+#define CONFIG_ANDROID_NORMAL_BOOTARGS "ip=dhcp mem=480M init=/init wvga calibration"
+#define CONFIG_ANDROID_RECOVERY_BOOTARGS "setenv bootargs ${bootargs} root=/dev/mmcblk0p4 ip=dhcp init=/init rootfstype=ext3 wvga"
+#define CONFIG_ANDROID_RECOVERY_BOOTCMD  "run bootargs_base bootargs_android;mmc read 0 ${loadaddr} 0x800 0x1280;bootm"
+#define CONFIG_ANDROID_RECOVERY_CMD_FILE "/cache/recovery/command"
+#define CONFIG_ANDROID_BOOTMOD_DELAY 3
+#define CONFIG_ANDROID_CACHE_PARTITION 4
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{9600, 19200, 38400, 57600, 115200}
+
+/***********************************************************
+ * Command definition
+ ***********************************************************/
+
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+/* Enable below configure when supporting nand */
+/* #define CONFIG_CMD_NAND */
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_ENV
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_PRIME	"FEC0"
+
+#define CONFIG_LOADADDR		0x90800000	/* loadaddr env var */
+#define CONFIG_RD_LOADADDR	(CONFIG_LOADADDR + 0x300000)
+
+#define	CONFIG_EXTRA_ENV_SETTINGS					\
+		"netdev=eth0\0"						\
+		"ethprime=FEC0\0"					\
+		"uboot_addr=0xa0000000\0"				\
+		"uboot=u-boot.bin\0"			\
+		"kernel=uImage\0"				\
+		"rd_loadaddr=0x90B00000\0"	\
+		"nfsroot=/opt/eldk/arm\0"				\
+		"bootargs_base=setenv bootargs console=ttymxc0,115200\0"\
+		"bootargs_nfs=setenv bootargs ${bootargs} root=/dev/nfs "\
+			"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0"\
+		"bootargs_android=setenv bootargs ${bootargs} ip=dhcp mem=480M init=/init wvga calibration\0"	\
+		"bootcmd=run bootcmd_android\0"				\
+		"bootcmd_net=run bootargs_base bootargs_nfs; "		\
+			"tftpboot ${loadaddr} ${kernel}; bootm\0"	\
+		"bootcmd_android=run bootargs_base bootargs_android; "	\
+			"mmcinit;cp.b 0x100000 ${loadaddr} 0x250000; "	\
+			"cp.b 0x400000 ${rd_loadaddr} 0x4B000; "	\
+			"bootm ${loadaddr} ${rd_loadaddr}\0"		\
+		"prg_uboot=tftpboot ${loadaddr} ${uboot}; "		\
+			"protect off ${uboot_addr} 0xa003ffff; "	\
+			"erase ${uboot_addr} 0xa003ffff; "		\
+			"cp.b ${loadaddr} ${uboot_addr} ${filesize}; "	\
+			"setenv filesize; saveenv\0"
+
+/*Support LAN9217*/
+/*
+#define CONFIG_SMC911X	1
+#define CONFIG_SMC911X_16_BIT 1
+#define CONFIG_SMC911X_BASE mx51_io_base_addr
+*/
+
+/*
+ * The MX51 3stack board seems to have a hardware "peculiarity" confirmed under
+ * U-Boot, RedBoot and Linux: the ethernet Rx signal is reaching the CS8900A
+ * controller inverted. The controller is capable of detecting and correcting
+ * this, but it needs 4 network packets for that. Which means, at startup, you
+ * will not receive answers to the first 4 packest, unless there have been some
+ * broadcasts on the network, or your board is on a hub. Reducing the ARP
+ * timeout from default 5 seconds to 200ms we speed up the initial TFTP
+ * transfer, should the user wish one, significantly.
+ */
+#define CONFIG_ARP_TIMEOUT	200UL
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP		/* undef to save memory */
+#define CONFIG_SYS_PROMPT		"BBG U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		256	/* Console I/O Buffer Size */
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS	16	/* max number of command args */
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE /* Boot Argument Buffer Size */
+
+#define CONFIG_SYS_MEMTEST_START	0	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x10000
+
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_SYS_HZ	CONFIG_MX51_CLK32/* use 32kHz clock as source */
+
+#define CONFIG_CMDLINE_EDITING	1
+
+/*
+ * Eth Configs
+ */
+#define CONFIG_HAS_ETH1
+#define CONFIG_NET_MULTI 1
+#define CONFIG_MXC_FEC
+#define CONFIG_MII
+#define CONFIG_DISCOVER_PHY
+
+#define CONFIG_FEC0_IOBASE	FEC_BASE_ADDR
+#define CONFIG_FEC0_PINMUX	-1
+#define CONFIG_FEC0_PHY_ADDR	0x1F
+#define CONFIG_FEC0_MIIBASE 	-1
+
+/*
+ * SPI Configs
+ * */
+#define CONFIG_FSL_SF		1
+#define CONFIG_CMD_SPI
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH_IMX_ATMEL	1
+#define CONFIG_SPI_FLASH_CS	1
+#define CONFIG_IMX_SPI
+#define CONFIG_IMX_SPI_PMIC
+#define CONFIG_IMX_SPI_PMIC_CS 0
+
+#define MAX_SPI_BYTES		(64 * 4)
+
+/*
+ * MMC Configs
+ * */
+#ifdef CONFIG_CMD_MMC
+	#define CONFIG_MMC				1
+	#define CONFIG_MMC_BASE		0x0
+	#define CONFIG_GENERIC_MMC
+	#define CONFIG_IMX_MMC
+	#define CONFIG_DOS_PARTITION	1
+	#define CONFIG_CMD_FAT		1
+	#define CONFIG_CMD_EXT2		1
+#endif
+/*-----------------------------------------------------------------------
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128 * 1024)	/* regular stack */
+
+/*-----------------------------------------------------------------------
+ * Physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS	1
+#define PHYS_SDRAM_1		CSD0_BASE_ADDR
+/* TO1 boards */
+/* #define PHYS_SDRAM_1_SIZE	(128 * 1024 * 1024) */
+#define PHYS_SDRAM_1_SIZE	(512 * 1024 * 1024)
+
+/*-----------------------------------------------------------------------
+ * FLASH and environment organization
+ */
+#define CONFIG_SYS_NO_FLASH
+
+/*-----------------------------------------------------------------------
+ * NAND FLASH driver setup
+ */
+#define NAND_MAX_CHIPS         8
+#define CONFIG_SYS_MAX_NAND_DEVICE    1
+#define CONFIG_SYS_NAND_BASE          0x40000000
+
+/* Monitor at beginning of flash */
+/* #define CONFIG_FSL_ENV_IN_SF */
+#define CONFIG_FSL_ENV_IN_MMC
+/* #define CONFIG_FSL_ENV_IN_NAND */
+
+#define CONFIG_ENV_SECT_SIZE    (128 * 1024)
+#define CONFIG_ENV_SIZE         CONFIG_ENV_SECT_SIZE
+
+#if defined(CONFIG_FSL_ENV_IN_NAND)
+	#define CONFIG_ENV_IS_IN_NAND 1
+	#define CONFIG_ENV_OFFSET	0x100000
+#elif defined(CONFIG_FSL_ENV_IN_MMC)
+	#define CONFIG_ENV_IS_IN_MMC	1
+	#define CONFIG_ENV_OFFSET	(768 * 1024)
+#elif defined(CONFIG_FSL_ENV_IN_SF)
+	#define CONFIG_ENV_IS_IN_SPI_FLASH	1
+	#define CONFIG_ENV_SPI_CS		1
+	#define CONFIG_ENV_OFFSET       (768 * 1024)
+#else
+	#define CONFIG_ENV_IS_NOWHERE	1
+#endif
+/*
+ * JFFS2 partitions
+ */
+#undef CONFIG_JFFS2_CMDLINE
+#define CONFIG_JFFS2_DEV	"nand0"
+
+#endif				/* __CONFIG_H */
diff --git a/include/fsl_esdhc.h b/include/fsl_esdhc.h
index 89b8304..f3c38e6 100644
--- a/include/fsl_esdhc.h
+++ b/include/fsl_esdhc.h
@@ -30,9 +30,11 @@
 
 /* FSL eSDHC-specific constants */
 #define SYSCTL			0x0002e02c
+#define SYSCTL_RSTA		0x01000000
 #define SYSCTL_INITA		0x08000000
 #define SYSCTL_TIMEOUT_MASK	0x000f0000
-#define SYSCTL_CLOCK_MASK	0x00000fff
+#define SYSCTL_CLOCK_MASK	0x0000fff0
+#define SYSCTL_SDCLKEN		0x00000008
 #define SYSCTL_PEREN		0x00000004
 #define SYSCTL_HCKEN		0x00000002
 #define SYSCTL_IPGEN		0x00000001
@@ -86,6 +88,7 @@
 #define PRSSTAT_CDPL		(0x00040000)
 #define PRSSTAT_CINS		(0x00010000)
 #define PRSSTAT_BREN		(0x00000800)
+#define PRSSTAT_SDSTB		(0x00000008)
 #define PRSSTAT_DLA		(0x00000004)
 #define PRSSTAT_CICHB		(0x00000002)
 #define PRSSTAT_CIDHB		(0x00000001)
@@ -94,6 +97,7 @@
 #define PROCTL_INIT		0x00000020
 #define PROCTL_DTW_4		0x00000002
 #define PROCTL_DTW_8		0x00000004
+#define PROCTL_D3CD		0x00000008
 
 #define CMDARG			0x0002e008
 
@@ -142,7 +146,7 @@
 #define ESDHC_HOSTCAPBLT_DMAS	0x00400000
 #define ESDHC_HOSTCAPBLT_HSS	0x00200000
 
-#ifdef CONFIG_FSL_ESDHC
+#if defined(CONFIG_FSL_ESDHC) || defined(CONFIG_IMX_MMC)
 int fsl_esdhc_mmc_init(bd_t *bis);
 void fdt_fixup_esdhc(void *blob, bd_t *bd);
 #else
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
deleted file mode 100644
index 393d587..0000000
--- a/include/linux/mmc/card.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- *  linux/include/linux/mmc/card.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- *  Card driver specific definitions.
- */
-#ifndef LINUX_MMC_CARD_H
-#define LINUX_MMC_CARD_H
-
-#include "core.h"
-
-struct mmc_cid {
-	unsigned int		manfid;
-	char			    prod_name[8];
-	unsigned int		serial;
-	union {
-	unsigned short		mmc_id;
-	char				sd_id[2];
-	} oemid;
-	unsigned short		year;
-	unsigned char		hwrev;
-	unsigned char		fwrev;
-	unsigned char		month;
-};
-
-struct mmc_csd {
-	unsigned char		mmca_vsn;
-	unsigned short		cmdclass;
-	unsigned short		tacc_clks;
-	unsigned int		tacc_ns;
-	unsigned int		r2w_factor;
-	unsigned int		max_dtr;
-	unsigned int		read_blkbits;
-	unsigned int		write_blkbits;
-	unsigned int		capacity;
-	unsigned int		read_partial:1,
-				read_misalign:1,
-				write_partial:1,
-				write_misalign:1;
-};
-
-struct mmc_ext_csd {
-	unsigned int		hs_max_dtr;
-	unsigned int		sectors;
-};
-
-struct sd_scr {
-	unsigned char		sda_vsn;
-	unsigned char		bus_widths;
-#define SD_SCR_BUS_WIDTH_1	(1<<0)
-#define SD_SCR_BUS_WIDTH_4	(1<<2)
-};
-
-struct sd_switch_caps {
-	unsigned int		hs_max_dtr;
-};
-
-struct sdio_cccr {
-	unsigned int		sdio_vsn;
-	unsigned int		sd_vsn;
-	unsigned int		multi_block:1,
-				low_speed:1,
-				wide_bus:1,
-				high_power:1,
-				high_speed:1;
-};
-
-struct sdio_cis {
-	unsigned short		vendor;
-	unsigned short		device;
-	unsigned short		blksize;
-	unsigned int		max_dtr;
-};
-
-struct mmc_host;
-struct sdio_func;
-struct sdio_func_tuple;
-
-#define SDIO_MAX_FUNCS		7
-
-/*
- * MMC device
- */
-struct mmc_card {
-	unsigned int rca; /* relative card address of device */
-	unsigned int type;	/* card type */
-#define MMC_TYPE_MMC 0  /* MMC card */
-#define MMC_TYPE_SD  1  /* SD card */
-#define MMC_TYPE_SDIO 2 /* SDIO card */
-	unsigned int state; /* (our) card state */
-#define MMC_STATE_PRESENT   (1<<0) /* present in sysfs */
-#define MMC_STATE_READONLY  (1<<1) /* card is read-only */
-#define MMC_STATE_HIGHSPEED (1<<2) /* card is in high speed mode */
-#define MMC_STATE_BLOCKADDR (1<<3) /* card uses block-addressing */
-
-	u32 raw_cid[4]; /* raw card CID */
-	u32 raw_csd[4]; /* raw card CSD */
-	u32 raw_scr[2]; /* raw card SCR */
-	struct mmc_cid cid; /* card identification */
-	struct mmc_csd csd; /* card specific */
-	struct mmc_ext_csd ext_csd; /* mmc v4 extended card specific */
-	struct sd_scr  scr; /* extra SD information */
-	struct sd_switch_caps sw_caps; /* switch (CMD6) caps */
-
-	unsigned int sdio_funcs; /* number of SDIO functions */
-	struct sdio_cccr cccr;   /* common card info */
-	struct sdio_cis  cis;    /* common tuple info */
-	/* SDIO functions (devices) */
-	struct sdio_func *sdio_func[SDIO_MAX_FUNCS];
-	unsigned num_info; /* number of info strings */
-	const char **info; /* info strings */
-	struct sdio_func_tuple *tuples; /* unknown common tuples */
-};
-
-#define mmc_card_mmc(c)  ((c)->type == MMC_TYPE_MMC)
-#define mmc_card_sd(c)   ((c)->type == MMC_TYPE_SD)
-#define mmc_card_sdio(c) ((c)->type == MMC_TYPE_SDIO)
-
-#define mmc_card_present(c)   ((c)->state & MMC_STATE_PRESENT)
-#define mmc_card_readonly(c)  ((c)->state & MMC_STATE_READONLY)
-#define mmc_card_highspeed(c) ((c)->state & MMC_STATE_HIGHSPEED)
-#define mmc_card_blockaddr(c) ((c)->state & MMC_STATE_BLOCKADDR)
-
-#define mmc_card_set_present(c) ((c)->state |= MMC_STATE_PRESENT)
-#define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
-#define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
-#define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
-
-#define mmc_card_name(c) ((c)->cid.prod_name)
-#define mmc_card_id(c)   ((c)->dev.bus_id)
-
-#define mmc_list_to_card(l) container_of(l, struct mmc_card, node)
-#define mmc_get_drvdata(c)  dev_get_drvdata(&(c)->dev)
-#define mmc_set_drvdata(c, d) dev_set_drvdata(&(c)->dev, d)
-
-#endif
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
deleted file mode 100644
index 7f0e786..0000000
--- a/include/linux/mmc/core.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- *  (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- *  linux/include/linux/mmc/core.h
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef MMC_CORE_H
-#define MMC_CORE_H
-
-#include <asm/arch/sdhc.h>
-
-struct request;
-struct mmc_data;
-struct mmc_request;
-
-struct mmc_command {
-    esdhc_cmd_t cmd;
-	esdhc_resp_t resp;
-#define MMC_RSP_PRESENT	(1 << 0)
-#define MMC_RSP_136	(1 << 1)      /* 136 bit response */
-#define MMC_RSP_CRC	(1 << 2)      /* expect valid crc */
-#define MMC_RSP_BUSY	(1 << 3)  /* card may send busy */
-#define MMC_RSP_OPCODE	(1 << 4)  /* response contains opcode */
-
-#define MMC_CMD_MASK	(3 << 5)  /* non-SPI command type */
-#define MMC_CMD_AC	(0 << 5)
-#define MMC_CMD_ADTC	(1 << 5)
-#define MMC_CMD_BC	(2 << 5)
-#define MMC_CMD_BCR	(3 << 5)
-
-#define MMC_RSP_SPI_S1	(1 << 7)  /* one status byte */
-#define MMC_RSP_SPI_S2	(1 << 8)  /* second byte */
-#define MMC_RSP_SPI_B4	(1 << 9)  /* four data bytes */
-#define MMC_RSP_SPI_BUSY (1 << 10) /* card may send busy */
-
-/*
- * These are the native response types, and correspond to valid bit
- * patterns of the above flags.  One additional valid pattern
- * is all zeros, which means we don't expect a response.
- */
-#define MMC_RSP_NONE	(0)
-#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R1B (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
-#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
-#define MMC_RSP_R3	(MMC_RSP_PRESENT)
-#define MMC_RSP_R4	(MMC_RSP_PRESENT)
-#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
-
-#define mmc_resp_type(cmd) ((cmd)->flags & \
-		(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC| \
-		 MMC_RSP_BUSY|MMC_RSP_OPCODE))
-
-#define MMC_KEEP_CLK_RUN (1 << 31) /* Keep card clock on after request */
-
-/*
- * These are the SPI response types for MMC, SD, and SDIO cards.
- * Commands return R1, with maybe more info.  Zero is an error type;
- * callers must always provide the appropriate MMC_RSP_SPI_Rx flags.
- */
-#define MMC_RSP_SPI_R1  (MMC_RSP_SPI_S1)
-#define MMC_RSP_SPI_R1B (MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY)
-#define MMC_RSP_SPI_R2  (MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
-#define MMC_RSP_SPI_R3  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
-#define MMC_RSP_SPI_R4  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
-#define MMC_RSP_SPI_R5  (MMC_RSP_SPI_S1|MMC_RSP_SPI_S2)
-#define MMC_RSP_SPI_R7  (MMC_RSP_SPI_S1|MMC_RSP_SPI_B4)
-
-#define mmc_spi_resp_type(cmd) ((cmd)->flags & \
-		(MMC_RSP_SPI_S1|MMC_RSP_SPI_BUSY|MMC_RSP_SPI_S2|MMC_RSP_SPI_B4))
-
-/*
- * These are the command types.
- */
-#define mmc_cmd_type(cmd) ((cmd)->flags & MMC_CMD_MASK)
-
-	unsigned int        retries; /* max number of retries */
-	unsigned int        error;   /* command error */
-
-/*
- * Standard errno values are used for errors, but some have specific
- * meaning in the MMC layer:
- *
- * ETIMEDOUT    Card took too long to respond
- * EILSEQ       Basic format problem with the received or sent data
- *              (e.g. CRC check failed, incorrect opcode in response
- *              or bad end bit)
- * EINVAL       Request cannot be performed because of restrictions
- *              in hardware and/or the driver
- * ENOMEDIUM    Host can determine that the slot is empty and is
- *              actively failing requests
- */
-
-	struct mmc_data *data;      /* data segment associated with cmd */
-	struct mmc_request *mrq;    /* associated request */
-};
-
-struct mmc_data {
-	unsigned int timeout_ns;   /* data timeout (in ns, max 80ms) */
-	unsigned int timeout_clks; /* data timeout (in clocks) */
-	unsigned int blksz;        /* data block size */
-	unsigned int blocks;       /* number of blocks */
-	unsigned int error;        /* data error */
-	unsigned int flags;
-
-#define MMC_DATA_WRITE	(1 << 8)
-#define MMC_DATA_READ	(1 << 9)
-#define MMC_DATA_STREAM	(1 << 10)
-
-	unsigned int       bytes_xfered;
-
-	struct mmc_command *stop;  /* stop command */
-	struct mmc_request *mrq;   /* associated request */
-
-	unsigned int       sg_len; /* size of scatter list */
-	struct scatterlist *sg;    /* I/O scatter list */
-};
-
-struct mmc_request {
-	struct mmc_command  *cmd;
-	struct mmc_data     *data;
-	struct mmc_command  *stop;
-
-	void *done_data;           /* completion data */
-	void (*done)(struct mmc_request *); /* completion function */
-};
-
-#endif
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
deleted file mode 100644
index 4b9bde9..0000000
--- a/include/linux/mmc/mmc.h
+++ /dev/null
@@ -1,291 +0,0 @@
-/* (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * Header for MultiMediaCard (MMC)
- *
- * Copyright 2002 Hewlett-Packard Company
- *
- * Use consistent with the GNU GPL is permitted,
- * provided that this copyright notice is
- * preserved in its entirety in all copies and derived works.
- *
- * HEWLETT-PACKARD COMPANY MAKES NO WARRANTIES, EXPRESSED OR IMPLIED,
- * AS TO THE USEFULNESS OR CORRECTNESS OF THIS CODE OR ITS
- * FITNESS FOR ANY PARTICULAR PURPOSE.
- *
- * Many thanks to Alessandro Rubini and Jonathan Corbet!
- *
- * Based strongly on code by:
- *
- * Author: Yong-iL Joh <tolkien@mizi.com>
- * Date  : $Date: 2002/06/18 12:37:30 $
- *
- * Author:  Andrew Christian
- *          15 May 2002
- */
-
-#ifndef MMC_MMC_H
-#define MMC_MMC_H
-
-/* Standard MMC commands (4.1)           type  argument     response */
-   /* class 1 */
-#define MMC_GO_IDLE_STATE         0   /* bc                          */
-#define MMC_SEND_OP_COND          1   /* bcr  [31:0] OCR         R3  */
-#define MMC_ALL_SEND_CID          2   /* bcr                     R2  */
-#define MMC_SET_RELATIVE_ADDR     3   /* ac   [31:16] RCA        R1  */
-#define MMC_SET_DSR               4   /* bc   [31:16] RCA            */
-#define MMC_SWITCH                6   /* ac   [31:0] See below   R1b */
-#define MMC_SELECT_CARD           7   /* ac   [31:16] RCA        R1  */
-#define MMC_SEND_EXT_CSD          8   /* adtc                    R1  */
-#define MMC_SEND_CSD              9   /* ac   [31:16] RCA        R2  */
-#define MMC_SEND_CID             10   /* ac   [31:16] RCA        R2  */
-#define MMC_READ_DAT_UNTIL_STOP  11   /* adtc [31:0] dadr        R1  */
-#define MMC_STOP_TRANSMISSION    12   /* ac                      R1b */
-#define MMC_SEND_STATUS          13   /* ac   [31:16] RCA        R1  */
-#define MMC_GO_INACTIVE_STATE    15   /* ac   [31:16] RCA            */
-#define MMC_SPI_READ_OCR         58   /* spi                  spi_R3 */
-#define MMC_SPI_CRC_ON_OFF       59   /* spi  [0:0] flag      spi_R1 */
-
-  /* class 2 */
-#define MMC_SET_BLOCKLEN         16   /* ac   [31:0] block len   R1  */
-#define MMC_READ_SINGLE_BLOCK    17   /* adtc [31:0] data addr   R1  */
-#define MMC_READ_MULTIPLE_BLOCK  18   /* adtc [31:0] data addr   R1  */
-
-  /* class 3 */
-#define MMC_WRITE_DAT_UNTIL_STOP 20   /* adtc [31:0] data addr   R1  */
-
-  /* class 4 */
-#define MMC_SET_BLOCK_COUNT      23   /* adtc [31:0] data addr   R1  */
-#define MMC_WRITE_BLOCK          24   /* adtc [31:0] data addr   R1  */
-#define MMC_WRITE_MULTIPLE_BLOCK 25   /* adtc                    R1  */
-#define MMC_PROGRAM_CID          26   /* adtc                    R1  */
-#define MMC_PROGRAM_CSD          27   /* adtc                    R1  */
-
-  /* class 6 */
-#define MMC_SET_WRITE_PROT       28   /* ac   [31:0] data addr   R1b */
-#define MMC_CLR_WRITE_PROT       29   /* ac   [31:0] data addr   R1b */
-#define MMC_SEND_WRITE_PROT      30   /* adtc [31:0] wpdata addr R1  */
-
-  /* class 5 */
-#define MMC_ERASE_GROUP_START    35   /* ac   [31:0] data addr   R1  */
-#define MMC_ERASE_GROUP_END      36   /* ac   [31:0] data addr   R1  */
-#define MMC_ERASE                38   /* ac                      R1b */
-
-  /* class 9 */
-#define MMC_FAST_IO              39   /* ac   <Complex>          R4  */
-#define MMC_GO_IRQ_STATE         40   /* bcr                     R5  */
-
-  /* class 7 */
-#define MMC_LOCK_UNLOCK          42   /* adtc                    R1b */
-
-  /* class 8 */
-#define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
-#define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
-
-/*
- * MMC_SWITCH argument format:
- *
- *	[31:26] Always 0
- *	[25:24] Access Mode
- *	[23:16] Location of target Byte in EXT_CSD
- *	[15:08] Value Byte
- *	[07:03] Always 0
- *	[02:00] Command Set
- */
-
-#define MMC_BUS_WIDTH_1		0
-#define MMC_BUS_WIDTH_4		2
-#define MMC_BUS_WIDTH_8		3
-
-/*
-  MMC status in R1, for native mode (SPI bits are different)
-  Type
-	e : error bit
-	s : status bit
-	r : detected and set for the actual command response
-	x : detected and set during command execution. the host must poll
-		the card by sending status command in order to read these bits.
-  Clear condition
-	a : according to the card state
-	b : always related to the previous command. Reception of
-		a valid command will clear it (with a delay of one command)
-	c : clear by read
- */
-
-#define R1_OUT_OF_RANGE		(1 << 31)	/* er, c */
-#define R1_ADDRESS_ERROR	(1 << 30)	/* erx, c */
-#define R1_BLOCK_LEN_ERROR	(1 << 29)	/* er, c */
-#define R1_ERASE_SEQ_ERROR      (1 << 28)	/* er, c */
-#define R1_ERASE_PARAM		(1 << 27)	/* ex, c */
-#define R1_WP_VIOLATION		(1 << 26)	/* erx, c */
-#define R1_CARD_IS_LOCKED	(1 << 25)	/* sx, a */
-#define R1_LOCK_UNLOCK_FAILED	(1 << 24)	/* erx, c */
-#define R1_COM_CRC_ERROR	(1 << 23)	/* er, b */
-#define R1_ILLEGAL_COMMAND	(1 << 22)	/* er, b */
-#define R1_CARD_ECC_FAILED	(1 << 21)	/* ex, c */
-#define R1_CC_ERROR		(1 << 20)	/* erx, c */
-#define R1_ERROR		(1 << 19)	/* erx, c */
-#define R1_UNDERRUN		(1 << 18)	/* ex, c */
-#define R1_OVERRUN		(1 << 17)	/* ex, c */
-#define R1_CID_CSD_OVERWRITE	(1 << 16)	/* erx, c, CID/CSD overwrite */
-#define R1_WP_ERASE_SKIP	(1 << 15)	/* sx, c */
-#define R1_CARD_ECC_DISABLED	(1 << 14)	/* sx, a */
-#define R1_ERASE_RESET		(1 << 13)	/* sr, c */
-#define R1_STATUS(x)            (x & 0xFFFFE000)
-#define R1_CURRENT_STATE(x)	((x & 0x00001E00) >> 9)	/* sx, b (4 bits) */
-#define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
-#define R1_APP_CMD		(1 << 5)	/* sr, c */
-
-/*
- * MMC/SD in SPI mode reports R1 status always, and R2 for SEND_STATUS
- * R1 is the low order byte; R2 is the next highest byte, when present.
- */
-#define R1_SPI_IDLE		(1 << 0)
-#define R1_SPI_ERASE_RESET	(1 << 1)
-#define R1_SPI_ILLEGAL_COMMAND	(1 << 2)
-#define R1_SPI_COM_CRC		(1 << 3)
-#define R1_SPI_ERASE_SEQ	(1 << 4)
-#define R1_SPI_ADDRESS		(1 << 5)
-#define R1_SPI_PARAMETER	(1 << 6)
-/* R1 bit 7 is always zero */
-#define R2_SPI_CARD_LOCKED	(1 << 8)
-#define R2_SPI_WP_ERASE_SKIP	(1 << 9)	/* or lock/unlock fail */
-#define R2_SPI_LOCK_UNLOCK_FAIL	R2_SPI_WP_ERASE_SKIP
-#define R2_SPI_ERROR		(1 << 10)
-#define R2_SPI_CC_ERROR		(1 << 11)
-#define R2_SPI_CARD_ECC_ERROR	(1 << 12)
-#define R2_SPI_WP_VIOLATION	(1 << 13)
-#define R2_SPI_ERASE_PARAM	(1 << 14)
-#define R2_SPI_OUT_OF_RANGE	(1 << 15)	/* or CSD overwrite */
-#define R2_SPI_CSD_OVERWRITE	R2_SPI_OUT_OF_RANGE
-
-/* These are unpacked versions of the actual responses */
-
-struct _mmc_csd {
-	u8  csd_structure;
-	u8  spec_vers;
-	u8  taac;
-	u8  nsac;
-	u8  tran_speed;
-	u16 ccc;
-	u8  read_bl_len;
-	u8  read_bl_partial;
-	u8  write_blk_misalign;
-	u8  read_blk_misalign;
-	u8  dsr_imp;
-	u16 c_size;
-	u8  vdd_r_curr_min;
-	u8  vdd_r_curr_max;
-	u8  vdd_w_curr_min;
-	u8  vdd_w_curr_max;
-	u8  c_size_mult;
-	union {
-		struct { /* MMC system specification version 3.1 */
-			u8  erase_grp_size;
-			u8  erase_grp_mult;
-		} v31;
-		struct { /* MMC system specification version 2.2 */
-			u8  sector_size;
-			u8  erase_grp_size;
-		} v22;
-	} erase;
-	u8  wp_grp_size;
-	u8  wp_grp_enable;
-	u8  default_ecc;
-	u8  r2w_factor;
-	u8  write_bl_len;
-	u8  write_bl_partial;
-	u8  file_format_grp;
-	u8  copy;
-	u8  perm_write_protect;
-	u8  tmp_write_protect;
-	u8  file_format;
-	u8  ecc;
-};
-
-/*
- * OCR bits are mostly in host.h
- */
-#define MMC_CARD_BUSY	0x80000000	/* Card Power up status bit */
-
-/*
- * Card Command Classes (CCC)
- */
-#define CCC_BASIC		(1<<0)	/* (0) Basic protocol functions */
-					/* (CMD0,1,2,3,4,7,9,10,12,13,15) */
-					/* (and for SPI, CMD58,59) */
-#define CCC_STREAM_READ		(1<<1)	/* (1) Stream read commands */
-					/* (CMD11) */
-#define CCC_BLOCK_READ		(1<<2)	/* (2) Block read commands */
-					/* (CMD16,17,18) */
-#define CCC_STREAM_WRITE	(1<<3)	/* (3) Stream write commands */
-					/* (CMD20) */
-#define CCC_BLOCK_WRITE		(1<<4)	/* (4) Block write commands */
-					/* (CMD16,24,25,26,27) */
-#define CCC_ERASE		(1<<5)	/* (5) Ability to erase blocks */
-					/* (CMD32,33,34,35,36,37,38,39) */
-#define CCC_WRITE_PROT		(1<<6)	/* (6) Able to write protect blocks */
-					/* (CMD28,29,30) */
-#define CCC_LOCK_CARD		(1<<7)	/* (7) Able to lock down card */
-					/* (CMD16,CMD42) */
-#define CCC_APP_SPEC		(1<<8)	/* (8) Application specific */
-					/* (CMD55,56,57,ACMD*) */
-#define CCC_IO_MODE		(1<<9)	/* (9) I/O mode */
-					/* (CMD5,39,40,52,53) */
-#define CCC_SWITCH		(1<<10)	/* (10) High speed switch */
-					/* (CMD6,34,35,36,37,50) */
-					/* (11) Reserved */
-					/* (CMD?) */
-
-/*
- * CSD field definitions
- */
-
-#define CSD_STRUCT_VER_1_0  0  /* Valid for system specification 1.0 - 1.2 */
-#define CSD_STRUCT_VER_1_1  1  /* Valid for system specification 1.4 - 2.2 */
-/* Valid for system specification 3.1 - 3.2 - 3.31 - 4.0 - 4.1 */
-#define CSD_STRUCT_VER_1_2  2
-/* Version is coded in CSD_STRUCTURE in EXT_CSD */
-#define CSD_STRUCT_EXT_CSD  3
-
-#define CSD_SPEC_VER_0 0  /* Implements system specification 1.0 - 1.2 */
-#define CSD_SPEC_VER_1 1  /* Implements system specification 1.4 */
-#define CSD_SPEC_VER_2 2  /* Implements system specification 2.0 - 2.2 */
-#define CSD_SPEC_VER_3 3  /* Implements system specification 3.1 - 3.2 - 3.31 */
-#define CSD_SPEC_VER_4 4  /* Implements system specification 4.0 - 4.1 */
-
-/*
- * EXT_CSD fields
- */
-
-#define EXT_CSD_BUS_WIDTH	183	/* R/W */
-#define EXT_CSD_HS_TIMING	185	/* R/W */
-#define EXT_CSD_CARD_TYPE	196	/* RO */
-#define EXT_CSD_REV		192	/* RO */
-#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
-
-/*
- * EXT_CSD field definitions
- */
-
-#define EXT_CSD_CMD_SET_NORMAL		(1<<0)
-#define EXT_CSD_CMD_SET_SECURE		(1<<1)
-#define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
-
-#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
-#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
-
-#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
-#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
-#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
-
-/*
- * MMC_SWITCH access modes
- */
-
-#define MMC_SWITCH_MODE_CMD_SET	  0x00  /* Change the command set */
-#define MMC_SWITCH_MODE_SET_BITS  0x01  /* Set bits which are 1 in value */
-#define MMC_SWITCH_MODE_CLEAR_BITS 0x02 /* Clear bits which are 1 in value */
-#define MMC_SWITCH_MODE_WRITE_BYTE 0x03 /* Set target to value */
-
-#endif  /* MMC_MMC_PROTOCOL_H */
-
diff --git a/include/linux/mmc/sd.h b/include/linux/mmc/sd.h
deleted file mode 100644
index f236909..0000000
--- a/include/linux/mmc/sd.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- *  include/linux/mmc/sd.h
- *
- *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
- *
- * Copyright 2008-2009 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- */
-
-#ifndef MMC_SD_H
-#define MMC_SD_H
-
-/* SD commands                           type  argument     response */
-  /* class 0 */
-/* This is basically the same command as for MMC with some quirks. */
-#define SD_SEND_RELATIVE_ADDR     3   /* bcr                     R6  */
-#define SD_SEND_IF_COND           8   /* bcr  [11:0] See below   R7  */
-
-  /* class 10 */
-#define SD_SWITCH                 6   /* adtc [31:0] See below   R1  */
-
-  /* Application commands */
-#define SD_APP_SET_BUS_WIDTH      6   /* ac   [1:0] bus width    R1  */
-#define SD_APP_SEND_NUM_WR_BLKS  22   /* adtc                    R1  */
-#define SD_APP_OP_COND           41   /* bcr  [31:0] OCR         R3  */
-#define SD_APP_SEND_SCR          51   /* adtc                    R1  */
-
-#define SD_OCR_VALUE_HV_LC     (0x00ff8000)
-#define SD_OCR_VALUE_HV_HC     (0x40ff8000)
-#define SD_OCR_VALUE_LV_HC     (0x40000080)
-#define SD_OCR_HC_RES          (0x40000000)
-#define SD_IF_HV_COND_ARG      (0x000001AA)
-#define SD_IF_LV_COND_ARG      (0x000002AA)
-
-#define SD_OCR_VALUE_COUNT     (3)
-#define SD_IF_CMD_ARG_COUNT    (2)
-
-/*
- * SD_SWITCH argument format:
- *
- *      [31] Check (0) or switch (1)
- *      [30:24] Reserved (0)
- *      [23:20] Function group 6
- *      [19:16] Function group 5
- *      [15:12] Function group 4
- *      [11:8] Function group 3
- *      [7:4] Function group 2
- *      [3:0] Function group 1
- */
-
-/*
- * SD_SEND_IF_COND argument format:
- *
- *	[31:12] Reserved (0)
- *	[11:8] Host Voltage Supply Flags
- *	[7:0] Check Pattern (0xAA)
- */
-
-/*
- * SCR field definitions
- */
-
-#define SCR_SPEC_VER_0  0   /* Implements system specification 1.0 - 1.01 */
-#define SCR_SPEC_VER_1  1   /* Implements system specification 1.10 */
-#define SCR_SPEC_VER_2  2   /* Implements system specification 2.00 */
-
-/*
- * SD bus widths
- */
-#define SD_BUS_WIDTH_1  0
-#define SD_BUS_WIDTH_4  2
-
-/*
- * SD_SWITCH mode
- */
-#define SD_SWITCH_CHECK 0
-#define SD_SWITCH_SET   1
-
-/*
- * SD_SWITCH function groups
- */
-#define SD_SWITCH_GRP_ACCESS 0
-
-/*
- * SD_SWITCH access modes
- */
-#define SD_SWITCH_ACCESS_DEF 0
-#define SD_SWITCH_ACCESS_HS  1
-
-#endif
-
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
deleted file mode 100644
index ee7fb26..0000000
--- a/include/linux/mmc/sdhci.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- *  linux/drivers/mmc/host/sdhci.h - Secure Digital Host Controller Interface driver
- *
- *  (C) Copyright 2008-2009 Freescale Semiconductor, Inc.
- *  Copyright (C) 2005-2008 Pierre Ossman, All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- */
-
-/*
- * PCI registers
- */
-
-#define PCI_SDHCI_IFPIO			0x00
-#define PCI_SDHCI_IFDMA			0x01
-#define PCI_SDHCI_IFVENDOR		0x02
-
-#define PCI_SLOT_INFO			0x40	/* 8 bits */
-#define  PCI_SLOT_INFO_SLOTS(x)		((x >> 4) & 7)
-#define  PCI_SLOT_INFO_FIRST_BAR_MASK	0x07
-
-/*
- * Controller registers
- */
-
-#define SDHCI_DMA_ADDRESS	0x00
-
-#define SDHCI_BLOCK_SIZE	0x04
-#define  SDHCI_MAKE_BLKSZ(dma, blksz) (((dma & 0x7) << 12) | (blksz & 0xFFF))
-
-#define SDHCI_BLOCK_COUNT	0x06
-
-#define SDHCI_ARGUMENT		0x08
-
-#define SDHCI_TRANSFER_MODE	0x0C
-#define  SDHCI_TRNS_DMA		0x01
-#define  SDHCI_TRNS_BLK_CNT_EN	0x02
-#define  SDHCI_TRNS_ACMD12	0x04
-#define  SDHCI_TRNS_READ	0x10
-#define  SDHCI_TRNS_MULTI	0x20
-
-#define SDHCI_COMMAND		0x0E
-#define  SDHCI_CMD_RESP_MASK	0x03
-#define  SDHCI_CMD_CRC		0x08
-#define  SDHCI_CMD_INDEX	0x10
-#define  SDHCI_CMD_DATA		0x20
-
-#define  SDHCI_CMD_RESP_NONE	0x00
-#define  SDHCI_CMD_RESP_LONG	0x01
-#define  SDHCI_CMD_RESP_SHORT	0x02
-#define  SDHCI_CMD_RESP_SHORT_BUSY 0x03
-
-#define SDHCI_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
-
-#define SDHCI_RESPONSE		0x10
-
-#define SDHCI_BUFFER		0x20
-
-#define SDHCI_PRESENT_STATE	0x24
-#define  SDHCI_CMD_INHIBIT	0x00000001
-#define  SDHCI_DATA_INHIBIT	0x00000002
-#define  SDHCI_DOING_WRITE	0x00000100
-#define  SDHCI_DOING_READ	0x00000200
-#define  SDHCI_SPACE_AVAILABLE	0x00000400
-#define  SDHCI_DATA_AVAILABLE	0x00000800
-#define  SDHCI_CARD_PRESENT	0x00010000
-#define  SDHCI_WRITE_PROTECT	0x00080000
-
-#define SDHCI_HOST_CONTROL 	0x28
-#define  SDHCI_CTRL_LED		0x01
-#define  SDHCI_CTRL_4BITBUS	0x00000002
-#define  SDHCI_CTRL_8BITBUS	0x00000004
-#define  SDHCI_CTRL_HISPD	0x04
-
-#define SDHCI_POWER_CONTROL	0x29
-#define  SDHCI_POWER_ON		0x01
-#define  SDHCI_POWER_180	0x0A
-#define  SDHCI_POWER_300	0x0C
-#define  SDHCI_POWER_330	0x0E
-
-#define SDHCI_BLOCK_GAP_CONTROL	0x2A
-
-#define SDHCI_WAKE_UP_CONTROL	0x2B
-
-#define SDHCI_CLOCK_CONTROL	0x2C
-#define SDHCI_SYSTEM_CONTROL 0x2C
-#define  SDHCI_DIVIDER_SHIFT	8
-#define  SDHCI_CLOCK_CARD_EN	0x0004
-#define  SDHCI_CLOCK_INT_STABLE	0x0002
-#define  SDHCI_CLOCK_INT_EN	0x0001
-
-#define SDHCI_TIMEOUT_CONTROL	0x2E
-
-#define SDHCI_SOFTWARE_RESET	0x2F
-#define  SDHCI_RESET_ALL	0x01
-#define  SDHCI_RESET_CMD	0x02
-#define  SDHCI_RESET_DATA	0x04
-
-#define SDHCI_INT_STATUS	0x30
-#define SDHCI_INT_ENABLE	0x34
-#define SDHCI_SIGNAL_ENABLE	0x38
-#define  SDHCI_INT_RESPONSE	0x00000001
-#define  SDHCI_INT_DATA_END	0x00000002
-#define  SDHCI_INT_DMA_END	0x00000008
-#define  SDHCI_INT_SPACE_AVAIL	0x00000010
-#define  SDHCI_INT_DATA_AVAIL	0x00000020
-#define  SDHCI_INT_CARD_INSERT	0x00000040
-#define  SDHCI_INT_CARD_REMOVE	0x00000080
-#define  SDHCI_INT_CARD_INT	0x00000100
-#define  SDHCI_INT_ERROR	0x00008000
-#define  SDHCI_INT_TIMEOUT	0x00010000
-#define  SDHCI_INT_CRC		0x00020000
-#define  SDHCI_INT_END_BIT	0x00040000
-#define  SDHCI_INT_INDEX	0x00080000
-#define  SDHCI_INT_DATA_TIMEOUT	0x00100000
-#define  SDHCI_INT_DATA_CRC	0x00200000
-#define  SDHCI_INT_DATA_END_BIT	0x00400000
-#define  SDHCI_INT_BUS_POWER	0x00800000
-#define  SDHCI_INT_ACMD12ERR	0x01000000
-
-#define  SDHCI_INT_NORMAL_MASK	0x00007FFF
-#define  SDHCI_INT_ERROR_MASK	0xFFFF8000
-
-#define  SDHCI_INT_CMD_MASK	(SDHCI_INT_RESPONSE | SDHCI_INT_TIMEOUT | \
-		SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX)
-#define  SDHCI_INT_DATA_MASK	(SDHCI_INT_DATA_END | SDHCI_INT_DMA_END | \
-		SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL | \
-		SDHCI_INT_DATA_TIMEOUT | SDHCI_INT_DATA_CRC | \
-		SDHCI_INT_DATA_END_BIT)
-
-#define SDHCI_ACMD12_ERR	0x3C
-
-/* 3E-3F reserved */
-
-#define SDHCI_CAPABILITIES	0x40
-#define  SDHCI_TIMEOUT_CLK_MASK	0x0000003F
-#define  SDHCI_TIMEOUT_CLK_SHIFT 0
-#define  SDHCI_TIMEOUT_CLK_UNIT	0x00000080
-#define  SDHCI_CLOCK_BASE_MASK	0x00003F00
-#define  SDHCI_CLOCK_BASE_SHIFT	8
-#define  SDHCI_MAX_BLOCK_MASK	0x00030000
-#define  SDHCI_MAX_BLOCK_SHIFT  16
-#define  SDHCI_CAN_DO_HISPD	0x00200000
-#define  SDHCI_CAN_DO_DMA	0x00400000
-#define  SDHCI_CAN_VDD_330	0x01000000
-#define  SDHCI_CAN_VDD_300	0x02000000
-#define  SDHCI_CAN_VDD_180	0x04000000
-
-/* 44-47 reserved for more caps */
-#define SDHCI_WML_LEV		0x44
-
-#define SDHCI_MAX_CURRENT	0x48
-
-/* 4C-4F reserved for more max current */
-
-/* 50-FB reserved */
-
-#define SDHCI_SLOT_INT_STATUS	0xFC
-
-#define SDHCI_HOST_VERSION	0xFE
-#define  SDHCI_VENDOR_VER_MASK	0xFF00
-#define  SDHCI_VENDOR_VER_SHIFT	8
-#define  SDHCI_SPEC_VER_MASK	0x00FF
-#define  SDHCI_SPEC_VER_SHIFT	0
-
-#if 0
-
-struct sdhci_chip;
-
-struct sdhci_host {
-	struct sdhci_chip	*chip;
-	struct mmc_host		*mmc;		/* MMC structure */
-
-#ifdef CONFIG_LEDS_CLASS
-	struct led_classdev	led;		/* LED control */
-#endif
-
-	spinlock_t		lock;		/* Mutex */
-
-	int			flags;		/* Host attributes */
-#define SDHCI_USE_DMA		(1<<0)		/* Host is DMA capable */
-#define SDHCI_REQ_USE_DMA	(1<<1)		/* Use DMA for this req. */
-
-	unsigned int		max_clk;	/* Max possible freq (MHz) */
-	unsigned int		timeout_clk;	/* Timeout freq (KHz) */
-
-	unsigned int		clock;		/* Current clock (MHz) */
-	unsigned short		power;		/* Current voltage */
-
-	struct mmc_request	*mrq;		/* Current request */
-	struct mmc_command	*cmd;		/* Current command */
-	struct mmc_data		*data;		/* Current data request */
-	unsigned int		data_early:1;	/* Data finished before cmd */
-
-	struct scatterlist	*cur_sg;	/* We're working on this */
-	int			num_sg;		/* Entries left */
-	int			offset;		/* Offset into current sg */
-	int			remain;		/* Bytes left in current */
-
-	int			irq;		/* Device IRQ */
-	int			bar;		/* PCI BAR index */
-	unsigned long		addr;		/* Bus address */
-	void __iomem		*ioaddr;		/* Mapped address */
-
-	struct tasklet_struct	card_tasklet;	/* Tasklet structures */
-	struct tasklet_struct	finish_tasklet;
-
-	struct timer_list	timer;		/* Timer for timeouts */
-};
-
-struct sdhci_chip {
-	struct pci_dev		*pdev;
-
-	unsigned long		quirks;
-
-	int			num_slots;	/* Slots on controller */
-	struct sdhci_host	*hosts[0];	/* Pointers to hosts */
-};
-
-#endif
diff --git a/lib_arm/board.c b/lib_arm/board.c
index 552ea5f..fce188d 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -374,6 +374,11 @@ void start_armboot (void)
 	dataflash_print_info();
 #endif
 
+#ifdef CONFIG_GENERIC_MMC
+	puts ("MMC:   ");
+	mmc_initialize (gd->bd);
+#endif
+
 	/* initialize environment */
 	env_relocate ();
 
@@ -456,11 +461,6 @@ extern void davinci_eth_set_mac_addr (const u_int8_t *addr);
 	board_late_init ();
 #endif
 
-#ifdef CONFIG_GENERIC_MMC
-	puts ("MMC:   ");
-	mmc_initialize (gd->bd);
-#endif
-
 #if defined(CONFIG_CMD_NET)
 #if defined(CONFIG_NET_MULTI)
 	puts ("Net:   ");
diff --git a/net/eth.c b/net/eth.c
index 67f6646..b72a4e8 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -523,8 +523,8 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_DRIVER_NS7520_ETHERNET)
 	ns7520_miiphy_initialize(bis);
 #endif
-#if defined(CONFIG_DRIVER_SMC911X)
-	smc911x_initialize(bis);
+#if defined(CONFIG_SMC911X)
+	smc911x_initialize(0, CONFIG_SMC911X_BASE);
 #endif
 	return 0;
 }
-- 
1.5.4.4

