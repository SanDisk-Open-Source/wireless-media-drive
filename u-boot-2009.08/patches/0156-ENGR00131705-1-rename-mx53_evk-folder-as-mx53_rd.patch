From ce931c240eb5fc03fd1df850e1a1b9dd995baeda Mon Sep 17 00:00:00 2001
From: Lily Zhang <r58066@freescale.com>
Date: Sun, 19 Sep 2010 15:51:44 +0800
Subject: [PATCH] ENGR00131705-1 rename mx53_evk folder as mx53_rd

Rename the folder "mx53_evk" as "mx53_rd" to put
all MX53 board files.

Signed-off-by: Terry Lv <r65388@freescale.com>
Signed-off-by: Lily Zhang <r58066@freescale.com>
---
 Makefile                                 |    2 +-
 board/freescale/mx53_evk/Makefile        |   49 --
 board/freescale/mx53_evk/config.mk       |    3 -
 board/freescale/mx53_evk/flash_header.S  |  250 --------
 board/freescale/mx53_evk/lowlevel_init.S |  219 -------
 board/freescale/mx53_evk/mx53_evk.c      | 1001 ------------------------------
 board/freescale/mx53_evk/u-boot.lds      |   73 ---
 board/freescale/mx53_rd/Makefile         |   49 ++
 board/freescale/mx53_rd/config.mk        |    3 +
 board/freescale/mx53_rd/flash_header.S   |  250 ++++++++
 board/freescale/mx53_rd/lowlevel_init.S  |  219 +++++++
 board/freescale/mx53_rd/mx53_rd.c        | 1001 ++++++++++++++++++++++++++++++
 board/freescale/mx53_rd/u-boot.lds       |   73 +++
 13 files changed, 1596 insertions(+), 1596 deletions(-)

diff --git a/Makefile b/Makefile
index 42a0e97..11ed5db 100644
--- a/Makefile
+++ b/Makefile
@@ -3274,7 +3274,7 @@ mx53_arm2_android_config	\
 mx53_arm2_ddr3_android_config	\
 mx53_evk_android_config		\
 mx53_evk_config      : unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 mx53_evk freescale mx53
+	@$(MKCONFIG) $(@:_config=) arm arm_cortexa8 mx53_rd freescale mx53
 
 omap2420h4_config	: unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm1136 omap2420h4 NULL omap24xx
diff --git a/board/freescale/mx53_evk/Makefile b/board/freescale/mx53_evk/Makefile
deleted file mode 100644
index 9e20903..0000000
--- a/board/freescale/mx53_evk/Makefile
+++ /dev/null
@@ -1,49 +0,0 @@
-#
-# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
-#
-# (C) Copyright 2010 Freescale Semiconductor, Inc.
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-# MA 02111-1307 USA
-#
-
-include $(TOPDIR)/config.mk
-
-LIB	= $(obj)lib$(BOARD).a
-
-COBJS	:= mx53_evk.o
-SOBJS	:= lowlevel_init.o flash_header.o
-
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(COBJS))
-SOBJS	:= $(addprefix $(obj),$(SOBJS))
-
-$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
-
-clean:
-	rm -f $(SOBJS) $(OBJS)
-
-distclean:	clean
-	rm -f $(LIB) core *.bak .depend
-
-#########################################################################
-
-# defines $(obj).depend target
-include $(SRCTREE)/rules.mk
-
-sinclude $(obj).depend
-
-#########################################################################
diff --git a/board/freescale/mx53_evk/config.mk b/board/freescale/mx53_evk/config.mk
deleted file mode 100644
index 34f830a..0000000
--- a/board/freescale/mx53_evk/config.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
-
-TEXT_BASE = 0x77800000
diff --git a/board/freescale/mx53_evk/flash_header.S b/board/freescale/mx53_evk/flash_header.S
deleted file mode 100644
index 014333d..0000000
--- a/board/freescale/mx53_evk/flash_header.S
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <asm/arch/mx53.h>
-
-#ifdef	CONFIG_FLASH_HEADER
-#ifndef CONFIG_FLASH_HEADER_OFFSET
-# error "Must define the offset of flash header"
-#endif
-
-#define CPU_2_BE_32(l) \
-       ((((l) & 0x000000FF) << 24) | \
-	(((l) & 0x0000FF00) << 8)  | \
-	(((l) & 0x00FF0000) >> 8)  | \
-	(((l) & 0xFF000000) >> 24))
-
-#define MXC_DCD_ITEM(i, addr, val)   \
-dcd_node_##i:                        \
-        .word CPU_2_BE_32(addr) ;     \
-        .word CPU_2_BE_32(val)  ;     \
-
-.section ".text.flasheader", "x"
-	b	_start
-	.org	CONFIG_FLASH_HEADER_OFFSET
-ivt_header:       .word 0x402000D1 /* Tag=0xD1, Len=0x0020, Ver=0x40 */
-app_code_jump_v:  .word _start
-reserv1:          .word 0x0
-dcd_ptr:          .word dcd_hdr
-boot_data_ptr:	  .word boot_data
-self_ptr:         .word ivt_header
-app_code_csf:     .word 0x0
-reserv2:          .word 0x0
-
-boot_data:        .word 0x77800000
-image_len:        .word _end - TEXT_BASE
-plugin:           .word 0x0
-
-#if defined(CONFIG_MX53_EVK)
-dcd_hdr:          .word 0x400802D2 /* Tag=0xD2, Len=64*8 + 4 + 4, Ver=0x40 */
-write_dcd_cmd:    .word 0x040402CC /* Tag=0xCC, Len=64*8 + 4, Param=4 */
-
-/* DCD */
-MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00380000)
-MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00380040)
-MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00380000)
-MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00380040)
-MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00380040)
-MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00200000)
-MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00380000)
-MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00200000)
-MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00380040)
-MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00380040)
-MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00380000)
-MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00380000)
-MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00380040)
-MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00380000)
-MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00380000)
-MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000200)
-MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
-MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
-MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00380000)
-MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00380000)
-MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00380000)
-MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x06000000)
-MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00380000)
-MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00380000)
-MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x2b2f3031)
-MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40363333)
-MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x098, 0x00000f00)
-MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x0f8, 0x00000800)
-MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x07c, 0x01310132)
-MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x080, 0x0133014b)
-MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x018, 0x000016d0)
-MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x000, 0xc4110000)
-MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x00c, 0x4d5122d2)
-MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x010, 0x92d18a22)
-MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x014, 0x00c70092)
-MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
-MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x030, 0x009f000e)
-MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
-MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
-MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
-MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
-MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
-MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x00008031)
-MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x0b5280b0)
-MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
-MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
-MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
-MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x01c, 0x0a528030)
-MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x01c, 0x03c68031)
-MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x01c, 0x00468031)
-MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
-MXC_DCD_ITEM(52, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
-MXC_DCD_ITEM(53, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
-MXC_DCD_ITEM(54, ESDCTL_BASE_ADDR + 0x01c, 0x00008039)
-MXC_DCD_ITEM(55, ESDCTL_BASE_ADDR + 0x01c, 0x0b528138)
-MXC_DCD_ITEM(56, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
-MXC_DCD_ITEM(57, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
-MXC_DCD_ITEM(58, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
-MXC_DCD_ITEM(59, ESDCTL_BASE_ADDR + 0x01c, 0x0a528038)
-MXC_DCD_ITEM(60, ESDCTL_BASE_ADDR + 0x01c, 0x03c68039)
-MXC_DCD_ITEM(61, ESDCTL_BASE_ADDR + 0x01c, 0x00468039)
-MXC_DCD_ITEM(62, ESDCTL_BASE_ADDR + 0x020, 0x00005800)
-MXC_DCD_ITEM(63, ESDCTL_BASE_ADDR + 0x058, 0x00033337)
-MXC_DCD_ITEM(64, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
-
-#elif defined(CONFIG_MX53_ARM2) /*ARM2 board*/
-dcd_hdr:          .word 0x400002D2 /* Tag=0xD2, Len=63*8 + 4 + 4, Ver=0x40 */
-write_dcd_cmd:    .word 0x04FC01CC /* Tag=0xCC, Len=63*8 + 4, Param=4 */
-
-/* DCD */
-MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00380000)
-MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00380040)
-MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00380000)
-MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00380040)
-MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00380040)
-MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00380000)
-MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00380000)
-MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00380000)
-MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00380040)
-MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00380040)
-MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00380000)
-MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00380000)
-MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00380040)
-MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00380000)
-MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00380000)
-MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000200)
-MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
-MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
-MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00380000)
-MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00380000)
-MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00380000)
-MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x02000000)
-MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00380000)
-MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00380000)
-MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x2d313331)
-MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40363333)
-MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x0f8, 0x00000800)
-MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x07c, 0x020c0211)
-MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x080, 0x014c0155)
-MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x018, 0x00001710)
-MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x000, 0xc4110000)
-MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x00c, 0x4d5122d2)
-MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x010, 0x92d18a22)
-MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x014, 0x00c70092)
-MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
-MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x030, 0x009f000e)
-MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
-MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
-MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
-MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
-MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
-MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x00008031)
-MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x0b5280b0)
-MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
-MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
-MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
-MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x0a528030)
-MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x01c, 0x03c68031)
-MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x01c, 0x00468031)
-MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
-MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
-MXC_DCD_ITEM(52, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
-MXC_DCD_ITEM(53, ESDCTL_BASE_ADDR + 0x01c, 0x00008039)
-MXC_DCD_ITEM(54, ESDCTL_BASE_ADDR + 0x01c, 0x0b528138)
-MXC_DCD_ITEM(55, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
-MXC_DCD_ITEM(56, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
-MXC_DCD_ITEM(57, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
-MXC_DCD_ITEM(58, ESDCTL_BASE_ADDR + 0x01c, 0x0a528038)
-MXC_DCD_ITEM(59, ESDCTL_BASE_ADDR + 0x01c, 0x03c68039)
-MXC_DCD_ITEM(60, ESDCTL_BASE_ADDR + 0x01c, 0x00468039)
-MXC_DCD_ITEM(61, ESDCTL_BASE_ADDR + 0x020, 0x00005800)
-MXC_DCD_ITEM(62, ESDCTL_BASE_ADDR + 0x058, 0x00033337)
-MXC_DCD_ITEM(63, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
-#elif defined(CONFIG_MX53_ARM2_DDR3)
-dcd_hdr:          .word 0x40A001D2 /* Tag=0xD2, Len=51*8 + 4 + 4, Ver=0x40 */
-write_dcd_cmd:    .word 0x049C01CC /* Tag=0xCC, Len=51*8 + 4, Param=4 */
-
-/* DCD */
-MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00300000)
-MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00300040)
-MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00300000)
-MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00300040)
-MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00300040)
-MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00300000)
-MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00300000)
-MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00300000)
-MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00300040)
-MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00300040)
-MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00300000)
-MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00300000)
-MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00300040)
-MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00300000)
-MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00300000)
-MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000000)
-MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
-MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
-MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00300000)
-MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00300000)
-MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00300000)
-MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x04000000)
-MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00300000)
-MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00300000)
-MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x32383535)
-MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40383538)
-MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x07c, 0x0136014d)
-MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x080, 0x01510141)
-MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x018, 0x00091740)
-MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x000, 0xc4190000)
-MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x00c, 0x565a7543)
-MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x010, 0xb6ae8aa3)
-MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x014, 0x01ff00db)
-MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
-MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x030, 0x009f0e21)
-MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
-MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
-MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
-MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
-MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x00028031)
-MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x092080b0)
-MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x04008040)
-MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
-MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
-MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x00028039)
-MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x09208138)
-MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x04008048)
-MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x020, 0x00001800)
-MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x040, 0x04b80003)
-MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x058, 0x00022227)
-MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
-#endif
-#endif
diff --git a/board/freescale/mx53_evk/lowlevel_init.S b/board/freescale/mx53_evk/lowlevel_init.S
deleted file mode 100644
index d5e9f66..0000000
--- a/board/freescale/mx53_evk/lowlevel_init.S
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <config.h>
-#include <asm/arch/mx53.h>
-
-/*
- * L2CC Cache setup/invalidation/disable
- */
-.macro init_l2cc
-	/* explicitly disable L2 cache */
-        mrc 15, 0, r0, c1, c0, 1
-        bic r0, r0, #0x2
-        mcr 15, 0, r0, c1, c0, 1
-
-        /* reconfigure L2 cache aux control reg */
-        mov r0, #0xC0                   /* tag RAM */
-        add r0, r0, #0x4                /* data RAM */
-        orr r0, r0, #(1 << 24)          /* disable write allocate delay */
-        orr r0, r0, #(1 << 23)          /* disable write allocate combine */
-        orr r0, r0, #(1 << 22)          /* disable write allocate */
-
-	mcr 15, 1, r0, c9, c0, 2
-.endm /* init_l2cc */
-
-/* AIPS setup - Only setup MPROTx registers.
- * The PACR default values are good.*/
-.macro init_aips
-	/*
-	 * Set all MPROTx to be non-bufferable, trusted for R/W,
-	 * not forced to user-mode.
-	 */
-	ldr r0, =AIPS1_BASE_ADDR
-	ldr r1, =0x77777777
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-	ldr r0, =AIPS2_BASE_ADDR
-	str r1, [r0, #0x0]
-	str r1, [r0, #0x4]
-.endm /* init_aips */
-
-.macro setup_pll pll, freq
-	ldr r0, =\pll
-	ldr r1, =0x00001232
-	str r1, [r0, #PLL_DP_CTL]
-	mov r1, #0x2
-	str r1, [r0, #PLL_DP_CONFIG]
-
-	ldr r1, W_DP_OP_\freq
-	str r1, [r0, #PLL_DP_OP]
-	str r1, [r0, #PLL_DP_HFS_OP]
-
-	ldr r1,	W_DP_MFD_\freq
-	str r1, [r0, #PLL_DP_MFD]
-	str r1, [r0, #PLL_DP_HFS_MFD]
-
-	ldr r1,  W_DP_MFN_\freq
-	str r1, [r0, #PLL_DP_MFN]
-	str r1, [r0, #PLL_DP_HFS_MFN]
-
-	ldr r1, =0x00001232
-	str r1, [r0, #PLL_DP_CTL]
-1:	ldr r1, [r0, #PLL_DP_CTL]
-	ands r1, r1, #0x1
-	beq 1b
-.endm
-
-.macro init_clock
-	ldr r0, CCM_BASE_ADDR_W
-
-	/* Switch ARM to step clock */
-	mov r1, #0x4
-	str r1, [r0, #CLKCTL_CCSR]
-
-	setup_pll PLL1_BASE_ADDR, 800
-
-        setup_pll PLL3_BASE_ADDR, 400
-
-        /* Switch peripheral to PLL3 */
-        ldr r0, CCM_BASE_ADDR_W
-        ldr r1, CCM_VAL_0x00015154
-        str r1, [r0, #CLKCTL_CBCMR]
-        ldr r1, CCM_VAL_0x02888945
-        orr r1, r1, #(1 << 16)
-        str r1, [r0, #CLKCTL_CBCDR]
-        /* make sure change is effective */
-1:      ldr r1, [r0, #CLKCTL_CDHIPR]
-        cmp r1, #0x0
-        bne 1b
-
-        setup_pll PLL2_BASE_ADDR, CONFIG_SYS_PLL2_FREQ
-
-	/* Switch peripheral to PLL2 */
-	ldr r0, CCM_BASE_ADDR_W
-	ldr r1, CCM_VAL_0x00808145
-	orr r1, r1, #(CONFIG_SYS_AHB_PODF << 10)
-	orr r1, r1, #(CONFIG_SYS_AXIA_PODF << 16)
-	orr r1, r1, #(CONFIG_SYS_AXIB_PODF << 19)
-	str r1, [r0, #CLKCTL_CBCDR]
-
-	ldr r1, CCM_VAL_0x00016154
-	str r1, [r0, #CLKCTL_CBCMR]
-
-	/* make sure change is effective */
-1:      ldr r1, [r0, #CLKCTL_CDHIPR]
-	cmp r1, #0x0
-	bne 1b
-
-        setup_pll PLL3_BASE_ADDR, 216
-
-	/* Set the platform clock dividers */
-	ldr r0, PLATFORM_BASE_ADDR_W
-	ldr r1, PLATFORM_CLOCK_DIV_W
-	str r1, [r0, #PLATFORM_ICGC]
-
-	ldr r0, CCM_BASE_ADDR_W
-	mov r1, #1
-	str r1, [r0, #CLKCTL_CACRR]
-
-	/* Switch ARM back to PLL 1. */
-	mov r1, #0x0
-	str r1, [r0, #CLKCTL_CCSR]
-
-	ldr r1, [r0, #CLKCTL_CSCDR1]
-	orr r1, r1, #0x3f
-	eor r1, r1, #0x3f
-	orr r1, r1, #0x21
-	str r1, [r0, #CLKCTL_CSCDR1]
-
-	/* Restore the default values in the Gate registers */
-	ldr r1, =0xFFFFFFFF
-	str r1, [r0, #CLKCTL_CCGR0]
-	str r1, [r0, #CLKCTL_CCGR1]
-	str r1, [r0, #CLKCTL_CCGR2]
-	str r1, [r0, #CLKCTL_CCGR3]
-	str r1, [r0, #CLKCTL_CCGR4]
-	str r1, [r0, #CLKCTL_CCGR5]
-	str r1, [r0, #CLKCTL_CCGR6]
-	str r1, [r0, #CLKCTL_CCGR7]
-
-        mov r1, #0x00000
-        str r1, [r0, #CLKCTL_CCDR]
-
-        /* for cko - for ARM div by 8 */
-        mov r1, #0x000A0000
-        add r1, r1, #0x00000F0
-        str r1, [r0, #CLKCTL_CCOSR]
-.endm
-
-.section ".text.init", "x"
-
-.globl lowlevel_init
-lowlevel_init:
-
-#ifdef ENABLE_IMPRECISE_ABORT
-        mrs r1, spsr            /* save old spsr */
-        mrs r0, cpsr            /* read out the cpsr */
-	bic r0, r0, #0x100      /* clear the A bit */
-	msr spsr, r0            /* update spsr */
-	add lr, pc, #0x8        /* update lr */
-        movs pc, lr             /* update cpsr */
-        nop
-        nop
-        nop
-	nop
-	msr spsr, r1            /* restore old spsr */
-#endif
-
-	/* ARM errata ID #468414 */
-	mrc 15, 0, r1, c1, c0, 1
-	orr r1, r1, #(1 << 5)    /* enable L1NEON bit */
-	mcr 15, 0, r1, c1, c0, 1
-
-	init_l2cc
-
-	init_aips
-
-	init_clock
-
-	mov pc, lr
-
-/* Board level setting value */
-CCM_BASE_ADDR_W:        .word CCM_BASE_ADDR
-CCM_VAL_0x00016154:     .word 0x00016154
-CCM_VAL_0x00808145:     .word 0x00808145
-CCM_VAL_0x00015154:     .word 0x00015154
-CCM_VAL_0x02888945:     .word 0x02888945
-W_DP_OP_800:           	.word DP_OP_800
-W_DP_MFD_800:           .word DP_MFD_800
-W_DP_MFN_800:           .word DP_MFN_800
-W_DP_OP_600:            .word DP_OP_600
-W_DP_MFD_600:           .word DP_MFD_600
-W_DP_MFN_600:           .word DP_MFN_600
-W_DP_OP_400:            .word DP_OP_400
-W_DP_MFD_400:           .word DP_MFD_400
-W_DP_MFN_400:           .word DP_MFN_400
-W_DP_OP_216:            .word DP_OP_216
-W_DP_MFD_216:           .word DP_MFD_216
-W_DP_MFN_216:           .word DP_MFN_216
-PLATFORM_BASE_ADDR_W:   .word ARM_BASE_ADDR
-PLATFORM_CLOCK_DIV_W:   .word 0x00000124
diff --git a/board/freescale/mx53_evk/mx53_evk.c b/board/freescale/mx53_evk/mx53_evk.c
deleted file mode 100644
index 92b6ce9..0000000
--- a/board/freescale/mx53_evk/mx53_evk.c
+++ /dev/null
@@ -1,1001 +0,0 @@
-/*
- * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
- *
- * (C) Copyright 2009-2010 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include <asm/io.h>
-#include <asm/arch/mx53.h>
-#include <asm/arch/mx53_pins.h>
-#include <asm/arch/iomux.h>
-#include <asm/errno.h>
-#include <imx_spi.h>
-
-#if CONFIG_I2C_MXC
-#include <i2c.h>
-#endif
-
-#ifdef CONFIG_CMD_MMC
-#include <mmc.h>
-#include <fsl_esdhc.h>
-#endif
-
-#ifdef CONFIG_ARCH_MMU
-#include <asm/mmu.h>
-#include <asm/arch/mmu.h>
-#endif
-
-#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
-#include <asm/imx_iim.h>
-#endif
-
-#ifdef CONFIG_CMD_CLOCK
-#include <asm/clock.h>
-#endif
-
-#ifdef CONFIG_ANDROID_RECOVERY
-#include "../common/recovery.h"
-#include <part.h>
-#include <ext2fs.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-#include <ubi_uboot.h>
-#include <jffs2/load_kernel.h>
-#endif
-
-DECLARE_GLOBAL_DATA_PTR;
-
-static u32 system_rev;
-static enum boot_device boot_dev;
-
-static inline void setup_boot_device(void)
-{
-	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
-	uint bt_mem_ctl = (soc_sbmr & 0x000000FF) >> 4 ;
-	uint bt_mem_type = (soc_sbmr & 0x00000008) >> 3;
-
-	switch (bt_mem_ctl) {
-	case 0x0:
-		if (bt_mem_type)
-			boot_dev = ONE_NAND_BOOT;
-		else
-			boot_dev = WEIM_NOR_BOOT;
-		break;
-	case 0x2:
-		if (bt_mem_type)
-			boot_dev = SATA_BOOT;
-		else
-			boot_dev = PATA_BOOT;
-		break;
-	case 0x3:
-		if (bt_mem_type)
-			boot_dev = SPI_NOR_BOOT;
-		else
-			boot_dev = I2C_BOOT;
-		break;
-	case 0x4:
-	case 0x5:
-		boot_dev = SD_BOOT;
-		break;
-	case 0x6:
-	case 0x7:
-		boot_dev = MMC_BOOT;
-		break;
-	case 0x8 ... 0xf:
-		boot_dev = NAND_BOOT;
-		break;
-	default:
-		boot_dev = UNKNOWN_BOOT;
-		break;
-	}
-}
-
-enum boot_device get_boot_device(void)
-{
-	return boot_dev;
-}
-
-u32 get_board_rev(void)
-{
-	return system_rev;
-}
-
-static inline void setup_soc_rev(void)
-{
-	system_rev = 0x53000 | CHIP_REV_1_0;
-}
-
-static inline void setup_board_rev(int rev)
-{
-	system_rev |= (rev & 0xF) << 8;
-}
-
-inline int is_soc_rev(int rev)
-{
-	return (system_rev & 0xFF) - rev;
-}
-
-#ifdef CONFIG_ARCH_MMU
-void board_mmu_init(void)
-{
-	unsigned long ttb_base = PHYS_SDRAM_1 + 0x4000;
-	unsigned long i;
-
-	/*
-	* Set the TTB register
-	*/
-	asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
-
-	/*
-	* Set the Domain Access Control Register
-	*/
-	i = ARM_ACCESS_DACR_DEFAULT;
-	asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
-
-	/*
-	* First clear all TT entries - ie Set them to Faulting
-	*/
-	memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
-	/* Actual   Virtual  Size   Attributes          Function */
-	/* Base     Base     MB     cached? buffered?  access permissions */
-	/* xxx00000 xxx00000 */
-	X_ARM_MMU_SECTION(0x000, 0x000, 0x10,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* ROM, 16M */
-	X_ARM_MMU_SECTION(0x070, 0x070, 0x010,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* IRAM */
-	X_ARM_MMU_SECTION(0x100, 0x100, 0x040,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* SATA */
-	X_ARM_MMU_SECTION(0x180, 0x180, 0x100,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* IPUv3M */
-	X_ARM_MMU_SECTION(0x200, 0x200, 0x200,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* GPU */
-	X_ARM_MMU_SECTION(0x400, 0x400, 0x300,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* periperals */
-	X_ARM_MMU_SECTION(0x700, 0x700, 0x400,
-			ARM_CACHEABLE, ARM_BUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* CSD0 1G */
-	X_ARM_MMU_SECTION(0x700, 0xB00, 0x400,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* CSD0 1G */
-	X_ARM_MMU_SECTION(0xF00, 0xF00, 0x100,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* CS1 EIM control*/
-	X_ARM_MMU_SECTION(0xF7F, 0xF7F, 0x040,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* NAND Flash buffer */
-	X_ARM_MMU_SECTION(0xF80, 0xF80, 0x001,
-			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
-			ARM_ACCESS_PERM_RW_RW); /* iRam */
-
-	/* Workaround for arm errata #709718 */
-	/* Setup PRRR so device is always mapped to non-shared */
-	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r"(i) : /*:*/);
-	i &= (~(3 << 0x10));
-	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(i) /*:*/);
-
-	/* Enable MMU */
-	MMU_ON();
-}
-#endif
-
-int dram_init(void)
-{
-	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
-	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
-	return 0;
-}
-
-static void setup_uart(void)
-{
-
-	/* UART1 RXD */
-	mxc_request_iomux(MX53_PIN_CSI0_D11, IOMUX_CONFIG_ALT2);
-	mxc_iomux_set_pad(MX53_PIN_CSI0_D11, 0x1E4);
-	mxc_iomux_set_input(MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT, 0x1);
-
-	/* UART1 TXD */
-	mxc_request_iomux(MX53_PIN_CSI0_D10, IOMUX_CONFIG_ALT2);
-	mxc_iomux_set_pad(MX53_PIN_CSI0_D10, 0x1E4);
-}
-
-#ifdef CONFIG_I2C_MXC
-static void setup_i2c(unsigned int module_base)
-{
-	switch (module_base) {
-	case I2C1_BASE_ADDR:
-		/* i2c1 SDA */
-		mxc_request_iomux(MX53_PIN_CSI0_D8,
-				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
-		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
-				INPUT_CTL_PATH0);
-		mxc_iomux_set_pad(MX53_PIN_CSI0_D8, PAD_CTL_SRE_FAST |
-				PAD_CTL_ODE_OPENDRAIN_ENABLE |
-				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
-				PAD_CTL_HYS_ENABLE);
-		/* i2c1 SCL */
-		mxc_request_iomux(MX53_PIN_CSI0_D9,
-				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
-		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
-				INPUT_CTL_PATH0);
-		mxc_iomux_set_pad(MX53_PIN_CSI0_D9, PAD_CTL_SRE_FAST |
-				PAD_CTL_ODE_OPENDRAIN_ENABLE |
-				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
-				PAD_CTL_HYS_ENABLE);
-		break;
-	case I2C2_BASE_ADDR:
-		/* i2c2 SDA */
-		mxc_request_iomux(MX53_PIN_KEY_ROW3,
-				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
-		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
-				INPUT_CTL_PATH0);
-		mxc_iomux_set_pad(MX53_PIN_KEY_ROW3,
-				PAD_CTL_SRE_FAST |
-				PAD_CTL_ODE_OPENDRAIN_ENABLE |
-				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
-				PAD_CTL_HYS_ENABLE);
-
-		/* i2c2 SCL */
-		mxc_request_iomux(MX53_PIN_KEY_COL3,
-				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
-		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
-				INPUT_CTL_PATH0);
-		mxc_iomux_set_pad(MX53_PIN_KEY_COL3,
-				PAD_CTL_SRE_FAST |
-				PAD_CTL_ODE_OPENDRAIN_ENABLE |
-				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
-				PAD_CTL_HYS_ENABLE);
-		break;
-	default:
-		printf("Invalid I2C base: 0x%x\n", module_base);
-		break;
-	}
-}
-
-void setup_core_voltages(void)
-{
-	unsigned char buf[4] = { 0 };
-
-	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
-
-	/* Set core voltage VDDGP to 1.05V for 800MHZ */
-	buf[0] = 0x45;
-	buf[1] = 0x4a;
-	buf[2] = 0x52;
-	if (i2c_write(0x8, 24, 1, buf, 3))
-		return;
-
-	/* Set DDR voltage VDDA to 1.25V */
-	buf[0] = 0;
-	buf[1] = 0x63;
-	buf[2] = 0x1a;
-	if (i2c_write(0x8, 26, 1, buf, 3))
-		return;
-
-	/* Raise the core frequency to 800MHz */
-	writel(0x0, CCM_BASE_ADDR + CLKCTL_CACRR);
-}
-
-#ifndef CONFIG_MX53_ARM2
-static int __read_adc_channel(unsigned int chan)
-{
-	unsigned char buf[4] = { 0 };
-
-	buf[0] = (0xb0 | ((chan & 0x1) << 3) | ((chan >> 1) & 0x7));
-
-	/* LTC2495 need 410ms delay */
-	udelay(410000);
-
-	if (i2c_write(0x14, chan, 0, &buf[0], 1)) {
-		printf("%s:i2c_write:error\n", __func__);
-		return -1;
-	}
-
-	/* LTC2495 need 410ms delay*/
-	udelay(410000);
-
-	if (i2c_read(0x14, chan, 0, &buf[0], 3)) {
-		printf("%s:i2c_read:error\n", __func__);
-		return -1;
-	}
-
-	return buf[0] << 16 | buf[1] << 8 | buf[2];
-}
-
-static int __lookup_board_id(int adc_val)
-{
-	int id;
-
-	if (adc_val < 0x3FFFC0)
-		id = 0;
-	else if (adc_val < 0x461863)
-		id = 1;
-	else if (adc_val < 0x4C30C4)
-		id = 2;
-	else if (adc_val < 0x524926)
-		id = 3;
-	else if (adc_val < 0x586187)
-		id = 4;
-	else if (adc_val < 0x5E79E9)
-		id = 5;
-	else if (adc_val < 0x64924A)
-		id = 6;
-	else if (adc_val < 0x6AAAAC)
-		id = 7;
-	else if (adc_val < 0x70C30D)
-		id = 8;
-	else if (adc_val < 0x76DB6F)
-		id = 9;
-	else if (adc_val < 0x7CF3D0)
-		id = 10;
-	else if (adc_val < 0x830C32)
-		id = 11;
-	else if (adc_val < 0x892493)
-		id = 12;
-	else if (adc_val < 0x8F3CF5)
-		id = 13;
-	else if (adc_val < 0x955556)
-		id = 14;
-	else if (adc_val < 0x9B6DB8)
-		id = 15;
-	else if (adc_val < 0xA18619)
-		id = 16;
-	else if (adc_val < 0xA79E7B)
-		id = 17;
-	else if (adc_val < 0xADB6DC)
-		id = 18;
-	else if (adc_val < 0xB3CF3E)
-		id = 19;
-	else if (adc_val < 0xB9E79F)
-		id = 20;
-	else if (adc_val <= 0xC00000)
-		id = 21;
-		else
-		return -1;
-
-	return id;
-}
-
-static int __print_board_info(int id0, int id1)
-{
-	int ret = 0;
-
-	switch (id0) {
-	case 21:
-		switch (id1) {
-		case 15:
-			printf("MX53-EVK with DDR2 1GByte RevB\n");
-
-			break;
-		case 18:
-			printf("MX53-EVK with DDR2 2GByte RevA1\n");
-
-			break;
-		case 19:
-			printf("MX53-EVK with DDR2 2GByte RevA2\n");
-			break;
-		default:
-			printf("Unkown board id1:%d\n", id1);
-			ret = -1;
-
-			break;
-		}
-
-		break;
-	case 11:
-		switch (id1) {
-		case 1:
-			printf("MX53 1.5V DDR3 x8 CPU Card, Rev. A\n");
-
-			break;
-		case 11:
-			printf("MX53 1.8V DDR2 x8 CPU Card, Rev. A\n");
-
-			break;
-		default:
-			printf("Unkown board id1:%d\n", id1);
-			ret = -1;
-
-			break;
-		}
-
-		break;
-	default:
-		printf("Unkown board id0:%d\n", id0);
-
-		break;
-	}
-
-	return ret;
-}
-
-static int _identify_board_fix_up(int id0, int id1)
-{
-	int ret = 0;
-
-#ifdef CONFIG_CMD_CLOCK
-	/* For EVK RevB, set DDR to 400MHz */
-	if (id0 == 21 && id1 == 15) {
-		ret = clk_config(CONFIG_REF_CLK_FREQ, 400, PERIPH_CLK);
-		if (ret < 0)
-			return ret;
-
-		ret = clk_config(CONFIG_REF_CLK_FREQ, 400, DDR_CLK);
-		if (ret < 0)
-			return ret;
-
-		/* set up rev #2 for EVK RevB board */
-		setup_board_rev(2);
-	}
-#endif
-	return ret;
-}
-
-int identify_board_id(void)
-{
-	int ret = 0;
-	int bd_id0, bd_id1;
-
-#define CPU_CHANNEL_ID0 0xc
-#define CPU_CHANNEL_ID1 0xd
-
-	ret = bd_id0 = __read_adc_channel(CPU_CHANNEL_ID0);
-	if (ret < 0)
-		return ret;
-
-	ret = bd_id1 = __read_adc_channel(CPU_CHANNEL_ID1);
-	if (ret < 0)
-		return ret;
-
-	ret = bd_id0 = __lookup_board_id(bd_id0);
-	if (ret < 0)
-		return ret;
-
-	ret = bd_id1 = __lookup_board_id(bd_id1);
-	if (ret < 0)
-		return ret;
-
-	ret = __print_board_info(bd_id0, bd_id1);
-	if (ret < 0)
-		return ret;
-
-	ret = _identify_board_fix_up(bd_id0, bd_id1);
-
-	return ret;
-
-}
-#endif
-#endif
-
-#ifdef CONFIG_IMX_ECSPI
-s32 spi_get_cfg(struct imx_spi_dev_t *dev)
-{
-	switch (dev->slave.cs) {
-	case 0:
-		/* pmic */
-		dev->base = CSPI1_BASE_ADDR;
-		dev->freq = 2500000;
-		dev->ss_pol = IMX_SPI_ACTIVE_HIGH;
-		dev->ss = 0;
-		dev->fifo_sz = 64 * 4;
-		dev->us_delay = 0;
-		break;
-	case 1:
-		/* spi_nor */
-		dev->base = CSPI1_BASE_ADDR;
-		dev->freq = 2500000;
-		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
-		dev->ss = 1;
-		dev->fifo_sz = 64 * 4;
-		dev->us_delay = 0;
-		break;
-	default:
-		printf("Invalid Bus ID! \n");
-		break;
-	}
-
-	return 0;
-}
-
-void spi_io_init(struct imx_spi_dev_t *dev)
-{
-	switch (dev->base) {
-	case CSPI1_BASE_ADDR:
-		/* Select mux mode: ALT4 mux port: MOSI of instance: ecspi1 */
-		mxc_request_iomux(MX53_PIN_EIM_D18, IOMUX_CONFIG_ALT4);
-		mxc_iomux_set_pad(MX53_PIN_EIM_D18, 0x104);
-		mxc_iomux_set_input(
-				MUX_IN_ECSPI1_IPP_IND_MOSI_SELECT_INPUT, 0x3);
-
-		/* Select mux mode: ALT4 mux port: MISO of instance: ecspi1. */
-		mxc_request_iomux(MX53_PIN_EIM_D17, IOMUX_CONFIG_ALT4);
-		mxc_iomux_set_pad(MX53_PIN_EIM_D17, 0x104);
-		mxc_iomux_set_input(
-				MUX_IN_ECSPI1_IPP_IND_MISO_SELECT_INPUT, 0x3);
-
-		if (dev->ss == 0) {
-			/* de-select SS1 of instance: ecspi1. */
-			mxc_request_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT1);
-			mxc_iomux_set_pad(MX53_PIN_EIM_D19, 0x1E4);
-
-			/* mux mode: ALT4 mux port: SS0 of instance: ecspi1. */
-			mxc_request_iomux(MX53_PIN_EIM_EB2, IOMUX_CONFIG_ALT4);
-			mxc_iomux_set_pad(MX53_PIN_EIM_EB2, 0x104);
-			mxc_iomux_set_input(
-				MUX_IN_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT, 0x3);
-		} else if (dev->ss == 1) {
-			/* de-select SS0 of instance: ecspi1. */
-			mxc_request_iomux(MX53_PIN_EIM_EB2, IOMUX_CONFIG_ALT1);
-			mxc_iomux_set_pad(MX53_PIN_EIM_EB2, 0x1E4);
-
-			/* mux mode: ALT0 mux port: SS1 of instance: ecspi1. */
-			mxc_request_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT4);
-			mxc_iomux_set_pad(MX53_PIN_EIM_D19, 0x104);
-			mxc_iomux_set_input(
-				MUX_IN_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT, 0x2);
-		}
-
-		/* Select mux mode: ALT0 mux port: SCLK of instance: ecspi1. */
-		mxc_request_iomux(MX53_PIN_EIM_D16, IOMUX_CONFIG_ALT4);
-		mxc_iomux_set_pad(MX53_PIN_EIM_D16, 0x104);
-		mxc_iomux_set_input(
-			MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT, 0x3);
-
-		break;
-	case CSPI2_BASE_ADDR:
-	default:
-
-		break;
-	}
-}
-#endif
-
-#ifdef CONFIG_MXC_FEC
-
-#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
-
-int fec_get_mac_addr(unsigned char *mac)
-{
-	u32 *iim1_mac_base =
-		(u32 *)(IIM_BASE_ADDR + IIM_BANK_AREA_1_OFFSET +
-			CONFIG_IIM_MAC_ADDR_OFFSET);
-	int i;
-
-	for (i = 0; i < 6; ++i, ++iim1_mac_base)
-		mac[i] = (u8)readl(iim1_mac_base);
-
-	return 0;
-}
-#endif
-
-static void setup_fec(void)
-{
-	volatile unsigned int reg;
-
-	/*FEC_MDIO*/
-	mxc_request_iomux(MX53_PIN_FEC_MDIO, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_MDIO, 0x1FC);
-	mxc_iomux_set_input(MUX_IN_FEC_FEC_MDI_SELECT_INPUT, 0x1);
-
-	/*FEC_MDC*/
-	mxc_request_iomux(MX53_PIN_FEC_MDC, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_MDC, 0x004);
-
-	/* FEC RXD1 */
-	mxc_request_iomux(MX53_PIN_FEC_RXD1, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_RXD1, 0x180);
-
-	/* FEC RXD0 */
-	mxc_request_iomux(MX53_PIN_FEC_RXD0, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_RXD0, 0x180);
-
-	 /* FEC TXD1 */
-	mxc_request_iomux(MX53_PIN_FEC_TXD1, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_TXD1, 0x004);
-
-	/* FEC TXD0 */
-	mxc_request_iomux(MX53_PIN_FEC_TXD0, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_TXD0, 0x004);
-
-	/* FEC TX_EN */
-	mxc_request_iomux(MX53_PIN_FEC_TX_EN, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_TX_EN, 0x004);
-
-	/* FEC TX_CLK */
-	mxc_request_iomux(MX53_PIN_FEC_REF_CLK, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_REF_CLK, 0x180);
-
-	/* FEC RX_ER */
-	mxc_request_iomux(MX53_PIN_FEC_RX_ER, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_RX_ER, 0x180);
-
-	/* FEC CRS */
-	mxc_request_iomux(MX53_PIN_FEC_CRS_DV, IOMUX_CONFIG_ALT0);
-	mxc_iomux_set_pad(MX53_PIN_FEC_CRS_DV, 0x180);
-
-	/* phy reset: gpio7-6 */
-	mxc_request_iomux(MX53_PIN_ATA_DA_0, IOMUX_CONFIG_ALT1);
-
-	reg = readl(GPIO7_BASE_ADDR + 0x0);
-	reg &= ~0x40;
-	writel(reg, GPIO7_BASE_ADDR + 0x0);
-
-	reg = readl(GPIO7_BASE_ADDR + 0x4);
-	reg |= 0x40;
-	writel(reg, GPIO7_BASE_ADDR + 0x4);
-
-	udelay(500);
-
-	reg = readl(GPIO7_BASE_ADDR + 0x0);
-	reg |= 0x40;
-	writel(reg, GPIO7_BASE_ADDR + 0x0);
-
-}
-#endif
-
-#if defined(CONFIG_MXC_KPD)
-int setup_mxc_kpd(void)
-{
-	mxc_request_iomux(MX53_PIN_KEY_COL0, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_COL1, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_COL2, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_COL3, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_COL4, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_GPIO_19,  IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
-	mxc_request_iomux(MX53_PIN_KEY_ROW4, IOMUX_CONFIG_ALT0);
-
-	return 0;
-}
-#endif
-
-
-#ifdef CONFIG_CMD_MMC
-
-struct fsl_esdhc_cfg esdhc_cfg[2] = {
-	{MMC_SDHC1_BASE_ADDR, 1, 1},
-	{MMC_SDHC3_BASE_ADDR, 1, 1},
-};
-
-#ifdef CONFIG_DYNAMIC_MMC_DEVNO
-int get_mmc_env_devno()
-{
-	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
-	return (soc_sbmr & 0x00300000)  ? 1 : 0;
-}
-#endif
-
-
-int esdhc_gpio_init(bd_t *bis)
-{
-	s32 status = 0;
-	u32 index = 0;
-
-	for (index = 0; index < CONFIG_SYS_FSL_ESDHC_NUM;
-		++index) {
-		switch (index) {
-		case 0:
-			mxc_request_iomux(MX53_PIN_SD1_CMD, IOMUX_CONFIG_ALT0);
-			mxc_request_iomux(MX53_PIN_SD1_CLK, IOMUX_CONFIG_ALT0);
-			mxc_request_iomux(MX53_PIN_SD1_DATA0,
-						IOMUX_CONFIG_ALT0);
-			mxc_request_iomux(MX53_PIN_SD1_DATA1,
-						IOMUX_CONFIG_ALT0);
-			mxc_request_iomux(MX53_PIN_SD1_DATA2,
-						IOMUX_CONFIG_ALT0);
-			mxc_request_iomux(MX53_PIN_SD1_DATA3,
-						IOMUX_CONFIG_ALT0);
-
-			mxc_iomux_set_pad(MX53_PIN_SD1_CMD, 0x1E4);
-			mxc_iomux_set_pad(MX53_PIN_SD1_CLK, 0xD4);
-			mxc_iomux_set_pad(MX53_PIN_SD1_DATA0, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_SD1_DATA1, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_SD1_DATA2, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_SD1_DATA3, 0x1D4);
-			break;
-		case 1:
-			mxc_request_iomux(MX53_PIN_ATA_RESET_B,
-						IOMUX_CONFIG_ALT2);
-			mxc_request_iomux(MX53_PIN_ATA_IORDY,
-						IOMUX_CONFIG_ALT2);
-			mxc_request_iomux(MX53_PIN_ATA_DATA8,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA9,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA10,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA11,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA0,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA1,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA2,
-						IOMUX_CONFIG_ALT4);
-			mxc_request_iomux(MX53_PIN_ATA_DATA3,
-						IOMUX_CONFIG_ALT4);
-
-			mxc_iomux_set_pad(MX53_PIN_ATA_RESET_B, 0x1E4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_IORDY, 0xD4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA8, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA9, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA10, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA11, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA0, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA1, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA2, 0x1D4);
-			mxc_iomux_set_pad(MX53_PIN_ATA_DATA3, 0x1D4);
-
-			break;
-		default:
-			printf("Warning: you configured more ESDHC controller"
-				"(%d) as supported by the board(2)\n",
-				CONFIG_SYS_FSL_ESDHC_NUM);
-			return status;
-			break;
-		}
-		status |= fsl_esdhc_initialize(bis, &esdhc_cfg[index]);
-	}
-
-	return status;
-}
-
-int board_mmc_init(bd_t *bis)
-{
-	if (!esdhc_gpio_init(bis))
-		return 0;
-	else
-		return -1;
-}
-
-#endif
-
-int board_init(void)
-{
-#ifdef CONFIG_MFG
-/* MFG firmware need reset usb to avoid host crash firstly */
-#define USBCMD 0x140
-	int val = readl(OTG_BASE_ADDR + USBCMD);
-	val &= ~0x1; /*RS bit*/
-	writel(val, OTG_BASE_ADDR + USBCMD);
-#endif
-	setup_boot_device();
-	setup_soc_rev();
-#if defined(CONFIG_MX53_ARM2) || defined(CONFIG_MX53_ARM2_DDR3)
-	setup_board_rev(1);
-#endif
-	gd->bd->bi_arch_number = MACH_TYPE_MX53_EVK;	/* board id for linux */
-	/* address of boot parameters */
-	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
-
-	setup_uart();
-	setup_fec();
-
-#ifdef CONFIG_I2C_MXC
-	setup_i2c(CONFIG_SYS_I2C_PORT);
-	setup_core_voltages();
-#endif
-
-	return 0;
-}
-
-
-#ifdef CONFIG_ANDROID_RECOVERY
-struct reco_envs supported_reco_envs[BOOT_DEV_NUM] = {
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-	{
-	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
-	 .args = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
-	 },
-	{
-	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
-	 .args = CONFIG_ANDROID_RECOVERY_BOOTARGS_MMC,
-	 },
-	{
-	 .cmd = NULL,
-	 .args = NULL,
-	 },
-};
-
-int check_recovery_cmd_file(void)
-{
-	disk_partition_t info;
-	ulong part_length;
-	int filelen;
-	char *env;
-
-	/* For test only */
-	/* When detecting android_recovery_switch,
-	 * enter recovery mode directly */
-	env = getenv("android_recovery_switch");
-	if (!strcmp(env, "1")) {
-		printf("Env recovery detected!\nEnter recovery mode!\n");
-		return 1;
-	}
-
-	printf("Checking for recovery command file...\n");
-	switch (get_boot_device()) {
-	case MMC_BOOT:
-	case SD_BOOT:
-		{
-			block_dev_desc_t *dev_desc = NULL;
-			struct mmc *mmc = find_mmc_device(0);
-
-			dev_desc = get_dev("mmc", 0);
-
-			if (NULL == dev_desc) {
-				puts("** Block device MMC 0 not supported\n");
-				return 0;
-			}
-
-			mmc_init(mmc);
-
-			if (get_partition_info(dev_desc,
-					CONFIG_ANDROID_CACHE_PARTITION_MMC,
-					&info)) {
-				printf("** Bad partition %d **\n",
-					CONFIG_ANDROID_CACHE_PARTITION_MMC);
-				return 0;
-			}
-
-			part_length = ext2fs_set_blk_dev(dev_desc,
-						CONFIG_ANDROID_CACHE_PARTITION_MMC);
-			if (part_length == 0) {
-				printf("** Bad partition - mmc 0:%d **\n",
-					CONFIG_ANDROID_CACHE_PARTITION_MMC);
-				ext2fs_close();
-				return 0;
-			}
-
-			if (!ext2fs_mount(part_length)) {
-				printf("** Bad ext2 partition or "
-					"disk - mmc 0:%d **\n",
-					CONFIG_ANDROID_CACHE_PARTITION_MMC);
-				ext2fs_close();
-				return 0;
-			}
-
-			filelen = ext2fs_open(CONFIG_ANDROID_RECOVERY_CMD_FILE);
-
-			ext2fs_close();
-		}
-		break;
-	case NAND_BOOT:
-		return 0;
-		break;
-	case SPI_NOR_BOOT:
-		return 0;
-		break;
-	case UNKNOWN_BOOT:
-	default:
-		return 0;
-		break;
-	}
-
-	return (filelen > 0) ? 1 : 0;
-
-}
-#endif
-
-int board_late_init(void)
-{
-	return 0;
-}
-
-int checkboard(void)
-{
-	printf("Board: ");
-
-#ifdef CONFIG_MX53_ARM2
-	printf("Board: MX53 ARMADILLO2 ");
-	printf("1.0 [");
-#else
-#ifdef CONFIG_I2C_MXC
-	identify_board_id();
-
-	printf("Boot Reason: [");
-#endif
-#endif
-
-	switch (__REG(SRC_BASE_ADDR + 0x8)) {
-	case 0x0001:
-		printf("POR");
-		break;
-	case 0x0009:
-		printf("RST");
-		break;
-	case 0x0010:
-	case 0x0011:
-		printf("WDOG");
-		break;
-	default:
-		printf("unknown");
-	}
-	printf("]\n");
-
-	printf("Boot Device: ");
-	switch (get_boot_device()) {
-	case WEIM_NOR_BOOT:
-		printf("NOR\n");
-		break;
-	case ONE_NAND_BOOT:
-		printf("ONE NAND\n");
-		break;
-	case PATA_BOOT:
-		printf("PATA\n");
-		break;
-	case SATA_BOOT:
-		printf("SATA\n");
-		break;
-	case I2C_BOOT:
-		printf("I2C\n");
-		break;
-	case SPI_NOR_BOOT:
-		printf("SPI NOR\n");
-		break;
-	case SD_BOOT:
-		printf("SD\n");
-		break;
-	case MMC_BOOT:
-		printf("MMC\n");
-		break;
-	case NAND_BOOT:
-		printf("NAND\n");
-		break;
-	case UNKNOWN_BOOT:
-	default:
-		printf("UNKNOWN\n");
-		break;
-	}
-	return 0;
-}
diff --git a/board/freescale/mx53_evk/u-boot.lds b/board/freescale/mx53_evk/u-boot.lds
deleted file mode 100644
index fe5f4eb..0000000
--- a/board/freescale/mx53_evk/u-boot.lds
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * January 2004 - Changed to support H4 device
- * Copyright (c) 2004 Texas Instruments
- *
- * (C) Copyright 2002
- * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
- *
- * (C) Copyright 2010 Freescale Semiconductor, Inc.
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
-OUTPUT_ARCH(arm)
-ENTRY(_start)
-SECTIONS
-{
-	. = 0x00000000;
-
-	. = ALIGN(4);
-	.text	   :
-	{
-	  /* WARNING - the following is hand-optimized to fit within	*/
-	  /* the sector layout of our flash chips!	XXX FIXME XXX	*/
-	  board/freescale/mx53_evk/flash_header.o	(.text.flasheader)
-	  cpu/arm_cortexa8/start.o
-	  board/freescale/mx53_evk/libmx53_evk.a	(.text)
-	  lib_arm/libarm.a		(.text)
-	  net/libnet.a			(.text)
-	  drivers/mtd/libmtd.a		(.text)
-	  drivers/mmc/libmmc.a		(.text)
-
-	  . = DEFINED(env_offset) ? env_offset : .;
-	  common/env_embedded.o(.text)
-
-	  *(.text)
-	}
-
-	. = ALIGN(4);
-	.rodata : { *(.rodata) }
-
-	. = ALIGN(4);
-	.data : { *(.data) }
-
-	. = ALIGN(4);
-	.got : { *(.got) }
-
-	. = .;
-	__u_boot_cmd_start = .;
-	.u_boot_cmd : { *(.u_boot_cmd) }
-	__u_boot_cmd_end = .;
-
-	. = ALIGN(4);
-	__bss_start = .;
-	.bss : { *(.bss) }
-	_end = .;
-}
diff --git a/board/freescale/mx53_rd/Makefile b/board/freescale/mx53_rd/Makefile
new file mode 100644
index 0000000..52d53bf
--- /dev/null
+++ b/board/freescale/mx53_rd/Makefile
@@ -0,0 +1,49 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2010 Freescale Semiconductor, Inc.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= mx53_rd.o
+SOBJS	:= lowlevel_init.o flash_header.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/freescale/mx53_rd/config.mk b/board/freescale/mx53_rd/config.mk
new file mode 100644
index 0000000..34f830a
--- /dev/null
+++ b/board/freescale/mx53_rd/config.mk
@@ -0,0 +1,3 @@
+LDSCRIPT := $(SRCTREE)/board/$(VENDOR)/$(BOARD)/u-boot.lds
+
+TEXT_BASE = 0x77800000
diff --git a/board/freescale/mx53_rd/flash_header.S b/board/freescale/mx53_rd/flash_header.S
new file mode 100644
index 0000000..014333d
--- /dev/null
+++ b/board/freescale/mx53_rd/flash_header.S
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx53.h>
+
+#ifdef	CONFIG_FLASH_HEADER
+#ifndef CONFIG_FLASH_HEADER_OFFSET
+# error "Must define the offset of flash header"
+#endif
+
+#define CPU_2_BE_32(l) \
+       ((((l) & 0x000000FF) << 24) | \
+	(((l) & 0x0000FF00) << 8)  | \
+	(((l) & 0x00FF0000) >> 8)  | \
+	(((l) & 0xFF000000) >> 24))
+
+#define MXC_DCD_ITEM(i, addr, val)   \
+dcd_node_##i:                        \
+        .word CPU_2_BE_32(addr) ;     \
+        .word CPU_2_BE_32(val)  ;     \
+
+.section ".text.flasheader", "x"
+	b	_start
+	.org	CONFIG_FLASH_HEADER_OFFSET
+ivt_header:       .word 0x402000D1 /* Tag=0xD1, Len=0x0020, Ver=0x40 */
+app_code_jump_v:  .word _start
+reserv1:          .word 0x0
+dcd_ptr:          .word dcd_hdr
+boot_data_ptr:	  .word boot_data
+self_ptr:         .word ivt_header
+app_code_csf:     .word 0x0
+reserv2:          .word 0x0
+
+boot_data:        .word 0x77800000
+image_len:        .word _end - TEXT_BASE
+plugin:           .word 0x0
+
+#if defined(CONFIG_MX53_EVK)
+dcd_hdr:          .word 0x400802D2 /* Tag=0xD2, Len=64*8 + 4 + 4, Ver=0x40 */
+write_dcd_cmd:    .word 0x040402CC /* Tag=0xCC, Len=64*8 + 4, Param=4 */
+
+/* DCD */
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00380000)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00380040)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00380000)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00380040)
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00380040)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00200000)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00380000)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00200000)
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00380040)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00380040)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00380000)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00380000)
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00380040)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00380000)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00380000)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000200)
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00380000)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00380000)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00380000)
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x06000000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00380000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00380000)
+MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x2b2f3031)
+MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40363333)
+MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x098, 0x00000f00)
+MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x0f8, 0x00000800)
+MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x07c, 0x01310132)
+MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x080, 0x0133014b)
+MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x018, 0x000016d0)
+MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x000, 0xc4110000)
+MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x00c, 0x4d5122d2)
+MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x010, 0x92d18a22)
+MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x014, 0x00c70092)
+MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
+MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x030, 0x009f000e)
+MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
+MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
+MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
+MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
+MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x00008031)
+MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x0b5280b0)
+MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
+MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
+MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
+MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x01c, 0x0a528030)
+MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x01c, 0x03c68031)
+MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x01c, 0x00468031)
+MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
+MXC_DCD_ITEM(52, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
+MXC_DCD_ITEM(53, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
+MXC_DCD_ITEM(54, ESDCTL_BASE_ADDR + 0x01c, 0x00008039)
+MXC_DCD_ITEM(55, ESDCTL_BASE_ADDR + 0x01c, 0x0b528138)
+MXC_DCD_ITEM(56, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
+MXC_DCD_ITEM(57, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
+MXC_DCD_ITEM(58, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
+MXC_DCD_ITEM(59, ESDCTL_BASE_ADDR + 0x01c, 0x0a528038)
+MXC_DCD_ITEM(60, ESDCTL_BASE_ADDR + 0x01c, 0x03c68039)
+MXC_DCD_ITEM(61, ESDCTL_BASE_ADDR + 0x01c, 0x00468039)
+MXC_DCD_ITEM(62, ESDCTL_BASE_ADDR + 0x020, 0x00005800)
+MXC_DCD_ITEM(63, ESDCTL_BASE_ADDR + 0x058, 0x00033337)
+MXC_DCD_ITEM(64, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
+
+#elif defined(CONFIG_MX53_ARM2) /*ARM2 board*/
+dcd_hdr:          .word 0x400002D2 /* Tag=0xD2, Len=63*8 + 4 + 4, Ver=0x40 */
+write_dcd_cmd:    .word 0x04FC01CC /* Tag=0xCC, Len=63*8 + 4, Param=4 */
+
+/* DCD */
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00380000)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00380040)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00380000)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00380040)
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00380040)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00380000)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00380000)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00380000)
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00380040)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00380040)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00380000)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00380000)
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00380040)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00380000)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00380000)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000200)
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00380000)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00380000)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00380000)
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x02000000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00380000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00380000)
+MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x2d313331)
+MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40363333)
+MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x0f8, 0x00000800)
+MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x07c, 0x020c0211)
+MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x080, 0x014c0155)
+MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x018, 0x00001710)
+MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x000, 0xc4110000)
+MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x00c, 0x4d5122d2)
+MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x010, 0x92d18a22)
+MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x014, 0x00c70092)
+MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
+MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x030, 0x009f000e)
+MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
+MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
+MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
+MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
+MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x00008031)
+MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x0b5280b0)
+MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x04008010)
+MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
+MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x00008020)
+MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x0a528030)
+MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x01c, 0x03c68031)
+MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x01c, 0x00468031)
+MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
+MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
+MXC_DCD_ITEM(52, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
+MXC_DCD_ITEM(53, ESDCTL_BASE_ADDR + 0x01c, 0x00008039)
+MXC_DCD_ITEM(54, ESDCTL_BASE_ADDR + 0x01c, 0x0b528138)
+MXC_DCD_ITEM(55, ESDCTL_BASE_ADDR + 0x01c, 0x04008018)
+MXC_DCD_ITEM(56, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
+MXC_DCD_ITEM(57, ESDCTL_BASE_ADDR + 0x01c, 0x00008028)
+MXC_DCD_ITEM(58, ESDCTL_BASE_ADDR + 0x01c, 0x0a528038)
+MXC_DCD_ITEM(59, ESDCTL_BASE_ADDR + 0x01c, 0x03c68039)
+MXC_DCD_ITEM(60, ESDCTL_BASE_ADDR + 0x01c, 0x00468039)
+MXC_DCD_ITEM(61, ESDCTL_BASE_ADDR + 0x020, 0x00005800)
+MXC_DCD_ITEM(62, ESDCTL_BASE_ADDR + 0x058, 0x00033337)
+MXC_DCD_ITEM(63, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
+#elif defined(CONFIG_MX53_ARM2_DDR3)
+dcd_hdr:          .word 0x40A001D2 /* Tag=0xD2, Len=51*8 + 4 + 4, Ver=0x40 */
+write_dcd_cmd:    .word 0x049C01CC /* Tag=0xCC, Len=51*8 + 4, Param=4 */
+
+/* DCD */
+MXC_DCD_ITEM(1, IOMUXC_BASE_ADDR + 0x554, 0x00300000)
+MXC_DCD_ITEM(2, IOMUXC_BASE_ADDR + 0x558, 0x00300040)
+MXC_DCD_ITEM(3, IOMUXC_BASE_ADDR + 0x560, 0x00300000)
+MXC_DCD_ITEM(4, IOMUXC_BASE_ADDR + 0x564, 0x00300040)
+MXC_DCD_ITEM(5, IOMUXC_BASE_ADDR + 0x568, 0x00300040)
+MXC_DCD_ITEM(6, IOMUXC_BASE_ADDR + 0x570, 0x00300000)
+MXC_DCD_ITEM(7, IOMUXC_BASE_ADDR + 0x574, 0x00300000)
+MXC_DCD_ITEM(8, IOMUXC_BASE_ADDR + 0x578, 0x00300000)
+MXC_DCD_ITEM(9, IOMUXC_BASE_ADDR + 0x57c, 0x00300040)
+MXC_DCD_ITEM(10, IOMUXC_BASE_ADDR + 0x580, 0x00300040)
+MXC_DCD_ITEM(11, IOMUXC_BASE_ADDR + 0x584, 0x00300000)
+MXC_DCD_ITEM(12, IOMUXC_BASE_ADDR + 0x588, 0x00300000)
+MXC_DCD_ITEM(13, IOMUXC_BASE_ADDR + 0x590, 0x00300040)
+MXC_DCD_ITEM(14, IOMUXC_BASE_ADDR + 0x594, 0x00300000)
+MXC_DCD_ITEM(15, IOMUXC_BASE_ADDR + 0x6f0, 0x00300000)
+MXC_DCD_ITEM(16, IOMUXC_BASE_ADDR + 0x6f4, 0x00000000)
+MXC_DCD_ITEM(17, IOMUXC_BASE_ADDR + 0x6fc, 0x00000000)
+MXC_DCD_ITEM(18, IOMUXC_BASE_ADDR + 0x714, 0x00000000)
+MXC_DCD_ITEM(19, IOMUXC_BASE_ADDR + 0x718, 0x00300000)
+MXC_DCD_ITEM(20, IOMUXC_BASE_ADDR + 0x71c, 0x00300000)
+MXC_DCD_ITEM(21, IOMUXC_BASE_ADDR + 0x720, 0x00300000)
+MXC_DCD_ITEM(22, IOMUXC_BASE_ADDR + 0x724, 0x04000000)
+MXC_DCD_ITEM(23, IOMUXC_BASE_ADDR + 0x728, 0x00300000)
+MXC_DCD_ITEM(24, IOMUXC_BASE_ADDR + 0x72c, 0x00300000)
+MXC_DCD_ITEM(25, ESDCTL_BASE_ADDR + 0x088, 0x32383535)
+MXC_DCD_ITEM(26, ESDCTL_BASE_ADDR + 0x090, 0x40383538)
+MXC_DCD_ITEM(27, ESDCTL_BASE_ADDR + 0x07c, 0x0136014d)
+MXC_DCD_ITEM(28, ESDCTL_BASE_ADDR + 0x080, 0x01510141)
+MXC_DCD_ITEM(29, ESDCTL_BASE_ADDR + 0x018, 0x00091740)
+MXC_DCD_ITEM(30, ESDCTL_BASE_ADDR + 0x000, 0xc4190000)
+MXC_DCD_ITEM(31, ESDCTL_BASE_ADDR + 0x00c, 0x565a7543)
+MXC_DCD_ITEM(32, ESDCTL_BASE_ADDR + 0x010, 0xb6ae8aa3)
+MXC_DCD_ITEM(33, ESDCTL_BASE_ADDR + 0x014, 0x01ff00db)
+MXC_DCD_ITEM(34, ESDCTL_BASE_ADDR + 0x02c, 0x000026d2)
+MXC_DCD_ITEM(35, ESDCTL_BASE_ADDR + 0x030, 0x009f0e21)
+MXC_DCD_ITEM(36, ESDCTL_BASE_ADDR + 0x008, 0x12272000)
+MXC_DCD_ITEM(37, ESDCTL_BASE_ADDR + 0x004, 0x00030012)
+MXC_DCD_ITEM(38, ESDCTL_BASE_ADDR + 0x01c, 0x00008032)
+MXC_DCD_ITEM(39, ESDCTL_BASE_ADDR + 0x01c, 0x00008033)
+MXC_DCD_ITEM(40, ESDCTL_BASE_ADDR + 0x01c, 0x00028031)
+MXC_DCD_ITEM(41, ESDCTL_BASE_ADDR + 0x01c, 0x092080b0)
+MXC_DCD_ITEM(42, ESDCTL_BASE_ADDR + 0x01c, 0x04008040)
+MXC_DCD_ITEM(43, ESDCTL_BASE_ADDR + 0x01c, 0x0000803a)
+MXC_DCD_ITEM(44, ESDCTL_BASE_ADDR + 0x01c, 0x0000803b)
+MXC_DCD_ITEM(45, ESDCTL_BASE_ADDR + 0x01c, 0x00028039)
+MXC_DCD_ITEM(46, ESDCTL_BASE_ADDR + 0x01c, 0x09208138)
+MXC_DCD_ITEM(47, ESDCTL_BASE_ADDR + 0x01c, 0x04008048)
+MXC_DCD_ITEM(48, ESDCTL_BASE_ADDR + 0x020, 0x00001800)
+MXC_DCD_ITEM(49, ESDCTL_BASE_ADDR + 0x040, 0x04b80003)
+MXC_DCD_ITEM(50, ESDCTL_BASE_ADDR + 0x058, 0x00022227)
+MXC_DCD_ITEM(51, ESDCTL_BASE_ADDR + 0x01c, 0x00000000)
+#endif
+#endif
diff --git a/board/freescale/mx53_rd/lowlevel_init.S b/board/freescale/mx53_rd/lowlevel_init.S
new file mode 100644
index 0000000..d5e9f66
--- /dev/null
+++ b/board/freescale/mx53_rd/lowlevel_init.S
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <asm/arch/mx53.h>
+
+/*
+ * L2CC Cache setup/invalidation/disable
+ */
+.macro init_l2cc
+	/* explicitly disable L2 cache */
+        mrc 15, 0, r0, c1, c0, 1
+        bic r0, r0, #0x2
+        mcr 15, 0, r0, c1, c0, 1
+
+        /* reconfigure L2 cache aux control reg */
+        mov r0, #0xC0                   /* tag RAM */
+        add r0, r0, #0x4                /* data RAM */
+        orr r0, r0, #(1 << 24)          /* disable write allocate delay */
+        orr r0, r0, #(1 << 23)          /* disable write allocate combine */
+        orr r0, r0, #(1 << 22)          /* disable write allocate */
+
+	mcr 15, 1, r0, c9, c0, 2
+.endm /* init_l2cc */
+
+/* AIPS setup - Only setup MPROTx registers.
+ * The PACR default values are good.*/
+.macro init_aips
+	/*
+	 * Set all MPROTx to be non-bufferable, trusted for R/W,
+	 * not forced to user-mode.
+	 */
+	ldr r0, =AIPS1_BASE_ADDR
+	ldr r1, =0x77777777
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+	ldr r0, =AIPS2_BASE_ADDR
+	str r1, [r0, #0x0]
+	str r1, [r0, #0x4]
+.endm /* init_aips */
+
+.macro setup_pll pll, freq
+	ldr r0, =\pll
+	ldr r1, =0x00001232
+	str r1, [r0, #PLL_DP_CTL]
+	mov r1, #0x2
+	str r1, [r0, #PLL_DP_CONFIG]
+
+	ldr r1, W_DP_OP_\freq
+	str r1, [r0, #PLL_DP_OP]
+	str r1, [r0, #PLL_DP_HFS_OP]
+
+	ldr r1,	W_DP_MFD_\freq
+	str r1, [r0, #PLL_DP_MFD]
+	str r1, [r0, #PLL_DP_HFS_MFD]
+
+	ldr r1,  W_DP_MFN_\freq
+	str r1, [r0, #PLL_DP_MFN]
+	str r1, [r0, #PLL_DP_HFS_MFN]
+
+	ldr r1, =0x00001232
+	str r1, [r0, #PLL_DP_CTL]
+1:	ldr r1, [r0, #PLL_DP_CTL]
+	ands r1, r1, #0x1
+	beq 1b
+.endm
+
+.macro init_clock
+	ldr r0, CCM_BASE_ADDR_W
+
+	/* Switch ARM to step clock */
+	mov r1, #0x4
+	str r1, [r0, #CLKCTL_CCSR]
+
+	setup_pll PLL1_BASE_ADDR, 800
+
+        setup_pll PLL3_BASE_ADDR, 400
+
+        /* Switch peripheral to PLL3 */
+        ldr r0, CCM_BASE_ADDR_W
+        ldr r1, CCM_VAL_0x00015154
+        str r1, [r0, #CLKCTL_CBCMR]
+        ldr r1, CCM_VAL_0x02888945
+        orr r1, r1, #(1 << 16)
+        str r1, [r0, #CLKCTL_CBCDR]
+        /* make sure change is effective */
+1:      ldr r1, [r0, #CLKCTL_CDHIPR]
+        cmp r1, #0x0
+        bne 1b
+
+        setup_pll PLL2_BASE_ADDR, CONFIG_SYS_PLL2_FREQ
+
+	/* Switch peripheral to PLL2 */
+	ldr r0, CCM_BASE_ADDR_W
+	ldr r1, CCM_VAL_0x00808145
+	orr r1, r1, #(CONFIG_SYS_AHB_PODF << 10)
+	orr r1, r1, #(CONFIG_SYS_AXIA_PODF << 16)
+	orr r1, r1, #(CONFIG_SYS_AXIB_PODF << 19)
+	str r1, [r0, #CLKCTL_CBCDR]
+
+	ldr r1, CCM_VAL_0x00016154
+	str r1, [r0, #CLKCTL_CBCMR]
+
+	/* make sure change is effective */
+1:      ldr r1, [r0, #CLKCTL_CDHIPR]
+	cmp r1, #0x0
+	bne 1b
+
+        setup_pll PLL3_BASE_ADDR, 216
+
+	/* Set the platform clock dividers */
+	ldr r0, PLATFORM_BASE_ADDR_W
+	ldr r1, PLATFORM_CLOCK_DIV_W
+	str r1, [r0, #PLATFORM_ICGC]
+
+	ldr r0, CCM_BASE_ADDR_W
+	mov r1, #1
+	str r1, [r0, #CLKCTL_CACRR]
+
+	/* Switch ARM back to PLL 1. */
+	mov r1, #0x0
+	str r1, [r0, #CLKCTL_CCSR]
+
+	ldr r1, [r0, #CLKCTL_CSCDR1]
+	orr r1, r1, #0x3f
+	eor r1, r1, #0x3f
+	orr r1, r1, #0x21
+	str r1, [r0, #CLKCTL_CSCDR1]
+
+	/* Restore the default values in the Gate registers */
+	ldr r1, =0xFFFFFFFF
+	str r1, [r0, #CLKCTL_CCGR0]
+	str r1, [r0, #CLKCTL_CCGR1]
+	str r1, [r0, #CLKCTL_CCGR2]
+	str r1, [r0, #CLKCTL_CCGR3]
+	str r1, [r0, #CLKCTL_CCGR4]
+	str r1, [r0, #CLKCTL_CCGR5]
+	str r1, [r0, #CLKCTL_CCGR6]
+	str r1, [r0, #CLKCTL_CCGR7]
+
+        mov r1, #0x00000
+        str r1, [r0, #CLKCTL_CCDR]
+
+        /* for cko - for ARM div by 8 */
+        mov r1, #0x000A0000
+        add r1, r1, #0x00000F0
+        str r1, [r0, #CLKCTL_CCOSR]
+.endm
+
+.section ".text.init", "x"
+
+.globl lowlevel_init
+lowlevel_init:
+
+#ifdef ENABLE_IMPRECISE_ABORT
+        mrs r1, spsr            /* save old spsr */
+        mrs r0, cpsr            /* read out the cpsr */
+	bic r0, r0, #0x100      /* clear the A bit */
+	msr spsr, r0            /* update spsr */
+	add lr, pc, #0x8        /* update lr */
+        movs pc, lr             /* update cpsr */
+        nop
+        nop
+        nop
+	nop
+	msr spsr, r1            /* restore old spsr */
+#endif
+
+	/* ARM errata ID #468414 */
+	mrc 15, 0, r1, c1, c0, 1
+	orr r1, r1, #(1 << 5)    /* enable L1NEON bit */
+	mcr 15, 0, r1, c1, c0, 1
+
+	init_l2cc
+
+	init_aips
+
+	init_clock
+
+	mov pc, lr
+
+/* Board level setting value */
+CCM_BASE_ADDR_W:        .word CCM_BASE_ADDR
+CCM_VAL_0x00016154:     .word 0x00016154
+CCM_VAL_0x00808145:     .word 0x00808145
+CCM_VAL_0x00015154:     .word 0x00015154
+CCM_VAL_0x02888945:     .word 0x02888945
+W_DP_OP_800:           	.word DP_OP_800
+W_DP_MFD_800:           .word DP_MFD_800
+W_DP_MFN_800:           .word DP_MFN_800
+W_DP_OP_600:            .word DP_OP_600
+W_DP_MFD_600:           .word DP_MFD_600
+W_DP_MFN_600:           .word DP_MFN_600
+W_DP_OP_400:            .word DP_OP_400
+W_DP_MFD_400:           .word DP_MFD_400
+W_DP_MFN_400:           .word DP_MFN_400
+W_DP_OP_216:            .word DP_OP_216
+W_DP_MFD_216:           .word DP_MFD_216
+W_DP_MFN_216:           .word DP_MFN_216
+PLATFORM_BASE_ADDR_W:   .word ARM_BASE_ADDR
+PLATFORM_CLOCK_DIV_W:   .word 0x00000124
diff --git a/board/freescale/mx53_rd/mx53_rd.c b/board/freescale/mx53_rd/mx53_rd.c
new file mode 100644
index 0000000..0f4f475
--- /dev/null
+++ b/board/freescale/mx53_rd/mx53_rd.c
@@ -0,0 +1,1001 @@
+/*
+ * Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+ *
+ * (C) Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/mx53.h>
+#include <asm/arch/mx53_pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/errno.h>
+#include <imx_spi.h>
+
+#if CONFIG_I2C_MXC
+#include <i2c.h>
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#endif
+
+#ifdef CONFIG_ARCH_MMU
+#include <asm/mmu.h>
+#include <asm/arch/mmu.h>
+#endif
+
+#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+#include <asm/imx_iim.h>
+#endif
+
+#ifdef CONFIG_CMD_CLOCK
+#include <asm/clock.h>
+#endif
+
+#ifdef CONFIG_ANDROID_RECOVERY
+#include "../common/recovery.h"
+#include <part.h>
+#include <ext2fs.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <ubi_uboot.h>
+#include <jffs2/load_kernel.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static u32 system_rev;
+static enum boot_device boot_dev;
+
+static inline void setup_boot_device(void)
+{
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	uint bt_mem_ctl = (soc_sbmr & 0x000000FF) >> 4 ;
+	uint bt_mem_type = (soc_sbmr & 0x00000008) >> 3;
+
+	switch (bt_mem_ctl) {
+	case 0x0:
+		if (bt_mem_type)
+			boot_dev = ONE_NAND_BOOT;
+		else
+			boot_dev = WEIM_NOR_BOOT;
+		break;
+	case 0x2:
+		if (bt_mem_type)
+			boot_dev = SATA_BOOT;
+		else
+			boot_dev = PATA_BOOT;
+		break;
+	case 0x3:
+		if (bt_mem_type)
+			boot_dev = SPI_NOR_BOOT;
+		else
+			boot_dev = I2C_BOOT;
+		break;
+	case 0x4:
+	case 0x5:
+		boot_dev = SD_BOOT;
+		break;
+	case 0x6:
+	case 0x7:
+		boot_dev = MMC_BOOT;
+		break;
+	case 0x8 ... 0xf:
+		boot_dev = NAND_BOOT;
+		break;
+	default:
+		boot_dev = UNKNOWN_BOOT;
+		break;
+	}
+}
+
+enum boot_device get_boot_device(void)
+{
+	return boot_dev;
+}
+
+u32 get_board_rev(void)
+{
+	return system_rev;
+}
+
+static inline void setup_soc_rev(void)
+{
+	system_rev = 0x53000 | CHIP_REV_1_0;
+}
+
+static inline void setup_board_rev(int rev)
+{
+	system_rev |= (rev & 0xF) << 8;
+}
+
+inline int is_soc_rev(int rev)
+{
+	return (system_rev & 0xFF) - rev;
+}
+
+#ifdef CONFIG_ARCH_MMU
+void board_mmu_init(void)
+{
+	unsigned long ttb_base = PHYS_SDRAM_1 + 0x4000;
+	unsigned long i;
+
+	/*
+	* Set the TTB register
+	*/
+	asm volatile ("mcr  p15,0,%0,c2,c0,0" : : "r"(ttb_base) /*:*/);
+
+	/*
+	* Set the Domain Access Control Register
+	*/
+	i = ARM_ACCESS_DACR_DEFAULT;
+	asm volatile ("mcr  p15,0,%0,c3,c0,0" : : "r"(i) /*:*/);
+
+	/*
+	* First clear all TT entries - ie Set them to Faulting
+	*/
+	memset((void *)ttb_base, 0, ARM_FIRST_LEVEL_PAGE_TABLE_SIZE);
+	/* Actual   Virtual  Size   Attributes          Function */
+	/* Base     Base     MB     cached? buffered?  access permissions */
+	/* xxx00000 xxx00000 */
+	X_ARM_MMU_SECTION(0x000, 0x000, 0x10,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* ROM, 16M */
+	X_ARM_MMU_SECTION(0x070, 0x070, 0x010,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* IRAM */
+	X_ARM_MMU_SECTION(0x100, 0x100, 0x040,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* SATA */
+	X_ARM_MMU_SECTION(0x180, 0x180, 0x100,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* IPUv3M */
+	X_ARM_MMU_SECTION(0x200, 0x200, 0x200,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* GPU */
+	X_ARM_MMU_SECTION(0x400, 0x400, 0x300,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* periperals */
+	X_ARM_MMU_SECTION(0x700, 0x700, 0x400,
+			ARM_CACHEABLE, ARM_BUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 1G */
+	X_ARM_MMU_SECTION(0x700, 0xB00, 0x400,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CSD0 1G */
+	X_ARM_MMU_SECTION(0xF00, 0xF00, 0x100,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* CS1 EIM control*/
+	X_ARM_MMU_SECTION(0xF7F, 0xF7F, 0x040,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* NAND Flash buffer */
+	X_ARM_MMU_SECTION(0xF80, 0xF80, 0x001,
+			ARM_UNCACHEABLE, ARM_UNBUFFERABLE,
+			ARM_ACCESS_PERM_RW_RW); /* iRam */
+
+	/* Workaround for arm errata #709718 */
+	/* Setup PRRR so device is always mapped to non-shared */
+	asm volatile ("mrc p15, 0, %0, c10, c2, 0" : "=r"(i) : /*:*/);
+	i &= (~(3 << 0x10));
+	asm volatile ("mcr p15, 0, %0, c10, c2, 0" : : "r"(i) /*:*/);
+
+	/* Enable MMU */
+	MMU_ON();
+}
+#endif
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
+	return 0;
+}
+
+static void setup_uart(void)
+{
+
+	/* UART1 RXD */
+	mxc_request_iomux(MX53_PIN_CSI0_D11, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D11, 0x1E4);
+	mxc_iomux_set_input(MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT, 0x1);
+
+	/* UART1 TXD */
+	mxc_request_iomux(MX53_PIN_CSI0_D10, IOMUX_CONFIG_ALT2);
+	mxc_iomux_set_pad(MX53_PIN_CSI0_D10, 0x1E4);
+}
+
+#ifdef CONFIG_I2C_MXC
+static void setup_i2c(unsigned int module_base)
+{
+	switch (module_base) {
+	case I2C1_BASE_ADDR:
+		/* i2c1 SDA */
+		mxc_request_iomux(MX53_PIN_CSI0_D8,
+				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SDA_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_CSI0_D8, PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+		/* i2c1 SCL */
+		mxc_request_iomux(MX53_PIN_CSI0_D9,
+				IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C1_IPP_SCL_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_CSI0_D9, PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+		break;
+	case I2C2_BASE_ADDR:
+		/* i2c2 SDA */
+		mxc_request_iomux(MX53_PIN_KEY_ROW3,
+				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_KEY_ROW3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+
+		/* i2c2 SCL */
+		mxc_request_iomux(MX53_PIN_KEY_COL3,
+				IOMUX_CONFIG_ALT4 | IOMUX_CONFIG_SION);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT,
+				INPUT_CTL_PATH0);
+		mxc_iomux_set_pad(MX53_PIN_KEY_COL3,
+				PAD_CTL_SRE_FAST |
+				PAD_CTL_ODE_OPENDRAIN_ENABLE |
+				PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+				PAD_CTL_HYS_ENABLE);
+		break;
+	default:
+		printf("Invalid I2C base: 0x%x\n", module_base);
+		break;
+	}
+}
+
+void setup_core_voltages(void)
+{
+	unsigned char buf[4] = { 0 };
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+
+	/* Set core voltage VDDGP to 1.05V for 800MHZ */
+	buf[0] = 0x45;
+	buf[1] = 0x4a;
+	buf[2] = 0x52;
+	if (i2c_write(0x8, 24, 1, buf, 3))
+		return;
+
+	/* Set DDR voltage VDDA to 1.25V */
+	buf[0] = 0;
+	buf[1] = 0x63;
+	buf[2] = 0x1a;
+	if (i2c_write(0x8, 26, 1, buf, 3))
+		return;
+
+	/* Raise the core frequency to 800MHz */
+	writel(0x0, CCM_BASE_ADDR + CLKCTL_CACRR);
+}
+
+#ifndef CONFIG_MX53_ARM2
+static int __read_adc_channel(unsigned int chan)
+{
+	unsigned char buf[4] = { 0 };
+
+	buf[0] = (0xb0 | ((chan & 0x1) << 3) | ((chan >> 1) & 0x7));
+
+	/* LTC2495 need 410ms delay */
+	udelay(410000);
+
+	if (i2c_write(0x14, chan, 0, &buf[0], 1)) {
+		printf("%s:i2c_write:error\n", __func__);
+		return -1;
+	}
+
+	/* LTC2495 need 410ms delay*/
+	udelay(410000);
+
+	if (i2c_read(0x14, chan, 0, &buf[0], 3)) {
+		printf("%s:i2c_read:error\n", __func__);
+		return -1;
+	}
+
+	return buf[0] << 16 | buf[1] << 8 | buf[2];
+}
+
+static int __lookup_board_id(int adc_val)
+{
+	int id;
+
+	if (adc_val < 0x3FFFC0)
+		id = 0;
+	else if (adc_val < 0x461863)
+		id = 1;
+	else if (adc_val < 0x4C30C4)
+		id = 2;
+	else if (adc_val < 0x524926)
+		id = 3;
+	else if (adc_val < 0x586187)
+		id = 4;
+	else if (adc_val < 0x5E79E9)
+		id = 5;
+	else if (adc_val < 0x64924A)
+		id = 6;
+	else if (adc_val < 0x6AAAAC)
+		id = 7;
+	else if (adc_val < 0x70C30D)
+		id = 8;
+	else if (adc_val < 0x76DB6F)
+		id = 9;
+	else if (adc_val < 0x7CF3D0)
+		id = 10;
+	else if (adc_val < 0x830C32)
+		id = 11;
+	else if (adc_val < 0x892493)
+		id = 12;
+	else if (adc_val < 0x8F3CF5)
+		id = 13;
+	else if (adc_val < 0x955556)
+		id = 14;
+	else if (adc_val < 0x9B6DB8)
+		id = 15;
+	else if (adc_val < 0xA18619)
+		id = 16;
+	else if (adc_val < 0xA79E7B)
+		id = 17;
+	else if (adc_val < 0xADB6DC)
+		id = 18;
+	else if (adc_val < 0xB3CF3E)
+		id = 19;
+	else if (adc_val < 0xB9E79F)
+		id = 20;
+	else if (adc_val <= 0xC00000)
+		id = 21;
+		else
+		return -1;
+
+	return id;
+}
+
+static int __print_board_info(int id0, int id1)
+{
+	int ret = 0;
+
+	switch (id0) {
+	case 21:
+		switch (id1) {
+		case 15:
+			printf("MX53-EVK with DDR2 1GByte RevB\n");
+
+			break;
+		case 18:
+			printf("MX53-EVK with DDR2 2GByte RevA1\n");
+
+			break;
+		case 19:
+			printf("MX53-EVK with DDR2 2GByte RevA2\n");
+			break;
+		default:
+			printf("Unkown board id1:%d\n", id1);
+			ret = -1;
+
+			break;
+		}
+
+		break;
+	case 11:
+		switch (id1) {
+		case 1:
+			printf("MX53 1.5V DDR3 x8 CPU Card, Rev. A\n");
+
+			break;
+		case 11:
+			printf("MX53 1.8V DDR2 x8 CPU Card, Rev. A\n");
+
+			break;
+		default:
+			printf("Unkown board id1:%d\n", id1);
+			ret = -1;
+
+			break;
+		}
+
+		break;
+	default:
+		printf("Unkown board id0:%d\n", id0);
+
+		break;
+	}
+
+	return ret;
+}
+
+static int _identify_board_fix_up(int id0, int id1)
+{
+	int ret = 0;
+
+#ifdef CONFIG_CMD_CLOCK
+	/* For EVK RevB, set DDR to 400MHz */
+	if (id0 == 21 && id1 == 15) {
+		ret = clk_config(CONFIG_REF_CLK_FREQ, 400, PERIPH_CLK);
+		if (ret < 0)
+			return ret;
+
+		ret = clk_config(CONFIG_REF_CLK_FREQ, 400, DDR_CLK);
+		if (ret < 0)
+			return ret;
+
+		/* set up rev #2 for EVK RevB board */
+		setup_board_rev(2);
+	}
+#endif
+	return ret;
+}
+
+int identify_board_id(void)
+{
+	int ret = 0;
+	int bd_id0, bd_id1;
+
+#define CPU_CHANNEL_ID0 0xc
+#define CPU_CHANNEL_ID1 0xd
+
+	ret = bd_id0 = __read_adc_channel(CPU_CHANNEL_ID0);
+	if (ret < 0)
+		return ret;
+
+	ret = bd_id1 = __read_adc_channel(CPU_CHANNEL_ID1);
+	if (ret < 0)
+		return ret;
+
+	ret = bd_id0 = __lookup_board_id(bd_id0);
+	if (ret < 0)
+		return ret;
+
+	ret = bd_id1 = __lookup_board_id(bd_id1);
+	if (ret < 0)
+		return ret;
+
+	ret = __print_board_info(bd_id0, bd_id1);
+	if (ret < 0)
+		return ret;
+
+	ret = _identify_board_fix_up(bd_id0, bd_id1);
+
+	return ret;
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_IMX_ECSPI
+s32 spi_get_cfg(struct imx_spi_dev_t *dev)
+{
+	switch (dev->slave.cs) {
+	case 0:
+		/* pmic */
+		dev->base = CSPI1_BASE_ADDR;
+		dev->freq = 2500000;
+		dev->ss_pol = IMX_SPI_ACTIVE_HIGH;
+		dev->ss = 0;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	case 1:
+		/* spi_nor */
+		dev->base = CSPI1_BASE_ADDR;
+		dev->freq = 2500000;
+		dev->ss_pol = IMX_SPI_ACTIVE_LOW;
+		dev->ss = 1;
+		dev->fifo_sz = 64 * 4;
+		dev->us_delay = 0;
+		break;
+	default:
+		printf("Invalid Bus ID! \n");
+		break;
+	}
+
+	return 0;
+}
+
+void spi_io_init(struct imx_spi_dev_t *dev)
+{
+	switch (dev->base) {
+	case CSPI1_BASE_ADDR:
+		/* Select mux mode: ALT4 mux port: MOSI of instance: ecspi1 */
+		mxc_request_iomux(MX53_PIN_EIM_D18, IOMUX_CONFIG_ALT4);
+		mxc_iomux_set_pad(MX53_PIN_EIM_D18, 0x104);
+		mxc_iomux_set_input(
+				MUX_IN_ECSPI1_IPP_IND_MOSI_SELECT_INPUT, 0x3);
+
+		/* Select mux mode: ALT4 mux port: MISO of instance: ecspi1. */
+		mxc_request_iomux(MX53_PIN_EIM_D17, IOMUX_CONFIG_ALT4);
+		mxc_iomux_set_pad(MX53_PIN_EIM_D17, 0x104);
+		mxc_iomux_set_input(
+				MUX_IN_ECSPI1_IPP_IND_MISO_SELECT_INPUT, 0x3);
+
+		if (dev->ss == 0) {
+			/* de-select SS1 of instance: ecspi1. */
+			mxc_request_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT1);
+			mxc_iomux_set_pad(MX53_PIN_EIM_D19, 0x1E4);
+
+			/* mux mode: ALT4 mux port: SS0 of instance: ecspi1. */
+			mxc_request_iomux(MX53_PIN_EIM_EB2, IOMUX_CONFIG_ALT4);
+			mxc_iomux_set_pad(MX53_PIN_EIM_EB2, 0x104);
+			mxc_iomux_set_input(
+				MUX_IN_ECSPI1_IPP_IND_SS_B_1_SELECT_INPUT, 0x3);
+		} else if (dev->ss == 1) {
+			/* de-select SS0 of instance: ecspi1. */
+			mxc_request_iomux(MX53_PIN_EIM_EB2, IOMUX_CONFIG_ALT1);
+			mxc_iomux_set_pad(MX53_PIN_EIM_EB2, 0x1E4);
+
+			/* mux mode: ALT0 mux port: SS1 of instance: ecspi1. */
+			mxc_request_iomux(MX53_PIN_EIM_D19, IOMUX_CONFIG_ALT4);
+			mxc_iomux_set_pad(MX53_PIN_EIM_D19, 0x104);
+			mxc_iomux_set_input(
+				MUX_IN_ECSPI1_IPP_IND_SS_B_2_SELECT_INPUT, 0x2);
+		}
+
+		/* Select mux mode: ALT0 mux port: SCLK of instance: ecspi1. */
+		mxc_request_iomux(MX53_PIN_EIM_D16, IOMUX_CONFIG_ALT4);
+		mxc_iomux_set_pad(MX53_PIN_EIM_D16, 0x104);
+		mxc_iomux_set_input(
+			MUX_IN_CSPI_IPP_CSPI_CLK_IN_SELECT_INPUT, 0x3);
+
+		break;
+	case CSPI2_BASE_ADDR:
+	default:
+
+		break;
+	}
+}
+#endif
+
+#ifdef CONFIG_MXC_FEC
+
+#ifdef CONFIG_GET_FEC_MAC_ADDR_FROM_IIM
+
+int fec_get_mac_addr(unsigned char *mac)
+{
+	u32 *iim1_mac_base =
+		(u32 *)(IIM_BASE_ADDR + IIM_BANK_AREA_1_OFFSET +
+			CONFIG_IIM_MAC_ADDR_OFFSET);
+	int i;
+
+	for (i = 0; i < 6; ++i, ++iim1_mac_base)
+		mac[i] = (u8)readl(iim1_mac_base);
+
+	return 0;
+}
+#endif
+
+static void setup_fec(void)
+{
+	volatile unsigned int reg;
+
+	/*FEC_MDIO*/
+	mxc_request_iomux(MX53_PIN_FEC_MDIO, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_MDIO, 0x1FC);
+	mxc_iomux_set_input(MUX_IN_FEC_FEC_MDI_SELECT_INPUT, 0x1);
+
+	/*FEC_MDC*/
+	mxc_request_iomux(MX53_PIN_FEC_MDC, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_MDC, 0x004);
+
+	/* FEC RXD1 */
+	mxc_request_iomux(MX53_PIN_FEC_RXD1, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RXD1, 0x180);
+
+	/* FEC RXD0 */
+	mxc_request_iomux(MX53_PIN_FEC_RXD0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RXD0, 0x180);
+
+	 /* FEC TXD1 */
+	mxc_request_iomux(MX53_PIN_FEC_TXD1, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TXD1, 0x004);
+
+	/* FEC TXD0 */
+	mxc_request_iomux(MX53_PIN_FEC_TXD0, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TXD0, 0x004);
+
+	/* FEC TX_EN */
+	mxc_request_iomux(MX53_PIN_FEC_TX_EN, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_TX_EN, 0x004);
+
+	/* FEC TX_CLK */
+	mxc_request_iomux(MX53_PIN_FEC_REF_CLK, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_REF_CLK, 0x180);
+
+	/* FEC RX_ER */
+	mxc_request_iomux(MX53_PIN_FEC_RX_ER, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_RX_ER, 0x180);
+
+	/* FEC CRS */
+	mxc_request_iomux(MX53_PIN_FEC_CRS_DV, IOMUX_CONFIG_ALT0);
+	mxc_iomux_set_pad(MX53_PIN_FEC_CRS_DV, 0x180);
+
+	/* phy reset: gpio7-6 */
+	mxc_request_iomux(MX53_PIN_ATA_DA_0, IOMUX_CONFIG_ALT1);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x0);
+	reg &= ~0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x0);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x4);
+	reg |= 0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x4);
+
+	udelay(500);
+
+	reg = readl(GPIO7_BASE_ADDR + 0x0);
+	reg |= 0x40;
+	writel(reg, GPIO7_BASE_ADDR + 0x0);
+
+}
+#endif
+
+#if defined(CONFIG_MXC_KPD)
+int setup_mxc_kpd(void)
+{
+	mxc_request_iomux(MX53_PIN_KEY_COL0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_COL1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_COL2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_COL3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_COL4, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_GPIO_19,  IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0);
+	mxc_request_iomux(MX53_PIN_KEY_ROW4, IOMUX_CONFIG_ALT0);
+
+	return 0;
+}
+#endif
+
+
+#ifdef CONFIG_CMD_MMC
+
+struct fsl_esdhc_cfg esdhc_cfg[2] = {
+	{MMC_SDHC1_BASE_ADDR, 1, 1},
+	{MMC_SDHC3_BASE_ADDR, 1, 1},
+};
+
+#ifdef CONFIG_DYNAMIC_MMC_DEVNO
+int get_mmc_env_devno()
+{
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	return (soc_sbmr & 0x00300000)  ? 1 : 0;
+}
+#endif
+
+
+int esdhc_gpio_init(bd_t *bis)
+{
+	s32 status = 0;
+	u32 index = 0;
+
+	for (index = 0; index < CONFIG_SYS_FSL_ESDHC_NUM;
+		++index) {
+		switch (index) {
+		case 0:
+			mxc_request_iomux(MX53_PIN_SD1_CMD, IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_CLK, IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA0,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA1,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA2,
+						IOMUX_CONFIG_ALT0);
+			mxc_request_iomux(MX53_PIN_SD1_DATA3,
+						IOMUX_CONFIG_ALT0);
+
+			mxc_iomux_set_pad(MX53_PIN_SD1_CMD, 0x1E4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_CLK, 0xD4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA0, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA1, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA2, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_SD1_DATA3, 0x1D4);
+			break;
+		case 1:
+			mxc_request_iomux(MX53_PIN_ATA_RESET_B,
+						IOMUX_CONFIG_ALT2);
+			mxc_request_iomux(MX53_PIN_ATA_IORDY,
+						IOMUX_CONFIG_ALT2);
+			mxc_request_iomux(MX53_PIN_ATA_DATA8,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA9,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA10,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA11,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA0,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA1,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA2,
+						IOMUX_CONFIG_ALT4);
+			mxc_request_iomux(MX53_PIN_ATA_DATA3,
+						IOMUX_CONFIG_ALT4);
+
+			mxc_iomux_set_pad(MX53_PIN_ATA_RESET_B, 0x1E4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_IORDY, 0xD4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA8, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA9, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA10, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA11, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA0, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA1, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA2, 0x1D4);
+			mxc_iomux_set_pad(MX53_PIN_ATA_DATA3, 0x1D4);
+
+			break;
+		default:
+			printf("Warning: you configured more ESDHC controller"
+				"(%d) as supported by the board(2)\n",
+				CONFIG_SYS_FSL_ESDHC_NUM);
+			return status;
+			break;
+		}
+		status |= fsl_esdhc_initialize(bis, &esdhc_cfg[index]);
+	}
+
+	return status;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	if (!esdhc_gpio_init(bis))
+		return 0;
+	else
+		return -1;
+}
+
+#endif
+
+int board_init(void)
+{
+#ifdef CONFIG_MFG
+/* MFG firmware need reset usb to avoid host crash firstly */
+#define USBCMD 0x140
+	int val = readl(OTG_BASE_ADDR + USBCMD);
+	val &= ~0x1; /*RS bit*/
+	writel(val, OTG_BASE_ADDR + USBCMD);
+#endif
+	setup_boot_device();
+	setup_soc_rev();
+#if defined(CONFIG_MX53_ARM2) || defined(CONFIG_MX53_ARM2_DDR3)
+	setup_board_rev(1);
+#endif
+	gd->bd->bi_arch_number = MACH_TYPE_MX53_EVK;	/* board id for linux */
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
+
+	setup_uart();
+	setup_fec();
+
+#ifdef CONFIG_I2C_MXC
+	setup_i2c(CONFIG_SYS_I2C_PORT);
+	setup_core_voltages();
+#endif
+
+	return 0;
+}
+
+
+#ifdef CONFIG_ANDROID_RECOVERY
+struct reco_envs supported_reco_envs[BOOT_DEV_NUM] = {
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+	{
+	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
+	 .args = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
+	 },
+	{
+	 .cmd = CONFIG_ANDROID_RECOVERY_BOOTCMD_MMC,
+	 .args = CONFIG_ANDROID_RECOVERY_BOOTARGS_MMC,
+	 },
+	{
+	 .cmd = NULL,
+	 .args = NULL,
+	 },
+};
+
+int check_recovery_cmd_file(void)
+{
+	disk_partition_t info;
+	ulong part_length;
+	int filelen;
+	char *env;
+
+	/* For test only */
+	/* When detecting android_recovery_switch,
+	 * enter recovery mode directly */
+	env = getenv("android_recovery_switch");
+	if (!strcmp(env, "1")) {
+		printf("Env recovery detected!\nEnter recovery mode!\n");
+		return 1;
+	}
+
+	printf("Checking for recovery command file...\n");
+	switch (get_boot_device()) {
+	case MMC_BOOT:
+	case SD_BOOT:
+		{
+			block_dev_desc_t *dev_desc = NULL;
+			struct mmc *mmc = find_mmc_device(0);
+
+			dev_desc = get_dev("mmc", 0);
+
+			if (NULL == dev_desc) {
+				puts("** Block device MMC 0 not supported\n");
+				return 0;
+			}
+
+			mmc_init(mmc);
+
+			if (get_partition_info(dev_desc,
+					CONFIG_ANDROID_CACHE_PARTITION_MMC,
+					&info)) {
+				printf("** Bad partition %d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				return 0;
+			}
+
+			part_length = ext2fs_set_blk_dev(dev_desc,
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+			if (part_length == 0) {
+				printf("** Bad partition - mmc 0:%d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				ext2fs_close();
+				return 0;
+			}
+
+			if (!ext2fs_mount(part_length)) {
+				printf("** Bad ext2 partition or "
+					"disk - mmc 0:%d **\n",
+					CONFIG_ANDROID_CACHE_PARTITION_MMC);
+				ext2fs_close();
+				return 0;
+			}
+
+			filelen = ext2fs_open(CONFIG_ANDROID_RECOVERY_CMD_FILE);
+
+			ext2fs_close();
+		}
+		break;
+	case NAND_BOOT:
+		return 0;
+		break;
+	case SPI_NOR_BOOT:
+		return 0;
+		break;
+	case UNKNOWN_BOOT:
+	default:
+		return 0;
+		break;
+	}
+
+	return (filelen > 0) ? 1 : 0;
+
+}
+#endif
+
+int board_late_init(void)
+{
+	return 0;
+}
+
+int checkboard(void)
+{
+	printf("Board: ");
+
+#ifdef CONFIG_MX53_ARM2
+	printf("Board: MX53 ARMADILLO2 ");
+	printf("1.0 [");
+#else
+#ifdef CONFIG_I2C_MXC
+	identify_board_id();
+
+	printf("Boot Reason: [");
+#endif
+#endif
+
+	switch (__REG(SRC_BASE_ADDR + 0x8)) {
+	case 0x0001:
+		printf("POR");
+		break;
+	case 0x0009:
+		printf("RST");
+		break;
+	case 0x0010:
+	case 0x0011:
+		printf("WDOG");
+		break;
+	default:
+		printf("unknown");
+	}
+	printf("]\n");
+
+	printf("Boot Device: ");
+	switch (get_boot_device()) {
+	case WEIM_NOR_BOOT:
+		printf("NOR\n");
+		break;
+	case ONE_NAND_BOOT:
+		printf("ONE NAND\n");
+		break;
+	case PATA_BOOT:
+		printf("PATA\n");
+		break;
+	case SATA_BOOT:
+		printf("SATA\n");
+		break;
+	case I2C_BOOT:
+		printf("I2C\n");
+		break;
+	case SPI_NOR_BOOT:
+		printf("SPI NOR\n");
+		break;
+	case SD_BOOT:
+		printf("SD\n");
+		break;
+	case MMC_BOOT:
+		printf("MMC\n");
+		break;
+	case NAND_BOOT:
+		printf("NAND\n");
+		break;
+	case UNKNOWN_BOOT:
+	default:
+		printf("UNKNOWN\n");
+		break;
+	}
+	return 0;
+}
diff --git a/board/freescale/mx53_rd/u-boot.lds b/board/freescale/mx53_rd/u-boot.lds
new file mode 100644
index 0000000..c6315c9
--- /dev/null
+++ b/board/freescale/mx53_rd/u-boot.lds
@@ -0,0 +1,73 @@
+/*
+ * January 2004 - Changed to support H4 device
+ * Copyright (c) 2004 Texas Instruments
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * (C) Copyright 2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  /* WARNING - the following is hand-optimized to fit within	*/
+	  /* the sector layout of our flash chips!	XXX FIXME XXX	*/
+	  board/freescale/mx53_rd/flash_header.o	(.text.flasheader)
+	  cpu/arm_cortexa8/start.o
+	  board/freescale/mx53_rd/libmx53_rd.a	(.text)
+	  lib_arm/libarm.a		(.text)
+	  net/libnet.a			(.text)
+	  drivers/mtd/libmtd.a		(.text)
+	  drivers/mmc/libmmc.a		(.text)
+
+	  . = DEFINED(env_offset) ? env_offset : .;
+	  common/env_embedded.o(.text)
+
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
-- 
1.5.4.4

